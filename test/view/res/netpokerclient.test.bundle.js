require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],3:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],4:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],5:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":3,"./encode":4}],6:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":2,"querystring":5}],7:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],8:[function(require,module,exports){
var PixiTextInput = require("./src/PixiTextInput");

module.exports = PixiTextInput;
},{"./src/PixiTextInput":9}],9:[function(require,module,exports){
if (typeof module !== 'undefined') {
	PIXI = require("pixi.js");
}

/**
 * Text input field for pixi.js.
 * A simple example:
 *
 *     // We need a container
 *     var container = new PIXI.DisplayObjectContainer();
 *
 *     // Same style options as PIXI.Text
 *     var style={ ... };
 *
 *     var inputField = new PixiTextInput("hello",style);
 *     container.addChild(inputField);
 *
 * The style definitions accepted by the constructor are the same as those accepted by
 * [PIXI.Text](http://www.goodboydigital.com/pixijs/docs/classes/Text.html).
 * @class PixiTextInput
 * @constructor
 * @param {String} [text] The initial text.
 * @param {Object} [style] Style definition, same as for PIXI.Text
 */
function PixiTextInput(text, style) {
	PIXI.DisplayObjectContainer.call(this);

	if (!text)
		text = "";

	text = text.toString();

	if (style && style.wordWrap)
		throw "wordWrap is not supported for input fields";

	this._text = text;

	this.localWidth = 100;
	this._backgroundColor = 0xffffff;
	this._caretColor = 0x000000;
	this._background = true;

	this.style = style;
	this.textField = new PIXI.Text(this._text, style);

	this.localHeight =
		this.textField.determineFontHeight('font: ' + this.textField.style.font + ';') +
		this.textField.style.strokeThickness;
	this.backgroundGraphics = new PIXI.Graphics();
	this.textFieldMask = new PIXI.Graphics();
	this.caret = new PIXI.Graphics();
	this.drawElements();

	this.addChild(this.backgroundGraphics);
	this.addChild(this.textField);
	this.addChild(this.caret);
	this.addChild(this.textFieldMask);

	this.scrollIndex = 0;
	this._caretIndex = 0;
	this.caretFlashInterval = null;
	this.blur();
	this.updateCaretPosition();

	this.backgroundGraphics.interactive = true;
	this.backgroundGraphics.buttonMode = true;
	this.backgroundGraphics.defaultCursor = "text";

	this.backgroundGraphics.mousedown = this.onBackgroundMouseDown.bind(this);
	this.keyEventClosure = this.onKeyEvent.bind(this);
	this.windowBlurClosure = this.onWindowBlur.bind(this);
	this.documentMouseDownClosure = this.onDocumentMouseDown.bind(this);
	this.isFocusClick = false;

	this.updateText();

	this.textField.mask = this.textFieldMask;

	this.keypress = null;
	this.keydown = null;
	this.change = null;
}

PixiTextInput.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
PixiTextInput.prototype.constructor = PixiTextInput;

/**
 * Someone clicked.
 * @method onBackgroundMouseDown
 * @private
 */
PixiTextInput.prototype.onBackgroundMouseDown = function(e) {
	var x = e.getLocalPosition(this).x;
	this._caretIndex = this.getCaretIndexByCoord(x);
	this.updateCaretPosition();

	this.focus();

	this.isFocusClick = true;
	var scope = this;
	setTimeout(function() {
		scope.isFocusClick = false;
	}, 0);
}

/**
 * Focus this input field.
 * @method focus
 */
PixiTextInput.prototype.focus = function() {
	this.blur();

	document.addEventListener("keydown", this.keyEventClosure);
	document.addEventListener("keypress", this.keyEventClosure);
	document.addEventListener("mousedown", this.documentMouseDownClosure);
	window.addEventListener("blur", this.windowBlurClosure);

	this.showCaret();
}

/**
 * Handle key event.
 * @method onKeyEvent
 * @private
 */
PixiTextInput.prototype.onKeyEvent = function(e) {
	/*console.log("key event");
	console.log(e);*/

	if (e.type == "keypress") {
		if (e.charCode < 32)
			return;

		this._text =
			this._text.substring(0, this._caretIndex) +
			String.fromCharCode(e.charCode) +
			this._text.substring(this._caretIndex);

		this._caretIndex++;
		this.ensureCaretInView();
		this.showCaret();
		this.updateText();
		this.trigger(this.keypress, e);
		this.trigger(this.change);
	}

	if (e.type == "keydown") {
		switch (e.keyCode) {
			case 8:
				if (this._caretIndex > 0) {
					this._text =
						this._text.substring(0, this._caretIndex - 1) +
						this._text.substring(this._caretIndex);

					this._caretIndex--;
					this.ensureCaretInView();
					this.showCaret();
					this.updateText();
				}
				e.preventDefault();
				this.trigger(this.change);
				break;

			case 46:
				this._text =
					this._text.substring(0, this._caretIndex) +
					this._text.substring(this._caretIndex + 1);

				this.ensureCaretInView();
				this.updateCaretPosition();
				this.showCaret();
				this.updateText();
				e.preventDefault();
				this.trigger(this.change);
				break;

			case 39:
				this._caretIndex++;
				if (this._caretIndex > this._text.length)
					this._caretIndex = this._text.length;

				this.ensureCaretInView();
				this.updateCaretPosition();
				this.showCaret();
				this.updateText();
				break;

			case 37:
				this._caretIndex--;
				if (this._caretIndex < 0)
					this._caretIndex = 0;

				this.ensureCaretInView();
				this.updateCaretPosition();
				this.showCaret();
				this.updateText();
				break;
		}

		this.trigger(this.keydown, e);
	}
}

/**
 * Ensure the caret is not outside the bounds.
 * @method ensureCaretInView
 * @private
 */
PixiTextInput.prototype.ensureCaretInView = function() {
	this.updateCaretPosition();

	while (this.caret.position.x >= this.localWidth - 1) {
		this.scrollIndex++;
		this.updateCaretPosition();
	}

	while (this.caret.position.x < 0) {
		this.scrollIndex -= 2;
		if (this.scrollIndex < 0)
			this.scrollIndex = 0;
		this.updateCaretPosition();
	}
}

/**
 * Blur ourself.
 * @method blur
 */
PixiTextInput.prototype.blur = function() {
	document.removeEventListener("keydown", this.keyEventClosure);
	document.removeEventListener("keypress", this.keyEventClosure);
	document.removeEventListener("mousedown", this.documentMouseDownClosure);
	window.removeEventListener("blur", this.windowBlurClosure);

	this.hideCaret();
}

/**
 * Window blur.
 * @method onDocumentMouseDown
 * @private
 */
PixiTextInput.prototype.onDocumentMouseDown = function() {
	if (!this.isFocusClick)
		this.blur();
}

/**
 * Window blur.
 * @method onWindowBlur
 * @private
 */
PixiTextInput.prototype.onWindowBlur = function() {
	this.blur();
}

/**
 * Update caret Position.
 * @method updateCaretPosition
 * @private
 */
PixiTextInput.prototype.updateCaretPosition = function() {
	if (this._caretIndex < this.scrollIndex) {
		this.caret.position.x = -1;
		return;
	}

	var sub = this._text.substring(0, this._caretIndex).substring(this.scrollIndex);
	this.caret.position.x = this.textField.context.measureText(sub).width;
}

/**
 * Update text.
 * @method updateText
 * @private
 */
PixiTextInput.prototype.updateText = function() {
	this.textField.setText(this._text.substring(this.scrollIndex));
}

/**
 * Draw the background and caret.
 * @method drawElements
 * @private
 */
PixiTextInput.prototype.drawElements = function() {
	this.backgroundGraphics.clear();
	this.backgroundGraphics.beginFill(this._backgroundColor);

	if (this._background)
		this.backgroundGraphics.drawRect(0, 0, this.localWidth, this.localHeight);

	this.backgroundGraphics.endFill();
	this.backgroundGraphics.hitArea = new PIXI.Rectangle(0, 0, this.localWidth, this.localHeight);

	this.textFieldMask.clear();
	this.textFieldMask.beginFill(this._backgroundColor);
	this.textFieldMask.drawRect(0, 0, this.localWidth, this.localHeight);
	this.textFieldMask.endFill();

	this.caret.clear();
	this.caret.beginFill(this._caretColor);
	this.caret.drawRect(1, 1, 1, this.localHeight - 2);
	this.caret.endFill();
}

/**
 * Show caret.
 * @method showCaret
 * @private
 */
PixiTextInput.prototype.showCaret = function() {
	if (this.caretFlashInterval) {
		clearInterval(this.caretFlashInterval);
		this.caretFlashInterval = null;
	}

	this.caret.visible = true;
	this.caretFlashInterval = setInterval(this.onCaretFlashInterval.bind(this), 500);
}

/**
 * Hide caret.
 * @method hideCaret
 * @private
 */
PixiTextInput.prototype.hideCaret = function() {
	if (this.caretFlashInterval) {
		clearInterval(this.caretFlashInterval);
		this.caretFlashInterval = null;
	}

	this.caret.visible = false;
}

/**
 * Caret flash interval.
 * @method onCaretFlashInterval
 * @private
 */
PixiTextInput.prototype.onCaretFlashInterval = function() {
	this.caret.visible = !this.caret.visible;
}

/**
 * Map position to caret index.
 * @method getCaretIndexByCoord
 * @private
 */
PixiTextInput.prototype.getCaretIndexByCoord = function(x) {
	var smallest = 10000;
	var cand = 0;
	var visible = this._text.substring(this.scrollIndex);

	for (i = 0; i < visible.length + 1; i++) {
		var sub = visible.substring(0, i);
		var w = this.textField.context.measureText(sub).width;

		if (Math.abs(w - x) < smallest) {
			smallest = Math.abs(w - x);
			cand = i;
		}
	}

	return this.scrollIndex + cand;
}

/**
 * The width of the PixiTextInput. This is overridden to have a slightly
 * different behaivour than the other DisplayObjects. Setting the
 * width of the PixiTextInput does not change the scale, but it rather
 * makes the field larger. If you actually want to scale it,
 * use the scale property.
 * @property width
 * @type Number
 */
Object.defineProperty(PixiTextInput.prototype, "width", {
	get: function() {
		return this.scale.x * this.getLocalBounds().width;
	},

	set: function(v) {
		this.localWidth = v;
		this.drawElements();
		this.ensureCaretInView();
		this.updateText();
	}
});

/**
 * The text in the input field. Setting will have the implicit function of resetting the scroll
 * of the input field and removing focus.
 * @property text
 * @type String
 */
Object.defineProperty(PixiTextInput.prototype, "text", {
	get: function() {
		return this._text;
	},

	set: function(v) {
		this._text = v.toString();
		this.scrollIndex = 0;
		this.caretIndex = 0;
		this.blur();
		this.updateText();
	}
});

/**
 * The color of the background for the input field.
 * This needs to be specified as an integer, not using HTML
 * notation, e.g. for red background:
 *
 *     myInputText.backgroundColor = 0xff0000;
 *
 * In order for the background to be drawn, the `background`
 * property needs to be true. If not, this property will have
 * no effect.
 * @property backgroundColor
 * @type Integer
 */
Object.defineProperty(PixiTextInput.prototype, "backgroundColor", {
	get: function() {
		return this._backgroundColor;
	},

	set: function(v) {
		this._backgroundColor = v;
		this.drawElements();
	}
});

/**
 * The color of the caret.
 * @property caretColor
 * @type Integer
 */
Object.defineProperty(PixiTextInput.prototype, "caretColor", {
	get: function() {
		return this._caretColor;
	},

	set: function(v) {
		this._caretColor = v;
		this.drawElements();
	}
});

/**
 * Determines if the background should be drawn behind the text.
 * The color of the background is specified using the backgroundColor
 * property.
 * @property background
 * @type Boolean
 */
Object.defineProperty(PixiTextInput.prototype, "background", {
	get: function() {
		return this._background;
	},

	set: function(v) {
		this._background = v;
		this.drawElements();
	}
});

/**
 * Set text.
 * @method setText
 * @param {String} text The new text.
 */
PixiTextInput.prototype.setText = function(v) {
	this.text = v;
}

/**
 * Trigger an event function if it exists.
 * @method trigger
 * @private
 */
PixiTextInput.prototype.trigger = function(fn, e) {
	if (fn)
		fn(e);
}

if (typeof module !== 'undefined') {
	module.exports = PixiTextInput;
}
},{"pixi.js":"pixi.js"}],10:[function(require,module,exports){
/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/sole/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/sole/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */

// Date.now shim for (ahem) Internet Explo(d|r)er
if ( Date.now === undefined ) {

	Date.now = function () {

		return new Date().valueOf();

	};

}

var TWEEN = TWEEN || ( function () {

	var _tweens = [];

	return {

		REVISION: '14',

		getAll: function () {

			return _tweens;

		},

		removeAll: function () {

			_tweens = [];

		},

		add: function ( tween ) {

			_tweens.push( tween );

		},

		remove: function ( tween ) {

			var i = _tweens.indexOf( tween );

			if ( i !== -1 ) {

				_tweens.splice( i, 1 );

			}

		},

		update: function ( time ) {

			if ( _tweens.length === 0 ) return false;

			var i = 0;

			time = time !== undefined ? time : ( typeof window !== 'undefined' && window.performance !== undefined && window.performance.now !== undefined ? window.performance.now() : Date.now() );

			while ( i < _tweens.length ) {

				if ( _tweens[ i ].update( time ) ) {

					i++;

				} else {

					_tweens.splice( i, 1 );

				}

			}

			return true;

		}
	};

} )();

TWEEN.Tween = function ( object ) {

	var _object = object;
	var _valuesStart = {};
	var _valuesEnd = {};
	var _valuesStartRepeat = {};
	var _duration = 1000;
	var _repeat = 0;
	var _yoyo = false;
	var _isPlaying = false;
	var _reversed = false;
	var _delayTime = 0;
	var _startTime = null;
	var _easingFunction = TWEEN.Easing.Linear.None;
	var _interpolationFunction = TWEEN.Interpolation.Linear;
	var _chainedTweens = [];
	var _onStartCallback = null;
	var _onStartCallbackFired = false;
	var _onUpdateCallback = null;
	var _onCompleteCallback = null;
	var _onStopCallback = null;

	// Set all starting values present on the target object
	for ( var field in object ) {

		_valuesStart[ field ] = parseFloat(object[field], 10);

	}

	this.to = function ( properties, duration ) {

		if ( duration !== undefined ) {

			_duration = duration;

		}

		_valuesEnd = properties;

		return this;

	};

	this.start = function ( time ) {

		TWEEN.add( this );

		_isPlaying = true;

		_onStartCallbackFired = false;

		_startTime = time !== undefined ? time : ( typeof window !== 'undefined' && window.performance !== undefined && window.performance.now !== undefined ? window.performance.now() : Date.now() );
		_startTime += _delayTime;

		for ( var property in _valuesEnd ) {

			// check if an Array was provided as property value
			if ( _valuesEnd[ property ] instanceof Array ) {

				if ( _valuesEnd[ property ].length === 0 ) {

					continue;

				}

				// create a local copy of the Array with the start value at the front
				_valuesEnd[ property ] = [ _object[ property ] ].concat( _valuesEnd[ property ] );

			}

			_valuesStart[ property ] = _object[ property ];

			if( ( _valuesStart[ property ] instanceof Array ) === false ) {
				_valuesStart[ property ] *= 1.0; // Ensures we're using numbers, not strings
			}

			_valuesStartRepeat[ property ] = _valuesStart[ property ] || 0;

		}

		return this;

	};

	this.stop = function () {

		if ( !_isPlaying ) {
			return this;
		}

		TWEEN.remove( this );
		_isPlaying = false;

		if ( _onStopCallback !== null ) {

			_onStopCallback.call( _object );

		}

		this.stopChainedTweens();
		return this;

	};

	this.stopChainedTweens = function () {

		for ( var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++ ) {

			_chainedTweens[ i ].stop();

		}

	};

	this.delay = function ( amount ) {

		_delayTime = amount;
		return this;

	};

	this.repeat = function ( times ) {

		_repeat = times;
		return this;

	};

	this.yoyo = function( yoyo ) {

		_yoyo = yoyo;
		return this;

	};


	this.easing = function ( easing ) {

		_easingFunction = easing;
		return this;

	};

	this.interpolation = function ( interpolation ) {

		_interpolationFunction = interpolation;
		return this;

	};

	this.chain = function () {

		_chainedTweens = arguments;
		return this;

	};

	this.onStart = function ( callback ) {

		_onStartCallback = callback;
		return this;

	};

	this.onUpdate = function ( callback ) {

		_onUpdateCallback = callback;
		return this;

	};

	this.onComplete = function ( callback ) {

		_onCompleteCallback = callback;
		return this;

	};

	this.onStop = function ( callback ) {

		_onStopCallback = callback;
		return this;

	};

	this.update = function ( time ) {

		var property;

		if ( time < _startTime ) {

			return true;

		}

		if ( _onStartCallbackFired === false ) {

			if ( _onStartCallback !== null ) {

				_onStartCallback.call( _object );

			}

			_onStartCallbackFired = true;

		}

		var elapsed = ( time - _startTime ) / _duration;
		elapsed = elapsed > 1 ? 1 : elapsed;

		var value = _easingFunction( elapsed );

		for ( property in _valuesEnd ) {

			var start = _valuesStart[ property ] || 0;
			var end = _valuesEnd[ property ];

			if ( end instanceof Array ) {

				_object[ property ] = _interpolationFunction( end, value );

			} else {

				// Parses relative end values with start as base (e.g.: +10, -3)
				if ( typeof(end) === "string" ) {
					end = start + parseFloat(end, 10);
				}

				// protect against non numeric properties.
				if ( typeof(end) === "number" ) {
					_object[ property ] = start + ( end - start ) * value;
				}

			}

		}

		if ( _onUpdateCallback !== null ) {

			_onUpdateCallback.call( _object, value );

		}

		if ( elapsed == 1 ) {

			if ( _repeat > 0 ) {

				if( isFinite( _repeat ) ) {
					_repeat--;
				}

				// reassign starting values, restart by making startTime = now
				for( property in _valuesStartRepeat ) {

					if ( typeof( _valuesEnd[ property ] ) === "string" ) {
						_valuesStartRepeat[ property ] = _valuesStartRepeat[ property ] + parseFloat(_valuesEnd[ property ], 10);
					}

					if (_yoyo) {
						var tmp = _valuesStartRepeat[ property ];
						_valuesStartRepeat[ property ] = _valuesEnd[ property ];
						_valuesEnd[ property ] = tmp;
					}

					_valuesStart[ property ] = _valuesStartRepeat[ property ];

				}

				if (_yoyo) {
					_reversed = !_reversed;
				}

				_startTime = time + _delayTime;

				return true;

			} else {

				if ( _onCompleteCallback !== null ) {

					_onCompleteCallback.call( _object );

				}

				for ( var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++ ) {

					_chainedTweens[ i ].start( time );

				}

				return false;

			}

		}

		return true;

	};

};


TWEEN.Easing = {

	Linear: {

		None: function ( k ) {

			return k;

		}

	},

	Quadratic: {

		In: function ( k ) {

			return k * k;

		},

		Out: function ( k ) {

			return k * ( 2 - k );

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1 ) return 0.5 * k * k;
			return - 0.5 * ( --k * ( k - 2 ) - 1 );

		}

	},

	Cubic: {

		In: function ( k ) {

			return k * k * k;

		},

		Out: function ( k ) {

			return --k * k * k + 1;

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k;
			return 0.5 * ( ( k -= 2 ) * k * k + 2 );

		}

	},

	Quartic: {

		In: function ( k ) {

			return k * k * k * k;

		},

		Out: function ( k ) {

			return 1 - ( --k * k * k * k );

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1) return 0.5 * k * k * k * k;
			return - 0.5 * ( ( k -= 2 ) * k * k * k - 2 );

		}

	},

	Quintic: {

		In: function ( k ) {

			return k * k * k * k * k;

		},

		Out: function ( k ) {

			return --k * k * k * k * k + 1;

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k * k * k;
			return 0.5 * ( ( k -= 2 ) * k * k * k * k + 2 );

		}

	},

	Sinusoidal: {

		In: function ( k ) {

			return 1 - Math.cos( k * Math.PI / 2 );

		},

		Out: function ( k ) {

			return Math.sin( k * Math.PI / 2 );

		},

		InOut: function ( k ) {

			return 0.5 * ( 1 - Math.cos( Math.PI * k ) );

		}

	},

	Exponential: {

		In: function ( k ) {

			return k === 0 ? 0 : Math.pow( 1024, k - 1 );

		},

		Out: function ( k ) {

			return k === 1 ? 1 : 1 - Math.pow( 2, - 10 * k );

		},

		InOut: function ( k ) {

			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( ( k *= 2 ) < 1 ) return 0.5 * Math.pow( 1024, k - 1 );
			return 0.5 * ( - Math.pow( 2, - 10 * ( k - 1 ) ) + 2 );

		}

	},

	Circular: {

		In: function ( k ) {

			return 1 - Math.sqrt( 1 - k * k );

		},

		Out: function ( k ) {

			return Math.sqrt( 1 - ( --k * k ) );

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1) return - 0.5 * ( Math.sqrt( 1 - k * k) - 1);
			return 0.5 * ( Math.sqrt( 1 - ( k -= 2) * k) + 1);

		}

	},

	Elastic: {

		In: function ( k ) {

			var s, a = 0.1, p = 0.4;
			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( !a || a < 1 ) { a = 1; s = p / 4; }
			else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
			return - ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );

		},

		Out: function ( k ) {

			var s, a = 0.1, p = 0.4;
			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( !a || a < 1 ) { a = 1; s = p / 4; }
			else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
			return ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 );

		},

		InOut: function ( k ) {

			var s, a = 0.1, p = 0.4;
			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( !a || a < 1 ) { a = 1; s = p / 4; }
			else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
			if ( ( k *= 2 ) < 1 ) return - 0.5 * ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );
			return a * Math.pow( 2, -10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) * 0.5 + 1;

		}

	},

	Back: {

		In: function ( k ) {

			var s = 1.70158;
			return k * k * ( ( s + 1 ) * k - s );

		},

		Out: function ( k ) {

			var s = 1.70158;
			return --k * k * ( ( s + 1 ) * k + s ) + 1;

		},

		InOut: function ( k ) {

			var s = 1.70158 * 1.525;
			if ( ( k *= 2 ) < 1 ) return 0.5 * ( k * k * ( ( s + 1 ) * k - s ) );
			return 0.5 * ( ( k -= 2 ) * k * ( ( s + 1 ) * k + s ) + 2 );

		}

	},

	Bounce: {

		In: function ( k ) {

			return 1 - TWEEN.Easing.Bounce.Out( 1 - k );

		},

		Out: function ( k ) {

			if ( k < ( 1 / 2.75 ) ) {

				return 7.5625 * k * k;

			} else if ( k < ( 2 / 2.75 ) ) {

				return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;

			} else if ( k < ( 2.5 / 2.75 ) ) {

				return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;

			} else {

				return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;

			}

		},

		InOut: function ( k ) {

			if ( k < 0.5 ) return TWEEN.Easing.Bounce.In( k * 2 ) * 0.5;
			return TWEEN.Easing.Bounce.Out( k * 2 - 1 ) * 0.5 + 0.5;

		}

	}

};

TWEEN.Interpolation = {

	Linear: function ( v, k ) {

		var m = v.length - 1, f = m * k, i = Math.floor( f ), fn = TWEEN.Interpolation.Utils.Linear;

		if ( k < 0 ) return fn( v[ 0 ], v[ 1 ], f );
		if ( k > 1 ) return fn( v[ m ], v[ m - 1 ], m - f );

		return fn( v[ i ], v[ i + 1 > m ? m : i + 1 ], f - i );

	},

	Bezier: function ( v, k ) {

		var b = 0, n = v.length - 1, pw = Math.pow, bn = TWEEN.Interpolation.Utils.Bernstein, i;

		for ( i = 0; i <= n; i++ ) {
			b += pw( 1 - k, n - i ) * pw( k, i ) * v[ i ] * bn( n, i );
		}

		return b;

	},

	CatmullRom: function ( v, k ) {

		var m = v.length - 1, f = m * k, i = Math.floor( f ), fn = TWEEN.Interpolation.Utils.CatmullRom;

		if ( v[ 0 ] === v[ m ] ) {

			if ( k < 0 ) i = Math.floor( f = m * ( 1 + k ) );

			return fn( v[ ( i - 1 + m ) % m ], v[ i ], v[ ( i + 1 ) % m ], v[ ( i + 2 ) % m ], f - i );

		} else {

			if ( k < 0 ) return v[ 0 ] - ( fn( v[ 0 ], v[ 0 ], v[ 1 ], v[ 1 ], -f ) - v[ 0 ] );
			if ( k > 1 ) return v[ m ] - ( fn( v[ m ], v[ m ], v[ m - 1 ], v[ m - 1 ], f - m ) - v[ m ] );

			return fn( v[ i ? i - 1 : 0 ], v[ i ], v[ m < i + 1 ? m : i + 1 ], v[ m < i + 2 ? m : i + 2 ], f - i );

		}

	},

	Utils: {

		Linear: function ( p0, p1, t ) {

			return ( p1 - p0 ) * t + p0;

		},

		Bernstein: function ( n , i ) {

			var fc = TWEEN.Interpolation.Utils.Factorial;
			return fc( n ) / fc( i ) / fc( n - i );

		},

		Factorial: ( function () {

			var a = [ 1 ];

			return function ( n ) {

				var s = 1, i;
				if ( a[ n ] ) return a[ n ];
				for ( i = n; i > 1; i-- ) s *= i;
				return a[ n ] = s;

			};

		} )(),

		CatmullRom: function ( p0, p1, p2, p3, t ) {

			var v0 = ( p2 - p0 ) * 0.5, v1 = ( p3 - p1 ) * 0.5, t2 = t * t, t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

		}

	}

};

module.exports=TWEEN;
},{}],11:[function(require,module,exports){
/**
 * AS3/jquery style event dispatcher. Slightly modified. The
 * jquery style on/off/trigger style of adding listeners is
 * currently the preferred one.
 *
 * The on method for adding listeners takes an extra parameter which is the
 * scope in which listeners should be called. So this:
 *
 *     object.on("event", listener, this);
 *
 * Has the same function when adding events as:
 *
 *     object.on("event", listener.bind(this));
 *
 * However, the difference is that if we use the second method it
 * will not be possible to remove the listeners later, unless
 * the closure created by bind is stored somewhere. If the
 * first method is used, we can remove the listener with:
 *
 *     object.off("event", listener, this);
 *
 * @class EventDispatcher
 */
function EventDispatcher() {
	this.listenerMap = {};
}

/**
 * Add event listener.
 * @method addEventListener
 */
EventDispatcher.prototype.addEventListener = function(eventType, listener, scope) {
	if (!this.listenerMap)
		this.listenerMap = {};

	if (!eventType)
		throw new Error("Event type required for event dispatcher");

	if (!listener)
		throw new Error("Listener required for event dispatcher");

	this.removeEventListener(eventType, listener, scope);

	if (!this.listenerMap.hasOwnProperty(eventType))
		this.listenerMap[eventType] = [];

	this.listenerMap[eventType].push({
		listener: listener,
		scope: scope
	});
}

/**
 * Remove event listener.
 * @method removeEventListener
 */
EventDispatcher.prototype.removeEventListener = function(eventType, listener, scope) {
	if (!this.listenerMap)
		this.listenerMap = {};

	if (!this.listenerMap.hasOwnProperty(eventType))
		return;

	var listeners = this.listenerMap[eventType];

	for (var i = 0; i < listeners.length; i++) {
		var listenerObj = listeners[i];

		if (listener == listenerObj.listener && scope == listenerObj.scope) {
			listeners.splice(i, 1);
			i--;
		}
	}

	if (!listeners.length)
		delete this.listenerMap[eventType];
}

/**
 * Dispatch event.
 * @method dispatchEvent
 */
EventDispatcher.prototype.dispatchEvent = function(event /* ... */ ) {
	if (!this.listenerMap)
		this.listenerMap = {};

	var eventType;
	var listenerParams;

	if (typeof event == "string") {
		eventType = event;

		if (arguments.length > 1)
			listenerParams = Array.prototype.slice.call(arguments, 1);

		else listenerParams = [{
			type: eventType,
			target: this
		}];
	} else {
		eventType = event.type;
		event.target = this;
		listenerParams = [event];
	}

	if (!this.listenerMap.hasOwnProperty(eventType))
		return;

	var map = [];
	for (var i = 0; i < this.listenerMap[eventType].length; i++)
		map.push(this.listenerMap[eventType][i])

	for (var i = 0; i < map.length; i++) {
		var listenerObj = map[i];
		listenerObj.listener.apply(listenerObj.scope, listenerParams);
	}
}

/**
 * Jquery style alias for addEventListener
 * @method on
 */
EventDispatcher.prototype.on = EventDispatcher.prototype.addEventListener;

/**
 * Jquery style alias for removeEventListener
 * @method off
 */
EventDispatcher.prototype.off = EventDispatcher.prototype.removeEventListener;

/**
 * Jquery style alias for dispatchEvent
 * @method trigger
 */
EventDispatcher.prototype.trigger = EventDispatcher.prototype.dispatchEvent;

/**
 * Make something an event dispatcher. Can be used for multiple inheritance.
 * @method init
 * @static
 */
EventDispatcher.init = function(cls) {
	cls.prototype.addEventListener = EventDispatcher.prototype.addEventListener;
	cls.prototype.removeEventListener = EventDispatcher.prototype.removeEventListener;
	cls.prototype.dispatchEvent = EventDispatcher.prototype.dispatchEvent;
	cls.prototype.on = EventDispatcher.prototype.on;
	cls.prototype.off = EventDispatcher.prototype.off;
	cls.prototype.trigger = EventDispatcher.prototype.trigger;
}

if (typeof module !== 'undefined') {
	module.exports = EventDispatcher;
}
},{}],12:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var ShowDialogMessage = require("../../proto/messages/ShowDialogMessage");
var ButtonsMessage = require("../../proto/messages/ButtonsMessage");
var ChatMessage = require("../../proto/messages/ChatMessage");
var TableInfoMessage = require("../../proto/messages/TableInfoMessage");
var HandInfoMessage = require("../../proto/messages/HandInfoMessage");
var PresetButtonsMessage = require("../../proto/messages/PresetButtonsMessage");
var InterfaceStateMessage = require("../../proto/messages/InterfaceStateMessage");
var CheckboxMessage = require("../../proto/messages/CheckboxMessage");
var PreTournamentInfoMessage = require("../../proto/messages/PreTournamentInfoMessage");

/**
 * Control user interface.
 * @class InterfaceController
 */
function InterfaceController(messageSequencer, view) {
	this.messageSequencer = messageSequencer;
	this.view = view;

	this.messageSequencer.addMessageHandler(ButtonsMessage.TYPE, this.onButtonsMessage, this);
	this.messageSequencer.addMessageHandler(ShowDialogMessage.TYPE, this.onShowDialogMessage, this);
	this.messageSequencer.addMessageHandler(ChatMessage.TYPE, this.onChat, this);
	this.messageSequencer.addMessageHandler(TableInfoMessage.TYPE, this.onTableInfoMessage, this);
	this.messageSequencer.addMessageHandler(HandInfoMessage.TYPE, this.onHandInfoMessage, this);
	this.messageSequencer.addMessageHandler(InterfaceStateMessage.TYPE, this.onInterfaceStateMessage, this);
	this.messageSequencer.addMessageHandler(CheckboxMessage.TYPE, this.onCheckboxMessage, this);
	this.messageSequencer.addMessageHandler(PreTournamentInfoMessage.TYPE, this.onPreTournamentInfoMessage, this);

	this.messageSequencer.addMessageHandler(PresetButtonsMessage.TYPE, this.onPresetButtons, this);
}

/**
 * Buttons message.
 * @method onButtonsMessage
 */
InterfaceController.prototype.onButtonsMessage = function(m) {
	var buttonsView = this.view.getButtonsView();

	buttonsView.setButtons(m.getButtons(), m.sliderButtonIndex, parseInt(m.min, 10), parseInt(m.max, 10));
}

/**
 * PresetButtons message.
 * @method onPresetButtons
 */
InterfaceController.prototype.onPresetButtons = function(m) {
	var presetButtonsView = this.view.getPresetButtonsView();

	var buttons = presetButtonsView.getButtons();
	for (var i = 0; i < buttons.length; i++) {
		if (i > m.buttons.length) {
			buttons[i].hide();
		} else {
			var data = m.buttons[i];

			if (data == null) {
				buttons[i].hide();
			} else {
				buttons[i].show(data.button, data.value);
			}
		}
	}

	presetButtonsView.setCurrent(m.current);
}

/**
 * Show dialog.
 * @method onShowDialogMessage
 */
InterfaceController.prototype.onShowDialogMessage = function(m) {
	var dialogView = this.view.getDialogView();

	dialogView.show(m.getText(), m.getButtons(), m.getDefaultValue());
}


/**
 * On chat message.
 * @method onChat
 */
InterfaceController.prototype.onChat = function(m) {
	this.view.chatView.addText(m.user, m.text);
}

/**
 * Handle table info message.
 * @method onTableInfoMessage
 */
InterfaceController.prototype.onTableInfoMessage = function(m) {
	var tableInfoView = this.view.getTableInfoView();

	tableInfoView.setTableInfoText(m.getText());
	tableInfoView.setJoinButtonVisible(m.getShowJoinButton());
	tableInfoView.setLeaveButtonVisible(m.getShowLeaveButton());
}

/**
 * Handle hand info message.
 * @method onHandInfoMessage
 */
InterfaceController.prototype.onHandInfoMessage = function(m) {
	var tableInfoView = this.view.getTableInfoView();

	tableInfoView.setHandInfoText(m.getText());
}

/**
 * Handle interface state message.
 * @method onInterfaceStateMessage
 */
InterfaceController.prototype.onInterfaceStateMessage = function(m) {
	var settingsView = this.view.getSettingsView();

	settingsView.setVisibleButtons(m.getVisibleButtons());
}

/**
 * Handle checkbox message.
 * @method onCheckboxMessage
 */
InterfaceController.prototype.onCheckboxMessage = function(m) {
	console.log(m);

	var settingsView = this.view.getSettingsView();

	settingsView.setCheckboxChecked(m.getId(), m.getChecked());
}

/**
 * Handle pre torunament info message.
 * @method onPreTournamentInfoMessage
 */
InterfaceController.prototype.onPreTournamentInfoMessage = function(m) {
	var tableInfoView = this.view.getTableInfoView();

	tableInfoView.setPreTournamentInfoText(m.getText());
}

module.exports = InterfaceController;
},{"../../proto/messages/ButtonsMessage":46,"../../proto/messages/ChatMessage":47,"../../proto/messages/CheckboxMessage":48,"../../proto/messages/HandInfoMessage":55,"../../proto/messages/InterfaceStateMessage":57,"../../proto/messages/PreTournamentInfoMessage":61,"../../proto/messages/PresetButtonsMessage":63,"../../proto/messages/ShowDialogMessage":66,"../../proto/messages/TableInfoMessage":70}],13:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var EventDispatcher = require("yaed");
var Sequencer = require("../../utils/Sequencer");
var inherits=require("inherits");

/**
 * An item in a message sequence.
 * @class MessageSequenceItem
 */
function MessageSequenceItem(message) {
	EventDispatcher.call(this);
	this.message = message;
	this.waitTarget = null;
	this.waitEvent = null;
	this.waitClosure = null;
}

inherits(MessageSequenceItem, EventDispatcher);

/**
 * Get message.
 * @method getMessage
 */
MessageSequenceItem.prototype.getMessage = function() {
	//console.log("getting: " + this.message.type);

	return this.message;
}

/**
 * Are we waiting for an event?
 * @method isWaiting
 */
MessageSequenceItem.prototype.isWaiting = function() {
	return this.waitEvent != null;
}

/**
 * Notify complete.
 * @method notifyComplete
 */
MessageSequenceItem.prototype.notifyComplete = function() {
	this.trigger(Sequencer.COMPLETE);
}

/**
 * Wait for event before processing next message.
 * @method waitFor
 */
MessageSequenceItem.prototype.waitFor = function(target, event) {
	this.waitTarget = target;
	this.waitEvent = event;
	this.waitClosure = this.onTargetComplete.bind(this);

	this.waitTarget.addEventListener(this.waitEvent, this.waitClosure);
}

/**
 * Wait target complete.
 * @method onTargetComplete
 * @private
 */
MessageSequenceItem.prototype.onTargetComplete = function() {
	//console.log("target is complete");
	this.waitTarget.removeEventListener(this.waitEvent, this.waitClosure);
	this.notifyComplete();
}

module.exports = MessageSequenceItem;
},{"../../utils/Sequencer":79,"inherits":7,"yaed":11}],14:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var Sequencer = require("../../utils/Sequencer");
var EventDispatcher = require("yaed");
var MessageSequenceItem = require("./MessageSequenceItem");

/**
 * Sequences messages.
 * @class MessageSequencer
 */
function MessageSequencer() {
	this.sequencer = new Sequencer();
	this.messageDispatcher = new EventDispatcher();
	this.currentItem = null;
}

/**
 * Add a message for procesing.
 * @method enqueue
 */
MessageSequencer.prototype.enqueue = function(message) {
	if (!message.type)
		throw "Message doesn't have a type";

	var sequenceItem = new MessageSequenceItem(message);

	sequenceItem.on(Sequencer.START, this.onSequenceItemStart, this);

	this.sequencer.enqueue(sequenceItem);
}

/**
 * Sequence item start.
 * @method onSequenceItemStart
 * @private
 */
MessageSequencer.prototype.onSequenceItemStart = function(e) {
	//console.log("starting item...");
	var item = e.target;

	item.off(Sequencer.START, this.onSequenceItemStart, this);

	this.currentItem = item;
	this.messageDispatcher.trigger(item.getMessage());
	this.currentItem = null;

	if (!item.isWaiting())
		item.notifyComplete();
}

/**
 * Add message handler.
 * @method addMessageHandler
 */
MessageSequencer.prototype.addMessageHandler = function(messageType, handler, scope) {
	this.messageDispatcher.on(messageType, handler, scope);
}

/**
 * Wait for the target to dispatch an event before continuing to
 * process the messages in the que.
 * @method waitFor
 */
MessageSequencer.prototype.waitFor = function(target, event) {
	if (!this.currentItem)
		throw "Not waiting for event";

	this.currentItem.waitFor(target, event);
}

module.exports = MessageSequencer;
},{"../../utils/Sequencer":79,"./MessageSequenceItem":13,"yaed":11}],15:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var MessageSequencer = require("./MessageSequencer");
var ProtoConnection = require("../../proto/ProtoConnection");
var ButtonsView = require("../view/ButtonsView");
var ButtonClickMessage = require("../../proto/messages/ButtonClickMessage");
var SeatClickMessage = require("../../proto/messages/SeatClickMessage");
var PresetButtonClickMessage = require("../../proto/messages/PresetButtonClickMessage");
var NetPokerClientView = require("../view/NetPokerClientView");
var DialogView = require("../view/DialogView");
var TableInfoView = require("../view/TableInfoView");
var SettingsView = require("../view/SettingsView");
var TableController = require("./TableController");
var InterfaceController = require("./InterfaceController");
var ChatMessage = require("../../proto/messages/ChatMessage");
var CheckboxMessage = require("../../proto/messages/CheckboxMessage");
var ButtonData = require("../../proto/data/ButtonData");
var PresetButtonsView = require("../view/PresetButtonsView");

/**
 * Main controller
 * @class NetPokerClientController
 */
function NetPokerClientController(view) {
	this.netPokerClientView = view;
	this.protoConnection = null;
	this.messageSequencer = new MessageSequencer();

	this.tableController = new TableController(this.messageSequencer, this.netPokerClientView);
	this.interfaceController = new InterfaceController(this.messageSequencer, this.netPokerClientView);

	//console.log(this.netPokerClientView.getDialogView());

	this.netPokerClientView.getButtonsView().on(ButtonsView.BUTTON_CLICK, this.onButtonClick, this);
	this.netPokerClientView.getTableInfoView().on(TableInfoView.BUTTON_CLICK, this.onButtonClick, this);
	this.netPokerClientView.getDialogView().on(DialogView.BUTTON_CLICK, this.onButtonClick, this);
	this.netPokerClientView.on(NetPokerClientView.SEAT_CLICK, this.onSeatClick, this);

	this.netPokerClientView.chatView.addEventListener("chat", this.onViewChat, this);
	this.netPokerClientView.settingsView.addEventListener(SettingsView.BUY_CHIPS_CLICK, this.onBuyChipsButtonClick, this);
	this.netPokerClientView.settingsView.addEventListener(SettingsView.CHECKBOX_CHANGE, this.onCheckboxChange, this);

	this.netPokerClientView.getPresetButtonsView().addEventListener(PresetButtonsView.CHANGE, this.onPresetButtonsChange, this);
}


/**
 * Set connection.
 * @method setProtoConnection
 */
NetPokerClientController.prototype.setProtoConnection = function(protoConnection) {
	if (this.protoConnection) {
		this.protoConnection.off(ProtoConnection.MESSAGE, this.onProtoConnectionMessage, this);
	}

	this.protoConnection = protoConnection;
	this.netPokerClientView.clear();

	if (this.protoConnection) {
		this.protoConnection.on(ProtoConnection.MESSAGE, this.onProtoConnectionMessage, this);
	}
}

/**
 * Incoming message.
 * Enqueue for processing.
 * @method onProtoConnectionMessage
 * @private
 */
NetPokerClientController.prototype.onProtoConnectionMessage = function(e) {
	this.messageSequencer.enqueue(e.message);
}

/**
 * Button click.
 * This function handles clicks from both the dialog and game play buttons.
 * @method onButtonClick
 * @private
 */
NetPokerClientController.prototype.onButtonClick = function(e) {
	if (!this.protoConnection)
		return;

	console.log("button click, v=" + e.value);

	var m = new ButtonClickMessage(e.button, e.value);
	this.protoConnection.send(m);
}

/**
 * Seat click.
 * @method onSeatClick
 * @private
 */
NetPokerClientController.prototype.onSeatClick = function(e) {
	var m = new SeatClickMessage(e.seatIndex);
	this.protoConnection.send(m);
}

/**
 * On send chat message.
 * @method onViewChat
 */
NetPokerClientController.prototype.onViewChat = function(e) {
	var message = new ChatMessage();
	message.user = "";
	message.text = e.text;

	this.protoConnection.send(message);
}

/**
 * On buy chips button click.
 * @method onBuyChipsButtonClick
 */
NetPokerClientController.prototype.onBuyChipsButtonClick = function() {
	console.log("buy chips click");

	this.protoConnection.send(new ButtonClickMessage(ButtonData.BUY_CHIPS));
}

/**
 * PresetButtons change message.
 * @method onPresetButtonsChange
 */
NetPokerClientController.prototype.onPresetButtonsChange = function() {
	var presetButtonsView = this.netPokerClientView.getPresetButtonsView();
	var message = new PresetButtonClickMessage();

	var c = presetButtonsView.getCurrent();
	if (c != null) {
		message.button = c.id;
		message.value = c.value;
	}

	this.protoConnection.send(message);
}

/**
 * Checkbox change.
 * @method onCheckboxChange
 */
NetPokerClientController.prototype.onCheckboxChange = function(ev) {
	this.protoConnection.send(new CheckboxMessage(ev.checkboxId, ev.checked));
}

module.exports = NetPokerClientController;
},{"../../proto/ProtoConnection":39,"../../proto/data/ButtonData":40,"../../proto/messages/ButtonClickMessage":45,"../../proto/messages/ChatMessage":47,"../../proto/messages/CheckboxMessage":48,"../../proto/messages/PresetButtonClickMessage":62,"../../proto/messages/SeatClickMessage":64,"../view/ButtonsView":20,"../view/DialogView":27,"../view/NetPokerClientView":29,"../view/PresetButtonsView":32,"../view/SettingsView":36,"../view/TableInfoView":37,"./InterfaceController":12,"./MessageSequencer":14,"./TableController":16}],16:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var SeatInfoMessage = require("../../proto/messages/SeatInfoMessage");
var CommunityCardsMessage = require("../../proto/messages/CommunityCardsMessage");
var PocketCardsMessage = require("../../proto/messages/PocketCardsMessage");
var DealerButtonMessage = require("../../proto/messages/DealerButtonMessage");
var BetMessage = require("../../proto/messages/BetMessage");
var BetsToPotMessage = require("../../proto/messages/BetsToPotMessage");
var PotMessage = require("../../proto/messages/PotMessage");
var TimerMessage = require("../../proto/messages/TimerMessage");
var ActionMessage = require("../../proto/messages/ActionMessage");
var FoldCardsMessage = require("../../proto/messages/FoldCardsMessage");
var DelayMessage = require("../../proto/messages/DelayMessage");
var EventDispatcher = require("yaed");
var ClearMessage = require("../../proto/messages/ClearMessage");
var PayOutMessage = require("../../proto/messages/PayOutMessage");

/**
 * Control the table
 * @class TableController
 */
function TableController(messageSequencer, view) {
	this.messageSequencer = messageSequencer;
	this.view = view;

	this.messageSequencer.addMessageHandler(SeatInfoMessage.TYPE, this.onSeatInfoMessage, this);
	this.messageSequencer.addMessageHandler(CommunityCardsMessage.TYPE, this.onCommunityCardsMessage, this);
	this.messageSequencer.addMessageHandler(PocketCardsMessage.TYPE, this.onPocketCardsMessage, this);
	this.messageSequencer.addMessageHandler(DealerButtonMessage.TYPE, this.onDealerButtonMessage, this);
	this.messageSequencer.addMessageHandler(BetMessage.TYPE, this.onBetMessage, this);
	this.messageSequencer.addMessageHandler(BetsToPotMessage.TYPE, this.onBetsToPot, this);
	this.messageSequencer.addMessageHandler(PotMessage.TYPE, this.onPot, this);
	this.messageSequencer.addMessageHandler(TimerMessage.TYPE, this.onTimer, this);
	this.messageSequencer.addMessageHandler(ActionMessage.TYPE, this.onAction, this);
	this.messageSequencer.addMessageHandler(FoldCardsMessage.TYPE, this.onFoldCards, this);
	this.messageSequencer.addMessageHandler(DelayMessage.TYPE, this.onDelay, this);
	this.messageSequencer.addMessageHandler(ClearMessage.TYPE, this.onClear, this);
	this.messageSequencer.addMessageHandler(PayOutMessage.TYPE, this.onPayOut, this);
}
EventDispatcher.init(TableController);

/**
 * Seat info message.
 * @method onSeatInfoMessage
 */
TableController.prototype.onSeatInfoMessage = function(m) {
	var seatView = this.view.getSeatViewByIndex(m.getSeatIndex());

	seatView.setName(m.getName());
	seatView.setChips(m.getChips());
	seatView.setActive(m.isActive());
	seatView.setSitout(m.isSitout());
}

/**
 * Seat info message.
 * @method onCommunityCardsMessage
 */
TableController.prototype.onCommunityCardsMessage = function(m) {
	var i;

	console.log("got community cards!");
	console.log(m);

	for (i = 0; i < m.getCards().length; i++) {
		var cardData = m.getCards()[i];
		var cardView = this.view.getCommunityCards()[m.getFirstIndex() + i];

		cardView.setCardData(cardData);
		cardView.show(m.animate, i * 500);
	}
	if (m.getCards().length > 0) {
		var cardData = m.getCards()[m.getCards().length - 1];
		var cardView = this.view.getCommunityCards()[m.getFirstIndex() + m.getCards().length - 1];
		if(m.animate)
			this.messageSequencer.waitFor(cardView, "animationDone");
	}
}

/**
 * Pocket cards message.
 * @method onPocketCardsMessage
 */
TableController.prototype.onPocketCardsMessage = function(m) {
	var seatView = this.view.getSeatViewByIndex(m.getSeatIndex());
	var i;

	for (i = 0; i < m.getCards().length; i++) {
		var cardData = m.getCards()[i];
		var cardView = seatView.getPocketCards()[m.getFirstIndex() + i];

		if(m.animate)
			this.messageSequencer.waitFor(cardView, "animationDone");
		cardView.setCardData(cardData);
		cardView.show(m.animate, 10);
	}
}

/**
 * Dealer button message.
 * @method onDealerButtonMessage
 */
TableController.prototype.onDealerButtonMessage = function(m) {
	var dealerButtonView = this.view.getDealerButtonView();

	if (m.seatIndex < 0) {
		dealerButtonView.hide();
	} else {
		this.messageSequencer.waitFor(dealerButtonView, "animationDone");
		dealerButtonView.show(m.getSeatIndex(), m.getAnimate());
	}
};

/**
 * Bet message.
 * @method onBetMessage
 */
TableController.prototype.onBetMessage = function(m) {
	this.view.seatViews[m.seatIndex].betChips.setValue(m.value);
};

/**
 * Bets to pot.
 * @method onBetsToPot
 */
TableController.prototype.onBetsToPot = function(m) {
	var haveChips = false;

	for (var i = 0; i < this.view.seatViews.length; i++)
		if (this.view.seatViews[i].betChips.value > 0)
			haveChips = true;

	if (!haveChips)
		return;

	for (var i = 0; i < this.view.seatViews.length; i++)
		this.view.seatViews[i].betChips.animateIn();

	this.messageSequencer.waitFor(this.view.seatViews[0].betChips, "animationDone");
}

/**
 * Pot message.
 * @method onPot
 */
TableController.prototype.onPot = function(m) {
	this.view.potView.setValues(m.values);
};

/**
 * Timer message.
 * @method onTimer
 */
TableController.prototype.onTimer = function(m) {
	if (m.seatIndex < 0)
		this.view.timerView.hide();

	else {
		this.view.timerView.show(m.seatIndex);
		this.view.timerView.countdown(m.totalTime, m.timeLeft);
	}
};

/**
 * Action message.
 * @method onAction
 */
TableController.prototype.onAction = function(m) {
	if (m.seatIndex == null)
		m.seatIndex = 0;

	this.view.seatViews[m.seatIndex].action(m.action);
};

/**
 * Fold cards message.
 * @method onFoldCards
 */
TableController.prototype.onFoldCards = function(m) {
	this.view.seatViews[m.seatIndex].foldCards();

	this.messageSequencer.waitFor(this.view.seatViews[m.seatIndex], "animationDone");
};

/**
 * Delay message.
 * @method onDelay
 */
TableController.prototype.onDelay = function(m) {
	console.log("delay for  = " + m.delay);


	this.messageSequencer.waitFor(this, "timerDone");
	setTimeout(this.dispatchEvent.bind(this, "timerDone"), m.delay);

};

/**
 * Clear message.
 * @method onClear
 */
TableController.prototype.onClear = function(m) {

	var components = m.getComponents();

	for(var i = 0; i < components.length; i++) {
		switch(components[i]) {
			case ClearMessage.POT: {
				this.view.potView.setValues([]);
				break;
			}
			case ClearMessage.BETS: {
				for(var s = 0; s < this.view.seatViews.length; s++) {
					this.view.seatViews[s].betChips.setValue(0);
				}
				break;
			}
			case ClearMessage.CARDS: {
				for(var s = 0; s < this.view.seatViews.length; s++) {
					for(var c = 0; c < this.view.seatViews[s].pocketCards.length; c++) {
						this.view.seatViews[s].pocketCards[c].hide();
					}
				}

				for(var c = 0; c < this.view.communityCards.length; c++) {
					this.view.communityCards[c].hide();
				}
				break;
			}
			case ClearMessage.CHAT: {
				this.view.chatView.clear();
				break;
			}
		}
	}
}

/**
 * Pay out message.
 * @method onPayOut
 */
TableController.prototype.onPayOut = function(m) {
	for (var i = 0; i < m.values.length; i++)
		this.view.seatViews[i].betChips.setValue(m.values[i]);

	for (var i = 0; i < this.view.seatViews.length; i++)
		this.view.seatViews[i].betChips.animateOut();

	this.messageSequencer.waitFor(this.view.seatViews[0].betChips, "animationDone");
};


module.exports = TableController;
},{"../../proto/messages/ActionMessage":42,"../../proto/messages/BetMessage":43,"../../proto/messages/BetsToPotMessage":44,"../../proto/messages/ClearMessage":49,"../../proto/messages/CommunityCardsMessage":50,"../../proto/messages/DealerButtonMessage":51,"../../proto/messages/DelayMessage":52,"../../proto/messages/FoldCardsMessage":54,"../../proto/messages/PayOutMessage":58,"../../proto/messages/PocketCardsMessage":59,"../../proto/messages/PotMessage":60,"../../proto/messages/SeatInfoMessage":65,"../../proto/messages/TimerMessage":72,"yaed":11}],17:[function(require,module,exports){
module.exports = {
	"tableBackground": "__table.png",
	"seatPlate": "__seatPlate.png",
	"timerBackground": "__timerBackground.png",
	"dealerButton": "__dealerButton.png",
	"cardFrame": "__cardFrame.png",
	"cardBack": "__cardBack.png",
	"suitSymbol0": "__suitSymbol0.png",
	"suitSymbol1": "__suitSymbol1.png",
	"suitSymbol2": "__suitSymbol2.png",
	"suitSymbol3": "__suitSymbol3.png",
	"chip0": "__chip0.png",
	"chip1": "__chip1.png",
	"chip2": "__chip2.png",
	"chip3": "__chip3.png",
	"chip4": "__chip4.png",
	"dividerLine": "__dividerLine.png",
	"framePlate": "__framePlate.png",
	"bigButton": "__bigButton.png",
	"dialogButton": "__dialogButton.png",
	"textScrollbarTrack": "__textScrollbarTrack.png",
	"textScrollbarThumb": "__textScrollbarThumb.png",
	"wrenchIcon": "__wrenchIcon.png",
	"chatBackground": "__chatBackground.png",
	"checkboxBackground": "__checkboxBackground.png",
	"checkboxTick": "__checkboxTick.png",
	"buttonBackground": "__buttonBackground.png",
	"sliderBackground": "__sliderBackground.png",
	"sliderKnob": "__sliderKnob.png",
	"upArrow": "__upArrow.png",

	"chipsColor0": 0x404040,
	"chipsColor1": 0x008000,
	"chipsColor2": 0x808000,
	"chipsColor3": 0x000080,
	"chipsColor4": 0xff0000,

	"communityCardMargin": 1,
	"betAlign": "LCRRRRCLLL",

	"tablePosition": [101, 94],
	"potPosition": [485, 315],

	"timerOffset": [55, -30],
	"communityCardsPosition": [255, 190],

	"seatPosition0": [287, 118],
	"seatPosition1": [483, 112],
	"seatPosition2": [676, 118],
	"seatPosition3": [844, 247],
	"seatPosition4": [817, 413],
	"seatPosition5": [676, 490],
	"seatPosition6": [483, 495],
	"seatPosition7": [287, 490],
	"seatPosition8": [140, 413],
	"seatPosition9": [123, 247],

	"dealerButtonPosition0": [347, 133],
	"dealerButtonPosition1": [395, 133],
	"dealerButtonPosition2": [574, 133],
	"dealerButtonPosition3": [762, 267],
	"dealerButtonPosition4": [715, 358],
	"dealerButtonPosition5": [574, 434],
	"dealerButtonPosition6": [536, 432],
	"dealerButtonPosition7": [351, 432],
	"dealerButtonPosition8": [193, 362],
	"dealerButtonPosition9": [168, 266],

	"betPosition0": [225, 150],
	"betPosition1": [478, 150],
	"betPosition2": [730, 150],
	"betPosition3": [778, 196],
	"betPosition4": [748, 322],
	"betPosition5": [719, 360],
	"betPosition6": [481, 360],
	"betPosition7": [232, 360],
	"betPosition8": [199, 322],
	"betPosition9": [181, 200],

	"bigButtonPosition": [366, 575]
};
},{}],18:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

/**
 * View configuration.
 * @class ViewConfig
 */
function ViewConfig() {
	this.playAnimations = true;
}

/**
 * Should we play animations?
 * @method setPlayAnimations
 */
ViewConfig.prototype.setPlayAnimations = function(value) {
	this.playAnimations = value;
}

/**
 * Should we play animations?
 * @method getPlayAnimations
 */
ViewConfig.prototype.getPlayAnimations = function() {
	return this.playAnimations;
}

/**
 * Scale animation time.
 * @method scaleAnimationTime
 */
ViewConfig.prototype.scaleAnimationTime = function(millis) {
	if (this.playAnimations)
		return millis;

	return 1;
}

module.exports = ViewConfig;
},{}],19:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var Button = require("../../utils/Button");
var inherits = require("inherits");

/**
 * Big button.
 * @class BigButton
 */
function BigButton(resources) {
	Button.call(this);

	this.resources = resources;

	this.bigButtonTexture = this.resources.getTexture("bigButton");

	this.addChild(new PIXI.Sprite(this.bigButtonTexture));

	var style = {
		font: "bold 18px Arial",
		//fill: "#000000"
	};

	this.labelField = new PIXI.Text("[button]", style);
	this.labelField.position.y = 30;
	this.addChild(this.labelField);

	var style = {
		font: "bold 14px Arial"
		//fill: "#000000"
	};

	this.valueField = new PIXI.Text("[value]", style);
	this.valueField.position.y = 50;
	this.addChild(this.valueField);

	this.setLabel("TEST");
	this.setValue(123);
}

inherits(BigButton, Button);

/**
 * Set label for the button.
 * @method setLabel
 */
BigButton.prototype.setLabel = function(label) {
	this.labelField.setText(label);
	this.labelField.updateTransform();
	this.labelField.x = this.bigButtonTexture.width / 2 - this.labelField.width / 2;
}

/**
 * Set value.
 * @method setValue
 */
BigButton.prototype.setValue = function(value) {
	if (!value) {
		this.valueField.visible = false;
		value = "";
	} else {
		this.valueField.visible = true;
	}

	this.valueField.setText(value);
	this.valueField.updateTransform();
	this.valueField.x = this.bigButtonTexture.width / 2 - this.valueField.width / 2;
}

module.exports = BigButton;
},{"../../utils/Button":"Button","inherits":7,"pixi.js":"pixi.js"}],20:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var EventDispatcher = require("yaed");
var Button = require("../../utils/Button");
var Slider = require("../../utils/Slider");
var NineSlice = require("../../utils/NineSlice");
var BigButton = require("./BigButton");
var RaiseShortcutButton = require("./RaiseShortcutButton");
var inherits = require("inherits");

/**
 * Buttons
 * @class ButtonsView
 */
function ButtonsView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);

	this.resources = resources;

	this.buttonHolder = new PIXI.DisplayObjectContainer();
	this.addChild(this.buttonHolder);

	var sliderBackground = new NineSlice(this.resources.getTexture("sliderBackground"), 20, 0, 20, 0);
	sliderBackground.setLocalSize(300,sliderBackground.height);
	//sliderBackground.width = 300;

	var knob = new PIXI.Sprite(this.resources.getTexture("sliderKnob"));

	this.slider = new Slider(sliderBackground, knob);
	var pos = this.resources.getPoint("bigButtonPosition");
	this.slider.position.x = pos.x;
	this.slider.position.y = pos.y - 35;
	this.slider.addEventListener("change", this.onSliderChange, this);
	this.addChild(this.slider);


	this.buttonHolder.position.x = 366;
	this.buttonHolder.position.y = 575;

	this.buttons = [];

	for (var i = 0; i < 3; i++) {
		var button = new BigButton(this.resources);
		button.on(Button.CLICK, this.onButtonClick, this);
		button.position.x = i * 105;
		this.buttonHolder.addChild(button);
		this.buttons.push(button);
	}

	var raiseSprite = new PIXI.Sprite(this.resources.getTexture("sliderKnob"));
	var arrowSprite = new PIXI.Sprite(this.resources.getTexture("upArrow"));
	arrowSprite.position.x = (raiseSprite.width - arrowSprite.width)*0.5 - 0.5;
	arrowSprite.position.y = (raiseSprite.height - arrowSprite.height)*0.5 - 2;
	raiseSprite.addChild(arrowSprite);

	this.raiseMenuButton = new Button(raiseSprite);
	this.raiseMenuButton.addEventListener(Button.CLICK, this.onRaiseMenuButtonClick, this);
	this.raiseMenuButton.position.x = 2*105 + 70;
	this.raiseMenuButton.position.y = -5;
	this.buttonHolder.addChild(this.raiseMenuButton);

	this.raiseMenuButton.visible = false;
	this.createRaiseAmountMenu();

	this.setButtons([], 0, -1, -1);

	this.buttonsDatas = [];
}

inherits(ButtonsView, PIXI.DisplayObjectContainer);
EventDispatcher.init(ButtonsView);

ButtonsView.BUTTON_CLICK = "buttonClick";


/**
 * Create raise amount menu.
 * @method createRaiseAmountMenu
 */
ButtonsView.prototype.createRaiseAmountMenu = function() {
	this.raiseAmountMenu = new PIXI.DisplayObjectContainer();

	this.raiseMenuBackground = new NineSlice(this.resources.getTexture("chatBackground"), 10, 10, 10, 10);
	this.raiseMenuBackground.position.x = 0;
	this.raiseMenuBackground.position.y = 0;
	this.raiseMenuBackground.width = 125;
	this.raiseMenuBackground.height = 220;
	this.raiseAmountMenu.addChild(this.raiseMenuBackground);

	this.raiseAmountMenu.x = 645;
	this.raiseAmountMenu.y = 570 - this.raiseAmountMenu.height;
	this.addChild(this.raiseAmountMenu);

	var styleObject = {
		font: "bold 18px Arial",
	};

	var t = new PIXI.Text("RAISE TO", styleObject);
	t.position.x = (125 - t.width)*0.5;
	t.position.y = 10;
	this.raiseAmountMenu.addChild(t);

	this.raiseShortcutButtons = new Array();

	for(var i = 0; i < 6; i++) {
		var b = new RaiseShortcutButton(this.resources);
		b.addEventListener(Button.CLICK, this.onRaiseShortcutClick, this);
		b.position.x = 10;
		b.position.y = 35 + i*30;

		this.raiseAmountMenu.addChild(b);
		this.raiseShortcutButtons.push(b);
	}

/*
	PixiTextinput should be used.
	this.raiseAmountMenuInput=new TextField();
	this.raiseAmountMenuInput.x=10;
	this.raiseAmountMenuInput.y=40+30*5;
	this.raiseAmountMenuInput.width=105;
	this.raiseAmountMenuInput.height=19;
	this.raiseAmountMenuInput.border=true;
	this.raiseAmountMenuInput.borderColor=0x404040;
	this.raiseAmountMenuInput.background=true;
	this.raiseAmountMenuInput.multiline=false;
	this.raiseAmountMenuInput.type=TextFieldType.INPUT;
	this.raiseAmountMenuInput.addEventListener(Event.CHANGE,onRaiseAmountMenuInputChange);
	this.raiseAmountMenuInput.addEventListener(KeyboardEvent.KEY_DOWN,onRaiseAmountMenuInputKeyDown);
	this.raiseAmountMenu.addChild(this.raiseAmountMenuInput);
	*/

	this.raiseAmountMenu.visible = false;
}

/**
 * Raise amount button.
 * @method onRaiseMenuButtonClick
 */
ButtonsView.prototype.onRaiseShortcutClick = function() {
	/*var b = cast e.target;

	_raiseAmountMenu.visible=false;

	buttons[_sliderIndex].value=b.value;
	_slider.value=(buttons[_sliderIndex].value-_sliderMin)/(_sliderMax-_sliderMin);
	_raiseAmountMenuInput.text=Std.string(buttons[_sliderIndex].value);

	trace("value click: "+b.value);*/
}



/**
 * Raise amount button.
 * @method onRaiseMenuButtonClick
 */
ButtonsView.prototype.onRaiseMenuButtonClick = function() {
	this.raiseAmountMenu.visible = !this.raiseAmountMenu.visible;
/*
	if(this.raiseAmountMenu.visible) {
		this.stage.mousedown = this.onStageMouseDown.bind(this);
		// this.raiseAmountMenuInput.focus();
		// this.raiseAmountMenuInput.SelectAll
	}
	else {
		this.stage.mousedown = null;
	}*/
}

/**
 * Slider change.
 * @method onSliderChange
 */
ButtonsView.prototype.onSliderChange = function() {
	var newValue = Math.round(this.sliderMin + this.slider.getValue()*(this.sliderMax - this.sliderMin));
	this.buttons[this.sliderIndex].setValue(newValue);
	this.buttonDatas[this.sliderIndex].value = newValue;
	console.log("newValue = " + newValue);

	//this.raiseAmountMenuInput.setText(buttons[_sliderIndex].value.toString());
}

/**
 * Show slider.
 * @method showSlider
 */
ButtonsView.prototype.showSlider = function(index, min, max) {
	console.log("showSlider");
	this.sliderIndex = index;
	this.sliderMin = min;
	this.sliderMax = max;

	console.log("this.buttonDatas["+index+"] = " + this.buttonDatas[index].getValue() + ", min = " + min + ", max = " + max);
	this.slider.setValue((this.buttonDatas[index].getValue() - min)/(max - min));
	console.log("this.slider.getValue() = " + this.slider.getValue());
	this.slider.visible = true;
	this.slider.show();
}

/**
 * Clear.
 * @method clear
 */
ButtonsView.prototype.clear = function(buttonDatas) {
	this.setButtons([], 0, -1, -1);
	this.slider.visible = false;
}

/**
 * Set button datas.
 * @method setButtons
 */
ButtonsView.prototype.setButtons = function(buttonDatas, sliderButtonIndex, min, max) {
	this.buttonDatas = buttonDatas;

	for (var i = 0; i < this.buttons.length; i++) {
		var button = this.buttons[i];
		if (i >= buttonDatas.length) {
			button.visible = false;
			continue;
		}

		var buttonData = buttonDatas[i];

		button.visible = true;
		button.setLabel(buttonData.getButtonString());
		button.setValue(buttonData.getValue());

	}

	if((min >= 0) && (max >= 0))
		this.showSlider(sliderButtonIndex, min, max);

	this.buttonHolder.position.x = 366;

	if (buttonDatas.length < 3)
		this.buttonHolder.position.x += 45;
}

/**
 * Button click.
 * @method onButtonClick
 * @private
 */
ButtonsView.prototype.onButtonClick = function(e) {
	var buttonIndex = -1;

	for (var i = 0; i < this.buttons.length; i++) {
		this.buttons[i].visible = false;
		if (e.target == this.buttons[i])
			buttonIndex = i;
	}

	this.slider.visible = false;

	//console.log("button click: " + buttonIndex);
	var buttonData = this.buttonDatas[buttonIndex];

	this.trigger({
		type: ButtonsView.BUTTON_CLICK,
		button: buttonData.getButton(),
		value: buttonData.getValue()
	});
}

module.exports = ButtonsView;
},{"../../utils/Button":"Button","../../utils/NineSlice":"NineSlice","../../utils/Slider":80,"./BigButton":19,"./RaiseShortcutButton":33,"inherits":7,"pixi.js":"pixi.js","yaed":11}],21:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var inherits = require("inherits");

/**
 * The front view of a card.
 * @class CardFrontView
 */
function CardFrontView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);

	this.resources = resources;
};
inherits(CardFrontView, PIXI.DisplayObjectContainer);


CardFrontView.prototype.setCardData = function(cardData) {
	this.cardData = cardData;

	// cardDiamonds2 cardDiamonds3 cardDiamonds4 cardDiamonds5 ...  cardDiamondsQ  cardDiamondsK  cardDiamondsA
	var cardTexture;
	var customName = "card" + this.cardData.getLongSuitString() + this.cardData.getCardValueString();

	if (this.resources.keyExists(customName))
		cardTexture = this.resources.getTexture(customName);

	if (cardTexture) {
		this.frame = new PIXI.Sprite(cardTexture);
		this.addChild(this.frame);
	} else {
		this.frame = new PIXI.Sprite(this.resources.getTexture("cardFrame"));
		this.addChild(this.frame);


		this.suit = new PIXI.Sprite(this.resources.getTexture("suitSymbol" + this.cardData.getSuitIndex()));
		this.suit.position.x = 8;
		this.suit.position.y = 25;
		this.addChild(this.suit);

		var style = {
			font: "bold 16px Arial"
		};

		this.valueField = new PIXI.Text("[val]", style);
		this.addChild(this.valueField);
		this.valueField.style.fill = this.cardData.getColor();

		this.valueField.setText(this.cardData.getCardValueString());
		this.valueField.updateTransform();
		this.valueField.position.x = 17 - this.valueField.canvas.width / 2;
		this.valueField.position.y = 5;

		this.suit.setTexture(this.resources.getTexture("suitSymbol" + this.cardData.getSuitIndex()));
	}
};



module.exports = CardFrontView;
},{"inherits":7,"pixi.js":"pixi.js"}],22:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var CardFrontView = require("./CardFrontView");
var EventDispatcher = require("yaed");
var inherits = require("inherits");

/**
 * A card view.
 * @class CardView
 */
function CardView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);
	this.targetPosition = null;

	this.viewConfig = viewConfig;
	this.resources = resources;


	this.front = new CardFrontView(this.viewConfig, this.resources);//PIXI.Sprite(this.resources.getTexture("cardFrame"));
	this.addChild(this.front);
/*
	this.suit = new PIXI.Sprite(this.resources.getTexture("suitSymbol" + 0));
	this.suit.position.x = 8;
	this.suit.position.y = 25;
	this.addChild(this.suit);
*/
/*	var style = {
		font: "bold 16px Arial"
	};

	this.valueField = new PIXI.Text("[val]", style);
	this.valueField.position.x = 6;
	this.valueField.position.y = 5;
	this.addChild(this.valueField);
*/
	this.back = new PIXI.Sprite(this.resources.getTexture("cardBack"));
	this.addChild(this.back);


	this.maskGraphics = new PIXI.Graphics();
	this.maskGraphics.beginFill(0x000000);
	this.maskGraphics.drawRect(0, 0, this.back.width, this.back.height);
	this.maskGraphics.endFill();
	this.addChild(this.maskGraphics);

	this.mask = this.maskGraphics;
}

inherits(CardView, PIXI.DisplayObjectContainer);
EventDispatcher.init(CardView);

/**
 * Set card data.
 * @method setCardData
 */
CardView.prototype.setCardData = function(cardData) {
	this.cardData = cardData;


	if (this.cardData.isShown()) {
		/*
		this.back.visible = false;
		this.frame.visible = true;
*/
/*
		this.valueField.style.fill = this.cardData.getColor();

		this.valueField.setText(this.cardData.getCardValueString());
		this.valueField.updateTransform();
		this.valueField.position.x = 17 - this.valueField.canvas.width / 2;

		this.suit.setTexture(this.resources.getTexture("suitSymbol" + this.cardData.getSuitIndex()));
		*/
		this.front.setCardData(this.cardData);

		this.maskGraphics.beginFill(0x000000);
		this.maskGraphics.drawRect(0, 0, this.front.width, this.front.height);
		this.maskGraphics.endFill();
	}
	this.back.visible = true;
	this.front.visible = false;
}

/**
 * Set card data.
 * @method setCardData
 */
CardView.prototype.setTargetPosition = function(point) {
	this.targetPosition = point;

	this.position.x = point.x;
	this.position.y = point.y;
}

/**
 * Hide.
 * @method hide
 */
CardView.prototype.hide = function() {
	this.visible = false;
}

/**
 * Show.
 * @method show
 */
CardView.prototype.show = function(animate, delay) {
	/*if(delay == undefined)
		delay = 1;
	*/
	this.maskGraphics.scale.y = 1;
	this.position.x = this.targetPosition.x;
	this.position.y = this.targetPosition.y;
	if (!animate) {
		this.visible = true;
		this.onShowComplete();
		return;
	}
	this.mask.height = this.height;

	var destination = {
		x: this.position.x,
		y: this.position.y
	};
	this.position.x = (this.parent.width - this.width) * 0.5;
	this.position.y = -this.height;

	var diffX = this.position.x - destination.x;
	var diffY = this.position.y - destination.y;
	var diff = Math.sqrt(diffX * diffX + diffY * diffY);

	var tween = new TWEEN.Tween(this.position)
		//            .delay(delay)
		.to({
			x: destination.x,
			y: destination.y
		}, this.viewConfig.scaleAnimationTime(500))
		.easing(TWEEN.Easing.Quadratic.Out)
		.onStart(this.onShowStart.bind(this))
		.onComplete(this.onShowComplete.bind(this))
		.start();
}

/**
 * Show complete.
 * @method onShowComplete
 */
CardView.prototype.onShowStart = function() {
	this.visible = true;
}

/**
 * Show complete.
 * @method onShowComplete
 */
CardView.prototype.onShowComplete = function() {
	if (this.cardData.isShown()) {
		this.back.visible = false;
		this.front.visible = true;
	}
	this.dispatchEvent("animationDone", this);
}

/**
 * Fold.
 * @method fold
 */
CardView.prototype.fold = function() {
	var o = {
		x: this.targetPosition.x,
		y: this.targetPosition.y + 80
	};

	var time = this.viewConfig.scaleAnimationTime(500);
	this.t0 = new TWEEN.Tween(this.position)
		.to(o, time)
		.easing(TWEEN.Easing.Quadratic.Out)
		.onUpdate(this.onFoldUpdate.bind(this))
		.onComplete(this.onFoldComplete.bind(this))
		.start();
}

/**
 * Fold animation update.
 * @method onFoldUpdate
 */
CardView.prototype.onFoldUpdate = function(progress) {
	this.maskGraphics.scale.y = 1 - progress;
}

/**
 * Fold animation complete.
 * @method onFoldComplete
 */
CardView.prototype.onFoldComplete = function() {
	this.dispatchEvent("animationDone");
}

module.exports = CardView;
},{"./CardFrontView":21,"inherits":7,"pixi.js":"pixi.js","tween.js":10,"yaed":11}],23:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var NineSlice = require("../../utils/NineSlice");
var Slider = require("../../utils/Slider");
var PixiTextInput = require("pixitextinput");
var MouseOverGroup = require("../../utils/MouseOverGroup");
var EventDispatcher = require("yaed");
var inherits = require("inherits");

/**
 * Chat view.
 * @class ChatView
 */
function ChatView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);

	this.resources = resources;
	this.margin = 5;

	
	var chatPlate = new NineSlice(this.resources.getTexture("framePlate"), 10);
	chatPlate.position.x = 10;
	chatPlate.position.y = 540;
	chatPlate.setLocalSize(330, 130);
	this.addChild(chatPlate);

	var s = new NineSlice(this.resources.getTexture("framePlate"), 10);
	s.position.x = 10;
	s.position.y = 675;
	s.setLocalSize(330, 35);
	this.addChild(s);

	var styleObject = {
		font: "12px Arial",
		wordWrapWidth: 310,
		height: 114,
		border: true,
		color: 0xFFFFFF,
		borderColor: 0x404040,
		wordWrap: true,
		multiline: true
	};

	this.container = new PIXI.DisplayObjectContainer();
	this.addChild(this.container);
	this.container.position.x = 20;
	this.container.position.y = 548;

	this.chatMask = new PIXI.Graphics();
	this.chatMask.beginFill(123);
	this.chatMask.drawRect(0, 0, 310, 114);
	this.chatMask.endFill();
	this.container.addChild(this.chatMask);

	this.chatText = new PIXI.Text("", styleObject);
	this.container.addChild(this.chatText);
	this.chatText.mask = this.chatMask;



	var styleObject = {
		font: "14px Arial",
		width: 310,
		height: 19,
		border: true,
		borderColor: 0x404040,
		background: true,
		multiline: true
	};
	this.inputField = new PixiTextInput("", styleObject);
	this.inputField.position.x = this.container.position.x;
	this.inputField.position.y = 683;
	this.inputField.width = 310;
	this.inputField.keydown = this.onKeyDown.bind(this);

	var inputShadow = new PIXI.Graphics();
	inputShadow.beginFill(0x000000);
	inputShadow.drawRect(-1, -1, 311, 20);
	inputShadow.position.x = this.inputField.position.x;
	inputShadow.position.y = this.inputField.position.y;
	this.addChild(inputShadow);

	var inputBackground = new PIXI.Graphics();
	inputBackground.beginFill(0xFFFFFF);
	inputBackground.drawRect(0, 0, 310, 19);
	inputBackground.position.x = this.inputField.position.x;
	inputBackground.position.y = this.inputField.position.y;
	this.addChild(inputBackground);

	this.addChild(this.inputField);



	var slideBack = new NineSlice(this.resources.getTexture("textScrollbarTrack"), 10, 0, 10, 0);
	slideBack.width = 107;
	var slideKnob = new NineSlice(this.resources.getTexture("textScrollbarThumb"), 10, 0, 10, 0);
	slideKnob.width = 30;


	this.slider = new Slider(slideBack, slideKnob);
	this.slider.rotation = Math.PI*0.5;
	this.slider.position.x = 326;
	this.slider.position.y = 552;
	this.slider.setValue(1);
	this.slider.visible = false;
	this.slider.addEventListener("change", this.onSliderChange.bind(this));
	this.addChild(this.slider);


	this.mouseOverGroup = new MouseOverGroup();
	this.mouseOverGroup.addDisplayObject(this.chatText);
	this.mouseOverGroup.addDisplayObject(this.slider);
	this.mouseOverGroup.addDisplayObject(this.chatMask);
	this.mouseOverGroup.addDisplayObject(chatPlate);
	this.mouseOverGroup.addEventListener("mouseover", this.onChatFieldMouseOver, this);
	this.mouseOverGroup.addEventListener("mouseout", this.onChatFieldMouseOut, this);
	this.mouseOverGroup.addEventListener("mousedown", this.onChatFieldMouseDown, this);
	this.mouseOverGroup.addEventListener("mouseup", this.onChatFieldMouseUp, this);

	chatPlate.touchstart = this.onChatFieldMouseDown.bind(this);


	this.clear();
}

inherits(ChatView, PIXI.DisplayObjectContainer);
EventDispatcher.init(ChatView);



/**
 * Clear messages.
 * @method clear
 */
ChatView.prototype.clear = function() {
	this.chatText.setText("");
 	this.chatText.y = -Math.round(this.slider.getValue()*(this.chatText.height + this.margin - this.chatMask.height ));
	this.slider.setValue(1);
}


/**
 *  Add text.
 * @method clear
 */
ChatView.prototype.addText = function(user, text) {
	this.chatText.setText(this.chatText.text + user + ": " + text + "\n");
 	this.chatText.y = -Math.round(this.slider.getValue()*(this.chatText.height + this.margin - this.chatMask.height ));
	this.slider.setValue(1);
}

/**
 * On slider value change
 * @method onSliderChange
 */
 ChatView.prototype.onSliderChange = function() {
 	this.chatText.y = -Math.round(this.slider.getValue()*(this.chatText.height + this.margin - this.chatMask.height));
 }


/**
 * On mouse over
 * @method onChatFieldMouseOver
 */
 ChatView.prototype.onChatFieldMouseOver = function() {
	this.slider.show();
 }


/**
 * On mouse out
 * @method onChatFieldMouseOut
 */
 ChatView.prototype.onChatFieldMouseOut = function() {
	this.slider.hide();
 }

/**
 * On mouse down
 * @method onChatFieldMouseDown
 */
ChatView.prototype.onChatFieldMouseDown = function(interaction_object) {
	interaction_object.target.touchend = interaction_object.target.touchendoutside = this.onChatFieldMouseUp.bind(this);
	interaction_object.target.touchmove = this.onChatFieldMouseMove.bind(this);
	this.startMousePos = interaction_object.global.y;
	this.startPos = this.chatText.y;
	this.slider.show();
}

/**
 * On mouse up
 * @method onChatFieldMouseUp
 */
ChatView.prototype.onChatFieldMouseUp = function(interaction_object) {
	interaction_object.target.touchend = interaction_object.target.touchendoutside = null;
	interaction_object.target.touchmove = null;
	this.slider.hide();
}

/**
 * On mouse up
 * @method onChatFieldMouseUp
 */
ChatView.prototype.onChatFieldMouseMove = function(interaction_object) {
	var pos = interaction_object.global.y;
	var diff = pos - this.startMousePos;

	this.slider.setValue((-(this.startPos + diff)) / (this.chatText.height + this.margin - this.chatMask.height));
 	this.onSliderChange();
}

/**
 * On key down
 * @method onKeyDown
 */
 ChatView.prototype.onKeyDown = function(event) {
	if(event.keyCode == 13) {
		this.dispatchEvent("chat", {text: this.inputField.text});
		
		this.inputField.setText("");
		
	}
 }



module.exports = ChatView;

},{"../../utils/MouseOverGroup":77,"../../utils/NineSlice":"NineSlice","../../utils/Slider":80,"inherits":7,"pixi.js":"pixi.js","pixitextinput":8,"yaed":11}],24:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var EventDispatcher = require("yaed");
var inherits = require("inherits");

/**
 * A chips view.
 * @class ChipsView
 */
function ChipsView(viewConfig, resources, showToolTip) {
	PIXI.DisplayObjectContainer.call(this);
	this.targetPosition = null;

	this.viewConfig = viewConfig;
	this.resources = resources;

	this.align = "left";

	this.value = 0;

	this.denominations = [500000, 100000, 25000, 5000, 1000, 500, 100, 25, 5, 1];

	this.stackClips = new Array();
	this.holder = new PIXI.DisplayObjectContainer();
	this.addChild(this.holder);

	this.toolTip = null;

	if (showToolTip) {
		this.toolTip = new ToolTip();
		this.addChild(this.toolTip);
	}

}

inherits(ChipsView, PIXI.DisplayObjectContainer);
EventDispatcher.init(ChipsView);

/**
 * Set alignment.
 * @method setCardData
 */
ChipsView.prototype.setAlignment = function(align) {
	if (!align)
		throw new Error("unknown alignment: " + align);

	this.align = align;
}

/**
 * Set target position.
 * @method setTargetPosition
 */
ChipsView.prototype.setTargetPosition = function(position) {
	//console.log("setting target position: " + JSON.stringify(position));

	this.targetPosition = position;
	this.position.x = position.x;
	this.position.y = position.y;
}

/**
 * Set value.
 * @method setValue
 */
ChipsView.prototype.setValue = function(value) {
	this.value = value;

	var sprite;

	for (var i = 0; i < this.stackClips.length; i++)
		this.holder.removeChild(this.stackClips[i]);

	this.stackClips = new Array();

	if (this.toolTip != null)
		this.toolTip.text = "Bet: " + this.value.toString();

	var i;
	var stackClip = null;
	var stackPos = 0;
	var chipPos = 0;

	for (i = 0; i < this.denominations.length; i++) {
		var denomination = this.denominations[i];

		chipPos = 0;
		stackClip = null;
		while (value >= denomination) {
			if (stackClip == null) {
				stackClip = new PIXI.DisplayObjectContainer();
				stackClip.x = stackPos;
				stackPos += 40;
				this.holder.addChild(stackClip);
				this.stackClips.push(stackClip);
			}
			var texture = this.resources.getTexture("chip" + (i % 5));
			var chip = new PIXI.Sprite(texture);
			chip.position.y = chipPos;
			chipPos -= 5;
			stackClip.addChild(chip);
			value -= denomination;

			var denominationString;

			if (denomination >= 1000)
				denominationString = Math.round(denomination / 1000) + "K";

			else
				denominationString = denomination;

			if ((stackClip != null) && (value < denomination)) {

				var textField = new PIXI.Text(denominationString, {
					font: "bold 12px Arial",
					align: "center",
					fill: this.resources.getColor("chipsColor" + (i % 5))
				});
				textField.position.x = (stackClip.width - textField.width) * 0.5;
				textField.position.y = chipPos + 11;
				textField.alpha = 0.5;
				/*
				textField.width = stackClip.width - 1;
				textField.height = 20;*/

				stackClip.addChild(textField);
			}
		}
	}

	switch (this.align) {
		case "left":
		case "L":
			this.holder.x = 0;
			break;

		case "center":
		case "C":
			this.holder.x = -this.holder.width / 2;
			break;

		case "right":
		case "R":
			this.holder.x = -this.holder.width;
			break;

		default:
			throw new Error("unknown align: " + this.align);
	}
}

/**
 * Hide.
 * @method hide
 */
ChipsView.prototype.hide = function() {
	this.visible = false;
}

/**
 * Show.
 * @method show
 */
ChipsView.prototype.show = function() {
	this.visible = true;

	var destination = {
		x: this.targetPosition.x,
		y: this.targetPosition.y
	};
	this.position.x = (this.parent.width - this.width) * 0.5;
	this.position.y = -this.height;

	var diffX = this.position.x - destination.x;
	var diffY = this.position.y - destination.y;
	var diff = Math.sqrt(diffX * diffX + diffY * diffY);

	var tween = new TWEEN.Tween(this.position)
		.to({
			x: destination.x,
			y: destination.y
		}, 3 * diff)
		.easing(TWEEN.Easing.Quadratic.Out)
		.onComplete(this.onShowComplete.bind(this))
		.start();
}

/**
 * Show complete.
 * @method onShowComplete
 */
ChipsView.prototype.onShowComplete = function() {

	this.dispatchEvent("animationDone", this);
}

/**
 * Animate in.
 * @method animateIn
 */
ChipsView.prototype.animateIn = function() {
	var o = {
		y: this.resources.getPoint("potPosition").y
	};

	switch (this.align) {
		case "left":
		case "L":
			o.x = this.resources.getPoint("potPosition").x - this.width / 2;
			break;

		case "center":
		case "C":
			o.x = this.resources.getPoint("potPosition").x;
			break;

		case "right":
		case "R":
			o.x = this.resources.getPoint("potPosition").x + this.width / 2;
			break;

		default:
			throw new Error("unknown align: " + this.align);
			break;
	}

	var time = this.viewConfig.scaleAnimationTime(500);
	var tween = new TWEEN.Tween(this)
		.to({
			y: this.resources.getPoint("potPosition").y,
			x: o.x
		}, time)
		.onComplete(this.onInAnimationComplete.bind(this))
		.start();
}

/**
 * In animation complete.
 * @method onInAnimationComplete
 */
ChipsView.prototype.onInAnimationComplete = function() {
	this.setValue(0);

	this.position.x = this.targetPosition.x;
	this.position.y = this.targetPosition.y;

	this.dispatchEvent("animationDone", this);
}

/**
 * Animate out.
 * @method animateOut
 */
ChipsView.prototype.animateOut = function() {
	this.position.y = this.resources.getPoint("potPosition").y;

	switch (this.align) {
		case "left":
		case "L":
			this.position.x = this.resources.getPoint("potPosition").x - this.width / 2;
			break;

		case "center":
		case "C":
			this.position.x = this.resources.getPoint("potPosition").x;
			break;

		case "right":
		case "R":
			this.position.x = this.resources.getPoint("potPosition").x + this.width / 2;
			break;

		default:
			throw new Error("unknown align: " + this.align);
			break;
	}

	var o = {
		x: this.targetPosition.x,
		y: this.targetPosition.y
	};

	var time = this.viewConfig.scaleAnimationTime(500);
	var tween = new TWEEN.Tween(this)
		.to(o, time)
		.onComplete(this.onOutAnimationComplete.bind(this))
		.start();

}

/**
 * Out animation complete.
 * @method onOutAnimationComplete
 */
ChipsView.prototype.onOutAnimationComplete = function() {

	var time = 500;
	var tween = new TWEEN.Tween({
			x: 0
		})
		.to({
			x: 10
		}, time)
		.onComplete(this.onOutWaitAnimationComplete.bind(this))
		.start();

	this.position.x = this.targetPosition.x;
	this.position.y = this.targetPosition.y;

}

/**
 * Out wait animation complete.
 * @method onOutWaitAnimationComplete
 */
ChipsView.prototype.onOutWaitAnimationComplete = function() {

	this.setValue(0);

	this.dispatchEvent("animationDone", this);
}

module.exports = ChipsView;
},{"inherits":7,"pixi.js":"pixi.js","tween.js":10,"yaed":11}],25:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var EventDispatcher = require("yaed");
var inherits = require("inherits");

/**
 * Dialog view.
 * @class DealerButtonView
 */
function DealerButtonView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);

	this.viewConfig = viewConfig;
	this.resources = resources;

	var dealerButtonTexture = this.resources.getTexture("dealerButton");
	this.sprite = new PIXI.Sprite(dealerButtonTexture);
	this.addChild(this.sprite);
	this.hide();
}

inherits(DealerButtonView, PIXI.DisplayObjectContainer);
EventDispatcher.init(DealerButtonView);

/**
 * Set seat index
 * @method setSeatIndex
 */
DealerButtonView.prototype.setSeatIndex = function(seatIndex) {
	this.position.x = this.resources.getPoint("dealerButtonPosition"+seatIndex).x;
	this.position.y = this.resources.getPoint("dealerButtonPosition"+seatIndex).y;
	this.dispatchEvent("animationDone", this);
};

/**
 * Animate to seat index.
 * @method animateToSeatIndex
 */
DealerButtonView.prototype.animateToSeatIndex = function(seatIndex) {
	if (!this.visible) {
		this.setSeatIndex(seatIndex);
		// todo dispatch event that it's complete?
		this.dispatchEvent("animationDone", this);
		return;
	}
	var destination = this.resources.getPoint("dealerButtonPosition"+seatIndex);
	var diffX = this.position.x - destination.x;
	var diffY = this.position.y - destination.y;
	var diff = Math.sqrt(diffX * diffX + diffY * diffY);

	var tween = new TWEEN.Tween(this.position)
		.to({
			x: destination.x,
			y: destination.y
		}, this.viewConfig.scaleAnimationTime(5 * diff))
		.easing(TWEEN.Easing.Quadratic.Out)
		.onComplete(this.onShowComplete.bind(this))
		.start();
};

/**
 * Show Complete.
 * @method onShowComplete
 */
DealerButtonView.prototype.onShowComplete = function() {
	this.dispatchEvent("animationDone", this);
}

/**
 * Hide.
 * @method hide
 */
DealerButtonView.prototype.hide = function() {
	this.visible = false;
}

/**
 * Show.
 * @method show
 */
DealerButtonView.prototype.show = function(seatIndex, animate) {
	if (this.visible && animate) {
		this.animateToSeatIndex(seatIndex);
	} else {
		this.visible = true;
		this.setSeatIndex(seatIndex);
	}
}

module.exports = DealerButtonView;
},{"inherits":7,"pixi.js":"pixi.js","tween.js":10,"yaed":11}],26:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var Button = require("../../utils/Button");
var inherits = require("inherits");

/**
 * Dialog button.
 * @class DialogButton
 */
function DialogButton(resources) {
	Button.call(this);

	this.buttonTexture = resources.getTexture("dialogButton");
	this.addChild(new PIXI.Sprite(this.buttonTexture));

	var style = {
		font: "normal 14px Arial",
		fill: "#ffffff"
	};

	this.textField = new PIXI.Text("[test]", style);
	this.textField.position.y = 15;
	this.addChild(this.textField);

	this.setText("BTN");
}

inherits(DialogButton, Button);

/**
 * Set text for the button.
 * @method setText
 */
DialogButton.prototype.setText = function(text) {
	this.textField.setText(text);
	this.textField.updateTransform();
	this.textField.x = this.buttonTexture.width / 2 - this.textField.width / 2;
}

module.exports = DialogButton;
},{"../../utils/Button":"Button","inherits":7,"pixi.js":"pixi.js"}],27:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var NineSlice = require("../../utils/NineSlice");
var DialogButton = require("./DialogButton");
var ButtonData = require("../../proto/data/ButtonData");
var PixiTextInput = require("pixitextinput");
var EventDispatcher = require("yaed");
var inherits = require("inherits");

/**
 * Dialog view.
 * @class DialogView
 */
function DialogView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);

	this.resources = resources;

	var cover = new PIXI.Graphics();
	cover.beginFill(0x000000, .5);
	cover.drawRect(-1000, -1000, 960 + 2000, 720 + 2000);
	cover.endFill();
	cover.interactive = true;
	//cover.buttonMode = true;
	cover.hitArea = new PIXI.Rectangle(0, 0, 960, 720);
	this.addChild(cover);

	var b = new NineSlice(this.resources.getTexture("framePlate"), 10);
	b.setLocalSize(480, 270);
	b.position.x = 480 - 480 / 2;
	b.position.y = 360 - 270 / 2;
	this.addChild(b);

	style = {
		font: "normal 14px Arial"
	};

	this.textField = new PIXI.Text("[text]", style);
	this.textField.position.x = b.position.x + 20;
	this.textField.position.y = b.position.y + 20;
	this.addChild(this.textField);

	this.buttonsHolder = new PIXI.DisplayObjectContainer();
	this.buttonsHolder.position.y = 430;
	this.addChild(this.buttonsHolder);
	this.buttons = [];

	for (var i = 0; i < 2; i++) {
		var b = new DialogButton(this.resources);

		b.position.x = i * 90;
		b.on("click", this.onButtonClick, this);
		this.buttonsHolder.addChild(b);
		this.buttons.push(b);
	}

	style = {
		font: "normal 18px Arial"
	};

	this.inputField = new PixiTextInput("", style);
	this.inputField.position.x = this.textField.position.x;

	this.inputFrame = new PIXI.Graphics();
	this.inputFrame.beginFill(0x000000);
	this.inputFrame.drawRect(-1, -1, 102, 23);
	this.inputFrame.position.x = this.inputField.position.x;
	this.addChild(this.inputFrame);

	this.addChild(this.inputField);

	this.hide();
}

inherits(DialogView, PIXI.DisplayObjectContainer);
EventDispatcher.init(DialogView);

DialogView.BUTTON_CLICK = "buttonClick";

/**
 * Hide.
 * @method hide
 */
DialogView.prototype.hide = function() {
	this.visible = false;
}

/**
 * Show.
 * @method show
 */
DialogView.prototype.show = function(text, buttonIds, defaultValue) {
	this.visible = true;

	this.buttonIds = buttonIds;

	for (i = 0; i < this.buttons.length; i++) {
		if (i < buttonIds.length) {
			var button = this.buttons[i]
			button.setText(ButtonData.getButtonStringForId(buttonIds[i]));
			button.visible = true;
		} else {
			this.buttons[i].visible = false;
		}
	}

	this.buttonsHolder.x = 480 - buttonIds.length * 90 / 2;
	this.textField.setText(text);

	if (defaultValue) {
		this.inputField.position.y = this.textField.position.y + this.textField.height + 20;
		this.inputFrame.position.y = this.inputField.position.y;
		this.inputField.visible = true;
		this.inputFrame.visible = true;

		this.inputField.text = defaultValue;
		this.inputField.focus();
	} else {
		this.inputField.visible = false;
		this.inputFrame.visible = false;
	}
}

/**
 * Handle button click.
 * @method onButtonClick
 */
DialogView.prototype.onButtonClick = function(e) {
	var buttonIndex = -1;

	for (var i = 0; i < this.buttons.length; i++)
		if (e.target == this.buttons[i])
			buttonIndex = i;

	var value = null;
	if (this.inputField.visible)
		value = this.inputField.text;

	var ev = {
		type: DialogView.BUTTON_CLICK,
		button: this.buttonIds[buttonIndex],
		value: value
	};

	this.trigger(ev);
	this.hide();
}

module.exports = DialogView;
},{"../../proto/data/ButtonData":40,"../../utils/NineSlice":"NineSlice","./DialogButton":26,"inherits":7,"pixi.js":"pixi.js","pixitextinput":8,"yaed":11}],28:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var Gradient = require("../../utils/Gradient");
var inherits = require("inherits");

/**
 * Loading screen.
 * @class LoadingScreen
 */
function LoadingScreen() {
	PIXI.DisplayObjectContainer.call(this);

	var gradient = new Gradient();
	gradient.setSize(100, 100);
	gradient.addColorStop(0, "#ffffff");
	gradient.addColorStop(1, "#c0c0c0");

	var s = gradient.createSprite();
	s.position.x=-1000;
	s.position.y=-1000;
	s.width = 960+2000;
	s.height = 720+2000;
	this.addChild(s);

	var style = {
		font: "bold 20px Arial",
		fill: "#808080"
	};

	this.textField = new PIXI.Text("[text]", style);
	this.textField.position.x = 960 / 2;
	this.textField.position.y = 720 / 2 - this.textField.height / 2;
	this.addChild(this.textField);
}

inherits(LoadingScreen, PIXI.DisplayObjectContainer);

/**
 * Show.
 * @method show
 */
LoadingScreen.prototype.show = function(message) {
	this.textField.setText(message);
	this.textField.updateTransform();
	this.textField.x = 960 / 2 - this.textField.width / 2;
	this.visible = true;
}

/**
 * Hide.
 * @method hide
 */
LoadingScreen.prototype.hide = function() {
	this.visible = false;
}

module.exports = LoadingScreen;
},{"../../utils/Gradient":"Gradient","inherits":7,"pixi.js":"pixi.js"}],29:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var EventDispatcher = require("yaed");
var SeatView = require("./SeatView");
var CardView = require("./CardView");
var ChatView = require("./ChatView");
var Point = require("../../utils/Point");
var Gradient = require("../../utils/Gradient");
var ButtonsView = require("./ButtonsView");
var DialogView = require("./DialogView");
var DealerButtonView = require("./DealerButtonView");
var ChipsView = require("./ChipsView");
var PotView = require("./PotView");
var TimerView = require("./TimerView");
var SettingsView = require("../view/SettingsView");
var TableInfoView = require("../view/TableInfoView");
var PresetButtonsView = require("../view/PresetButtonsView");
var inherits = require("inherits");

/**
 * Net poker client view.
 * @class NetPokerClientView
 */
function NetPokerClientView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);

	this.viewConfig = viewConfig;
	this.resources = resources;
	this.setupBackground();

	this.tableContainer = new PIXI.DisplayObjectContainer();
	this.addChild(this.tableContainer);

	this.tableBackground = new PIXI.Sprite(this.resources.getTexture("tableBackground"));
	this.tableContainer.addChild(this.tableBackground);
	this.tableBackground.position.x = this.resources.getPoint("tablePosition").x;
	this.tableBackground.position.y = this.resources.getPoint("tablePosition").y;

	this.setupSeats();
	this.setupCommunityCards();

	this.timerView = new TimerView(this.viewConfig, this.resources);
	this.tableContainer.addChild(this.timerView);

	this.chatView = new ChatView(this.viewConfig, this.resources);
	this.addChild(this.chatView);

	this.buttonsView = new ButtonsView(this.viewConfig, this.resources);
	this.addChild(this.buttonsView);

	this.dealerButtonView = new DealerButtonView(this.viewConfig, this.resources);
	this.addChild(this.dealerButtonView);

	this.tableInfoView = new TableInfoView(this.viewConfig, this.resources);
	this.addChild(this.tableInfoView);

	this.potView = new PotView(this.viewConfig, this.resources);
	this.addChild(this.potView);
	this.potView.position.x = this.resources.getPoint("potPosition").x;
	this.potView.position.y = this.resources.getPoint("potPosition").y;

	this.settingsView = new SettingsView(this.viewConfig, this.resources);
	this.addChild(this.settingsView);

	this.dialogView = new DialogView(this.viewConfig, this.resources);
	this.addChild(this.dialogView);

	this.presetButtonsView = new PresetButtonsView(this.viewConfig, this.resources);
	this.addChild(this.presetButtonsView);

	this.setupChips();
}

inherits(NetPokerClientView, PIXI.DisplayObjectContainer);
EventDispatcher.init(NetPokerClientView);

NetPokerClientView.SEAT_CLICK = "seatClick";

/**
 * Setup background.
 * @method setupBackground
 */
NetPokerClientView.prototype.setupBackground = function() {
	var g = new PIXI.Graphics();
	g.beginFill(0x05391d, 1);
	g.drawRect(-1000, 0, 960 + 2000, 720);
	g.endFill();
	this.addChild(g);

	var g = new PIXI.Graphics();
	g.beginFill(0x909090, 1);
	g.drawRect(-1000, 720, 960 + 2000, 1000);
	g.endFill();
	this.addChild(g);

	var gradient = new Gradient();
	gradient.setSize(100, 100);
	gradient.addColorStop(0, "#606060");
	gradient.addColorStop(.05, "#a0a0a0");
	gradient.addColorStop(1, "#909090");

	var s = gradient.createSprite();
	s.position.y = 530;
	s.position.x = -1000;
	s.width = 960 + 2000;
	s.height = 190;
	this.addChild(s);

	var s = new PIXI.Sprite(this.resources.getTexture("dividerLine"));
	s.x = 345;
	s.y = 540;
	this.addChild(s);

	var s = new PIXI.Sprite(this.resources.getTexture("dividerLine"));
	s.x = 693;
	s.y = 540;
	this.addChild(s);
}

/**
 * Setup seats.
 * @method serupSeats
 */
NetPokerClientView.prototype.setupSeats = function() {
	var i, j;
	var pocketCards;

	this.seatViews = [];

	for (i = 0; i < 10; i++) {
		var seatView = new SeatView(this.resources, i);
		var p = seatView.position;

		for (j = 0; j < 2; j++) {
			var c = new CardView(this.viewConfig, this.resources);
			c.hide();
			c.setTargetPosition(Point(p.x + j * 30 - 60, p.y - 100));
			this.tableContainer.addChild(c);
			seatView.addPocketCard(c);
			seatView.on("click", this.onSeatClick, this);
		}

		this.tableContainer.addChild(seatView);
		this.seatViews.push(seatView);
	}
}

/**
 * Setup chips.
 * @method serupSeats
 */
NetPokerClientView.prototype.setupChips = function() {
	var i;
	for (i = 0; i < 10; i++) {
		var chipsView = new ChipsView(this.viewConfig, this.resources);
		this.seatViews[i].setBetChipsView(chipsView);

		chipsView.setAlignment(this.resources.getValue("betAlign").charAt(i));
		chipsView.setTargetPosition(this.resources.getPoint("betPosition"+i));
		this.tableContainer.addChild(chipsView);
	}
}

/**
 * Seat click.
 * @method onSeatClick
 * @private
 */
NetPokerClientView.prototype.onSeatClick = function(e) {
	var seatIndex = -1;

	for (var i = 0; i < this.seatViews.length; i++)
		if (e.target == this.seatViews[i])
			seatIndex = i;

	console.log("seat click: " + seatIndex);
	this.trigger({
		type: NetPokerClientView.SEAT_CLICK,
		seatIndex: seatIndex
	});
}

/**
 * Setup community cards.
 * @method setupCommunityCards
 * @private
 */
NetPokerClientView.prototype.setupCommunityCards = function() {
	this.communityCards = [];

	var p = this.resources.getPoint("communityCardsPosition");
	var margin = parseInt(this.resources.getValue("communityCardMargin"));
	for (i = 0; i < 5; i++) {
		var cardView = new CardView(this.viewConfig, this.resources);
		cardView.hide();
		cardView.setTargetPosition(Point(p.x + i * (cardView.back.width + margin), p.y));

		this.communityCards.push(cardView);
		this.tableContainer.addChild(cardView);
	}
}

/**
 * Get seat view by index.
 * @method getSeatViewByIndex
 */
NetPokerClientView.prototype.getSeatViewByIndex = function(index) {
	return this.seatViews[index];
}

/**
 * Get community cards.
 * @method getCommunityCards
 */
NetPokerClientView.prototype.getCommunityCards = function() {
	return this.communityCards;
}

/**
 * Get buttons view.
 * @method getButtonsView
 */
NetPokerClientView.prototype.getButtonsView = function() {
	return this.buttonsView;
}

/**
 * Get preset buttons view.
 * @method presetButtonsView
 */
NetPokerClientView.prototype.getPresetButtonsView = function() {
	return this.presetButtonsView;
}

/**
 * Get dialog view.
 * @method getDialogView
 */
NetPokerClientView.prototype.getDialogView = function() {
	return this.dialogView;
}

/**
 * Get dialog view.
 * @method getDealerButtonView
 */
NetPokerClientView.prototype.getDealerButtonView = function() {
	return this.dealerButtonView;
}

/**
 * Get table info view.
 * @method getTableInfoView
 */
NetPokerClientView.prototype.getTableInfoView = function() {
	return this.tableInfoView;
}

/**
 * Get settings view.
 * @method getSettingsView
 */
NetPokerClientView.prototype.getSettingsView = function() {
	return this.settingsView;
}

/**
 * Clear everything to an empty state.
 * @method clear
 */
NetPokerClientView.prototype.clear = function() {
	var i;

	for (i = 0; i < this.communityCards.length; i++)
		this.communityCards[i].hide();

	for (i = 0; i < this.seatViews.length; i++)
		this.seatViews[i].clear();

	this.timerView.hide();
	this.potView.setValues(new Array());
	this.dealerButtonView.hide();
	this.chatView.clear();

	this.presetButtonsView.hide();

	this.dialogView.hide();
	this.buttonsView.clear();

	this.tableInfoView.clear();
	this.settingsView.clear();
}

module.exports = NetPokerClientView;
},{"../../utils/Gradient":"Gradient","../../utils/Point":78,"../view/PresetButtonsView":32,"../view/SettingsView":36,"../view/TableInfoView":37,"./ButtonsView":20,"./CardView":22,"./ChatView":23,"./ChipsView":24,"./DealerButtonView":25,"./DialogView":27,"./PotView":30,"./SeatView":34,"./TimerView":38,"inherits":7,"pixi.js":"pixi.js","yaed":11}],30:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var EventDispatcher = require("yaed");
var ChipsView = require("./ChipsView");
var inherits = require("inherits");

/**
 * A pot view
 * @class PotView
 */
function PotView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);
	
	this.viewConfig = viewConfig
	this.resources = resources;
	this.value = 0;

	this.holder = new PIXI.DisplayObjectContainer();
	this.addChild(this.holder);

	this.stacks = new Array();
}

inherits(PotView, PIXI.DisplayObjectContainer);
EventDispatcher.init(PotView);

/**
 * Set value.
 * @method setValue
 */
PotView.prototype.setValues = function(values) {
	
	for(var i = 0; i < this.stacks.length; i++)
		this.holder.removeChild(this.stacks[i]);

	this.stacks = new Array();

	var pos = 0;

	for(var i = 0; i < values.length; i++) {
		var chips = new ChipsView(this.viewConfig, this.resources, false);
		this.stacks.push(chips);
		this.holder.addChild(chips);
		chips.setValue(values[i]);
		chips.x = pos;
		pos += Math.floor(chips.width + 20);

		var textField = new PIXI.Text(values[i], {
			font: "bold 12px Arial",
			align: "center",
			fill: "#ffffff"
		});

		textField.position.x = (chips.width - textField.width)*0.5;
		textField.position.y = 30;

		chips.addChild(textField);
	}

	this.holder.x = -this.holder.width*0.5;
}

/**
 * Hide.
 * @method hide
 */
PotView.prototype.hide = function() {
	this.visible = false;
}

/**
 * Show.
 * @method show
 */
PotView.prototype.show = function() {
	this.visible = true;

}

module.exports = PotView;
},{"./ChipsView":24,"inherits":7,"pixi.js":"pixi.js","tween.js":10,"yaed":11}],31:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var EventDispatcher = require("yaed");
var Checkbox = require("../../utils/Checkbox");
var ButtonData = require("../../proto/data/ButtonData");
var inherits = require("inherits");

/**
 * A pot view
 * @class PresetButton
 */
function PresetButton(resources) {
	PIXI.DisplayObjectContainer.call(this);
	
	this.resources = resources;

	this.id = null;
	this.visible = false;
	this.value = 0;

	var b = new PIXI.Sprite(this.resources.getTexture("checkboxBackground"));
	var t = new PIXI.Sprite(this.resources.getTexture("checkboxTick"));
	t.x = 1;

	this.checkbox = new Checkbox(b,t);
	this.checkbox.addEventListener("change", this.onCheckboxChange, this);
	this.addChild(this.checkbox);

	var styleObject = {
		font: "bold 12px Arial",
		wordWrap: true,
		wordWrapWidth: 250,
		fill: "white"
	};

	this.labelField = new PIXI.Text("", styleObject);
	this.labelField.position.x = 25;

	this.addChild(this.labelField);
}

inherits(PresetButton, PIXI.DisplayObjectContainer);
EventDispatcher.init(PresetButton);


PresetButton.CHANGE = "change";

/**
 * Preset button change.
 * @method onPresetButtonChange
 */
PresetButton.prototype.onCheckboxChange = function() {
	this.dispatchEvent(PresetButton.CHANGE);
}

/**
 * Set label.
 * @method setLabel
 */
PresetButton.prototype.setLabel = function(label) {
	this.labelField.setText(label);
	return label;
}

/**
 * Show.
 * @method show
 */
PresetButton.prototype.show = function(id, value) {
	this.id = id;
	this.value = value;

	if(this.value > 0)
		this.setLabel(ButtonData.getButtonStringForId(id)+" ("+this.value+")");

	else
		this.setLabel(ButtonData.getButtonStringForId(id));

	this.visible = true;
}

/**
 * Hide.
 * @method hide
 */
PresetButton.prototype.hide = function() {
	this.id = null;
	this.visible = false;
	this.value = 0;
	this.setChecked(false);
}

/**
 * Get checked.
 * @method getChecked
 */
PresetButton.prototype.getChecked = function() {
	return this.checkbox.getChecked();
}

/**
 * Set checked.
 * @method setChecked
 */
PresetButton.prototype.setChecked = function(b) {
	this.checkbox.setChecked(b);

	return this.checkbox.getChecked();
}

/**
 * Get value.
 * @method getValue
 */
PresetButton.prototype.getValue = function() {
	return this.value;
}

module.exports = PresetButton;
},{"../../proto/data/ButtonData":40,"../../utils/Checkbox":74,"inherits":7,"pixi.js":"pixi.js","tween.js":10,"yaed":11}],32:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var EventDispatcher = require("yaed");
var PresetButton = require("./PresetButton");
var inherits = require("inherits");

/**
 * A pot view
 * @class PresetButtonsView
 */
function PresetButtonsView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);

	this.resources = resources;

	this.buttons = new Array();
	var origin = this.resources.getPoint("bigButtonPosition");

	for (var i = 0; i < 6; i++) {
		var p = new PresetButton(this.resources);
		p.addEventListener(PresetButton.CHANGE, this.onPresetButtonChange, this);
		p.x = origin.x + 30 + 140 * (i % 2);
		p.y = origin.y + 35 * Math.floor(i / 2);
		this.addChild(p);
		this.buttons.push(p);
	}

	this.hide();
}

inherits(PresetButtonsView, PIXI.DisplayObjectContainer);
EventDispatcher.init(PresetButtonsView);

PresetButtonsView.CHANGE = "change";

/**
 * Preset button change.
 * @method onPresetButtonChange
 */
PresetButtonsView.prototype.onPresetButtonChange = function(ev) {

	for (var i = 0; i < this.buttons.length; i++) {
		var b = this.buttons[i];
		if (b != ev.target) {
			b.setChecked(false);
		}
	}

	this.dispatchEvent(PresetButtonsView.CHANGE);
}

/**
 * Hide.
 * @method hide
 */
PresetButtonsView.prototype.hide = function() {
	for (var i = 0; i < this.buttons.length; i++) {
		this.buttons[i].hide();
	}
}

/**
 * Show.
 * @method show
 */
PresetButtonsView.prototype.show = function() {
	this.visible = true;

}

/**
 * Get buttons.
 * @method getButtons
 */
PresetButtonsView.prototype.getButtons = function() {
	return this.buttons;
}

/**
 * Get current preset button.
 * @method getCurrent
 */
PresetButtonsView.prototype.getCurrent = function() {
	for (var i = 0; i < this.buttons.length; i++) {
		if (this.buttons[i].getChecked() == true) {
			return this.buttons[i];
		}
	}
	return null;
}

/**
 * Get current preset button.
 * @method setCurrent
 */
PresetButtonsView.prototype.setCurrent = function(id) {
	for (var i = 0; i < this.buttons.length; i++) {
		var b = this.buttons[i];
		if ((id != null) && (b.id == id)) {
			b.setChecked(true);
		} else {
			b.setChecked(false);
		}
	}
}

module.exports = PresetButtonsView;
},{"./PresetButton":31,"inherits":7,"pixi.js":"pixi.js","tween.js":10,"yaed":11}],33:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var Button = require("../../utils/Button");
var NineSlice = require("../../utils/NineSlice");
var EventDispatcher = require("yaed");
var Checkbox = require("../../utils/Checkbox");
var inherits = require("inherits");

/**
 * Raise shortcut button
 * @class RaiseShortcutButton
 */
function RaiseShortcutButton(resources) {
	var background = new NineSlice(resources.getTexture("buttonBackground"), 10, 5, 10, 5);
	background.setLocalSize(105, 25);
	Button.call(this, background);

	var styleObject = {
		width: 105,
		height: 20,
		font: "bold 14px Arial",
		color: "white"
	};
	this.label = new PIXI.Text("", styleObject);
	this.label.position.x = 8;
	this.label.position.y = 4;
	this.addChild(this.label);
}

inherits(RaiseShortcutButton, Button);
EventDispatcher.init(RaiseShortcutButton);

/**
 * Setter.
 * @method setText
 */
RaiseShortcutButton.prototype.setText = function(string) {
	this.label.setText(string);
	return string;
}

/**
 * Set enabled.
 * @method setEnabled
 */
RaiseShortcutButton.prototype.setEnabled = function(value) {
	if (value) {
		this.alpha = 1;
		this.interactive = true;
		this.buttonMode = true;
	} else {
		this.alpha = 0.5;
		this.interactive = false;
		this.buttonMode = false;
	}
	return value;
}

module.exports = RaiseShortcutButton;
},{"../../utils/Button":"Button","../../utils/Checkbox":74,"../../utils/NineSlice":"NineSlice","inherits":7,"pixi.js":"pixi.js","tween.js":10,"yaed":11}],34:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var Button = require("../../utils/Button");
var inherits = require("inherits");

/**
 * A seat view.
 * @class SeatView
 */
function SeatView(resources, seatIndex) {
	Button.call(this);

	this.pocketCards = [];
	this.resources = resources;
	this.seatIndex = seatIndex;

	var seatTexture = this.resources.getTexture("seatPlate");
	var seatSprite = new PIXI.Sprite(seatTexture);

	seatSprite.position.x = -seatTexture.width / 2;
	seatSprite.position.y = -seatTexture.height / 2;

	this.addChild(seatSprite);

	var pos = this.resources.getPoint("seatPosition" + this.seatIndex);

	this.position.x = pos.x;
	this.position.y = pos.y;

	var style;

	style = {
		font: "bold 20px Arial"
	};

	this.nameField = new PIXI.Text("[name]", style);
	this.nameField.position.y = -20;
	this.addChild(this.nameField);

	style = {
		font: "normal 12px Arial"
	};

	this.chipsField = new PIXI.Text("[name]", style);
	this.chipsField.position.y = 5;
	this.addChild(this.chipsField);

	style = {
		font: "bold 20px Arial"
	};

	this.actionField = new PIXI.Text("action", style);
	this.actionField.position.y = -13;
	this.addChild(this.actionField);
	this.actionField.alpha = 0;

	this.setName("");
	this.setChips("");

	this.betChips = null;
}

inherits(SeatView, Button);

/**
 * Set reference to bet chips.
 * @method setBetChipsView
 */
SeatView.prototype.setBetChipsView = function(value) {
	this.betChips = value;
}

/**
 * Set name.
 * @method setName
 */
SeatView.prototype.setName = function(name) {
	this.nameField.setText(name);
	this.nameField.updateTransform();

	this.nameField.position.x = -this.nameField.canvas.width / 2;
}

/**
 * Set name.
 * @method setChips
 */
SeatView.prototype.setChips = function(chips) {
	this.chipsField.setText(chips);
	this.chipsField.updateTransform();

	this.chipsField.position.x = -this.chipsField.canvas.width / 2;
}

/**
 * Set sitout.
 * @method setSitout
 */
SeatView.prototype.setSitout = function(sitout) {
	if (sitout)
		this.alpha = .5;

	else
		this.alpha = 1;
}

/**
 * Set sitout.
 * @method setActive
 */
SeatView.prototype.setActive = function(active) {
	this.visible = active;
}

/**
 * Add pocket card.
 * @method addPocketCard
 */
SeatView.prototype.addPocketCard = function(cardView) {
	this.pocketCards.push(cardView);
}

/**
 * Get pocket cards.
 * @method getPocketCards
 */
SeatView.prototype.getPocketCards = function() {
	return this.pocketCards;
}

/**
 * Fold cards.
 * @method foldCards
 */
SeatView.prototype.foldCards = function() {
	this.pocketCards[0].addEventListener("animationDone", this.onFoldComplete, this);
	for (var i = 0; i < this.pocketCards.length; i++) {
		this.pocketCards[i].fold();
	}
}

/**
 * Fold complete.
 * @method onFoldComplete
 */
SeatView.prototype.onFoldComplete = function() {
	this.pocketCards[0].removeEventListener("animationDone", this.onFoldComplete, this);
	this.dispatchEvent("animationDone");
}

/**
 * Show user action.
 * @method action
 */
SeatView.prototype.action = function(action) {
	this.actionField.setText(action);
	this.actionField.position.x = -this.actionField.canvas.width / 2;

	this.actionField.alpha = 1;
	this.nameField.alpha = 0;
	this.chipsField.alpha = 0;

	setTimeout(this.onTimer.bind(this), 1000);
}

/**
 * Show user action.
 * @method action
 */
SeatView.prototype.onTimer = function(action) {

	var t1 = new TWEEN.Tween(this.actionField)
		.to({
			alpha: 0
		}, 1000)
		.start();
	var t2 = new TWEEN.Tween(this.nameField)
		.to({
			alpha: 1
		}, 1000)
		.start();
	var t3 = new TWEEN.Tween(this.chipsField)
		.to({
			alpha: 1
		}, 1000)
		.start();

}

/**
 * Clear.
 * @method clear
 */
SeatView.prototype.clear = function() {
	var i;

	this.visible = true;
	this.sitout = false;
	this.betChips.setValue(0);
	this.setName("");
	this.setChips("");

	for (i = 0; i < this.pocketCards.length; i++)
		this.pocketCards[i].hide();
}

module.exports = SeatView;
},{"../../utils/Button":"Button","inherits":7,"pixi.js":"pixi.js","tween.js":10}],35:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var Button = require("../../utils/Button");
var NineSlice = require("../../utils/NineSlice");
var EventDispatcher = require("yaed");
var Checkbox = require("../../utils/Checkbox");
var inherits = require("inherits");

/**
 * Checkboxes view
 * @class SettingsCheckbox
 */
function SettingsCheckbox(resources, id, string) {
 	PIXI.DisplayObjectContainer.call(this);

 	this.resources = resources;
 	this.id = id;

 	var y = 0;

 	var styleObject = {
 		width: 200,
 		height: 25,
 		font: "bold 13px Arial",
 		color: "white"
 	};
 	this.label = new PIXI.Text(string, styleObject);
 	this.label.position.x = 25;
 	this.label.position.y = y + 1;
 	this.addChild(this.label);

 	var background = new PIXI.Sprite(this.resources.getTexture("checkboxBackground"));
 	var tick = new PIXI.Sprite(this.resources.getTexture("checkboxTick"));
 	tick.x = 1;

 	this.checkbox = new Checkbox(background, tick);
 	this.checkbox.position.y = y;
 	this.addChild(this.checkbox);

 	this.checkbox.addEventListener("change", this.onCheckboxChange, this);
}

inherits(SettingsCheckbox, PIXI.DisplayObjectContainer);
EventDispatcher.init(SettingsCheckbox);

/**
 * Checkbox change.
 * @method onCheckboxChange
 */
SettingsCheckbox.prototype.onCheckboxChange = function(interaction_object) {
	this.dispatchEvent("change", this);
}

/**
 * Getter.
 * @method getChecked
 */
SettingsCheckbox.prototype.getChecked = function() {
	return this.checkbox.getChecked();
}

/**
 * Setter.
 * @method setChecked
 */
SettingsCheckbox.prototype.setChecked = function(checked) {
	this.checkbox.setChecked(checked);
	return checked;
}

module.exports = SettingsCheckbox;
},{"../../utils/Button":"Button","../../utils/Checkbox":74,"../../utils/NineSlice":"NineSlice","inherits":7,"pixi.js":"pixi.js","tween.js":10,"yaed":11}],36:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var Button = require("../../utils/Button");
var NineSlice = require("../../utils/NineSlice");
var EventDispatcher = require("yaed");
var SettingsCheckbox = require("./SettingsCheckbox");
var RaiseShortcutButton = require("./RaiseShortcutButton");
var CheckboxMessage = require("../../proto/messages/CheckboxMessage");
var ButtonData = require("../../proto/data/ButtonData");
var inherits = require("inherits");

/**
 * A settings view
 * @class SettingsView
 */
function SettingsView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);

	this.viewConfig = viewConfig;
	this.resources = resources;

	var object = new PIXI.DisplayObjectContainer();
	var bg = new NineSlice(this.resources.getTexture("chatBackground"), 10, 10, 10, 10);
	bg.setLocalSize(30, 30);
	object.addChild(bg);

	var sprite = new PIXI.Sprite(this.resources.getTexture("wrenchIcon"));
	sprite.x = 5;
	sprite.y = 5;
	object.addChild(sprite);

	this.settingsButton = new Button(object);
	this.settingsButton.position.x = 960 - 10 - this.settingsButton.width;
	this.settingsButton.position.y = 543;
	this.settingsButton.addEventListener(Button.CLICK, this.onSettingsButtonClick, this);
	this.addChild(this.settingsButton);

	this.settingsMenu = new PIXI.DisplayObjectContainer();

	var mbg = new NineSlice(this.resources.getTexture("chatBackground"), 10, 10, 10, 10);
	mbg.setLocalSize(250, 100);
	this.settingsMenu.addChild(mbg);

	var styleObject = {
		font: "bold 14px Arial",
		color: "#FFFFFF",
		width: 200,
		height: 20
	};
	var label = new PIXI.Text("Settings", styleObject);
	label.position.x = 16;
	label.position.y = 10;

	this.settingsMenu.addChild(label);
	this.settingsMenu.position.x = 960 - 10 - this.settingsMenu.width;
	this.settingsMenu.position.y = 538 - this.settingsMenu.height;
	this.addChild(this.settingsMenu);

	this.settings = {};

	//console.log("setting up settings, viewconfig=" + this.viewConfig);

	this.createMenuSetting("playAnimations", "Play animations", 40, this.viewConfig.getPlayAnimations());
	this.createMenuSetting(CheckboxMessage.AUTO_MUCK_LOSING, "Muck losing hands", 65);

	this.createSetting(CheckboxMessage.AUTO_POST_BLINDS, "Post blinds", 0);
	this.createSetting(CheckboxMessage.SITOUT_NEXT, "Sit out", 25);

	this.settingsMenu.visible = false;

	this.buyChipsButton = new RaiseShortcutButton(this.resources);
	this.buyChipsButton.addEventListener("click", this.onBuyChipsClick, this);
	this.buyChipsButton.x = 700;
	this.buyChipsButton.y = 635;
	this.buyChipsButton.setText("Buy chips");
	this.addChild(this.buyChipsButton);

	this.buyChipsButton.visible = false;

	// Prevent mouse over from falling through, doesn't work.
	/*this.settingsMenu.interactive = true;
	this.settingsMenu.buttonMode = true;
	this.settingsMenu.mouseover = function() { console.log("test"); };
	this.settingsMenu.mouseout = function() { console.log("test"); };
	this.settingsMenu.mousedown = function() { console.log("test"); };
	this.settingsMenu.mouseup = function() { console.log("test"); };
	this.settingsMenu.click = function() { console.log("test"); };*/
}

inherits(SettingsView, PIXI.DisplayObjectContainer);
EventDispatcher.init(SettingsView);

SettingsView.BUY_CHIPS_CLICK = "buyChipsClick";
SettingsView.CHECKBOX_CHANGE = "checkboxChange";

/**
 * On buy chips button clicked.
 * @method onBuyChipsClick
 */
SettingsView.prototype.onBuyChipsClick = function(interaction_object) {
	console.log("buy chips click");
	this.dispatchEvent(SettingsView.BUY_CHIPS_CLICK);
}

/**
 * Create checkbox.
 * @method createMenuSetting
 */
SettingsView.prototype.createMenuSetting = function(id, string, y, def) {
	var setting = new SettingsCheckbox(this.resources, id, string);

	setting.y = y;
	setting.x = 16;
	this.settingsMenu.addChild(setting);

	setting.addEventListener("change", this.onCheckboxChange, this)

	this.settings[id] = setting;
	setting.setChecked(def);
}

/**
 * Create setting.
 * @method createSetting
 */
SettingsView.prototype.createSetting = function(id, string, y) {
	var setting = new SettingsCheckbox(this.resources, id, string);

	setting.y = 545 + y;
	setting.x = 700;
	this.addChild(setting);

	setting.addEventListener("change", this.onCheckboxChange, this)

	this.settings[id] = setting;
}

/**
 * Checkbox change.
 * @method onCheckboxChange
 */
SettingsView.prototype.onCheckboxChange = function(checkbox) {
	if (checkbox.id == "playAnimations") {
		this.viewConfig.setPlayAnimations(checkbox.getChecked());
		console.log("anims changed..");
	}

	this.dispatchEvent(SettingsView.CHECKBOX_CHANGE, {
		checkboxId: checkbox.id,
		checked: checkbox.getChecked()
	});
}

/**
 * Settings button click.
 * @method onSettingsButtonClick
 */
SettingsView.prototype.onSettingsButtonClick = function(interaction_object) {
	console.log("SettingsView.prototype.onSettingsButtonClick");
	this.settingsMenu.visible = !this.settingsMenu.visible;

	if (this.settingsMenu.visible) {
		this.stage.mousedown = this.stage.touchstart = this.onStageMouseDown.bind(this);
	} else {
		this.stage.mousedown = null;
	}
}

/**
 * Stage mouse down.
 * @method onStageMouseDown
 */
SettingsView.prototype.onStageMouseDown = function(interaction_object) {
	console.log("SettingsView.prototype.onStageMouseDown");
	if ((this.hitTest(this.settingsMenu, interaction_object)) || (this.hitTest(this.settingsButton, interaction_object))) {
		return;
	}

	this.stage.mousedown = null;
	this.settingsMenu.visible = false;
}

/**
 * Hit test.
 * @method hitTest
 */
SettingsView.prototype.hitTest = function(object, interaction_object) {
	if ((interaction_object.global.x > object.getBounds().x) && (interaction_object.global.x < (object.getBounds().x + object.getBounds().width)) &&
		(interaction_object.global.y > object.getBounds().y) && (interaction_object.global.y < (object.getBounds().y + object.getBounds().height))) {
		return true;
	}
	return false;
}

/**
 * Reset.
 * @method clear
 */
SettingsView.prototype.clear = function() {
	this.buyChipsButton.enabled = true;
	this.setVisibleButtons([]);

	this.setCheckboxChecked(CheckboxMessage.AUTO_POST_BLINDS, false);
	this.setCheckboxChecked(CheckboxMessage.AUTO_MUCK_LOSING, false);
	this.setCheckboxChecked(CheckboxMessage.SITOUT_NEXT, false);

	this.settingsMenu.visible = false;
	if (this.settingsMenu.visible)
		this.stage.mousedown = null;
}

/**
 * Set visible buttons.
 * @method setVisibleButtons
 */
SettingsView.prototype.setVisibleButtons = function(buttons) {
	this.buyChipsButton.visible = buttons.indexOf(ButtonData.BUY_CHIPS) != -1;
	this.settings[CheckboxMessage.AUTO_POST_BLINDS].visible = buttons.indexOf(CheckboxMessage.AUTO_POST_BLINDS) >= 0;
	this.settings[CheckboxMessage.SITOUT_NEXT].visible = buttons.indexOf(CheckboxMessage.SITOUT_NEXT) >= 0;

	var yp = 543;

	if (this.buyChipsButton.visible) {
		this.buyChipsButton.y = yp;
		yp += 35;
	} else {
		yp += 2;
	}

	if (this.settings[CheckboxMessage.AUTO_POST_BLINDS].visible) {
		this.settings[CheckboxMessage.AUTO_POST_BLINDS].y = yp;
		yp += 25;
	}

	if (this.settings[CheckboxMessage.SITOUT_NEXT].visible) {
		this.settings[CheckboxMessage.SITOUT_NEXT].y = yp;
		yp += 25;
	}
}

/**
 * Set checkbox state.
 * @method setCheckboxChecked
 */
SettingsView.prototype.setCheckboxChecked = function(id, checked) {
	//console.log("setting checkbox state for: " + id);

	this.settings[id].setChecked(checked);
}

module.exports = SettingsView;
},{"../../proto/data/ButtonData":40,"../../proto/messages/CheckboxMessage":48,"../../utils/Button":"Button","../../utils/NineSlice":"NineSlice","./RaiseShortcutButton":33,"./SettingsCheckbox":35,"inherits":7,"pixi.js":"pixi.js","tween.js":10,"yaed":11}],37:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var EventDispatcher = require("yaed");
var DialogButton = require("./DialogButton");
var inherits = require("inherits");
var ButtonData = require("../../proto/data/ButtonData");

/**
 * Show table info.
 * @class TableInfoView
 */
function TableInfoView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);

	this.viewConfig = viewConfig;
	this.resources = resources;

	var style = {
		font: "bold 24px Times New Roman",
		fill: "#ffffff",
		dropShadow: true,
		dropShadowColor: "#000000",
		dropShadowDistance: 2,
		stroke: "#000000",
		strokeThickness: 2,
		wordWrap: true,
		wordWrapWidth: 300
	};

	this.tableInfoText = new PIXI.Text("<TableInfoText>", style);
	this.tableInfoText.position.x = 355;
	this.tableInfoText.position.y = 540;
	this.addChild(this.tableInfoText);

	var style = {
		font: "bold 24px Times New Roman",
		fill: "#ffffff",
		align: "center"
	};

	this.preTournamentInfoText = new PIXI.Text("<PreTournamentInfoText>", style);
	this.preTournamentInfoText.position.y = 360;
	//this.preTournamentInfoText.position.y = 280;
	this.preTournamentInfoText.position.x = Math.round(960 - 300) / 2;
	this.preTournamentInfoText.alpha = .25;
	this.addChild(this.preTournamentInfoText);

	var style = {
		font: "bold 12px Arial",
		fill: "#ffffff",
		dropShadow: true,
		dropShadowColor: "#000000",
		dropShadowDistance: 1,
		stroke: "#000000",
		strokeThickness: 1,
	};

	this.handInfoText = new PIXI.Text("<HandInfoText>", style);
	this.handInfoText.position.y = 10;
	this.handInfoText.position.x = 960 - this.handInfoText.width;
	this.addChild(this.handInfoText);

	this.joinButton = new DialogButton(this.resources);
	this.joinButton.position.x = 355;
	this.joinButton.setText("JOIN");
	this.joinButton.visible = false;
	this.joinButton.on("click", this.onButtonClick, this);
	this.addChild(this.joinButton);

	this.leaveButton = new DialogButton(this.resources);
	this.leaveButton.position.x = 355;
	this.leaveButton.setText("LEAVE");
	this.leaveButton.visible = false;
	this.leaveButton.on("click", this.onButtonClick, this);
	this.addChild(this.leaveButton);
}

inherits(TableInfoView, PIXI.DisplayObjectContainer);
EventDispatcher.init(TableInfoView);

TableInfoView.BUTTON_CLICK = "buttonClick";

/**
 * Set table info text.
 * @method setTableInfoText
 */
TableInfoView.prototype.setTableInfoText = function(s) {
	if (!s)
		s = "";

	this.tableInfoText.setText(s);
	this.joinButton.position.y = this.tableInfoText.position.y + this.tableInfoText.height + 5;
	this.leaveButton.position.y = this.tableInfoText.position.y + this.tableInfoText.height + 5;
}

/**
 * Set pre tournament info text.
 * @method setPreTournamentInfoText
 */
TableInfoView.prototype.setPreTournamentInfoText = function(s) {
	if (!s)
		s = "";

	this.preTournamentInfoText.setText(s);
	this.preTournamentInfoText.position.x = 960 / 2 - this.preTournamentInfoText.width / 2;
}

/**
 * Join button.
 * @method setJoinButtonVisible
 */
TableInfoView.prototype.setJoinButtonVisible = function(value) {
	this.joinButton.visible = value;
}

/**
 * Join button
 * @method setLeaveButtonVisible
 */
TableInfoView.prototype.setLeaveButtonVisible = function(value) {
	this.leaveButton.visible = value;
}

/**
 * Set hand info text.
 * @method setTableInfoText
 */
TableInfoView.prototype.setHandInfoText = function(s) {
	if (!s)
		s = "";

	this.handInfoText.setText(s);
	this.handInfoText.updateTransform();
	this.handInfoText.position.x = 960 - this.handInfoText.width - 10;
}

/**
 * Clear.
 * @method clear
 */
TableInfoView.prototype.clear = function() {
	this.tableInfoText.setText("");
	this.handInfoText.setText("");
	this.preTournamentInfoText.setText("");
	this.joinButton.visible = false;
	this.leaveButton.visible = false;
}

/**
 * Button click
 * @method onButtonClick
 * @private
 */
TableInfoView.prototype.onButtonClick = function(e) {
	this.joinButton.visible = false;
	this.leaveButton.visible = false;

	var ev = {
		type: TableInfoView.BUTTON_CLICK
	};

	if (e.target == this.joinButton)
		ev.button = ButtonData.JOIN_TOURNAMENT;

	if (e.target == this.leaveButton)
		ev.button = ButtonData.LEAVE_TOURNAMENT;

	console.log("button click");
	this.trigger(ev);
}

module.exports = TableInfoView;
},{"../../proto/data/ButtonData":40,"./DialogButton":26,"inherits":7,"pixi.js":"pixi.js","yaed":11}],38:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var EventDispatcher = require("yaed");
var inherits = require("inherits");

/**
 * A timer view
 * @class TimerView
 */
function TimerView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);

	this.resources = resources

	this.timerClip = new PIXI.Sprite(this.resources.getTexture("timerBackground"));
	this.addChild(this.timerClip);


	this.canvas = new PIXI.Graphics();
	this.canvas.x = this.timerClip.width * 0.5;
	this.canvas.y = this.timerClip.height * 0.5;
	this.timerClip.addChild(this.canvas);

	this.timerClip.visible = false;

	this.tween = null;

	//this.showPercent(30);
}

inherits(TimerView, PIXI.DisplayObjectContainer);
EventDispatcher.init(TimerView);

/**
 * Hide.
 * @method hide
 */
TimerView.prototype.hide = function() {
	this.timerClip.visible = false;
	this.stop();
}

/**
 * Show.
 * @method show
 */
TimerView.prototype.show = function(seatIndex) {

	this.timerClip.visible = true;

	var seatPosition = this.resources.getPoint("seatPosition" + seatIndex);
	var timerOffset = this.resources.getPoint("timerOffset");

	this.timerClip.x = seatPosition.x + timerOffset.x;
	this.timerClip.y = seatPosition.y + timerOffset.y;

	this.stop();

}

/**
 * Stop.
 * @method stop
 */
TimerView.prototype.stop = function(seatIndex) {
	if (this.tween != null)
		this.tween.stop();

}

/**
 * Countdown.
 * @method countdown
 */
TimerView.prototype.countdown = function(totalTime, timeLeft) {
	this.stop();

	totalTime *= 1000;
	timeLeft *= 1000;

	var time = Date.now();
	this.startAt = time + timeLeft - totalTime;
	this.stopAt = time + timeLeft;

	this.tween = new TWEEN.Tween({
			time: time
		})
		.to({
			time: this.stopAt
		}, timeLeft)
		.onUpdate(this.onUpdate.bind(this))
		.onComplete(this.onComplete.bind(this))
		.start();

}

/**
 * On tween update.
 * @method onUpdate
 */
TimerView.prototype.onUpdate = function() {
	var time = Date.now();
	var percent = 100 * (time - this.startAt) / (this.stopAt - this.startAt);

	//	console.log("p = " + percent);

	this.showPercent(percent);
}

/**
 * On tween update.
 * @method onUpdate
 */
TimerView.prototype.onComplete = function() {
	var time = Date.now();
	var percent = 100;
	this.showPercent(percent);
	this.tween = null;
}

/**
 * Show percent.
 * @method showPercent
 */
TimerView.prototype.showPercent = function(value) {
	if (value < 0)
		value = 0;

	if (value > 100)
		value = 100;

	this.canvas.clear();

	this.canvas.beginFill(0xc00000);
	this.canvas.drawCircle(0, 0, 10);
	this.canvas.endFill();

	this.canvas.beginFill(0xffffff);
	this.canvas.moveTo(0, 0);
	for (var i = 0; i < 33; i++) {
		this.canvas.lineTo(
			10 * Math.cos(i * value * 2 * Math.PI / (32 * 100) - Math.PI / 2),
			10 * Math.sin(i * value * 2 * Math.PI / (32 * 100) - Math.PI / 2)
		);
	}

	this.canvas.lineTo(0, 0);
	this.canvas.endFill();

}

module.exports = TimerView;
},{"inherits":7,"pixi.js":"pixi.js","tween.js":10,"yaed":11}],39:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

var EventDispatcher = require("yaed");
var inherits = require("inherits");

var InitMessage = require("./messages/InitMessage");
var StateCompleteMessage = require("./messages/StateCompleteMessage");
var SeatInfoMessage = require("./messages/SeatInfoMessage");
var CommunityCardsMessage = require("./messages/CommunityCardsMessage");
var PocketCardsMessage = require("./messages/PocketCardsMessage");
var SeatClickMessage = require("./messages/SeatClickMessage");
var ShowDialogMessage = require("./messages/ShowDialogMessage");
var ButtonClickMessage = require("./messages/ButtonClickMessage");
var ButtonsMessage = require("./messages/ButtonsMessage");
var DelayMessage = require("./messages/DelayMessage");
var ClearMessage = require("./messages/ClearMessage");
var DealerButtonMessage = require("./messages/DealerButtonMessage");
var BetMessage = require("./messages/BetMessage");
var BetsToPotMessage = require("./messages/BetsToPotMessage");

var ActionMessage = require("./messages/ActionMessage");
var ChatMessage = require("./messages/ChatMessage");
var CheckboxMessage = require("./messages/CheckboxMessage");
var FadeTableMessage = require("./messages/FadeTableMessage");
var HandInfoMessage = require("./messages/HandInfoMessage");
var InterfaceStateMessage = require("./messages/InterfaceStateMessage");
var PayOutMessage = require("./messages/PayOutMessage");
var PotMessage = require("./messages/PotMessage");
var PresetButtonClickMessage = require("./messages/PresetButtonClickMessage");
var PresetButtonsMessage = require("./messages/PresetButtonsMessage");
var PreTournamentInfoMessage = require("./messages/PreTournamentInfoMessage");
var TableButtonClickMessage = require("./messages/TableButtonClickMessage");
var TableButtonsMessage = require("./messages/TableButtonsMessage");
var TableInfoMessage = require("./messages/TableInfoMessage");
var TestCaseRequestMessage = require("./messages/TestCaseRequestMessage");
var TimerMessage = require("./messages/TimerMessage");
var TournamentResultMessage = require("./messages/TournamentResultMessage");
var FoldCardsMessage = require("./messages/FoldCardsMessage");

/**
 * A protocol connection with an underlying connection.
 *
 * There are two ways to liten for connections, the first one and most straight
 * forward is the addMessageHandler, which registers a listener for a
 * particular network message. The first argument should be the message
 * class to listen for:
 *
 *     function onSeatInfoMessage(m) {
 *         // Check if the seat is active.
 *         m.isActive();
 *     }
 *
 *     protoConnection.addMessageHandler(SeatInfoMessage, onSeatInfoMessage);
 *
 * The second method is to listen to the ProtoConnection.MESSAGE dispatched
 * by the instance of the ProtoConnection. In this case, the listener
 * will be called for all messages received on the connection.
 *
 *     function onMessage(e) {
 *         var message=e.message;
 *
 *         // Is it a SeatInfoMessage?
 *         if (message instanceof SeatInfoMessage) {
 *             // ...
 *         }
 *     }
 *
 *     protoConnection.addMessageHandler(SeatInfoMessage, onMessage);
 *
 * The underlying connection should be an object that implements an "interface"
 * of a connection. It is not an interface per se, since JavaScript doesn't support
 * it. Anyway, the signature of this interface, is that the connection object
 * should have a `send` method which receives a object to be send. It should also
 * dispatch "message" events as messages are received, and "close" events if the
 * connection is closed by the remote party.
 *
 * @class ProtoConnection
 * @extends EventDispatcher
 * @constructor
 * @param connection The underlying connection object.
 */
function ProtoConnection(connection) {
	EventDispatcher.call(this);

	this.logMessages = false;
	this.messageDispatcher = new EventDispatcher();
	this.connection = connection;
	this.connection.addEventListener("message", this.onConnectionMessage, this);
	this.connection.addEventListener("close", this.onConnectionClose, this);
}

inherits(ProtoConnection, EventDispatcher);

/**
 * Triggers if the remote party closes the underlying connection.
 * @event ProtoConnection.CLOSE
 */
ProtoConnection.CLOSE = "close";

/**
 * Triggers when we receive a message from the remote party.
 * @event ProtoConnection.MESSAGE
 * @param {Object} message The message that was received.
 */
ProtoConnection.MESSAGE = "message";

ProtoConnection.MESSAGE_TYPES = {};
ProtoConnection.MESSAGE_TYPES[InitMessage.TYPE] = InitMessage;
ProtoConnection.MESSAGE_TYPES[StateCompleteMessage.TYPE] = StateCompleteMessage;
ProtoConnection.MESSAGE_TYPES[SeatInfoMessage.TYPE] = SeatInfoMessage;
ProtoConnection.MESSAGE_TYPES[CommunityCardsMessage.TYPE] = CommunityCardsMessage;
ProtoConnection.MESSAGE_TYPES[PocketCardsMessage.TYPE] = PocketCardsMessage;
ProtoConnection.MESSAGE_TYPES[SeatClickMessage.TYPE] = SeatClickMessage;
ProtoConnection.MESSAGE_TYPES[ShowDialogMessage.TYPE] = ShowDialogMessage;
ProtoConnection.MESSAGE_TYPES[ButtonClickMessage.TYPE] = ButtonClickMessage;
ProtoConnection.MESSAGE_TYPES[ButtonsMessage.TYPE] = ButtonsMessage;
ProtoConnection.MESSAGE_TYPES[DelayMessage.TYPE] = DelayMessage;
ProtoConnection.MESSAGE_TYPES[ClearMessage.TYPE] = ClearMessage;
ProtoConnection.MESSAGE_TYPES[DealerButtonMessage.TYPE] = DealerButtonMessage;
ProtoConnection.MESSAGE_TYPES[BetMessage.TYPE] = BetMessage;
ProtoConnection.MESSAGE_TYPES[BetsToPotMessage.TYPE] = BetsToPotMessage;

ProtoConnection.MESSAGE_TYPES[ActionMessage.TYPE] = ActionMessage;
ProtoConnection.MESSAGE_TYPES[ChatMessage.TYPE] = ChatMessage;
ProtoConnection.MESSAGE_TYPES[CheckboxMessage.TYPE] = CheckboxMessage;
ProtoConnection.MESSAGE_TYPES[FadeTableMessage.TYPE] = FadeTableMessage;
ProtoConnection.MESSAGE_TYPES[HandInfoMessage.TYPE] = HandInfoMessage;
ProtoConnection.MESSAGE_TYPES[InterfaceStateMessage.TYPE] = InterfaceStateMessage;
ProtoConnection.MESSAGE_TYPES[PayOutMessage.TYPE] = PayOutMessage;
ProtoConnection.MESSAGE_TYPES[PotMessage.TYPE] = PotMessage;
ProtoConnection.MESSAGE_TYPES[PresetButtonClickMessage.TYPE] = PresetButtonClickMessage;
ProtoConnection.MESSAGE_TYPES[PresetButtonsMessage.TYPE] = PresetButtonsMessage;
ProtoConnection.MESSAGE_TYPES[PreTournamentInfoMessage.TYPE] = PreTournamentInfoMessage;
ProtoConnection.MESSAGE_TYPES[TableButtonClickMessage.TYPE] = TableButtonClickMessage;
ProtoConnection.MESSAGE_TYPES[TableButtonsMessage.TYPE] = TableButtonsMessage;
ProtoConnection.MESSAGE_TYPES[TableInfoMessage.TYPE] = TableInfoMessage;
ProtoConnection.MESSAGE_TYPES[TestCaseRequestMessage.TYPE] = TestCaseRequestMessage;
ProtoConnection.MESSAGE_TYPES[TimerMessage.TYPE] = TimerMessage;
ProtoConnection.MESSAGE_TYPES[TournamentResultMessage.TYPE] = TournamentResultMessage;
ProtoConnection.MESSAGE_TYPES[FoldCardsMessage.TYPE] = FoldCardsMessage;

/**
 * Add message handler.
 * @method addMessageHandler
 */
ProtoConnection.prototype.addMessageHandler = function(messageType, handler, scope) {
	if (messageType.hasOwnProperty("TYPE"))
		messageType = messageType.TYPE;

	this.messageDispatcher.on(messageType, handler, scope);
}

/**
 * Remove message handler.
 * @method removeMessageHandler
 */
ProtoConnection.prototype.removeMessageHandler = function(messageType, handler, scope) {
	if (messageType.hasOwnProperty("TYPE"))
		messageType = messageType.TYPE;

	this.messageDispatcher.off(messageType, handler, scope);
}

/**
 * Connection message.
 * @method onConnectionMessage
 * @private
 */
ProtoConnection.prototype.onConnectionMessage = function(ev) {
	var message = ev.message;
	var constructor;

	if (this.logMessages)
		console.log("==> " + JSON.stringify(message));

	for (type in ProtoConnection.MESSAGE_TYPES) {
		if (message.type == type)
			constructor = ProtoConnection.MESSAGE_TYPES[type]
	}

	if (!constructor) {
		console.warn("unknown message: " + message.type);
		return;
	}

	var o = new constructor();
	o.unserialize(message);
	o.type = message.type;

	this.messageDispatcher.trigger(o);

	this.trigger({
		type: ProtoConnection.MESSAGE,
		message: o
	});
}

/**
 * Connection close.
 * @method onConnectionClose
 * @private
 */
ProtoConnection.prototype.onConnectionClose = function(ev) {
	this.connection.off("message", this.onConnectionMessage, this);
	this.connection.off("close", this.onConnectionClose, this);

	this.close();

	this.connection = null;

	this.trigger(ProtoConnection.CLOSE);
}

/**
 * Send a message.
 * @method send
 */
ProtoConnection.prototype.send = function(message) {
	var serialized = message.serialize();

	for (type in ProtoConnection.MESSAGE_TYPES) {
		if (message instanceof ProtoConnection.MESSAGE_TYPES[type])
			serialized.type = type;
	}

	if (!serialized.type)
		throw new Error("Unknown message type for send, message=" + message.constructor.name);

	//	console.log("sending: "+serialized);

	this.connection.send(serialized);
}

/**
 * Should messages be logged to console?
 * @method setLogMessages
 */
ProtoConnection.prototype.setLogMessages = function(value) {
	this.logMessages = value;
}

/**
 * Close the underlying connection. Only close it if the readyState is undefined,
 * i.e. we are in a node.js environment, or if it says that it is actually open.
 * @method close
 */
ProtoConnection.prototype.close = function() {
	if (!this.connection)
		return;

	if (this.connection.readyState === undefined ||
		this.connection.readyState == 1)
		this.connection.close();
}

/**
 * Get string representation.
 * @method toString
 */
ProtoConnection.prototype.toString = function() {
	return "<ProtoConnection>";
}

module.exports = ProtoConnection;
},{"./messages/ActionMessage":42,"./messages/BetMessage":43,"./messages/BetsToPotMessage":44,"./messages/ButtonClickMessage":45,"./messages/ButtonsMessage":46,"./messages/ChatMessage":47,"./messages/CheckboxMessage":48,"./messages/ClearMessage":49,"./messages/CommunityCardsMessage":50,"./messages/DealerButtonMessage":51,"./messages/DelayMessage":52,"./messages/FadeTableMessage":53,"./messages/FoldCardsMessage":54,"./messages/HandInfoMessage":55,"./messages/InitMessage":56,"./messages/InterfaceStateMessage":57,"./messages/PayOutMessage":58,"./messages/PocketCardsMessage":59,"./messages/PotMessage":60,"./messages/PreTournamentInfoMessage":61,"./messages/PresetButtonClickMessage":62,"./messages/PresetButtonsMessage":63,"./messages/SeatClickMessage":64,"./messages/SeatInfoMessage":65,"./messages/ShowDialogMessage":66,"./messages/StateCompleteMessage":67,"./messages/TableButtonClickMessage":68,"./messages/TableButtonsMessage":69,"./messages/TableInfoMessage":70,"./messages/TestCaseRequestMessage":71,"./messages/TimerMessage":72,"./messages/TournamentResultMessage":73,"inherits":7,"yaed":11}],40:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Button data.
 * @class ButtonData
 */
function ButtonData(button, value) {
	this.button = button;
	this.value = value;
}

ButtonData.RAISE = "raise";
ButtonData.FOLD = "fold";
ButtonData.BET = "bet";
ButtonData.SIT_OUT = "sitOut";
ButtonData.SIT_IN = "sitIn";
ButtonData.CALL = "call";
ButtonData.POST_BB = "postBB";
ButtonData.POST_SB = "postSB";
ButtonData.CANCEL = "cancel";
ButtonData.CHECK = "check";
ButtonData.SHOW = "show";
ButtonData.MUCK = "muck";
ButtonData.OK = "ok";
ButtonData.IM_BACK = "imBack";
ButtonData.LEAVE = "leave";
ButtonData.CHECK_FOLD = "checkFold";
ButtonData.CALL_ANY = "callAny";
ButtonData.RAISE_ANY = "raiseAny";
ButtonData.BUY_IN = "buyIn";
ButtonData.RE_BUY = "reBuy";
ButtonData.JOIN_TOURNAMENT = "joinTournament";
ButtonData.LEAVE_TOURNAMENT = "leaveTournament";

/**
 * Get button.
 * @method getButton
 */
ButtonData.prototype.getButton = function() {
	return this.button;
}

/**
 * Get button string for this button.
 * @method getButtonString
 */
ButtonData.prototype.getButtonString = function() {
	return ButtonData.getButtonStringForId(this.button);
}

/**
 * Get value.
 * @method getValue
 */
ButtonData.prototype.getValue = function() {
	return this.value;
}

/**
 * Get button string for id.
 * @method getButtonStringForId
 * @static
 */
ButtonData.getButtonStringForId = function(b) {
	switch (b) {
		case ButtonData.FOLD:
			return "FOLD";

		case ButtonData.CALL:
			return "CALL";

		case ButtonData.RAISE:
			return "RAISE TO";

		case ButtonData.BET:
			return "BET";

		case ButtonData.SIT_OUT:
			return "SIT OUT";

		case ButtonData.POST_BB:
			return "POST BB";

		case ButtonData.POST_SB:
			return "POST SB";

		case ButtonData.SIT_IN:
			return "SIT IN";

		case ButtonData.CANCEL:
			return "CANCEL";

		case ButtonData.CHECK:
			return "CHECK";

		case ButtonData.SHOW:
			return "SHOW";

		case ButtonData.MUCK:
			return "MUCK";

		case ButtonData.OK:
			return "OK";

		case ButtonData.IM_BACK:
			return "I'M BACK";

		case ButtonData.LEAVE:
			return "LEAVE";

		case ButtonData.CHECK_FOLD:
			return "CHECK / FOLD";

		case ButtonData.CALL_ANY:
			return "CALL ANY";

		case ButtonData.RAISE_ANY:
			return "RAISE ANY";

		case ButtonData.RE_BUY:
			return "RE-BUY";

		case ButtonData.BUY_IN:
			return "BUY IN";
	}

	return "";
}

ButtonData.prototype.toString = function() {
	return "<ButtonData button=" + this.button + ", value=" + this.value + ">";
}

module.exports = ButtonData;
},{}],41:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Card data.
 * @class CardData
 */
function CardData(value) {
	this.value = value;
}

CardData.CARD_VALUE_STRINGS =
	["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"];

CardData.SUIT_STRINGS =
	["D", "C", "H", "S"];
CardData.LONG_SUIT_STRINGS =
	["Diamonds", "Clubs", "Hearts", "Spades"];

CardData.HIDDEN = -1;

/**
 * Does this CardData represent a show card?
 * If not it should be rendered with its backside.
 * @method isShown
 */
CardData.prototype.isShown = function() {
	return this.value >= 0;
}

/**
 * Get card value.
 * This value represents the rank of the card, but starts on 0.
 * @method getCardValue
 */
CardData.prototype.getCardValue = function() {
	return this.value % 13;
}

/**
 * Get card value string.
 * @method getCardValueString
 */
CardData.prototype.getCardValueString = function() {
	return CardData.CARD_VALUE_STRINGS[this.value % 13];
}

/**
 * Get suit index.
 * @method getSuitIndex
 */
CardData.prototype.getSuitIndex = function() {
	return Math.floor(this.value / 13);
}

/**
 * Get suit string.
 * @method getSuitString
 */
CardData.prototype.getSuitString = function() {
	return CardData.SUIT_STRINGS[this.getSuitIndex()];
}

/**
 * Get long suit string.
 * @method getLongSuitString
 */
CardData.prototype.getLongSuitString = function() {
	return CardData.LONG_SUIT_STRINGS[this.getSuitIndex()];
}

/**
 * Get color.
 * @method getColor
 */
CardData.prototype.getColor = function() {
	if (this.getSuitIndex() % 2 != 0)
		return "#000000";

	else
		return "#ff0000";
}

/**
 * To string.
 * @method toString
 */
CardData.prototype.toString = function() {
	if (this.value < 0)
		return "XX";

	//	return "<card " + this.getCardValueString() + this.getSuitString() + ">";
	return this.getCardValueString() + this.getSuitString();
}

/**
 * Get value of the card.
 * @method getValue
 */
CardData.prototype.getValue = function() {
	return this.value;
}

/**
 * Compare with respect to value. Not really useful except for debugging!
 * @method compareValue
 * @static
 */
CardData.compareValue = function(a, b) {
	if (!(a instanceof CardData) || !(b instanceof CardData))
		throw new Error("Not comparing card data");

	if (a.getValue() > b.getValue())
		return 1;

	if (a.getValue() < b.getValue())
		return -1;

	return 0;
}

/**
 * Compare with respect to card value.
 * @method compareCardValue
 * @static
 */
CardData.compareCardValue = function(a, b) {
	if (!(a instanceof CardData) || !(b instanceof CardData))
		throw new Error("Not comparing card data");

	if (a.getCardValue() > b.getCardValue())
		return 1;

	if (a.getCardValue() < b.getCardValue())
		return -1;

	return 0;
}

/**
 * Compare with respect to suit.
 * @method compareSuit
 * @static
 */
CardData.compareSuitIndex = function(a, b) {
	if (!(a instanceof CardData) || !(b instanceof CardData))
		throw new Error("Not comparing card data");

	if (a.getSuitIndex() > b.getSuitIndex())
		return 1;

	if (a.getSuitIndex() < b.getSuitIndex())
		return -1;

	return 0;
}

/**
 * Create a card data from a string.
 * @method fromString
 * @static
 */
CardData.fromString = function(s) {
	var i;

	var cardValue = -1;
	for (i = 0; i < CardData.CARD_VALUE_STRINGS.length; i++) {
		var cand = CardData.CARD_VALUE_STRINGS[i];

		if (s.substring(0, cand.length).toUpperCase() == cand)
			cardValue = i;
	}

	if (cardValue < 0)
		throw new Error("Not a valid card string: " + s);

	var suitString = s.substring(CardData.CARD_VALUE_STRINGS[cardValue].length);

	var suitIndex = -1;
	for (i = 0; i < CardData.SUIT_STRINGS.length; i++) {
		var cand = CardData.SUIT_STRINGS[i];

		if (suitString.toUpperCase() == cand)
			suitIndex = i;
	}

	if (suitIndex < 0)
		throw new Error("Not a valid card string: " + s);

	return new CardData(suitIndex * 13 + cardValue);
}

module.exports = CardData;
},{}],42:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when player made an action.
 * @class ActionMessage
 */
function ActionMessage(seatIndex, action) {
	this.seatIndex = seatIndex;
	this.action = action;
}

ActionMessage.TYPE = "action";

ActionMessage.FOLD = "fold";
ActionMessage.CALL = "call";
ActionMessage.RAISE = "raise";
ActionMessage.CHECK = "check";
ActionMessage.BET = "bet";
ActionMessage.MUCK = "muck";
ActionMessage.ANTE = "ante";

/**
 * Seat index.
 * @method getSeatIndex
 */
ActionMessage.prototype.getSeatIndex = function() {
	return this.seatIndex;
}

/**
 * Getter.
 * @method getAction
 */
ActionMessage.prototype.getAction = function() {
	return this.action;
}

/**
 * Un-serialize.
 * @method unserialize
 */
ActionMessage.prototype.unserialize = function(data) {
	this.seatIndex = data.seatIndex;
	this.action = data.action;
}

/**
 * Serialize message.
 * @method serialize
 */
ActionMessage.prototype.serialize = function() {
	return {
		seatIndex: this.seatIndex,
		action: this.action
	};
}

module.exports = ActionMessage;
},{}],43:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when player has placed a bet.
 * @class BetMessage
 */
function BetMessage(seatIndex, value) {
	this.seatIndex = seatIndex;
	this.value = value;
}

BetMessage.TYPE = "bet";

/**
 * Getter.
 * @method getSeatIndex
 */
BetMessage.prototype.getSeatIndex = function() {
	return this.seatIndex;
}

/**
 * Getter.
 * @method getValue
 */
BetMessage.prototype.getValue = function() {
	return this.value;
}

/**
 * Un-serialize.
 * @method unserialize
 */
BetMessage.prototype.unserialize = function(data) {
	this.seatIndex = data.seatIndex;
	this.value = data.value;
}

/**
 * Serialize message.
 * @method serialize
 */
BetMessage.prototype.serialize = function() {
	return {
		seatIndex: this.seatIndex,
		value: this.value
	};
}

module.exports = BetMessage;
},{}],44:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when bets should be placed in pot.
 * @class BetsToPotMessage
 */
function BetsToPotMessage() {
}

BetsToPotMessage.TYPE = "betsToPot";

/**
 * Un-serialize.
 * @method unserialize
 */
BetsToPotMessage.prototype.unserialize = function(data) {
}

/**
 * Serialize message.
 * @method serialize
 */
BetsToPotMessage.prototype.serialize = function() {
	return {};
}

module.exports = BetsToPotMessage;
},{}],45:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Sent when the user clicks a button, either in a dialog or
 * for a game action.
 * @class ButtonClickMessage
 */
function ButtonClickMessage(button, value) {
	this.button = button;
	this.value = value;

//	console.log("Creating button click message, value=" + value);
}

ButtonClickMessage.TYPE = "buttonClick";

/**
 * The the button that was pressed.
 * @method getButton
 */
ButtonClickMessage.prototype.getButton = function() {
	return this.button;
}

/**
 * Setter.
 * @method getValue
 */
ButtonClickMessage.prototype.getValue = function() {
	return this.value;
}

/**
 * Un-serialize.
 * @method unserialize
 */
ButtonClickMessage.prototype.unserialize = function(data) {
	this.button = data.button;
	this.value = data.value;
}

/**
 * Serialize message.
 * @method serialize
 */
ButtonClickMessage.prototype.serialize = function() {
	return {
		button: this.button,
		value: this.value
	};
}

module.exports = ButtonClickMessage;
},{}],46:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

var ButtonData = require("../data/ButtonData");

/**
 * Message sent when the client should show game action buttons,
 * FOLD, RAISE etc.
 * @class ButtonsMessage
 */
function ButtonsMessage() {
	this.buttons = [];
	this.sliderButtonIndex = 0;
	this.min = -1;
	this.max = -1;
}

ButtonsMessage.TYPE = "buttons";

/**
 * Get an array of ButtonData indicating which buttons to show.
 * @method getButtons
 */
ButtonsMessage.prototype.getButtons = function() {
	return this.buttons;
}

/**
 * Add a button to be sent.
 * @method addButton
 */
ButtonsMessage.prototype.addButton = function(button) {
	this.buttons.push(button);
}

/**
 * Un-serialize.
 * @method unserialize.
 */
ButtonsMessage.prototype.unserialize = function(data) {
	this.buttons = [];

	for (var i = 0; i < data.buttons.length; i++) {
		var button = data.buttons[i];
		var buttonData = new ButtonData(button.button, button.value);
		this.addButton(buttonData);
	}
	this.sliderButtonIndex = data.sliderButtonIndex;
	this.min = data.min;
	this.max = data.max;
}

/**
 * Serialize message.
 * @method serialize
 */
ButtonsMessage.prototype.serialize = function() {
	var buttons = [];

	for (var i = 0; i < this.buttons.length; i++) {
		var button = {};
		button.button = this.buttons[i].getButton();
		button.value = this.buttons[i].getValue();
		buttons.push(button);
	}

	return {
		buttons: buttons,
		sliderButtonIndex: this.sliderButtonIndex,
		min: this.min,
		max: this.max
	};
}

module.exports = ButtonsMessage;
},{"../data/ButtonData":40}],47:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when something has occurred in the chat.
 * @class ChatMessage
 */
function ChatMessage(user, text) {
	this.user = user;
	this.text = text;
}

ChatMessage.TYPE = "chat";

/**
 * Get text.
 * @method getText
 */
ChatMessage.prototype.getText = function() {
	return this.text;
}

/**
 * Get user.
 * @method getUser
 */
ChatMessage.prototype.getUser = function() {
	return this.user;
}

/**
 * Un-serialize.
 * @method unserialize
 */
ChatMessage.prototype.unserialize = function(data) {
	this.text = data.text;
	this.user = data.user;
}

/**
 * Serialize message.
 * @method serialize
 */
ChatMessage.prototype.serialize = function() {
	return {
		text: this.text,
		user: this.user
	};
}

module.exports = ChatMessage;
},{}],48:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Sent when player has checked a checkbox.
 * @class CheckboxMessage
 */
function CheckboxMessage(id, checked) {
	this.id = id;
	this.checked = checked;
}

CheckboxMessage.TYPE = "checkbox";

CheckboxMessage.AUTO_POST_BLINDS = "autoPostBlinds";
CheckboxMessage.AUTO_MUCK_LOSING = "autoMuckLosing";
CheckboxMessage.SITOUT_NEXT = "sitoutNext";

/**
 * Id of checkbox.
 * @method getId
 */
CheckboxMessage.prototype.getId = function() {
	return this.id;
}

/**
 * Getter.
 * @method getValue
 */
CheckboxMessage.prototype.getChecked = function() {
	return this.checked;
}

/**
 * Un-serialize.
 * @method unserialize
 */
CheckboxMessage.prototype.unserialize = function(data) {
	this.id = data.id;
	this.checked = data.checked;
}

/**
 * Serialize message.
 * @method serialize
 */
CheckboxMessage.prototype.serialize = function() {
	return {
		id: this.id,
		checked: this.checked
	};
}

module.exports = CheckboxMessage;
},{}],49:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * @class ClearMessage
 */
function ClearMessage(components) {
	if (!components)
		components = [];

	this.components = components;
}

ClearMessage.TYPE = "clear";

ClearMessage.CARDS = "cards";
ClearMessage.BETS = "bets";
ClearMessage.POT = "pot";
ClearMessage.CHAT = "chat";

/**
 * Getter.
 * @method getComponents
 */
ClearMessage.prototype.getComponents = function() {
	return this.components;
}

/**
 * Un-serialize.
 * @method unserialize
 */
ClearMessage.prototype.unserialize = function(data) {
	this.components = data.components;
}

/**
 * Serialize message.
 * @method serialize
 */
ClearMessage.prototype.serialize = function() {
	return {
		components: this.components
	};
}

module.exports = ClearMessage;
},{}],50:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

var CardData = require("../data/CardData");

/**
 * Show community cards.
 * @class CommunityCardsMessage
 */
function CommunityCardsMessage(cards) {
	if (!cards)
		cards = [];

	this.animate = false;
	this.cards = cards;
	this.firstIndex = 0;
}

CommunityCardsMessage.TYPE = "communityCards";

/**
 * Animation or not?
 * @method setAnimate
 */
CommunityCardsMessage.prototype.setAnimate = function(value) {
	return this.animate = value;
}

/**
 * Set first index.
 * @method setFirstIndex
 */
CommunityCardsMessage.prototype.setFirstIndex = function(value) {
	return this.firstIndex = value;
}

/**
 * Add card.
 * @method addCard
 */
CommunityCardsMessage.prototype.addCard = function(c) {
	this.cards.push(c);
}

/**
 * Get card data.
 * @method getCards
 */
CommunityCardsMessage.prototype.getCards = function() {
	return this.cards;
}

/**
 * Get the index of the first card to be shown in the sequence.
 * @method getFirstIndex
 */
CommunityCardsMessage.prototype.getFirstIndex = function() {
	return this.firstIndex;
}

/**
 * Un-serialize.
 * @method unserialize.
 */
CommunityCardsMessage.prototype.unserialize = function(data) {
	var i;

	this.animate = data.animate;
	this.firstIndex = parseInt(data.firstIndex);
	this.cards = [];

	for (i = 0; i < data.cards.length; i++)
		this.cards.push(new CardData(data.cards[i]));
}

/**
 * Serialize message.
 * @method serialize
 */
CommunityCardsMessage.prototype.serialize = function() {
	var cards = [];

	for (i = 0; i < this.cards.length; i++)
		cards.push(this.cards[i].getValue());

	return {
		animate: this.animate,
		firstIndex: this.firstIndex,
		cards: cards
	};
}

module.exports = CommunityCardsMessage;
},{"../data/CardData":41}],51:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * @class DealerButtonMessage
 */
function DealerButtonMessage(seatIndex, animate) {
	this.seatIndex = seatIndex;
	this.animate = animate;
}

DealerButtonMessage.TYPE = "dealerButton";

/**
 * Getter.
 * @method getSeatIndex
 */
DealerButtonMessage.prototype.getSeatIndex = function() {
	return this.seatIndex;
}

/**
 * Getter.
 * @method getAnimate
 */
DealerButtonMessage.prototype.getAnimate = function() {
	return this.animate;
}

/**
 * Un-serialize.
 * @method unserialize
 */
DealerButtonMessage.prototype.unserialize = function(data) {
	this.seatIndex = data.seatIndex;
	this.animate = data.animate;
}

/**
 * Serialize message.
 * @method serialize
 */
DealerButtonMessage.prototype.serialize = function() {
	return {
		seatIndex: this.seatIndex,
		animate: this.animate
	};
}

module.exports = DealerButtonMessage;
},{}],52:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * @class DelayMessage
 */
function DelayMessage(delay) {
	this.delay = delay;
}

DelayMessage.TYPE = "delay";

/**
 * Getter.
 * @method getDelay
 */
DelayMessage.prototype.getDelay = function() {
	return this.delay;
}

/**
 * Un-serialize.
 * @method unserialize
 */
DelayMessage.prototype.unserialize = function(data) {
	this.delay = data.delay;
}

/**
 * Serialize message.
 * @method serialize
 */
DelayMessage.prototype.serialize = function() {
	return {
		delay: this.delay
	};
}

module.exports = DelayMessage;
},{}],53:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received table should fade.
 * @class FadeTableMessage
 */
function FadeTableMessage(visible, direction) {
	this.visible = visible;
	this.direction = direction;
}

FadeTableMessage.TYPE = "fadeTable";

/**
 * Getter.
 * @method getVisible
 */
FadeTableMessage.prototype.getVisible = function() {
	return this.visible;
}

/**
 * Getter.
 * @method getDirection
 */
FadeTableMessage.prototype.getDirection = function() {
	return this.direction;
}

/**
 * Un-serialize.
 * @method unserialize
 */
FadeTableMessage.prototype.unserialize = function(data) {
	this.visible = data.visible;
	this.direction = data.direction;
}

/**
 * Serialize message.
 * @method serialize
 */
FadeTableMessage.prototype.serialize = function() {
	return {
		visible: this.visible,
		direction: this.direction
	};
}

module.exports = FadeTableMessage;
},{}],54:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received player has folded.
 * @class FoldCardsMessage
 */
function FoldCardsMessage(seatIndex) {
	this.seatIndex = seatIndex;
}

FoldCardsMessage.TYPE = "foldCards";

/**
 * Getter.
 * @method getSeatIndex
 */
FoldCardsMessage.prototype.getSeatIndex = function() {
	return this.seatIndex;
}

/**
 * Un-serialize.
 * @method unserialize
 */
FoldCardsMessage.prototype.unserialize = function(data) {
	this.seatIndex = data.seatIndex;
}

/**
 * Serialize message.
 * @method serialize
 */
FoldCardsMessage.prototype.serialize = function() {
	return {
		seatIndex: this.seatIndex
	};
}

module.exports = FoldCardsMessage;
},{}],55:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when ?.
 * @class HandInfoMessage
 */
function HandInfoMessage(text, countdown) {
	this.text = text;
	this.countdown = countdown;
}

HandInfoMessage.TYPE = "handInfo";

/**
 * Getter.
 * @method getSeatIndex
 */
HandInfoMessage.prototype.getText = function() {
	return this.text;
}

/**
 * Getter.
 * @method getValue
 */
HandInfoMessage.prototype.getCountdown = function() {
	return this.countdown;
}

/**
 * Un-serialize.
 * @method unserialize
 */
HandInfoMessage.prototype.unserialize = function(data) {
	this.text = data.text;
	this.countdown = data.countdown;
}

/**
 * Serialize message.
 * @method serialize
 */
HandInfoMessage.prototype.serialize = function() {
	return {
		text: this.text,
		countdown: this.countdown
	};
}

module.exports = HandInfoMessage;
},{}],56:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * @class InitMessage
 */
function InitMessage(token) {
	this.token = token;
	this.tableId = null;
	this.viewCase = null;
	this.tournamentId = null;
}

InitMessage.TYPE = "init";

/**
 * get token.
 * @method getToken
 */
InitMessage.prototype.getToken = function() {
	return this.token;
}

/**
 * Set table id.
 * @method setTableId
 */
InitMessage.prototype.setTableId = function(id) {
	this.tableId = id;
}

/**
 * Get table id.
 * @method getTableId
 */
InitMessage.prototype.getTableId = function() {
	return this.tableId;
}

/**
 * Set table id.
 * @method setTournamentId
 */
InitMessage.prototype.setTournamentId = function(id) {
	this.tournamentId = id;
}

/**
 * Get table id.
 * @method getTournamentId
 */
InitMessage.prototype.getTournamentId = function() {
	return this.tournamentId;
}

/**
 * Set view case.
 * @method setTableId
 */
InitMessage.prototype.setViewCase = function(viewCase) {
	this.viewCase = viewCase;
}

/**
 * Get view case.
 * @method getTableId
 */
InitMessage.prototype.getViewCase = function() {
	return this.viewCase;
}

/**
 * Un-serialize.
 * @method unserialize.
 */
InitMessage.prototype.unserialize = function(data) {
	this.token = data.token;
	this.tableId = data.tableId;
	this.viewCase = data.viewCase;
	this.tournamentId = data.tournamentId;
}

/**
 * Serialize message.
 * @method serialize
 */
InitMessage.prototype.serialize = function() {
	return {
		token: this.token,
		tableId: this.tableId,
		viewCase: this.viewCase,
		tournamentId: this.tournamentId
	};
}

module.exports = InitMessage;
},{}],57:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when interface state has changed.
 * @class InterfaceStateMessage
 */
function InterfaceStateMessage(visibleButtons) {
	if (!visibleButtons)
		visibleButtons = [];

	this.visibleButtons = visibleButtons;
}

InterfaceStateMessage.TYPE = "interfaceState";

/**
 * Getter.
 * @method getVisibleButtons
 */
InterfaceStateMessage.prototype.getVisibleButtons = function() {
	return this.visibleButtons;
}

/**
 * Add a button to be shown.
 * @method addVisibleButton
 */
InterfaceStateMessage.prototype.addVisibleButton=function(buttonId) {
	this.visibleButtons.push(buttonId);
}

/**
 * Un-serialize.
 * @method unserialize
 */
InterfaceStateMessage.prototype.unserialize = function(data) {
	this.visibleButtons = data.visibleButtons;
}

/**
 * Serialize message.
 * @method serialize
 */
InterfaceStateMessage.prototype.serialize = function() {
	return {
		visibleButtons: this.visibleButtons
	};
}

module.exports = InterfaceStateMessage;
},{}],58:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when player has placed a bet.
 * @class PayOutMessage
 */
function PayOutMessage() {
	this.values = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
}

PayOutMessage.TYPE = "payOut";

/**
 * Getter.
 * @method getValues
 */
PayOutMessage.prototype.getValues = function() {
	return this.values;
}

/**
 * Set value at.
 * @method setValueAt
 */
PayOutMessage.prototype.setValueAt = function(seatIndex, value) {
	this.values[seatIndex] = value;
}

/**
 * Un-serialize.
 * @method unserialize
 */
PayOutMessage.prototype.unserialize = function(data) {
	for (var i = 0; i < data.values.length; i++) {
		this.values[i] = data.values[i];
	}
}

/**
 * Serialize message.
 * @method serialize
 */
PayOutMessage.prototype.serialize = function() {
	return {
		values: this.values
	};
}

module.exports = PayOutMessage;
},{}],59:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

var CardData = require("../data/CardData");

/**
 * Show pocket cards.
 * @class PocketCardsMessage
 */
function PocketCardsMessage(seatIndex) {
	this.animate = false;
	this.cards = [];
	this.firstIndex = 0;
	this.seatIndex = seatIndex;
}

PocketCardsMessage.TYPE = "pocketCards";

/**
 * Animation?
 * @method setAnimate
 */
PocketCardsMessage.prototype.setAnimate = function(value) {
	this.animate = value;
}

/**
 * Set first index.
 * @method setFirstIndex
 */
PocketCardsMessage.prototype.setFirstIndex = function(index) {
	this.firstIndex = index;
}

/**
 * Get array of CardData.
 * @method getCards
 */
PocketCardsMessage.prototype.getCards = function() {
	return this.cards;
}

/**
 * Add a card.
 * @method addCard
 */
PocketCardsMessage.prototype.addCard = function(c) {
	this.cards.push(c);
}

/**
 * Get first index.
 * @method getFirstIndex
 */
PocketCardsMessage.prototype.getFirstIndex = function() {
	return this.firstIndex;
}

/**
 * Get seat index.
 * @method getSeatIndex
 */
PocketCardsMessage.prototype.getSeatIndex = function() {
	return this.seatIndex;
}

/**
 * Un-serialize.
 * @method unserialize.
 */
PocketCardsMessage.prototype.unserialize = function(data) {
	var i;

	this.animate = data.animate;
	this.firstIndex = parseInt(data.firstIndex);
	this.cards = [];
	this.seatIndex = data.seatIndex;

	for (i = 0; i < data.cards.length; i++)
		this.cards.push(new CardData(data.cards[i]));
}

/**
 * Serialize message.
 * @method serialize
 */
PocketCardsMessage.prototype.serialize = function() {
	var cards = [];

	for (i = 0; i < this.cards.length; i++)
		cards.push(this.cards[i].getValue());

	return {
		animate: this.animate,
		firstIndex: this.firstIndex,
		cards: cards,
		seatIndex: this.seatIndex
	};
}

module.exports = PocketCardsMessage;
},{"../data/CardData":41}],60:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when player pot has changed.
 * @class PotMessage
 */
function PotMessage(values) {
	this.values = values == null ? new Array() : values;
}

PotMessage.TYPE = "pot";

/**
 * Getter.
 * @method getValues
 */
PotMessage.prototype.getValues = function() {
	return this.values;
}

/**
 * Un-serialize.
 * @method unserialize
 */
PotMessage.prototype.unserialize = function(data) {
	this.values = data.values;
}

/**
 * Serialize message.
 * @method serialize
 */
PotMessage.prototype.serialize = function() {
	return {
		values: this.values
	};
}

module.exports = PotMessage;
},{}],61:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when Pre tournament info message is dispatched.
 * @class PreTournamentInfoMessage
 */
function PreTournamentInfoMessage(text, countdown) {
	this.text = text;
	this.countdown = countdown;
}

PreTournamentInfoMessage.TYPE = "preTournamentInfo";

/**
 * Getter.
 * @method getText
 */
PreTournamentInfoMessage.prototype.getText = function() {
	return this.text;
}

/**
 * Getter.
 * @method getCountdown
 */
PreTournamentInfoMessage.prototype.getCountdown = function() {
	return this.countdown;
}

/**
 * Un-serialize.
 * @method unserialize
 */
PreTournamentInfoMessage.prototype.unserialize = function(data) {
	this.text = data.text;
	this.countdown = data.countdown;
}

/**
 * Serialize message.
 * @method serialize
 */
PreTournamentInfoMessage.prototype.serialize = function() {
	if (this.countdown < 0)
		this.countdown = 0;

	return {
		text: this.text,
		countdown: this.countdown
	};
}

module.exports = PreTournamentInfoMessage;
},{}],62:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when ?.
 * @class PresetButtonClickMessage
 */
function PresetButtonClickMessage(button, value) {
	if (!value)
		value = null;

	this.button = button;
	this.value = value;
}

PresetButtonClickMessage.TYPE = "presetButtonClick";

/**
 * Getter.
 * @method getButton
 */
PresetButtonClickMessage.prototype.getButton = function() {
	return this.button;
}

/**
 * Getter.
 * @method getValue
 */
PresetButtonClickMessage.prototype.getValue = function() {
	return this.value;
}

/**
 * Un-serialize.
 * @method unserialize
 */
PresetButtonClickMessage.prototype.unserialize = function(data) {
	this.button = data.button;
	this.value = data.value;
}

/**
 * Serialize message.
 * @method serialize
 */
PresetButtonClickMessage.prototype.serialize = function() {
	return {
		button: this.button,
		value: this.value
	};
}

module.exports = PresetButtonClickMessage;
},{}],63:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

var ButtonData = require("../data/ButtonData");

/**
 * Received when ?.
 * @class PresetButtonsMessage
 */
function PresetButtonsMessage() {
	this.buttons = new Array(7);
	this.current = null;
}

PresetButtonsMessage.TYPE = "presetButtons";

/**
 * Getter.
 * @method getButtons
 */
PresetButtonsMessage.prototype.getButtons = function() {
	return this.buttons;
}

/**
 * Getter.
 * @method getCurrent
 */
PresetButtonsMessage.prototype.getCurrent = function() {
	return this.current;
}

/**
 * Set buton data.
 * @method
 */
PresetButtonsMessage.prototype.setButtonDataAt = function(index, buttonData) {
	this.buttons[index] = buttonData;
}

/**
 * Un-serialize.
 * @method unserialize
 */
PresetButtonsMessage.prototype.unserialize = function(data) {
	this.current = data.current;

	this.buttons = new Array();

	for (var i = 0; i < data.buttons.length; i++) {
		var button = data.buttons[i];
		var buttonData = null;

		if (button != null) {
			buttonData = new ButtonData(button.button, button.value);
		}

		this.buttons.push(buttonData);
	}
}

/**
 * Serialize message.
 * @method serialize
 */
PresetButtonsMessage.prototype.serialize = function() {
	var object = {
		buttons: [],
		current: this.current
	};

	for (var i = 0; i < this.buttons.length; i++) {
		var buttonData = this.buttons[i];
		if (buttonData != null)
			object.buttons.push({
				button: buttonData.button,
				value: buttonData.value
			});

		else
			object.buttons.push(null);
	}

	return object;
}

module.exports = PresetButtonsMessage;
},{"../data/ButtonData":40}],64:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Message indicating that the user has clicked a seat.
 * @class SeatClickMessage
 */
function SeatClickMessage(seatIndex) {
	this.seatIndex=seatIndex;
}

SeatClickMessage.TYPE = "seatClick";

/**
 * Getter.
 * @method getSeatIndex
 */
SeatClickMessage.prototype.getSeatIndex = function() {
	return this.seatIndex;
}

/**
 * Un-serialize.
 * @method unserialize.
 */
SeatClickMessage.prototype.unserialize = function(data) {
	this.seatIndex = data.seatIndex;
}

/**
 * Serialize message.
 * @method serialize
 */
SeatClickMessage.prototype.serialize = function() {
	return {
		seatIndex: this.seatIndex,
	};
}

module.exports = SeatClickMessage;
},{}],65:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Show username and chips on seat.
 * @class SeatInfoMessage
 */
function SeatInfoMessage(seatIndex) {
	this.seatIndex = seatIndex;
	this.active = true;
	this.sitout = false;
	this.name = "";
	this.chips = "";
}

SeatInfoMessage.TYPE = "seatInfo";

/**
 * Getter.
 * @method getSeatIndex
 */
SeatInfoMessage.prototype.getSeatIndex = function() {
	return this.seatIndex;
}

/**
 * Getter.
 * @method getName
 */
SeatInfoMessage.prototype.getName = function() {
	return this.name;
}

/**
 * Getter.
 * @method getChips
 */
SeatInfoMessage.prototype.getChips = function() {
	return this.chips;
}

/**
 * Getter.
 * @method isSitout
 */
SeatInfoMessage.prototype.isSitout = function() {
	return this.sitout;
}

/**
 * Getter.
 * @method isActive
 */
SeatInfoMessage.prototype.isActive = function() {
	return this.active;
}

/**
 * Setter.
 * @method setActive
 */
SeatInfoMessage.prototype.setActive = function(v) {
	this.active = v;
}

/**
 * Set sitout.
 * @method setSitout
 */
SeatInfoMessage.prototype.setSitout = function(v) {
	this.sitout = v;
}

/**
 * Setter.
 * @method setName
 */
SeatInfoMessage.prototype.setName = function(v) {
	this.name = v;
}

/**
 * Setter.
 * @method setChips
 */
SeatInfoMessage.prototype.setChips = function(v) {
	this.chips = v;
}

/**
 * Un-serialize.
 * @method unserialize
 */
SeatInfoMessage.prototype.unserialize = function(data) {
	this.seatIndex = data.seatIndex;
	this.name = data.name;
	this.chips = data.chips;
	this.sitout = data.sitout;
	this.active = data.active;
}

/**
 * Serialize message.
 * @method serialize
 */
SeatInfoMessage.prototype.serialize = function() {
	return {
		seatIndex: this.seatIndex,
		name: this.name,
		chips: this.chips,
		sitout: this.sitout,
		active: this.active
	};
}

module.exports = SeatInfoMessage;
},{}],66:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Show dialog, for e.g. buy in.
 * @class ShowDialogMessage
 */
function ShowDialogMessage() {
	this.text = "";
	this.buttons = [];
	this.defaultValue = null;
}

ShowDialogMessage.TYPE = "showDialog";

/**
 * Add a button to the dialog.
 * @method addButton
 */
ShowDialogMessage.prototype.addButton = function(button) {
	this.buttons.push(button);
}

/**
 * Get text of the dialog.
 * @method getText
 */
ShowDialogMessage.prototype.getText = function() {
	return this.text;
}

/**
 * Get array of ButtonData to be shown in the dialog.
 * @method getButtons
 */
ShowDialogMessage.prototype.getButtons = function() {
	return this.buttons;
}

/**
 * Get default value.
 * @method getButtons
 */
ShowDialogMessage.prototype.getDefaultValue = function() {
	return this.defaultValue;
}

/**
 * Set default value.
 * @method setDefaultValue
 */
ShowDialogMessage.prototype.setDefaultValue = function(v) {
	this.defaultValue=v;
}

/**
 * Set text in the dialog.
 * @method setText
 */
ShowDialogMessage.prototype.setText = function(text) {
	this.text = text;
}

/**
 * Un-serialize.
 * @method unserialize.
 */
ShowDialogMessage.prototype.unserialize = function(data) {
	this.text = data.text;
	this.buttons = data.buttons;
	this.defaultValue = data.defaultValue;
}

/**
 * Serialize message.
 * @method serialize
 */
ShowDialogMessage.prototype.serialize = function() {
	return {
		text: this.text,
		buttons: this.buttons,
		defaultValue: this.defaultValue
	};
}

module.exports = ShowDialogMessage;
},{}],67:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * @class StateCompleteMessage
 */
function StateCompleteMessage() {}

StateCompleteMessage.TYPE = "stateComplete";

/**
 * Un-serialize.
 * @method unserialize.
 */
StateCompleteMessage.prototype.unserialize = function(data) {}

/**
 * Serialize message.
 * @method serialize
 */
StateCompleteMessage.prototype.serialize = function() {
	return {};
}

module.exports = StateCompleteMessage;
},{}],68:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when table button clicked.
 * @class TableButtonClickMessage
 */
function TableButtonClickMessage(tableIndex) {
	this.tableIndex = tableIndex;
}

TableButtonClickMessage.TYPE = "tableButtonClick";

/**
 * Getter.
 * @method getTableIndex
 */
TableButtonClickMessage.prototype.getTableIndex = function() {
	return this.tableIndex;
}

/**
 * Un-serialize.
 * @method unserialize
 */
TableButtonClickMessage.prototype.unserialize = function(data) {
	this.tableIndex = data.tableIndex;
}

/**
 * Serialize message.
 * @method serialize
 */
TableButtonClickMessage.prototype.serialize = function() {
	return {
		tableIndex: this.tableIndex
	};
}

module.exports = TableButtonClickMessage;
},{}],69:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when ?.
 * @class TableButtonsMessage
 */
function TableButtonsMessage() {
	this.enabled = new Array();
	this.currentIndex = -1;
	this.playerIndex = -1;
	this.infoLink = "";
}

TableButtonsMessage.TYPE = "tableButtons";

/**
 * Getter.
 * @method getEnabled
 */
TableButtonsMessage.prototype.getEnabled = function() {
	return this.enabled;
}

/**
 * Getter.
 * @method getCurrentIndex
 */
TableButtonsMessage.prototype.getCurrentIndex = function() {
	return this.currentIndex;
}

/**
 * Getter.
 * @method getPlayerIndex
 */
TableButtonsMessage.prototype.getPlayerIndex = function() {
	return this.playerIndex;
}

/**
 * Getter.
 * @method getInfoLink
 */
TableButtonsMessage.prototype.getInfoLink = function() {
	return this.infoLink;
}

/**
 * Un-serialize.
 * @method unserialize
 */
TableButtonsMessage.prototype.unserialize = function(data) {
	this.playerIndex = data.playerIndex;
	this.currentIndex = data.currentIndex;
	this.infoLink = data.infoLink;

	this.enabled = new Array();
	for(var i = 0; i < data.enabled.length; i++)
		this.enabled.push(data.enabled[i]);
}

/**
 * Serialize message.
 * @method serialize
 */
TableButtonsMessage.prototype.serialize = function() {
	var object = {
		currentIndex: this.currentIndex,
		playerIndex: this.playerIndex,
		enabled: [],
		infoLink: this.infoLink
	};

	for(var i = 0; i < this.enabled.length; i++)
		object.enabled.push(this.enabled[i]);

	return object;
}

module.exports = TableButtonsMessage;
},{}],70:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Set the big text that calls for user action,
 * such as "Welcome, please take a seat!".
 * @class TableInfoMessage
 */
function TableInfoMessage(text, countdown) {
	this.countdown = countdown;
	this.text = text;
	this.showJoinButton = false;
	this.showLeaveButton = false;
	this.infoLink = null;
	this.infoLinkText = null;
}

TableInfoMessage.TYPE = "tableInfo";

/**
 * Getter.
 * @method getCountdown
 */
TableInfoMessage.prototype.getCountdown = function() {
	return this.countdown;
}

/**
 * Getter.
 * @method getText
 */
TableInfoMessage.prototype.getText = function() {
	return this.text;
}

/**
 * Getter.
 * @method getShowJoinButton
 */
TableInfoMessage.prototype.getShowJoinButton = function() {
	return this.showJoinButton;
}

/**
 * Getter.
 * @method getShowLeaveButton
 */
TableInfoMessage.prototype.getShowLeaveButton = function() {
	return this.showLeaveButton;
}

/**
 * Setter.
 * @method getShowJoinButton
 */
TableInfoMessage.prototype.setShowJoinButton = function(value) {
	this.showJoinButton = value;
}

/**
 * Setter.
 * @method getShowLeaveButton
 */
TableInfoMessage.prototype.setShowLeaveButton = function(value) {
	this.showLeaveButton = value;
}

/**
 * Getter.
 * @method getInfoLink
 */
TableInfoMessage.prototype.getInfoLink = function() {
	return this.infoLink;
}

/**
 * Getter.
 * @method getInfoLinkText
 */
TableInfoMessage.prototype.getInfoLinkText = function() {
	return this.infoLinkText;
}

/**
 * Un-serialize.
 * @method unserialize
 */
TableInfoMessage.prototype.unserialize = function(data) {
	if (data.text != null)
		this.text = data.text;

	if (data.countdown != null)
		this.countdown = data.countdown;

	if (data.showJoinButton != null)
		this.showJoinButton = data.showJoinButton;

	if (data.showLeaveButton != null)
		this.showLeaveButton = data.showLeaveButton;

	if (data.infoLink != null)
		this.infoLink = data.infoLink;

	if (data.infoLinkText != null)
		this.infoLinkText = data.infoLinkText;
}

/**
 * Serialize message.
 * @method serialize
 */
TableInfoMessage.prototype.serialize = function() {
	return {
		text: this.text,
		countdown: this.countdown,
		showJoinButton: this.showJoinButton,
		showLeaveButton: this.showLeaveButton,
		infoLink: this.infoLink,
		infoLinkText: this.infoLinkText
	};
}

module.exports = TableInfoMessage;
},{}],71:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when ?.
 * @class TestCaseRequestMessage
 */
function TestCaseRequestMessage(testCase) {
	this.testCase = testCase;
}

TestCaseRequestMessage.TYPE = "testCaseRequest";

/**
 * Getter.
 * @method getTestCase
 */
TestCaseRequestMessage.prototype.getTestCase = function() {
	return this.testCase;
}

/**
 * Un-serialize.
 * @method unserialize
 */
TestCaseRequestMessage.prototype.unserialize = function(data) {
	this.testCase = data.testCase;
}

/**
 * Serialize message.
 * @method serialize
 */
TestCaseRequestMessage.prototype.serialize = function() {
	return {
		testCase: this.testCase
	};
}

module.exports = TestCaseRequestMessage;
},{}],72:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when ?.
 * @class TimerMessage
 */
function TimerMessage() {
	this.seatIndex = -1;
	this.totalTime = -1;
	this.timeLeft = -1;
}

TimerMessage.TYPE = "timer";

/**
 * Getter.
 * @method getSeatIndex
 */
TimerMessage.prototype.getSeatIndex = function() {
	return this.seatIndex;
}

/**
 * Getter.
 * @method getTotalTime
 */
TimerMessage.prototype.getTotalTime = function() {
	return this.totalTime;
}

/**
 * Getter.
 * @method getTimeLeft
 */
TimerMessage.prototype.getTimeLeft = function() {
	return this.timeLeft;
}

/**
 * Setter.
 * @method setSeatIndex
 */
TimerMessage.prototype.setSeatIndex = function(value) {
	this.seatIndex = value;
}

/**
 * Setter.
 * @method setTotalTime
 */
TimerMessage.prototype.setTotalTime = function(value) {
	this.totalTime = value;
}

/**
 * Setter.
 * @method setTimeLeft
 */
TimerMessage.prototype.setTimeLeft = function(value) {
	this.timeLeft = value;
}

/**
 * Un-serialize.
 * @method unserialize
 */
TimerMessage.prototype.unserialize = function(data) {
	this.seatIndex = data.seatIndex;
	this.totalTime = data.totalTime;
	this.timeLeft = data.timeLeft;
}

/**
 * Serialize message.
 * @method serialize
 */
TimerMessage.prototype.serialize = function() {
	return {
		seatIndex: this.seatIndex,
		totalTime: this.totalTime,
		timeLeft: this.timeLeft
	};
}

module.exports = TimerMessage;
},{}],73:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when tournament result message is dispatched.
 * @class TournamentResultMessage
 */
function TournamentResultMessage(text, rightColumnText) {
	this.text = text;
	this.rightColumnText = rightColumnText;
}

TournamentResultMessage.TYPE = "tournamentResult";

/**
 * Getter.
 * @method getText
 */
TournamentResultMessage.prototype.getText = function() {
	return this.text;
}

/**
 * Getter.
 * @method getRightColumnText
 */
TournamentResultMessage.prototype.getRightColumnText = function() {
	return this.rightColumnText;
}

/**
 * Un-serialize.
 * @method unserialize
 */
TournamentResultMessage.prototype.unserialize = function(data) {
	this.text = data.text;
	this.rightColumnText = data.rightColumnText;
}

/**
 * Serialize message.
 * @method serialize
 */
TournamentResultMessage.prototype.serialize = function() {
	return {
		text: this.text,
		rightColumnText: this.rightColumnText
	};
}

module.exports = TournamentResultMessage;
},{}],74:[function(require,module,exports){
/**
 * Utilities.
 * @module utils
 */

var PIXI = require("pixi.js");
var EventDispatcher = require("yaed");
var Button = require("./Button");
var inherits = require("inherits");

/**
 * Checkbox.
 * @class Checkbox
 */
function Checkbox(background, tick) {
	PIXI.DisplayObjectContainer.call(this);

	this.button = new Button(background);
	this.addChild(this.button);

	this.check = tick;
	this.addChild(this.check);

	this.button.addEventListener("click", this.onButtonClick, this);

	this.setChecked(false);
}

inherits(Checkbox, PIXI.DisplayObjectContainer);
EventDispatcher.init(Checkbox);

/**
 * Button click.
 * @method onButtonClick
 * @private
 */
Checkbox.prototype.onButtonClick = function() {
	this.check.visible = !this.check.visible;

	this.dispatchEvent("change");
}

/**
 * Setter.
 * @method setChecked
 */
Checkbox.prototype.setChecked = function(value) {
	this.check.visible = value;
	return value;
}

/**
 * Getter.
 * @method getChecked
 */
Checkbox.prototype.getChecked = function() {
	return this.check.visible;
}


module.exports = Checkbox;
},{"./Button":"Button","inherits":7,"pixi.js":"pixi.js","yaed":11}],75:[function(require,module,exports){
/**
 * Utilities.
 * @module utils
 */

var Thenable = require("tinp");
var inherits = require("inherits");
var EventDispatcher = require("yaed");
var HttpRequest = require("../utils/HttpRequest");

/**
 * A "connection" that loads its messages from a json file rather than
 * actually connecting.
 * @class MessageRequestConnection
 */
function MessageRequestConnection() {
	EventDispatcher.call(this);
	this.test = 1;
}

inherits(MessageRequestConnection, EventDispatcher);

MessageRequestConnection.CONNECT = "connect";
MessageRequestConnection.MESSAGE = "message";
MessageRequestConnection.CLOSE = "close";

/**
 * Connect.
 * @method connect
 */
MessageRequestConnection.prototype.connect = function(url) {
	var request = new HttpRequest(url);

	request.send().then(
		this.onRequestComplete.bind(this),
		this.onRequestError.bind(this)
	);
}

/**
 * @method onRequestComplete
 * @private
 */
MessageRequestConnection.prototype.onRequestComplete = function(body) {
	this.trigger(MessageRequestConnection.CONNECT);

	var lines = body.toString().split("\n");

	//console.log("MessageRequestConnection: lines="+lines.length);

	for (var i = 0; i < lines.length; i++) {
		var line = lines[i];

		//console.log("line: "+line);

		if (line.length && line[0] != "/") {
			console.log("trigger message: " + line);
			this.trigger({
				type: MessageRequestConnection.MESSAGE,
				message: JSON.parse(line)
			});
		}
	}
}

/**
 * @method onRequestComplete
 * @private
 */
MessageRequestConnection.prototype.onRequestError = function(e) {
	console.log("error in request connection");
	console.log(e);
	this.trigger(MessageRequestConnection.CLOSE);
}

/**
 * Send.
 * @method send
 */
MessageRequestConnection.prototype.send = function(m) {
	console.log('ignoring "send" for MessageRequestConnection');
}

module.exports = MessageRequestConnection;
},{"../utils/HttpRequest":"HttpRequest","inherits":7,"tinp":"tinp","yaed":11}],76:[function(require,module,exports){
/**
 * Utilities.
 * @module utils
 */

var EventDispatcher = require("yaed");
var Thenable = require("tinp");
var inherits = require("inherits");

/**
 * Message connection in a browser.
 * @class MessageWebSocketConnection
 */
function MessageWebSocketConnection() {
	EventDispatcher.call(this);
	this.test = 1;
}

inherits(MessageWebSocketConnection, EventDispatcher);

MessageWebSocketConnection.CONNECT = "connect";
MessageWebSocketConnection.MESSAGE = "message";
MessageWebSocketConnection.CLOSE = "close";

/**
 * Connect.
 * @method connect
 */
MessageWebSocketConnection.prototype.connect = function(url) {
	this.webSocket = new WebSocket(url);

	this.webSocket.onopen = this.onWebSocketOpen.bind(this);
	this.webSocket.onmessage = this.onWebSocketMessage.bind(this);
	this.webSocket.onclose = this.onWebSocketClose.bind(this);
	this.webSocket.onerror = this.onWebSocketError.bind(this);
}

/**
 * Send.
 * @method send
 */
MessageWebSocketConnection.prototype.send = function(m) {
	this.webSocket.send(JSON.stringify(m));
}

/**
 * Web socket open.
 * @method onWebSocketOpen
 * @private
 */
MessageWebSocketConnection.prototype.onWebSocketOpen = function() {
	this.trigger(MessageWebSocketConnection.CONNECT);
}

/**
 * Web socket message.
 * @method onWebSocketMessage
 * @private
 */
MessageWebSocketConnection.prototype.onWebSocketMessage = function(e) {
	var message = JSON.parse(e.data);

	this.trigger({
		type: MessageWebSocketConnection.MESSAGE,
		message: message
	});
}

/**
 * Web socket close.
 * @method onWebSocketClose
 * @private
 */
MessageWebSocketConnection.prototype.onWebSocketClose = function() {
	console.log("web socket close, ws=" + this.webSocket + " this=" + this.test);
	this.webSocket.close();
	this.clearWebSocket();

	this.trigger(MessageWebSocketConnection.CLOSE);
}

/**
 * Web socket error.
 * @method onWebSocketError
 * @private
 */
MessageWebSocketConnection.prototype.onWebSocketError = function() {
	console.log("web socket error, ws=" + this.webSocket + " this=" + this.test);

	this.webSocket.close();
	this.clearWebSocket();

	this.trigger(MessageWebSocketConnection.CLOSE);
}

/**
 * Clear the current web socket.
 * @method clearWebSocket
 */
MessageWebSocketConnection.prototype.clearWebSocket = function() {
	this.webSocket.onopen = null;
	this.webSocket.onmessage = null;
	this.webSocket.onclose = null;
	this.webSocket.onerror = null;

	this.webSocket = null;
}

module.exports = MessageWebSocketConnection;
},{"inherits":7,"tinp":"tinp","yaed":11}],77:[function(require,module,exports){
/**
 * Utilities.
 * @module utils
 */

var PIXI = require("pixi.js");
var EventDispatcher = require("yaed");
var inherits = require("inherits");

/**
 * MouseOverGroup. This is the class for the MouseOverGroup.
 * @class MouseOverGroup
 */
function MouseOverGroup() {
	this.objects = new Array();
	this.currentlyOver = false;
	this.mouseDown = false;

}
inherits(MouseOverGroup, PIXI.DisplayObjectContainer);
EventDispatcher.init(MouseOverGroup);


/**
 * Add displayobject to watchlist.
 * @method addDisplayObject
 */
MouseOverGroup.prototype.addDisplayObject = function(displayObject) {

	displayObject.interactive = true;
	displayObject.mouseoverEnabled = true;
	displayObject.mouseover = this.onObjectMouseOver.bind(this);
	displayObject.mouseout = this.onObjectMouseOut.bind(this);
	displayObject.mousedown = this.onObjectMouseDown.bind(this);
	this.objects.push(displayObject);

}


/**
 * Mouse over object.
 * @method onObjectMouseOver
 */
MouseOverGroup.prototype.onObjectMouseOver = function(interaction_object) {
	if(this.currentlyOver)
		return;

	this.currentlyOver = true;
	this.dispatchEvent("mouseover");
}


/**
 * Mouse out object.
 * @method onObjectMouseOut
 */
MouseOverGroup.prototype.onObjectMouseOut = function(interaction_object) {
	if(!this.currentlyOver || this.mouseDown)
		return;

	for(var i = 0; i < this.objects.length; i++)
		if(this.hitTest(this.objects[i], interaction_object))
			return;

	this.currentlyOver = false;
	this.dispatchEvent("mouseout");
}


/**
 * Hit test.
 * @method hitTest
 */
MouseOverGroup.prototype.hitTest = function(object, interaction_object) {
	if((interaction_object.global.x > object.getBounds().x ) && (interaction_object.global.x < (object.getBounds().x + object.getBounds().width)) &&
		(interaction_object.global.y > object.getBounds().y) && (interaction_object.global.y < (object.getBounds().y + object.getBounds().height))) {
		return true;		
	}
	return false;
}


/**
 * Mouse down object.
 * @method onObjectMouseDown
 */
MouseOverGroup.prototype.onObjectMouseDown = function(interaction_object) {
	this.mouseDown = true;
	interaction_object.target.mouseup = interaction_object.target.mouseupoutside = this.onStageMouseUp.bind(this);
}


/**
 * Mouse up stage.
 * @method onStageMouseUp
 */
MouseOverGroup.prototype.onStageMouseUp = function(interaction_object) {
	interaction_object.target.mouseup = interaction_object.target.mouseupoutside = null;
	this.mouseDown = false;

	if(this.currentlyOver) {
		var over = false;

		for(var i = 0; i < this.objects.length; i++)
			if(this.hitTest(this.objects[i], interaction_object))
				over = true;

		if(!over) {
			this.currentlyOver = false;
			this.dispatchEvent("mouseout");
		}
	}
}


module.exports = MouseOverGroup;


},{"inherits":7,"pixi.js":"pixi.js","yaed":11}],78:[function(require,module,exports){
/**
 * Utilities.
 * @module utils
 */

/**
 * Represents a point.
 * @class Point
 * @module utils
 */
function Point(x, y) {
	if (!(this instanceof Point))
		return new Point(x, y);

	this.x = x;
	this.y = y;
}

module.exports = Point;
},{}],79:[function(require,module,exports){
/**
 * Utilities.
 * @module utils
 */

var EventDispatcher = require("yaed");
var inherits = require("inherits");

/**
 * Perform tasks in a sequence.
 * Tasks, which should be event dispatchers,
 * are euqueued with the enqueue function,
 * a START event is dispatcher upon task
 * start, and the task is considered complete
 * as it dispatches a COMPLETE event.
 * @class Sequencer
 */
function Sequencer() {
	EventDispatcher.call(this);

	this.queue = [];
	this.currentTask = null;
	this.onTaskCompleteClosure = this.onTaskComplete.bind(this);
}

inherits(Sequencer, EventDispatcher);

Sequencer.START = "start";
Sequencer.COMPLETE = "complete";

/**
 * Enqueue a task to be performed.
 * @method enqueue
 */
Sequencer.prototype.enqueue = function(task) {
	if (!this.currentTask)
		this.startTask(task)

	else
		this.queue.push(task);
}

/**
 * Start the task.
 * @method startTask
 * @private
 */
Sequencer.prototype.startTask = function(task) {
	this.currentTask = task;

	this.currentTask.addEventListener(Sequencer.COMPLETE, this.onTaskCompleteClosure);
	this.currentTask.dispatchEvent({
		type: Sequencer.START
	});
}

/**
 * The current task is complete.
 * @method onTaskComplete
 * @private
 */
Sequencer.prototype.onTaskComplete = function() {
	this.currentTask.removeEventListener(Sequencer.COMPLETE, this.onTaskCompleteClosure);
	this.currentTask = null;

	if (this.queue.length > 0)
		this.startTask(this.queue.shift());

	else
		this.trigger(Sequencer.COMPLETE);

}

/**
 * Abort the sequence.
 * @method abort
 */
Sequencer.prototype.abort = function() {
	if (this.currentTask) {
		this.currentTask.removeEventListener(Sequencer.COMPLETE, this.onTaskCompleteClosure);
		this.currentTask = null;
	}

	this.queue = [];
}

module.exports = Sequencer;
},{"inherits":7,"yaed":11}],80:[function(require,module,exports){
/**
 * Utilities.
 * @module utils
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var EventDispatcher = require("yaed");
var inherits = require("inherits");

/**
 * Slider. This is the class for the slider.
 * @class Slider
 */
function Slider(background, knob) {
	PIXI.DisplayObjectContainer.call(this);

	this.background = background;
	this.knob = knob;

	this.addChild(this.background);
	this.addChild(this.knob);


	this.knob.buttonMode = true;
	this.knob.interactive = true;
	this.knob.mousedown = this.onKnobMouseDown.bind(this);

	this.background.buttonMode = true;
	this.background.interactive = true;
	this.background.mousedown = this.onBackgroundMouseDown.bind(this);

	this.fadeTween = null;
	this.alpha = 0;
}

inherits(Slider, PIXI.DisplayObjectContainer);
EventDispatcher.init(Slider);


/**
 * Mouse down on knob.
 * @method onKnobMouseDown
 */
Slider.prototype.onKnobMouseDown = function(interaction_object) {
	this.downPos = this.knob.position.x;
	this.downX = interaction_object.getLocalPosition(this).x;

	this.stage.mouseup = this.onStageMouseUp.bind(this);
	this.stage.mousemove = this.onStageMouseMove.bind(this);
}


/**
 * Mouse down on background.
 * @method onBackgroundMouseDown
 */
Slider.prototype.onBackgroundMouseDown = function(interaction_object) {
	this.downX = interaction_object.getLocalPosition(this).x;
	this.knob.x = interaction_object.getLocalPosition(this).x - this.knob.width*0.5;

	this.validateValue();

	this.downPos = this.knob.position.x;

	this.stage.mouseup = this.onStageMouseUp.bind(this);
	this.stage.mousemove = this.onStageMouseMove.bind(this);

	this.dispatchEvent("change");
}


/**
 * Mouse up.
 * @method onStageMouseUp
 */
Slider.prototype.onStageMouseUp = function(interaction_object) {
	this.stage.mouseup = null;
	this.stage.mousemove = null;
}


/**
 * Mouse move.
 * @method onStageMouseMove
 */
Slider.prototype.onStageMouseMove = function(interaction_object) {
	this.knob.x = this.downPos + (interaction_object.getLocalPosition(this).x - this.downX);

	this.validateValue();

	this.dispatchEvent("change");
}


/**
 * Validate position.
 * @method validateValue
 */
Slider.prototype.validateValue = function() {

	if(this.knob.x < 0)
		this.knob.x = 0;

	if(this.knob.x > (this.background.width - this.knob.width))
		this.knob.x = this.background.width - this.knob.width;
}


/**
 * Get value.
 * @method getValue
 */
Slider.prototype.getValue = function() {
	var fraction = this.knob.position.x/(this.background.width - this.knob.width);

	return fraction;
}


/**
 * Get value.
 * @method getValue
 */
Slider.prototype.setValue = function(value) {
	this.knob.x = this.background.position.x + value*(this.background.width - this.knob.width);

	this.validateValue();
	return this.getValue();
}


/**
 * Show.
 * @method show
 */
Slider.prototype.show = function() {
	this.visible = true;
	if(this.fadeTween != null)
		this.fadeTween.stop();
	this.fadeTween = new TWEEN.Tween(this)
			.to({alpha: 1}, 250)
			.start();
}

/**
 * Hide.
 * @method hide
 */
Slider.prototype.hide = function() {
	if(this.fadeTween != null)
		this.fadeTween.stop();
	this.fadeTween = new TWEEN.Tween(this)
			.to({alpha: 0}, 250)
			.onComplete(this.onHidden.bind(this))
			.start();
}

/**
 * On hidden.
 * @method onHidden
 */
Slider.prototype.onHidden = function() {
	this.visible = false;
}


module.exports = Slider;

},{"inherits":7,"pixi.js":"pixi.js","tween.js":10,"yaed":11}],81:[function(require,module,exports){
var url = require("url");

/**
 * URL utility.
 * @class UrlUtil
 */
function UrlUtil() {
	throw new Error("static");
}

/**
 * Make absolute url.
 * @method makeAbsolute
 */
UrlUtil.makeAbsolute = function(target) {
	var parsedUrl = url.parse(target);

	if (parsedUrl.protocol)
		return target;

	if (target.charAt(0) == "/") {
		var u = url.parse(window.location.href);

		u.pathname = target;

		return url.format(u);
	} else {
		var path;
		path = window.location.href.substring(0, window.location.href.lastIndexOf("/") + 1);
		return path + target;
	}
}

module.exports = UrlUtil;
},{"url":6}],"Button":[function(require,module,exports){
/**
 * Utilities.
 * @module utils
 */

var PIXI = require("pixi.js");
var EventDispatcher = require("yaed");
var inherits = require("inherits");

/**
 * Button.
 * @class Button
 */
function Button(content) {
	PIXI.DisplayObjectContainer.call(this);

	if (content)
		this.addChild(content);

	this.interactive = true;
	this.buttonMode = true;

	this.mouseover = this.onMouseover.bind(this);
	this.mouseout = this.touchend = this.touchendoutside = this.onMouseout.bind(this);
	this.mousedown = this.touchstart = this.onMousedown.bind(this);
	this.mouseup = this.onMouseup.bind(this);
	this.click = this.tap = this.onClick.bind(this);

	this.colorMatrixFilter = new PIXI.ColorMatrixFilter();
	this.colorMatrixFilter.matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

	this.filters = [this.colorMatrixFilter];
}

inherits(Button, PIXI.DisplayObjectContainer);
EventDispatcher.init(Button);

Button.LIGHT_MATRIX = [1.5, 0, 0, 0, 0, 1.5, 0, 0, 0, 0, 1.5, 0, 0, 0, 0, 1];
Button.DARK_MATRIX = [.75, 0, 0, 0, 0, .75, 0, 0, 0, 0, .75, 0, 0, 0, 0, 1];
Button.DEFAULT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

Button.CLICK = "click";

/**
 * Mouse over.
 * @method onMouseover
 * @private
 */
Button.prototype.onMouseover = function() {
	this.colorMatrixFilter.matrix = Button.LIGHT_MATRIX;
}

/**
 * Mouse out.
 * @method onMouseout
 * @private
 */
Button.prototype.onMouseout = function() {
	this.colorMatrixFilter.matrix = Button.DEFAULT_MATRIX;
}

/**
 * Mouse down.
 * @method onMousedown
 * @private
 */
Button.prototype.onMousedown = function() {
	this.colorMatrixFilter.matrix = Button.DARK_MATRIX;
}

/**
 * Mouse up.
 * @method onMouseup
 * @private
 */
Button.prototype.onMouseup = function() {
	this.colorMatrixFilter.matrix = Button.LIGHT_MATRIX;
}

/**
 * Click.
 * @method onClick
 * @private
 */
Button.prototype.onClick = function() {
	this.trigger(Button.CLICK);
}

module.exports = Button;
},{"inherits":7,"pixi.js":"pixi.js","yaed":11}],"CountDownText":[function(require,module,exports){
/**
 * Utilities.
 * @module utils
 */

var PIXI = require("pixi.js");
var inherits = require("inherits");

/**
 * A text that counts down.
 * @class CountdownText
 */
function CountdownText(text, style) {
	PIXI.Text.call(this, text, style);

	this.timeLeft = 0;
	this.timerInterval = null;
	this.setText(text);
}

inherits(CountdownText, PIXI.Text);

/**
 * Override the setText function.
 * @method setText
 */
CountdownText.prototype.setText = function(text) {
	this.format = text;

	this.updateFormattedText();
}

/**
 * Update the actual text.
 * @method updateFormattedText
 */
CountdownText.prototype.updateFormattedText = function() {
	var s = (this.timeLeft % 60).toString();
	var m = (Math.floor(this.timeLeft / 60) % 60).toString();
	var h = (Math.floor(this.timeLeft / (60 * 60))).toString();

	if (s.length < 2)
		s = "0" + s;

	if (m.length < 2)
		m = "0" + m;

	if (h == "0")
		h = "";

	else {
		if (h.length < 2)
			h = "0" + h;

		h += ":";
	}

	var text = this.format.toString().replace("%t", h + m + ":" + s);

	//console.log("update text: " + text);

	PIXI.Text.prototype.setText.call(this, text);
}

/**
 * Set time left.
 * @method setTimeLeft
 */
CountdownText.prototype.setTimeLeft = function(timeLeft) {
	if (timeLeft < 0)
		timeLeft = 0;

	if (this.timerInterval) {
		clearInterval(this.timerInterval);
		this.timerInterval = null;
	}

	this.timeLeft = timeLeft;

	if (this.timeLeft > 0) {
		this.timerInterval = setInterval(this.onTimerInterval.bind(this), 1000);
	}

	this.updateFormattedText();
}

/**
 * Timer interval.
 * @method onTimerInterval
 */
CountdownText.prototype.onTimerInterval = function() {
	this.timeLeft--;

	if (this.timeLeft <= 0) {
		clearInterval(this.timerInterval);
		this.timerInterval = null;
	}

	this.updateFormattedText();
}

module.exports = CountdownText;
},{"inherits":7,"pixi.js":"pixi.js"}],"Gradient":[function(require,module,exports){
/**
 * Utilities.
 * @module utils
 */

var PIXI = require("pixi.js");

/**
 * Create a sprite with a gradient.
 * @class Gradient
 */
function Gradient() {
	this.width = 100;
	this.height = 100;
	this.stops = [];
}

/**
 * Set size of the gradient.
 * @method setSize
 */
Gradient.prototype.setSize = function(w, h) {
	this.width = w;
	this.height = h;
}

/**
 * Add color stop.
 * @method addColorStop
 */
Gradient.prototype.addColorStop = function(weight, color) {
	this.stops.push({
		weight: weight,
		color: color
	});
}

/**
 * Render the sprite.
 * @method createSprite
 */
Gradient.prototype.createSprite = function() {
	//console.log("rendering gradient...");
	var c = document.createElement("canvas");
	c.width = this.width;
	c.height = this.height;

	var ctx = c.getContext("2d");
	var grd = ctx.createLinearGradient(0, 0, 0, this.height);
	var i;

	for (i = 0; i < this.stops.length; i++)
		grd.addColorStop(this.stops[i].weight, this.stops[i].color);

	ctx.fillStyle = grd;
	ctx.fillRect(0, 0, this.width, this.height);

	return new PIXI.Sprite(PIXI.Texture.fromCanvas(c));
}

module.exports = Gradient;
},{"pixi.js":"pixi.js"}],"HttpRequest":[function(require,module,exports){
var Thenable = require("tinp");

/**
 * Wraps XMLHttpRequest.
 * @class HttpRequest
 */
function HttpRequest(url) {
	this.url = url;
	this.thenable = null;
	this.resultType = null;
}

/**
 * Set result type.
 * @method setResultType
 */
HttpRequest.prototype.setResultType = function(type) {
	this.resultType = type;
}

/**
 * Set url.
 * @method setUrl
 */
HttpRequest.prototype.setUrl = function(url) {
	this.url = url;
}

/**
 * Send.
 * @method send
 */
HttpRequest.prototype.send = function(url) {
	if (this.thenable)
		throw new Error("Request already sent");

	if (url)
		this.url = url;

	this.thenable = new Thenable();

	this.request = new XMLHttpRequest();
	this.request.open("GET", this.url, true);

	this.request.onload = this.onRequestLoad.bind(this);
	this.request.onerror = this.onRequestError.bind(this);

	this.request.send();

	return this.thenable;
}

/**
 * @method onRequestLoad
 * @private
 */
HttpRequest.prototype.onRequestLoad = function() {
	if (this.request.status != 200) {
		this.thenable.reject(this.request.status);
		this.thenable = null;
		return;
	}

	var result = this.request.responseText;

	switch (this.resultType) {
		case "json":
			try {
				result = JSON.parse(this.request.responseText);
			} catch (e) {
				this.thenable.reject("JSON.parse: "+e);
				return;
			}
			break;
	}

	this.thenable.resolve(result);
}

/**
 * @method onRequestError
 * @private
 */
HttpRequest.prototype.onRequestError = function(e) {
	this.request = null;

	this.thenable.reject(e);
}

module.exports = HttpRequest;
},{"tinp":"tinp"}],"NetPokerClient":[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var PixiApp = require("pixiapp");
var NetPokerClientView = require("../view/NetPokerClientView");
var NetPokerClientController = require("../controller/NetPokerClientController");
var MessageWebSocketConnection = require("../../utils/MessageWebSocketConnection");
var MessageRequestConnection = require("../../utils/MessageRequestConnection");
var ProtoConnection = require("../../proto/ProtoConnection");
var LoadingScreen = require("../view/LoadingScreen");
var StateCompleteMessage = require("../../proto/messages/StateCompleteMessage");
var InitMessage = require("../../proto/messages/InitMessage");
var Resources = require("../resources/Resources");
var ViewConfig = require("../resources/ViewConfig");
var url = require("url");
var TWEEN = require("tween.js");
var inherits = require("inherits");
var UrlUtil = require("../../utils/UrlUtil");
var DefaultSkin = require("../resources/DefaultSkin");

/**
 * Main entry point for client.
 * @class NetPokerClient
 */
function NetPokerClient() {
	PixiApp.call(this, 960, 720);

	this.verticalAlign = PixiApp.TOP;

	this.resources = new Resources();
	this.resources.addSkinSource(DefaultSkin);
	this.resources.addSpriteSheet("netpokerclient.spritesheet.json");

	this.loadingScreen = new LoadingScreen();
	this.addChild(this.loadingScreen);
	this.enterAppState("LOADING", 0);
	this.loadingScreen.show("LOADING");

	this.url = null;
	this.tableId = null;
	this.tournamentId = null;
	this.viewConfig = new ViewConfig();

	this.on("frame", TWEEN.update);
}

inherits(NetPokerClient, PixiApp);

/**
 * Set url.
 * @method setUrl
 */
NetPokerClient.prototype.setUrl = function(url) {
	this.url = url;
}

/**
 * Set table id.
 * @method setTableId
 */
NetPokerClient.prototype.setTableId = function(tableId) {
	this.tableId = tableId;
}

/**
 * Set tournament id.
 * @method setTournamentId
 */
NetPokerClient.prototype.setTournamentId = function(tournamentId) {
	this.tournamentId = tournamentId;
}

/**
 * Set view case.
 * @method setViewCase
 */
NetPokerClient.prototype.setViewCase = function(viewCase) {
	console.log("****** running view case: " + viewCase);
	this.viewCase = viewCase;
}

/**
 * Set token.
 * @method setToken
 */
NetPokerClient.prototype.setToken = function(token) {
	this.token = token;
}

/**
 * Add skin source.
 * @method addSkinSource
 */
NetPokerClient.prototype.addSkinSource = function(skin) {
	this.resources.addSkinSource(skin);
}

/**
 * Add sprite sheet.
 * @method addSpriteSheet
 */
NetPokerClient.prototype.addSpriteSheet = function(spriteSheet) {
	this.resources.addSpriteSheet(spriteSheet);
}

/**
 * Set sprite sheet.
 * @method setSpriteSheet
 */
NetPokerClient.prototype.setSpriteSheet = function(spriteSheet) {
	this.resources.setSpriteSheet(spriteSheet);
}

/**
 * Run.
 * @method run
 */
NetPokerClient.prototype.run = function() {
	//console.log("loading resources.....");
	this.enterAppState("LOADING RESOURCES", 50);

	this.resources.load().then(
		this.onResourcesLoaded.bind(this),
		this.onResourcesError.bind(this)
	);
}

/**
 * Error while loading resources.
 * @method onResourcesError
 */
NetPokerClient.prototype.onResourcesError = function() {
	console.log("resource error");

	this.enterAppState("ERROR LOADING RESOURCES");
}

/**
 * Assets loaded, connect.
 * @method onAssetLoaderComplete
 * @private
 */
NetPokerClient.prototype.onResourcesLoaded = function() {
	//console.log("resources loaded complete...");

	this.netPokerClientView = new NetPokerClientView(this.viewConfig, this.resources);
	this.addChildAt(this.netPokerClientView, 0);

	this.netPokerClientController = new NetPokerClientController(this.netPokerClientView);
	this.connect();
}

/**
 * Connect.
 * @method connect
 * @private
 */
NetPokerClient.prototype.connect = function() {
	if (!this.url) {
		this.enterAppState("NEED URL");
		return;
	}

	var parsedUrl = url.parse(this.url);

	console.log(parsedUrl);

	if (!parsedUrl.protocol || parsedUrl.protocol == "http:" || parsedUrl.protocol == "https:") {
		this.url = UrlUtil.makeAbsolute(this.url);
		this.connection = new MessageRequestConnection();
	} else {
		this.connection = new MessageWebSocketConnection();
	}

	this.connection.on(MessageWebSocketConnection.CONNECT, this.onConnectionConnect, this);
	this.connection.on(MessageWebSocketConnection.CLOSE, this.onConnectionClose, this);

	console.log("Connecting to: " + this.url);

	this.enterAppState("CONNECTING", 65);
	this.connection.connect(this.url);
}

/**
 * Connection complete.
 * @method onConnectionConnect
 * @private
 */
NetPokerClient.prototype.onConnectionConnect = function() {
	console.log("**** connected");
	this.protoConnection = new ProtoConnection(this.connection);
	this.protoConnection.addMessageHandler(StateCompleteMessage, this.onStateCompleteMessage, this);
	this.netPokerClientController.setProtoConnection(this.protoConnection);
	this.enterAppState("INITIALIZING", 80);

	var initMessage = new InitMessage(this.token);

	if (this.tableId)
		initMessage.setTableId(this.tableId);

	if (this.tournamentId)
		initMessage.setTournamentId(this.tournamentId);

	if (this.viewCase)
		initMessage.setViewCase(this.viewCase);

	this.protoConnection.send(initMessage);
}

/**
 * State complete.
 * @method onStateCompleteMessage
 * @private
 */
NetPokerClient.prototype.onStateCompleteMessage = function() {
	this.enterAppState(null);
}

/**
 * Connection closed.
 * @method onConnectionClose
 * @private
 */
NetPokerClient.prototype.onConnectionClose = function() {
	console.log("**** connection closed");
	if (this.protoConnection)
		this.protoConnection.removeMessageHandler(StateCompleteMessage, this.onStateCompleteMessage, this);

	this.protoConnection = null;
	this.netPokerClientController.setProtoConnection(null);
	this.enterAppState("CONNECTION ERROR");
	setTimeout(this.connect.bind(this), 3000);
}

/**
 * Enter app state.
 * @method enterAppState
 * @private
 */
NetPokerClient.prototype.enterAppState = function(message, progress) {
	if (message)
		this.loadingScreen.show(message);

	else
		this.loadingScreen.hide();

	this.trigger({
		type: "appStateChange",
		message: message,
		progress: progress
	});
}

/**
 * Utility function to get all query string params.
 * @method getQueryStringParams
 * @static
 */
NetPokerClient.getQueryStringParams = function() {
	var params = {};
	(function() {

		var match,
			pl = /\+/g, // Regex for replacing addition symbol with a space
			search = /([^&=]+)=?([^&]*)/g,
			decode = function(s) {
				return decodeURIComponent(s.replace(pl, " "));
			},
			query = window.location.search.substring(1).replace(/amp;/g, "");

		while (match = search.exec(query))
			params[decode(match[1])] = decode(match[2]);
	})();

	return params;
}

module.exports = NetPokerClient;
},{"../../proto/ProtoConnection":39,"../../proto/messages/InitMessage":56,"../../proto/messages/StateCompleteMessage":67,"../../utils/MessageRequestConnection":75,"../../utils/MessageWebSocketConnection":76,"../../utils/UrlUtil":81,"../controller/NetPokerClientController":15,"../resources/DefaultSkin":17,"../resources/Resources":"Resources","../resources/ViewConfig":18,"../view/LoadingScreen":28,"../view/NetPokerClientView":29,"inherits":7,"pixi.js":"pixi.js","pixiapp":"pixiapp","tween.js":10,"url":6}],"NineSlice":[function(require,module,exports){
/**
 * Utilities.
 * @module utils
 */

var PIXI = require("pixi.js");
var inherits = require("inherits");

/**
 * Nine slice. This is a sprite that is a grid, and only the
 * middle part stretches when scaling.
 * @class NineSlice
 */
function NineSlice(texture, left, top, right, bottom) {
	PIXI.DisplayObjectContainer.call(this);

	this.texture = texture;

	if (!top)
		top = left;

	if (!right)
		right = left;

	if (!bottom)
		bottom = top;

	this.left = left;
	this.top = top;
	this.right = right;
	this.bottom = bottom;

	this.localWidth = texture.width;
	this.localHeight = texture.height;

	this.buildParts();
	this.updateSizes();
}

inherits(NineSlice, PIXI.DisplayObjectContainer);

/**
 * Build the parts for the slices.
 * @method buildParts
 * @private
 */
NineSlice.prototype.buildParts = function() {
	var xp = [0, this.left, this.texture.width - this.right, this.texture.width];
	var yp = [0, this.top, this.texture.height - this.bottom, this.texture.height];
	var hi, vi;

	this.parts = [];

	for (vi = 0; vi < 3; vi++) {
		for (hi = 0; hi < 3; hi++) {
			var w = xp[hi + 1] - xp[hi];
			var h = yp[vi + 1] - yp[vi];

			if (w != 0 && h != 0) {
				var texturePart = this.createTexturePart(xp[hi], yp[vi], w, h);
				var s = new PIXI.Sprite(texturePart);
				this.addChild(s);

				this.parts.push(s);
			} else {
				this.parts.push(null);
			}
		}
	}
}

/**
 * Update sizes.
 * @method updateSizes
 * @private
 */
NineSlice.prototype.updateSizes = function() {
	var xp = [0, this.left, this.localWidth - this.right, this.localWidth];
	var yp = [0, this.top, this.localHeight - this.bottom, this.localHeight];
	var hi, vi, i = 0;

	for (vi = 0; vi < 3; vi++) {
		for (hi = 0; hi < 3; hi++) {
			if (this.parts[i]) {
				var part = this.parts[i];

				part.position.x = xp[hi];
				part.position.y = yp[vi];
				part.width = xp[hi + 1] - xp[hi];
				part.height = yp[vi + 1] - yp[vi];
			}

			i++;
		}
	}
}

/**
 * Set local size.
 * @method setLocalSize
 */
NineSlice.prototype.setLocalSize = function(w, h) {
	this.localWidth = w;
	this.localHeight = h;
	this.updateSizes();
}

/**
 * Create texture part.
 * @method createTexturePart
 * @private
 */
NineSlice.prototype.createTexturePart = function(x, y, width, height) {
	var frame = {
		x: this.texture.frame.x + x,
		y: this.texture.frame.y + y,
		width: width,
		height: height
	};

	return new PIXI.Texture(this.texture, frame);
}

module.exports = NineSlice;
},{"inherits":7,"pixi.js":"pixi.js"}],"Resources":[function(require,module,exports){
var Thenable = require("tinp");
var PIXI = require("pixi.js");
var UrlUtil = require("../../utils/UrlUtil");
var HttpRequest = require("../../utils/HttpRequest");

/**
 * Resources
 * @class Resources
 */
function Resources() {
	this.spriteSheets = [];
	this.skinSources = [];
	this.data = [];
	this.loadThenable = null;
	this.skinSourceIndex = 0;
}

/**
 * Set sprite sheet.
 * @method setSpriteSheet
 */
Resources.prototype.setSpriteSheet = function(spriteSheet) {
	this.spriteSheets = [spriteSheet];
}

/**
 * Add a sprite sheet.
 * @method addSpriteSheet
 */
Resources.prototype.addSpriteSheet = function(spriteSheet) {
	this.spriteSheets.push(spriteSheet);
}

/**
 * Add a cascading skin source.
 * Object or url.
 * @method source
 */
Resources.prototype.addSkinSource = function(source) {
	this.skinSources.push(source);
}

/**
 * Get a Point resource.
 * @method getPoint
 */
Resources.prototype.getPoint = function(id) {
	this.assertKeyExists(id);

	return new PIXI.Point(this.data[id][0], this.data[id][1]);
}

/**
 * Get a string resource.
 * @method getString
 */
Resources.prototype.getString = function(id) {
	this.assertKeyExists(id);

	return this.data[id].toString();
}

/**
 * Get value.
 * @method getValue
 */
Resources.prototype.getValue = Resources.prototype.getString;

/**
 * Get color.
 * @method getValue
 */
Resources.prototype.getColor = Resources.prototype.getString;

/**
 * Get Texture.
 * @method getTexture
 */
Resources.prototype.getTexture = function(id) {
	var texture = PIXI.Texture.fromFrame(this.getString(id));

	return texture;
}

/**
 * Assert that the key exists.
 * @method assertKeyExists
 * @private
 */
Resources.prototype.assertKeyExists = function(id) {
	if (!this.data.hasOwnProperty(id))
		throw new Error("No such resource: " + id);
}

/**
 * Does this key exist?
 * @method keyExists
 */
Resources.prototype.keyExists = function(id) {
	return this.data.hasOwnProperty(id);
}

/**
 * Load resources.
 * @method load
 */
Resources.prototype.load = function() {
	if (this.loadThenable)
		throw new Error("Already loading");

	this.loadThenable = new Thenable();
	this.skinSourceIndex = 0;

	if (this.spriteSheets.length) {
		this.assetLoader = new PIXI.AssetLoader(this.spriteSheets);
		this.assetLoader.on("onComplete", this.onAssetLoaderComplete.bind(this));
		this.assetLoader.on("onProgress", this.onAssetLoaderProgress.bind(this));
		//console.log("loading assets: "+this.spriteSheets);
		this.assetLoader.load();
	} else {
		this.loadNextSkinSource();
	}

	return this.loadThenable;
}

/**
 * Asset loader progress.
 * @method onAssetLoaderProgress
 */
Resources.prototype.onAssetLoaderProgress = function(ev) {
	console.log("asset loader progress");
	/*	console.log(ev);

		ev.loader.ajaxRequest.onprogress = function() {
			console.log("request progres...");
		};

		ev.loader.ajaxRequest.addEventListener("progress", function() {
			console.log("progress...");
		});*/
}

/**
 * Asset loader complete.
 * @method onAssetLoaderComplete
 */
Resources.prototype.onAssetLoaderComplete = function() {
	//console.log("asset loader complete, loading skin");
	this.loadNextSkinSource();
}

/**
 * Process next skin source in sequence.
 * @method loadNextSkinSource
 * @private
 */
Resources.prototype.loadNextSkinSource = function() {
	if (this.skinSourceIndex >= this.skinSources.length) {
		//console.log("resolving thenable...");
		this.loadThenable.resolve();
		return;
	}

	var o = this.skinSources[this.skinSourceIndex];

	if (typeof o == "object") {
		this.processSkinData(o);
		return;
	}

	var request = new HttpRequest(UrlUtil.makeAbsolute(o));
	request.setResultType("json");

	request.send().then(
		this.onSkinSourceLoaded.bind(this),
		this.onSkinSourceLoadError.bind(this)
	);
}

/**
 * Skin source loaded.
 * @method onSkinSourceLoaded
 */
Resources.prototype.onSkinSourceLoaded = function(data) {
	this.processSkinData(data);
}

/**
 * Skin source load error.
 * @method onSkinSourceLoadError
 */
Resources.prototype.onSkinSourceLoadError = function(error) {
	this.loadThenable.reject(error);
}

/**
 * Process skin data.
 * @method processSkinData
 */
Resources.prototype.processSkinData = function(data) {
	for (i in data)
		this.data[i] = data[i];

	this.skinSourceIndex++;
	this.loadNextSkinSource();
}

module.exports = Resources;
},{"../../utils/HttpRequest":"HttpRequest","../../utils/UrlUtil":81,"pixi.js":"pixi.js","tinp":"tinp"}],"pixi.js":[function(require,module,exports){
/**
 * @license
 * pixi.js - v1.6.0
 * Copyright (c) 2012-2014, Mat Groves
 * http://goodboydigital.com/
 *
 * Compiled: 2014-07-18
 *
 * pixi.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license.php
 */
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

(function(){

    var root = this;

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * @module PIXI
 */
var PIXI = PIXI || {};

/* 
* 
* This file contains a lot of pixi consts which are used across the rendering engine
* @class Consts
*/
PIXI.WEBGL_RENDERER = 0;
PIXI.CANVAS_RENDERER = 1;

// useful for testing against if your lib is using pixi.
PIXI.VERSION = "v1.6.1";


// the various blend modes supported by pixi
PIXI.blendModes = {
    NORMAL:0,
    ADD:1,
    MULTIPLY:2,
    SCREEN:3,
    OVERLAY:4,
    DARKEN:5,
    LIGHTEN:6,
    COLOR_DODGE:7,
    COLOR_BURN:8,
    HARD_LIGHT:9,
    SOFT_LIGHT:10,
    DIFFERENCE:11,
    EXCLUSION:12,
    HUE:13,
    SATURATION:14,
    COLOR:15,
    LUMINOSITY:16
};

// the scale modes
PIXI.scaleModes = {
    DEFAULT:0,
    LINEAR:0,
    NEAREST:1
};

// used to create uids for various pixi objects..
PIXI._UID = 0;

if(typeof(Float32Array) != 'undefined')
{
    PIXI.Float32Array = Float32Array;
    PIXI.Uint16Array = Uint16Array;
}
else
{
    PIXI.Float32Array = Array;
    PIXI.Uint16Array = Array;
}

// interaction frequency 
PIXI.INTERACTION_FREQUENCY = 30;
PIXI.AUTO_PREVENT_DEFAULT = true;

PIXI.RAD_TO_DEG = 180 / Math.PI;
PIXI.DEG_TO_RAD = Math.PI / 180;


PIXI.dontSayHello = false;

PIXI.sayHello = function (type) 
{
    if(PIXI.dontSayHello)return;

    if ( navigator.userAgent.toLowerCase().indexOf('chrome') > -1 )
    {
        var args = [
            '%c %c %c Pixi.js ' + PIXI.VERSION + ' - ' + type + '  %c ' + ' %c ' + ' http://www.pixijs.com/  %c %c ♥%c♥%c♥ ',
            'background: #ff66a5',
            'background: #ff66a5',
            'color: #ff66a5; background: #030307;',
            'background: #ff66a5',
            'background: #ffc3dc',
            'background: #ff66a5',
            'color: #ff2424; background: #fff',
            'color: #ff2424; background: #fff',
            'color: #ff2424; background: #fff'
        ];

       

        console.log.apply(console, args);
    }
    else if (window['console'])
    {
        console.log('Pixi.js ' + PIXI.VERSION + ' - http://www.pixijs.com/');
    }

    PIXI.dontSayHello = true;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The Point object represents a location in a two-dimensional coordinate system, where x represents the horizontal axis and y represents the vertical axis.
 *
 * @class Point
 * @constructor
 * @param x {Number} position of the point on the x axis
 * @param y {Number} position of the point on the y axis
 */
PIXI.Point = function(x, y)
{
    /**
     * @property x
     * @type Number
     * @default 0
     */
    this.x = x || 0;

    /**
     * @property y
     * @type Number
     * @default 0
     */
    this.y = y || 0;
};

/**
 * Creates a clone of this point
 *
 * @method clone
 * @return {Point} a copy of the point
 */
PIXI.Point.prototype.clone = function()
{
    return new PIXI.Point(this.x, this.y);
};

/**
 * Sets the point to a new x and y position.
 * If y is ommited, both x and y will be set to x.
 * 
 * @method set
 * @param [x=0] {Number} position of the point on the x axis
 * @param [y=0] {Number} position of the point on the y axis
 */
PIXI.Point.prototype.set = function(x, y)
{
    this.x = x || 0;
    this.y = y || ( (y !== 0) ? this.x : 0 ) ;
};

// constructor
PIXI.Point.prototype.constructor = PIXI.Point;
/**
 * @author Mat Groves http://matgroves.com/
 */

/**
 * the Rectangle object is an area defined by its position, as indicated by its top-left corner point (x, y) and by its width and its height.
 *
 * @class Rectangle
 * @constructor
 * @param x {Number} The X coord of the upper-left corner of the rectangle
 * @param y {Number} The Y coord of the upper-left corner of the rectangle
 * @param width {Number} The overall width of this rectangle
 * @param height {Number} The overall height of this rectangle
 */
PIXI.Rectangle = function(x, y, width, height)
{
    /**
     * @property x
     * @type Number
     * @default 0
     */
    this.x = x || 0;

    /**
     * @property y
     * @type Number
     * @default 0
     */
    this.y = y || 0;

    /**
     * @property width
     * @type Number
     * @default 0
     */
    this.width = width || 0;

    /**
     * @property height
     * @type Number
     * @default 0
     */
    this.height = height || 0;
};

/**
 * Creates a clone of this Rectangle
 *
 * @method clone
 * @return {Rectangle} a copy of the rectangle
 */
PIXI.Rectangle.prototype.clone = function()
{
    return new PIXI.Rectangle(this.x, this.y, this.width, this.height);
};

/**
 * Checks whether the x and y coordinates passed to this function are contained within this Rectangle
 *
 * @method contains
 * @param x {Number} The X coordinate of the point to test
 * @param y {Number} The Y coordinate of the point to test
 * @return {Boolean} Whether the x/y coords are within this Rectangle
 */
PIXI.Rectangle.prototype.contains = function(x, y)
{
    if(this.width <= 0 || this.height <= 0)
        return false;

    var x1 = this.x;
    if(x >= x1 && x <= x1 + this.width)
    {
        var y1 = this.y;

        if(y >= y1 && y <= y1 + this.height)
        {
            return true;
        }
    }

    return false;
};

// constructor
PIXI.Rectangle.prototype.constructor = PIXI.Rectangle;

PIXI.EmptyRectangle = new PIXI.Rectangle(0,0,0,0);
/**
 * @author Adrien Brault <adrien.brault@gmail.com>
 */

/**
 * @class Polygon
 * @constructor
 * @param points* {Array<Point>|Array<Number>|Point...|Number...} This can be an array of Points that form the polygon,
 *      a flat array of numbers that will be interpreted as [x,y, x,y, ...], or the arguments passed can be
 *      all the points of the polygon e.g. `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the
 *      arguments passed can be flat x,y values e.g. `new PIXI.Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are
 *      Numbers.
 */
PIXI.Polygon = function(points)
{
    //if points isn't an array, use arguments as the array
    if(!(points instanceof Array))
        points = Array.prototype.slice.call(arguments);

    //if this is a flat array of numbers, convert it to points
    if(typeof points[0] === 'number') {
        var p = [];
        for(var i = 0, il = points.length; i < il; i+=2) {
            p.push(
                new PIXI.Point(points[i], points[i + 1])
            );
        }

        points = p;
    }

    this.points = points;
};

/**
 * Creates a clone of this polygon
 *
 * @method clone
 * @return {Polygon} a copy of the polygon
 */
PIXI.Polygon.prototype.clone = function()
{
    var points = [];
    for (var i=0; i<this.points.length; i++) {
        points.push(this.points[i].clone());
    }

    return new PIXI.Polygon(points);
};

/**
 * Checks whether the x and y coordinates passed to this function are contained within this polygon
 *
 * @method contains
 * @param x {Number} The X coordinate of the point to test
 * @param y {Number} The Y coordinate of the point to test
 * @return {Boolean} Whether the x/y coordinates are within this polygon
 */
PIXI.Polygon.prototype.contains = function(x, y)
{
    var inside = false;

    // use some raycasting to test hits
    // https://github.com/substack/point-in-polygon/blob/master/index.js
    for(var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {
        var xi = this.points[i].x, yi = this.points[i].y,
            xj = this.points[j].x, yj = this.points[j].y,
            intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);

        if(intersect) inside = !inside;
    }

    return inside;
};

// constructor
PIXI.Polygon.prototype.constructor = PIXI.Polygon;

/**
 * @author Chad Engler <chad@pantherdev.com>
 */

/**
 * The Circle object can be used to specify a hit area for displayObjects
 *
 * @class Circle
 * @constructor
 * @param x {Number} The X coordinate of the center of this circle
 * @param y {Number} The Y coordinate of the center of this circle
 * @param radius {Number} The radius of the circle
 */
PIXI.Circle = function(x, y, radius)
{
    /**
     * @property x
     * @type Number
     * @default 0
     */
    this.x = x || 0;

    /**
     * @property y
     * @type Number
     * @default 0
     */
    this.y = y || 0;

    /**
     * @property radius
     * @type Number
     * @default 0
     */
    this.radius = radius || 0;
};

/**
 * Creates a clone of this Circle instance
 *
 * @method clone
 * @return {Circle} a copy of the polygon
 */
PIXI.Circle.prototype.clone = function()
{
    return new PIXI.Circle(this.x, this.y, this.radius);
};

/**
 * Checks whether the x, and y coordinates passed to this function are contained within this circle
 *
 * @method contains
 * @param x {Number} The X coordinate of the point to test
 * @param y {Number} The Y coordinate of the point to test
 * @return {Boolean} Whether the x/y coordinates are within this polygon
 */
PIXI.Circle.prototype.contains = function(x, y)
{
    if(this.radius <= 0)
        return false;

    var dx = (this.x - x),
        dy = (this.y - y),
        r2 = this.radius * this.radius;

    dx *= dx;
    dy *= dy;

    return (dx + dy <= r2);
};

/**
* Returns the framing rectangle of the circle as a PIXI.Rectangle object
*
* @method getBounds
* @return {Rectangle} the framing rectangle
*/
PIXI.Circle.prototype.getBounds = function()
{
    return new PIXI.Rectangle(this.x - this.radius, this.y - this.radius, this.width, this.height);
};

// constructor
PIXI.Circle.prototype.constructor = PIXI.Circle;


/**
 * @author Chad Engler <chad@pantherdev.com>
 */

/**
 * The Ellipse object can be used to specify a hit area for displayObjects
 *
 * @class Ellipse
 * @constructor
 * @param x {Number} The X coordinate of the center of the ellipse
 * @param y {Number} The Y coordinate of the center of the ellipse
 * @param width {Number} The half width of this ellipse
 * @param height {Number} The half height of this ellipse
 */
PIXI.Ellipse = function(x, y, width, height)
{
    /**
     * @property x
     * @type Number
     * @default 0
     */
    this.x = x || 0;

    /**
     * @property y
     * @type Number
     * @default 0
     */
    this.y = y || 0;

    /**
     * @property width
     * @type Number
     * @default 0
     */
    this.width = width || 0;

    /**
     * @property height
     * @type Number
     * @default 0
     */
    this.height = height || 0;
};

/**
 * Creates a clone of this Ellipse instance
 *
 * @method clone
 * @return {Ellipse} a copy of the ellipse
 */
PIXI.Ellipse.prototype.clone = function()
{
    return new PIXI.Ellipse(this.x, this.y, this.width, this.height);
};

/**
 * Checks whether the x and y coordinates passed to this function are contained within this ellipse
 *
 * @method contains
 * @param x {Number} The X coordinate of the point to test
 * @param y {Number} The Y coordinate of the point to test
 * @return {Boolean} Whether the x/y coords are within this ellipse
 */
PIXI.Ellipse.prototype.contains = function(x, y)
{
    if(this.width <= 0 || this.height <= 0)
        return false;

    //normalize the coords to an ellipse with center 0,0
    var normx = ((x - this.x) / this.width),
        normy = ((y - this.y) / this.height);

    normx *= normx;
    normy *= normy;

    return (normx + normy <= 1);
};

/**
* Returns the framing rectangle of the ellipse as a PIXI.Rectangle object
*
* @method getBounds
* @return {Rectangle} the framing rectangle
*/
PIXI.Ellipse.prototype.getBounds = function()
{
    return new PIXI.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
};

// constructor
PIXI.Ellipse.prototype.constructor = PIXI.Ellipse;

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The Matrix class is now an object, which makes it a lot faster, 
 * here is a representation of it : 
 * | a | b | tx|
 * | c | d | ty|
 * | 0 | 0 | 1 |
 *
 * @class Matrix
 * @constructor
 */
PIXI.Matrix = function()
{
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;
};

/**
 * Creates a pixi matrix object based on the array given as a parameter
 *
 * @method fromArray
 * @param array {Array} The array that the matrix will be filled with
 */
PIXI.Matrix.prototype.fromArray = function(array)
{
    this.a = array[0];
    this.b = array[1];
    this.c = array[3];
    this.d = array[4];
    this.tx = array[2];
    this.ty = array[5];
};

/**
 * Creates an array from the current Matrix object
 *
 * @method toArray
 * @param transpose {Boolean} Whether we need to transpose the matrix or not
 * @return {Array} the newly created array which contains the matrix
 */
PIXI.Matrix.prototype.toArray = function(transpose)
{
    if(!this.array) this.array = new Float32Array(9);
    var array = this.array;

    if(transpose)
    {
        array[0] = this.a;
        array[1] = this.c;
        array[2] = 0;
        array[3] = this.b;
        array[4] = this.d;
        array[5] = 0;
        array[6] = this.tx;
        array[7] = this.ty;
        array[8] = 1;
    }
    else
    {
        array[0] = this.a;
        array[1] = this.b;
        array[2] = this.tx;
        array[3] = this.c;
        array[4] = this.d;
        array[5] = this.ty;
        array[6] = 0;
        array[7] = 0;
        array[8] = 1;
    }

    return array;
};

PIXI.identityMatrix = new PIXI.Matrix();

PIXI.determineMatrixArrayType = function() {
    return (typeof Float32Array !== 'undefined') ? Float32Array : Array;
};

/**
 * The Matrix2 class will choose the best type of array to use between
 * a regular javascript Array and a Float32Array if the latter is available
 *
 * @class Matrix2
 * @constructor
 */
PIXI.Matrix2 = PIXI.determineMatrixArrayType();

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The base class for all objects that are rendered on the screen. 
 * This is an abstract class and should not be used on its own rather it should be extended.
 *
 * @class DisplayObject
 * @constructor
 */
PIXI.DisplayObject = function()
{
    /**
     * The coordinate of the object relative to the local coordinates of the parent.
     *
     * @property position
     * @type Point
     */
    this.position = new PIXI.Point();

    /**
     * The scale factor of the object.
     *
     * @property scale
     * @type Point
     */
    this.scale = new PIXI.Point(1,1);//{x:1, y:1};

    /**
     * The pivot point of the displayObject that it rotates around
     *
     * @property pivot
     * @type Point
     */
    this.pivot = new PIXI.Point(0,0);

    /**
     * The rotation of the object in radians.
     *
     * @property rotation
     * @type Number
     */
    this.rotation = 0;

    /**
     * The opacity of the object.
     *
     * @property alpha
     * @type Number
     */
    this.alpha = 1;

    /**
     * The visibility of the object.
     *
     * @property visible
     * @type Boolean
     */
    this.visible = true;

    /**
     * This is the defined area that will pick up mouse / touch events. It is null by default.
     * Setting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)
     *
     * @property hitArea
     * @type Rectangle|Circle|Ellipse|Polygon
     */
    this.hitArea = null;

    /**
     * This is used to indicate if the displayObject should display a mouse hand cursor on rollover
     *
     * @property buttonMode
     * @type Boolean
     */
    this.buttonMode = false;

    /**
     * Can this object be rendered
     *
     * @property renderable
     * @type Boolean
     */
    this.renderable = false;

    /**
     * [read-only] The display object container that contains this display object.
     *
     * @property parent
     * @type DisplayObjectContainer
     * @readOnly
     */
    this.parent = null;

    /**
     * [read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.
     *
     * @property stage
     * @type Stage
     * @readOnly
     */
    this.stage = null;

    /**
     * [read-only] The multiplied alpha of the displayObject
     *
     * @property worldAlpha
     * @type Number
     * @readOnly
     */
    this.worldAlpha = 1;

    /**
     * [read-only] Whether or not the object is interactive, do not toggle directly! use the `interactive` property
     *
     * @property _interactive
     * @type Boolean
     * @readOnly
     * @private
     */
    this._interactive = false;

    /**
     * This is the cursor that will be used when the mouse is over this object. To enable this the element must have interaction = true and buttonMode = true
     * 
     * @property defaultCursor
     * @type String
     *
    */
    this.defaultCursor = 'pointer';

    /**
     * [read-only] Current transform of the object based on world (parent) factors
     *
     * @property worldTransform
     * @type Mat3
     * @readOnly
     * @private
     */
    this.worldTransform = new PIXI.Matrix();

    /**
     * [NYI] Unknown
     *
     * @property color
     * @type Array<>
     * @private
     */
    this.color = [];

    /**
     * [NYI] Holds whether or not this object is dynamic, for rendering optimization
     *
     * @property dynamic
     * @type Boolean
     * @private
     */
    this.dynamic = true;

    // cached sin rotation and cos rotation
    this._sr = 0;
    this._cr = 1;

    /**
     * The area the filter is applied to like the hitArea this is used as more of an optimisation
     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle
     *
     * @property filterArea
     * @type Rectangle
     */
    this.filterArea = null;//new PIXI.Rectangle(0,0,1,1);

    /**
     * The original, cached bounds of the object
     *
     * @property _bounds
     * @type Rectangle
     * @private
     */
    this._bounds = new PIXI.Rectangle(0, 0, 1, 1);
    /**
     * The most up-to-date bounds of the object
     *
     * @property _currentBounds
     * @type Rectangle
     * @private
     */
    this._currentBounds = null;
    /**
     * The original, cached mask of the object
     *
     * @property _currentBounds
     * @type Rectangle
     * @private
     */
    this._mask = null;

    this._cacheAsBitmap = false;
    this._cacheIsDirty = false;


    /*
     * MOUSE Callbacks
     */

    /**
     * A callback that is used when the users clicks on the displayObject with their mouse
     * @method click
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the user clicks the mouse down over the sprite
     * @method mousedown
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the user releases the mouse that was over the displayObject
     * for this callback to be fired the mouse must have been pressed down over the displayObject
     * @method mouseup
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the user releases the mouse that was over the displayObject but is no longer over the displayObject
     * for this callback to be fired, The touch must have started over the displayObject
     * @method mouseupoutside
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the users mouse rolls over the displayObject
     * @method mouseover
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the users mouse leaves the displayObject
     * @method mouseout
     * @param interactionData {InteractionData}
     */


    /*
     * TOUCH Callbacks
     */

    /**
     * A callback that is used when the users taps on the sprite with their finger
     * basically a touch version of click
     * @method tap
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the user touches over the displayObject
     * @method touchstart
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the user releases a touch over the displayObject
     * @method touchend
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the user releases the touch that was over the displayObject
     * for this callback to be fired, The touch must have started over the sprite
     * @method touchendoutside
     * @param interactionData {InteractionData}
     */
};

// constructor
PIXI.DisplayObject.prototype.constructor = PIXI.DisplayObject;

/**
 * [Deprecated] Indicates if the sprite will have touch and mouse interactivity. It is false by default
 * Instead of using this function you can now simply set the interactive property to true or false
 *
 * @method setInteractive
 * @param interactive {Boolean}
 * @deprecated Simply set the `interactive` property directly
 */
PIXI.DisplayObject.prototype.setInteractive = function(interactive)
{
    this.interactive = interactive;
};

/**
 * Indicates if the sprite will have touch and mouse interactivity. It is false by default
 *
 * @property interactive
 * @type Boolean
 * @default false
 */
Object.defineProperty(PIXI.DisplayObject.prototype, 'interactive', {
    get: function() {
        return this._interactive;
    },
    set: function(value) {
        this._interactive = value;

        // TODO more to be done here..
        // need to sort out a re-crawl!
        if(this.stage)this.stage.dirty = true;
    }
});

/**
 * [read-only] Indicates if the sprite is globaly visible.
 *
 * @property worldVisible
 * @type Boolean
 */
Object.defineProperty(PIXI.DisplayObject.prototype, 'worldVisible', {
    get: function() {
        var item = this;

        do
        {
            if(!item.visible)return false;
            item = item.parent;
        }
        while(item);

        return true;
    }
});

/**
 * Sets a mask for the displayObject. A mask is an object that limits the visibility of an object to the shape of the mask applied to it.
 * In PIXI a regular mask must be a PIXI.Graphics object. This allows for much faster masking in canvas as it utilises shape clipping.
 * To remove a mask, set this property to null.
 *
 * @property mask
 * @type Graphics
 */
Object.defineProperty(PIXI.DisplayObject.prototype, 'mask', {
    get: function() {
        return this._mask;
    },
    set: function(value) {

        if(this._mask)this._mask.isMask = false;
        this._mask = value;
        if(this._mask)this._mask.isMask = true;
    }
});

/**
 * Sets the filters for the displayObject.
 * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.
 * To remove filters simply set this property to 'null'
 * @property filters
 * @type Array An array of filters
 */
Object.defineProperty(PIXI.DisplayObject.prototype, 'filters', {
    get: function() {
        return this._filters;
    },
    set: function(value) {

        if(value)
        {
            // now put all the passes in one place..
            var passes = [];
            for (var i = 0; i < value.length; i++)
            {
                var filterPasses = value[i].passes;
                for (var j = 0; j < filterPasses.length; j++)
                {
                    passes.push(filterPasses[j]);
                }
            }

            // TODO change this as it is legacy
            this._filterBlock = {target:this, filterPasses:passes};
        }

        this._filters = value;
    }
});

/**
 * Set weather or not a the display objects is cached as a bitmap.
 * This basically takes a snap shot of the display object as it is at that moment. It can provide a performance benefit for complex static displayObjects
 * To remove filters simply set this property to 'null'
 * @property cacheAsBitmap
 * @type Boolean
 */
Object.defineProperty(PIXI.DisplayObject.prototype, 'cacheAsBitmap', {
    get: function() {
        return  this._cacheAsBitmap;
    },
    set: function(value) {

        if(this._cacheAsBitmap === value)return;

        if(value)
        {
            //this._cacheIsDirty = true;
            this._generateCachedSprite();
        }
        else
        {
            this._destroyCachedSprite();
        }

        this._cacheAsBitmap = value;
    }
});

/*
 * Updates the object transform for rendering
 *
 * @method updateTransform
 * @private
 */
PIXI.DisplayObject.prototype.updateTransform = function()
{
    // TODO OPTIMIZE THIS!! with dirty
    if(this.rotation !== this.rotationCache)
    {

        this.rotationCache = this.rotation;
        this._sr =  Math.sin(this.rotation);
        this._cr =  Math.cos(this.rotation);
    }

   // var localTransform = this.localTransform//.toArray();
    var parentTransform = this.parent.worldTransform;//.toArray();
    var worldTransform = this.worldTransform;//.toArray();

    var px = this.pivot.x;
    var py = this.pivot.y;

    var a00 = this._cr * this.scale.x,
        a01 = -this._sr * this.scale.y,
        a10 = this._sr * this.scale.x,
        a11 = this._cr * this.scale.y,
        a02 = this.position.x - a00 * px - py * a01,
        a12 = this.position.y - a11 * py - px * a10,
        b00 = parentTransform.a, b01 = parentTransform.b,
        b10 = parentTransform.c, b11 = parentTransform.d;

    worldTransform.a = b00 * a00 + b01 * a10;
    worldTransform.b = b00 * a01 + b01 * a11;
    worldTransform.tx = b00 * a02 + b01 * a12 + parentTransform.tx;

    worldTransform.c = b10 * a00 + b11 * a10;
    worldTransform.d = b10 * a01 + b11 * a11;
    worldTransform.ty = b10 * a02 + b11 * a12 + parentTransform.ty;

    this.worldAlpha = this.alpha * this.parent.worldAlpha;
};

/**
 * Retrieves the bounds of the displayObject as a rectangle object
 *
 * @method getBounds
 * @return {Rectangle} the rectangular bounding area
 */
PIXI.DisplayObject.prototype.getBounds = function( matrix )
{
    matrix = matrix;//just to get passed js hinting (and preserve inheritance)
    return PIXI.EmptyRectangle;
};

/**
 * Retrieves the local bounds of the displayObject as a rectangle object
 *
 * @method getLocalBounds
 * @return {Rectangle} the rectangular bounding area
 */
PIXI.DisplayObject.prototype.getLocalBounds = function()
{
    return this.getBounds(PIXI.identityMatrix);///PIXI.EmptyRectangle();
};


/**
 * Sets the object's stage reference, the stage this object is connected to
 *
 * @method setStageReference
 * @param stage {Stage} the stage that the object will have as its current stage reference
 */
PIXI.DisplayObject.prototype.setStageReference = function(stage)
{
    this.stage = stage;
    if(this._interactive)this.stage.dirty = true;
};

PIXI.DisplayObject.prototype.generateTexture = function(renderer)
{
    var bounds = this.getLocalBounds();

    var renderTexture = new PIXI.RenderTexture(bounds.width | 0, bounds.height | 0, renderer);
    renderTexture.render(this, new PIXI.Point(-bounds.x, -bounds.y) );

    return renderTexture;
};

PIXI.DisplayObject.prototype.updateCache = function()
{
    this._generateCachedSprite();
};

PIXI.DisplayObject.prototype._renderCachedSprite = function(renderSession)
{
    this._cachedSprite.worldAlpha = this.worldAlpha;
   
    if(renderSession.gl)
    {
        PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession);
    }
    else
    {
        PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, renderSession);
    }
};

PIXI.DisplayObject.prototype._generateCachedSprite = function()//renderSession)
{
    this._cacheAsBitmap = false;
    var bounds = this.getLocalBounds();
   
    if(!this._cachedSprite)
    {
        var renderTexture = new PIXI.RenderTexture(bounds.width | 0, bounds.height | 0);//, renderSession.renderer);
        
        this._cachedSprite = new PIXI.Sprite(renderTexture);
        this._cachedSprite.worldTransform = this.worldTransform;
    }
    else
    {
        this._cachedSprite.texture.resize(bounds.width | 0, bounds.height | 0);
    }

    //REMOVE filter!
    var tempFilters = this._filters;
    this._filters = null;

    this._cachedSprite.filters = tempFilters;
    this._cachedSprite.texture.render(this, new PIXI.Point(-bounds.x, -bounds.y) );

    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );
    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );

    this._filters = tempFilters;

    this._cacheAsBitmap = true;
};

/**
* Renders the object using the WebGL renderer
*
* @method _renderWebGL
* @param renderSession {RenderSession} 
* @private
*/
PIXI.DisplayObject.prototype._destroyCachedSprite = function()
{
    if(!this._cachedSprite)return;

    this._cachedSprite.texture.destroy(true);
  //  console.log("DESTROY")
    // let the gc collect the unused sprite
    // TODO could be object pooled!
    this._cachedSprite = null;
};


PIXI.DisplayObject.prototype._renderWebGL = function(renderSession)
{
    // OVERWRITE;
    // this line is just here to pass jshinting :)
    renderSession = renderSession;
};

/**
* Renders the object using the Canvas renderer
*
* @method _renderCanvas
* @param renderSession {RenderSession} 
* @private
*/
PIXI.DisplayObject.prototype._renderCanvas = function(renderSession)
{
    // OVERWRITE;
    // this line is just here to pass jshinting :)
    renderSession = renderSession;
};

/**
 * The position of the displayObject on the x axis relative to the local coordinates of the parent.
 *
 * @property x
 * @type Number
 */
Object.defineProperty(PIXI.DisplayObject.prototype, 'x', {
    get: function() {
        return  this.position.x;
    },
    set: function(value) {
        this.position.x = value;
    }
});

/**
 * The position of the displayObject on the y axis relative to the local coordinates of the parent.
 *
 * @property y
 * @type Number
 */
Object.defineProperty(PIXI.DisplayObject.prototype, 'y', {
    get: function() {
        return  this.position.y;
    },
    set: function(value) {
        this.position.y = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */


/**
 * A DisplayObjectContainer represents a collection of display objects.
 * It is the base class of all display objects that act as a container for other objects.
 *
 * @class DisplayObjectContainer
 * @extends DisplayObject
 * @constructor
 */
PIXI.DisplayObjectContainer = function()
{
    PIXI.DisplayObject.call( this );

    /**
     * [read-only] The array of children of this container.
     *
     * @property children
     * @type Array<DisplayObject>
     * @readOnly
     */
    this.children = [];
};

// constructor
PIXI.DisplayObjectContainer.prototype = Object.create( PIXI.DisplayObject.prototype );
PIXI.DisplayObjectContainer.prototype.constructor = PIXI.DisplayObjectContainer;

/**
 * The width of the displayObjectContainer, setting this will actually modify the scale to achieve the value set
 *
 * @property width
 * @type Number
 */

 
Object.defineProperty(PIXI.DisplayObjectContainer.prototype, 'width', {
    get: function() {
        return this.scale.x * this.getLocalBounds().width;
    },
    set: function(value) {
        
        var width = this.getLocalBounds().width;

        if(width !== 0)
        {
            this.scale.x = value / ( width/this.scale.x );
        }
        else
        {
            this.scale.x = 1;
        }

        
        this._width = value;
    }
});


/**
 * The height of the displayObjectContainer, setting this will actually modify the scale to achieve the value set
 *
 * @property height
 * @type Number
 */

Object.defineProperty(PIXI.DisplayObjectContainer.prototype, 'height', {
    get: function() {
        return  this.scale.y * this.getLocalBounds().height;
    },
    set: function(value) {

        var height = this.getLocalBounds().height;

        if(height !== 0)
        {
            this.scale.y = value / ( height/this.scale.y );
        }
        else
        {
            this.scale.y = 1;
        }

        this._height = value;
    }
});


/**
 * Adds a child to the container.
 *
 * @method addChild
 * @param child {DisplayObject} The DisplayObject to add to the container
 */
PIXI.DisplayObjectContainer.prototype.addChild = function(child)
{
    return this.addChildAt(child, this.children.length);
};

/**
 * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown
 *
 * @method addChildAt
 * @param child {DisplayObject} The child to add
 * @param index {Number} The index to place the child in
 */
PIXI.DisplayObjectContainer.prototype.addChildAt = function(child, index)
{
    if(index >= 0 && index <= this.children.length)
    {
        if(child.parent)
        {
            child.parent.removeChild(child);
        }

        child.parent = this;

        this.children.splice(index, 0, child);

        if(this.stage)child.setStageReference(this.stage);

        return child;
    }
    else
    {
        throw new Error(child + ' The index '+ index +' supplied is out of bounds ' + this.children.length);
    }
};

/**
 * [NYI] Swaps the depth of 2 displayObjects
 *
 * @method swapChildren
 * @param child {DisplayObject}
 * @param child2 {DisplayObject}
 * @private
 */
PIXI.DisplayObjectContainer.prototype.swapChildren = function(child, child2)
{
    if(child === child2) {
        return;
    }

    var index1 = this.children.indexOf(child);
    var index2 = this.children.indexOf(child2);

    if(index1 < 0 || index2 < 0) {
        throw new Error('swapChildren: Both the supplied DisplayObjects must be a child of the caller.');
    }

    this.children[index1] = child2;
    this.children[index2] = child;
    
};

/**
 * Returns the child at the specified index
 *
 * @method getChildAt
 * @param index {Number} The index to get the child from
 */
PIXI.DisplayObjectContainer.prototype.getChildAt = function(index)
{
    if(index >= 0 && index < this.children.length)
    {
        return this.children[index];
    }
    else
    {
        throw new Error('Supplied index does not exist in the child list, or the supplied DisplayObject must be a child of the caller');
    }
};

/**
 * Removes a child from the container.
 *
 * @method removeChild
 * @param child {DisplayObject} The DisplayObject to remove
 */
PIXI.DisplayObjectContainer.prototype.removeChild = function(child)
{
    return this.removeChildAt( this.children.indexOf( child ) );
};

/**
 * Removes a child from the specified index position in the child list of the container.
 *
 * @method removeChildAt
 * @param index {Number} The index to get the child from
 */
PIXI.DisplayObjectContainer.prototype.removeChildAt = function(index)
{
    var child = this.getChildAt( index );
    if(this.stage)
        child.removeStageReference();

    child.parent = undefined;
    this.children.splice( index, 1 );
    return child;
};

/**
* Removes all child instances from the child list of the container.
*
* @method removeChildren
* @param beginIndex {Number} The beginning position. Predefined value is 0.
* @param endIndex {Number} The ending position. Predefined value is children's array length.
*/
PIXI.DisplayObjectContainer.prototype.removeChildren = function(beginIndex, endIndex)
{
    var begin = beginIndex || 0;
    var end = typeof endIndex === 'number' ? endIndex : this.children.length;
    var range = end - begin;

    if (range > 0 && range <= end)
    {
        var removed = this.children.splice(begin, range);
        for (var i = 0; i < removed.length; i++) {
            var child = removed[i];
            if(this.stage)
                child.removeStageReference();
            child.parent = undefined;
        }
        return removed;
    }
    else
    {
        throw new Error( 'Range Error, numeric values are outside the acceptable range' );
    }
};

/*
 * Updates the container's childrens transform for rendering
 *
 * @method updateTransform
 * @private
 */
PIXI.DisplayObjectContainer.prototype.updateTransform = function()
{
    //this._currentBounds = null;

    if(!this.visible)return;

    PIXI.DisplayObject.prototype.updateTransform.call( this );

    if(this._cacheAsBitmap)return;

    for(var i=0,j=this.children.length; i<j; i++)
    {
        this.children[i].updateTransform();
    }
};

/**
 * Retrieves the bounds of the displayObjectContainer as a rectangle object
 *
 * @method getBounds
 * @return {Rectangle} the rectangular bounding area
 */
PIXI.DisplayObjectContainer.prototype.getBounds = function(matrix)
{
    if(this.children.length === 0)return PIXI.EmptyRectangle;

    // TODO the bounds have already been calculated this render session so return what we have
    if(matrix)
    {
        var matrixCache = this.worldTransform;
        this.worldTransform = matrix;
        this.updateTransform();
        this.worldTransform = matrixCache;
    }

    var minX = Infinity;
    var minY = Infinity;

    var maxX = -Infinity;
    var maxY = -Infinity;

    var childBounds;
    var childMaxX;
    var childMaxY;

    var childVisible = false;

    for(var i=0,j=this.children.length; i<j; i++)
    {
        var child = this.children[i];
        
        if(!child.visible)continue;

        childVisible = true;

        childBounds = this.children[i].getBounds( matrix );
     
        minX = minX < childBounds.x ? minX : childBounds.x;
        minY = minY < childBounds.y ? minY : childBounds.y;

        childMaxX = childBounds.width + childBounds.x;
        childMaxY = childBounds.height + childBounds.y;

        maxX = maxX > childMaxX ? maxX : childMaxX;
        maxY = maxY > childMaxY ? maxY : childMaxY;
    }

    if(!childVisible)
        return PIXI.EmptyRectangle;

    var bounds = this._bounds;

    bounds.x = minX;
    bounds.y = minY;
    bounds.width = maxX - minX;
    bounds.height = maxY - minY;

    // TODO: store a reference so that if this function gets called again in the render cycle we do not have to recalculate
    //this._currentBounds = bounds;
   
    return bounds;
};

PIXI.DisplayObjectContainer.prototype.getLocalBounds = function()
{
    var matrixCache = this.worldTransform;

    this.worldTransform = PIXI.identityMatrix;

    for(var i=0,j=this.children.length; i<j; i++)
    {
        this.children[i].updateTransform();
    }

    var bounds = this.getBounds();

    this.worldTransform = matrixCache;

    return bounds;
};

/**
 * Sets the container's stage reference, the stage this object is connected to
 *
 * @method setStageReference
 * @param stage {Stage} the stage that the container will have as its current stage reference
 */
PIXI.DisplayObjectContainer.prototype.setStageReference = function(stage)
{
    this.stage = stage;
    if(this._interactive)this.stage.dirty = true;

    for(var i=0,j=this.children.length; i<j; i++)
    {
        var child = this.children[i];
        child.setStageReference(stage);
    }
};

/**
 * removes the current stage reference of the container
 *
 * @method removeStageReference
 */
PIXI.DisplayObjectContainer.prototype.removeStageReference = function()
{

    for(var i=0,j=this.children.length; i<j; i++)
    {
        var child = this.children[i];
        child.removeStageReference();
    }

    if(this._interactive)this.stage.dirty = true;
    
    this.stage = null;
};

/**
* Renders the object using the WebGL renderer
*
* @method _renderWebGL
* @param renderSession {RenderSession} 
* @private
*/
PIXI.DisplayObjectContainer.prototype._renderWebGL = function(renderSession)
{
    if(!this.visible || this.alpha <= 0)return;
    
    if(this._cacheAsBitmap)
    {
        this._renderCachedSprite(renderSession);
        return;
    }
    
    var i,j;

    if(this._mask || this._filters)
    {
        
        // push filter first as we need to ensure the stencil buffer is correct for any masking
        if(this._filters)
        {
            renderSession.spriteBatch.flush();
            renderSession.filterManager.pushFilter(this._filterBlock);
        }

        if(this._mask)
        {
            renderSession.spriteBatch.stop();
            renderSession.maskManager.pushMask(this.mask, renderSession);
            renderSession.spriteBatch.start();
        }

        // simple render children!
        for(i=0,j=this.children.length; i<j; i++)
        {
            this.children[i]._renderWebGL(renderSession);
        }

        renderSession.spriteBatch.stop();

        if(this._mask)renderSession.maskManager.popMask(this._mask, renderSession);
        if(this._filters)renderSession.filterManager.popFilter();
        
        renderSession.spriteBatch.start();
    }
    else
    {
        // simple render children!
        for(i=0,j=this.children.length; i<j; i++)
        {
            this.children[i]._renderWebGL(renderSession);
        }
    }
};

/**
* Renders the object using the Canvas renderer
*
* @method _renderCanvas
* @param renderSession {RenderSession} 
* @private
*/
PIXI.DisplayObjectContainer.prototype._renderCanvas = function(renderSession)
{
    if(this.visible === false || this.alpha === 0)return;

    if(this._cacheAsBitmap)
    {

        this._renderCachedSprite(renderSession);
        return;
    }

    if(this._mask)
    {
        renderSession.maskManager.pushMask(this._mask, renderSession.context);
    }

    for(var i=0,j=this.children.length; i<j; i++)
    {
        var child = this.children[i];
        child._renderCanvas(renderSession);
    }

    if(this._mask)
    {
        renderSession.maskManager.popMask(renderSession.context);
    }
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The Sprite object is the base for all textured objects that are rendered to the screen
 *
 * @class Sprite
 * @extends DisplayObjectContainer
 * @constructor
 * @param texture {Texture} The texture for this sprite
 * 
 * A sprite can be created directly from an image like this : 
 * var sprite = new PIXI.Sprite.fromImage('assets/image.png');
 * yourStage.addChild(sprite);
 * then obviously don't forget to add it to the stage you have already created
 */
PIXI.Sprite = function(texture)
{
    PIXI.DisplayObjectContainer.call( this );

    /**
     * The anchor sets the origin point of the texture.
     * The default is 0,0 this means the texture's origin is the top left
     * Setting than anchor to 0.5,0.5 means the textures origin is centred
     * Setting the anchor to 1,1 would mean the textures origin points will be the bottom right corner
     *
     * @property anchor
     * @type Point
     */
    this.anchor = new PIXI.Point();

    /**
     * The texture that the sprite is using
     *
     * @property texture
     * @type Texture
     */
    this.texture = texture;

    /**
     * The width of the sprite (this is initially set by the texture)
     *
     * @property _width
     * @type Number
     * @private
     */
    this._width = 0;

    /**
     * The height of the sprite (this is initially set by the texture)
     *
     * @property _height
     * @type Number
     * @private
     */
    this._height = 0;


    /**
     * The tint applied to the sprite. This is a hex value
     *
     * @property tint
     * @type Number
     * @default 0xFFFFFF
     */
    this.tint = 0xFFFFFF;// * Math.random();
    
    /**
     * The blend mode to be applied to the sprite
     *
     * @property blendMode
     * @type Number
     * @default PIXI.blendModes.NORMAL;
     */
    this.blendMode = PIXI.blendModes.NORMAL;

    if(texture.baseTexture.hasLoaded)
    {
        this.onTextureUpdate();
    }
    else
    {
        this.onTextureUpdateBind = this.onTextureUpdate.bind(this);
        this.texture.addEventListener( 'update', this.onTextureUpdateBind );
    }

    this.renderable = true;
};

// constructor
PIXI.Sprite.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );
PIXI.Sprite.prototype.constructor = PIXI.Sprite;

/**
 * The width of the sprite, setting this will actually modify the scale to achieve the value set
 *
 * @property width
 * @type Number
 */
Object.defineProperty(PIXI.Sprite.prototype, 'width', {
    get: function() {
        return this.scale.x * this.texture.frame.width;
    },
    set: function(value) {
        this.scale.x = value / this.texture.frame.width;
        this._width = value;
    }
});

/**
 * The height of the sprite, setting this will actually modify the scale to achieve the value set
 *
 * @property height
 * @type Number
 */
Object.defineProperty(PIXI.Sprite.prototype, 'height', {
    get: function() {
        return  this.scale.y * this.texture.frame.height;
    },
    set: function(value) {
        this.scale.y = value / this.texture.frame.height;
        this._height = value;
    }
});

/**
 * Sets the texture of the sprite
 *
 * @method setTexture
 * @param texture {Texture} The PIXI texture that is displayed by the sprite
 */
PIXI.Sprite.prototype.setTexture = function(texture)
{
    this.texture = texture;
    this.cachedTint = 0xFFFFFF;
};

/**
 * When the texture is updated, this event will fire to update the scale and frame
 *
 * @method onTextureUpdate
 * @param event
 * @private
 */
PIXI.Sprite.prototype.onTextureUpdate = function()
{
    // so if _width is 0 then width was not set..
    if(this._width)this.scale.x = this._width / this.texture.frame.width;
    if(this._height)this.scale.y = this._height / this.texture.frame.height;


    //this.updateFrame = true;
};

/**
* Returns the framing rectangle of the sprite as a PIXI.Rectangle object
*
* @method getBounds
* @param matrix {Matrix} the transformation matrix of the sprite
* @return {Rectangle} the framing rectangle
*/
PIXI.Sprite.prototype.getBounds = function(matrix)
{

    var width = this.texture.frame.width;
    var height = this.texture.frame.height;

    var w0 = width * (1-this.anchor.x);
    var w1 = width * -this.anchor.x;

    var h0 = height * (1-this.anchor.y);
    var h1 = height * -this.anchor.y;

    var worldTransform = matrix || this.worldTransform ;

    var a = worldTransform.a;
    var b = worldTransform.c;
    var c = worldTransform.b;
    var d = worldTransform.d;
    var tx = worldTransform.tx;
    var ty = worldTransform.ty;

    var x1 = a * w1 + c * h1 + tx;
    var y1 = d * h1 + b * w1 + ty;

    var x2 = a * w0 + c * h1 + tx;
    var y2 = d * h1 + b * w0 + ty;

    var x3 = a * w0 + c * h0 + tx;
    var y3 = d * h0 + b * w0 + ty;

    var x4 =  a * w1 + c * h0 + tx;
    var y4 =  d * h0 + b * w1 + ty;

    var maxX = -Infinity;
    var maxY = -Infinity;

    var minX = Infinity;
    var minY = Infinity;

    minX = x1 < minX ? x1 : minX;
    minX = x2 < minX ? x2 : minX;
    minX = x3 < minX ? x3 : minX;
    minX = x4 < minX ? x4 : minX;

    minY = y1 < minY ? y1 : minY;
    minY = y2 < minY ? y2 : minY;
    minY = y3 < minY ? y3 : minY;
    minY = y4 < minY ? y4 : minY;

    maxX = x1 > maxX ? x1 : maxX;
    maxX = x2 > maxX ? x2 : maxX;
    maxX = x3 > maxX ? x3 : maxX;
    maxX = x4 > maxX ? x4 : maxX;

    maxY = y1 > maxY ? y1 : maxY;
    maxY = y2 > maxY ? y2 : maxY;
    maxY = y3 > maxY ? y3 : maxY;
    maxY = y4 > maxY ? y4 : maxY;

    var bounds = this._bounds;

    bounds.x = minX;
    bounds.width = maxX - minX;

    bounds.y = minY;
    bounds.height = maxY - minY;

    // store a reference so that if this function gets called again in the render cycle we do not have to recalculate
    this._currentBounds = bounds;

    return bounds;
};

/**
* Renders the object using the WebGL renderer
*
* @method _renderWebGL
* @param renderSession {RenderSession} 
* @private
*/
PIXI.Sprite.prototype._renderWebGL = function(renderSession)
{
    // if the sprite is not visible or the alpha is 0 then no need to render this element
    if(!this.visible || this.alpha <= 0)return;
    
    var i,j;

    // do a quick check to see if this element has a mask or a filter.
    if(this._mask || this._filters)
    {
        var spriteBatch =  renderSession.spriteBatch;

        // push filter first as we need to ensure the stencil buffer is correct for any masking
        if(this._filters)
        {
            spriteBatch.flush();
            renderSession.filterManager.pushFilter(this._filterBlock);
        }

        if(this._mask)
        {
            spriteBatch.stop();
            renderSession.maskManager.pushMask(this.mask, renderSession);
            spriteBatch.start();
        }

        // add this sprite to the batch
        spriteBatch.render(this);

        // now loop through the children and make sure they get rendered
        for(i=0,j=this.children.length; i<j; i++)
        {
            this.children[i]._renderWebGL(renderSession);
        }

        // time to stop the sprite batch as either a mask element or a filter draw will happen next
        spriteBatch.stop();

        if(this._mask)renderSession.maskManager.popMask(this._mask, renderSession);
        if(this._filters)renderSession.filterManager.popFilter();
        
        spriteBatch.start();
    }
    else
    {
        renderSession.spriteBatch.render(this);

        // simple render children!
        for(i=0,j=this.children.length; i<j; i++)
        {
            this.children[i]._renderWebGL(renderSession);
        }
    }

   
    //TODO check culling  
};

/**
* Renders the object using the Canvas renderer
*
* @method _renderCanvas
* @param renderSession {RenderSession} 
* @private
*/
PIXI.Sprite.prototype._renderCanvas = function(renderSession)
{
    // If the sprite is not visible or the alpha is 0 then no need to render this element
    if (this.visible === false || this.alpha === 0) return;
    
    if (this.blendMode !== renderSession.currentBlendMode)
    {
        renderSession.currentBlendMode = this.blendMode;
        renderSession.context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];
    }

    if (this._mask)
    {
        renderSession.maskManager.pushMask(this._mask, renderSession.context);
    }

    //  Ignore null sources
    if (this.texture.valid)
    {
        renderSession.context.globalAlpha = this.worldAlpha;

        //  Allow for pixel rounding
        if (renderSession.roundPixels)
        {
            renderSession.context.setTransform(
                this.worldTransform.a,
                this.worldTransform.c,
                this.worldTransform.b,
                this.worldTransform.d,
                this.worldTransform.tx | 0,
                this.worldTransform.ty | 0);
        }
        else
        {
            renderSession.context.setTransform(
                this.worldTransform.a,
                this.worldTransform.c,
                this.worldTransform.b,
                this.worldTransform.d,
                this.worldTransform.tx,
                this.worldTransform.ty);
        }

        //  If smoothingEnabled is supported and we need to change the smoothing property for this texture
        if (renderSession.smoothProperty && renderSession.scaleMode !== this.texture.baseTexture.scaleMode)
        {
            renderSession.scaleMode = this.texture.baseTexture.scaleMode;
            renderSession.context[renderSession.smoothProperty] = (renderSession.scaleMode === PIXI.scaleModes.LINEAR);
        }

        //  If the texture is trimmed we offset by the trim x/y, otherwise we use the frame dimensions
        var dx = (this.texture.trim) ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width;
        var dy = (this.texture.trim) ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height;

        if (this.tint !== 0xFFFFFF)
        {
            if (this.cachedTint !== this.tint)
            {
                this.cachedTint = this.tint;
                
                //  TODO clean up caching - how to clean up the caches?
                this.tintedTexture = PIXI.CanvasTinter.getTintedTexture(this, this.tint);
            }

            renderSession.context.drawImage(
                                this.tintedTexture,
                                0,
                                0,
                                this.texture.crop.width,
                                this.texture.crop.height,
                                dx,
                                dy,
                                this.texture.crop.width,
                                this.texture.crop.height);
        }
        else
        {
            renderSession.context.drawImage(
                                this.texture.baseTexture.source,
                                this.texture.crop.x,
                                this.texture.crop.y,
                                this.texture.crop.width,
                                this.texture.crop.height,
                                dx,
                                dy,
                                this.texture.crop.width,
                                this.texture.crop.height);
        }
    }

    // OVERWRITE
    for (var i = 0, j = this.children.length; i < j; i++)
    {
        this.children[i]._renderCanvas(renderSession);
    }

    if (this._mask)
    {
        renderSession.maskManager.popMask(renderSession.context);
    }
};

// some helper functions..

/**
 *
 * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
 * The frame ids are created when a Texture packer file has been loaded
 *
 * @method fromFrame
 * @static
 * @param frameId {String} The frame Id of the texture in the cache
 * @return {Sprite} A new Sprite using a texture from the texture cache matching the frameId
 */
PIXI.Sprite.fromFrame = function(frameId)
{
    var texture = PIXI.TextureCache[frameId];
    if(!texture) throw new Error('The frameId "' + frameId + '" does not exist in the texture cache' + this);
    return new PIXI.Sprite(texture);
};

/**
 *
 * Helper function that creates a sprite that will contain a texture based on an image url
 * If the image is not in the texture cache it will be loaded
 *
 * @method fromImage
 * @static
 * @param imageId {String} The image url of the texture
 * @return {Sprite} A new Sprite using a texture from the texture cache matching the image id
 */
PIXI.Sprite.fromImage = function(imageId, crossorigin, scaleMode)
{
    var texture = PIXI.Texture.fromImage(imageId, crossorigin, scaleMode);
    return new PIXI.Sprite(texture);
};

/**
 * @author Mat Groves http://matgroves.com/
 */

/**
 * The SpriteBatch class is a really fast version of the DisplayObjectContainer 
 * built solely for speed, so use when you need a lot of sprites or particles.
 * And it's extremely easy to use : 

    var container = new PIXI.SpriteBatch();
 
    stage.addChild(container);
 
    for(var i  = 0; i < 100; i++)
    {
        var sprite = new PIXI.Sprite.fromImage("myImage.png");
        container.addChild(sprite);
    }
 * And here you have a hundred sprites that will be renderer at the speed of light
 *
 * @class SpriteBatch
 * @constructor
 * @param texture {Texture}
 */
PIXI.SpriteBatch = function(texture)
{
    PIXI.DisplayObjectContainer.call( this);

    this.textureThing = texture;

    this.ready = false;
};

PIXI.SpriteBatch.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
PIXI.SpriteBatch.constructor = PIXI.SpriteBatch;

/*
 * Initialises the spriteBatch
 *
 * @method initWebGL
 * @param gl {WebGLContext} the current WebGL drawing context
 */
PIXI.SpriteBatch.prototype.initWebGL = function(gl)
{
    // TODO only one needed for the whole engine really?
    this.fastSpriteBatch = new PIXI.WebGLFastSpriteBatch(gl);

    this.ready = true;
};

/*
 * Updates the object transform for rendering
 *
 * @method updateTransform
 * @private
 */
PIXI.SpriteBatch.prototype.updateTransform = function()
{
   // TODO dont need to!
    PIXI.DisplayObject.prototype.updateTransform.call( this );
  //  PIXI.DisplayObjectContainer.prototype.updateTransform.call( this );
};

/**
* Renders the object using the WebGL renderer
*
* @method _renderWebGL
* @param renderSession {RenderSession} 
* @private
*/
PIXI.SpriteBatch.prototype._renderWebGL = function(renderSession)
{
    if(!this.visible || this.alpha <= 0 || !this.children.length)return;

    if(!this.ready)this.initWebGL( renderSession.gl );
    
    renderSession.spriteBatch.stop();
    
    renderSession.shaderManager.setShader(renderSession.shaderManager.fastShader);
    
    this.fastSpriteBatch.begin(this, renderSession);
    this.fastSpriteBatch.render(this);

    renderSession.spriteBatch.start();
 
};

/**
* Renders the object using the Canvas renderer
*
* @method _renderCanvas
* @param renderSession {RenderSession} 
* @private
*/
PIXI.SpriteBatch.prototype._renderCanvas = function(renderSession)
{
    var context = renderSession.context;
    context.globalAlpha = this.worldAlpha;

    PIXI.DisplayObject.prototype.updateTransform.call(this);

    var transform = this.worldTransform;
    // alow for trimming
       
    var isRotated = true;

    for (var i = 0; i < this.children.length; i++) {
       
        var child = this.children[i];

        if(!child.visible)continue;

        var texture = child.texture;
        var frame = texture.frame;

        context.globalAlpha = this.worldAlpha * child.alpha;

        if(child.rotation % (Math.PI * 2) === 0)
        {
            if(isRotated)
            {
                context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);
                isRotated = false;
            }

            // this is the fastest  way to optimise! - if rotation is 0 then we can avoid any kind of setTransform call
            context.drawImage(texture.baseTexture.source,
                                 frame.x,
                                 frame.y,
                                 frame.width,
                                 frame.height,
                                 ((child.anchor.x) * (-frame.width * child.scale.x) + child.position.x  + 0.5) | 0,
                                 ((child.anchor.y) * (-frame.height * child.scale.y) + child.position.y  + 0.5) | 0,
                                 frame.width * child.scale.x,
                                 frame.height * child.scale.y);
        }
        else
        {
            if(!isRotated)isRotated = true;
    
            PIXI.DisplayObject.prototype.updateTransform.call(child);
           
            var childTransform = child.worldTransform;

            // allow for trimming
           
            if (renderSession.roundPixels)
            {
                context.setTransform(childTransform.a, childTransform.c, childTransform.b, childTransform.d, childTransform.tx | 0, childTransform.ty | 0);
            }
            else
            {
                context.setTransform(childTransform.a, childTransform.c, childTransform.b, childTransform.d, childTransform.tx, childTransform.ty);
            }

            context.drawImage(texture.baseTexture.source,
                                 frame.x,
                                 frame.y,
                                 frame.width,
                                 frame.height,
                                 ((child.anchor.x) * (-frame.width) + 0.5) | 0,
                                 ((child.anchor.y) * (-frame.height) + 0.5) | 0,
                                 frame.width,
                                 frame.height);
           

        }

       // context.restore();
    }

//    context.restore();
};


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * A MovieClip is a simple way to display an animation depicted by a list of textures.
 *
 * @class MovieClip
 * @extends Sprite
 * @constructor
 * @param textures {Array<Texture>} an array of {Texture} objects that make up the animation
 */
PIXI.MovieClip = function(textures)
{
    PIXI.Sprite.call(this, textures[0]);

    /**
     * The array of textures that make up the animation
     *
     * @property textures
     * @type Array
     */
    this.textures = textures;

    /**
     * The speed that the MovieClip will play at. Higher is faster, lower is slower
     *
     * @property animationSpeed
     * @type Number
     * @default 1
     */
    this.animationSpeed = 1;

    /**
     * Whether or not the movie clip repeats after playing.
     *
     * @property loop
     * @type Boolean
     * @default true
     */
    this.loop = true;

    /**
     * Function to call when a MovieClip finishes playing
     *
     * @property onComplete
     * @type Function
     */
    this.onComplete = null;

    /**
     * [read-only] The MovieClips current frame index (this may not have to be a whole number)
     *
     * @property currentFrame
     * @type Number
     * @default 0
     * @readOnly
     */
    this.currentFrame = 0;

    /**
     * [read-only] Indicates if the MovieClip is currently playing
     *
     * @property playing
     * @type Boolean
     * @readOnly
     */
    this.playing = false;
};

// constructor
PIXI.MovieClip.prototype = Object.create( PIXI.Sprite.prototype );
PIXI.MovieClip.prototype.constructor = PIXI.MovieClip;

/**
* [read-only] totalFrames is the total number of frames in the MovieClip. This is the same as number of textures
* assigned to the MovieClip.
*
* @property totalFrames
* @type Number
* @default 0
* @readOnly
*/
Object.defineProperty( PIXI.MovieClip.prototype, 'totalFrames', {
	get: function() {

		return this.textures.length;
	}
});


/**
 * Stops the MovieClip
 *
 * @method stop
 */
PIXI.MovieClip.prototype.stop = function()
{
    this.playing = false;
};

/**
 * Plays the MovieClip
 *
 * @method play
 */
PIXI.MovieClip.prototype.play = function()
{
    this.playing = true;
};

/**
 * Stops the MovieClip and goes to a specific frame
 *
 * @method gotoAndStop
 * @param frameNumber {Number} frame index to stop at
 */
PIXI.MovieClip.prototype.gotoAndStop = function(frameNumber)
{
    this.playing = false;
    this.currentFrame = frameNumber;
    var round = (this.currentFrame + 0.5) | 0;
    this.setTexture(this.textures[round % this.textures.length]);
};

/**
 * Goes to a specific frame and begins playing the MovieClip
 *
 * @method gotoAndPlay
 * @param frameNumber {Number} frame index to start at
 */
PIXI.MovieClip.prototype.gotoAndPlay = function(frameNumber)
{
    this.currentFrame = frameNumber;
    this.playing = true;
};

/*
 * Updates the object transform for rendering
 *
 * @method updateTransform
 * @private
 */
PIXI.MovieClip.prototype.updateTransform = function()
{
    PIXI.Sprite.prototype.updateTransform.call(this);

    if(!this.playing)return;

    this.currentFrame += this.animationSpeed;

    var round = (this.currentFrame + 0.5) | 0;

    this.currentFrame = this.currentFrame % this.textures.length;

    if(this.loop || round < this.textures.length)
    {
        this.setTexture(this.textures[round % this.textures.length]);
    }
    else if(round >= this.textures.length)
    {
        this.gotoAndStop(this.textures.length - 1);
        if(this.onComplete)
        {
            this.onComplete();
        }
    }
};

/**
 * A short hand way of creating a movieclip from an array of frame ids
 *
 * @static
 * @method fromFrames
 * @param frames {Array} the array of frames ids the movieclip will use as its texture frames
 */
PIXI.MovieClip.fromFrames = function(frames)
{
    var textures = [];

    for (var i = 0; i < frames.length; i++)
    {
        textures.push(new PIXI.Texture.fromFrame(frames[i]));
    }

    return new PIXI.MovieClip(textures);
};

/**
 * A short hand way of creating a movieclip from an array of image ids
 *
 * @static
 * @method fromFrames
 * @param frames {Array} the array of image ids the movieclip will use as its texture frames
 */
PIXI.MovieClip.fromImages = function(images)
{
    var textures = [];

    for (var i = 0; i < images.length; i++)
    {
        textures.push(new PIXI.Texture.fromImage(images[i]));
    }

    return new PIXI.MovieClip(textures);
};
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */


PIXI.FilterBlock = function()
{
    this.visible = true;
    this.renderable = true;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 * - Modified by Tom Slezakowski http://www.tomslezakowski.com @TomSlezakowski (24/03/2014) - Added dropShadowColor.
 */

/**
 * A Text Object will create a line(s) of text. To split a line you can use '\n' 
 * or add a wordWrap property set to true and and wordWrapWidth property with a value
 * in the style object
 *
 * @class Text
 * @extends Sprite
 * @constructor
 * @param text {String} The copy that you would like the text to display
 * @param [style] {Object} The style parameters
 * @param [style.font] {String} default 'bold 20px Arial' The style and size of the font
 * @param [style.fill='black'] {String|Number} A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'
 * @param [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
 * @param [style.stroke] {String|Number} A canvas fillstyle that will be used on the text stroke e.g 'blue', '#FCFF00'
 * @param [style.strokeThickness=0] {Number} A number that represents the thickness of the stroke. Default is 0 (no stroke)
 * @param [style.wordWrap=false] {Boolean} Indicates if word wrap should be used
 * @param [style.wordWrapWidth=100] {Number} The width at which text will wrap, it needs wordWrap to be set to true
 * @param [style.dropShadow=false] {Boolean} Set a drop shadow for the text
 * @param [style.dropShadowColor='#000000'] {String} A fill style to be used on the dropshadow e.g 'red', '#00FF00'
 * @param [style.dropShadowAngle=Math.PI/4] {Number} Set a angle of the drop shadow
 * @param [style.dropShadowDistance=5] {Number} Set a distance of the drop shadow
 */
PIXI.Text = function(text, style)
{
    /**
     * The canvas element that everything is drawn to
     *
     * @property canvas
     * @type HTMLCanvasElement
     */
    this.canvas = document.createElement('canvas');

    /**
     * The canvas 2d context that everything is drawn with
     * @property context
     * @type HTMLCanvasElement 2d Context
     */
    this.context = this.canvas.getContext('2d');

    PIXI.Sprite.call(this, PIXI.Texture.fromCanvas(this.canvas));

    this.setText(text);
    this.setStyle(style);
};

// constructor
PIXI.Text.prototype = Object.create(PIXI.Sprite.prototype);
PIXI.Text.prototype.constructor = PIXI.Text;


/**
 * The width of the sprite, setting this will actually modify the scale to achieve the value set
 *
 * @property width
 * @type Number
 */
Object.defineProperty(PIXI.Text.prototype, 'width', {
    get: function() {

        if(this.dirty)
        {
            this.updateText();
            this.dirty = false;
        }


        return this.scale.x * this.texture.frame.width;
    },
    set: function(value) {
        this.scale.x = value / this.texture.frame.width;
        this._width = value;
    }
});

/**
 * The height of the Text, setting this will actually modify the scale to achieve the value set
 *
 * @property height
 * @type Number
 */
Object.defineProperty(PIXI.Text.prototype, 'height', {
    get: function() {

        if(this.dirty)
        {
            this.updateText();
            this.dirty = false;
        }


        return  this.scale.y * this.texture.frame.height;
    },
    set: function(value) {
        this.scale.y = value / this.texture.frame.height;
        this._height = value;
    }
});


/**
 * Set the style of the text
 *
 * @method setStyle
 * @param [style] {Object} The style parameters
 * @param [style.font='bold 20pt Arial'] {String} The style and size of the font
 * @param [style.fill='black'] {Object} A canvas fillstyle that will be used on the text eg 'red', '#00FF00'
 * @param [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
 * @param [style.stroke='black'] {String} A canvas fillstyle that will be used on the text stroke eg 'blue', '#FCFF00'
 * @param [style.strokeThickness=0] {Number} A number that represents the thickness of the stroke. Default is 0 (no stroke)
 * @param [style.wordWrap=false] {Boolean} Indicates if word wrap should be used
 * @param [style.wordWrapWidth=100] {Number} The width at which text will wrap
 * @param [style.dropShadow=false] {Boolean} Set a drop shadow for the text
 * @param [style.dropShadowColor='#000000'] {String} A fill style to be used on the dropshadow e.g 'red', '#00FF00'
 * @param [style.dropShadowAngle=Math.PI/4] {Number} Set a angle of the drop shadow
 * @param [style.dropShadowDistance=5] {Number} Set a distance of the drop shadow
 */
PIXI.Text.prototype.setStyle = function(style)
{
    style = style || {};
    style.font = style.font || 'bold 20pt Arial';
    style.fill = style.fill || 'black';
    style.align = style.align || 'left';
    style.stroke = style.stroke || 'black'; //provide a default, see: https://github.com/GoodBoyDigital/pixi.js/issues/136
    style.strokeThickness = style.strokeThickness || 0;
    style.wordWrap = style.wordWrap || false;
    style.wordWrapWidth = style.wordWrapWidth || 100;
    style.wordWrapWidth = style.wordWrapWidth || 100;
    
    style.dropShadow = style.dropShadow || false;
    style.dropShadowAngle = style.dropShadowAngle || Math.PI / 6;
    style.dropShadowDistance = style.dropShadowDistance || 4;
    style.dropShadowColor = style.dropShadowColor || 'black';

    this.style = style;
    this.dirty = true;
};

/**
 * Set the copy for the text object. To split a line you can use '\n'
 *
 * @method setText
 * @param {String} text The copy that you would like the text to display
 */
PIXI.Text.prototype.setText = function(text)
{
    this.text = text.toString() || ' ';
    this.dirty = true;

};

/**
 * Renders text and updates it when needed
 *
 * @method updateText
 * @private
 */
PIXI.Text.prototype.updateText = function()
{
    this.context.font = this.style.font;

    var outputText = this.text;

    // word wrap
    // preserve original text
    if(this.style.wordWrap)outputText = this.wordWrap(this.text);

    //split text into lines
    var lines = outputText.split(/(?:\r\n|\r|\n)/);

    //calculate text width
    var lineWidths = [];
    var maxLineWidth = 0;
    for (var i = 0; i < lines.length; i++)
    {
        var lineWidth = this.context.measureText(lines[i]).width;
        lineWidths[i] = lineWidth;
        maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }

    var width = maxLineWidth + this.style.strokeThickness;
    if(this.style.dropShadow)width += this.style.dropShadowDistance;

    this.canvas.width = width + this.context.lineWidth;
    //calculate text height
    var lineHeight = this.determineFontHeight('font: ' + this.style.font  + ';') + this.style.strokeThickness;
    
    var height = lineHeight * lines.length;
    if(this.style.dropShadow)height += this.style.dropShadowDistance;

    this.canvas.height = height;

    if(navigator.isCocoonJS) this.context.clearRect(0,0,this.canvas.width,this.canvas.height);
    
    this.context.font = this.style.font;
    this.context.strokeStyle = this.style.stroke;
    this.context.lineWidth = this.style.strokeThickness;
    this.context.textBaseline = 'top';

    var linePositionX;
    var linePositionY;

    if(this.style.dropShadow)
    {
        this.context.fillStyle = this.style.dropShadowColor;

        var xShadowOffset = Math.sin(this.style.dropShadowAngle) * this.style.dropShadowDistance;
        var yShadowOffset = Math.cos(this.style.dropShadowAngle) * this.style.dropShadowDistance;

        for (i = 0; i < lines.length; i++)
        {
            linePositionX = this.style.strokeThickness / 2;
            linePositionY = this.style.strokeThickness / 2 + i * lineHeight;

            if(this.style.align === 'right')
            {
                linePositionX += maxLineWidth - lineWidths[i];
            }
            else if(this.style.align === 'center')
            {
                linePositionX += (maxLineWidth - lineWidths[i]) / 2;
            }

            if(this.style.fill)
            {
                this.context.fillText(lines[i], linePositionX + xShadowOffset, linePositionY + yShadowOffset);
            }

          //  if(dropShadow)
        }
    }

    //set canvas text styles
    this.context.fillStyle = this.style.fill;
    
    //draw lines line by line
    for (i = 0; i < lines.length; i++)
    {
        linePositionX = this.style.strokeThickness / 2;
        linePositionY = this.style.strokeThickness / 2 + i * lineHeight;

        if(this.style.align === 'right')
        {
            linePositionX += maxLineWidth - lineWidths[i];
        }
        else if(this.style.align === 'center')
        {
            linePositionX += (maxLineWidth - lineWidths[i]) / 2;
        }

        if(this.style.stroke && this.style.strokeThickness)
        {
            this.context.strokeText(lines[i], linePositionX, linePositionY);
        }

        if(this.style.fill)
        {
            this.context.fillText(lines[i], linePositionX, linePositionY);
        }

      //  if(dropShadow)
    }


    this.updateTexture();
};

/**
 * Updates texture size based on canvas size
 *
 * @method updateTexture
 * @private
 */
PIXI.Text.prototype.updateTexture = function()
{
    this.texture.baseTexture.width = this.canvas.width;
    this.texture.baseTexture.height = this.canvas.height;
    this.texture.crop.width = this.texture.frame.width = this.canvas.width;
    this.texture.crop.height = this.texture.frame.height = this.canvas.height;

    this._width = this.canvas.width;
    this._height = this.canvas.height;

    this.requiresUpdate =  true;
};

/**
* Renders the object using the WebGL renderer
*
* @method _renderWebGL
* @param renderSession {RenderSession} 
* @private
*/
PIXI.Text.prototype._renderWebGL = function(renderSession)
{
    if(this.requiresUpdate)
    {
        this.requiresUpdate = false;
        PIXI.updateWebGLTexture(this.texture.baseTexture, renderSession.gl);
    }

    PIXI.Sprite.prototype._renderWebGL.call(this, renderSession);
};

/**
 * Updates the transform of this object
 *
 * @method updateTransform
 * @private
 */
PIXI.Text.prototype.updateTransform = function()
{
    if(this.dirty)
    {
        this.updateText();
        this.dirty = false;
    }

    PIXI.Sprite.prototype.updateTransform.call(this);
};

/*
 * http://stackoverflow.com/users/34441/ellisbben
 * great solution to the problem!
 * returns the height of the given font
 *
 * @method determineFontHeight
 * @param fontStyle {Object}
 * @private
 */
PIXI.Text.prototype.determineFontHeight = function(fontStyle)
{
    // build a little reference dictionary so if the font style has been used return a
    // cached version...
    var result = PIXI.Text.heightCache[fontStyle];

    if(!result)
    {
        var body = document.getElementsByTagName('body')[0];
        var dummy = document.createElement('div');
        var dummyText = document.createTextNode('M');
        dummy.appendChild(dummyText);
        dummy.setAttribute('style', fontStyle + ';position:absolute;top:0;left:0');
        body.appendChild(dummy);

        result = dummy.offsetHeight;
        PIXI.Text.heightCache[fontStyle] = result;

        body.removeChild(dummy);
    }

    return result;
};

/**
 * Applies newlines to a string to have it optimally fit into the horizontal
 * bounds set by the Text object's wordWrapWidth property.
 *
 * @method wordWrap
 * @param text {String}
 * @private
 */
PIXI.Text.prototype.wordWrap = function(text)
{
    // Greedy wrapping algorithm that will wrap words as the line grows longer
    // than its horizontal bounds.
    var result = '';
    var lines = text.split('\n');
    for (var i = 0; i < lines.length; i++)
    {
        var spaceLeft = this.style.wordWrapWidth;
        var words = lines[i].split(' ');
        for (var j = 0; j < words.length; j++)
        {
            var wordWidth = this.context.measureText(words[j]).width;
            var wordWidthWithSpace = wordWidth + this.context.measureText(' ').width;
            if(j === 0 || wordWidthWithSpace > spaceLeft)
            {
                // Skip printing the newline if it's the first word of the line that is
                // greater than the word wrap width.
                if(j > 0)
                {
                    result += '\n';
                }
                result += words[j];
                spaceLeft = this.style.wordWrapWidth - wordWidth;
            }
            else
            {
                spaceLeft -= wordWidthWithSpace;
                result += ' ' + words[j];
            }
        }

        if (i < lines.length-1)
        {
            result += '\n';
        }
    }
    return result;
};

/**
 * Destroys this text object
 *
 * @method destroy
 * @param destroyBaseTexture {Boolean} whether to destroy the base texture as well
 */
PIXI.Text.prototype.destroy = function(destroyBaseTexture)
{
    // make sure to reset the the context and canvas.. dont want this hanging around in memory!
    this.context = null;
    this.canvas = null;

    this.texture.destroy(destroyBaseTexture === undefined ? true : destroyBaseTexture);
};

PIXI.Text.heightCache = {};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * A Text Object will create a line(s) of text using bitmap font. To split a line you can use '\n', '\r' or '\r\n'
 * You can generate the fnt files using
 * http://www.angelcode.com/products/bmfont/ for windows or
 * http://www.bmglyph.com/ for mac.
 *
 * @class BitmapText
 * @extends DisplayObjectContainer
 * @constructor
 * @param text {String} The copy that you would like the text to display
 * @param style {Object} The style parameters
 * @param style.font {String} The size (optional) and bitmap font id (required) eq 'Arial' or '20px Arial' (must have loaded previously)
 * @param [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
 */
PIXI.BitmapText = function(text, style)
{
    PIXI.DisplayObjectContainer.call(this);

    this._pool = [];

    this.setText(text);
    this.setStyle(style);
    this.updateText();
    this.dirty = false;
};

// constructor
PIXI.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
PIXI.BitmapText.prototype.constructor = PIXI.BitmapText;

/**
 * Set the copy for the text object
 *
 * @method setText
 * @param text {String} The copy that you would like the text to display
 */
PIXI.BitmapText.prototype.setText = function(text)
{
    this.text = text || ' ';
    this.dirty = true;
};

/**
 * Set the style of the text
 * style.font {String} The size (optional) and bitmap font id (required) eq 'Arial' or '20px Arial' (must have loaded previously)
 * [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
 *
 * @method setStyle
 * @param style {Object} The style parameters, contained as properties of an object
 */
PIXI.BitmapText.prototype.setStyle = function(style)
{
    style = style || {};
    style.align = style.align || 'left';
    this.style = style;

    var font = style.font.split(' ');
    this.fontName = font[font.length - 1];
    this.fontSize = font.length >= 2 ? parseInt(font[font.length - 2], 10) : PIXI.BitmapText.fonts[this.fontName].size;

    this.dirty = true;
    this.tint = style.tint;
};

/**
 * Renders text and updates it when needed
 *
 * @method updateText
 * @private
 */
PIXI.BitmapText.prototype.updateText = function()
{
    var data = PIXI.BitmapText.fonts[this.fontName];
    var pos = new PIXI.Point();
    var prevCharCode = null;
    var chars = [];
    var maxLineWidth = 0;
    var lineWidths = [];
    var line = 0;
    var scale = this.fontSize / data.size;
    

    for(var i = 0; i < this.text.length; i++)
    {
        var charCode = this.text.charCodeAt(i);
        if(/(?:\r\n|\r|\n)/.test(this.text.charAt(i)))
        {
            lineWidths.push(pos.x);
            maxLineWidth = Math.max(maxLineWidth, pos.x);
            line++;

            pos.x = 0;
            pos.y += data.lineHeight;
            prevCharCode = null;
            continue;
        }

        var charData = data.chars[charCode];
        if(!charData) continue;

        if(prevCharCode && charData[prevCharCode])
        {
            pos.x += charData.kerning[prevCharCode];
        }
        chars.push({texture:charData.texture, line: line, charCode: charCode, position: new PIXI.Point(pos.x + charData.xOffset, pos.y + charData.yOffset)});
        pos.x += charData.xAdvance;

        prevCharCode = charCode;
    }

    lineWidths.push(pos.x);
    maxLineWidth = Math.max(maxLineWidth, pos.x);

    var lineAlignOffsets = [];
    for(i = 0; i <= line; i++)
    {
        var alignOffset = 0;
        if(this.style.align === 'right')
        {
            alignOffset = maxLineWidth - lineWidths[i];
        }
        else if(this.style.align === 'center')
        {
            alignOffset = (maxLineWidth - lineWidths[i]) / 2;
        }
        lineAlignOffsets.push(alignOffset);
    }

    var lenChildren = this.children.length;
    var lenChars = chars.length;
    var tint = this.tint || 0xFFFFFF;
    for(i = 0; i < lenChars; i++)
    {
        var c = i < lenChildren ? this.children[i] : this._pool.pop(); // get old child if have. if not - take from pool.

        if (c) c.setTexture(chars[i].texture); // check if got one before.
        else c = new PIXI.Sprite(chars[i].texture); // if no create new one.

        c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale;
        c.position.y = chars[i].position.y * scale;
        c.scale.x = c.scale.y = scale;
        c.tint = tint;
        if (!c.parent) this.addChild(c);
    }

    // remove unnecessary children.
    // and put their into the pool.
    while(this.children.length > lenChars)
    {
        var child = this.getChildAt(this.children.length - 1);
        this._pool.push(child);
        this.removeChild(child);
    }


    /**
     * [read-only] The width of the overall text, different from fontSize,
     * which is defined in the style object
     *
     * @property textWidth
     * @type Number
     */
    this.textWidth = maxLineWidth * scale;

    /**
     * [read-only] The height of the overall text, different from fontSize,
     * which is defined in the style object
     *
     * @property textHeight
     * @type Number
     */
    this.textHeight = (pos.y + data.lineHeight) * scale;
};

/**
 * Updates the transform of this object
 *
 * @method updateTransform
 * @private
 */
PIXI.BitmapText.prototype.updateTransform = function()
{
    if(this.dirty)
    {
        this.updateText();
        this.dirty = false;
    }

    PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
};

PIXI.BitmapText.fonts = {};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */
 
/**
 * Holds all information related to an Interaction event
 *
 * @class InteractionData
 * @constructor
 */
PIXI.InteractionData = function()
{
    /**
     * This point stores the global coords of where the touch/mouse event happened
     *
     * @property global
     * @type Point
     */
    this.global = new PIXI.Point();

   
    /**
     * The target Sprite that was interacted with
     *
     * @property target
     * @type Sprite
     */
    this.target = null;

    /**
     * When passed to an event handler, this will be the original DOM Event that was captured
     *
     * @property originalEvent
     * @type Event
     */
    this.originalEvent = null;
};

/**
 * This will return the local coordinates of the specified displayObject for this InteractionData
 *
 * @method getLocalPosition
 * @param displayObject {DisplayObject} The DisplayObject that you would like the local coords off
 * @return {Point} A point containing the coordinates of the InteractionData position relative to the DisplayObject
 */
PIXI.InteractionData.prototype.getLocalPosition = function(displayObject)
{
    var worldTransform = displayObject.worldTransform;
    var global = this.global;

    // do a cheeky transform to get the mouse coords;
    var a00 = worldTransform.a, a01 = worldTransform.b, a02 = worldTransform.tx,
        a10 = worldTransform.c, a11 = worldTransform.d, a12 = worldTransform.ty,
        id = 1 / (a00 * a11 + a01 * -a10);
    // set the mouse coords...
    return new PIXI.Point(a11 * id * global.x + -a01 * id * global.y + (a12 * a01 - a02 * a11) * id,
                               a00 * id * global.y + -a10 * id * global.x + (-a12 * a00 + a02 * a10) * id);
};

// constructor
PIXI.InteractionData.prototype.constructor = PIXI.InteractionData;
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

 /**
 * The interaction manager deals with mouse and touch events. Any DisplayObject can be interactive
 * if its interactive parameter is set to true
 * This manager also supports multitouch.
 *
 * @class InteractionManager
 * @constructor
 * @param stage {Stage} The stage to handle interactions
 */
PIXI.InteractionManager = function(stage)
{
    /**
     * a reference to the stage
     *
     * @property stage
     * @type Stage
     */
    this.stage = stage;

    /**
     * the mouse data
     *
     * @property mouse
     * @type InteractionData
     */
    this.mouse = new PIXI.InteractionData();

    /**
     * an object that stores current touches (InteractionData) by id reference
     *
     * @property touchs
     * @type Object
     */
    this.touchs = {};

    // helpers
    this.tempPoint = new PIXI.Point();

    /**
     * 
     * @property mouseoverEnabled
     * @type Boolean
     * @default
     */
    this.mouseoverEnabled = true;

    /**
     * tiny little interactiveData pool !
     * 
     * @property pool
     * @type Array
     */
    this.pool = [];

    /**
     * An array containing all the iterative items from the our interactive tree
     * @property interactiveItems
     * @type Array
     * @private
     *
     */
    this.interactiveItems = [];

    /**
     * Our canvas
     * @property interactionDOMElement
     * @type HTMLCanvasElement
     * @private
     */
    this.interactionDOMElement = null;

    //this will make it so that you dont have to call bind all the time
    this.onMouseMove = this.onMouseMove.bind( this );
    this.onMouseDown = this.onMouseDown.bind(this);
    this.onMouseOut = this.onMouseOut.bind(this);
    this.onMouseUp = this.onMouseUp.bind(this);

    this.onTouchStart = this.onTouchStart.bind(this);
    this.onTouchEnd = this.onTouchEnd.bind(this);
    this.onTouchMove = this.onTouchMove.bind(this);

    this.last = 0;

    /**
     * The css style of the cursor that is being used
     * @property currentCursorStyle
     * @type String
     *
     */
    this.currentCursorStyle = 'inherit';

    /**
     * Is set to true when the mouse is moved out of the canvas
     * @property mouseOut
     * @type Boolean
     *
     */
    this.mouseOut = false;
};

// constructor
PIXI.InteractionManager.prototype.constructor = PIXI.InteractionManager;

/**
 * Collects an interactive sprite recursively to have their interactions managed
 *
 * @method collectInteractiveSprite
 * @param displayObject {DisplayObject} the displayObject to collect
 * @param iParent {DisplayObject} the display object's parent
 * @private
 */
PIXI.InteractionManager.prototype.collectInteractiveSprite = function(displayObject, iParent)
{
    var children = displayObject.children;
    var length = children.length;

    // make an interaction tree... {item.__interactiveParent}
    for (var i = length-1; i >= 0; i--)
    {
        var child = children[i];

        // push all interactive bits
        if(child._interactive)
        {
            iParent.interactiveChildren = true;
            //child.__iParent = iParent;
            this.interactiveItems.push(child);

            if(child.children.length > 0)
            {
                this.collectInteractiveSprite(child, child);
            }
        }
        else
        {
            child.__iParent = null;

            if(child.children.length > 0)
            {
                this.collectInteractiveSprite(child, iParent);
            }
        }

    }
};

/**
 * Sets the target for event delegation
 *
 * @method setTarget
 * @param target {WebGLRenderer|CanvasRenderer} the renderer to bind events to
 * @private
 */
PIXI.InteractionManager.prototype.setTarget = function(target)
{
    this.target = target;

    //check if the dom element has been set. If it has don't do anything
    if( this.interactionDOMElement === null ) {

        this.setTargetDomElement( target.view );
    }

    
};


/**
 * Sets the DOM element which will receive mouse/touch events. This is useful for when you have other DOM
 * elements on top of the renderers Canvas element. With this you'll be able to delegate another DOM element
 * to receive those events
 *
 * @method setTargetDomElement
 * @param domElement {DOMElement} the DOM element which will receive mouse and touch events
 * @private
 */
PIXI.InteractionManager.prototype.setTargetDomElement = function(domElement)
{

    this.removeEvents();


    if (window.navigator.msPointerEnabled)
    {
        // time to remove some of that zoom in ja..
        domElement.style['-ms-content-zooming'] = 'none';
        domElement.style['-ms-touch-action'] = 'none';

        // DO some window specific touch!
    }

    this.interactionDOMElement = domElement;

    domElement.addEventListener('mousemove',  this.onMouseMove, true);
    domElement.addEventListener('mousedown',  this.onMouseDown, true);
    domElement.addEventListener('mouseout',   this.onMouseOut, true);

    // aint no multi touch just yet!
    domElement.addEventListener('touchstart', this.onTouchStart, true);
    domElement.addEventListener('touchend', this.onTouchEnd, true);
    domElement.addEventListener('touchmove', this.onTouchMove, true);

    window.addEventListener('mouseup',  this.onMouseUp, true);
};


PIXI.InteractionManager.prototype.removeEvents = function()
{
    if(!this.interactionDOMElement)return;

    this.interactionDOMElement.style['-ms-content-zooming'] = '';
    this.interactionDOMElement.style['-ms-touch-action'] = '';

    this.interactionDOMElement.removeEventListener('mousemove',  this.onMouseMove, true);
    this.interactionDOMElement.removeEventListener('mousedown',  this.onMouseDown, true);
    this.interactionDOMElement.removeEventListener('mouseout',   this.onMouseOut, true);

    // aint no multi touch just yet!
    this.interactionDOMElement.removeEventListener('touchstart', this.onTouchStart, true);
    this.interactionDOMElement.removeEventListener('touchend', this.onTouchEnd, true);
    this.interactionDOMElement.removeEventListener('touchmove', this.onTouchMove, true);

    this.interactionDOMElement = null;

    window.removeEventListener('mouseup',  this.onMouseUp, true);
};

/**
 * updates the state of interactive objects
 *
 * @method update
 * @private
 */
PIXI.InteractionManager.prototype.update = function()
{
    if(!this.target)return;

    // frequency of 30fps??
    var now = Date.now();
    var diff = now - this.last;
    diff = (diff * PIXI.INTERACTION_FREQUENCY ) / 1000;
    if(diff < 1)return;
    this.last = now;

    var i = 0;

    // ok.. so mouse events??
    // yes for now :)
    // OPTIMISE - how often to check??
    if(this.dirty)
    {
        this.rebuildInteractiveGraph();
    }

    // loop through interactive objects!
    var length = this.interactiveItems.length;
    var cursor = 'inherit';
    var over = false;

    for (i = 0; i < length; i++)
    {
        var item = this.interactiveItems[i];

        // OPTIMISATION - only calculate every time if the mousemove function exists..
        // OK so.. does the object have any other interactive functions?
        // hit-test the clip!
       // if(item.mouseover || item.mouseout || item.buttonMode)
       // {
        // ok so there are some functions so lets hit test it..
        item.__hit = this.hitTest(item, this.mouse);
        this.mouse.target = item;
        // ok so deal with interactions..
        // looks like there was a hit!
        if(item.__hit && !over)
        {
            if(item.buttonMode) cursor = item.defaultCursor;

            if(!item.interactiveChildren)over = true;

            if(!item.__isOver)
            {
                if(item.mouseover)item.mouseover(this.mouse);
                item.__isOver = true;
            }
        }
        else
        {
            if(item.__isOver)
            {
                // roll out!
                if(item.mouseout)item.mouseout(this.mouse);
                item.__isOver = false;
            }
        }
    }

    if( this.currentCursorStyle !== cursor )
    {
        this.currentCursorStyle = cursor;
        this.interactionDOMElement.style.cursor = cursor;
    }
};

PIXI.InteractionManager.prototype.rebuildInteractiveGraph = function()
{
    this.dirty = false;

    var len = this.interactiveItems.length;

    for (var i = 0; i < len; i++) {
        this.interactiveItems[i].interactiveChildren = false;
    }

    this.interactiveItems = [];

    if(this.stage.interactive)this.interactiveItems.push(this.stage);
    // go through and collect all the objects that are interactive..
    this.collectInteractiveSprite(this.stage, this.stage);
};

/**
 * Is called when the mouse moves across the renderer element
 *
 * @method onMouseMove
 * @param event {Event} The DOM event of the mouse moving
 * @private
 */
PIXI.InteractionManager.prototype.onMouseMove = function(event)
{
    if(this.dirty)
    {
        this.rebuildInteractiveGraph();
    }

    this.mouse.originalEvent = event || window.event; //IE uses window.event
    // TODO optimize by not check EVERY TIME! maybe half as often? //
    var rect = this.interactionDOMElement.getBoundingClientRect();

    this.mouse.global.x = (event.clientX - rect.left) * (this.target.width / rect.width);
    this.mouse.global.y = (event.clientY - rect.top) * ( this.target.height / rect.height);

    var length = this.interactiveItems.length;

    for (var i = 0; i < length; i++)
    {
        var item = this.interactiveItems[i];

        if(item.mousemove)
        {
            //call the function!
            item.mousemove(this.mouse);
        }
    }
};

/**
 * Is called when the mouse button is pressed down on the renderer element
 *
 * @method onMouseDown
 * @param event {Event} The DOM event of a mouse button being pressed down
 * @private
 */
PIXI.InteractionManager.prototype.onMouseDown = function(event)
{
    if(this.dirty)
    {
        this.rebuildInteractiveGraph();
    }

    this.mouse.originalEvent = event || window.event; //IE uses window.event

    if(PIXI.AUTO_PREVENT_DEFAULT)this.mouse.originalEvent.preventDefault();

    // loop through interaction tree...
    // hit test each item! ->
    // get interactive items under point??
    //stage.__i
    var length = this.interactiveItems.length;

    // while
    // hit test
    for (var i = 0; i < length; i++)
    {
        var item = this.interactiveItems[i];

        if(item.mousedown || item.click)
        {
            item.__mouseIsDown = true;
            item.__hit = this.hitTest(item, this.mouse);

            if(item.__hit)
            {
                //call the function!
                if(item.mousedown)item.mousedown(this.mouse);
                item.__isDown = true;

                // just the one!
                if(!item.interactiveChildren)break;
            }
        }
    }
};

/**
 * Is called when the mouse button is moved out of the renderer element
 *
 * @method onMouseOut
 * @param event {Event} The DOM event of a mouse button being moved out
 * @private 
 */
PIXI.InteractionManager.prototype.onMouseOut = function()
{
    if(this.dirty)
    {
        this.rebuildInteractiveGraph();
    }

    var length = this.interactiveItems.length;

    this.interactionDOMElement.style.cursor = 'inherit';

    for (var i = 0; i < length; i++)
    {
        var item = this.interactiveItems[i];
        if(item.__isOver)
        {
            this.mouse.target = item;
            if(item.mouseout)item.mouseout(this.mouse);
            item.__isOver = false;
        }
    }

    this.mouseOut = true;

    // move the mouse to an impossible position
    this.mouse.global.x = -10000;
    this.mouse.global.y = -10000;
};

/**
 * Is called when the mouse button is released on the renderer element
 *
 * @method onMouseUp
 * @param event {Event} The DOM event of a mouse button being released
 * @private
 */
PIXI.InteractionManager.prototype.onMouseUp = function(event)
{
    if(this.dirty)
    {
        this.rebuildInteractiveGraph();
    }

    this.mouse.originalEvent = event || window.event; //IE uses window.event

    var length = this.interactiveItems.length;
    var up = false;

    for (var i = 0; i < length; i++)
    {
        var item = this.interactiveItems[i];

        item.__hit = this.hitTest(item, this.mouse);

        if(item.__hit && !up)
        {
            //call the function!
            if(item.mouseup)
            {
                item.mouseup(this.mouse);
            }
            if(item.__isDown)
            {
                if(item.click)item.click(this.mouse);
            }

            if(!item.interactiveChildren)up = true;
        }
        else
        {
            if(item.__isDown)
            {
                if(item.mouseupoutside)item.mouseupoutside(this.mouse);
            }
        }

        item.__isDown = false;
        //}
    }
};

/**
 * Tests if the current mouse coordinates hit a sprite
 *
 * @method hitTest
 * @param item {DisplayObject} The displayObject to test for a hit
 * @param interactionData {InteractionData} The interactionData object to update in the case there is a hit
 * @private
 */
PIXI.InteractionManager.prototype.hitTest = function(item, interactionData)
{
    var global = interactionData.global;

    if( !item.worldVisible )return false;

    // temp fix for if the element is in a non visible
   
    var isSprite = (item instanceof PIXI.Sprite),
        worldTransform = item.worldTransform,
        a00 = worldTransform.a, a01 = worldTransform.b, a02 = worldTransform.tx,
        a10 = worldTransform.c, a11 = worldTransform.d, a12 = worldTransform.ty,
        id = 1 / (a00 * a11 + a01 * -a10),
        x = a11 * id * global.x + -a01 * id * global.y + (a12 * a01 - a02 * a11) * id,
        y = a00 * id * global.y + -a10 * id * global.x + (-a12 * a00 + a02 * a10) * id;

    interactionData.target = item;

    //a sprite or display object with a hit area defined
    if(item.hitArea && item.hitArea.contains) {
        if(item.hitArea.contains(x, y)) {
            //if(isSprite)
            interactionData.target = item;

            return true;
        }

        return false;
    }
    // a sprite with no hitarea defined
    else if(isSprite)
    {
        var width = item.texture.frame.width,
            height = item.texture.frame.height,
            x1 = -width * item.anchor.x,
            y1;

        if(x > x1 && x < x1 + width)
        {
            y1 = -height * item.anchor.y;

            if(y > y1 && y < y1 + height)
            {
                // set the target property if a hit is true!
                interactionData.target = item;
                return true;
            }
        }
    }

    var length = item.children.length;

    for (var i = 0; i < length; i++)
    {
        var tempItem = item.children[i];
        var hit = this.hitTest(tempItem, interactionData);
        if(hit)
        {
            // hmm.. TODO SET CORRECT TARGET?
            interactionData.target = item;
            return true;
        }
    }

    return false;
};

/**
 * Is called when a touch is moved across the renderer element
 *
 * @method onTouchMove
 * @param event {Event} The DOM event of a touch moving across the renderer view
 * @private
 */
PIXI.InteractionManager.prototype.onTouchMove = function(event)
{
    if(this.dirty)
    {
        this.rebuildInteractiveGraph();
    }

    var rect = this.interactionDOMElement.getBoundingClientRect();
    var changedTouches = event.changedTouches;
    var touchData;
    var i = 0;

    for (i = 0; i < changedTouches.length; i++)
    {
        var touchEvent = changedTouches[i];
        touchData = this.touchs[touchEvent.identifier];
        touchData.originalEvent =  event || window.event;

        // update the touch position
        touchData.global.x = (touchEvent.clientX - rect.left) * (this.target.width / rect.width);
        touchData.global.y = (touchEvent.clientY - rect.top)  * (this.target.height / rect.height);
        if(navigator.isCocoonJS) {
            touchData.global.x = touchEvent.clientX;
            touchData.global.y = touchEvent.clientY;
        }

        for (var j = 0; j < this.interactiveItems.length; j++)
        {
            var item = this.interactiveItems[j];
            if(item.touchmove && item.__touchData && item.__touchData[touchEvent.identifier]) item.touchmove(touchData);
        }
    }
};

/**
 * Is called when a touch is started on the renderer element
 *
 * @method onTouchStart
 * @param event {Event} The DOM event of a touch starting on the renderer view
 * @private
 */
PIXI.InteractionManager.prototype.onTouchStart = function(event)
{
    if(this.dirty)
    {
        this.rebuildInteractiveGraph();
    }

    var rect = this.interactionDOMElement.getBoundingClientRect();

    if(PIXI.AUTO_PREVENT_DEFAULT)event.preventDefault();
    
    var changedTouches = event.changedTouches;
    for (var i=0; i < changedTouches.length; i++)
    {
        var touchEvent = changedTouches[i];

        var touchData = this.pool.pop();
        if(!touchData)touchData = new PIXI.InteractionData();

        touchData.originalEvent =  event || window.event;

        this.touchs[touchEvent.identifier] = touchData;
        touchData.global.x = (touchEvent.clientX - rect.left) * (this.target.width / rect.width);
        touchData.global.y = (touchEvent.clientY - rect.top)  * (this.target.height / rect.height);
        if(navigator.isCocoonJS) {
            touchData.global.x = touchEvent.clientX;
            touchData.global.y = touchEvent.clientY;
        }

        var length = this.interactiveItems.length;

        for (var j = 0; j < length; j++)
        {
            var item = this.interactiveItems[j];

            if(item.touchstart || item.tap)
            {
                item.__hit = this.hitTest(item, touchData);

                if(item.__hit)
                {
                    //call the function!
                    if(item.touchstart)item.touchstart(touchData);
                    item.__isDown = true;
                    item.__touchData = item.__touchData || {};
                    item.__touchData[touchEvent.identifier] = touchData;

                    if(!item.interactiveChildren)break;
                }
            }
        }
    }
};

/**
 * Is called when a touch is ended on the renderer element
 *
 * @method onTouchEnd
 * @param event {Event} The DOM event of a touch ending on the renderer view
 * @private
 */
PIXI.InteractionManager.prototype.onTouchEnd = function(event)
{
    if(this.dirty)
    {
        this.rebuildInteractiveGraph();
    }
    
    //this.mouse.originalEvent = event || window.event; //IE uses window.event
    var rect = this.interactionDOMElement.getBoundingClientRect();
    var changedTouches = event.changedTouches;

    for (var i=0; i < changedTouches.length; i++)
    {
        var touchEvent = changedTouches[i];
        var touchData = this.touchs[touchEvent.identifier];
        var up = false;
        touchData.global.x = (touchEvent.clientX - rect.left) * (this.target.width / rect.width);
        touchData.global.y = (touchEvent.clientY - rect.top)  * (this.target.height / rect.height);
        if(navigator.isCocoonJS) {
            touchData.global.x = touchEvent.clientX;
            touchData.global.y = touchEvent.clientY;
        }

        var length = this.interactiveItems.length;
        for (var j = 0; j < length; j++)
        {
            var item = this.interactiveItems[j];

            if(item.__touchData && item.__touchData[touchEvent.identifier]) {

                item.__hit = this.hitTest(item, item.__touchData[touchEvent.identifier]);

                // so this one WAS down...
                touchData.originalEvent = event || window.event;
                // hitTest??

                if(item.touchend || item.tap)
                {
                    if(item.__hit && !up)
                    {
                        if(item.touchend)item.touchend(touchData);
                        if(item.__isDown)
                        {
                            if(item.tap)item.tap(touchData);
                        }

                        if(!item.interactiveChildren)up = true;
                    }
                    else
                    {
                        if(item.__isDown)
                        {
                            if(item.touchendoutside)item.touchendoutside(touchData);
                        }
                    }

                    item.__isDown = false;
                }

                item.__touchData[touchEvent.identifier] = null;
            }
        }
        // remove the touch..
        this.pool.push(touchData);
        this.touchs[touchEvent.identifier] = null;
    }
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * A Stage represents the root of the display tree. Everything connected to the stage is rendered
 *
 * @class Stage
 * @extends DisplayObjectContainer
 * @constructor
 * @param backgroundColor {Number} the background color of the stage, you have to pass this in is in hex format
 *      like: 0xFFFFFF for white
 * 
 * Creating a stage is a mandatory process when you use Pixi, which is as simple as this : 
 * var stage = new PIXI.Stage(0xFFFFFF);
 * where the parameter given is the background colour of the stage, in hex
 * you will use this stage instance to add your sprites to it and therefore to the renderer
 * Here is how to add a sprite to the stage : 
 * stage.addChild(sprite);
 */
PIXI.Stage = function(backgroundColor)
{
    PIXI.DisplayObjectContainer.call( this );

    /**
     * [read-only] Current transform of the object based on world (parent) factors
     *
     * @property worldTransform
     * @type Mat3
     * @readOnly
     * @private
     */
    this.worldTransform = new PIXI.Matrix();

    /**
     * Whether or not the stage is interactive
     *
     * @property interactive
     * @type Boolean
     */
    this.interactive = true;

    /**
     * The interaction manage for this stage, manages all interactive activity on the stage
     *
     * @property interactionManager
     * @type InteractionManager
     */
    this.interactionManager = new PIXI.InteractionManager(this);

    /**
     * Whether the stage is dirty and needs to have interactions updated
     *
     * @property dirty
     * @type Boolean
     * @private
     */
    this.dirty = true;

    //the stage is its own stage
    this.stage = this;

    //optimize hit detection a bit
    this.stage.hitArea = new PIXI.Rectangle(0,0,100000, 100000);

    this.setBackgroundColor(backgroundColor);
};

// constructor
PIXI.Stage.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );
PIXI.Stage.prototype.constructor = PIXI.Stage;

/**
 * Sets another DOM element which can receive mouse/touch interactions instead of the default Canvas element.
 * This is useful for when you have other DOM elements on top of the Canvas element.
 *
 * @method setInteractionDelegate
 * @param domElement {DOMElement} This new domElement which will receive mouse/touch events
 */
PIXI.Stage.prototype.setInteractionDelegate = function(domElement)
{
    this.interactionManager.setTargetDomElement( domElement );
};

/*
 * Updates the object transform for rendering
 *
 * @method updateTransform
 * @private
 */
PIXI.Stage.prototype.updateTransform = function()
{
    this.worldAlpha = 1;

    for(var i=0,j=this.children.length; i<j; i++)
    {
        this.children[i].updateTransform();
    }

    if(this.dirty)
    {
        this.dirty = false;
        // update interactive!
        this.interactionManager.dirty = true;
    }

    if(this.interactive)this.interactionManager.update();
};

/**
 * Sets the background color for the stage
 *
 * @method setBackgroundColor
 * @param backgroundColor {Number} the color of the background, easiest way to pass this in is in hex format
 *      like: 0xFFFFFF for white
 */
PIXI.Stage.prototype.setBackgroundColor = function(backgroundColor)
{
    this.backgroundColor = backgroundColor || 0x000000;
    this.backgroundColorSplit = PIXI.hex2rgb(this.backgroundColor);
    var hex = this.backgroundColor.toString(16);
    hex = '000000'.substr(0, 6 - hex.length) + hex;
    this.backgroundColorString = '#' + hex;
};

/**
 * This will return the point containing global coords of the mouse.
 *
 * @method getMousePosition
 * @return {Point} The point containing the coords of the global InteractionData position.
 */
PIXI.Stage.prototype.getMousePosition = function()
{
    return this.interactionManager.mouse.global;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */
 
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel

// MIT license

/**
 * A polyfill for requestAnimationFrame
 * You can actually use both requestAnimationFrame and requestAnimFrame, 
 * you will still benefit from the polyfill
 *
 * @method requestAnimationFrame
 */
/**
 * A polyfill for cancelAnimationFrame
 *
 * @method cancelAnimationFrame
 */
var lastTime = 0;
var vendors = ['ms', 'moz', 'webkit', 'o'];
for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||
        window[vendors[x] + 'CancelRequestAnimationFrame'];
}

if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function(callback) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function() { callback(currTime + timeToCall); },
          timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };
}

if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function(id) {
        clearTimeout(id);
    };
}

window.requestAnimFrame = window.requestAnimationFrame;

/**
 * Converts a hex color number to an [R, G, B] array
 *
 * @method hex2rgb
 * @param hex {Number}
 */
PIXI.hex2rgb = function(hex) {
    return [(hex >> 16 & 0xFF) / 255, ( hex >> 8 & 0xFF) / 255, (hex & 0xFF)/ 255];
};

/**
 * Converts a color as an [R, G, B] array to a hex number
 *
 * @method rgb2hex
 * @param rgb {Array}
 */
PIXI.rgb2hex = function(rgb) {
    return ((rgb[0]*255 << 16) + (rgb[1]*255 << 8) + rgb[2]*255);
};

/**
 * A polyfill for Function.prototype.bind
 *
 * @method bind
 */
if (typeof Function.prototype.bind !== 'function') {
    Function.prototype.bind = (function () {
        var slice = Array.prototype.slice;
        return function (thisArg) {
            var target = this, boundArgs = slice.call(arguments, 1);

            if (typeof target !== 'function') throw new TypeError();

            function bound() {
                var args = boundArgs.concat(slice.call(arguments));
                target.apply(this instanceof bound ? this : thisArg, args);
            }

            bound.prototype = (function F(proto) {
                if (proto) F.prototype = proto;
                if (!(this instanceof F)) return new F();
            })(target.prototype);

            return bound;
        };
    })();
}

/**
 * A wrapper for ajax requests to be handled cross browser
 *
 * @class AjaxRequest
 * @constructor
 */
PIXI.AjaxRequest = function()
{
    var activexmodes = ['Msxml2.XMLHTTP.6.0', 'Msxml2.XMLHTTP.3.0', 'Microsoft.XMLHTTP']; //activeX versions to check for in IE

    if (window.ActiveXObject)
    { //Test for support for ActiveXObject in IE first (as XMLHttpRequest in IE7 is broken)
        for (var i=0; i<activexmodes.length; i++)
        {
            try{
                return new window.ActiveXObject(activexmodes[i]);
            }
            catch(e) {
                //suppress error
            }
        }
    }
    else if (window.XMLHttpRequest) // if Mozilla, Safari etc
    {
        return new window.XMLHttpRequest();
    }
    else
    {
        return false;
    }
};
/*
PIXI.packColorRGBA = function(r, g, b, a)//r, g, b, a)
{
  //  console.log(r, b, c, d)
  return (Math.floor((r)*63) << 18) | (Math.floor((g)*63) << 12) | (Math.floor((b)*63) << 6);// | (Math.floor((a)*63))
  //  i = i | (Math.floor((a)*63));
   // return i;
   // var r = (i / 262144.0 ) / 64;
   // var g = (i / 4096.0)%64 / 64;
  //  var b = (i / 64.0)%64 / 64;
  //  var a = (i)%64 / 64;
     
  //  console.log(r, g, b, a);
  //  return i;

};
*/
/*
PIXI.packColorRGB = function(r, g, b)//r, g, b, a)
{
    return (Math.floor((r)*255) << 16) | (Math.floor((g)*255) << 8) | (Math.floor((b)*255));
};

PIXI.unpackColorRGB = function(r, g, b)//r, g, b, a)
{
    return (Math.floor((r)*255) << 16) | (Math.floor((g)*255) << 8) | (Math.floor((b)*255));
};
*/

/**
 * Checks whether the Canvas BlendModes are supported by the current browser
 *
 * @method canUseNewCanvasBlendModes
 * @return {Boolean} whether they are supported
 */
PIXI.canUseNewCanvasBlendModes = function()
{
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    var context = canvas.getContext('2d');
    context.fillStyle = '#000';
    context.fillRect(0,0,1,1);
    context.globalCompositeOperation = 'multiply';
    context.fillStyle = '#fff';
    context.fillRect(0,0,1,1);
    return context.getImageData(0,0,1,1).data[0] === 0;
};

/**
 * Given a number, this function returns the closest number that is a power of two
 * this function is taken from Starling Framework as its pretty neat ;)
 *
 * @method getNextPowerOfTwo
 * @param number {Number}
 * @return {Number} the closest number that is a power of two
 */
PIXI.getNextPowerOfTwo = function(number)
{
    if (number > 0 && (number & (number - 1)) === 0) // see: http://goo.gl/D9kPj
        return number;
    else
    {
        var result = 1;
        while (result < number) result <<= 1;
        return result;
    }
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */
 
/**
 * https://github.com/mrdoob/eventtarget.js/
 * THankS mr DOob!
 */

/**
 * Adds event emitter functionality to a class
 *
 * @class EventTarget
 * @example
 *      function MyEmitter() {
 *          PIXI.EventTarget.call(this); //mixes in event target stuff
 *      }
 *
 *      var em = new MyEmitter();
 *      em.emit({ type: 'eventName', data: 'some data' });
 */
PIXI.EventTarget = function () {

    /**
     * Holds all the listeners
     *
     * @property listeners
     * @type Object
     */
    var listeners = {};

    /**
     * Adds a listener for a specific event
     *
     * @method addEventListener
     * @param type {string} A string representing the event type to listen for.
     * @param listener {function} The callback function that will be fired when the event occurs
     */
    this.addEventListener = this.on = function ( type, listener ) {


        if ( listeners[ type ] === undefined ) {

            listeners[ type ] = [];

        }

        if ( listeners[ type ].indexOf( listener ) === - 1 ) {

            listeners[ type ].unshift( listener );
        }

    };

    /**
     * Fires the event, ie pretends that the event has happened
     *
     * @method dispatchEvent
     * @param event {Event} the event object
     */
    this.dispatchEvent = this.emit = function ( event ) {

        if ( !listeners[ event.type ] || !listeners[ event.type ].length ) {

            return;

        }


        for(var i = listeners[ event.type ].length-1; i >= 0; i--) {
//        for(var i = 0, l=listeners[ event.type ].length; i < l; i++) {


            listeners[ event.type ][ i ]( event );

        }

    };

    /**
     * Removes the specified listener that was assigned to the specified event type
     *
     * @method removeEventListener
     * @param type {string} A string representing the event type which will have its listener removed
     * @param listener {function} The callback function that was be fired when the event occured
     */
    this.removeEventListener = this.off = function ( type, listener ) {

        if ( listeners[ type ] === undefined ) return;

        var index = listeners[ type ].indexOf( listener );

        if ( index !== - 1 ) {

            listeners[ type ].splice( index, 1 );

        }

    };

    /**
     * Removes all the listeners that were active for the specified event type
     *
     * @method removeAllEventListeners
     * @param type {string} A string representing the event type which will have all its listeners removed
     */
	this.removeAllEventListeners = function( type ) {
		var a = listeners[type];
		if (a)
			a.length = 0;
	};
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * This helper function will automatically detect which renderer you should be using.
 * WebGL is the preferred renderer as it is a lot faster. If webGL is not supported by
 * the browser then this function will return a canvas renderer
 * @class autoDetectRenderer
 * @static
 * @param width=800 {Number} the width of the renderers view
 * @param height=600 {Number} the height of the renderers view
 * @param [view] {Canvas} the canvas to use as a view, optional 
 * @param [transparent=false] {Boolean} the transparency of the render view, default false
 * @param [antialias=false] {Boolean} sets antialias (only applicable in webGL chrome at the moment)
 *
 */
PIXI.autoDetectRenderer = function(width, height, view, transparent, antialias)
{
    if(!width)width = 800;
    if(!height)height = 600;

    // BORROWED from Mr Doob (mrdoob.com)
    var webgl = ( function () { try {
                                    var canvas = document.createElement( 'canvas' );
                                    return !! window.WebGLRenderingContext && ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) );
                                } catch( e ) {
                                    return false;
                                }
                            } )();

    if( webgl )
    {
        return new PIXI.WebGLRenderer(width, height, view, transparent, antialias);
    }

    return  new PIXI.CanvasRenderer(width, height, view, transparent);
};

/**
 * This helper function will automatically detect which renderer you should be using.
 * This function is very similar to the autoDetectRenderer function except that is will return a canvas renderer for android.
 * Even thought both android chrome suports webGL the canvas implementation perform better at the time of writing. 
 * This function will likely change and update as webGL performance imporoves on thease devices.
 * @class getRecommendedRenderer
 * @static
 * @param width=800 {Number} the width of the renderers view
 * @param height=600 {Number} the height of the renderers view
 * @param [view] {Canvas} the canvas to use as a view, optional 
 * @param [transparent=false] {Boolean} the transparency of the render view, default false
 * @param [antialias=false] {Boolean} sets antialias (only applicable in webGL chrome at the moment)
 *
 */
PIXI.autoDetectRecommendedRenderer = function(width, height, view, transparent, antialias)
{
    if(!width)width = 800;
    if(!height)height = 600;

    // BORROWED from Mr Doob (mrdoob.com)
    var webgl = ( function () { try {
                                    var canvas = document.createElement( 'canvas' );
                                    return !! window.WebGLRenderingContext && ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) );
                                } catch( e ) {
                                    return false;
                                }
                            } )();

    var isAndroid = /Android/i.test(navigator.userAgent);

    if( webgl && !isAndroid)
    {
        return new PIXI.WebGLRenderer(width, height, view, transparent, antialias);
    }

    return  new PIXI.CanvasRenderer(width, height, view, transparent);
};

/*
    PolyK library
    url: http://polyk.ivank.net
    Released under MIT licence.

    Copyright (c) 2012 Ivan Kuckir

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.

    This is an amazing lib!

    slightly modified by Mat Groves (matgroves.com);
*/

/**
 * Based on the Polyk library http://polyk.ivank.net released under MIT licence.
 * This is an amazing lib!
 * slightly modified by Mat Groves (matgroves.com);
 * @class PolyK
 *
 */
PIXI.PolyK = {};

/**
 * Triangulates shapes for webGL graphic fills
 *
 * @method Triangulate
 * 
 */
PIXI.PolyK.Triangulate = function(p)
{
    var sign = true;

    var n = p.length >> 1;
    if(n < 3) return [];

    var tgs = [];
    var avl = [];
    for(var i = 0; i < n; i++) avl.push(i);

    i = 0;
    var al = n;
    while(al > 3)
    {
        var i0 = avl[(i+0)%al];
        var i1 = avl[(i+1)%al];
        var i2 = avl[(i+2)%al];

        var ax = p[2*i0],  ay = p[2*i0+1];
        var bx = p[2*i1],  by = p[2*i1+1];
        var cx = p[2*i2],  cy = p[2*i2+1];

        var earFound = false;
        if(PIXI.PolyK._convex(ax, ay, bx, by, cx, cy, sign))
        {
            earFound = true;
            for(var j = 0; j < al; j++)
            {
                var vi = avl[j];
                if(vi === i0 || vi === i1 || vi === i2) continue;

                if(PIXI.PolyK._PointInTriangle(p[2*vi], p[2*vi+1], ax, ay, bx, by, cx, cy)) {
                    earFound = false;
                    break;
                }
            }
        }

        if(earFound)
        {
            tgs.push(i0, i1, i2);
            avl.splice((i+1)%al, 1);
            al--;
            i = 0;
        }
        else if(i++ > 3*al)
        {
            // need to flip flip reverse it!
            // reset!
            if(sign)
            {
                tgs = [];
                avl = [];
                for(i = 0; i < n; i++) avl.push(i);

                i = 0;
                al = n;

                sign = false;
            }
            else
            {
                window.console.log("PIXI Warning: shape too complex to fill");
                return [];
            }
        }
    }

    tgs.push(avl[0], avl[1], avl[2]);
    return tgs;
};

/**
 * Checks whether a point is within a triangle
 *
 * @method _PointInTriangle
 * @param px {Number} x coordinate of the point to test
 * @param py {Number} y coordinate of the point to test
 * @param ax {Number} x coordinate of the a point of the triangle
 * @param ay {Number} y coordinate of the a point of the triangle
 * @param bx {Number} x coordinate of the b point of the triangle
 * @param by {Number} y coordinate of the b point of the triangle
 * @param cx {Number} x coordinate of the c point of the triangle
 * @param cy {Number} y coordinate of the c point of the triangle
 * @private
 */
PIXI.PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy)
{
    var v0x = cx-ax;
    var v0y = cy-ay;
    var v1x = bx-ax;
    var v1y = by-ay;
    var v2x = px-ax;
    var v2y = py-ay;

    var dot00 = v0x*v0x+v0y*v0y;
    var dot01 = v0x*v1x+v0y*v1y;
    var dot02 = v0x*v2x+v0y*v2y;
    var dot11 = v1x*v1x+v1y*v1y;
    var dot12 = v1x*v2x+v1y*v2y;

    var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
    var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

    // Check if point is in triangle
    return (u >= 0) && (v >= 0) && (u + v < 1);
};

/**
 * Checks whether a shape is convex
 *
 * @method _convex
 * 
 * @private
 */
PIXI.PolyK._convex = function(ax, ay, bx, by, cx, cy, sign)
{
    return ((ay-by)*(cx-bx) + (bx-ax)*(cy-by) >= 0) === sign;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

// TODO Alvin and Mat
// Should we eventually create a Utils class ? 
// Or just move this file to the pixi.js file ?
PIXI.initDefaultShaders = function()
{
   
  //  PIXI.stripShader = new PIXI.StripShader();
//    PIXI.stripShader.init();

};

PIXI.CompileVertexShader = function(gl, shaderSrc)
{
    return PIXI._CompileShader(gl, shaderSrc, gl.VERTEX_SHADER);
};

PIXI.CompileFragmentShader = function(gl, shaderSrc)
{
    return PIXI._CompileShader(gl, shaderSrc, gl.FRAGMENT_SHADER);
};

PIXI._CompileShader = function(gl, shaderSrc, shaderType)
{
    var src = shaderSrc.join("\n");
    var shader = gl.createShader(shaderType);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        window.console.log(gl.getShaderInfoLog(shader));
        return null;
    }

    return shader;
};

PIXI.compileProgram = function(gl, vertexSrc, fragmentSrc)
{
    var fragmentShader = PIXI.CompileFragmentShader(gl, fragmentSrc);
    var vertexShader = PIXI.CompileVertexShader(gl, vertexSrc);

    var shaderProgram = gl.createProgram();

    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        window.console.log("Could not initialise shaders");
    }

    return shaderProgram;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 * @author Richard Davey http://www.photonstorm.com @photonstorm
 */

/**
* @class PixiShader
* @constructor
*/
PIXI.PixiShader = function(gl)
{
    this._UID = PIXI._UID++;
    
    /**
     * @property gl
     * @type WebGLContext
     */
    this.gl = gl;

    /**
    * @property {any} program - The WebGL program.
    */
    this.program = null;

    /**
    * @property {array} fragmentSrc - The fragment shader.
    */
    this.fragmentSrc = [
        'precision lowp float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform sampler2D uSampler;',
        'void main(void) {',
        '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',
        '}'
    ];

    /**
    * @property {number} textureCount - A local texture counter for multi-texture shaders.
    */
    this.textureCount = 0;

    this.attributes = [];

    this.init();
};

/**
* Initialises the shader
* @method init
*
*/
PIXI.PixiShader.prototype.init = function()
{
    var gl = this.gl;

    var program = PIXI.compileProgram(gl, this.vertexSrc || PIXI.PixiShader.defaultVertexSrc, this.fragmentSrc);
    
    gl.useProgram(program);

    // get and store the uniforms for the shader
    this.uSampler = gl.getUniformLocation(program, 'uSampler');
    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');
    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');
    this.dimensions = gl.getUniformLocation(program, 'dimensions');

    // get and store the attributes
    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');
    this.colorAttribute = gl.getAttribLocation(program, 'aColor');


    // Begin worst hack eva //

    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?
    // maybe its something to do with the current state of the gl context.
    // Im convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel
    // If theres any webGL people that know why could happen please help :)
    if(this.colorAttribute === -1)
    {
        this.colorAttribute = 2;
    }

    this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute];

    // End worst hack eva //

    // add those custom shaders!
    for (var key in this.uniforms)
    {
        // get the uniform locations..
        this.uniforms[key].uniformLocation = gl.getUniformLocation(program, key);
    }

    this.initUniforms();

    this.program = program;
};

/**
* Initialises the shader uniform values.
* Uniforms are specified in the GLSL_ES Specification: http://www.khronos.org/registry/webgl/specs/latest/1.0/
* http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf
*
* @method initUniforms
*/
PIXI.PixiShader.prototype.initUniforms = function()
{
    this.textureCount = 1;
    var gl = this.gl;
    var uniform;

    for (var key in this.uniforms)
    {
        uniform = this.uniforms[key];

        var type = uniform.type;

        if (type === 'sampler2D')
        {
            uniform._init = false;

            if (uniform.value !== null)
            {
                this.initSampler2D(uniform);
            }
        }
        else if (type === 'mat2' || type === 'mat3' || type === 'mat4')
        {
            //  These require special handling
            uniform.glMatrix = true;
            uniform.glValueLength = 1;

            if (type === 'mat2')
            {
                uniform.glFunc = gl.uniformMatrix2fv;
            }
            else if (type === 'mat3')
            {
                uniform.glFunc = gl.uniformMatrix3fv;
            }
            else if (type === 'mat4')
            {
                uniform.glFunc = gl.uniformMatrix4fv;
            }
        }
        else
        {
            //  GL function reference
            uniform.glFunc = gl['uniform' + type];

            if (type === '2f' || type === '2i')
            {
                uniform.glValueLength = 2;
            }
            else if (type === '3f' || type === '3i')
            {
                uniform.glValueLength = 3;
            }
            else if (type === '4f' || type === '4i')
            {
                uniform.glValueLength = 4;
            }
            else
            {
                uniform.glValueLength = 1;
            }
        }
    }

};

/**
* Initialises a Sampler2D uniform (which may only be available later on after initUniforms once the texture has loaded)
*
* @method initSampler2D
*/
PIXI.PixiShader.prototype.initSampler2D = function(uniform)
{
    if (!uniform.value || !uniform.value.baseTexture || !uniform.value.baseTexture.hasLoaded)
    {
        return;
    }

    var gl = this.gl;

    gl.activeTexture(gl['TEXTURE' + this.textureCount]);
    gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id]);

    //  Extended texture data
    if (uniform.textureData)
    {
        var data = uniform.textureData;

        // GLTexture = mag linear, min linear_mipmap_linear, wrap repeat + gl.generateMipmap(gl.TEXTURE_2D);
        // GLTextureLinear = mag/min linear, wrap clamp
        // GLTextureNearestRepeat = mag/min NEAREST, wrap repeat
        // GLTextureNearest = mag/min nearest, wrap clamp
        // AudioTexture = whatever + luminance + width 512, height 2, border 0
        // KeyTexture = whatever + luminance + width 256, height 2, border 0

        //  magFilter can be: gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR or gl.NEAREST
        //  wrapS/T can be: gl.CLAMP_TO_EDGE or gl.REPEAT

        var magFilter = (data.magFilter) ? data.magFilter : gl.LINEAR;
        var minFilter = (data.minFilter) ? data.minFilter : gl.LINEAR;
        var wrapS = (data.wrapS) ? data.wrapS : gl.CLAMP_TO_EDGE;
        var wrapT = (data.wrapT) ? data.wrapT : gl.CLAMP_TO_EDGE;
        var format = (data.luminance) ? gl.LUMINANCE : gl.RGBA;

        if (data.repeat)
        {
            wrapS = gl.REPEAT;
            wrapT = gl.REPEAT;
        }

        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY);

        if (data.width)
        {
            var width = (data.width) ? data.width : 512;
            var height = (data.height) ? data.height : 2;
            var border = (data.border) ? data.border : 0;

            // void texImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels);
            gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null);
        }
        else
        {
            //  void texImage2D(GLenum target, GLint level, GLenum internalformat, GLenum format, GLenum type, ImageData? pixels);
            gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.value.baseTexture.source);
        }

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
    }

    gl.uniform1i(uniform.uniformLocation, this.textureCount);

    uniform._init = true;

    this.textureCount++;

};

/**
* Updates the shader uniform values.
*
* @method syncUniforms
*/
PIXI.PixiShader.prototype.syncUniforms = function()
{
    this.textureCount = 1;
    var uniform;
    var gl = this.gl;

    //  This would probably be faster in an array and it would guarantee key order
    for (var key in this.uniforms)
    {
        uniform = this.uniforms[key];

        if (uniform.glValueLength === 1)
        {
            if (uniform.glMatrix === true)
            {
                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.transpose, uniform.value);
            }
            else
            {
                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value);
            }
        }
        else if (uniform.glValueLength === 2)
        {
            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y);
        }
        else if (uniform.glValueLength === 3)
        {
            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z);
        }
        else if (uniform.glValueLength === 4)
        {
            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z, uniform.value.w);
        }
        else if (uniform.type === 'sampler2D')
        {
            if (uniform._init)
            {
                gl.activeTexture(gl['TEXTURE' + this.textureCount]);
                gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id] || PIXI.createWebGLTexture( uniform.value.baseTexture, gl));
                gl.uniform1i(uniform.uniformLocation, this.textureCount);
                this.textureCount++;
            }
            else
            {
                this.initSampler2D(uniform);
            }
        }
    }

};

/**
* Destroys the shader
* @method destroy
*/
PIXI.PixiShader.prototype.destroy = function()
{
    this.gl.deleteProgram( this.program );
    this.uniforms = null;
    this.gl = null;

    this.attributes = null;
};

/**
* The Default Vertex shader source
* @property defaultVertexSrc
* @type String
*/
PIXI.PixiShader.defaultVertexSrc = [
    'attribute vec2 aVertexPosition;',
    'attribute vec2 aTextureCoord;',
    'attribute vec2 aColor;',

    'uniform vec2 projectionVector;',
    'uniform vec2 offsetVector;',

    'varying vec2 vTextureCoord;',
    'varying vec4 vColor;',

    'const vec2 center = vec2(-1.0, 1.0);',

    'void main(void) {',
    '   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);',
    '   vTextureCoord = aTextureCoord;',
    '   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;',
    '   vColor = vec4(color * aColor.x, aColor.x);',
    '}'
];

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 * @author Richard Davey http://www.photonstorm.com @photonstorm
 */

/**
* @class PixiFastShader
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.PixiFastShader = function(gl)
{
    this._UID = PIXI._UID++;
    
    /**
     * @property gl
     * @type WebGLContext
     */
    this.gl = gl;

    /**
     * @property {any} program - The WebGL program.
     */
    this.program = null;

    /**
     * @property {array} fragmentSrc - The fragment shader.
     */
    this.fragmentSrc = [
        'precision lowp float;',
        'varying vec2 vTextureCoord;',
        'varying float vColor;',
        'uniform sampler2D uSampler;',
        'void main(void) {',
        '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',
        '}'
    ];

    /**
    * @property {array} vertexSrc - The vertex shader
    */
    this.vertexSrc = [
        'attribute vec2 aVertexPosition;',
        'attribute vec2 aPositionCoord;',
        'attribute vec2 aScale;',
        'attribute float aRotation;',
        'attribute vec2 aTextureCoord;',
        'attribute float aColor;',

        'uniform vec2 projectionVector;',
        'uniform vec2 offsetVector;',
        'uniform mat3 uMatrix;',

        'varying vec2 vTextureCoord;',
        'varying float vColor;',

        'const vec2 center = vec2(-1.0, 1.0);',

        'void main(void) {',
        '   vec2 v;',
        '   vec2 sv = aVertexPosition * aScale;',
        '   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);',
        '   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);',
        '   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;',
        '   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);',
        '   vTextureCoord = aTextureCoord;',
      //  '   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;',
        '   vColor = aColor;',
        '}'
    ];


    /**
    * @property {number} textureCount - A local texture counter for multi-texture shaders.
    */
    this.textureCount = 0;

    
    this.init();
};

/**
* Initialises the shader
* @method init
*
*/
PIXI.PixiFastShader.prototype.init = function()
{

    var gl = this.gl;

    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
    
    gl.useProgram(program);

    // get and store the uniforms for the shader
    this.uSampler = gl.getUniformLocation(program, 'uSampler');

    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');
    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');
    this.dimensions = gl.getUniformLocation(program, 'dimensions');
    this.uMatrix = gl.getUniformLocation(program, 'uMatrix');

    // get and store the attributes
    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
    this.aPositionCoord = gl.getAttribLocation(program, 'aPositionCoord');

    this.aScale = gl.getAttribLocation(program, 'aScale');
    this.aRotation = gl.getAttribLocation(program, 'aRotation');

    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');
    this.colorAttribute = gl.getAttribLocation(program, 'aColor');
   

   
    // Begin worst hack eva //

    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?
    // maybe its somthing to do with the current state of the gl context.
    // Im convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel
    // If theres any webGL people that know why could happen please help :)
    if(this.colorAttribute === -1)
    {
        this.colorAttribute = 2;
    }

    this.attributes = [this.aVertexPosition, this.aPositionCoord,  this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute];
    
    // End worst hack eva //


    this.program = program;
};

/**
* Destroys the shader
* @method destroy
*
*/
PIXI.PixiFastShader.prototype.destroy = function()
{
    this.gl.deleteProgram( this.program );
    this.uniforms = null;
    this.gl = null;

    this.attributes = null;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */


PIXI.StripShader = function(gl)
{
    this._UID = PIXI._UID++;
    
    this.gl = gl;

    /**
    * @property {any} program - The WebGL program.
    */
    this.program = null;

    /**
     * @property {array} fragmentSrc - The fragment shader.
     */
    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
     //   'varying float vColor;',
        'uniform float alpha;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));',
      //  '   gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);',//gl_FragColor * alpha;',
        '}'
    ];

     /**
    * @property {array} fragmentSrc - The fragment shader.
    */
    this.vertexSrc  = [
        'attribute vec2 aVertexPosition;',
        'attribute vec2 aTextureCoord;',
        'uniform mat3 translationMatrix;',
        'uniform vec2 projectionVector;',
        'uniform vec2 offsetVector;',
      //  'uniform float alpha;',
       // 'uniform vec3 tint;',
        'varying vec2 vTextureCoord;',
      //  'varying vec4 vColor;',

        'void main(void) {',
        '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);',
        '   v -= offsetVector.xyx;',
        '   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);',
        '   vTextureCoord = aTextureCoord;',
       // '   vColor = aColor * vec4(tint * alpha, alpha);',
        '}'
    ];

    this.init();
};

/**
* Initialises the shader
* @method init
*
*/
PIXI.StripShader.prototype.init = function()
{
    var gl = this.gl;

    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
    gl.useProgram(program);

    // get and store the uniforms for the shader
    this.uSampler = gl.getUniformLocation(program, 'uSampler');
    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');
    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');
    this.colorAttribute = gl.getAttribLocation(program, 'aColor');
    //this.dimensions = gl.getUniformLocation(this.program, 'dimensions');

    // get and store the attributes
    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');

    this.attributes = [this.aVertexPosition, this.aTextureCoord];

    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');
    this.alpha = gl.getUniformLocation(program, 'alpha');

    this.program = program;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class PrimitiveShader
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.PrimitiveShader = function(gl)
{
    this._UID = PIXI._UID++;
 
    /**
     * @property gl
     * @type WebGLContext
     */
    this.gl = gl;

    /**
    * @property {any} program - The WebGL program.
    */
    this.program = null;

    /**
     * @property fragmentSrc
     * @type Array
     */
    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec4 vColor;',

        'void main(void) {',
        '   gl_FragColor = vColor;',
        '}'
    ];

    /**
     * @property vertexSrc
     * @type Array
     */
    this.vertexSrc  = [
        'attribute vec2 aVertexPosition;',
        'attribute vec4 aColor;',
        'uniform mat3 translationMatrix;',
        'uniform vec2 projectionVector;',
        'uniform vec2 offsetVector;',
        'uniform float alpha;',
        'uniform vec3 tint;',
        'varying vec4 vColor;',

        'void main(void) {',
        '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);',
        '   v -= offsetVector.xyx;',
        '   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);',
        '   vColor = aColor * vec4(tint * alpha, alpha);',
        '}'
    ];

    this.init();
};

/**
* Initialises the shader
* @method init
*
*/
PIXI.PrimitiveShader.prototype.init = function()
{

    var gl = this.gl;

    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
    gl.useProgram(program);

    // get and store the uniforms for the shader
    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');
    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');
    this.tintColor = gl.getUniformLocation(program, 'tint');


    // get and store the attributes
    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
    this.colorAttribute = gl.getAttribLocation(program, 'aColor');

    this.attributes = [this.aVertexPosition, this.colorAttribute];

    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');
    this.alpha = gl.getUniformLocation(program, 'alpha');

    this.program = program;
};

/**
* Destroys the shader
* @method destroy
*
*/
PIXI.PrimitiveShader.prototype.destroy = function()
{
    this.gl.deleteProgram( this.program );
    this.uniforms = null;
    this.gl = null;

    this.attribute = null;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class ComplexPrimitiveShader
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.ComplexPrimitiveShader = function(gl)
{
    this._UID = PIXI._UID++;
    /**
     * @property gl
     * @type WebGLContext
     */
    this.gl = gl;

    /**
    * @property {any} program - The WebGL program.
    */
    this.program = null;

    /**
     * @property fragmentSrc
     * @type Array
     */
    this.fragmentSrc = [
        'precision mediump float;',
        


        'varying vec4 vColor;',

        'void main(void) {',
        '   gl_FragColor = vColor;',
        '}'
    ];

    /**
     * @property vertexSrc
     * @type Array
     */
    this.vertexSrc  = [
        'attribute vec2 aVertexPosition;',
        //'attribute vec4 aColor;',
        'uniform mat3 translationMatrix;',
        'uniform vec2 projectionVector;',
        'uniform vec2 offsetVector;',
        
        'uniform vec3 tint;',
        'uniform float alpha;',
        'uniform vec3 color;',

        'varying vec4 vColor;',

        'void main(void) {',
        '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);',
        '   v -= offsetVector.xyx;',
        '   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);',
        '   vColor = vec4(color * alpha * tint, alpha);',//" * vec4(tint * alpha, alpha);',
        '}'
    ];

    this.init();
};

/**
* Initialises the shader
* @method init
*
*/
PIXI.ComplexPrimitiveShader.prototype.init = function()
{

    var gl = this.gl;

    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
    gl.useProgram(program);

    // get and store the uniforms for the shader
    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');
    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');
    this.tintColor = gl.getUniformLocation(program, 'tint');
    this.color = gl.getUniformLocation(program, 'color');


    // get and store the attributes
    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
   // this.colorAttribute = gl.getAttribLocation(program, 'aColor');

    this.attributes = [this.aVertexPosition, this.colorAttribute];

    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');
    this.alpha = gl.getUniformLocation(program, 'alpha');

    this.program = program;
};

/**
* Destroys the shader
* @method destroy
*
*/
PIXI.ComplexPrimitiveShader.prototype.destroy = function()
{
    this.gl.deleteProgram( this.program );
    this.uniforms = null;
    this.gl = null;

    this.attribute = null;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * A set of functions used by the webGL renderer to draw the primitive graphics data
 *
 * @class WebGLGraphics
 * @private
 * @static
 */
PIXI.WebGLGraphics = function()
{

};

/**
 * Renders the graphics object
 *
 * @static
 * @private
 * @method renderGraphics
 * @param graphics {Graphics}
 * @param renderSession {Object}
 */
PIXI.WebGLGraphics.renderGraphics = function(graphics, renderSession)//projection, offset)
{
    var gl = renderSession.gl;
    var projection = renderSession.projection,
        offset = renderSession.offset,
        shader = renderSession.shaderManager.primitiveShader,
        webGLData;

    if(graphics.dirty)
    {
        PIXI.WebGLGraphics.updateGraphics(graphics, gl);
    }

    var webGL = graphics._webGL[gl.id];

    // This  could be speeded up for sure!

    for (var i = 0; i < webGL.data.length; i++)
    {
        if(webGL.data[i].mode === 1)
        {
            webGLData = webGL.data[i];

            renderSession.stencilManager.pushStencil(graphics, webGLData, renderSession);

            // render quad..
            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );
            
            renderSession.stencilManager.popStencil(graphics, webGLData, renderSession);
            
            this.last = webGLData.mode;
        }
        else
        {
            webGLData = webGL.data[i];
           

            renderSession.shaderManager.setShader( shader );//activatePrimitiveShader();
            shader = renderSession.shaderManager.primitiveShader;
            gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));

            gl.uniform2f(shader.projectionVector, projection.x, -projection.y);
            gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);

            gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));

            gl.uniform1f(shader.alpha, graphics.worldAlpha);
            

            gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);

            gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);
            gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false,4 * 6, 2 * 4);

            // set the index buffer!
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
            gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );
        }
    }
};

/**
 * Updates the graphics object
 *
 * @static
 * @private
 * @method updateGraphics
 * @param graphicsData {Graphics} The graphics object to update
 * @param gl {WebGLContext} the current WebGL drawing context
 */
PIXI.WebGLGraphics.updateGraphics = function(graphics, gl)
{
    // get the contexts graphics object
    var webGL = graphics._webGL[gl.id];
    // if the graphics object does not exist in the webGL context time to create it!
    if(!webGL)webGL = graphics._webGL[gl.id] = {lastIndex:0, data:[], gl:gl};

    // flag the graphics as not dirty as we are about to update it...
    graphics.dirty = false;

    var i;

    // if the user cleared the graphics object we will need to clear every object
    if(graphics.clearDirty)
    {
        graphics.clearDirty = false;

        // lop through and return all the webGLDatas to the object pool so than can be reused later on
        for (i = 0; i < webGL.data.length; i++)
        {
            var graphicsData = webGL.data[i];
            graphicsData.reset();
            PIXI.WebGLGraphics.graphicsDataPool.push( graphicsData );
        }

        // clear the array and reset the index.. 
        webGL.data = [];
        webGL.lastIndex = 0;
    }

    
    var webGLData;
    
    // loop through the graphics datas and construct each one..
    // if the object is a complex fill then the new stencil buffer technique will be used
    // other wise graphics objects will be pushed into a batch..
    for (i = webGL.lastIndex; i < graphics.graphicsData.length; i++)
    {
        var data = graphics.graphicsData[i];

        if(data.type === PIXI.Graphics.POLY)
        {
            // MAKE SURE WE HAVE THE CORRECT TYPE..
            if(data.fill)
            {
                if(data.points.length > 6)
                {
                    if(data.points.length > 5 * 2)
                    {
                        webGLData = PIXI.WebGLGraphics.switchMode(webGL, 1);
                        PIXI.WebGLGraphics.buildComplexPoly(data, webGLData);
                    }
                    else
                    {
                        webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0);
                        PIXI.WebGLGraphics.buildPoly(data, webGLData);
                    }
                }
            }

            if(data.lineWidth > 0)
            {
                webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0);
                PIXI.WebGLGraphics.buildLine(data, webGLData);

            }
        }
        else
        {
            webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0);
            
            if(data.type === PIXI.Graphics.RECT)
            {
                PIXI.WebGLGraphics.buildRectangle(data, webGLData);
            }
            else if(data.type === PIXI.Graphics.CIRC || data.type === PIXI.Graphics.ELIP)
            {
                PIXI.WebGLGraphics.buildCircle(data, webGLData);
            }
            else if(data.type === PIXI.Graphics.RREC)
            {
                PIXI.WebGLGraphics.buildRoundedRectangle(data, webGLData);
            }
        }


        webGL.lastIndex++;
    }

    // upload all the dirty data...
    for (i = 0; i < webGL.data.length; i++)
    {
        webGLData = webGL.data[i];
        if(webGLData.dirty)webGLData.upload();
    }
};


PIXI.WebGLGraphics.switchMode = function(webGL, type)
{
    var webGLData;

    if(!webGL.data.length)
    {
        webGLData = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(webGL.gl);
        webGLData.mode = type;
        webGL.data.push(webGLData);
    }
    else
    {
        webGLData = webGL.data[webGL.data.length-1];

        if(webGLData.mode !== type || type === 1)
        {
            webGLData = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(webGL.gl);
            webGLData.mode = type;
            webGL.data.push(webGLData);
        }
    }

    webGLData.dirty = true;

    return webGLData;
};

/**
 * Builds a rectangle to draw
 *
 * @static
 * @private
 * @method buildRectangle
 * @param graphicsData {Graphics} The graphics object containing all the necessary properties
 * @param webGLData {Object}
 */
PIXI.WebGLGraphics.buildRectangle = function(graphicsData, webGLData)
{
    // --- //
    // need to convert points to a nice regular data
    //
    var rectData = graphicsData.points;
    var x = rectData[0];
    var y = rectData[1];
    var width = rectData[2];
    var height = rectData[3];


    if(graphicsData.fill)
    {
        var color = PIXI.hex2rgb(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vertPos = verts.length/6;

        // start
        verts.push(x, y);
        verts.push(r, g, b, alpha);

        verts.push(x + width, y);
        verts.push(r, g, b, alpha);

        verts.push(x , y + height);
        verts.push(r, g, b, alpha);

        verts.push(x + width, y + height);
        verts.push(r, g, b, alpha);

        // insert 2 dead triangles..
        indices.push(vertPos, vertPos, vertPos+1, vertPos+2, vertPos+3, vertPos+3);
    }

    if(graphicsData.lineWidth)
    {
        var tempPoints = graphicsData.points;

        graphicsData.points = [x, y,
                  x + width, y,
                  x + width, y + height,
                  x, y + height,
                  x, y];


        PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
};

/**
 * Builds a rounded rectangle to draw
 *
 * @static
 * @private
 * @method buildRoundedRectangle
 * @param graphicsData {Graphics} The graphics object containing all the necessary properties
 * @param webGLData {Object}
 */
PIXI.WebGLGraphics.buildRoundedRectangle = function(graphicsData, webGLData)
{

    var points = graphicsData.points;
    var x = points[0];
    var y = points[1];
    var width = points[2];
    var height = points[3];
    var radius = points[4];


    var recPoints = [];
    recPoints.push(x, y + radius);
    recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x, y + height - radius, x, y + height, x + radius, y + height));
    recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + width - radius, y + height, x + width, y + height, x + width, y + height - radius));
    recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + width, y + radius, x + width, y, x + width - radius, y));
    recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + radius, y, x, y, x, y + radius));


    if (graphicsData.fill) {
        var color = PIXI.hex2rgb(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vecPos = verts.length/6;

        var triangles = PIXI.PolyK.Triangulate(recPoints);

        var i = 0;
        for (i = 0; i < triangles.length; i+=3)
        {
            indices.push(triangles[i] + vecPos);
            indices.push(triangles[i] + vecPos);
            indices.push(triangles[i+1] + vecPos);
            indices.push(triangles[i+2] + vecPos);
            indices.push(triangles[i+2] + vecPos);
        }

        for (i = 0; i < recPoints.length; i++)
        {
            verts.push(recPoints[i], recPoints[++i], r, g, b, alpha);
        }
    }

    if (graphicsData.lineWidth) {
        var tempPoints = graphicsData.points;

        graphicsData.points = recPoints;

        PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
};

/**
 * Calcul the points for a quadratic bezier curve. (helper function..)
 * Based on : https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
 *
 * @param  {number}   fromX Origin point x
 * @param  {number}   fromY Origin point x
 * @param  {number}   cpX   Control point x
 * @param  {number}   cpY   Control point y
 * @param  {number}   toX   Destination point x
 * @param  {number}   toY   Destination point y
 * @return {number[]}
 */
PIXI.WebGLGraphics.quadraticBezierCurve = function(fromX, fromY, cpX, cpY, toX, toY) {
    var xa,
        ya,
        xb,
        yb,
        x,
        y,
        n = 20,
        points = [];

    function getPt(n1 , n2, perc) {
        var diff = n2 - n1;

        return n1 + ( diff * perc );
    }

    var j = 0;
    for (var i = 0; i <= n; i++ )
    {
        j = i / n;

        // The Green Line
        xa = getPt( fromX , cpX , j );
        ya = getPt( fromY , cpY , j );
        xb = getPt( cpX , toX , j );
        yb = getPt( cpY , toY , j );

        // The Black Dot
        x = getPt( xa , xb , j );
        y = getPt( ya , yb , j );

        points.push(x, y);
    }
    return points;
};

/**
 * Builds a circle to draw
 *
 * @static
 * @private
 * @method buildCircle
 * @param graphicsData {Graphics} The graphics object to draw
 * @param webGLData {Object}
 */
PIXI.WebGLGraphics.buildCircle = function(graphicsData, webGLData)
{
    
    // need to convert points to a nice regular data
    var rectData = graphicsData.points;
    var x = rectData[0];
    var y = rectData[1];
    var width = rectData[2];
    var height = rectData[3];

    var totalSegs = 40;
    var seg = (Math.PI * 2) / totalSegs ;

    var i = 0;

    if(graphicsData.fill)
    {
        var color = PIXI.hex2rgb(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vecPos = verts.length/6;

        indices.push(vecPos);

        for (i = 0; i < totalSegs + 1 ; i++)
        {
            verts.push(x,y, r, g, b, alpha);

            verts.push(x + Math.sin(seg * i) * width,
                       y + Math.cos(seg * i) * height,
                       r, g, b, alpha);

            indices.push(vecPos++, vecPos++);
        }

        indices.push(vecPos-1);
    }

    if(graphicsData.lineWidth)
    {
        var tempPoints = graphicsData.points;

        graphicsData.points = [];

        for (i = 0; i < totalSegs + 1; i++)
        {
            graphicsData.points.push(x + Math.sin(seg * i) * width,
                                     y + Math.cos(seg * i) * height);
        }

        PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
};

/**
 * Builds a line to draw
 *
 * @static
 * @private
 * @method buildLine
 * @param graphicsData {Graphics} The graphics object containing all the necessary properties
 * @param webGLData {Object}
 */
PIXI.WebGLGraphics.buildLine = function(graphicsData, webGLData)
{
    // TODO OPTIMISE!
    var i = 0;

    var points = graphicsData.points;
    if(points.length === 0)return;

    // if the line width is an odd number add 0.5 to align to a whole pixel
    if(graphicsData.lineWidth%2)
    {
        for (i = 0; i < points.length; i++) {
            points[i] += 0.5;
        }
    }

    // get first and last point.. figure out the middle!
    var firstPoint = new PIXI.Point( points[0], points[1] );
    var lastPoint = new PIXI.Point( points[points.length - 2], points[points.length - 1] );

    // if the first point is the last point - gonna have issues :)
    if(firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y)
    {
        // need to clone as we are going to slightly modify the shape..
        points = points.slice();

        points.pop();
        points.pop();

        lastPoint = new PIXI.Point( points[points.length - 2], points[points.length - 1] );

        var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) *0.5;
        var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) *0.5;

        points.unshift(midPointX, midPointY);
        points.push(midPointX, midPointY);
    }

    var verts = webGLData.points;
    var indices = webGLData.indices;
    var length = points.length / 2;
    var indexCount = points.length;
    var indexStart = verts.length/6;

    // DRAW the Line
    var width = graphicsData.lineWidth / 2;

    // sort color
    var color = PIXI.hex2rgb(graphicsData.lineColor);
    var alpha = graphicsData.lineAlpha;
    var r = color[0] * alpha;
    var g = color[1] * alpha;
    var b = color[2] * alpha;

    var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
    var perpx, perpy, perp2x, perp2y, perp3x, perp3y;
    var a1, b1, c1, a2, b2, c2;
    var denom, pdist, dist;

    p1x = points[0];
    p1y = points[1];

    p2x = points[2];
    p2y = points[3];

    perpx = -(p1y - p2y);
    perpy =  p1x - p2x;

    dist = Math.sqrt(perpx*perpx + perpy*perpy);

    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;

    // start
    verts.push(p1x - perpx , p1y - perpy,
                r, g, b, alpha);

    verts.push(p1x + perpx , p1y + perpy,
                r, g, b, alpha);

    for (i = 1; i < length-1; i++)
    {
        p1x = points[(i-1)*2];
        p1y = points[(i-1)*2 + 1];

        p2x = points[(i)*2];
        p2y = points[(i)*2 + 1];

        p3x = points[(i+1)*2];
        p3y = points[(i+1)*2 + 1];

        perpx = -(p1y - p2y);
        perpy = p1x - p2x;

        dist = Math.sqrt(perpx*perpx + perpy*perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;

        perp2x = -(p2y - p3y);
        perp2y = p2x - p3x;

        dist = Math.sqrt(perp2x*perp2x + perp2y*perp2y);
        perp2x /= dist;
        perp2y /= dist;
        perp2x *= width;
        perp2y *= width;

        a1 = (-perpy + p1y) - (-perpy + p2y);
        b1 = (-perpx + p2x) - (-perpx + p1x);
        c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
        a2 = (-perp2y + p3y) - (-perp2y + p2y);
        b2 = (-perp2x + p2x) - (-perp2x + p3x);
        c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);

        denom = a1*b2 - a2*b1;

        if(Math.abs(denom) < 0.1 )
        {

            denom+=10.1;
            verts.push(p2x - perpx , p2y - perpy,
                r, g, b, alpha);

            verts.push(p2x + perpx , p2y + perpy,
                r, g, b, alpha);

            continue;
        }

        px = (b1*c2 - b2*c1)/denom;
        py = (a2*c1 - a1*c2)/denom;


        pdist = (px -p2x) * (px -p2x) + (py -p2y) + (py -p2y);


        if(pdist > 140 * 140)
        {
            perp3x = perpx - perp2x;
            perp3y = perpy - perp2y;

            dist = Math.sqrt(perp3x*perp3x + perp3y*perp3y);
            perp3x /= dist;
            perp3y /= dist;
            perp3x *= width;
            perp3y *= width;

            verts.push(p2x - perp3x, p2y -perp3y);
            verts.push(r, g, b, alpha);

            verts.push(p2x + perp3x, p2y +perp3y);
            verts.push(r, g, b, alpha);

            verts.push(p2x - perp3x, p2y -perp3y);
            verts.push(r, g, b, alpha);

            indexCount++;
        }
        else
        {

            verts.push(px , py);
            verts.push(r, g, b, alpha);

            verts.push(p2x - (px-p2x), p2y - (py - p2y));
            verts.push(r, g, b, alpha);
        }
    }

    p1x = points[(length-2)*2];
    p1y = points[(length-2)*2 + 1];

    p2x = points[(length-1)*2];
    p2y = points[(length-1)*2 + 1];

    perpx = -(p1y - p2y);
    perpy = p1x - p2x;

    dist = Math.sqrt(perpx*perpx + perpy*perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;

    verts.push(p2x - perpx , p2y - perpy);
    verts.push(r, g, b, alpha);

    verts.push(p2x + perpx , p2y + perpy);
    verts.push(r, g, b, alpha);

    indices.push(indexStart);

    for (i = 0; i < indexCount; i++)
    {
        indices.push(indexStart++);
    }

    indices.push(indexStart-1);
};

/**
 * Builds a complex polygon to draw
 *
 * @static
 * @private
 * @method buildPoly
 * @param graphicsData {Graphics} The graphics object containing all the necessary properties
 * @param webGLData {Object}
 */
PIXI.WebGLGraphics.buildComplexPoly = function(graphicsData, webGLData)
{

    //TODO - no need to copy this as it gets turned into a FLoat32Array anyways..
    var points = graphicsData.points.slice();
    if(points.length < 6)return;

    // get first and last point.. figure out the middle!
    var indices = webGLData.indices;
    webGLData.points = points;
    webGLData.alpha = graphicsData.fillAlpha;
    webGLData.color = PIXI.hex2rgb(graphicsData.fillColor);

    /*
        calclate the bounds..
    */
    var minX = Infinity;
    var maxX = -Infinity;

    var minY = Infinity;
    var maxY = -Infinity;

    var x,y;

    // get size..
    for (var i = 0; i < points.length; i+=2)
    {
        x = points[i];
        y = points[i+1];

        minX = x < minX ? x : minX;
        maxX = x > maxX ? x : maxX;

        minY = y < minY ? y : minY;
        maxY = y > maxY ? y : maxY;
    }

    // add a quad to the end cos there is no point making another buffer!
    points.push(minX, minY,
                maxX, minY,
                maxX, maxY,
                minX, maxY);

    // push a quad onto the end.. 
    
    //TODO - this aint needed!
    var length = points.length / 2;
    for (i = 0; i < length; i++)
    {
        indices.push( i );
    }

};

PIXI.WebGLGraphics.buildPoly = function(graphicsData, webGLData)
{
    var points = graphicsData.points;
    if(points.length < 6)return;

    // get first and last point.. figure out the middle!
    var verts = webGLData.points;
    var indices = webGLData.indices;

    var length = points.length / 2;

    // sort color
    var color = PIXI.hex2rgb(graphicsData.fillColor);
    var alpha = graphicsData.fillAlpha;
    var r = color[0] * alpha;
    var g = color[1] * alpha;
    var b = color[2] * alpha;

    var triangles = PIXI.PolyK.Triangulate(points);
    var vertPos = verts.length / 6;

    var i = 0;

    for (i = 0; i < triangles.length; i+=3)
    {
        indices.push(triangles[i] + vertPos);
        indices.push(triangles[i] + vertPos);
        indices.push(triangles[i+1] + vertPos);
        indices.push(triangles[i+2] +vertPos);
        indices.push(triangles[i+2] + vertPos);
    }

    for (i = 0; i < length; i++)
    {
        verts.push(points[i * 2], points[i * 2 + 1],
                   r, g, b, alpha);
    }

};

PIXI.WebGLGraphics.graphicsDataPool = [];

PIXI.WebGLGraphicsData = function(gl)
{
    this.gl = gl;

    //TODO does this need to be split before uploding??
    this.color = [0,0,0]; // color split!
    this.points = [];
    this.indices = [];
    this.lastIndex = 0;
    this.buffer = gl.createBuffer();
    this.indexBuffer = gl.createBuffer();
    this.mode = 1;
    this.alpha = 1;
    this.dirty = true;
};

PIXI.WebGLGraphicsData.prototype.reset = function()
{
    this.points = [];
    this.indices = [];
    this.lastIndex = 0;
};

PIXI.WebGLGraphicsData.prototype.upload = function()
{
    var gl = this.gl;

//    this.lastIndex = graphics.graphicsData.length;
    this.glPoints = new Float32Array(this.points);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.glPoints, gl.STATIC_DRAW);

    this.glIndicies = new Uint16Array(this.indices);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.glIndicies, gl.STATIC_DRAW);

    this.dirty = false;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

PIXI.glContexts = []; // this is where we store the webGL contexts for easy access.

/**
 * the WebGLRenderer draws the stage and all its content onto a webGL enabled canvas. This renderer
 * should be used for browsers that support webGL. This Render works by automatically managing webGLBatch's.
 * So no need for Sprite Batch's or Sprite Cloud's
 * Dont forget to add the view to your DOM or you will not see anything :)
 *
 * @class WebGLRenderer
 * @constructor
 * @param width=0 {Number} the width of the canvas view
 * @param height=0 {Number} the height of the canvas view
 * @param view {HTMLCanvasElement} the canvas to use as a view, optional
 * @param transparent=false {Boolean} If the render view is transparent, default false
 * @param antialias=false {Boolean} sets antialias (only applicable in chrome at the moment)
 * @param preserveDrawingBuffer=false {Boolean} enables drawing buffer preservation, enable this if you need to call toDataUrl on the webgl context
 *
 */
PIXI.WebGLRenderer = function(width, height, view, transparent, antialias, preserveDrawingBuffer)
{
    if(!PIXI.defaultRenderer)
    {
        PIXI.sayHello('webGL');
        PIXI.defaultRenderer = this;
    }

    this.type = PIXI.WEBGL_RENDERER;

    // do a catch.. only 1 webGL renderer..
    /**
     * Whether the render view is transparent
     *
     * @property transparent
     * @type Boolean
     */
    this.transparent = !!transparent;

    /**
     * The value of the preserveDrawingBuffer flag affects whether or not the contents of the stencil buffer is retained after rendering.
     *
     * @property preserveDrawingBuffer
     * @type Boolean
     */
    this.preserveDrawingBuffer = preserveDrawingBuffer;

    /**
     * The width of the canvas view
     *
     * @property width
     * @type Number
     * @default 800
     */
    this.width = width || 800;

    /**
     * The height of the canvas view
     *
     * @property height
     * @type Number
     * @default 600
     */
    this.height = height || 600;

    /**
     * The canvas element that everything is drawn to
     *
     * @property view
     * @type HTMLCanvasElement
     */
    this.view = view || document.createElement( 'canvas' );
    this.view.width = this.width;
    this.view.height = this.height;

    // deal with losing context..
    this.contextLost = this.handleContextLost.bind(this);
    this.contextRestoredLost = this.handleContextRestored.bind(this);
    
    this.view.addEventListener('webglcontextlost', this.contextLost, false);
    this.view.addEventListener('webglcontextrestored', this.contextRestoredLost, false);

    this.options = {
        alpha: this.transparent,
        antialias:!!antialias, // SPEED UP??
        premultipliedAlpha:!!transparent,
        stencil:true,
        preserveDrawingBuffer: preserveDrawingBuffer
    };

    var gl = null;

    ['experimental-webgl', 'webgl'].forEach(function(name) {
        try {
            gl = gl || this.view.getContext(name,  this.options);
        } catch(e) {}
    }, this);

    if (!gl) {
        // fail, not able to get a context
        throw new Error('This browser does not support webGL. Try using the canvas renderer' + this);
    }

    this.gl = gl;
    this.glContextId = gl.id = PIXI.WebGLRenderer.glContextId ++;

    PIXI.glContexts[this.glContextId] = gl;

    if(!PIXI.blendModesWebGL)
    {
        PIXI.blendModesWebGL = [];

        PIXI.blendModesWebGL[PIXI.blendModes.NORMAL]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.ADD]           = [gl.SRC_ALPHA, gl.DST_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.MULTIPLY]      = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.SCREEN]        = [gl.SRC_ALPHA, gl.ONE];
        PIXI.blendModesWebGL[PIXI.blendModes.OVERLAY]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.DARKEN]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.LIGHTEN]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.COLOR_DODGE]   = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.COLOR_BURN]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.HARD_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.SOFT_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.DIFFERENCE]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.EXCLUSION]     = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.HUE]           = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.SATURATION]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.COLOR]         = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.LUMINOSITY]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
    }




    this.projection = new PIXI.Point();
    this.projection.x =  this.width/2;
    this.projection.y =  -this.height/2;

    this.offset = new PIXI.Point(0, 0);

    this.resize(this.width, this.height);
    this.contextLost = false;

    // time to create the render managers! each one focuses on managine a state in webGL
    this.shaderManager = new PIXI.WebGLShaderManager(gl);                   // deals with managing the shader programs and their attribs
    this.spriteBatch = new PIXI.WebGLSpriteBatch(gl);                       // manages the rendering of sprites
    //this.primitiveBatch = new PIXI.WebGLPrimitiveBatch(gl);               // primitive batch renderer
    this.maskManager = new PIXI.WebGLMaskManager(gl);                       // manages the masks using the stencil buffer
    this.filterManager = new PIXI.WebGLFilterManager(gl, this.transparent); // manages the filters
    this.stencilManager = new PIXI.WebGLStencilManager(gl);
    this.blendModeManager = new PIXI.WebGLBlendModeManager(gl);

    this.renderSession = {};
    this.renderSession.gl = this.gl;
    this.renderSession.drawCount = 0;
    this.renderSession.shaderManager = this.shaderManager;
    this.renderSession.maskManager = this.maskManager;
    this.renderSession.filterManager = this.filterManager;
    this.renderSession.blendModeManager = this.blendModeManager;
   // this.renderSession.primitiveBatch = this.primitiveBatch;
    this.renderSession.spriteBatch = this.spriteBatch;
    this.renderSession.stencilManager = this.stencilManager;
    this.renderSession.renderer = this;

    gl.useProgram(this.shaderManager.defaultShader.program);

    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);

    gl.enable(gl.BLEND);
    gl.colorMask(true, true, true, this.transparent);
};

// constructor
PIXI.WebGLRenderer.prototype.constructor = PIXI.WebGLRenderer;

/**
 * Renders the stage to its webGL view
 *
 * @method render
 * @param stage {Stage} the Stage element to be rendered
 */
PIXI.WebGLRenderer.prototype.render = function(stage)
{
    if(this.contextLost)return;


    // if rendering a new stage clear the batches..
    if(this.__stage !== stage)
    {
        if(stage.interactive)stage.interactionManager.removeEvents();

        // TODO make this work
        // dont think this is needed any more?
        this.__stage = stage;
    }

    // update any textures this includes uvs and uploading them to the gpu
    PIXI.WebGLRenderer.updateTextures();

    // update the scene graph
    stage.updateTransform();


    // interaction
    if(stage._interactive)
    {
        //need to add some events!
        if(!stage._interactiveEventsAdded)
        {
            stage._interactiveEventsAdded = true;
            stage.interactionManager.setTarget(this);
        }
    }
    
    var gl = this.gl;

    // -- Does this need to be set every frame? -- //
    //gl.colorMask(true, true, true, this.transparent);
    gl.viewport(0, 0, this.width, this.height);

    // make sure we are bound to the main frame buffer
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    if(this.transparent)
    {
        gl.clearColor(0, 0, 0, 0);
    }
    else
    {
        gl.clearColor(stage.backgroundColorSplit[0],stage.backgroundColorSplit[1],stage.backgroundColorSplit[2], 1);
    }


    gl.clear(gl.COLOR_BUFFER_BIT);

    this.renderDisplayObject( stage, this.projection );

    // interaction
    if(stage.interactive)
    {
        //need to add some events!
        if(!stage._interactiveEventsAdded)
        {
            stage._interactiveEventsAdded = true;
            stage.interactionManager.setTarget(this);
        }
    }
    else
    {
        if(stage._interactiveEventsAdded)
        {
            stage._interactiveEventsAdded = false;
            stage.interactionManager.setTarget(this);
        }
    }

    /*
    //can simulate context loss in Chrome like so:
     this.view.onmousedown = function(ev) {
     console.dir(this.gl.getSupportedExtensions());
        var ext = (
            gl.getExtension("WEBGL_scompressed_texture_s3tc")
       // gl.getExtension("WEBGL_compressed_texture_s3tc") ||
       // gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
       // gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc")
     );
     console.dir(ext);
     var loseCtx = this.gl.getExtension("WEBGL_lose_context");
      console.log("killing context");
      loseCtx.loseContext();
     setTimeout(function() {
          console.log("restoring context...");
          loseCtx.restoreContext();
      }.bind(this), 1000);
     }.bind(this);
     */
};

/**
 * Renders a display Object
 *
 * @method renderDIsplayObject
 * @param displayObject {DisplayObject} The DisplayObject to render
 * @param projection {Point} The projection
 * @param buffer {Array} a standard WebGL buffer 
 */
PIXI.WebGLRenderer.prototype.renderDisplayObject = function(displayObject, projection, buffer)
{
    this.renderSession.blendModeManager.setBlendMode(PIXI.blendModes.NORMAL);
    // reset the render session data..
    this.renderSession.drawCount = 0;
    this.renderSession.currentBlendMode = 9999;

    this.renderSession.projection = projection;
    this.renderSession.offset = this.offset;

    // start the sprite batch
    this.spriteBatch.begin(this.renderSession);

//    this.primitiveBatch.begin(this.renderSession);

    // start the filter manager
    this.filterManager.begin(this.renderSession, buffer);

    // render the scene!
    displayObject._renderWebGL(this.renderSession);

    // finish the sprite batch
    this.spriteBatch.end();

//    this.primitiveBatch.end();
};

/**
 * Updates the textures loaded into this webgl renderer
 *
 * @static
 * @method updateTextures
 * @private
 */
PIXI.WebGLRenderer.updateTextures = function()
{
    var i = 0;

    //TODO break this out into a texture manager...
  //  for (i = 0; i < PIXI.texturesToUpdate.length; i++)
  //      PIXI..updateWebGLTexture(PIXI.texturesToUpdate[i], this.gl);


    for (i=0; i < PIXI.Texture.frameUpdates.length; i++)
        PIXI.WebGLRenderer.updateTextureFrame(PIXI.Texture.frameUpdates[i]);

    for (i = 0; i < PIXI.texturesToDestroy.length; i++)
        PIXI.WebGLRenderer.destroyTexture(PIXI.texturesToDestroy[i]);

    PIXI.texturesToUpdate.length = 0;
    PIXI.texturesToDestroy.length = 0;
    PIXI.Texture.frameUpdates.length = 0;
};

/**
 * Destroys a loaded webgl texture
 *
 * @method destroyTexture
 * @param texture {Texture} The texture to update
 * @private
 */
PIXI.WebGLRenderer.destroyTexture = function(texture)
{
    //TODO break this out into a texture manager...

    for (var i = texture._glTextures.length - 1; i >= 0; i--)
    {
        var glTexture = texture._glTextures[i];
        var gl = PIXI.glContexts[i];

        if(gl && glTexture)
        {
            gl.deleteTexture(glTexture);
        }
    }

    texture._glTextures.length = 0;
};

/**
 *
 * @method updateTextureFrame
 * @param texture {Texture} The texture to update the frame from
 * @private
 */
PIXI.WebGLRenderer.updateTextureFrame = function(texture)
{
    //texture.updateFrame = false;

    // now set the uvs. Figured that the uv data sits with a texture rather than a sprite.
    // so uv data is stored on the texture itself
    texture._updateWebGLuvs();
};

/**
 * resizes the webGL view to the specified width and height
 *
 * @method resize
 * @param width {Number} the new width of the webGL view
 * @param height {Number} the new height of the webGL view
 */
PIXI.WebGLRenderer.prototype.resize = function(width, height)
{
    this.width = width;
    this.height = height;

    this.view.width = width;
    this.view.height = height;

    this.gl.viewport(0, 0, this.width, this.height);

    this.projection.x =  this.width/2;
    this.projection.y =  -this.height/2;
};

/**
 * Creates a WebGL texture
 *
 * @method createWebGLTexture
 * @param texture {Texture} the texture to render
 * @param gl {webglContext} the WebGL context
 * @static
 */
PIXI.createWebGLTexture = function(texture, gl)
{


    if(texture.hasLoaded)
    {
        texture._glTextures[gl.id] = gl.createTexture();

        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);

        // reguler...

        if(!texture._powerOf2)
        {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }
        else
        {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        }

        gl.bindTexture(gl.TEXTURE_2D, null);

        texture._dirty[gl.id] = false;
    }

    return  texture._glTextures[gl.id];
};

/**
 * Updates a WebGL texture
 *
 * @method updateWebGLTexture
 * @param texture {Texture} the texture to update
 * @param gl {webglContext} the WebGL context
 * @private
 */
PIXI.updateWebGLTexture = function(texture, gl)
{
    if( texture._glTextures[gl.id] )
    {
        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);

        // reguler...

        if(!texture._powerOf2)
        {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }
        else
        {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        }

        texture._dirty[gl.id] = false;
    }
    
};

/**
 * Handles a lost webgl context
 *
 * @method handleContextLost
 * @param event {Event}
 * @private
 */
PIXI.WebGLRenderer.prototype.handleContextLost = function(event)
{
    event.preventDefault();
    this.contextLost = true;
};

/**
 * Handles a restored webgl context
 *
 * @method handleContextRestored
 * @param event {Event}
 * @private
 */
PIXI.WebGLRenderer.prototype.handleContextRestored = function()
{

    //try 'experimental-webgl'
    try {
        this.gl = this.view.getContext('experimental-webgl',  this.options);
    } catch (e) {
        //try 'webgl'
        try {
            this.gl = this.view.getContext('webgl',  this.options);
        } catch (e2) {
            // fail, not able to get a context
            throw new Error(' This browser does not support webGL. Try using the canvas renderer' + this);
        }
    }

    var gl = this.gl;
    gl.id = PIXI.WebGLRenderer.glContextId ++;



    // need to set the context...
    this.shaderManager.setContext(gl);
    this.spriteBatch.setContext(gl);
    this.primitiveBatch.setContext(gl);
    this.maskManager.setContext(gl);
    this.filterManager.setContext(gl);


    this.renderSession.gl = this.gl;

    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);

    gl.enable(gl.BLEND);
    gl.colorMask(true, true, true, this.transparent);

    this.gl.viewport(0, 0, this.width, this.height);

    for(var key in PIXI.TextureCache)
    {
        var texture = PIXI.TextureCache[key].baseTexture;
        texture._glTextures = [];
    }

    /**
     * Whether the context was lost 
     * @property contextLost
     * @type Boolean
     */
    this.contextLost = false;

};

/**
 * Removes everything from the renderer (event listeners, spritebatch, etc...)
 *
 * @method destroy
 */
PIXI.WebGLRenderer.prototype.destroy = function()
{

    // deal with losing context..
    
    // remove listeners
    this.view.removeEventListener('webglcontextlost', this.contextLost);
    this.view.removeEventListener('webglcontextrestored', this.contextRestoredLost);

    PIXI.glContexts[this.glContextId] = null;

    this.projection = null;
    this.offset = null;

    // time to create the render managers! each one focuses on managine a state in webGL
    this.shaderManager.destroy();
    this.spriteBatch.destroy();
    this.primitiveBatch.destroy();
    this.maskManager.destroy();
    this.filterManager.destroy();

    this.shaderManager = null;
    this.spriteBatch = null;
    this.maskManager = null;
    this.filterManager = null;
    
    this.gl = null;
    //
    this.renderSession = null;
};


PIXI.WebGLRenderer.glContextId = 0;

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class WebGLMaskManager
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
* @private
*/
PIXI.WebGLBlendModeManager = function(gl)
{
    this.gl = gl;
    this.currentBlendMode = 99999;
};

/**
* Sets-up the given blendMode from WebGL's point of view
* @method setBlendMode 
*
* @param blendMode {Number} the blendMode, should be a Pixi const, such as PIXI.BlendModes.ADD
*/
PIXI.WebGLBlendModeManager.prototype.setBlendMode = function(blendMode)
{
    if(this.currentBlendMode === blendMode)return false;
 //   console.log("SWAP!")
    this.currentBlendMode = blendMode;
    
    var blendModeWebGL = PIXI.blendModesWebGL[this.currentBlendMode];
    this.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
    
    return true;
};

PIXI.WebGLBlendModeManager.prototype.destroy = function()
{
    this.gl = null;
};
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class WebGLMaskManager
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
* @private
*/
PIXI.WebGLMaskManager = function(gl)
{
    this.maskStack = [];
    this.maskPosition = 0;

    this.setContext(gl);

    this.reverse = false;
    this.count = 0;
};

/**
* Sets the drawing context to the one given in parameter
* @method setContext 
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.WebGLMaskManager.prototype.setContext = function(gl)
{
    this.gl = gl;
};

/**
* Applies the Mask and adds it to the current filter stack
* @method pushMask
* @param maskData {Array}
* @param renderSession {RenderSession}
*/
PIXI.WebGLMaskManager.prototype.pushMask = function(maskData, renderSession)
{
    var gl = renderSession.gl;

    if(maskData.dirty)
    {
        PIXI.WebGLGraphics.updateGraphics(maskData, gl);
    }

    if(!maskData._webGL[gl.id].data.length)return;

    renderSession.stencilManager.pushStencil(maskData, maskData._webGL[gl.id].data[0], renderSession);
};

/**
* Removes the last filter from the filter stack and doesn't return it
* @method popMask
*
* @param renderSession {RenderSession} an object containing all the useful parameters
*/
PIXI.WebGLMaskManager.prototype.popMask = function(maskData, renderSession)
{
    var gl = this.gl;
    renderSession.stencilManager.popStencil(maskData, maskData._webGL[gl.id].data[0], renderSession);
};


/**
* Destroys the mask stack
* @method destroy
*/
PIXI.WebGLMaskManager.prototype.destroy = function()
{
    this.maskStack = null;
    this.gl = null;
};
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */
 
//BA0285
//Intercontinental Hotel, 888 Howard Street
//San Francisco

/**
* @class WebGLStencilManager
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
* @private
*/
PIXI.WebGLStencilManager = function(gl)
{
   
    this.stencilStack = [];
    this.setContext(gl);
    this.reverse = true;
    this.count = 0;

};

/**
* Sets the drawing context to the one given in parameter
* @method setContext 
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.WebGLStencilManager.prototype.setContext = function(gl)
{
    this.gl = gl;
};

/**
* Applies the Mask and adds it to the current filter stack
* @method pushMask
* @param maskData {Array}
* @param renderSession {RenderSession}
*/
PIXI.WebGLStencilManager.prototype.pushStencil = function(graphics, webGLData, renderSession)
{
    var gl = this.gl;
    this.bindGraphics(graphics, webGLData, renderSession);

    if(this.stencilStack.length === 0)
    {
        gl.enable(gl.STENCIL_TEST);
        gl.clear(gl.STENCIL_BUFFER_BIT);
        this.reverse = true;
        this.count = 0;
    }

    this.stencilStack.push(webGLData);

    var level = this.count;

    gl.colorMask(false, false, false, false);

    gl.stencilFunc(gl.ALWAYS,0,0xFF);
    gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT);

    // draw the triangle strip!

    if(webGLData.mode === 1)
    {

        gl.drawElements(gl.TRIANGLE_FAN,  webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0 );
       
        if(this.reverse)
        {
            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
        }

        // draw a quad to increment..
        gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );
               
        if(this.reverse)
        {
            gl.stencilFunc(gl.EQUAL,0xFF-(level+1), 0xFF);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
        }

        this.reverse = !this.reverse;
    }
    else
    {
        if(!this.reverse)
        {
            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
        }

        gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );

        if(!this.reverse)
        {
            gl.stencilFunc(gl.EQUAL,0xFF-(level+1), 0xFF);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
        }
    }

    gl.colorMask(true, true, true, true);
    gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);

    this.count++;
};

//TODO this does not belong here!
PIXI.WebGLStencilManager.prototype.bindGraphics = function(graphics, webGLData, renderSession)
{
    //if(this._currentGraphics === graphics)return;
    this._currentGraphics = graphics;

    var gl = this.gl;

     // bind the graphics object..
    var projection = renderSession.projection,
        offset = renderSession.offset,
        shader;// = renderSession.shaderManager.primitiveShader;

    if(webGLData.mode === 1)
    {
        shader = renderSession.shaderManager.complexPrimativeShader;

        renderSession.shaderManager.setShader( shader );

        gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));

        gl.uniform2f(shader.projectionVector, projection.x, -projection.y);
        gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);

        gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));
        gl.uniform3fv(shader.color, webGLData.color);

        gl.uniform1f(shader.alpha, graphics.worldAlpha * webGLData.alpha);

        gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);

        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 2, 0);


        // now do the rest..
        // set the index buffer!
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
    }
    else
    {
        //renderSession.shaderManager.activatePrimitiveShader();
        shader = renderSession.shaderManager.primitiveShader;
        renderSession.shaderManager.setShader( shader );

        gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));

        gl.uniform2f(shader.projectionVector, projection.x, -projection.y);
        gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);

        gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));

        gl.uniform1f(shader.alpha, graphics.worldAlpha);
        
        gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);

        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);
        gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false,4 * 6, 2 * 4);

        // set the index buffer!
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
    }
};

PIXI.WebGLStencilManager.prototype.popStencil = function(graphics, webGLData, renderSession)
{
	var gl = this.gl;
    this.stencilStack.pop();
   
    this.count--;

    if(this.stencilStack.length === 0)
    {
        // the stack is empty!
        gl.disable(gl.STENCIL_TEST);

    }
    else
    {

        var level = this.count;

        this.bindGraphics(graphics, webGLData, renderSession);

        gl.colorMask(false, false, false, false);
    
        if(webGLData.mode === 1)
        {
            this.reverse = !this.reverse;

            if(this.reverse)
            {
                gl.stencilFunc(gl.EQUAL, 0xFF - (level+1), 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
            }

            // draw a quad to increment..
            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );
            
            gl.stencilFunc(gl.ALWAYS,0,0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT);

            // draw the triangle strip!
            gl.drawElements(gl.TRIANGLE_FAN,  webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0 );
           
            if(!this.reverse)
            {
                gl.stencilFunc(gl.EQUAL,0xFF-(level), 0xFF);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level, 0xFF);
            }

        }
        else
        {
          //  console.log("<<>>")
            if(!this.reverse)
            {
                gl.stencilFunc(gl.EQUAL, 0xFF - (level+1), 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
            }

            gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );

            if(!this.reverse)
            {
                gl.stencilFunc(gl.EQUAL,0xFF-(level), 0xFF);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level, 0xFF);
            }
        }

        gl.colorMask(true, true, true, true);
        gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);


    }

    //renderSession.shaderManager.deactivatePrimitiveShader();
};

/**
* Destroys the mask stack
* @method destroy
*/
PIXI.WebGLStencilManager.prototype.destroy = function()
{
    this.maskStack = null;
    this.gl = null;
};
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class WebGLShaderManager
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
* @private
*/
PIXI.WebGLShaderManager = function(gl)
{

    this.maxAttibs = 10;
    this.attribState = [];
    this.tempAttribState = [];
    this.shaderMap = [];

    for (var i = 0; i < this.maxAttibs; i++) {
        this.attribState[i] = false;
    }

    this.setContext(gl);
    // the final one is used for the rendering strips
};


/**
* Initialises the context and the properties
* @method setContext 
* @param gl {WebGLContext} the current WebGL drawing context
* @param transparent {Boolean} Whether or not the drawing context should be transparent
*/
PIXI.WebGLShaderManager.prototype.setContext = function(gl)
{
    this.gl = gl;
    
    // the next one is used for rendering primatives
    this.primitiveShader = new PIXI.PrimitiveShader(gl);

    // the next one is used for rendering triangle strips
    this.complexPrimativeShader = new PIXI.ComplexPrimitiveShader(gl);

    // this shader is used for the default sprite rendering
    this.defaultShader = new PIXI.PixiShader(gl);

    // this shader is used for the fast sprite rendering
    this.fastShader = new PIXI.PixiFastShader(gl);

    // the next one is used for rendering triangle strips
    this.stripShader = new PIXI.StripShader(gl);
    this.setShader(this.defaultShader);
};


/**
* Takes the attributes given in parameters 
* @method setAttribs
* @param attribs {Array} attribs 
*/
PIXI.WebGLShaderManager.prototype.setAttribs = function(attribs)
{
    // reset temp state

    var i;

    for (i = 0; i < this.tempAttribState.length; i++)
    {
        this.tempAttribState[i] = false;
    }

    // set the new attribs
    for (i = 0; i < attribs.length; i++)
    {
        var attribId = attribs[i];
        this.tempAttribState[attribId] = true;
    }

    var gl = this.gl;

    for (i = 0; i < this.attribState.length; i++)
    {
        if(this.attribState[i] !== this.tempAttribState[i])
        {
            this.attribState[i] = this.tempAttribState[i];

            if(this.tempAttribState[i])
            {
                gl.enableVertexAttribArray(i);
            }
            else
            {
                gl.disableVertexAttribArray(i);
            }
        }
    }
};

PIXI.WebGLShaderManager.prototype.setShader = function(shader)
{
    if(this._currentId === shader._UID)return false;
    
    this._currentId = shader._UID;

    this.currentShader = shader;

    this.gl.useProgram(shader.program);
    this.setAttribs(shader.attributes);

    return true;
};

/**
* Destroys
* @method destroy
*/
PIXI.WebGLShaderManager.prototype.destroy = function()
{
    this.attribState = null;

    this.tempAttribState = null;

    this.primitiveShader.destroy();

    this.defaultShader.destroy();

    this.fastShader.destroy();

    this.stripShader.destroy();

    this.gl = null;
};


/**
 * @author Mat Groves
 * 
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original pixi version!
 *
 * Heavily inspired by LibGDX's WebGLSpriteBatch:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/WebGLSpriteBatch.java
 */

 /**
 *
 * @class WebGLSpriteBatch
 * @private
 * @constructor
 * @param gl {WebGLContext} the current WebGL drawing context
 *
 */
PIXI.WebGLSpriteBatch = function(gl)
{

    /**
     * 
     *
     * @property vertSize
     * @type Number
     */
    this.vertSize = 6;

    /**
     * The number of images in the SpriteBatch before it flushes
     * @property size
     * @type Number
     */
    this.size = 2000;//Math.pow(2, 16) /  this.vertSize;

    //the total number of floats in our batch
    var numVerts = this.size * 4 *  this.vertSize;
    //the total number of indices in our batch
    var numIndices = this.size * 6;

    //vertex data

    /**
    * Holds the vertices
    *
    * @property vertices
    * @type Float32Array
    */
    this.vertices = new Float32Array(numVerts);

    //index data
    /**
     * Holds the indices
     *
     * @property indices
     * @type Uint16Array
     */
    this.indices = new Uint16Array(numIndices);
    
    this.lastIndexCount = 0;

    for (var i=0, j=0; i < numIndices; i += 6, j += 4)
    {
        this.indices[i + 0] = j + 0;
        this.indices[i + 1] = j + 1;
        this.indices[i + 2] = j + 2;
        this.indices[i + 3] = j + 0;
        this.indices[i + 4] = j + 2;
        this.indices[i + 5] = j + 3;
    }


    this.drawing = false;
    this.currentBatchSize = 0;
    this.currentBaseTexture = null;
    
    this.setContext(gl);

    this.dirty = true;

    this.textures = [];
    this.blendModes = [];
};

/**
* 
* @method setContext
*
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.WebGLSpriteBatch.prototype.setContext = function(gl)
{
    this.gl = gl;

    // create a couple of buffers
    this.vertexBuffer = gl.createBuffer();
    this.indexBuffer = gl.createBuffer();

    // 65535 is max index, so 65535 / 6 = 10922.


    //upload the index data
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);

    this.currentBlendMode = 99999;
};

/**
* 
* @method begin
*
* @param renderSession {RenderSession} the RenderSession
*/
PIXI.WebGLSpriteBatch.prototype.begin = function(renderSession)
{
    this.renderSession = renderSession;
    this.shader = this.renderSession.shaderManager.defaultShader;

    this.start();
};

/**
* 
* @method end
*
*/
PIXI.WebGLSpriteBatch.prototype.end = function()
{
    this.flush();
};

/**
* 
* @method render
* 
* @param sprite {Sprite} the sprite to render when using this spritebatch
*/
PIXI.WebGLSpriteBatch.prototype.render = function(sprite)
{
    var texture = sprite.texture;
    
   //TODO set blend modes.. 
    // check texture..
    if(this.currentBatchSize >= this.size)
    {
        //return;
        this.flush();
        this.currentBaseTexture = texture.baseTexture;
    }

    // get the uvs for the texture
    var uvs = texture._uvs;
    // if the uvs have not updated then no point rendering just yet!
    if(!uvs)return;

    // get the sprites current alpha
    var alpha = sprite.worldAlpha;
    var tint = sprite.tint;

    var verticies = this.vertices;


    // TODO trim??
    var aX = sprite.anchor.x;
    var aY = sprite.anchor.y;

    var w0, w1, h0, h1;
        
    if (texture.trim)
    {
        // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..
        var trim = texture.trim;

        w1 = trim.x - aX * trim.width;
        w0 = w1 + texture.crop.width;

        h1 = trim.y - aY * trim.height;
        h0 = h1 + texture.crop.height;

    }
    else
    {
        w0 = (texture.frame.width ) * (1-aX);
        w1 = (texture.frame.width ) * -aX;

        h0 = texture.frame.height * (1-aY);
        h1 = texture.frame.height * -aY;
    }

    var index = this.currentBatchSize * 4 * this.vertSize;

    var worldTransform = sprite.worldTransform;

    var a = worldTransform.a;//[0];
    var b = worldTransform.c;//[3];
    var c = worldTransform.b;//[1];
    var d = worldTransform.d;//[4];
    var tx = worldTransform.tx;//[2];
    var ty = worldTransform.ty;///[5];

    // xy
    verticies[index++] = a * w1 + c * h1 + tx;
    verticies[index++] = d * h1 + b * w1 + ty;
    // uv
    verticies[index++] = uvs.x0;
    verticies[index++] = uvs.y0;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;

    // xy
    verticies[index++] = a * w0 + c * h1 + tx;
    verticies[index++] = d * h1 + b * w0 + ty;
    // uv
    verticies[index++] = uvs.x1;
    verticies[index++] = uvs.y1;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;

    // xy
    verticies[index++] = a * w0 + c * h0 + tx;
    verticies[index++] = d * h0 + b * w0 + ty;
    // uv
    verticies[index++] = uvs.x2;
    verticies[index++] = uvs.y2;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;

    // xy
    verticies[index++] = a * w1 + c * h0 + tx;
    verticies[index++] = d * h0 + b * w1 + ty;
    // uv
    verticies[index++] = uvs.x3;
    verticies[index++] = uvs.y3;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;
    
    // increment the batchsize
    this.textures[this.currentBatchSize] = sprite.texture.baseTexture;
    this.blendModes[this.currentBatchSize] = sprite.blendMode;

    this.currentBatchSize++;

};

/**
* Renders a tilingSprite using the spriteBatch
* @method renderTilingSprite
* 
* @param sprite {TilingSprite} the tilingSprite to render
*/
PIXI.WebGLSpriteBatch.prototype.renderTilingSprite = function(tilingSprite)
{
    var texture = tilingSprite.tilingTexture;

    
    // check texture..
    if(this.currentBatchSize >= this.size)
    {
        //return;
        this.flush();
        this.currentBaseTexture = texture.baseTexture;
    }

     // set the textures uvs temporarily
    // TODO create a separate texture so that we can tile part of a texture

    if(!tilingSprite._uvs)tilingSprite._uvs = new PIXI.TextureUvs();

    var uvs = tilingSprite._uvs;

    tilingSprite.tilePosition.x %= texture.baseTexture.width * tilingSprite.tileScaleOffset.x;
    tilingSprite.tilePosition.y %= texture.baseTexture.height * tilingSprite.tileScaleOffset.y;

    var offsetX =  tilingSprite.tilePosition.x/(texture.baseTexture.width*tilingSprite.tileScaleOffset.x);
    var offsetY =  tilingSprite.tilePosition.y/(texture.baseTexture.height*tilingSprite.tileScaleOffset.y);

    var scaleX =  (tilingSprite.width / texture.baseTexture.width)  / (tilingSprite.tileScale.x * tilingSprite.tileScaleOffset.x);
    var scaleY =  (tilingSprite.height / texture.baseTexture.height) / (tilingSprite.tileScale.y * tilingSprite.tileScaleOffset.y);

    uvs.x0 = 0 - offsetX;
    uvs.y0 = 0 - offsetY;

    uvs.x1 = (1 * scaleX) - offsetX;
    uvs.y1 = 0 - offsetY;

    uvs.x2 = (1 * scaleX) - offsetX;
    uvs.y2 = (1 * scaleY) - offsetY;

    uvs.x3 = 0 - offsetX;
    uvs.y3 = (1 *scaleY) - offsetY;

    // get the tilingSprites current alpha
    var alpha = tilingSprite.worldAlpha;
    var tint = tilingSprite.tint;

    var  verticies = this.vertices;

    var width = tilingSprite.width;
    var height = tilingSprite.height;

    // TODO trim??
    var aX = tilingSprite.anchor.x;
    var aY = tilingSprite.anchor.y;
    var w0 = width * (1-aX);
    var w1 = width * -aX;

    var h0 = height * (1-aY);
    var h1 = height * -aY;

    var index = this.currentBatchSize * 4 * this.vertSize;

    var worldTransform = tilingSprite.worldTransform;

    var a = worldTransform.a;//[0];
    var b = worldTransform.c;//[3];
    var c = worldTransform.b;//[1];
    var d = worldTransform.d;//[4];
    var tx = worldTransform.tx;//[2];
    var ty = worldTransform.ty;///[5];

    // xy
    verticies[index++] = a * w1 + c * h1 + tx;
    verticies[index++] = d * h1 + b * w1 + ty;
    // uv
    verticies[index++] = uvs.x0;
    verticies[index++] = uvs.y0;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;

    // xy
    verticies[index++] = (a * w0 + c * h1 + tx);
    verticies[index++] = d * h1 + b * w0 + ty;
    // uv
    verticies[index++] = uvs.x1;
    verticies[index++] = uvs.y1;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;
    
    // xy
    verticies[index++] = a * w0 + c * h0 + tx;
    verticies[index++] = d * h0 + b * w0 + ty;
    // uv
    verticies[index++] = uvs.x2;
    verticies[index++] = uvs.y2;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;

    // xy
    verticies[index++] = a * w1 + c * h0 + tx;
    verticies[index++] = d * h0 + b * w1 + ty;
    // uv
    verticies[index++] = uvs.x3;
    verticies[index++] = uvs.y3;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;

    // increment the batchs
    this.textures[this.currentBatchSize] = texture.baseTexture;
    this.blendModes[this.currentBatchSize] = tilingSprite.blendMode;
    this.currentBatchSize++;
};


/**
* Renders the content and empties the current batch
*
* @method flush
* 
*/
PIXI.WebGLSpriteBatch.prototype.flush = function()
{
    // If the batch is length 0 then return as there is nothing to draw
    if (this.currentBatchSize===0)return;

    var gl = this.gl;

    this.renderSession.shaderManager.setShader(this.renderSession.shaderManager.defaultShader);

    if(this.dirty)
    {
        this.dirty = false;
        // bind the main texture
        gl.activeTexture(gl.TEXTURE0);

        // bind the buffers
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

        // set the projection
        var projection = this.renderSession.projection;
        gl.uniform2f(this.shader.projectionVector, projection.x, projection.y);

        // set the pointers
        var stride =  this.vertSize * 4;
        gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);
        gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, false, stride, 2 * 4);
        gl.vertexAttribPointer(this.shader.colorAttribute, 2, gl.FLOAT, false, stride, 4 * 4);

    }

    // upload the verts to the buffer  
    if(this.currentBatchSize > ( this.size * 0.5 ) )
    {
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);
    }
    else
    {
        var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);
    }

    var nextTexture, nextBlendMode;
    var batchSize = 0;
    var start = 0;

    var currentBaseTexture = null;
    var currentBlendMode = this.renderSession.blendModeManager.currentBlendMode;

    for (var i = 0, j = this.currentBatchSize; i < j; i++) {
        
        nextTexture = this.textures[i];
        nextBlendMode = this.blendModes[i];

        if(currentBaseTexture !== nextTexture || currentBlendMode !== nextBlendMode)
        {
            this.renderBatch(currentBaseTexture, batchSize, start);

            start = i;
            batchSize = 0;
            currentBaseTexture = nextTexture;
            currentBlendMode = nextBlendMode;
            
            this.renderSession.blendModeManager.setBlendMode( currentBlendMode );
        }

        batchSize++;
    }

    this.renderBatch(currentBaseTexture, batchSize, start);

    // then reset the batch!
    this.currentBatchSize = 0;
};

PIXI.WebGLSpriteBatch.prototype.renderBatch = function(texture, size, startIndex)
{
    if(size === 0)return;

    var gl = this.gl;
    // bind the current texture
    gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id] || PIXI.createWebGLTexture(texture, gl));

    // check if a texture is dirty..
    if(texture._dirty[gl.id])
    {
        PIXI.updateWebGLTexture(this.currentBaseTexture, gl);
    }

    // now draw those suckas!
    gl.drawElements(gl.TRIANGLES, size * 6, gl.UNSIGNED_SHORT, startIndex * 6 * 2);
    
    // increment the draw count
    this.renderSession.drawCount++;
};

/**
* 
* @method stop
*
*/
PIXI.WebGLSpriteBatch.prototype.stop = function()
{
    this.flush();
};

/**
* 
* @method start
*
*/
PIXI.WebGLSpriteBatch.prototype.start = function()
{
    this.dirty = true;
};

/**
* Destroys the SpriteBatch
* @method destroy
*/
PIXI.WebGLSpriteBatch.prototype.destroy = function()
{

    this.vertices = null;
    this.indices = null;
    
    this.gl.deleteBuffer( this.vertexBuffer );
    this.gl.deleteBuffer( this.indexBuffer );
    
    this.currentBaseTexture = null;
    
    this.gl = null;
};


/**
 * @author Mat Groves
 * 
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original pixi version!
 *
 * Heavily inspired by LibGDX's WebGLSpriteBatch:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/WebGLSpriteBatch.java
 */

PIXI.WebGLFastSpriteBatch = function(gl)
{
   

    this.vertSize = 10;
    this.maxSize = 6000;//Math.pow(2, 16) /  this.vertSize;
    this.size = this.maxSize;

    //the total number of floats in our batch
    var numVerts = this.size * 4 *  this.vertSize;
    //the total number of indices in our batch
    var numIndices = this.maxSize * 6;

     //vertex data
    this.vertices = new Float32Array(numVerts);
    //index data
    this.indices = new Uint16Array(numIndices);
    
    this.vertexBuffer = null;
    this.indexBuffer = null;

    this.lastIndexCount = 0;

    for (var i=0, j=0; i < numIndices; i += 6, j += 4)
    {
        this.indices[i + 0] = j + 0;
        this.indices[i + 1] = j + 1;
        this.indices[i + 2] = j + 2;
        this.indices[i + 3] = j + 0;
        this.indices[i + 4] = j + 2;
        this.indices[i + 5] = j + 3;
    }

    this.drawing = false;
    this.currentBatchSize = 0;
    this.currentBaseTexture = null;
   
    this.currentBlendMode = 0;
    this.renderSession = null;
    

    this.shader = null;

    this.matrix = null;

    this.setContext(gl);
};

PIXI.WebGLFastSpriteBatch.prototype.setContext = function(gl)
{
    this.gl = gl;

    // create a couple of buffers
    this.vertexBuffer = gl.createBuffer();
    this.indexBuffer = gl.createBuffer();

    // 65535 is max index, so 65535 / 6 = 10922.


    //upload the index data
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);
};

PIXI.WebGLFastSpriteBatch.prototype.begin = function(spriteBatch, renderSession)
{
    this.renderSession = renderSession;
    this.shader = this.renderSession.shaderManager.fastShader;

    this.matrix = spriteBatch.worldTransform.toArray(true);

    this.start();
};

PIXI.WebGLFastSpriteBatch.prototype.end = function()
{
    this.flush();
};


PIXI.WebGLFastSpriteBatch.prototype.render = function(spriteBatch)
{

    var children = spriteBatch.children;
    var sprite = children[0];

    // if the uvs have not updated then no point rendering just yet!
    
    // check texture.
    if(!sprite.texture._uvs)return;
   
    this.currentBaseTexture = sprite.texture.baseTexture;
    
    // check blend mode
    if(sprite.blendMode !== this.renderSession.blendModeManager.currentBlendMode)
    {
        this.flush();
        this.renderSession.blendModeManager.setBlendMode(sprite.blendMode);
    }
    
    for(var i=0,j= children.length; i<j; i++)
    {
        this.renderSprite(children[i]);
    }

    this.flush();
};

PIXI.WebGLFastSpriteBatch.prototype.renderSprite = function(sprite)
{
    //sprite = children[i];
    if(!sprite.visible)return;
    
    // TODO trim??
    if(sprite.texture.baseTexture !== this.currentBaseTexture)
    {
        this.flush();
        this.currentBaseTexture = sprite.texture.baseTexture;
        
        if(!sprite.texture._uvs)return;
    }

    var uvs, verticies = this.vertices, width, height, w0, w1, h0, h1, index;

    uvs = sprite.texture._uvs;


    width = sprite.texture.frame.width;
    height = sprite.texture.frame.height;

    if (sprite.texture.trim)
    {
        // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..
        var trim = sprite.texture.trim;

        w1 = trim.x - sprite.anchor.x * trim.width;
        w0 = w1 + sprite.texture.crop.width;

        h1 = trim.y - sprite.anchor.y * trim.height;
        h0 = h1 + sprite.texture.crop.height;
    }
    else
    {
        w0 = (sprite.texture.frame.width ) * (1-sprite.anchor.x);
        w1 = (sprite.texture.frame.width ) * -sprite.anchor.x;

        h0 = sprite.texture.frame.height * (1-sprite.anchor.y);
        h1 = sprite.texture.frame.height * -sprite.anchor.y;
    }

    index = this.currentBatchSize * 4 * this.vertSize;

    // xy
    verticies[index++] = w1;
    verticies[index++] = h1;

    verticies[index++] = sprite.position.x;
    verticies[index++] = sprite.position.y;

    //scale
    verticies[index++] = sprite.scale.x;
    verticies[index++] = sprite.scale.y;

    //rotation
    verticies[index++] = sprite.rotation;

    // uv
    verticies[index++] = uvs.x0;
    verticies[index++] = uvs.y1;
    // color
    verticies[index++] = sprite.alpha;
 

    // xy
    verticies[index++] = w0;
    verticies[index++] = h1;

    verticies[index++] = sprite.position.x;
    verticies[index++] = sprite.position.y;

    //scale
    verticies[index++] = sprite.scale.x;
    verticies[index++] = sprite.scale.y;

     //rotation
    verticies[index++] = sprite.rotation;

    // uv
    verticies[index++] = uvs.x1;
    verticies[index++] = uvs.y1;
    // color
    verticies[index++] = sprite.alpha;
  

    // xy
    verticies[index++] = w0;
    verticies[index++] = h0;

    verticies[index++] = sprite.position.x;
    verticies[index++] = sprite.position.y;

    //scale
    verticies[index++] = sprite.scale.x;
    verticies[index++] = sprite.scale.y;

     //rotation
    verticies[index++] = sprite.rotation;

    // uv
    verticies[index++] = uvs.x2;
    verticies[index++] = uvs.y2;
    // color
    verticies[index++] = sprite.alpha;
 



    // xy
    verticies[index++] = w1;
    verticies[index++] = h0;

    verticies[index++] = sprite.position.x;
    verticies[index++] = sprite.position.y;

    //scale
    verticies[index++] = sprite.scale.x;
    verticies[index++] = sprite.scale.y;

     //rotation
    verticies[index++] = sprite.rotation;

    // uv
    verticies[index++] = uvs.x3;
    verticies[index++] = uvs.y3;
    // color
    verticies[index++] = sprite.alpha;

    // increment the batchs
    this.currentBatchSize++;

    if(this.currentBatchSize >= this.size)
    {
        this.flush();
    }
};

PIXI.WebGLFastSpriteBatch.prototype.flush = function()
{

    // If the batch is length 0 then return as there is nothing to draw
    if (this.currentBatchSize===0)return;

    var gl = this.gl;
    
    // bind the current texture

    if(!this.currentBaseTexture._glTextures[gl.id])PIXI.createWebGLTexture(this.currentBaseTexture, gl);

    gl.bindTexture(gl.TEXTURE_2D, this.currentBaseTexture._glTextures[gl.id]);

    // upload the verts to the buffer

   
    if(this.currentBatchSize > ( this.size * 0.5 ) )
    {
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);
    }
    else
    {
        var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);
    }
    
    
    // now draw those suckas!
    gl.drawElements(gl.TRIANGLES, this.currentBatchSize * 6, gl.UNSIGNED_SHORT, 0);
   
    // then reset the batch!
    this.currentBatchSize = 0;

    // increment the draw count
    this.renderSession.drawCount++;
};


PIXI.WebGLFastSpriteBatch.prototype.stop = function()
{
    this.flush();
};

PIXI.WebGLFastSpriteBatch.prototype.start = function()
{
    var gl = this.gl;

    // bind the main texture
    gl.activeTexture(gl.TEXTURE0);

    // bind the buffers
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

    // set the projection
    var projection = this.renderSession.projection;
    gl.uniform2f(this.shader.projectionVector, projection.x, projection.y);

    // set the matrix
    gl.uniformMatrix3fv(this.shader.uMatrix, false, this.matrix);

    // set the pointers
    var stride =  this.vertSize * 4;

    gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);
    gl.vertexAttribPointer(this.shader.aPositionCoord, 2, gl.FLOAT, false, stride, 2 * 4);
    gl.vertexAttribPointer(this.shader.aScale, 2, gl.FLOAT, false, stride, 4 * 4);
    gl.vertexAttribPointer(this.shader.aRotation, 1, gl.FLOAT, false, stride, 6 * 4);
    gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, false, stride, 7 * 4);
    gl.vertexAttribPointer(this.shader.colorAttribute, 1, gl.FLOAT, false, stride, 9 * 4);

    
};



/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class WebGLFilterManager
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
* @param transparent {Boolean} Whether or not the drawing context should be transparent
* @private
*/
PIXI.WebGLFilterManager = function(gl, transparent)
{
    this.transparent = transparent;

    this.filterStack = [];
    
    this.offsetX = 0;
    this.offsetY = 0;

    this.setContext(gl);
};

// API
/**
* Initialises the context and the properties
* @method setContext 
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.WebGLFilterManager.prototype.setContext = function(gl)
{
    this.gl = gl;
    this.texturePool = [];

    this.initShaderBuffers();
};

/**
* 
* @method begin
* @param renderSession {RenderSession} 
* @param buffer {ArrayBuffer} 
*/
PIXI.WebGLFilterManager.prototype.begin = function(renderSession, buffer)
{
    this.renderSession = renderSession;
    this.defaultShader = renderSession.shaderManager.defaultShader;

    var projection = this.renderSession.projection;
   // console.log(this.width)
    this.width = projection.x * 2;
    this.height = -projection.y * 2;
    this.buffer = buffer;
};

/**
* Applies the filter and adds it to the current filter stack
* @method pushFilter
* @param filterBlock {Object} the filter that will be pushed to the current filter stack
*/
PIXI.WebGLFilterManager.prototype.pushFilter = function(filterBlock)
{
    var gl = this.gl;

    var projection = this.renderSession.projection;
    var offset = this.renderSession.offset;

    filterBlock._filterArea = filterBlock.target.filterArea || filterBlock.target.getBounds();


    // filter program
    // OPTIMISATION - the first filter is free if its a simple color change?
    this.filterStack.push(filterBlock);

    var filter = filterBlock.filterPasses[0];

    this.offsetX += filterBlock._filterArea.x;
    this.offsetY += filterBlock._filterArea.y;

    var texture = this.texturePool.pop();
    if(!texture)
    {
        texture = new PIXI.FilterTexture(this.gl, this.width, this.height);
    }
    else
    {
        texture.resize(this.width, this.height);
    }

    gl.bindTexture(gl.TEXTURE_2D,  texture.texture);

    var filterArea = filterBlock._filterArea;// filterBlock.target.getBounds();///filterBlock.target.filterArea;

    var padding = filter.padding;
    filterArea.x -= padding;
    filterArea.y -= padding;
    filterArea.width += padding * 2;
    filterArea.height += padding * 2;

    // cap filter to screen size..
    if(filterArea.x < 0)filterArea.x = 0;
    if(filterArea.width > this.width)filterArea.width = this.width;
    if(filterArea.y < 0)filterArea.y = 0;
    if(filterArea.height > this.height)filterArea.height = this.height;

    //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  filterArea.width, filterArea.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, texture.frameBuffer);

    // set view port
    gl.viewport(0, 0, filterArea.width, filterArea.height);

    projection.x = filterArea.width/2;
    projection.y = -filterArea.height/2;

    offset.x = -filterArea.x;
    offset.y = -filterArea.y;

    // update projection
    // now restore the regular shader..
    this.renderSession.shaderManager.setShader(this.defaultShader);
    gl.uniform2f(this.defaultShader.projectionVector, filterArea.width/2, -filterArea.height/2);
    gl.uniform2f(this.defaultShader.offsetVector, -filterArea.x, -filterArea.y);

    gl.colorMask(true, true, true, true);
    gl.clearColor(0,0,0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    filterBlock._glFilterTexture = texture;

};


/**
* Removes the last filter from the filter stack and doesn't return it
* @method popFilter
*/
PIXI.WebGLFilterManager.prototype.popFilter = function()
{
    var gl = this.gl;
    var filterBlock = this.filterStack.pop();
    var filterArea = filterBlock._filterArea;
    var texture = filterBlock._glFilterTexture;
    var projection = this.renderSession.projection;
    var offset = this.renderSession.offset;

    if(filterBlock.filterPasses.length > 1)
    {
        gl.viewport(0, 0, filterArea.width, filterArea.height);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);

        this.vertexArray[0] = 0;
        this.vertexArray[1] = filterArea.height;

        this.vertexArray[2] = filterArea.width;
        this.vertexArray[3] = filterArea.height;

        this.vertexArray[4] = 0;
        this.vertexArray[5] = 0;

        this.vertexArray[6] = filterArea.width;
        this.vertexArray[7] = 0;

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
        // now set the uvs..
        this.uvArray[2] = filterArea.width/this.width;
        this.uvArray[5] = filterArea.height/this.height;
        this.uvArray[6] = filterArea.width/this.width;
        this.uvArray[7] = filterArea.height/this.height;

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);

        var inputTexture = texture;
        var outputTexture = this.texturePool.pop();
        if(!outputTexture)outputTexture = new PIXI.FilterTexture(this.gl, this.width, this.height);
        outputTexture.resize(this.width, this.height);

        // need to clear this FBO as it may have some left over elements from a previous filter.
        gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer );
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.disable(gl.BLEND);

        for (var i = 0; i < filterBlock.filterPasses.length-1; i++)
        {
            var filterPass = filterBlock.filterPasses[i];

            gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer );

            // set texture
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);

            // draw texture..
            //filterPass.applyFilterPass(filterArea.width, filterArea.height);
            this.applyFilterPass(filterPass, filterArea, filterArea.width, filterArea.height);

            // swap the textures..
            var temp = inputTexture;
            inputTexture = outputTexture;
            outputTexture = temp;
        }

        gl.enable(gl.BLEND);

        texture = inputTexture;
        this.texturePool.push(outputTexture);
    }

    var filter = filterBlock.filterPasses[filterBlock.filterPasses.length-1];

    this.offsetX -= filterArea.x;
    this.offsetY -= filterArea.y;


    var sizeX = this.width;
    var sizeY = this.height;

    var offsetX = 0;
    var offsetY = 0;

    var buffer = this.buffer;

    // time to render the filters texture to the previous scene
    if(this.filterStack.length === 0)
    {
        gl.colorMask(true, true, true, true);//this.transparent);
    }
    else
    {
        var currentFilter = this.filterStack[this.filterStack.length-1];
        filterArea = currentFilter._filterArea;

        sizeX = filterArea.width;
        sizeY = filterArea.height;

        offsetX = filterArea.x;
        offsetY = filterArea.y;

        buffer =  currentFilter._glFilterTexture.frameBuffer;
    }



    // TODO need toremove thease global elements..
    projection.x = sizeX/2;
    projection.y = -sizeY/2;

    offset.x = offsetX;
    offset.y = offsetY;

    filterArea = filterBlock._filterArea;

    var x = filterArea.x-offsetX;
    var y = filterArea.y-offsetY;

    // update the buffers..
    // make sure to flip the y!
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);

    this.vertexArray[0] = x;
    this.vertexArray[1] = y + filterArea.height;

    this.vertexArray[2] = x + filterArea.width;
    this.vertexArray[3] = y + filterArea.height;

    this.vertexArray[4] = x;
    this.vertexArray[5] = y;

    this.vertexArray[6] = x + filterArea.width;
    this.vertexArray[7] = y;

    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);

    this.uvArray[2] = filterArea.width/this.width;
    this.uvArray[5] = filterArea.height/this.height;
    this.uvArray[6] = filterArea.width/this.width;
    this.uvArray[7] = filterArea.height/this.height;

    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);

   //console.log(this.vertexArray)
   //console.log(this.uvArray)
    //console.log(sizeX + " : " + sizeY)

    gl.viewport(0, 0, sizeX, sizeY);

    // bind the buffer
    gl.bindFramebuffer(gl.FRAMEBUFFER, buffer );

    // set the blend mode! 
    //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)

    // set texture
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture.texture);

    // apply!
    this.applyFilterPass(filter, filterArea, sizeX, sizeY);

    // now restore the regular shader..
    this.renderSession.shaderManager.setShader(this.defaultShader);
    gl.uniform2f(this.defaultShader.projectionVector, sizeX/2, -sizeY/2);
    gl.uniform2f(this.defaultShader.offsetVector, -offsetX, -offsetY);

    // return the texture to the pool
    this.texturePool.push(texture);
    filterBlock._glFilterTexture = null;
};


/**
* Applies the filter to the specified area
* @method applyFilterPass
* @param filter {AbstractFilter} the filter that needs to be applied
* @param filterArea {texture} TODO - might need an update
* @param width {Number} the horizontal range of the filter
* @param height {Number} the vertical range of the filter
*/
PIXI.WebGLFilterManager.prototype.applyFilterPass = function(filter, filterArea, width, height)
{
    // use program
    var gl = this.gl;
    var shader = filter.shaders[gl.id];

    if(!shader)
    {
        shader = new PIXI.PixiShader(gl);

        shader.fragmentSrc = filter.fragmentSrc;
        shader.uniforms = filter.uniforms;
        shader.init();

        filter.shaders[gl.id] = shader;
    }

    // set the shader
    this.renderSession.shaderManager.setShader(shader);

//    gl.useProgram(shader.program);

    gl.uniform2f(shader.projectionVector, width/2, -height/2);
    gl.uniform2f(shader.offsetVector, 0,0);

    if(filter.uniforms.dimensions)
    {
        filter.uniforms.dimensions.value[0] = this.width;//width;
        filter.uniforms.dimensions.value[1] = this.height;//height;
        filter.uniforms.dimensions.value[2] = this.vertexArray[0];
        filter.uniforms.dimensions.value[3] = this.vertexArray[5];//filterArea.height;
    }

  //  console.log(this.uvArray )
    shader.syncUniforms();

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
    gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
    gl.vertexAttribPointer(shader.colorAttribute, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

    // draw the filter...
    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

    this.renderSession.drawCount++;
};

/**
* Initialises the shader buffers
* @method initShaderBuffers
*/
PIXI.WebGLFilterManager.prototype.initShaderBuffers = function()
{
    var gl = this.gl;

    // create some buffers
    this.vertexBuffer = gl.createBuffer();
    this.uvBuffer = gl.createBuffer();
    this.colorBuffer = gl.createBuffer();
    this.indexBuffer = gl.createBuffer();


    // bind and upload the vertexs..
    // keep a reference to the vertexFloatData..
    this.vertexArray = new Float32Array([0.0, 0.0,
                                         1.0, 0.0,
                                         0.0, 1.0,
                                         1.0, 1.0]);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(
    gl.ARRAY_BUFFER,
    this.vertexArray,
    gl.STATIC_DRAW);


    // bind and upload the uv buffer
    this.uvArray = new Float32Array([0.0, 0.0,
                                     1.0, 0.0,
                                     0.0, 1.0,
                                     1.0, 1.0]);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
    gl.bufferData(
    gl.ARRAY_BUFFER,
    this.uvArray,
    gl.STATIC_DRAW);

    this.colorArray = new Float32Array([1.0, 0xFFFFFF,
                                        1.0, 0xFFFFFF,
                                        1.0, 0xFFFFFF,
                                        1.0, 0xFFFFFF]);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
    gl.bufferData(
    gl.ARRAY_BUFFER,
    this.colorArray,
    gl.STATIC_DRAW);

    // bind and upload the index
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(
    gl.ELEMENT_ARRAY_BUFFER,
    new Uint16Array([0, 1, 2, 1, 3, 2]),
    gl.STATIC_DRAW);
};

/**
* Destroys the filter and removes it from the filter stack
* @method destroy
*/
PIXI.WebGLFilterManager.prototype.destroy = function()
{
    var gl = this.gl;

    this.filterStack = null;
    
    this.offsetX = 0;
    this.offsetY = 0;

    // destroy textures
    for (var i = 0; i < this.texturePool.length; i++) {
        this.texturePool[i].destroy();
    }
    
    this.texturePool = null;

    //destroy buffers..
    gl.deleteBuffer(this.vertexBuffer);
    gl.deleteBuffer(this.uvBuffer);
    gl.deleteBuffer(this.colorBuffer);
    gl.deleteBuffer(this.indexBuffer);
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class FilterTexture
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
* @param width {Number} the horizontal range of the filter
* @param height {Number} the vertical range of the filter
* @param scaleMode {Number} Should be one of the PIXI.scaleMode consts
* @private
*/
PIXI.FilterTexture = function(gl, width, height, scaleMode)
{
    /**
     * @property gl
     * @type WebGLContext
     */
    this.gl = gl;

    // next time to create a frame buffer and texture
    this.frameBuffer = gl.createFramebuffer();
    this.texture = gl.createTexture();

    scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;

    gl.bindTexture(gl.TEXTURE_2D,  this.texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer );

    gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer );
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);

    // required for masking a mask??
    this.renderBuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.renderBuffer);
  
    this.resize(width, height);
};


/**
* Clears the filter texture
* @method clear
*/
PIXI.FilterTexture.prototype.clear = function()
{
    var gl = this.gl;
    
    gl.clearColor(0,0,0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
};

/**
 * Resizes the texture to the specified width and height
 *
 * @method resize
 * @param width {Number} the new width of the texture
 * @param height {Number} the new height of the texture
 */
PIXI.FilterTexture.prototype.resize = function(width, height)
{
    if(this.width === width && this.height === height) return;

    this.width = width;
    this.height = height;

    var gl = this.gl;

    gl.bindTexture(gl.TEXTURE_2D,  this.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

    // update the stencil buffer width and height
    gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
};

/**
* Destroys the filter texture
* @method destroy
*/
PIXI.FilterTexture.prototype.destroy = function()
{
    var gl = this.gl;
    gl.deleteFramebuffer( this.frameBuffer );
    gl.deleteTexture( this.texture );

    this.frameBuffer = null;
    this.texture = null;
};

/**
 * @author Mat Groves
 * 
 * 
 */
/**
 * A set of functions used to handle masking
 *
 * @class CanvasMaskManager
 */
PIXI.CanvasMaskManager = function()
{
    
};

/**
 * This method adds it to the current stack of masks
 *
 * @method pushMask
 * @param maskData the maskData that will be pushed
 * @param context {Context2D} the 2d drawing method of the canvas
 */
PIXI.CanvasMaskManager.prototype.pushMask = function(maskData, context)
{
    context.save();
    
    var cacheAlpha = maskData.alpha;
    var transform = maskData.worldTransform;

    context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);

    PIXI.CanvasGraphics.renderGraphicsMask(maskData, context);

    context.clip();

    maskData.worldAlpha = cacheAlpha;
};

/**
 * Restores the current drawing context to the state it was before the mask was applied
 *
 * @method popMask
 * @param context {Context2D} the 2d drawing method of the canvas
 */
PIXI.CanvasMaskManager.prototype.popMask = function(context)
{
    context.restore();
};

/**
 * @author Mat Groves
 * 
 * 
 */

/**
 * @class CanvasTinter
 * @constructor
 * @static
 */
PIXI.CanvasTinter = function()
{
    /// this.textureCach
};

//PIXI.CanvasTinter.cachTint = true;
    

/**
 * Basically this method just needs a sprite and a color and tints the sprite 
 * with the given color
 * 
 * @method getTintedTexture 
 * @param sprite {Sprite} the sprite to tint
 * @param color {Number} the color to use to tint the sprite with
 */
PIXI.CanvasTinter.getTintedTexture = function(sprite, color)
{

    var texture = sprite.texture;

    color = PIXI.CanvasTinter.roundColor(color);

    var stringColor = "#" + ("00000" + ( color | 0).toString(16)).substr(-6);
   
    texture.tintCache = texture.tintCache || {};

    if(texture.tintCache[stringColor]) return texture.tintCache[stringColor];

     // clone texture..
    var canvas = PIXI.CanvasTinter.canvas || document.createElement("canvas");
    
    //PIXI.CanvasTinter.tintWithPerPixel(texture, stringColor, canvas);

    
    PIXI.CanvasTinter.tintMethod(texture, color, canvas);

    if(PIXI.CanvasTinter.convertTintToImage)
    {
        // is this better?
        var tintImage = new Image();
        tintImage.src = canvas.toDataURL();

        texture.tintCache[stringColor] = tintImage;
    }
    else
    {
      
        texture.tintCache[stringColor] = canvas;
        // if we are not converting the texture to an image then we need to lose the reference to the canvas
        PIXI.CanvasTinter.canvas = null;

    }

    return canvas;
};

/**
 * Tint a texture using the "multiply" operation
 * @method tintWithMultiply
 * @param texture {texture} the texture to tint
 * @param color {Number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */
PIXI.CanvasTinter.tintWithMultiply = function(texture, color, canvas)
{
    var context = canvas.getContext( "2d" );

    var frame = texture.frame;

    canvas.width = frame.width;
    canvas.height = frame.height;

    context.fillStyle = "#" + ("00000" + ( color | 0).toString(16)).substr(-6);
    
    context.fillRect(0, 0, frame.width, frame.height);
    
    context.globalCompositeOperation = "multiply";

    context.drawImage(texture.baseTexture.source,
                           frame.x,
                           frame.y,
                           frame.width,
                           frame.height,
                           0,
                           0,
                           frame.width,
                           frame.height);

    context.globalCompositeOperation = "destination-atop";
    
    context.drawImage(texture.baseTexture.source,
                           frame.x,
                           frame.y,
                           frame.width,
                           frame.height,
                           0,
                           0,
                           frame.width,
                           frame.height);
};

/**
 * Tint a texture using the "overlay" operation
 * @method tintWithOverlay
 * @param texture {texture} the texture to tint
 * @param color {Number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */
PIXI.CanvasTinter.tintWithOverlay = function(texture, color, canvas)
{
    var context = canvas.getContext( "2d" );

    var frame = texture.frame;

    canvas.width = frame.width;
    canvas.height = frame.height;

    
    
    context.globalCompositeOperation = "copy";
    context.fillStyle = "#" + ("00000" + ( color | 0).toString(16)).substr(-6);
    context.fillRect(0, 0, frame.width, frame.height);

    context.globalCompositeOperation = "destination-atop";
    context.drawImage(texture.baseTexture.source,
                           frame.x,
                           frame.y,
                           frame.width,
                           frame.height,
                           0,
                           0,
                           frame.width,
                           frame.height);

    
    //context.globalCompositeOperation = "copy";

};

/**
 * Tint a texture pixel per pixel
 * @method tintPerPixel
 * @param texture {texture} the texture to tint
 * @param color {Number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */
PIXI.CanvasTinter.tintWithPerPixel = function(texture, color, canvas)
{
    var context = canvas.getContext( "2d" );

    var frame = texture.frame;

    canvas.width = frame.width;
    canvas.height = frame.height;
  
    context.globalCompositeOperation = "copy";
    context.drawImage(texture.baseTexture.source,
                           frame.x,
                           frame.y,
                           frame.width,
                           frame.height,
                           0,
                           0,
                           frame.width,
                           frame.height);

    var rgbValues = PIXI.hex2rgb(color);
    var r = rgbValues[0], g = rgbValues[1], b = rgbValues[2];

    var pixelData = context.getImageData(0, 0, frame.width, frame.height);

    var pixels = pixelData.data;

    for (var i = 0; i < pixels.length; i += 4)
    {
        pixels[i+0] *= r;
        pixels[i+1] *= g;
        pixels[i+2] *= b;
    }

    context.putImageData(pixelData, 0, 0);
};

/**
 * Rounds the specified color according to the PIXI.CanvasTinter.cacheStepsPerColorChannel
 * @method roundColor
 * @param color {number} the color to round, should be a hex color
 */
PIXI.CanvasTinter.roundColor = function(color)
{
    var step = PIXI.CanvasTinter.cacheStepsPerColorChannel;

    var rgbValues = PIXI.hex2rgb(color);

    rgbValues[0] = Math.min(255, (rgbValues[0] / step) * step);
    rgbValues[1] = Math.min(255, (rgbValues[1] / step) * step);
    rgbValues[2] = Math.min(255, (rgbValues[2] / step) * step);

    return PIXI.rgb2hex(rgbValues);
};

/**
 * 
 * Number of steps which will be used as a cap when rounding colors
 *
 * @property cacheStepsPerColorChannel
 * @type Number
 */
PIXI.CanvasTinter.cacheStepsPerColorChannel = 8;
/**
 * 
 * Number of steps which will be used as a cap when rounding colors
 *
 * @property convertTintToImage
 * @type Boolean
 */
PIXI.CanvasTinter.convertTintToImage = false;

/**
 * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method
 *
 * @property canUseMultiply
 * @type Boolean
 */
PIXI.CanvasTinter.canUseMultiply = PIXI.canUseNewCanvasBlendModes();

PIXI.CanvasTinter.tintMethod = PIXI.CanvasTinter.canUseMultiply ? PIXI.CanvasTinter.tintWithMultiply :  PIXI.CanvasTinter.tintWithPerPixel;


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * the CanvasRenderer draws the stage and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.
 * Dont forget to add the view to your DOM or you will not see anything :)
 *
 * @class CanvasRenderer
 * @constructor
 * @param width=800 {Number} the width of the canvas view
 * @param height=600 {Number} the height of the canvas view
 * @param [view] {HTMLCanvasElement} the canvas to use as a view, optional
 * @param [transparent=false] {Boolean} the transparency of the render view, default false
 */
PIXI.CanvasRenderer = function(width, height, view, transparent)
{
    if(!PIXI.defaultRenderer)
    {
        PIXI.sayHello("Canvas");
        PIXI.defaultRenderer = this;
    }

    this.type = PIXI.CANVAS_RENDERER;

    /**
     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.
     * If the Stage is NOT transparent Pixi will use a canvas sized fillRect operation every frame to set the canvas background color.
     * If the Stage is transparent Pixi will use clearRect to clear the canvas every frame.
     * Disable this by setting this to false. For example if your game has a canvas filling background image you often don't need this set.
     *
     * @property clearBeforeRender
     * @type Boolean
     * @default
     */
    this.clearBeforeRender = true;

    /**
     * Whether the render view is transparent
     *
     * @property transparent
     * @type Boolean
     */
    this.transparent = !!transparent;

    if(!PIXI.blendModesCanvas)
    {
        PIXI.blendModesCanvas = [];

        if(PIXI.canUseNewCanvasBlendModes())
        {
            PIXI.blendModesCanvas[PIXI.blendModes.NORMAL]   = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.ADD]      = "lighter"; //IS THIS OK???
            PIXI.blendModesCanvas[PIXI.blendModes.MULTIPLY] = "multiply";
            PIXI.blendModesCanvas[PIXI.blendModes.SCREEN]   = "screen";
            PIXI.blendModesCanvas[PIXI.blendModes.OVERLAY]  = "overlay";
            PIXI.blendModesCanvas[PIXI.blendModes.DARKEN]   = "darken";
            PIXI.blendModesCanvas[PIXI.blendModes.LIGHTEN]  = "lighten";
            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_DODGE] = "color-dodge";
            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_BURN] = "color-burn";
            PIXI.blendModesCanvas[PIXI.blendModes.HARD_LIGHT] = "hard-light";
            PIXI.blendModesCanvas[PIXI.blendModes.SOFT_LIGHT] = "soft-light";
            PIXI.blendModesCanvas[PIXI.blendModes.DIFFERENCE] = "difference";
            PIXI.blendModesCanvas[PIXI.blendModes.EXCLUSION] = "exclusion";
            PIXI.blendModesCanvas[PIXI.blendModes.HUE]       = "hue";
            PIXI.blendModesCanvas[PIXI.blendModes.SATURATION] = "saturation";
            PIXI.blendModesCanvas[PIXI.blendModes.COLOR]      = "color";
            PIXI.blendModesCanvas[PIXI.blendModes.LUMINOSITY] = "luminosity";
        }
        else
        {
            // this means that the browser does not support the cool new blend modes in canvas "cough" ie "cough"
            PIXI.blendModesCanvas[PIXI.blendModes.NORMAL]   = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.ADD]      = "lighter"; //IS THIS OK???
            PIXI.blendModesCanvas[PIXI.blendModes.MULTIPLY] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.SCREEN]   = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.OVERLAY]  = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.DARKEN]   = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.LIGHTEN]  = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_DODGE] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_BURN] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.HARD_LIGHT] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.SOFT_LIGHT] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.DIFFERENCE] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.EXCLUSION] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.HUE]       = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.SATURATION] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.COLOR]      = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.LUMINOSITY] = "source-over";
        }
    }

    /**
     * The width of the canvas view
     *
     * @property width
     * @type Number
     * @default 800
     */
    this.width = width || 800;

    /**
     * The height of the canvas view
     *
     * @property height
     * @type Number
     * @default 600
     */
    this.height = height || 600;

    /**
     * The canvas element that everything is drawn to
     *
     * @property view
     * @type HTMLCanvasElement
     */
    this.view = view || document.createElement( "canvas" );

    /**
     * The canvas 2d context that everything is drawn with
     * @property context
     * @type HTMLCanvasElement 2d Context
     */
    this.context = this.view.getContext( "2d", { alpha: this.transparent } );

    this.refresh = true;
    // hack to enable some hardware acceleration!
    //this.view.style["transform"] = "translatez(0)";

    this.view.width = this.width;
    this.view.height = this.height;
    this.count = 0;

    /**
     * Instance of a PIXI.CanvasMaskManager, handles masking when using the canvas renderer
     * @property CanvasMaskManager
     * @type CanvasMaskManager
     */
    this.maskManager = new PIXI.CanvasMaskManager();

    /**
     * The render session is just a bunch of parameter used for rendering
     * @property renderSession
     * @type Object
     */
    this.renderSession = {
        context: this.context,
        maskManager: this.maskManager,
        scaleMode: null,
        smoothProperty: null,

        /**
         * If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
         * Handy for crisp pixel art and speed on legacy devices.
         *
         */
        roundPixels: false
    };

    if("imageSmoothingEnabled" in this.context)
        this.renderSession.smoothProperty = "imageSmoothingEnabled";
    else if("webkitImageSmoothingEnabled" in this.context)
        this.renderSession.smoothProperty = "webkitImageSmoothingEnabled";
    else if("mozImageSmoothingEnabled" in this.context)
        this.renderSession.smoothProperty = "mozImageSmoothingEnabled";
    else if("oImageSmoothingEnabled" in this.context)
        this.renderSession.smoothProperty = "oImageSmoothingEnabled";
};

// constructor
PIXI.CanvasRenderer.prototype.constructor = PIXI.CanvasRenderer;

/**
 * Renders the stage to its canvas view
 *
 * @method render
 * @param stage {Stage} the Stage element to be rendered
 */
PIXI.CanvasRenderer.prototype.render = function(stage)
{
    // update textures if need be
    PIXI.texturesToUpdate.length = 0;
    PIXI.texturesToDestroy.length = 0;

    stage.updateTransform();

    this.context.setTransform(1,0,0,1,0,0);
    this.context.globalAlpha = 1;

    if (navigator.isCocoonJS && this.view.screencanvas) {
        this.context.fillStyle = "black";
        this.context.clear();
    }

    if (!this.transparent && this.clearBeforeRender)
    {
        this.context.fillStyle = stage.backgroundColorString;
        this.context.fillRect(0, 0, this.width, this.height);
    }
    else if (this.transparent && this.clearBeforeRender)
    {
        this.context.clearRect(0, 0, this.width, this.height);
    }

    this.renderDisplayObject(stage);

    // run interaction!
    if(stage.interactive)
    {
        //need to add some events!
        if(!stage._interactiveEventsAdded)
        {
            stage._interactiveEventsAdded = true;
            stage.interactionManager.setTarget(this);
        }
    }

    // remove frame updates..
    if(PIXI.Texture.frameUpdates.length > 0)
    {
        PIXI.Texture.frameUpdates.length = 0;
    }
};

/**
 * Resizes the canvas view to the specified width and height
 *
 * @method resize
 * @param width {Number} the new width of the canvas view
 * @param height {Number} the new height of the canvas view
 */
PIXI.CanvasRenderer.prototype.resize = function(width, height)
{
    this.width = width;
    this.height = height;

    this.view.width = width;
    this.view.height = height;
};

/**
 * Renders a display object
 *
 * @method renderDisplayObject
 * @param displayObject {DisplayObject} The displayObject to render
 * @param context {Context2D} the context 2d method of the canvas
 * @private
 */
PIXI.CanvasRenderer.prototype.renderDisplayObject = function(displayObject, context)
{
    // no longer recursive!
    //var transform;
    //var context = this.context;

    this.renderSession.context = context || this.context;
    displayObject._renderCanvas(this.renderSession);
};

/**
 * Renders a flat strip
 *
 * @method renderStripFlat
 * @param strip {Strip} The Strip to render
 * @private
 */
PIXI.CanvasRenderer.prototype.renderStripFlat = function(strip)
{
    var context = this.context;
    var verticies = strip.verticies;

    var length = verticies.length/2;
    this.count++;

    context.beginPath();
    for (var i=1; i < length-2; i++)
    {
        // draw some triangles!
        var index = i*2;

        var x0 = verticies[index],   x1 = verticies[index+2], x2 = verticies[index+4];
        var y0 = verticies[index+1], y1 = verticies[index+3], y2 = verticies[index+5];

        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
    }

    context.fillStyle = "#FF0000";
    context.fill();
    context.closePath();
};

/**
 * Renders a strip
 *
 * @method renderStrip
 * @param strip {Strip} The Strip to render
 * @private
 */
PIXI.CanvasRenderer.prototype.renderStrip = function(strip)
{
    var context = this.context;

    // draw triangles!!
    var verticies = strip.verticies;
    var uvs = strip.uvs;

    var length = verticies.length/2;
    this.count++;

    for (var i = 1; i < length-2; i++)
    {
        // draw some triangles!
        var index = i*2;

        var x0 = verticies[index],   x1 = verticies[index+2], x2 = verticies[index+4];
        var y0 = verticies[index+1], y1 = verticies[index+3], y2 = verticies[index+5];

        var u0 = uvs[index] * strip.texture.width,   u1 = uvs[index+2] * strip.texture.width, u2 = uvs[index+4]* strip.texture.width;
        var v0 = uvs[index+1]* strip.texture.height, v1 = uvs[index+3] * strip.texture.height, v2 = uvs[index+5]* strip.texture.height;

        context.save();
        context.beginPath();
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
        context.closePath();

        context.clip();

        // Compute matrix transform
        var delta = u0*v1 + v0*u2 + u1*v2 - v1*u2 - v0*u1 - u0*v2;
        var deltaA = x0*v1 + v0*x2 + x1*v2 - v1*x2 - v0*x1 - x0*v2;
        var deltaB = u0*x1 + x0*u2 + u1*x2 - x1*u2 - x0*u1 - u0*x2;
        var deltaC = u0*v1*x2 + v0*x1*u2 + x0*u1*v2 - x0*v1*u2 - v0*u1*x2 - u0*x1*v2;
        var deltaD = y0*v1 + v0*y2 + y1*v2 - v1*y2 - v0*y1 - y0*v2;
        var deltaE = u0*y1 + y0*u2 + u1*y2 - y1*u2 - y0*u1 - u0*y2;
        var deltaF = u0*v1*y2 + v0*y1*u2 + y0*u1*v2 - y0*v1*u2 - v0*u1*y2 - u0*y1*v2;

        context.transform(deltaA / delta, deltaD / delta,
                            deltaB / delta, deltaE / delta,
                            deltaC / delta, deltaF / delta);

        context.drawImage(strip.texture.baseTexture.source, 0, 0);
        context.restore();
    }
};

/**
 * Creates a Canvas element of the given size
 *
 * @method CanvasBuffer
 * @param width {Number} the width for the newly created canvas
 * @param height {Number} the height for the newly created canvas
 * @static
 * @private
 */
PIXI.CanvasBuffer = function(width, height)
{
    this.width = width;
    this.height = height;

    this.canvas = document.createElement( "canvas" );
    this.context = this.canvas.getContext( "2d" );

    this.canvas.width = width;
    this.canvas.height = height;
};

/**
 * Clears the canvas that was created by the CanvasBuffer class
 *
 * @method clear
 * @private
 */
PIXI.CanvasBuffer.prototype.clear = function()
{
    this.context.clearRect(0,0, this.width, this.height);
};

/**
 * Resizes the canvas that was created by the CanvasBuffer class to the specified width and height
 *
 * @method resize
 * @param width {Number} the new width of the canvas
 * @param height {Number} the new height of the canvas
 * @private
 */

PIXI.CanvasBuffer.prototype.resize = function(width, height)
{
    this.width = this.canvas.width = width;
    this.height = this.canvas.height = height;
};


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */


/**
 * A set of functions used by the canvas renderer to draw the primitive graphics data
 *
 * @class CanvasGraphics
 */
PIXI.CanvasGraphics = function()
{

};


/*
 * Renders the graphics object
 *
 * @static
 * @private
 * @method renderGraphics
 * @param graphics {Graphics} the actual graphics object to render
 * @param context {Context2D} the 2d drawing method of the canvas
 */
PIXI.CanvasGraphics.renderGraphics = function(graphics, context)
{
    var worldAlpha = graphics.worldAlpha;
    var color = '';

    for (var i = 0; i < graphics.graphicsData.length; i++)
    {
        var data = graphics.graphicsData[i];
        var points = data.points;

        context.strokeStyle = color = '#' + ('00000' + ( data.lineColor | 0).toString(16)).substr(-6);

        context.lineWidth = data.lineWidth;

        if(data.type === PIXI.Graphics.POLY)
        {
            context.beginPath();

            context.moveTo(points[0], points[1]);

            for (var j=1; j < points.length/2; j++)
            {
                context.lineTo(points[j * 2], points[j * 2 + 1]);
            }

            // if the first and last point are the same close the path - much neater :)
            if(points[0] === points[points.length-2] && points[1] === points[points.length-1])
            {
                context.closePath();
            }

            if(data.fill)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);
                context.fill();
            }
            if(data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.stroke();
            }
        }
        else if(data.type === PIXI.Graphics.RECT)
        {

            if(data.fillColor || data.fillColor === 0)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);
                context.fillRect(points[0], points[1], points[2], points[3]);

            }
            if(data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.strokeRect(points[0], points[1], points[2], points[3]);
            }

        }
        else if(data.type === PIXI.Graphics.CIRC)
        {
            // TODO - need to be Undefined!
            context.beginPath();
            context.arc(points[0], points[1], points[2],0,2*Math.PI);
            context.closePath();

            if(data.fill)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);
                context.fill();
            }
            if(data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.stroke();
            }
        }
        else if(data.type === PIXI.Graphics.ELIP)
        {

            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas

            var ellipseData =  data.points;

            var w = ellipseData[2] * 2;
            var h = ellipseData[3] * 2;

            var x = ellipseData[0] - w/2;
            var y = ellipseData[1] - h/2;

            context.beginPath();

            var kappa = 0.5522848,
                ox = (w / 2) * kappa, // control point offset horizontal
                oy = (h / 2) * kappa, // control point offset vertical
                xe = x + w,           // x-end
                ye = y + h,           // y-end
                xm = x + w / 2,       // x-middle
                ym = y + h / 2;       // y-middle

            context.moveTo(x, ym);
            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);

            context.closePath();

            if(data.fill)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);
                context.fill();
            }
            if(data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.stroke();
            }
        }
        else if (data.type === PIXI.Graphics.RREC)
        {
            var rx = points[0];
            var ry = points[1];
            var width = points[2];
            var height = points[3];
            var radius = points[4];

            var maxRadius = Math.min(width, height) / 2 | 0;
            radius = radius > maxRadius ? maxRadius : radius;

            context.beginPath();
            context.moveTo(rx, ry + radius);
            context.lineTo(rx, ry + height - radius);
            context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
            context.lineTo(rx + width - radius, ry + height);
            context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
            context.lineTo(rx + width, ry + radius);
            context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
            context.lineTo(rx + radius, ry);
            context.quadraticCurveTo(rx, ry, rx, ry + radius);
            context.closePath();

            if(data.fillColor || data.fillColor === 0)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);
                context.fill();

            }
            if(data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.stroke();
            }
        }
    }
};

/*
 * Renders a graphics mask
 *
 * @static
 * @private
 * @method renderGraphicsMask
 * @param graphics {Graphics} the graphics which will be used as a mask
 * @param context {Context2D} the context 2d method of the canvas
 */
PIXI.CanvasGraphics.renderGraphicsMask = function(graphics, context)
{
    var len = graphics.graphicsData.length;

    if(len === 0) return;

    if(len > 1)
    {
        len = 1;
        window.console.log('Pixi.js warning: masks in canvas can only mask using the first path in the graphics object');
    }

    for (var i = 0; i < 1; i++)
    {
        var data = graphics.graphicsData[i];
        var points = data.points;

        if(data.type === PIXI.Graphics.POLY)
        {
            context.beginPath();
            context.moveTo(points[0], points[1]);

            for (var j=1; j < points.length/2; j++)
            {
                context.lineTo(points[j * 2], points[j * 2 + 1]);
            }

            // if the first and last point are the same close the path - much neater :)
            if(points[0] === points[points.length-2] && points[1] === points[points.length-1])
            {
                context.closePath();
            }

        }
        else if(data.type === PIXI.Graphics.RECT)
        {
            context.beginPath();
            context.rect(points[0], points[1], points[2], points[3]);
            context.closePath();
        }
        else if(data.type === PIXI.Graphics.CIRC)
        {
            // TODO - need to be Undefined!
            context.beginPath();
            context.arc(points[0], points[1], points[2],0,2*Math.PI);
            context.closePath();
        }
        else if(data.type === PIXI.Graphics.ELIP)
        {

            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
            var ellipseData =  data.points;

            var w = ellipseData[2] * 2;
            var h = ellipseData[3] * 2;

            var x = ellipseData[0] - w/2;
            var y = ellipseData[1] - h/2;

            context.beginPath();

            var kappa = 0.5522848,
                ox = (w / 2) * kappa, // control point offset horizontal
                oy = (h / 2) * kappa, // control point offset vertical
                xe = x + w,           // x-end
                ye = y + h,           // y-end
                xm = x + w / 2,       // x-middle
                ym = y + h / 2;       // y-middle

            context.moveTo(x, ym);
            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
            context.closePath();
        }
        else if (data.type === PIXI.Graphics.RREC)
        {
            var rx = points[0];
            var ry = points[1];
            var width = points[2];
            var height = points[3];
            var radius = points[4];

            var maxRadius = Math.min(width, height) / 2 | 0;
            radius = radius > maxRadius ? maxRadius : radius;

            context.beginPath();
            context.moveTo(rx, ry + radius);
            context.lineTo(rx, ry + height - radius);
            context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
            context.lineTo(rx + width - radius, ry + height);
            context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
            context.lineTo(rx + width, ry + radius);
            context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
            context.lineTo(rx + radius, ry);
            context.quadraticCurveTo(rx, ry, rx, ry + radius);
            context.closePath();
        }
    }
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */


/**
 * The Graphics class contains a set of methods that you can use to create primitive shapes and lines.
 * It is important to know that with the webGL renderer only simple polygons can be filled at this stage
 * Complex polygons will not be filled. Heres an example of a complex polygon: http://www.goodboydigital.com/wp-content/uploads/2013/06/complexPolygon.png
 *
 * @class Graphics
 * @extends DisplayObjectContainer
 * @constructor
 */
PIXI.Graphics = function()
{
    PIXI.DisplayObjectContainer.call( this );

    this.renderable = true;

    /**
     * The alpha of the fill of this graphics object
     *
     * @property fillAlpha
     * @type Number
     */
    this.fillAlpha = 1;

    /**
     * The width of any lines drawn
     *
     * @property lineWidth
     * @type Number
     */
    this.lineWidth = 0;

    /**
     * The color of any lines drawn
     *
     * @property lineColor
     * @type String
     */
    this.lineColor = "black";

    /**
     * Graphics data
     *
     * @property graphicsData
     * @type Array
     * @private
     */
    this.graphicsData = [];


    /**
     * The tint applied to the graphic shape. This is a hex value
     *
     * @property tint
     * @type Number
     * @default 0xFFFFFF
     */
    this.tint = 0xFFFFFF;// * Math.random();
    
    /**
     * The blend mode to be applied to the graphic shape
     *
     * @property blendMode
     * @type Number
     * @default PIXI.blendModes.NORMAL;
     */
    this.blendMode = PIXI.blendModes.NORMAL;
    
    /**
     * Current path
     *
     * @property currentPath
     * @type Object
     * @private
     */
    this.currentPath = {points:[]};

    /**
     * Array containing some WebGL-related properties used by the WebGL renderer
     *
     * @property _webGL
     * @type Array
     * @private
     */
    this._webGL = [];

    /**
     * Whether this shape is being used as a mask
     *
     * @property isMask
     * @type isMask
     */
    this.isMask = false;

    /**
     * The bounds of the graphic shape as rectangle object
     *
     * @property bounds
     * @type Rectangle
     */
    this.bounds = null;

    /**
     * the bounds' padding used for bounds calculation
     *
     * @property boundsPadding
     * @type Number
     */
    this.boundsPadding = 10;

    /**
     * Used to detect if the graphics object has changed if this is set to true then the graphics object will be recalculated
     * 
     * @type {Boolean}
     */
    this.dirty = true;
};

// constructor
PIXI.Graphics.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );
PIXI.Graphics.prototype.constructor = PIXI.Graphics;

/**
 * If cacheAsBitmap is true the graphics object will then be rendered as if it was a sprite.
 * This is useful if your graphics element does not change often as it will speed up the rendering of the object
 * It is also usful as the graphics object will always be antialiased because it will be rendered using canvas
 * Not recommended if you are constanly redrawing the graphics element.
 *
 * @property cacheAsBitmap
 * @default false
 * @type Boolean
 * @private
 */
Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", {
    get: function() {
        return  this._cacheAsBitmap;
    },
    set: function(value) {
        this._cacheAsBitmap = value;

        if(this._cacheAsBitmap)
        {
            this._generateCachedSprite();
        }
        else
        {
            this.destroyCachedSprite();
            this.dirty = true;
        }

    }
});


/**
 * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo() method or the drawCircle() method.
 *
 * @method lineStyle
 * @param lineWidth {Number} width of the line to draw, will update the object's stored style
 * @param color {Number} color of the line to draw, will update the object's stored style
 * @param alpha {Number} alpha of the line to draw, will update the object's stored style
 */
PIXI.Graphics.prototype.lineStyle = function(lineWidth, color, alpha)
{
    if (!this.currentPath.points.length) this.graphicsData.pop();

    this.lineWidth = lineWidth || 0;
    this.lineColor = color || 0;
    this.lineAlpha = (arguments.length < 3) ? 1 : alpha;

    this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,
                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling, points:[], type:PIXI.Graphics.POLY};

    this.graphicsData.push(this.currentPath);

    return this;
};

/**
 * Moves the current drawing position to (x, y).
 *
 * @method moveTo
 * @param x {Number} the X coordinate to move to
 * @param y {Number} the Y coordinate to move to
 */
PIXI.Graphics.prototype.moveTo = function(x, y)
{
    if (!this.currentPath.points.length) this.graphicsData.pop();

    this.currentPath = this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,
                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling, points:[], type:PIXI.Graphics.POLY};

    this.currentPath.points.push(x, y);

    this.graphicsData.push(this.currentPath);

    return this;
};

/**
 * Draws a line using the current line style from the current drawing position to (x, y);
 * the current drawing position is then set to (x, y).
 *
 * @method lineTo
 * @param x {Number} the X coordinate to draw to
 * @param y {Number} the Y coordinate to draw to
 */
PIXI.Graphics.prototype.lineTo = function(x, y)
{
    this.currentPath.points.push(x, y);
    this.dirty = true;

    return this;
};

/**
 * Calculate the points for a quadratic bezier curve.
 * Based on : https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
 *
 * @method quadraticCurveTo
 * @param  {number}   cpX   Control point x
 * @param  {number}   cpY   Control point y
 * @param  {number}   toX   Destination point x
 * @param  {number}   toY   Destination point y
 * @return {PIXI.Graphics}
 */
PIXI.Graphics.prototype.quadraticCurveTo = function(cpX, cpY, toX, toY)
{
    if( this.currentPath.points.length === 0)this.moveTo(0,0);

    var xa,
    ya,
    n = 20,
    points = this.currentPath.points;
    if(points.length === 0)this.moveTo(0, 0);
    

    var fromX = points[points.length-2];
    var fromY = points[points.length-1];

    var j = 0;
    for (var i = 1; i <= n; i++ )
    {
        j = i / n;

        xa = fromX + ( (cpX - fromX) * j );
        ya = fromY + ( (cpY - fromY) * j );

        points.push( xa + ( ((cpX + ( (toX - cpX) * j )) - xa) * j ),
                     ya + ( ((cpY + ( (toY - cpY) * j )) - ya) * j ) );
    }


    this.dirty = true;

    return this;
};

/**
 * Calculate the points for a bezier curve.
 *
 * @method bezierCurveTo
 * @param  {number}   cpX    Control point x
 * @param  {number}   cpY    Control point y
 * @param  {number}   cpX2   Second Control point x
 * @param  {number}   cpY2   Second Control point y
 * @param  {number}   toX    Destination point x
 * @param  {number}   toY    Destination point y
 * @return {PIXI.Graphics}
 */
PIXI.Graphics.prototype.bezierCurveTo = function(cpX, cpY, cpX2, cpY2, toX, toY)
{
    if( this.currentPath.points.length === 0)this.moveTo(0,0);

    var n = 20,
    dt,
    dt2,
    dt3,
    t2,
    t3,
    points = this.currentPath.points;

    var fromX = points[points.length-2];
    var fromY = points[points.length-1];
    
    var j = 0;

    for (var i=1; i<n; i++)
    {
        j = i / n;

        dt = (1 - j);
        dt2 = dt * dt;
        dt3 = dt2 * dt;

        t2 = j * j;
        t3 = t2 * j;
        
        points.push( dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX,
                     dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
        
    }
    
    this.dirty = true;

    return this;
};

/*
 * the arcTo() method creates an arc/curve between two tangents on the canvas.
 * 
 * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
 *
 * @method arcTo
 * @param  {number}   x1        The x-coordinate of the beginning of the arc
 * @param  {number}   y1        The y-coordinate of the beginning of the arc
 * @param  {number}   x2        The x-coordinate of the end of the arc
 * @param  {number}   y2        The y-coordinate of the end of the arc
 * @param  {number}   radius    The radius of the arc
 * @return {PIXI.Graphics}
 */
PIXI.Graphics.prototype.arcTo = function(x1, y1, x2, y2, radius)
{
    // check that path contains subpaths
    if( this.currentPath.points.length === 0)this.moveTo(x1, y1);
    
    var points = this.currentPath.points;
    var fromX = points[points.length-2];
    var fromY = points[points.length-1];

//    points.push( x1,  y1);

    var a1 = fromY - y1;
    var b1 = fromX - x1;
    var a2 = y2   - y1;
    var b2 = x2   - x1;
    var mm = Math.abs(a1 * b2 - b1 * a2);

    if (mm < 1.0e-8 || radius === 0)
    {
        points.push(x1, y1);
    }
    else
    {
        var dd = a1 * a1 + b1 * b1;
        var cc = a2 * a2 + b2 * b2;
        var tt = a1 * a2 + b1 * b2;
        var k1 = radius * Math.sqrt(dd) / mm;
        var k2 = radius * Math.sqrt(cc) / mm;
        var j1 = k1 * tt / dd;
        var j2 = k2 * tt / cc;
        var cx = k1 * b2 + k2 * b1;
        var cy = k1 * a2 + k2 * a1;
        var px = b1 * (k2 + j1);
        var py = a1 * (k2 + j1);
        var qx = b2 * (k1 + j2);
        var qy = a2 * (k1 + j2);
        var startAngle = Math.atan2(py - cy, px - cx);
        var endAngle   = Math.atan2(qy - cy, qx - cx);
        // not required?
     //   points.push(px + x1 , py + y1);
        this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);
    }

    this.dirty = true;

    return this;
};

/**
 * The arc() method creates an arc/curve (used to create circles, or parts of circles).
 *
 * @method arc
 * @param  {number}   cx                The x-coordinate of the center of the circle
 * @param  {number}   cy                The y-coordinate of the center of the circle
 * @param  {number}   radius            The radius of the circle
 * @param  {number}   startAngle        The starting angle, in radians (0 is at the 3 o'clock position of the arc's circle)
 * @param  {number}   endAngle          The ending angle, in radians
 * @param  {number}   anticlockwise     Optional. Specifies whether the drawing should be counterclockwise or clockwise. False is default, and indicates clockwise, while true indicates counter-clockwise.
 * @return {PIXI.Graphics}
 */
PIXI.Graphics.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise)
{
    var startX = cx + Math.cos(startAngle) * radius;
    var startY = cy + Math.sin(startAngle) * radius;
    
    var points = this.currentPath.points;

    if(points.length !== 0 && points[points.length-2] !== startX || points[points.length-1] !== startY)
    {
        this.moveTo(startX, startY);
        points = this.currentPath.points;
    }

    if (startAngle === endAngle)return this;

    if( !anticlockwise && endAngle <= startAngle )
    {
        endAngle += Math.PI * 2;
    }
    else if( anticlockwise && startAngle <= endAngle )
    {
        startAngle += Math.PI * 2;
    }

    var sweep = anticlockwise ? (startAngle - endAngle) *-1 : (endAngle - startAngle);
    var segs =  ( Math.abs(sweep)/ (Math.PI * 2) ) * 40;

    if( sweep === 0 ) return this;

    var theta = sweep/(segs*2);
    var theta2 = theta*2;

    var cTheta = Math.cos(theta);
    var sTheta = Math.sin(theta);
    
    var segMinus = segs - 1;

    var remainder = ( segMinus % 1 ) / segMinus;

    for(var i=0; i<=segMinus; i++)
    {
        var real =  i + remainder * i;

    
        var angle = ((theta) + startAngle + (theta2 * real));

        var c = Math.cos(angle);
        var s = -Math.sin(angle);

        points.push(( (cTheta *  c) + (sTheta * s) ) * radius + cx,
                    ( (cTheta * -s) + (sTheta * c) ) * radius + cy);
    }

    this.dirty = true;

    return this;
};

/**
 * Draws a line using the current line style from the current drawing position to (x, y);
 * the current drawing position is then set to (x, y).
 *
 * @method lineTo
 * @param x {Number} the X coordinate to draw to
 * @param y {Number} the Y coordinate to draw to
 */
PIXI.Graphics.prototype.drawPath = function(path)
{
    if (!this.currentPath.points.length) this.graphicsData.pop();

    this.currentPath = this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,
                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling, points:[], type:PIXI.Graphics.POLY};

    this.graphicsData.push(this.currentPath);

    this.currentPath.points = this.currentPath.points.concat(path);
    this.dirty = true;

    return this;
};

/**
 * Specifies a simple one-color fill that subsequent calls to other Graphics methods
 * (such as lineTo() or drawCircle()) use when drawing.
 *
 * @method beginFill
 * @param color {Number} the color of the fill
 * @param alpha {Number} the alpha of the fill
 */
PIXI.Graphics.prototype.beginFill = function(color, alpha)
{

    this.filling = true;
    this.fillColor = color || 0;
    this.fillAlpha = (arguments.length < 2) ? 1 : alpha;

    return this;
};

/**
 * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
 *
 * @method endFill
 */
PIXI.Graphics.prototype.endFill = function()
{
    this.filling = false;
    this.fillColor = null;
    this.fillAlpha = 1;

    return this;
};

/**
 * @method drawRect
 *
 * @param x {Number} The X coord of the top-left of the rectangle
 * @param y {Number} The Y coord of the top-left of the rectangle
 * @param width {Number} The width of the rectangle
 * @param height {Number} The height of the rectangle
 */
PIXI.Graphics.prototype.drawRect = function( x, y, width, height )
{
    if (!this.currentPath.points.length) this.graphicsData.pop();

    this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,
                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling,
                        points:[x, y, width, height], type:PIXI.Graphics.RECT};

    this.graphicsData.push(this.currentPath);
    this.dirty = true;

    return this;
};

/**
 * @method drawRoundedRect
 *
 * @param x {Number} The X coord of the top-left of the rectangle
 * @param y {Number} The Y coord of the top-left of the rectangle
 * @param width {Number} The width of the rectangle
 * @param height {Number} The height of the rectangle
 * @param radius {Number} Radius of the rectangle corners
 */
PIXI.Graphics.prototype.drawRoundedRect = function( x, y, width, height, radius )
{
    if (!this.currentPath.points.length) this.graphicsData.pop();

    this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,
                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling,
                        points:[x, y, width, height, radius], type:PIXI.Graphics.RREC};

    this.graphicsData.push(this.currentPath);
    this.dirty = true;

    return this;
};

/**
 * Draws a circle.
 *
 * @method drawCircle
 * @param x {Number} The X coordinate of the center of the circle
 * @param y {Number} The Y coordinate of the center of the circle
 * @param radius {Number} The radius of the circle
 */
PIXI.Graphics.prototype.drawCircle = function(x, y, radius)
{

    if (!this.currentPath.points.length) this.graphicsData.pop();

    this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,
                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling,
                        points:[x, y, radius, radius], type:PIXI.Graphics.CIRC};

    this.graphicsData.push(this.currentPath);
    this.dirty = true;

    return this;
};

/**
 * Draws an ellipse.
 *
 * @method drawEllipse
 * @param x {Number} The X coordinate of the center of the ellipse
 * @param y {Number} The Y coordinate of the center of the ellipse
 * @param width {Number} The half width of the ellipse
 * @param height {Number} The half height of the ellipse
 */
PIXI.Graphics.prototype.drawEllipse = function(x, y, width, height)
{

    if (!this.currentPath.points.length) this.graphicsData.pop();

    this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,
                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling,
                        points:[x, y, width, height], type:PIXI.Graphics.ELIP};

    this.graphicsData.push(this.currentPath);
    this.dirty = true;

    return this;
};

/**
 * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
 *
 * @method clear
 */
PIXI.Graphics.prototype.clear = function()
{
    this.lineWidth = 0;
    this.filling = false;

    this.dirty = true;
    this.clearDirty = true;
    this.graphicsData = [];

    this.bounds = null; //new PIXI.Rectangle();

    return this;
};

/**
 * Useful function that returns a texture of the graphics object that can then be used to create sprites
 * This can be quite useful if your geometry is complicated and needs to be reused multiple times.
 *
 * @method generateTexture
 * @return {Texture} a texture of the graphics object
 */
PIXI.Graphics.prototype.generateTexture = function()
{
    var bounds = this.getBounds();

    var canvasBuffer = new PIXI.CanvasBuffer(bounds.width, bounds.height);
    var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);

    canvasBuffer.context.translate(-bounds.x,-bounds.y);
    
    PIXI.CanvasGraphics.renderGraphics(this, canvasBuffer.context);

    return texture;
};

/**
* Renders the object using the WebGL renderer
*
* @method _renderWebGL
* @param renderSession {RenderSession} 
* @private
*/
PIXI.Graphics.prototype._renderWebGL = function(renderSession)
{
    // if the sprite is not visible or the alpha is 0 then no need to render this element
    if(this.visible === false || this.alpha === 0 || this.isMask === true)return;
    

    if(this._cacheAsBitmap)
    {
       
        if(this.dirty)
        {
            this._generateCachedSprite();
            // we will also need to update the texture on the gpu too!
            PIXI.updateWebGLTexture(this._cachedSprite.texture.baseTexture, renderSession.gl);
            
            this.dirty =  false;
        }

        this._cachedSprite.alpha = this.alpha;
        PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession);

        return;
    }
    else
    {
        renderSession.spriteBatch.stop();
        renderSession.blendModeManager.setBlendMode(this.blendMode);

        if(this._mask)renderSession.maskManager.pushMask(this._mask, renderSession);
        if(this._filters)renderSession.filterManager.pushFilter(this._filterBlock);
      
        // check blend mode
        if(this.blendMode !== renderSession.spriteBatch.currentBlendMode)
        {
            renderSession.spriteBatch.currentBlendMode = this.blendMode;
            var blendModeWebGL = PIXI.blendModesWebGL[renderSession.spriteBatch.currentBlendMode];
            renderSession.spriteBatch.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
        }
        
      //  for (var i = this.graphicsData.length - 1; i >= 0; i--) {
        //    this.graphicsData[i]
            
//        };

        PIXI.WebGLGraphics.renderGraphics(this, renderSession);
        
        // only render if it has children!
        if(this.children.length)
        {
            renderSession.spriteBatch.start();

             // simple render children!
            for(var i=0, j=this.children.length; i<j; i++)
            {
                this.children[i]._renderWebGL(renderSession);
            }

            renderSession.spriteBatch.stop();
        }

        if(this._filters)renderSession.filterManager.popFilter();
        if(this._mask)renderSession.maskManager.popMask(this.mask, renderSession);
          
        renderSession.drawCount++;

        renderSession.spriteBatch.start();
    }
};

/**
* Renders the object using the Canvas renderer
*
* @method _renderCanvas
* @param renderSession {RenderSession} 
* @private
*/
PIXI.Graphics.prototype._renderCanvas = function(renderSession)
{
    // if the sprite is not visible or the alpha is 0 then no need to render this element
    if(this.visible === false || this.alpha === 0 || this.isMask === true)return;
    
    var context = renderSession.context;
    var transform = this.worldTransform;
    
    if(this.blendMode !== renderSession.currentBlendMode)
    {
        renderSession.currentBlendMode = this.blendMode;
        context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];
    }

    if(this._mask)
    {
        renderSession.maskManager.pushMask(this._mask, renderSession.context);
    }

    context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);
    PIXI.CanvasGraphics.renderGraphics(this, context);

     // simple render children!
    for(var i=0, j=this.children.length; i<j; i++)
    {
        this.children[i]._renderCanvas(renderSession);
    }

    if(this._mask)
    {
        renderSession.maskManager.popMask(renderSession.context);
    }
};

/**
 * Retrieves the bounds of the graphic shape as a rectangle object
 *
 * @method getBounds
 * @return {Rectangle} the rectangular bounding area
 */
PIXI.Graphics.prototype.getBounds = function( matrix )
{
    if(!this.bounds)this.updateBounds();

    var w0 = this.bounds.x;
    var w1 = this.bounds.width + this.bounds.x;

    var h0 = this.bounds.y;
    var h1 = this.bounds.height + this.bounds.y;

    var worldTransform = matrix || this.worldTransform;

    var a = worldTransform.a;
    var b = worldTransform.c;
    var c = worldTransform.b;
    var d = worldTransform.d;
    var tx = worldTransform.tx;
    var ty = worldTransform.ty;

    var x1 = a * w1 + c * h1 + tx;
    var y1 = d * h1 + b * w1 + ty;

    var x2 = a * w0 + c * h1 + tx;
    var y2 = d * h1 + b * w0 + ty;

    var x3 = a * w0 + c * h0 + tx;
    var y3 = d * h0 + b * w0 + ty;

    var x4 =  a * w1 + c * h0 + tx;
    var y4 =  d * h0 + b * w1 + ty;

    var maxX = x1;
    var maxY = y1;

    var minX = x1;
    var minY = y1;

    minX = x2 < minX ? x2 : minX;
    minX = x3 < minX ? x3 : minX;
    minX = x4 < minX ? x4 : minX;

    minY = y2 < minY ? y2 : minY;
    minY = y3 < minY ? y3 : minY;
    minY = y4 < minY ? y4 : minY;

    maxX = x2 > maxX ? x2 : maxX;
    maxX = x3 > maxX ? x3 : maxX;
    maxX = x4 > maxX ? x4 : maxX;

    maxY = y2 > maxY ? y2 : maxY;
    maxY = y3 > maxY ? y3 : maxY;
    maxY = y4 > maxY ? y4 : maxY;

    var bounds = this._bounds;

    bounds.x = minX;
    bounds.width = maxX - minX;

    bounds.y = minY;
    bounds.height = maxY - minY;

    return bounds;
};

/**
 * Update the bounds of the object
 *
 * @method updateBounds
 */
PIXI.Graphics.prototype.updateBounds = function()
{
    
    var minX = Infinity;
    var maxX = -Infinity;

    var minY = Infinity;
    var maxY = -Infinity;

    var points, x, y, w, h;

    for (var i = 0; i < this.graphicsData.length; i++) {
        var data = this.graphicsData[i];
        var type = data.type;
        var lineWidth = data.lineWidth;

        points = data.points;

        if(type === PIXI.Graphics.RECT)
        {
            x = points[0] - lineWidth/2;
            y = points[1] - lineWidth/2;
            w = points[2] + lineWidth;
            h = points[3] + lineWidth;

            minX = x < minX ? x : minX;
            maxX = x + w > maxX ? x + w : maxX;

            minY = y < minY ? x : minY;
            maxY = y + h > maxY ? y + h : maxY;
        }
        else if(type === PIXI.Graphics.CIRC || type === PIXI.Graphics.ELIP)
        {
            x = points[0];
            y = points[1];
            w = points[2] + lineWidth/2;
            h = points[3] + lineWidth/2;

            minX = x - w < minX ? x - w : minX;
            maxX = x + w > maxX ? x + w : maxX;

            minY = y - h < minY ? y - h : minY;
            maxY = y + h > maxY ? y + h : maxY;
        }
        else
        {
            // POLY
            for (var j = 0; j < points.length; j+=2)
            {

                x = points[j];
                y = points[j+1];
                minX = x-lineWidth < minX ? x-lineWidth : minX;
                maxX = x+lineWidth > maxX ? x+lineWidth : maxX;

                minY = y-lineWidth < minY ? y-lineWidth : minY;
                maxY = y+lineWidth > maxY ? y+lineWidth : maxY;
            }
        }
    }

    var padding = this.boundsPadding;
    this.bounds = new PIXI.Rectangle(minX - padding, minY - padding, (maxX - minX) + padding * 2, (maxY - minY) + padding * 2);
};


/**
 * Generates the cached sprite when the sprite has cacheAsBitmap = true
 *
 * @method _generateCachedSprite
 * @private
 */
PIXI.Graphics.prototype._generateCachedSprite = function()
{
    var bounds = this.getLocalBounds();

    if(!this._cachedSprite)
    {
        var canvasBuffer = new PIXI.CanvasBuffer(bounds.width, bounds.height);
        var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);
        
        this._cachedSprite = new PIXI.Sprite(texture);
        this._cachedSprite.buffer = canvasBuffer;

        this._cachedSprite.worldTransform = this.worldTransform;
    }
    else
    {
        this._cachedSprite.buffer.resize(bounds.width, bounds.height);
    }

    // leverage the anchor to account for the offset of the element
    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );
    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );

   // this._cachedSprite.buffer.context.save();
    this._cachedSprite.buffer.context.translate(-bounds.x,-bounds.y);
    
    PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context);
    this._cachedSprite.alpha = this.alpha;

   // this._cachedSprite.buffer.context.restore();
};

PIXI.Graphics.prototype.destroyCachedSprite = function()
{
    this._cachedSprite.texture.destroy(true);

    // let the gc collect the unused sprite
    // TODO could be object pooled!
    this._cachedSprite = null;
};


// SOME TYPES:
PIXI.Graphics.POLY = 0;
PIXI.Graphics.RECT = 1;
PIXI.Graphics.CIRC = 2;
PIXI.Graphics.ELIP = 3;
PIXI.Graphics.RREC = 4;


/**
 * @author Mat Groves http://matgroves.com/
 */

 /**
 * 
 * @class Strip
 * @extends DisplayObjectContainer
 * @constructor
 * @param texture {Texture} The texture to use
 * @param width {Number} the width 
 * @param height {Number} the height
 * 
 */
PIXI.Strip = function(texture)
{
    PIXI.DisplayObjectContainer.call( this );
    
    this.texture = texture;

    // set up the main bits..
    this.uvs = new PIXI.Float32Array([0, 1,
                                    1, 1,
                                    1, 0,
                                    0,1]);

    this.verticies = new PIXI.Float32Array([0, 0,
                      100,0,
                      100,100,
                      0, 100]);

    this.colors = new PIXI.Float32Array([1, 1, 1, 1]);

    this.indices = new PIXI.Uint16Array([0, 1, 2, 3]);
    

    this.dirty = true;
};

// constructor
PIXI.Strip.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
PIXI.Strip.prototype.constructor = PIXI.Strip;

PIXI.Strip.prototype._renderWebGL = function(renderSession)
{
    // if the sprite is not visible or the alpha is 0 then no need to render this element
    if(!this.visible || this.alpha <= 0)return;
    // render triangle strip..

    renderSession.spriteBatch.stop();

    // init! init!
    if(!this._vertexBuffer)this._initWebGL(renderSession);
    
    renderSession.shaderManager.setShader(renderSession.shaderManager.stripShader);

    this._renderStrip(renderSession);

    ///renderSession.shaderManager.activateDefaultShader();

    renderSession.spriteBatch.start();

    //TODO check culling  
};

PIXI.Strip.prototype._initWebGL = function(renderSession)
{
    // build the strip!
    var gl = renderSession.gl;
    
    this._vertexBuffer = gl.createBuffer();
    this._indexBuffer = gl.createBuffer();
    this._uvBuffer = gl.createBuffer();
    this._colorBuffer = gl.createBuffer();
    
    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.verticies, gl.DYNAMIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer);
    gl.bufferData(gl.ARRAY_BUFFER,  this.uvs, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this._colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.colors, gl.STATIC_DRAW);
 
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
};

PIXI.Strip.prototype._renderStrip = function(renderSession)
{
    var gl = renderSession.gl;
    var projection = renderSession.projection,
        offset = renderSession.offset,
        shader = renderSession.shaderManager.stripShader;


    // gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mat4Real);

    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

    // set uniforms
    gl.uniformMatrix3fv(shader.translationMatrix, false, this.worldTransform.toArray(true));
    gl.uniform2f(shader.projectionVector, projection.x, -projection.y);
    gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);
    gl.uniform1f(shader.alpha, 1);

    if(!this.dirty)
    {
        
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.verticies);
        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
        
        // update the uvs
        gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer);
        gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
            
        gl.activeTexture(gl.TEXTURE0);
         // bind the current texture
        gl.bindTexture(gl.TEXTURE_2D, this.texture.baseTexture._glTextures[gl.id] || PIXI.createWebGLTexture(this.texture.baseTexture, gl));
    
        // dont need to upload!
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    
    
    }
    else
    {

        this.dirty = false;
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.verticies, gl.STATIC_DRAW);
        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
        
        // update the uvs
        gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.uvs, gl.STATIC_DRAW);
        gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
            
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.texture.baseTexture._glTextures[gl.id] || PIXI.createWebGLTexture(this.texture.baseTexture, gl));
    
        // dont need to upload!
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
        
    }
    //console.log(gl.TRIANGLE_STRIP)
    //
    //
    gl.drawElements(gl.TRIANGLE_STRIP, this.indices.length, gl.UNSIGNED_SHORT, 0);
    
  
};

PIXI.Strip.prototype._renderCanvas = function(renderSession)
{
    var context = renderSession.context;
    
    var transform = this.worldTransform;

    if (renderSession.roundPixels)
    {
        context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx | 0, transform.ty | 0);
    }
    else
    {
        context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);
    }
        
    var strip = this;
    // draw triangles!!
    var verticies = strip.verticies;
    var uvs = strip.uvs;

    var length = verticies.length/2;
    this.count++;

    for (var i = 0; i < length-2; i++)
    {
        // draw some triangles!
        var index = i*2;

        var x0 = verticies[index],   x1 = verticies[index+2], x2 = verticies[index+4];
        var y0 = verticies[index+1], y1 = verticies[index+3], y2 = verticies[index+5];

        if(true)
        {

            //expand();
            var centerX = (x0 + x1 + x2)/3;
            var centerY = (y0 + y1 + y2)/3;

            var normX = x0 - centerX;
            var normY = y0 - centerY;

            var dist = Math.sqrt( normX * normX + normY * normY );
            x0 = centerX + (normX / dist) * (dist + 3);
            y0 = centerY + (normY / dist) * (dist + 3);

            // 
            
            normX = x1 - centerX;
            normY = y1 - centerY;

            dist = Math.sqrt( normX * normX + normY * normY );
            x1 = centerX + (normX / dist) * (dist + 3);
            y1 = centerY + (normY / dist) * (dist + 3);

            normX = x2 - centerX;
            normY = y2 - centerY;

            dist = Math.sqrt( normX * normX + normY * normY );
            x2 = centerX + (normX / dist) * (dist + 3);
            y2 = centerY + (normY / dist) * (dist + 3);

        }

        var u0 = uvs[index] * strip.texture.width,   u1 = uvs[index+2] * strip.texture.width, u2 = uvs[index+4]* strip.texture.width;
        var v0 = uvs[index+1]* strip.texture.height, v1 = uvs[index+3] * strip.texture.height, v2 = uvs[index+5]* strip.texture.height;

        context.save();
        context.beginPath();


        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);

        context.closePath();

        context.clip();

        // Compute matrix transform
        var delta = u0*v1 + v0*u2 + u1*v2 - v1*u2 - v0*u1 - u0*v2;
        var deltaA = x0*v1 + v0*x2 + x1*v2 - v1*x2 - v0*x1 - x0*v2;
        var deltaB = u0*x1 + x0*u2 + u1*x2 - x1*u2 - x0*u1 - u0*x2;
        var deltaC = u0*v1*x2 + v0*x1*u2 + x0*u1*v2 - x0*v1*u2 - v0*u1*x2 - u0*x1*v2;
        var deltaD = y0*v1 + v0*y2 + y1*v2 - v1*y2 - v0*y1 - y0*v2;
        var deltaE = u0*y1 + y0*u2 + u1*y2 - y1*u2 - y0*u1 - u0*y2;
        var deltaF = u0*v1*y2 + v0*y1*u2 + y0*u1*v2 - y0*v1*u2 - v0*u1*y2 - u0*y1*v2;

        context.transform(deltaA / delta, deltaD / delta,
                            deltaB / delta, deltaE / delta,
                            deltaC / delta, deltaF / delta);

        context.drawImage(strip.texture.baseTexture.source, 0, 0);
        context.restore();
    }
};

/*
 * Sets the texture that the Strip will use 
 *
 * @method setTexture
 * @param texture {Texture} the texture that will be used
 * @private
 */

/*
PIXI.Strip.prototype.setTexture = function(texture)
{
    //TODO SET THE TEXTURES
    //TODO VISIBILITY

    // stop current texture
    this.texture = texture;
    this.width   = texture.frame.width;
    this.height  = texture.frame.height;
    this.updateFrame = true;
};
*/

/**
 * When the texture is updated, this event will fire to update the scale and frame
 *
 * @method onTextureUpdate
 * @param event
 * @private
 */

PIXI.Strip.prototype.onTextureUpdate = function()
{
    this.updateFrame = true;
};
/* @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * 
 * @class Rope
 * @constructor
 * @param texture {Texture} The texture to use
 * @param points {Array}
 * 
 */
PIXI.Rope = function(texture, points)
{
    PIXI.Strip.call( this, texture );
    this.points = points;

    this.verticies = new PIXI.Float32Array(points.length * 4);
    this.uvs = new PIXI.Float32Array(points.length * 4);
    this.colors = new PIXI.Float32Array(points.length * 2);
    this.indices = new PIXI.Uint16Array(points.length * 2);
   

    this.refresh();
};


// constructor
PIXI.Rope.prototype = Object.create( PIXI.Strip.prototype );
PIXI.Rope.prototype.constructor = PIXI.Rope;

/*
 * Refreshes 
 *
 * @method refresh
 */
PIXI.Rope.prototype.refresh = function()
{
    var points = this.points;
    if(points.length < 1) return;

    var uvs = this.uvs;

    var lastPoint = points[0];
    var indices = this.indices;
    var colors = this.colors;

    this.count-=0.2;

    uvs[0] = 0;
    uvs[1] = 0;
    uvs[2] = 0;
    uvs[3] = 1;

    colors[0] = 1;
    colors[1] = 1;

    indices[0] = 0;
    indices[1] = 1;

    var total = points.length,
        point, index, amount;

    for (var i = 1; i < total; i++)
    {
        point = points[i];
        index = i * 4;
        // time to do some smart drawing!
        amount = i / (total-1);

        if(i%2)
        {
            uvs[index] = amount;
            uvs[index+1] = 0;

            uvs[index+2] = amount;
            uvs[index+3] = 1;
        }
        else
        {
            uvs[index] = amount;
            uvs[index+1] = 0;

            uvs[index+2] = amount;
            uvs[index+3] = 1;
        }

        index = i * 2;
        colors[index] = 1;
        colors[index+1] = 1;

        index = i * 2;
        indices[index] = index;
        indices[index + 1] = index + 1;

        lastPoint = point;
    }
};

/*
 * Updates the object transform for rendering
 *
 * @method updateTransform
 * @private
 */
PIXI.Rope.prototype.updateTransform = function()
{

    var points = this.points;
    if(points.length < 1)return;

    var lastPoint = points[0];
    var nextPoint;
    var perp = {x:0, y:0};

    this.count-=0.2;

    var verticies = this.verticies;
    var total = points.length,
        point, index, ratio, perpLength, num;

    for (var i = 0; i < total; i++)
    {
        point = points[i];
        index = i * 4;

        if(i < points.length-1)
        {
            nextPoint = points[i+1];
        }
        else
        {
            nextPoint = point;
        }

        perp.y = -(nextPoint.x - lastPoint.x);
        perp.x = nextPoint.y - lastPoint.y;

        ratio = (1 - (i / (total-1))) * 10;

        if(ratio > 1) ratio = 1;

        perpLength = Math.sqrt(perp.x * perp.x + perp.y * perp.y);
        num = this.texture.height / 2; //(20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;
        perp.x /= perpLength;
        perp.y /= perpLength;

        perp.x *= num;
        perp.y *= num;

        verticies[index] = point.x + perp.x;
        verticies[index+1] = point.y + perp.y;
        verticies[index+2] = point.x - perp.x;
        verticies[index+3] = point.y - perp.y;

        lastPoint = point;
    }

    PIXI.DisplayObjectContainer.prototype.updateTransform.call( this );
};
/*
 * Sets the texture that the Rope will use 
 *
 * @method setTexture
 * @param texture {Texture} the texture that will be used
 */
PIXI.Rope.prototype.setTexture = function(texture)
{
    // stop current texture
    this.texture = texture;
    //this.updateFrame = true;
};

/**
 * @author Mat Groves http://matgroves.com/
 */

/**
 * A tiling sprite is a fast way of rendering a tiling image
 *
 * @class TilingSprite
 * @extends Sprite
 * @constructor
 * @param texture {Texture} the texture of the tiling sprite
 * @param width {Number}  the width of the tiling sprite
 * @param height {Number} the height of the tiling sprite
 */
PIXI.TilingSprite = function(texture, width, height)
{
    PIXI.Sprite.call( this, texture);

    /**
     * The with of the tiling sprite
     *
     * @property width
     * @type Number
     */
    this._width = width || 100;

    /**
     * The height of the tiling sprite
     *
     * @property height
     * @type Number
     */
    this._height = height || 100;

    /**
     * The scaling of the image that is being tiled
     *
     * @property tileScale
     * @type Point
     */
    this.tileScale = new PIXI.Point(1,1);

    /**
     * A point that represents the scale of the texture object
     *
     * @property tileScaleOffset
     * @type Point
     */
    this.tileScaleOffset = new PIXI.Point(1,1);
    
    /**
     * The offset position of the image that is being tiled
     *
     * @property tilePosition
     * @type Point
     */
    this.tilePosition = new PIXI.Point(0,0);

    /**
     * Whether this sprite is renderable or not
     *
     * @property renderable
     * @type Boolean
     * @default true
     */
    this.renderable = true;

    /**
     * The tint applied to the sprite. This is a hex value
     *
     * @property tint
     * @type Number
     * @default 0xFFFFFF
     */
    this.tint = 0xFFFFFF;
    
    /**
     * The blend mode to be applied to the sprite
     *
     * @property blendMode
     * @type Number
     * @default PIXI.blendModes.NORMAL;
     */
    this.blendMode = PIXI.blendModes.NORMAL;

    

};

// constructor
PIXI.TilingSprite.prototype = Object.create(PIXI.Sprite.prototype);
PIXI.TilingSprite.prototype.constructor = PIXI.TilingSprite;


/**
 * The width of the sprite, setting this will actually modify the scale to achieve the value set
 *
 * @property width
 * @type Number
 */
Object.defineProperty(PIXI.TilingSprite.prototype, 'width', {
    get: function() {
        return this._width;
    },
    set: function(value) {
        
        this._width = value;
    }
});

/**
 * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set
 *
 * @property height
 * @type Number
 */
Object.defineProperty(PIXI.TilingSprite.prototype, 'height', {
    get: function() {
        return  this._height;
    },
    set: function(value) {
        this._height = value;
    }
});

PIXI.TilingSprite.prototype.setTexture = function(texture)
{
    if (this.texture === texture) return;

    this.texture = texture;

    this.refreshTexture = true;

    this.cachedTint = 0xFFFFFF;
};

/**
* Renders the object using the WebGL renderer
*
* @method _renderWebGL
* @param renderSession {RenderSession} 
* @private
*/
PIXI.TilingSprite.prototype._renderWebGL = function(renderSession)
{
    if (this.visible === false || this.alpha === 0) return;
    var i,j;

    if (this._mask)
    {
        renderSession.spriteBatch.stop();
        renderSession.maskManager.pushMask(this.mask, renderSession);
        renderSession.spriteBatch.start();
    }

    if (this._filters)
    {
        renderSession.spriteBatch.flush();
        renderSession.filterManager.pushFilter(this._filterBlock);
    }

   

    if (!this.tilingTexture || this.refreshTexture)
    {
        this.generateTilingTexture(true);

        if (this.tilingTexture && this.tilingTexture.needsUpdate)
        {
            //TODO - tweaking
            PIXI.updateWebGLTexture(this.tilingTexture.baseTexture, renderSession.gl);
            this.tilingTexture.needsUpdate = false;
           // this.tilingTexture._uvs = null;
        }
    }
    else
    {
        renderSession.spriteBatch.renderTilingSprite(this);
    }
    // simple render children!
    for (i=0,j=this.children.length; i<j; i++)
    {
        this.children[i]._renderWebGL(renderSession);
    }

    renderSession.spriteBatch.stop();

    if (this._filters) renderSession.filterManager.popFilter();
    if (this._mask) renderSession.maskManager.popMask(renderSession);
    
    renderSession.spriteBatch.start();
};

/**
* Renders the object using the Canvas renderer
*
* @method _renderCanvas
* @param renderSession {RenderSession} 
* @private
*/
PIXI.TilingSprite.prototype._renderCanvas = function(renderSession)
{
    if (this.visible === false || this.alpha === 0)return;
    
    var context = renderSession.context;

    if (this._mask)
    {
        renderSession.maskManager.pushMask(this._mask, context);
    }

    context.globalAlpha = this.worldAlpha;
    
    var transform = this.worldTransform;

    var i,j;

    context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx , transform.ty);

    if (!this.__tilePattern ||  this.refreshTexture)
    {
        this.generateTilingTexture(false);
    
        if (this.tilingTexture)
        {
            this.__tilePattern = context.createPattern(this.tilingTexture.baseTexture.source, 'repeat');
        }
        else
        {
            return;
        }
    }

    // check blend mode
    if (this.blendMode !== renderSession.currentBlendMode)
    {
        renderSession.currentBlendMode = this.blendMode;
        context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];
    }

    var tilePosition = this.tilePosition;
    var tileScale = this.tileScale;

    tilePosition.x %= this.tilingTexture.baseTexture.width;
    tilePosition.y %= this.tilingTexture.baseTexture.height;

    // offset
    context.scale(tileScale.x,tileScale.y);
    context.translate(tilePosition.x, tilePosition.y);

    context.fillStyle = this.__tilePattern;

    // make sure to account for the anchor point..
    context.fillRect(-tilePosition.x + (this.anchor.x * -this._width),
                    -tilePosition.y + (this.anchor.y * -this._height),
                    this._width / tileScale.x,
                    this._height / tileScale.y);

    context.scale(1 / tileScale.x, 1 / tileScale.y);
    context.translate(-tilePosition.x, -tilePosition.y);

    if (this._mask)
    {
        renderSession.maskManager.popMask(renderSession.context);
    }

    for (i=0,j=this.children.length; i<j; i++)
    {
        this.children[i]._renderCanvas(renderSession);
    }
};


/**
* Returns the framing rectangle of the sprite as a PIXI.Rectangle object
*
* @method getBounds
* @return {Rectangle} the framing rectangle
*/
PIXI.TilingSprite.prototype.getBounds = function()
{
    var width = this._width;
    var height = this._height;

    var w0 = width * (1-this.anchor.x);
    var w1 = width * -this.anchor.x;

    var h0 = height * (1-this.anchor.y);
    var h1 = height * -this.anchor.y;

    var worldTransform = this.worldTransform;

    var a = worldTransform.a;
    var b = worldTransform.c;
    var c = worldTransform.b;
    var d = worldTransform.d;
    var tx = worldTransform.tx;
    var ty = worldTransform.ty;
    
    var x1 = a * w1 + c * h1 + tx;
    var y1 = d * h1 + b * w1 + ty;

    var x2 = a * w0 + c * h1 + tx;
    var y2 = d * h1 + b * w0 + ty;

    var x3 = a * w0 + c * h0 + tx;
    var y3 = d * h0 + b * w0 + ty;

    var x4 =  a * w1 + c * h0 + tx;
    var y4 =  d * h0 + b * w1 + ty;

    var maxX = -Infinity;
    var maxY = -Infinity;

    var minX = Infinity;
    var minY = Infinity;

    minX = x1 < minX ? x1 : minX;
    minX = x2 < minX ? x2 : minX;
    minX = x3 < minX ? x3 : minX;
    minX = x4 < minX ? x4 : minX;

    minY = y1 < minY ? y1 : minY;
    minY = y2 < minY ? y2 : minY;
    minY = y3 < minY ? y3 : minY;
    minY = y4 < minY ? y4 : minY;

    maxX = x1 > maxX ? x1 : maxX;
    maxX = x2 > maxX ? x2 : maxX;
    maxX = x3 > maxX ? x3 : maxX;
    maxX = x4 > maxX ? x4 : maxX;

    maxY = y1 > maxY ? y1 : maxY;
    maxY = y2 > maxY ? y2 : maxY;
    maxY = y3 > maxY ? y3 : maxY;
    maxY = y4 > maxY ? y4 : maxY;

    var bounds = this._bounds;

    bounds.x = minX;
    bounds.width = maxX - minX;

    bounds.y = minY;
    bounds.height = maxY - minY;

    // store a reference so that if this function gets called again in the render cycle we do not have to recalculate
    this._currentBounds = bounds;

    return bounds;
};



/**
 * When the texture is updated, this event will fire to update the scale and frame
 *
 * @method onTextureUpdate
 * @param event
 * @private
 */
PIXI.TilingSprite.prototype.onTextureUpdate = function()
{
   // overriding the sprite version of this!
};


/**
* 
* @method generateTilingTexture
* 
* @param forcePowerOfTwo {Boolean} Whether we want to force the texture to be a power of two
*/
PIXI.TilingSprite.prototype.generateTilingTexture = function(forcePowerOfTwo)
{
    if (!this.texture.baseTexture.hasLoaded) return;

    var texture = this.texture;
    var frame = texture.frame;
    var targetWidth, targetHeight;

    //  Check that the frame is the same size as the base texture.
    var isFrame = frame.width !== texture.baseTexture.width || frame.height !== texture.baseTexture.height;

    var newTextureRequired = false;

    if (!forcePowerOfTwo)
    {
        if (isFrame)
        {
            targetWidth = frame.width;
            targetHeight = frame.height;
           
            newTextureRequired = true;
        }
    }
    else
    {
        targetWidth = PIXI.getNextPowerOfTwo(frame.width);
        targetHeight = PIXI.getNextPowerOfTwo(frame.height);

        if (frame.width !== targetWidth || frame.height !== targetHeight) newTextureRequired = true;
    }

    if (newTextureRequired)
    {
        var canvasBuffer;

        if (this.tilingTexture && this.tilingTexture.isTiling)
        {
            canvasBuffer = this.tilingTexture.canvasBuffer;
            canvasBuffer.resize(targetWidth, targetHeight);
            this.tilingTexture.baseTexture.width = targetWidth;
            this.tilingTexture.baseTexture.height = targetHeight;
            this.tilingTexture.needsUpdate = true;
        }
        else
        {
            canvasBuffer = new PIXI.CanvasBuffer(targetWidth, targetHeight);

            this.tilingTexture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);
            this.tilingTexture.canvasBuffer = canvasBuffer;
            this.tilingTexture.isTiling = true;
        }

        canvasBuffer.context.drawImage(texture.baseTexture.source,
                               texture.crop.x,
                               texture.crop.y,
                               texture.crop.width,
                               texture.crop.height,
                               0,
                               0,
                               targetWidth,
                               targetHeight);

        this.tileScaleOffset.x = frame.width / targetWidth;
        this.tileScaleOffset.y = frame.height / targetHeight;
    }
    else
    {
        //  TODO - switching?
        if (this.tilingTexture && this.tilingTexture.isTiling)
        {
            // destroy the tiling texture!
            // TODO could store this somewhere?
            this.tilingTexture.destroy(true);
        }

        this.tileScaleOffset.x = 1;
        this.tileScaleOffset.y = 1;
        this.tilingTexture = texture;
    }

    this.refreshTexture = false;
    this.tilingTexture.baseTexture._powerOf2 = true;
};
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 * based on pixi impact spine implementation made by Eemeli Kelokorpi (@ekelokorpi) https://github.com/ekelokorpi
 *
 * Awesome JS run time provided by EsotericSoftware
 * https://github.com/EsotericSoftware/spine-runtimes
 *
 */

/*
 * Awesome JS run time provided by EsotericSoftware
 *
 * https://github.com/EsotericSoftware/spine-runtimes
 *
 */



var spine = {};

spine.BoneData = function (name, parent) {
    this.name = name;
    this.parent = parent;
};
spine.BoneData.prototype = {
    length: 0,
    x: 0, y: 0,
    rotation: 0,
    scaleX: 1, scaleY: 1
};

spine.SlotData = function (name, boneData) {
    this.name = name;
    this.boneData = boneData;
};
spine.SlotData.prototype = {
    r: 1, g: 1, b: 1, a: 1,
    attachmentName: null
};

spine.Bone = function (boneData, parent) {
    this.data = boneData;
    this.parent = parent;
    this.setToSetupPose();
};
spine.Bone.yDown = false;
spine.Bone.prototype = {
    x: 0, y: 0,
    rotation: 0,
    scaleX: 1, scaleY: 1,
    m00: 0, m01: 0, worldX: 0, // a b x
    m10: 0, m11: 0, worldY: 0, // c d y
    worldRotation: 0,
    worldScaleX: 1, worldScaleY: 1,
    updateWorldTransform: function (flipX, flipY) {
        var parent = this.parent;
        if (parent != null) {
            this.worldX = this.x * parent.m00 + this.y * parent.m01 + parent.worldX;
            this.worldY = this.x * parent.m10 + this.y * parent.m11 + parent.worldY;
            this.worldScaleX = parent.worldScaleX * this.scaleX;
            this.worldScaleY = parent.worldScaleY * this.scaleY;
            this.worldRotation = parent.worldRotation + this.rotation;
        } else {
            this.worldX = this.x;
            this.worldY = this.y;
            this.worldScaleX = this.scaleX;
            this.worldScaleY = this.scaleY;
            this.worldRotation = this.rotation;
        }
        var radians = this.worldRotation * Math.PI / 180;
        var cos = Math.cos(radians);
        var sin = Math.sin(radians);
        this.m00 = cos * this.worldScaleX;
        this.m10 = sin * this.worldScaleX;
        this.m01 = -sin * this.worldScaleY;
        this.m11 = cos * this.worldScaleY;
        if (flipX) {
            this.m00 = -this.m00;
            this.m01 = -this.m01;
        }
        if (flipY) {
            this.m10 = -this.m10;
            this.m11 = -this.m11;
        }
        if (spine.Bone.yDown) {
            this.m10 = -this.m10;
            this.m11 = -this.m11;
        }
    },
    setToSetupPose: function () {
        var data = this.data;
        this.x = data.x;
        this.y = data.y;
        this.rotation = data.rotation;
        this.scaleX = data.scaleX;
        this.scaleY = data.scaleY;
    }
};

spine.Slot = function (slotData, skeleton, bone) {
    this.data = slotData;
    this.skeleton = skeleton;
    this.bone = bone;
    this.setToSetupPose();
};
spine.Slot.prototype = {
    r: 1, g: 1, b: 1, a: 1,
    _attachmentTime: 0,
    attachment: null,
    setAttachment: function (attachment) {
        this.attachment = attachment;
        this._attachmentTime = this.skeleton.time;
    },
    setAttachmentTime: function (time) {
        this._attachmentTime = this.skeleton.time - time;
    },
    getAttachmentTime: function () {
        return this.skeleton.time - this._attachmentTime;
    },
    setToSetupPose: function () {
        var data = this.data;
        this.r = data.r;
        this.g = data.g;
        this.b = data.b;
        this.a = data.a;

        var slotDatas = this.skeleton.data.slots;
        for (var i = 0, n = slotDatas.length; i < n; i++) {
            if (slotDatas[i] == data) {
                this.setAttachment(!data.attachmentName ? null : this.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));
                break;
            }
        }
    }
};

spine.Skin = function (name) {
    this.name = name;
    this.attachments = {};
};
spine.Skin.prototype = {
    addAttachment: function (slotIndex, name, attachment) {
        this.attachments[slotIndex + ":" + name] = attachment;
    },
    getAttachment: function (slotIndex, name) {
        return this.attachments[slotIndex + ":" + name];
    },
    _attachAll: function (skeleton, oldSkin) {
        for (var key in oldSkin.attachments) {
            var colon = key.indexOf(":");
            var slotIndex = parseInt(key.substring(0, colon), 10);
            var name = key.substring(colon + 1);
            var slot = skeleton.slots[slotIndex];
            if (slot.attachment && slot.attachment.name == name) {
                var attachment = this.getAttachment(slotIndex, name);
                if (attachment) slot.setAttachment(attachment);
            }
        }
    }
};

spine.Animation = function (name, timelines, duration) {
    this.name = name;
    this.timelines = timelines;
    this.duration = duration;
};
spine.Animation.prototype = {
    apply: function (skeleton, time, loop) {
        if (loop && this.duration) time %= this.duration;
        var timelines = this.timelines;
        for (var i = 0, n = timelines.length; i < n; i++)
            timelines[i].apply(skeleton, time, 1);
    },
    mix: function (skeleton, time, loop, alpha) {
        if (loop && this.duration) time %= this.duration;
        var timelines = this.timelines;
        for (var i = 0, n = timelines.length; i < n; i++)
            timelines[i].apply(skeleton, time, alpha);
    }
};

spine.binarySearch = function (values, target, step) {
    var low = 0;
    var high = Math.floor(values.length / step) - 2;
    if (!high) return step;
    var current = high >>> 1;
    while (true) {
        if (values[(current + 1) * step] <= target)
            low = current + 1;
        else
            high = current;
        if (low == high) return (low + 1) * step;
        current = (low + high) >>> 1;
    }
};
spine.linearSearch = function (values, target, step) {
    for (var i = 0, last = values.length - step; i <= last; i += step)
        if (values[i] > target) return i;
    return -1;
};

spine.Curves = function (frameCount) {
    this.curves = []; // dfx, dfy, ddfx, ddfy, dddfx, dddfy, ...
    this.curves.length = (frameCount - 1) * 6;
};
spine.Curves.prototype = {
    setLinear: function (frameIndex) {
        this.curves[frameIndex * 6] = 0/*LINEAR*/;
    },
    setStepped: function (frameIndex) {
        this.curves[frameIndex * 6] = -1/*STEPPED*/;
    },
    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.
     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of
     * the difference between the keyframe's values. */
    setCurve: function (frameIndex, cx1, cy1, cx2, cy2) {
        var subdiv_step = 1 / 10/*BEZIER_SEGMENTS*/;
        var subdiv_step2 = subdiv_step * subdiv_step;
        var subdiv_step3 = subdiv_step2 * subdiv_step;
        var pre1 = 3 * subdiv_step;
        var pre2 = 3 * subdiv_step2;
        var pre4 = 6 * subdiv_step2;
        var pre5 = 6 * subdiv_step3;
        var tmp1x = -cx1 * 2 + cx2;
        var tmp1y = -cy1 * 2 + cy2;
        var tmp2x = (cx1 - cx2) * 3 + 1;
        var tmp2y = (cy1 - cy2) * 3 + 1;
        var i = frameIndex * 6;
        var curves = this.curves;
        curves[i] = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv_step3;
        curves[i + 1] = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv_step3;
        curves[i + 2] = tmp1x * pre4 + tmp2x * pre5;
        curves[i + 3] = tmp1y * pre4 + tmp2y * pre5;
        curves[i + 4] = tmp2x * pre5;
        curves[i + 5] = tmp2y * pre5;
    },
    getCurvePercent: function (frameIndex, percent) {
        percent = percent < 0 ? 0 : (percent > 1 ? 1 : percent);
        var curveIndex = frameIndex * 6;
        var curves = this.curves;
        var dfx = curves[curveIndex];
        if (!dfx/*LINEAR*/) return percent;
        if (dfx == -1/*STEPPED*/) return 0;
        var dfy = curves[curveIndex + 1];
        var ddfx = curves[curveIndex + 2];
        var ddfy = curves[curveIndex + 3];
        var dddfx = curves[curveIndex + 4];
        var dddfy = curves[curveIndex + 5];
        var x = dfx, y = dfy;
        var i = 10/*BEZIER_SEGMENTS*/ - 2;
        while (true) {
            if (x >= percent) {
                var lastX = x - dfx;
                var lastY = y - dfy;
                return lastY + (y - lastY) * (percent - lastX) / (x - lastX);
            }
            if (!i) break;
            i--;
            dfx += ddfx;
            dfy += ddfy;
            ddfx += dddfx;
            ddfy += dddfy;
            x += dfx;
            y += dfy;
        }
        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.
    }
};

spine.RotateTimeline = function (frameCount) {
    this.curves = new spine.Curves(frameCount);
    this.frames = []; // time, angle, ...
    this.frames.length = frameCount * 2;
};
spine.RotateTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function () {
        return this.frames.length / 2;
    },
    setFrame: function (frameIndex, time, angle) {
        frameIndex *= 2;
        this.frames[frameIndex] = time;
        this.frames[frameIndex + 1] = angle;
    },
    apply: function (skeleton, time, alpha) {
        var frames = this.frames,
            amount;

        if (time < frames[0]) return; // Time is before first frame.

        var bone = skeleton.bones[this.boneIndex];

        if (time >= frames[frames.length - 2]) { // Time is after last frame.
            amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;
            while (amount > 180)
                amount -= 360;
            while (amount < -180)
                amount += 360;
            bone.rotation += amount * alpha;
            return;
        }

        // Interpolate between the last frame and the current frame.
        var frameIndex = spine.binarySearch(frames, time, 2);
        var lastFrameValue = frames[frameIndex - 1];
        var frameTime = frames[frameIndex];
        var percent = 1 - (time - frameTime) / (frames[frameIndex - 2/*LAST_FRAME_TIME*/] - frameTime);
        percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);

        amount = frames[frameIndex + 1/*FRAME_VALUE*/] - lastFrameValue;
        while (amount > 180)
            amount -= 360;
        while (amount < -180)
            amount += 360;
        amount = bone.data.rotation + (lastFrameValue + amount * percent) - bone.rotation;
        while (amount > 180)
            amount -= 360;
        while (amount < -180)
            amount += 360;
        bone.rotation += amount * alpha;
    }
};

spine.TranslateTimeline = function (frameCount) {
    this.curves = new spine.Curves(frameCount);
    this.frames = []; // time, x, y, ...
    this.frames.length = frameCount * 3;
};
spine.TranslateTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function () {
        return this.frames.length / 3;
    },
    setFrame: function (frameIndex, time, x, y) {
        frameIndex *= 3;
        this.frames[frameIndex] = time;
        this.frames[frameIndex + 1] = x;
        this.frames[frameIndex + 2] = y;
    },
    apply: function (skeleton, time, alpha) {
        var frames = this.frames;
        if (time < frames[0]) return; // Time is before first frame.

        var bone = skeleton.bones[this.boneIndex];

        if (time >= frames[frames.length - 3]) { // Time is after last frame.
            bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;
            bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;
            return;
        }

        // Interpolate between the last frame and the current frame.
        var frameIndex = spine.binarySearch(frames, time, 3);
        var lastFrameX = frames[frameIndex - 2];
        var lastFrameY = frames[frameIndex - 1];
        var frameTime = frames[frameIndex];
        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*LAST_FRAME_TIME*/] - frameTime);
        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);

        bone.x += (bone.data.x + lastFrameX + (frames[frameIndex + 1/*FRAME_X*/] - lastFrameX) * percent - bone.x) * alpha;
        bone.y += (bone.data.y + lastFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - lastFrameY) * percent - bone.y) * alpha;
    }
};

spine.ScaleTimeline = function (frameCount) {
    this.curves = new spine.Curves(frameCount);
    this.frames = []; // time, x, y, ...
    this.frames.length = frameCount * 3;
};
spine.ScaleTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function () {
        return this.frames.length / 3;
    },
    setFrame: function (frameIndex, time, x, y) {
        frameIndex *= 3;
        this.frames[frameIndex] = time;
        this.frames[frameIndex + 1] = x;
        this.frames[frameIndex + 2] = y;
    },
    apply: function (skeleton, time, alpha) {
        var frames = this.frames;
        if (time < frames[0]) return; // Time is before first frame.

        var bone = skeleton.bones[this.boneIndex];

        if (time >= frames[frames.length - 3]) { // Time is after last frame.
            bone.scaleX += (bone.data.scaleX - 1 + frames[frames.length - 2] - bone.scaleX) * alpha;
            bone.scaleY += (bone.data.scaleY - 1 + frames[frames.length - 1] - bone.scaleY) * alpha;
            return;
        }

        // Interpolate between the last frame and the current frame.
        var frameIndex = spine.binarySearch(frames, time, 3);
        var lastFrameX = frames[frameIndex - 2];
        var lastFrameY = frames[frameIndex - 1];
        var frameTime = frames[frameIndex];
        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*LAST_FRAME_TIME*/] - frameTime);
        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);

        bone.scaleX += (bone.data.scaleX - 1 + lastFrameX + (frames[frameIndex + 1/*FRAME_X*/] - lastFrameX) * percent - bone.scaleX) * alpha;
        bone.scaleY += (bone.data.scaleY - 1 + lastFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - lastFrameY) * percent - bone.scaleY) * alpha;
    }
};

spine.ColorTimeline = function (frameCount) {
    this.curves = new spine.Curves(frameCount);
    this.frames = []; // time, r, g, b, a, ...
    this.frames.length = frameCount * 5;
};
spine.ColorTimeline.prototype = {
    slotIndex: 0,
    getFrameCount: function () {
        return this.frames.length / 5;
    },
    setFrame: function (frameIndex, time, r, g, b, a) {
        frameIndex *= 5;
        this.frames[frameIndex] = time;
        this.frames[frameIndex + 1] = r;
        this.frames[frameIndex + 2] = g;
        this.frames[frameIndex + 3] = b;
        this.frames[frameIndex + 4] = a;
    },
    apply: function (skeleton, time, alpha) {
        var frames = this.frames;
        if (time < frames[0]) return; // Time is before first frame.

        var slot = skeleton.slots[this.slotIndex];

        if (time >= frames[frames.length - 5]) { // Time is after last frame.
            var i = frames.length - 1;
            slot.r = frames[i - 3];
            slot.g = frames[i - 2];
            slot.b = frames[i - 1];
            slot.a = frames[i];
            return;
        }

        // Interpolate between the last frame and the current frame.
        var frameIndex = spine.binarySearch(frames, time, 5);
        var lastFrameR = frames[frameIndex - 4];
        var lastFrameG = frames[frameIndex - 3];
        var lastFrameB = frames[frameIndex - 2];
        var lastFrameA = frames[frameIndex - 1];
        var frameTime = frames[frameIndex];
        var percent = 1 - (time - frameTime) / (frames[frameIndex - 5/*LAST_FRAME_TIME*/] - frameTime);
        percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);

        var r = lastFrameR + (frames[frameIndex + 1/*FRAME_R*/] - lastFrameR) * percent;
        var g = lastFrameG + (frames[frameIndex + 2/*FRAME_G*/] - lastFrameG) * percent;
        var b = lastFrameB + (frames[frameIndex + 3/*FRAME_B*/] - lastFrameB) * percent;
        var a = lastFrameA + (frames[frameIndex + 4/*FRAME_A*/] - lastFrameA) * percent;
        if (alpha < 1) {
            slot.r += (r - slot.r) * alpha;
            slot.g += (g - slot.g) * alpha;
            slot.b += (b - slot.b) * alpha;
            slot.a += (a - slot.a) * alpha;
        } else {
            slot.r = r;
            slot.g = g;
            slot.b = b;
            slot.a = a;
        }
    }
};

spine.AttachmentTimeline = function (frameCount) {
    this.curves = new spine.Curves(frameCount);
    this.frames = []; // time, ...
    this.frames.length = frameCount;
    this.attachmentNames = []; // time, ...
    this.attachmentNames.length = frameCount;
};
spine.AttachmentTimeline.prototype = {
    slotIndex: 0,
    getFrameCount: function () {
            return this.frames.length;
    },
    setFrame: function (frameIndex, time, attachmentName) {
        this.frames[frameIndex] = time;
        this.attachmentNames[frameIndex] = attachmentName;
    },
    apply: function (skeleton, time, alpha) {
        var frames = this.frames;
        if (time < frames[0]) return; // Time is before first frame.

        var frameIndex;
        if (time >= frames[frames.length - 1]) // Time is after last frame.
            frameIndex = frames.length - 1;
        else
            frameIndex = spine.binarySearch(frames, time, 1) - 1;

        var attachmentName = this.attachmentNames[frameIndex];
        skeleton.slots[this.slotIndex].setAttachment(!attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));
    }
};

spine.SkeletonData = function () {
    this.bones = [];
    this.slots = [];
    this.skins = [];
    this.animations = [];
};
spine.SkeletonData.prototype = {
    defaultSkin: null,
    /** @return May be null. */
    findBone: function (boneName) {
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
            if (bones[i].name == boneName) return bones[i];
        return null;
    },
    /** @return -1 if the bone was not found. */
    findBoneIndex: function (boneName) {
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
            if (bones[i].name == boneName) return i;
        return -1;
    },
    /** @return May be null. */
    findSlot: function (slotName) {
        var slots = this.slots;
        for (var i = 0, n = slots.length; i < n; i++) {
            if (slots[i].name == slotName) return slot[i];
        }
        return null;
    },
    /** @return -1 if the bone was not found. */
    findSlotIndex: function (slotName) {
        var slots = this.slots;
        for (var i = 0, n = slots.length; i < n; i++)
            if (slots[i].name == slotName) return i;
        return -1;
    },
    /** @return May be null. */
    findSkin: function (skinName) {
        var skins = this.skins;
        for (var i = 0, n = skins.length; i < n; i++)
            if (skins[i].name == skinName) return skins[i];
        return null;
    },
    /** @return May be null. */
    findAnimation: function (animationName) {
        var animations = this.animations;
        for (var i = 0, n = animations.length; i < n; i++)
            if (animations[i].name == animationName) return animations[i];
        return null;
    }
};

spine.Skeleton = function (skeletonData) {
    this.data = skeletonData;

    this.bones = [];
    for (var i = 0, n = skeletonData.bones.length; i < n; i++) {
        var boneData = skeletonData.bones[i];
        var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];
        this.bones.push(new spine.Bone(boneData, parent));
    }

    this.slots = [];
    this.drawOrder = [];
    for (i = 0, n = skeletonData.slots.length; i < n; i++) {
        var slotData = skeletonData.slots[i];
        var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];
        var slot = new spine.Slot(slotData, this, bone);
        this.slots.push(slot);
        this.drawOrder.push(slot);
    }
};
spine.Skeleton.prototype = {
    x: 0, y: 0,
    skin: null,
    r: 1, g: 1, b: 1, a: 1,
    time: 0,
    flipX: false, flipY: false,
    /** Updates the world transform for each bone. */
    updateWorldTransform: function () {
        var flipX = this.flipX;
        var flipY = this.flipY;
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
            bones[i].updateWorldTransform(flipX, flipY);
    },
    /** Sets the bones and slots to their setup pose values. */
    setToSetupPose: function () {
        this.setBonesToSetupPose();
        this.setSlotsToSetupPose();
    },
    setBonesToSetupPose: function () {
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
            bones[i].setToSetupPose();
    },
    setSlotsToSetupPose: function () {
        var slots = this.slots;
        for (var i = 0, n = slots.length; i < n; i++)
            slots[i].setToSetupPose(i);
    },
    /** @return May return null. */
    getRootBone: function () {
        return this.bones.length ? this.bones[0] : null;
    },
    /** @return May be null. */
    findBone: function (boneName) {
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
            if (bones[i].data.name == boneName) return bones[i];
        return null;
    },
    /** @return -1 if the bone was not found. */
    findBoneIndex: function (boneName) {
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
            if (bones[i].data.name == boneName) return i;
        return -1;
    },
    /** @return May be null. */
    findSlot: function (slotName) {
        var slots = this.slots;
        for (var i = 0, n = slots.length; i < n; i++)
            if (slots[i].data.name == slotName) return slots[i];
        return null;
    },
    /** @return -1 if the bone was not found. */
    findSlotIndex: function (slotName) {
        var slots = this.slots;
        for (var i = 0, n = slots.length; i < n; i++)
            if (slots[i].data.name == slotName) return i;
        return -1;
    },
    setSkinByName: function (skinName) {
        var skin = this.data.findSkin(skinName);
        if (!skin) throw "Skin not found: " + skinName;
        this.setSkin(skin);
    },
    /** Sets the skin used to look up attachments not found in the {@link SkeletonData#getDefaultSkin() default skin}. Attachments
     * from the new skin are attached if the corresponding attachment from the old skin was attached.
     * @param newSkin May be null. */
    setSkin: function (newSkin) {
        if (this.skin && newSkin) newSkin._attachAll(this, this.skin);
        this.skin = newSkin;
    },
    /** @return May be null. */
    getAttachmentBySlotName: function (slotName, attachmentName) {
        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);
    },
    /** @return May be null. */
    getAttachmentBySlotIndex: function (slotIndex, attachmentName) {
        if (this.skin) {
            var attachment = this.skin.getAttachment(slotIndex, attachmentName);
            if (attachment) return attachment;
        }
        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
        return null;
    },
    /** @param attachmentName May be null. */
    setAttachment: function (slotName, attachmentName) {
        var slots = this.slots;
        for (var i = 0, n = slots.size; i < n; i++) {
            var slot = slots[i];
            if (slot.data.name == slotName) {
                var attachment = null;
                if (attachmentName) {
                    attachment = this.getAttachment(i, attachmentName);
                    if (attachment == null) throw "Attachment not found: " + attachmentName + ", for slot: " + slotName;
                }
                slot.setAttachment(attachment);
                return;
            }
        }
        throw "Slot not found: " + slotName;
    },
    update: function (delta) {
        time += delta;
    }
};

spine.AttachmentType = {
    region: 0
};

spine.RegionAttachment = function () {
    this.offset = [];
    this.offset.length = 8;
    this.uvs = [];
    this.uvs.length = 8;
};
spine.RegionAttachment.prototype = {
    x: 0, y: 0,
    rotation: 0,
    scaleX: 1, scaleY: 1,
    width: 0, height: 0,
    rendererObject: null,
    regionOffsetX: 0, regionOffsetY: 0,
    regionWidth: 0, regionHeight: 0,
    regionOriginalWidth: 0, regionOriginalHeight: 0,
    setUVs: function (u, v, u2, v2, rotate) {
        var uvs = this.uvs;
        if (rotate) {
            uvs[2/*X2*/] = u;
            uvs[3/*Y2*/] = v2;
            uvs[4/*X3*/] = u;
            uvs[5/*Y3*/] = v;
            uvs[6/*X4*/] = u2;
            uvs[7/*Y4*/] = v;
            uvs[0/*X1*/] = u2;
            uvs[1/*Y1*/] = v2;
        } else {
            uvs[0/*X1*/] = u;
            uvs[1/*Y1*/] = v2;
            uvs[2/*X2*/] = u;
            uvs[3/*Y2*/] = v;
            uvs[4/*X3*/] = u2;
            uvs[5/*Y3*/] = v;
            uvs[6/*X4*/] = u2;
            uvs[7/*Y4*/] = v2;
        }
    },
    updateOffset: function () {
        var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;
        var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;
        var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;
        var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;
        var localX2 = localX + this.regionWidth * regionScaleX;
        var localY2 = localY + this.regionHeight * regionScaleY;
        var radians = this.rotation * Math.PI / 180;
        var cos = Math.cos(radians);
        var sin = Math.sin(radians);
        var localXCos = localX * cos + this.x;
        var localXSin = localX * sin;
        var localYCos = localY * cos + this.y;
        var localYSin = localY * sin;
        var localX2Cos = localX2 * cos + this.x;
        var localX2Sin = localX2 * sin;
        var localY2Cos = localY2 * cos + this.y;
        var localY2Sin = localY2 * sin;
        var offset = this.offset;
        offset[0/*X1*/] = localXCos - localYSin;
        offset[1/*Y1*/] = localYCos + localXSin;
        offset[2/*X2*/] = localXCos - localY2Sin;
        offset[3/*Y2*/] = localY2Cos + localXSin;
        offset[4/*X3*/] = localX2Cos - localY2Sin;
        offset[5/*Y3*/] = localY2Cos + localX2Sin;
        offset[6/*X4*/] = localX2Cos - localYSin;
        offset[7/*Y4*/] = localYCos + localX2Sin;
    },
    computeVertices: function (x, y, bone, vertices) {
        x += bone.worldX;
        y += bone.worldY;
        var m00 = bone.m00;
        var m01 = bone.m01;
        var m10 = bone.m10;
        var m11 = bone.m11;
        var offset = this.offset;
        vertices[0/*X1*/] = offset[0/*X1*/] * m00 + offset[1/*Y1*/] * m01 + x;
        vertices[1/*Y1*/] = offset[0/*X1*/] * m10 + offset[1/*Y1*/] * m11 + y;
        vertices[2/*X2*/] = offset[2/*X2*/] * m00 + offset[3/*Y2*/] * m01 + x;
        vertices[3/*Y2*/] = offset[2/*X2*/] * m10 + offset[3/*Y2*/] * m11 + y;
        vertices[4/*X3*/] = offset[4/*X3*/] * m00 + offset[5/*X3*/] * m01 + x;
        vertices[5/*X3*/] = offset[4/*X3*/] * m10 + offset[5/*X3*/] * m11 + y;
        vertices[6/*X4*/] = offset[6/*X4*/] * m00 + offset[7/*Y4*/] * m01 + x;
        vertices[7/*Y4*/] = offset[6/*X4*/] * m10 + offset[7/*Y4*/] * m11 + y;
    }
}

spine.AnimationStateData = function (skeletonData) {
    this.skeletonData = skeletonData;
    this.animationToMixTime = {};
};
spine.AnimationStateData.prototype = {
        defaultMix: 0,
    setMixByName: function (fromName, toName, duration) {
        var from = this.skeletonData.findAnimation(fromName);
        if (!from) throw "Animation not found: " + fromName;
        var to = this.skeletonData.findAnimation(toName);
        if (!to) throw "Animation not found: " + toName;
        this.setMix(from, to, duration);
    },
    setMix: function (from, to, duration) {
        this.animationToMixTime[from.name + ":" + to.name] = duration;
    },
    getMix: function (from, to) {
        var time = this.animationToMixTime[from.name + ":" + to.name];
            return time ? time : this.defaultMix;
    }
};

spine.AnimationState = function (stateData) {
    this.data = stateData;
    this.queue = [];
};
spine.AnimationState.prototype = {
    animationSpeed: 1,
    current: null,
    previous: null,
    currentTime: 0,
    previousTime: 0,
    currentLoop: false,
    previousLoop: false,
    mixTime: 0,
    mixDuration: 0,
    update: function (delta) {
        this.currentTime += (delta * this.animationSpeed); //timeScale: Multiply delta by the speed of animation required.
        this.previousTime += delta;
        this.mixTime += delta;

        if (this.queue.length > 0) {
            var entry = this.queue[0];
            if (this.currentTime >= entry.delay) {
                this._setAnimation(entry.animation, entry.loop);
                this.queue.shift();
            }
        }
    },
    apply: function (skeleton) {
        if (!this.current) return;
        if (this.previous) {
            this.previous.apply(skeleton, this.previousTime, this.previousLoop);
            var alpha = this.mixTime / this.mixDuration;
            if (alpha >= 1) {
                alpha = 1;
                this.previous = null;
            }
            this.current.mix(skeleton, this.currentTime, this.currentLoop, alpha);
        } else
            this.current.apply(skeleton, this.currentTime, this.currentLoop);
    },
    clearAnimation: function () {
        this.previous = null;
        this.current = null;
        this.queue.length = 0;
    },
    _setAnimation: function (animation, loop) {
        this.previous = null;
        if (animation && this.current) {
            this.mixDuration = this.data.getMix(this.current, animation);
            if (this.mixDuration > 0) {
                this.mixTime = 0;
                this.previous = this.current;
                this.previousTime = this.currentTime;
                this.previousLoop = this.currentLoop;
            }
        }
        this.current = animation;
        this.currentLoop = loop;
        this.currentTime = 0;
    },
    /** @see #setAnimation(Animation, Boolean) */
    setAnimationByName: function (animationName, loop) {
        var animation = this.data.skeletonData.findAnimation(animationName);
        if (!animation) throw "Animation not found: " + animationName;
        this.setAnimation(animation, loop);
    },
    /** Set the current animation. Any queued animations are cleared and the current animation time is set to 0.
     * @param animation May be null. */
    setAnimation: function (animation, loop) {
        this.queue.length = 0;
        this._setAnimation(animation, loop);
    },
    /** @see #addAnimation(Animation, Boolean, Number) */
    addAnimationByName: function (animationName, loop, delay) {
        var animation = this.data.skeletonData.findAnimation(animationName);
        if (!animation) throw "Animation not found: " + animationName;
        this.addAnimation(animation, loop, delay);
    },
    /** Adds an animation to be played delay seconds after the current or last queued animation.
     * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */
    addAnimation: function (animation, loop, delay) {
        var entry = {};
        entry.animation = animation;
        entry.loop = loop;

        if (!delay || delay <= 0) {
            var previousAnimation = this.queue.length ? this.queue[this.queue.length - 1].animation : this.current;
            if (previousAnimation != null)
                delay = previousAnimation.duration - this.data.getMix(previousAnimation, animation) + (delay || 0);
            else
                delay = 0;
        }
        entry.delay = delay;

        this.queue.push(entry);
    },
    /** Returns true if no animation is set or if the current time is greater than the animation duration, regardless of looping. */
    isComplete: function () {
        return !this.current || this.currentTime >= this.current.duration;
    }
};

spine.SkeletonJson = function (attachmentLoader) {
    this.attachmentLoader = attachmentLoader;
};
spine.SkeletonJson.prototype = {
    scale: 1,
    readSkeletonData: function (root) {
        /*jshint -W069*/
        var skeletonData = new spine.SkeletonData(),
            boneData;

        // Bones.
        var bones = root["bones"];
        for (var i = 0, n = bones.length; i < n; i++) {
            var boneMap = bones[i];
            var parent = null;
            if (boneMap["parent"]) {
                parent = skeletonData.findBone(boneMap["parent"]);
                if (!parent) throw "Parent bone not found: " + boneMap["parent"];
            }
            boneData = new spine.BoneData(boneMap["name"], parent);
            boneData.length = (boneMap["length"] || 0) * this.scale;
            boneData.x = (boneMap["x"] || 0) * this.scale;
            boneData.y = (boneMap["y"] || 0) * this.scale;
            boneData.rotation = (boneMap["rotation"] || 0);
            boneData.scaleX = boneMap["scaleX"] || 1;
            boneData.scaleY = boneMap["scaleY"] || 1;
            skeletonData.bones.push(boneData);
        }

        // Slots.
        var slots = root["slots"];
        for (i = 0, n = slots.length; i < n; i++) {
            var slotMap = slots[i];
            boneData = skeletonData.findBone(slotMap["bone"]);
            if (!boneData) throw "Slot bone not found: " + slotMap["bone"];
            var slotData = new spine.SlotData(slotMap["name"], boneData);

            var color = slotMap["color"];
            if (color) {
                slotData.r = spine.SkeletonJson.toColor(color, 0);
                slotData.g = spine.SkeletonJson.toColor(color, 1);
                slotData.b = spine.SkeletonJson.toColor(color, 2);
                slotData.a = spine.SkeletonJson.toColor(color, 3);
            }

            slotData.attachmentName = slotMap["attachment"];

            skeletonData.slots.push(slotData);
        }

        // Skins.
        var skins = root["skins"];
        for (var skinName in skins) {
            if (!skins.hasOwnProperty(skinName)) continue;
            var skinMap = skins[skinName];
            var skin = new spine.Skin(skinName);
            for (var slotName in skinMap) {
                if (!skinMap.hasOwnProperty(slotName)) continue;
                var slotIndex = skeletonData.findSlotIndex(slotName);
                var slotEntry = skinMap[slotName];
                for (var attachmentName in slotEntry) {
                    if (!slotEntry.hasOwnProperty(attachmentName)) continue;
                    var attachment = this.readAttachment(skin, attachmentName, slotEntry[attachmentName]);
                    if (attachment != null) skin.addAttachment(slotIndex, attachmentName, attachment);
                }
            }
            skeletonData.skins.push(skin);
            if (skin.name == "default") skeletonData.defaultSkin = skin;
        }

        // Animations.
        var animations = root["animations"];
        for (var animationName in animations) {
            if (!animations.hasOwnProperty(animationName)) continue;
            this.readAnimation(animationName, animations[animationName], skeletonData);
        }

        return skeletonData;
    },
    readAttachment: function (skin, name, map) {
        /*jshint -W069*/
        name = map["name"] || name;

        var type = spine.AttachmentType[map["type"] || "region"];

        if (type == spine.AttachmentType.region) {
            var attachment = new spine.RegionAttachment();
            attachment.x = (map["x"] || 0) * this.scale;
            attachment.y = (map["y"] || 0) * this.scale;
            attachment.scaleX = map["scaleX"] || 1;
            attachment.scaleY = map["scaleY"] || 1;
            attachment.rotation = map["rotation"] || 0;
            attachment.width = (map["width"] || 32) * this.scale;
            attachment.height = (map["height"] || 32) * this.scale;
            attachment.updateOffset();

            attachment.rendererObject = {};
            attachment.rendererObject.name = name;
            attachment.rendererObject.scale = {};
            attachment.rendererObject.scale.x = attachment.scaleX;
            attachment.rendererObject.scale.y = attachment.scaleY;
            attachment.rendererObject.rotation = -attachment.rotation * Math.PI / 180;
            return attachment;
        }

            throw "Unknown attachment type: " + type;
    },

    readAnimation: function (name, map, skeletonData) {
        /*jshint -W069*/
        var timelines = [];
        var duration = 0;
        var frameIndex, timeline, timelineName, valueMap, values,
            i, n;

        var bones = map["bones"];
        for (var boneName in bones) {
            if (!bones.hasOwnProperty(boneName)) continue;
            var boneIndex = skeletonData.findBoneIndex(boneName);
            if (boneIndex == -1) throw "Bone not found: " + boneName;
            var boneMap = bones[boneName];

            for (timelineName in boneMap) {
                if (!boneMap.hasOwnProperty(timelineName)) continue;
                values = boneMap[timelineName];
                if (timelineName == "rotate") {
                    timeline = new spine.RotateTimeline(values.length);
                    timeline.boneIndex = boneIndex;

                    frameIndex = 0;
                    for (i = 0, n = values.length; i < n; i++) {
                        valueMap = values[i];
                        timeline.setFrame(frameIndex, valueMap["time"], valueMap["angle"]);
                        spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
                        frameIndex++;
                    }
                    timelines.push(timeline);
                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);

                } else if (timelineName == "translate" || timelineName == "scale") {
                    var timelineScale = 1;
                    if (timelineName == "scale")
                        timeline = new spine.ScaleTimeline(values.length);
                    else {
                        timeline = new spine.TranslateTimeline(values.length);
                        timelineScale = this.scale;
                    }
                    timeline.boneIndex = boneIndex;

                    frameIndex = 0;
                    for (i = 0, n = values.length; i < n; i++) {
                        valueMap = values[i];
                        var x = (valueMap["x"] || 0) * timelineScale;
                        var y = (valueMap["y"] || 0) * timelineScale;
                        timeline.setFrame(frameIndex, valueMap["time"], x, y);
                        spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
                        frameIndex++;
                    }
                    timelines.push(timeline);
                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);

                } else
                    throw "Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")";
            }
        }
        var slots = map["slots"];
        for (var slotName in slots) {
            if (!slots.hasOwnProperty(slotName)) continue;
            var slotMap = slots[slotName];
            var slotIndex = skeletonData.findSlotIndex(slotName);

            for (timelineName in slotMap) {
                if (!slotMap.hasOwnProperty(timelineName)) continue;
                values = slotMap[timelineName];
                if (timelineName == "color") {
                    timeline = new spine.ColorTimeline(values.length);
                    timeline.slotIndex = slotIndex;

                    frameIndex = 0;
                    for (i = 0, n = values.length; i < n; i++) {
                        valueMap = values[i];
                        var color = valueMap["color"];
                        var r = spine.SkeletonJson.toColor(color, 0);
                        var g = spine.SkeletonJson.toColor(color, 1);
                        var b = spine.SkeletonJson.toColor(color, 2);
                        var a = spine.SkeletonJson.toColor(color, 3);
                        timeline.setFrame(frameIndex, valueMap["time"], r, g, b, a);
                        spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
                        frameIndex++;
                    }
                    timelines.push(timeline);
                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);

                } else if (timelineName == "attachment") {
                    timeline = new spine.AttachmentTimeline(values.length);
                    timeline.slotIndex = slotIndex;

                    frameIndex = 0;
                    for (i = 0, n = values.length; i < n; i++) {
                        valueMap = values[i];
                        timeline.setFrame(frameIndex++, valueMap["time"], valueMap["name"]);
                    }
                    timelines.push(timeline);
                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);

                } else
                    throw "Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")";
            }
        }
        skeletonData.animations.push(new spine.Animation(name, timelines, duration));
    }
};
spine.SkeletonJson.readCurve = function (timeline, frameIndex, valueMap) {
    /*jshint -W069*/
    var curve = valueMap["curve"];
    if (!curve) return;
    if (curve == "stepped")
        timeline.curves.setStepped(frameIndex);
    else if (curve instanceof Array)
        timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);
};
spine.SkeletonJson.toColor = function (hexString, colorIndex) {
    if (hexString.length != 8) throw "Color hexidecimal length must be 8, recieved: " + hexString;
    return parseInt(hexString.substr(colorIndex * 2, 2), 16) / 255;
};

spine.Atlas = function (atlasText, textureLoader) {
    this.textureLoader = textureLoader;
    this.pages = [];
    this.regions = [];

    var reader = new spine.AtlasReader(atlasText);
    var tuple = [];
    tuple.length = 4;
    var page = null;
    while (true) {
        var line = reader.readLine();
        if (line == null) break;
        line = reader.trim(line);
        if (!line.length)
            page = null;
        else if (!page) {
            page = new spine.AtlasPage();
            page.name = line;

            page.format = spine.Atlas.Format[reader.readValue()];

            reader.readTuple(tuple);
            page.minFilter = spine.Atlas.TextureFilter[tuple[0]];
            page.magFilter = spine.Atlas.TextureFilter[tuple[1]];

            var direction = reader.readValue();
            page.uWrap = spine.Atlas.TextureWrap.clampToEdge;
            page.vWrap = spine.Atlas.TextureWrap.clampToEdge;
            if (direction == "x")
                page.uWrap = spine.Atlas.TextureWrap.repeat;
            else if (direction == "y")
                page.vWrap = spine.Atlas.TextureWrap.repeat;
            else if (direction == "xy")
                page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;

            textureLoader.load(page, line);

            this.pages.push(page);

        } else {
            var region = new spine.AtlasRegion();
            region.name = line;
            region.page = page;

            region.rotate = reader.readValue() == "true";

            reader.readTuple(tuple);
            var x = parseInt(tuple[0], 10);
            var y = parseInt(tuple[1], 10);

            reader.readTuple(tuple);
            var width = parseInt(tuple[0], 10);
            var height = parseInt(tuple[1], 10);

            region.u = x / page.width;
            region.v = y / page.height;
            if (region.rotate) {
                region.u2 = (x + height) / page.width;
                region.v2 = (y + width) / page.height;
            } else {
                region.u2 = (x + width) / page.width;
                region.v2 = (y + height) / page.height;
            }
            region.x = x;
            region.y = y;
            region.width = Math.abs(width);
            region.height = Math.abs(height);

            if (reader.readTuple(tuple) == 4) { // split is optional
                region.splits = [parseInt(tuple[0], 10), parseInt(tuple[1], 10), parseInt(tuple[2], 10), parseInt(tuple[3], 10)];

                if (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits
                    region.pads = [parseInt(tuple[0], 10), parseInt(tuple[1], 10), parseInt(tuple[2], 10), parseInt(tuple[3], 10)];

                    reader.readTuple(tuple);
                }
            }

            region.originalWidth = parseInt(tuple[0], 10);
            region.originalHeight = parseInt(tuple[1], 10);

            reader.readTuple(tuple);
            region.offsetX = parseInt(tuple[0], 10);
            region.offsetY = parseInt(tuple[1], 10);

            region.index = parseInt(reader.readValue(), 10);

            this.regions.push(region);
        }
    }
};
spine.Atlas.prototype = {
    findRegion: function (name) {
        var regions = this.regions;
        for (var i = 0, n = regions.length; i < n; i++)
            if (regions[i].name == name) return regions[i];
        return null;
    },
    dispose: function () {
        var pages = this.pages;
        for (var i = 0, n = pages.length; i < n; i++)
            this.textureLoader.unload(pages[i].rendererObject);
    },
    updateUVs: function (page) {
        var regions = this.regions;
        for (var i = 0, n = regions.length; i < n; i++) {
            var region = regions[i];
            if (region.page != page) continue;
            region.u = region.x / page.width;
            region.v = region.y / page.height;
            if (region.rotate) {
                region.u2 = (region.x + region.height) / page.width;
                region.v2 = (region.y + region.width) / page.height;
            } else {
                region.u2 = (region.x + region.width) / page.width;
                region.v2 = (region.y + region.height) / page.height;
            }
        }
    }
};

spine.Atlas.Format = {
    alpha: 0,
    intensity: 1,
    luminanceAlpha: 2,
    rgb565: 3,
    rgba4444: 4,
    rgb888: 5,
    rgba8888: 6
};

spine.Atlas.TextureFilter = {
    nearest: 0,
    linear: 1,
    mipMap: 2,
    mipMapNearestNearest: 3,
    mipMapLinearNearest: 4,
    mipMapNearestLinear: 5,
    mipMapLinearLinear: 6
};

spine.Atlas.TextureWrap = {
    mirroredRepeat: 0,
    clampToEdge: 1,
    repeat: 2
};

spine.AtlasPage = function () {};
spine.AtlasPage.prototype = {
    name: null,
    format: null,
    minFilter: null,
    magFilter: null,
    uWrap: null,
    vWrap: null,
    rendererObject: null,
    width: 0,
    height: 0
};

spine.AtlasRegion = function () {};
spine.AtlasRegion.prototype = {
    page: null,
    name: null,
    x: 0, y: 0,
    width: 0, height: 0,
    u: 0, v: 0, u2: 0, v2: 0,
    offsetX: 0, offsetY: 0,
    originalWidth: 0, originalHeight: 0,
    index: 0,
    rotate: false,
    splits: null,
    pads: null
};

spine.AtlasReader = function (text) {
    this.lines = text.split(/\r\n|\r|\n/);
};
spine.AtlasReader.prototype = {
    index: 0,
    trim: function (value) {
        return value.replace(/^\s+|\s+$/g, "");
    },
    readLine: function () {
        if (this.index >= this.lines.length) return null;
        return this.lines[this.index++];
    },
    readValue: function () {
        var line = this.readLine();
        var colon = line.indexOf(":");
        if (colon == -1) throw "Invalid line: " + line;
        return this.trim(line.substring(colon + 1));
    },
    /** Returns the number of tuple values read (2 or 4). */
    readTuple: function (tuple) {
        var line = this.readLine();
        var colon = line.indexOf(":");
        if (colon == -1) throw "Invalid line: " + line;
        var i = 0, lastMatch= colon + 1;
        for (; i < 3; i++) {
            var comma = line.indexOf(",", lastMatch);
            if (comma == -1) {
                if (!i) throw "Invalid line: " + line;
                break;
            }
            tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));
            lastMatch = comma + 1;
        }
        tuple[i] = this.trim(line.substring(lastMatch));
        return i + 1;
    }
}

spine.AtlasAttachmentLoader = function (atlas) {
    this.atlas = atlas;
}
spine.AtlasAttachmentLoader.prototype = {
    newAttachment: function (skin, type, name) {
        switch (type) {
        case spine.AttachmentType.region:
            var region = this.atlas.findRegion(name);
            if (!region) throw "Region not found in atlas: " + name + " (" + type + ")";
            var attachment = new spine.RegionAttachment(name);
            attachment.rendererObject = region;
            attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);
            attachment.regionOffsetX = region.offsetX;
            attachment.regionOffsetY = region.offsetY;
            attachment.regionWidth = region.width;
            attachment.regionHeight = region.height;
            attachment.regionOriginalWidth = region.originalWidth;
            attachment.regionOriginalHeight = region.originalHeight;
            return attachment;
        }
        throw "Unknown attachment type: " + type;
    }
}

spine.Bone.yDown = true;
PIXI.AnimCache = {};

/**
 * A class that enables the you to import and run your spine animations in pixi.
 * Spine animation data needs to be loaded using the PIXI.AssetLoader or PIXI.SpineLoader before it can be used by this class
 * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source
 *
 * @class Spine
 * @extends DisplayObjectContainer
 * @constructor
 * @param url {String} The url of the spine anim file to be used
 */
PIXI.Spine = function (url) {
    PIXI.DisplayObjectContainer.call(this);

    this.spineData = PIXI.AnimCache[url];

    if (!this.spineData) {
        throw new Error("Spine data must be preloaded using PIXI.SpineLoader or PIXI.AssetLoader: " + url);
    }

    this.skeleton = new spine.Skeleton(this.spineData);
    this.skeleton.updateWorldTransform();

    this.stateData = new spine.AnimationStateData(this.spineData);
    this.state = new spine.AnimationState(this.stateData);

    this.slotContainers = [];

    for (var i = 0, n = this.skeleton.drawOrder.length; i < n; i++) {
        var slot = this.skeleton.drawOrder[i];
        var attachment = slot.attachment;
        var slotContainer = new PIXI.DisplayObjectContainer();
        this.slotContainers.push(slotContainer);
        this.addChild(slotContainer);
        if (!(attachment instanceof spine.RegionAttachment)) {
            continue;
        }
        var spriteName = attachment.rendererObject.name;
        var sprite = this.createSprite(slot, attachment.rendererObject);
        slot.currentSprite = sprite;
        slot.currentSpriteName = spriteName;
        slotContainer.addChild(sprite);
    }
};

PIXI.Spine.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
PIXI.Spine.prototype.constructor = PIXI.Spine;

/*
 * Updates the object transform for rendering
 *
 * @method updateTransform
 * @private
 */
PIXI.Spine.prototype.updateTransform = function () {
    this.lastTime = this.lastTime || Date.now();
    var timeDelta = (Date.now() - this.lastTime) * 0.001;
    this.lastTime = Date.now();
    this.state.update(timeDelta);
    this.state.apply(this.skeleton);
    this.skeleton.updateWorldTransform();

    var drawOrder = this.skeleton.drawOrder;
    for (var i = 0, n = drawOrder.length; i < n; i++) {
        var slot = drawOrder[i];
        var attachment = slot.attachment;
        var slotContainer = this.slotContainers[i];
        if (!(attachment instanceof spine.RegionAttachment)) {
            slotContainer.visible = false;
            continue;
        }

        if (attachment.rendererObject) {
            if (!slot.currentSpriteName || slot.currentSpriteName != attachment.name) {
                var spriteName = attachment.rendererObject.name;
                if (slot.currentSprite !== undefined) {
                    slot.currentSprite.visible = false;
                }
                slot.sprites = slot.sprites || {};
                if (slot.sprites[spriteName] !== undefined) {
                    slot.sprites[spriteName].visible = true;
                } else {
                    var sprite = this.createSprite(slot, attachment.rendererObject);
                    slotContainer.addChild(sprite);
                }
                slot.currentSprite = slot.sprites[spriteName];
                slot.currentSpriteName = spriteName;
            }
        }
        slotContainer.visible = true;

        var bone = slot.bone;

        slotContainer.position.x = bone.worldX + attachment.x * bone.m00 + attachment.y * bone.m01;
        slotContainer.position.y = bone.worldY + attachment.x * bone.m10 + attachment.y * bone.m11;
        slotContainer.scale.x = bone.worldScaleX;
        slotContainer.scale.y = bone.worldScaleY;

        slotContainer.rotation = -(slot.bone.worldRotation * Math.PI / 180);

        slotContainer.alpha = slot.a;
        slot.currentSprite.tint = PIXI.rgb2hex([slot.r,slot.g,slot.b]);
    }

    PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
};


PIXI.Spine.prototype.createSprite = function (slot, descriptor) {
    var name = PIXI.TextureCache[descriptor.name] ? descriptor.name : descriptor.name + ".png";
    var sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(name));
    sprite.scale = descriptor.scale;
    sprite.rotation = descriptor.rotation;
    sprite.anchor.x = sprite.anchor.y = 0.5;

    slot.sprites = slot.sprites || {};
    slot.sprites[descriptor.name] = sprite;
    return sprite;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

PIXI.BaseTextureCache = {};
PIXI.texturesToUpdate = [];
PIXI.texturesToDestroy = [];

PIXI.BaseTextureCacheIdGenerator = 0;

/**
 * A texture stores the information that represents an image. All textures have a base texture
 *
 * @class BaseTexture
 * @uses EventTarget
 * @constructor
 * @param source {String} the source object (image or canvas)
 * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts
 */
PIXI.BaseTexture = function(source, scaleMode)
{
    PIXI.EventTarget.call( this );

    /**
     * [read-only] The width of the base texture set when the image has loaded
     *
     * @property width
     * @type Number
     * @readOnly
     */
    this.width = 100;

    /**
     * [read-only] The height of the base texture set when the image has loaded
     *
     * @property height
     * @type Number
     * @readOnly
     */
    this.height = 100;

    /**
     * The scale mode to apply when scaling this texture
     * @property scaleMode
     * @type PIXI.scaleModes
     * @default PIXI.scaleModes.LINEAR
     */
    this.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;

    /**
     * [read-only] Describes if the base texture has loaded or not
     *
     * @property hasLoaded
     * @type Boolean
     * @readOnly
     */
    this.hasLoaded = false;

    /**
     * The source that is loaded to create the texture
     *
     * @property source
     * @type Image
     */
    this.source = source;

    //TODO will be used for futer pixi 1.5...
    this.id = PIXI.BaseTextureCacheIdGenerator++;

    /**
     * Controls if RGB channels should be premultiplied by Alpha  (WebGL only)
     *
     * @property
     * @type Boolean
     * @default TRUE
    */
    this.premultipliedAlpha = true;

    // used for webGL
    this._glTextures = [];
    
    // used for webGL teture updateing...
    this._dirty = [];
    
    if(!source)return;

    if((this.source.complete || this.source.getContext) && this.source.width && this.source.height)
    {
        this.hasLoaded = true;
        this.width = this.source.width;
        this.height = this.source.height;

        PIXI.texturesToUpdate.push(this);
    }
    else
    {

        var scope = this;
        this.source.onload = function() {

            scope.hasLoaded = true;
            scope.width = scope.source.width;
            scope.height = scope.source.height;

            for (var i = 0; i < scope._glTextures.length; i++)
            {
                scope._dirty[i] = true;
            }

            // add it to somewhere...
            scope.dispatchEvent( { type: 'loaded', content: scope } );
        };
        this.source.onerror = function() {
            scope.dispatchEvent( { type: 'error', content: scope } );
        };
    }

    this.imageUrl = null;
    this._powerOf2 = false;

    

};

PIXI.BaseTexture.prototype.constructor = PIXI.BaseTexture;

/**
 * Destroys this base texture
 *
 * @method destroy
 */
PIXI.BaseTexture.prototype.destroy = function()
{
    if(this.imageUrl)
    {
        delete PIXI.BaseTextureCache[this.imageUrl];
        delete PIXI.TextureCache[this.imageUrl];
        this.imageUrl = null;
        this.source.src = null;
    }
    else if (this.source && this.source._pixiId)
    {
        delete PIXI.BaseTextureCache[this.source._pixiId];
    }
    this.source = null;
    PIXI.texturesToDestroy.push(this);
};

/**
 * Changes the source image of the texture
 *
 * @method updateSourceImage
 * @param newSrc {String} the path of the image
 */
PIXI.BaseTexture.prototype.updateSourceImage = function(newSrc)
{
    this.hasLoaded = false;
    this.source.src = null;
    this.source.src = newSrc;
};

/**
 * Helper function that returns a base texture based on an image url
 * If the image is not in the base texture cache it will be created and loaded
 *
 * @static
 * @method fromImage
 * @param imageUrl {String} The image url of the texture
 * @param crossorigin {Boolean} 
 * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts
 * @return BaseTexture
 */
PIXI.BaseTexture.fromImage = function(imageUrl, crossorigin, scaleMode)
{
    var baseTexture = PIXI.BaseTextureCache[imageUrl];
    
    if(crossorigin === undefined && imageUrl.indexOf('data:') === -1) crossorigin = true;

    if(!baseTexture)
    {
        // new Image() breaks tex loading in some versions of Chrome.
        // See https://code.google.com/p/chromium/issues/detail?id=238071
        var image = new Image();//document.createElement('img');
        if (crossorigin)
        {
            image.crossOrigin = '';
        }
        image.src = imageUrl;
        baseTexture = new PIXI.BaseTexture(image, scaleMode);
        baseTexture.imageUrl = imageUrl;
        PIXI.BaseTextureCache[imageUrl] = baseTexture;
    }

    return baseTexture;
};

/**
 * Helper function that returns a base texture based on a canvas element
 * If the image is not in the base texture cache it will be created and loaded
 *
 * @static
 * @method fromCanvas
 * @param canvas {Canvas} The canvas element source of the texture
 * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts
 * @return BaseTexture
 */
PIXI.BaseTexture.fromCanvas = function(canvas, scaleMode)
{
    if(!canvas._pixiId)
    {
        canvas._pixiId = 'canvas_' + PIXI.TextureCacheIdGenerator++;
    }

    var baseTexture = PIXI.BaseTextureCache[canvas._pixiId];

    if(!baseTexture)
    {
        baseTexture = new PIXI.BaseTexture(canvas, scaleMode);
        PIXI.BaseTextureCache[canvas._pixiId] = baseTexture;
    }

    return baseTexture;
};



/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

PIXI.TextureCache = {};
PIXI.FrameCache = {};

PIXI.TextureCacheIdGenerator = 0;

/**
 * A texture stores the information that represents an image or part of an image. It cannot be added
 * to the display list directly. To do this use PIXI.Sprite. If no frame is provided then the whole image is used
 *
 * @class Texture
 * @uses EventTarget
 * @constructor
 * @param baseTexture {BaseTexture} The base texture source to create the texture from
 * @param frame {Rectangle} The rectangle frame of the texture to show
 */
PIXI.Texture = function(baseTexture, frame)
{
    PIXI.EventTarget.call( this );

    /**
     * Does this Texture have any frame data assigned to it?
     *
     * @property noFrame
     * @type Boolean
     */
    this.noFrame = false;

    if (!frame)
    {
        this.noFrame = true;
        frame = new PIXI.Rectangle(0,0,1,1);
    }

    if (baseTexture instanceof PIXI.Texture)
    {
        baseTexture = baseTexture.baseTexture;
    }

    /**
     * The base texture that this texture uses.
     *
     * @property baseTexture
     * @type BaseTexture
     */
    this.baseTexture = baseTexture;

    /**
     * The frame specifies the region of the base texture that this texture uses
     *
     * @property frame
     * @type Rectangle
     */
    this.frame = frame;

    /**
     * The trim point
     *
     * @property trim
     * @type Rectangle
     */
    this.trim = null;
    
    /**
     * This will let the renderer know if the texture is valid. If its not then it cannot be rendered.
     *
     * @property valid
     * @type Boolean
     */
    this.valid = false;

    /**
     * The context scope under which events are run.
     *
     * @property scope
     * @type Object
     */
    this.scope = this;

    /**
     * The WebGL UV data cache.
     *
     * @private
     * @property _uvs
     * @type Object
     */
    this._uvs = null;
    
    /**
     * The width of the Texture in pixels.
     *
     * @property width
     * @type Number
     */
    this.width = 0;

    /**
     * The height of the Texture in pixels.
     *
     * @property height
     * @type Number
     */
    this.height = 0;

    /**
     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
     *
     * @property crop
     * @type Rectangle
     */
    this.crop = new PIXI.Rectangle(0, 0, 1, 1);

    if (baseTexture.hasLoaded)
    {
        if (this.noFrame) frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height);
        this.setFrame(frame);
    }
    else
    {
        var scope = this;
        baseTexture.addEventListener('loaded', function(){ scope.onBaseTextureLoaded(); });
    }
};

PIXI.Texture.prototype.constructor = PIXI.Texture;

/**
 * Called when the base texture is loaded
 *
 * @method onBaseTextureLoaded
 * @param event
 * @private
 */
PIXI.Texture.prototype.onBaseTextureLoaded = function()
{
    var baseTexture = this.baseTexture;
    baseTexture.removeEventListener('loaded', this.onLoaded);

    if (this.noFrame) this.frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height);
    
    this.setFrame(this.frame);

    this.scope.dispatchEvent( { type: 'update', content: this } );
};

/**
 * Destroys this texture
 *
 * @method destroy
 * @param destroyBase {Boolean} Whether to destroy the base texture as well
 */
PIXI.Texture.prototype.destroy = function(destroyBase)
{
    if (destroyBase) this.baseTexture.destroy();

    this.valid = false;
};

/**
 * Specifies the region of the baseTexture that this texture will use.
 *
 * @method setFrame
 * @param frame {Rectangle} The frame of the texture to set it to
 */
PIXI.Texture.prototype.setFrame = function(frame)
{
    this.noFrame = false;

    this.frame = frame;
    this.width = frame.width;
    this.height = frame.height;

    this.crop.x = frame.x;
    this.crop.y = frame.y;
    this.crop.width = frame.width;
    this.crop.height = frame.height;

    if (!this.trim && (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height))
    {
        throw new Error('Texture Error: frame does not fit inside the base Texture dimensions ' + this);
    }

    this.valid = frame && frame.width && frame.height && this.baseTexture.source && this.baseTexture.hasLoaded;

    if (this.trim)
    {
        this.width = this.trim.width;
        this.height = this.trim.height;
        this.frame.width = this.trim.width;
        this.frame.height = this.trim.height;
    }

    if (this.valid) PIXI.Texture.frameUpdates.push(this);

};

/**
 * Updates the internal WebGL UV cache.
 *
 * @method _updateWebGLuvs
 * @private
 */
PIXI.Texture.prototype._updateWebGLuvs = function()
{
    if(!this._uvs)this._uvs = new PIXI.TextureUvs();

    var frame = this.crop;
    var tw = this.baseTexture.width;
    var th = this.baseTexture.height;

    this._uvs.x0 = frame.x / tw;
    this._uvs.y0 = frame.y / th;

    this._uvs.x1 = (frame.x + frame.width) / tw;
    this._uvs.y1 = frame.y / th;

    this._uvs.x2 = (frame.x + frame.width) / tw;
    this._uvs.y2 = (frame.y + frame.height) / th;

    this._uvs.x3 = frame.x / tw;
    this._uvs.y3 = (frame.y + frame.height) / th;

};

/**
 * Helper function that returns a texture based on an image url
 * If the image is not in the texture cache it will be  created and loaded
 *
 * @static
 * @method fromImage
 * @param imageUrl {String} The image url of the texture
 * @param crossorigin {Boolean} Whether requests should be treated as crossorigin
 * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts
 * @return Texture
 */
PIXI.Texture.fromImage = function(imageUrl, crossorigin, scaleMode)
{
    var texture = PIXI.TextureCache[imageUrl];

    if(!texture)
    {
        texture = new PIXI.Texture(PIXI.BaseTexture.fromImage(imageUrl, crossorigin, scaleMode));
        PIXI.TextureCache[imageUrl] = texture;
    }

    return texture;
};

/**
 * Helper function that returns a texture based on a frame id
 * If the frame id is not in the texture cache an error will be thrown
 *
 * @static
 * @method fromFrame
 * @param frameId {String} The frame id of the texture
 * @return Texture
 */
PIXI.Texture.fromFrame = function(frameId)
{
    var texture = PIXI.TextureCache[frameId];
    if(!texture) throw new Error('The frameId "' + frameId + '" does not exist in the texture cache ');
    return texture;
};

/**
 * Helper function that returns a texture based on a canvas element
 * If the canvas is not in the texture cache it will be  created and loaded
 *
 * @static
 * @method fromCanvas
 * @param canvas {Canvas} The canvas element source of the texture
 * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts
 * @return Texture
 */
PIXI.Texture.fromCanvas = function(canvas, scaleMode)
{
    var baseTexture = PIXI.BaseTexture.fromCanvas(canvas, scaleMode);

    return new PIXI.Texture( baseTexture );

};


/**
 * Adds a texture to the textureCache.
 *
 * @static
 * @method addTextureToCache
 * @param texture {Texture}
 * @param id {String} the id that the texture will be stored against.
 */
PIXI.Texture.addTextureToCache = function(texture, id)
{
    PIXI.TextureCache[id] = texture;
};

/**
 * Remove a texture from the textureCache.
 *
 * @static
 * @method removeTextureFromCache
 * @param id {String} the id of the texture to be removed
 * @return {Texture} the texture that was removed
 */
PIXI.Texture.removeTextureFromCache = function(id)
{
    var texture = PIXI.TextureCache[id];
    delete PIXI.TextureCache[id];
    delete PIXI.BaseTextureCache[id];
    return texture;
};

// this is more for webGL.. it contains updated frames..
PIXI.Texture.frameUpdates = [];

PIXI.TextureUvs = function()
{
    this.x0 = 0;
    this.y0 = 0;

    this.x1 = 0;
    this.y1 = 0;

    this.x2 = 0;
    this.y2 = 0;

    this.x3 = 0;
    this.y3 = 0;


};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 A RenderTexture is a special texture that allows any pixi displayObject to be rendered to it.

 __Hint__: All DisplayObjects (exmpl. Sprites) that render on RenderTexture should be preloaded.
 Otherwise black rectangles will be drawn instead.

 RenderTexture takes snapshot of DisplayObject passed to render method. If DisplayObject is passed to render method, position and rotation of it will be ignored. For example:

    var renderTexture = new PIXI.RenderTexture(800, 600);
    var sprite = PIXI.Sprite.fromImage("spinObj_01.png");
    sprite.position.x = 800/2;
    sprite.position.y = 600/2;
    sprite.anchor.x = 0.5;
    sprite.anchor.y = 0.5;
    renderTexture.render(sprite);

 Sprite in this case will be rendered to 0,0 position. To render this sprite at center DisplayObjectContainer should be used:

    var doc = new PIXI.DisplayObjectContainer();
    doc.addChild(sprite);
    renderTexture.render(doc);  // Renders to center of renderTexture

 * @class RenderTexture
 * @extends Texture
 * @constructor
 * @param width {Number} The width of the render texture
 * @param height {Number} The height of the render texture
 * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts
 */
PIXI.RenderTexture = function(width, height, renderer, scaleMode)
{
    PIXI.EventTarget.call( this );

    /**
     * The with of the render texture
     *
     * @property width
     * @type Number
     */
    this.width = width || 100;
    /**
     * The height of the render texture
     *
     * @property height
     * @type Number
     */
    this.height = height || 100;

    /**
     * The framing rectangle of the render texture
     *
     * @property frame
     * @type Rectangle
     */
    this.frame = new PIXI.Rectangle(0, 0, this.width, this.height);

    /**
     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
     *
     * @property crop
     * @type Rectangle
     */
    this.crop = new PIXI.Rectangle(0, 0, this.width, this.height);
    
    /**
     * The base texture object that this texture uses
     *
     * @property baseTexture
     * @type BaseTexture
     */
    this.baseTexture = new PIXI.BaseTexture();
    this.baseTexture.width = this.width;
    this.baseTexture.height = this.height;
    this.baseTexture._glTextures = [];

    this.baseTexture.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;

    this.baseTexture.hasLoaded = true;

    // each render texture can only belong to one renderer at the moment if its webGL
    this.renderer = renderer || PIXI.defaultRenderer;

    if(this.renderer.type === PIXI.WEBGL_RENDERER)
    {
        var gl = this.renderer.gl;

        this.textureBuffer = new PIXI.FilterTexture(gl, this.width, this.height, this.baseTexture.scaleMode);
        this.baseTexture._glTextures[gl.id] =  this.textureBuffer.texture;

        this.render = this.renderWebGL;
        this.projection = new PIXI.Point(this.width/2 , -this.height/2);
    }
    else
    {
        this.render = this.renderCanvas;
        this.textureBuffer = new PIXI.CanvasBuffer(this.width, this.height);
        this.baseTexture.source = this.textureBuffer.canvas;
    }

    this.valid = true;
    PIXI.Texture.frameUpdates.push(this);


};

PIXI.RenderTexture.prototype = Object.create(PIXI.Texture.prototype);
PIXI.RenderTexture.prototype.constructor = PIXI.RenderTexture;

/**
 * Resize the RenderTexture.
 *
 * @method resize
 * @param width {Number} The width to resize to.
 * @param height {Number} The height to resize to.
 * @param updateBase {Boolean} Should the baseTexture.width and height values be resized as well?
 */
PIXI.RenderTexture.prototype.resize = function(width, height, updateBase)
{
    if (width === this.width && height === this.height)
    {
        return;
    }

    this.width = this.frame.width = this.crop.width = width;
    this.height =  this.frame.height = this.crop.height = height;

    if (updateBase)
    {
        this.baseTexture.width = this.width;
        this.baseTexture.height = this.height;
    }

    if (this.renderer.type === PIXI.WEBGL_RENDERER)
    {
        this.projection.x = this.width / 2;
        this.projection.y = -this.height / 2;
    }
    
    this.textureBuffer.resize(this.width, this.height);
};

/**
 * Clears the RenderTexture.
 *
 * @method clear
 */
PIXI.RenderTexture.prototype.clear = function()
{
    if (this.renderer.type === PIXI.WEBGL_RENDERER)
    {
        this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
    }
    
    this.textureBuffer.clear();
};

/**
 * This function will draw the display object to the texture.
 *
 * @method renderWebGL
 * @param displayObject {DisplayObject} The display object to render this texture on
 * @param clear {Boolean} If true the texture will be cleared before the displayObject is drawn
 * @private
 */
PIXI.RenderTexture.prototype.renderWebGL = function(displayObject, position, clear)
{
    //TOOD replace position with matrix..
    var gl = this.renderer.gl;

    gl.colorMask(true, true, true, true);

    gl.viewport(0, 0, this.width, this.height);

    gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer );

    if(clear)this.textureBuffer.clear();


    // THIS WILL MESS WITH HIT TESTING!
    var children = displayObject.children;

    //TODO -? create a new one??? dont think so!
    var originalWorldTransform = displayObject.worldTransform;
    displayObject.worldTransform = PIXI.RenderTexture.tempMatrix;
    // modify to flip...
    displayObject.worldTransform.d = -1;
    displayObject.worldTransform.ty = this.projection.y * -2;

    if(position)
    {
        displayObject.worldTransform.tx = position.x;
        displayObject.worldTransform.ty -= position.y;
    }

    for(var i=0,j=children.length; i<j; i++)
    {
        children[i].updateTransform();
    }

    // update the textures!
    PIXI.WebGLRenderer.updateTextures();

    this.renderer.spriteBatch.dirty = true;
    
    this.renderer.renderDisplayObject(displayObject, this.projection, this.textureBuffer.frameBuffer);

    displayObject.worldTransform = originalWorldTransform;

    this.renderer.spriteBatch.dirty = true;
};


/**
 * This function will draw the display object to the texture.
 *
 * @method renderCanvas
 * @param displayObject {DisplayObject} The display object to render this texture on
 * @param clear {Boolean} If true the texture will be cleared before the displayObject is drawn
 * @private
 */
PIXI.RenderTexture.prototype.renderCanvas = function(displayObject, position, clear)
{
    var children = displayObject.children;

    var originalWorldTransform = displayObject.worldTransform;

    displayObject.worldTransform = PIXI.RenderTexture.tempMatrix;
    
    if(position)
    {
        displayObject.worldTransform.tx = position.x;
        displayObject.worldTransform.ty = position.y;
    }
    else
    {
        displayObject.worldTransform.tx = 0;
        displayObject.worldTransform.ty = 0;
    }

    for(var i = 0, j = children.length; i < j; i++)
    {
        children[i].updateTransform();
    }

    if(clear)this.textureBuffer.clear();

    var context = this.textureBuffer.context;

    this.renderer.renderDisplayObject(displayObject, context);

    context.setTransform(1,0,0,1,0,0);

    displayObject.worldTransform = originalWorldTransform;
};

PIXI.RenderTexture.tempMatrix = new PIXI.Matrix();


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * A Class that loads a bunch of images / sprite sheet / bitmap font files. Once the
 * assets have been loaded they are added to the PIXI Texture cache and can be accessed
 * easily through PIXI.Texture.fromImage() and PIXI.Sprite.fromImage()
 * When all items have been loaded this class will dispatch a 'onLoaded' event
 * As each individual item is loaded this class will dispatch a 'onProgress' event
 *
 * @class AssetLoader
 * @constructor
 * @uses EventTarget
 * @param {Array<String>} assetURLs an array of image/sprite sheet urls that you would like loaded
 *      supported. Supported image formats include 'jpeg', 'jpg', 'png', 'gif'. Supported
 *      sprite sheet data formats only include 'JSON' at this time. Supported bitmap font
 *      data formats include 'xml' and 'fnt'.
 * @param crossorigin {Boolean} Whether requests should be treated as crossorigin
 */
PIXI.AssetLoader = function(assetURLs, crossorigin)
{
    PIXI.EventTarget.call(this);

    /**
     * The array of asset URLs that are going to be loaded
     *
     * @property assetURLs
     * @type Array<String>
     */
    this.assetURLs = assetURLs;

    /**
     * Whether the requests should be treated as cross origin
     *
     * @property crossorigin
     * @type Boolean
     */
    this.crossorigin = crossorigin;

    /**
     * Maps file extension to loader types
     *
     * @property loadersByType
     * @type Object
     */
    this.loadersByType = {
        'jpg':  PIXI.ImageLoader,
        'jpeg': PIXI.ImageLoader,
        'png':  PIXI.ImageLoader,
        'gif':  PIXI.ImageLoader,
        'webp': PIXI.ImageLoader,
        'json': PIXI.JsonLoader,
        'atlas': PIXI.AtlasLoader,
        'anim': PIXI.SpineLoader,
        'xml':  PIXI.BitmapFontLoader,
        'fnt':  PIXI.BitmapFontLoader
    };
};

/**
 * Fired when an item has loaded
 * @event onProgress
 */

/**
 * Fired when all the assets have loaded
 * @event onComplete
 */

// constructor
PIXI.AssetLoader.prototype.constructor = PIXI.AssetLoader;

/**
 * Given a filename, returns its extension, wil
 *
 * @method _getDataType
 * @param str {String} the name of the asset
 */
PIXI.AssetLoader.prototype._getDataType = function(str)
{
    var test = 'data:';
    //starts with 'data:'
    var start = str.slice(0, test.length).toLowerCase();
    if (start === test) {
        var data = str.slice(test.length);

        var sepIdx = data.indexOf(',');
        if (sepIdx === -1) //malformed data URI scheme
            return null;

        //e.g. 'image/gif;base64' => 'image/gif'
        var info = data.slice(0, sepIdx).split(';')[0];

        //We might need to handle some special cases here...
        //standardize text/plain to 'txt' file extension
        if (!info || info.toLowerCase() === 'text/plain')
            return 'txt';

        //User specified mime type, try splitting it by '/'
        return info.split('/').pop().toLowerCase();
    }

    return null;
};

/**
 * Starts loading the assets sequentially
 *
 * @method load
 */
PIXI.AssetLoader.prototype.load = function()
{
    var scope = this;

    function onLoad(evt) {
        scope.onAssetLoaded(evt.content);
    }

    this.loadCount = this.assetURLs.length;

    for (var i=0; i < this.assetURLs.length; i++)
    {
        var fileName = this.assetURLs[i];
        //first see if we have a data URI scheme..
        var fileType = this._getDataType(fileName);

        //if not, assume it's a file URI
        if (!fileType)
            fileType = fileName.split('?').shift().split('.').pop().toLowerCase();

        var Constructor = this.loadersByType[fileType];
        if(!Constructor)
            throw new Error(fileType + ' is an unsupported file type');

        var loader = new Constructor(fileName, this.crossorigin);

        loader.addEventListener('loaded', onLoad);
        loader.load();
    }
};

/**
 * Invoked after each file is loaded
 *
 * @method onAssetLoaded
 * @private
 */
PIXI.AssetLoader.prototype.onAssetLoaded = function(loader)
{
    this.loadCount--;
    this.dispatchEvent({ type: 'onProgress', content: this, loader: loader });
    if (this.onProgress) this.onProgress(loader);

    if (!this.loadCount)
    {
        this.dispatchEvent({type: 'onComplete', content: this});
        if(this.onComplete) this.onComplete();
    }
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The json file loader is used to load in JSON data and parse it
 * When loaded this class will dispatch a 'loaded' event
 * If loading fails this class will dispatch an 'error' event
 *
 * @class JsonLoader
 * @uses EventTarget
 * @constructor
 * @param url {String} The url of the JSON file
 * @param crossorigin {Boolean} Whether requests should be treated as crossorigin
 */
PIXI.JsonLoader = function (url, crossorigin) {
    PIXI.EventTarget.call(this);

    /**
     * The url of the bitmap font data
     *
     * @property url
     * @type String
     */
    this.url = url;

    /**
     * Whether the requests should be treated as cross origin
     *
     * @property crossorigin
     * @type Boolean
     */
    this.crossorigin = crossorigin;

    /**
     * [read-only] The base url of the bitmap font data
     *
     * @property baseUrl
     * @type String
     * @readOnly
     */
    this.baseUrl = url.replace(/[^\/]*$/, '');

    /**
     * [read-only] Whether the data has loaded yet
     *
     * @property loaded
     * @type Boolean
     * @readOnly
     */
    this.loaded = false;

};

// constructor
PIXI.JsonLoader.prototype.constructor = PIXI.JsonLoader;

/**
 * Loads the JSON data
 *
 * @method load
 */
PIXI.JsonLoader.prototype.load = function () {

    var scope = this;

    if(window.XDomainRequest && scope.crossorigin)
    {
        this.ajaxRequest = new window.XDomainRequest();

        // XDomainRequest has a few querks. Occasionally it will abort requests
        // A way to avoid this is to make sure ALL callbacks are set even if not used
        // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9
        this.ajaxRequest.timeout = 3000;

        this.ajaxRequest.onerror = function () {
            scope.onError();
        };
           
        this.ajaxRequest.ontimeout = function () {
            scope.onError();
        };

        this.ajaxRequest.onprogress = function() {};

    }
    else if (window.XMLHttpRequest)
    {
        this.ajaxRequest = new window.XMLHttpRequest();
    }
    else
    {
        this.ajaxRequest = new window.ActiveXObject('Microsoft.XMLHTTP');
    }

    

    this.ajaxRequest.onload = function(){

        scope.onJSONLoaded();
    };

    this.ajaxRequest.open('GET',this.url,true);

    this.ajaxRequest.send();
};

/**
 * Invoke when JSON file is loaded
 *
 * @method onJSONLoaded
 * @private
 */
PIXI.JsonLoader.prototype.onJSONLoaded = function () {
    
    if(!this.ajaxRequest.responseText )
    {
        this.onError();
        return;
    }
   
    this.json = JSON.parse(this.ajaxRequest.responseText);

    if(this.json.frames)
    {
        // sprite sheet
        var scope = this;
        var textureUrl = this.baseUrl + this.json.meta.image;
        var image = new PIXI.ImageLoader(textureUrl, this.crossorigin);
        var frameData = this.json.frames;

        this.texture = image.texture.baseTexture;
        image.addEventListener('loaded', function() {
            scope.onLoaded();
        });

        for (var i in frameData)
        {
            var rect = frameData[i].frame;

            if (rect)
            {
                PIXI.TextureCache[i] = new PIXI.Texture(this.texture, {
                    x: rect.x,
                    y: rect.y,
                    width: rect.w,
                    height: rect.h
                });

                PIXI.TextureCache[i].crop = new PIXI.Rectangle(rect.x, rect.y, rect.w, rect.h);

                //  Check to see if the sprite is trimmed
                if (frameData[i].trimmed)
                {
                    var actualSize = frameData[i].sourceSize;
                    var realSize = frameData[i].spriteSourceSize;
                    PIXI.TextureCache[i].trim = new PIXI.Rectangle(realSize.x, realSize.y, actualSize.w, actualSize.h);
                }
            }
        }

        image.load();

    }
    else if(this.json.bones)
    {
        // spine animation
        var spineJsonParser = new spine.SkeletonJson();
        var skeletonData = spineJsonParser.readSkeletonData(this.json);
        PIXI.AnimCache[this.url] = skeletonData;
        this.onLoaded();
    }
    else
    {
        this.onLoaded();
    }
};

/**
 * Invoke when json file loaded
 *
 * @method onLoaded
 * @private
 */
PIXI.JsonLoader.prototype.onLoaded = function () {
    this.loaded = true;
    this.dispatchEvent({
        type: 'loaded',
        content: this
    });
};

/**
 * Invoke when error occured
 *
 * @method onError
 * @private
 */
PIXI.JsonLoader.prototype.onError = function () {

    this.dispatchEvent({
        type: 'error',
        content: this
    });
};

/**
 * @author Martin Kelm http://mkelm.github.com
 */

/**
 * The atlas file loader is used to load in Atlas data and parse it
 * When loaded this class will dispatch a 'loaded' event
 * If loading fails this class will dispatch an 'error' event
 * @class AtlasLoader
 * @extends EventTarget
 * @constructor
 * @param {String} url the url of the JSON file
 * @param {Boolean} crossorigin
 */

PIXI.AtlasLoader = function (url, crossorigin) {
    PIXI.EventTarget.call(this);
    this.url = url;
    this.baseUrl = url.replace(/[^\/]*$/, '');
    this.crossorigin = crossorigin;
    this.loaded = false;

};

// constructor
PIXI.AtlasLoader.constructor = PIXI.AtlasLoader;


 /**
 * Starts loading the JSON file
 *
 * @method load
 */
PIXI.AtlasLoader.prototype.load = function () {
    this.ajaxRequest = new PIXI.AjaxRequest();
    this.ajaxRequest.onreadystatechange = this.onAtlasLoaded.bind(this);

    this.ajaxRequest.open('GET', this.url, true);
    if (this.ajaxRequest.overrideMimeType) this.ajaxRequest.overrideMimeType('application/json');
    this.ajaxRequest.send(null);
};

/**
 * Invoke when JSON file is loaded
 * @method onAtlasLoaded
 * @private
 */
PIXI.AtlasLoader.prototype.onAtlasLoaded = function () {
    if (this.ajaxRequest.readyState === 4) {
        if (this.ajaxRequest.status === 200 || window.location.href.indexOf('http') === -1) {
            this.atlas = {
                meta : {
                    image : []
                },
                frames : []
            };
            var result = this.ajaxRequest.responseText.split(/\r?\n/);
            var lineCount = -3;

            var currentImageId = 0;
            var currentFrame = null;
            var nameInNextLine = false;

            var i = 0,
                j = 0,
                selfOnLoaded = this.onLoaded.bind(this);

            // parser without rotation support yet!
            for (i = 0; i < result.length; i++) {
                result[i] = result[i].replace(/^\s+|\s+$/g, '');
                if (result[i] === '') {
                    nameInNextLine = i+1;
                }
                if (result[i].length > 0) {
                    if (nameInNextLine === i) {
                        this.atlas.meta.image.push(result[i]);
                        currentImageId = this.atlas.meta.image.length - 1;
                        this.atlas.frames.push({});
                        lineCount = -3;
                    } else if (lineCount > 0) {
                        if (lineCount % 7 === 1) { // frame name
                            if (currentFrame != null) { //jshint ignore:line
                                this.atlas.frames[currentImageId][currentFrame.name] = currentFrame;
                            }
                            currentFrame = { name: result[i], frame : {} };
                        } else {
                            var text = result[i].split(' ');
                            if (lineCount % 7 === 3) { // position
                                currentFrame.frame.x = Number(text[1].replace(',', ''));
                                currentFrame.frame.y = Number(text[2]);
                            } else if (lineCount % 7 === 4) { // size
                                currentFrame.frame.w = Number(text[1].replace(',', ''));
                                currentFrame.frame.h = Number(text[2]);
                            } else if (lineCount % 7 === 5) { // real size
                                var realSize = {
                                    x : 0,
                                    y : 0,
                                    w : Number(text[1].replace(',', '')),
                                    h : Number(text[2])
                                };

                                if (realSize.w > currentFrame.frame.w || realSize.h > currentFrame.frame.h) {
                                    currentFrame.trimmed = true;
                                    currentFrame.realSize = realSize;
                                } else {
                                    currentFrame.trimmed = false;
                                }
                            }
                        }
                    }
                    lineCount++;
                }
            }

            if (currentFrame != null) { //jshint ignore:line
                this.atlas.frames[currentImageId][currentFrame.name] = currentFrame;
            }

            if (this.atlas.meta.image.length > 0) {
                this.images = [];
                for (j = 0; j < this.atlas.meta.image.length; j++) {
                    // sprite sheet
                    var textureUrl = this.baseUrl + this.atlas.meta.image[j];
                    var frameData = this.atlas.frames[j];
                    this.images.push(new PIXI.ImageLoader(textureUrl, this.crossorigin));

                    for (i in frameData) {
                        var rect = frameData[i].frame;
                        if (rect) {
                            PIXI.TextureCache[i] = new PIXI.Texture(this.images[j].texture.baseTexture, {
                                x: rect.x,
                                y: rect.y,
                                width: rect.w,
                                height: rect.h
                            });
                            if (frameData[i].trimmed) {
                                PIXI.TextureCache[i].realSize = frameData[i].realSize;
                                // trim in pixi not supported yet, todo update trim properties if it is done ...
                                PIXI.TextureCache[i].trim.x = 0;
                                PIXI.TextureCache[i].trim.y = 0;
                            }
                        }
                    }
                }

                this.currentImageId = 0;
                for (j = 0; j < this.images.length; j++) {
                    this.images[j].addEventListener('loaded', selfOnLoaded);
                }
                this.images[this.currentImageId].load();

            } else {
                this.onLoaded();
            }

        } else {
            this.onError();
        }
    }
};

/**
 * Invoke when json file has loaded
 * @method onLoaded
 * @private
 */
PIXI.AtlasLoader.prototype.onLoaded = function () {
    if (this.images.length - 1 > this.currentImageId) {
        this.currentImageId++;
        this.images[this.currentImageId].load();
    } else {
        this.loaded = true;
        this.dispatchEvent({
            type: 'loaded',
            content: this
        });
    }
};

/**
 * Invoke when error occured
 * @method onError
 * @private
 */
PIXI.AtlasLoader.prototype.onError = function () {
    this.dispatchEvent({
        type: 'error',
        content: this
    });
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The sprite sheet loader is used to load in JSON sprite sheet data
 * To generate the data you can use http://www.codeandweb.com/texturepacker and publish in the 'JSON' format
 * There is a free version so thats nice, although the paid version is great value for money.
 * It is highly recommended to use Sprite sheets (also know as a 'texture atlas') as it means sprites can be batched and drawn together for highly increased rendering speed.
 * Once the data has been loaded the frames are stored in the PIXI texture cache and can be accessed though PIXI.Texture.fromFrameId() and PIXI.Sprite.fromFrameId()
 * This loader will load the image file that the Spritesheet points to as well as the data.
 * When loaded this class will dispatch a 'loaded' event
 *
 * @class SpriteSheetLoader
 * @uses EventTarget
 * @constructor
 * @param url {String} The url of the sprite sheet JSON file
 * @param crossorigin {Boolean} Whether requests should be treated as crossorigin
 */
PIXI.SpriteSheetLoader = function (url, crossorigin) {
    /*
     * i use texture packer to load the assets..
     * http://www.codeandweb.com/texturepacker
     * make sure to set the format as 'JSON'
     */
    PIXI.EventTarget.call(this);

    /**
     * The url of the bitmap font data
     *
     * @property url
     * @type String
     */
    this.url = url;

    /**
     * Whether the requests should be treated as cross origin
     *
     * @property crossorigin
     * @type Boolean
     */
    this.crossorigin = crossorigin;

    /**
     * [read-only] The base url of the bitmap font data
     *
     * @property baseUrl
     * @type String
     * @readOnly
     */
    this.baseUrl = url.replace(/[^\/]*$/, '');

    /**
     * The texture being loaded
     *
     * @property texture
     * @type Texture
     */
    this.texture = null;

    /**
     * The frames of the sprite sheet
     *
     * @property frames
     * @type Object
     */
    this.frames = {};
};

// constructor
PIXI.SpriteSheetLoader.prototype.constructor = PIXI.SpriteSheetLoader;

/**
 * This will begin loading the JSON file
 *
 * @method load
 */
PIXI.SpriteSheetLoader.prototype.load = function () {
    var scope = this;
    var jsonLoader = new PIXI.JsonLoader(this.url, this.crossorigin);
    jsonLoader.addEventListener('loaded', function (event) {
        scope.json = event.content.json;
        scope.onLoaded();
    });
    jsonLoader.load();
};

/**
 * Invoke when all files are loaded (json and texture)
 *
 * @method onLoaded
 * @private
 */
PIXI.SpriteSheetLoader.prototype.onLoaded = function () {
    this.dispatchEvent({
        type: 'loaded',
        content: this
    });
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The image loader class is responsible for loading images file formats ('jpeg', 'jpg', 'png' and 'gif')
 * Once the image has been loaded it is stored in the PIXI texture cache and can be accessed though PIXI.Texture.fromFrameId() and PIXI.Sprite.fromFrameId()
 * When loaded this class will dispatch a 'loaded' event
 *
 * @class ImageLoader
 * @uses EventTarget
 * @constructor
 * @param url {String} The url of the image
 * @param crossorigin {Boolean} Whether requests should be treated as crossorigin
 */
PIXI.ImageLoader = function(url, crossorigin)
{
    PIXI.EventTarget.call(this);

    /**
     * The texture being loaded
     *
     * @property texture
     * @type Texture
     */
    this.texture = PIXI.Texture.fromImage(url, crossorigin);

    /**
     * if the image is loaded with loadFramedSpriteSheet
     * frames will contain the sprite sheet frames
     *
     */
    this.frames = [];
};

// constructor
PIXI.ImageLoader.prototype.constructor = PIXI.ImageLoader;

/**
 * Loads image or takes it from cache
 *
 * @method load
 */
PIXI.ImageLoader.prototype.load = function()
{
    if(!this.texture.baseTexture.hasLoaded)
    {
        var scope = this;
        this.texture.baseTexture.addEventListener('loaded', function()
        {
            scope.onLoaded();
        });
    }
    else
    {
        this.onLoaded();
    }
};

/**
 * Invoked when image file is loaded or it is already cached and ready to use
 *
 * @method onLoaded
 * @private
 */
PIXI.ImageLoader.prototype.onLoaded = function()
{
    this.dispatchEvent({type: 'loaded', content: this});
};

/**
 * Loads image and split it to uniform sized frames
 *
 *
 * @method loadFramedSpriteSheet
 * @param frameWidth {Number} width of each frame
 * @param frameHeight {Number} height of each frame
 * @param textureName {String} if given, the frames will be cached in <textureName>-<ord> format
 */
PIXI.ImageLoader.prototype.loadFramedSpriteSheet = function(frameWidth, frameHeight, textureName)
{
    this.frames = [];
    var cols = Math.floor(this.texture.width / frameWidth);
    var rows = Math.floor(this.texture.height / frameHeight);

    var i=0;
    for (var y=0; y<rows; y++)
    {
        for (var x=0; x<cols; x++,i++)
        {
            var texture = new PIXI.Texture(this.texture, {
                x: x*frameWidth,
                y: y*frameHeight,
                width: frameWidth,
                height: frameHeight
            });

            this.frames.push(texture);
            if (textureName) PIXI.TextureCache[textureName + '-' + i] = texture;
        }
    }

    if(!this.texture.baseTexture.hasLoaded)
    {
        var scope = this;
        this.texture.baseTexture.addEventListener('loaded', function() {
            scope.onLoaded();
        });
    }
    else
    {
        this.onLoaded();
    }
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The xml loader is used to load in XML bitmap font data ('xml' or 'fnt')
 * To generate the data you can use http://www.angelcode.com/products/bmfont/
 * This loader will also load the image file as the data.
 * When loaded this class will dispatch a 'loaded' event
 *
 * @class BitmapFontLoader
 * @uses EventTarget
 * @constructor
 * @param url {String} The url of the sprite sheet JSON file
 * @param crossorigin {Boolean} Whether requests should be treated as crossorigin
 */
PIXI.BitmapFontLoader = function(url, crossorigin)
{
    /*
     * I use texture packer to load the assets..
     * http://www.codeandweb.com/texturepacker
     * make sure to set the format as 'JSON'
     */
    PIXI.EventTarget.call(this);

    /**
     * The url of the bitmap font data
     *
     * @property url
     * @type String
     */
    this.url = url;

    /**
     * Whether the requests should be treated as cross origin
     *
     * @property crossorigin
     * @type Boolean
     */
    this.crossorigin = crossorigin;

    /**
     * [read-only] The base url of the bitmap font data
     *
     * @property baseUrl
     * @type String
     * @readOnly
     */
    this.baseUrl = url.replace(/[^\/]*$/, '');

    /**
     * [read-only] The texture of the bitmap font
     *
     * @property baseUrl
     * @type String
     */
    this.texture = null;
};

// constructor
PIXI.BitmapFontLoader.prototype.constructor = PIXI.BitmapFontLoader;

/**
 * Loads the XML font data
 *
 * @method load
 */
PIXI.BitmapFontLoader.prototype.load = function()
{
    this.ajaxRequest = new PIXI.AjaxRequest();
    var scope = this;
    this.ajaxRequest.onreadystatechange = function()
    {
        scope.onXMLLoaded();
    };

    this.ajaxRequest.open('GET', this.url, true);
    if (this.ajaxRequest.overrideMimeType) this.ajaxRequest.overrideMimeType('application/xml');
    this.ajaxRequest.send(null);
};

/**
 * Invoked when the XML file is loaded, parses the data
 *
 * @method onXMLLoaded
 * @private
 */
PIXI.BitmapFontLoader.prototype.onXMLLoaded = function()
{
    if (this.ajaxRequest.readyState === 4)
    {
        if (this.ajaxRequest.status === 200 || window.location.protocol.indexOf('http') === -1)
        {
            var responseXML = this.ajaxRequest.responseXML;
            if(!responseXML || /MSIE 9/i.test(navigator.userAgent) || navigator.isCocoonJS) {
                if(typeof(window.DOMParser) === 'function') {
                    var domparser = new DOMParser();
                    responseXML = domparser.parseFromString(this.ajaxRequest.responseText, 'text/xml');
                } else {
                    var div = document.createElement('div');
                    div.innerHTML = this.ajaxRequest.responseText;
                    responseXML = div;
                }
            }

            var textureUrl = this.baseUrl + responseXML.getElementsByTagName('page')[0].getAttribute('file');
            var image = new PIXI.ImageLoader(textureUrl, this.crossorigin);
            this.texture = image.texture.baseTexture;

            var data = {};
            var info = responseXML.getElementsByTagName('info')[0];
            var common = responseXML.getElementsByTagName('common')[0];
            data.font = info.getAttribute('face');
            data.size = parseInt(info.getAttribute('size'), 10);
            data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);
            data.chars = {};

            //parse letters
            var letters = responseXML.getElementsByTagName('char');

            for (var i = 0; i < letters.length; i++)
            {
                var charCode = parseInt(letters[i].getAttribute('id'), 10);

                var textureRect = new PIXI.Rectangle(
                    parseInt(letters[i].getAttribute('x'), 10),
                    parseInt(letters[i].getAttribute('y'), 10),
                    parseInt(letters[i].getAttribute('width'), 10),
                    parseInt(letters[i].getAttribute('height'), 10)
                );

                data.chars[charCode] = {
                    xOffset: parseInt(letters[i].getAttribute('xoffset'), 10),
                    yOffset: parseInt(letters[i].getAttribute('yoffset'), 10),
                    xAdvance: parseInt(letters[i].getAttribute('xadvance'), 10),
                    kerning: {},
                    texture: PIXI.TextureCache[charCode] = new PIXI.Texture(this.texture, textureRect)

                };
            }

            //parse kernings
            var kernings = responseXML.getElementsByTagName('kerning');
            for (i = 0; i < kernings.length; i++)
            {
                var first = parseInt(kernings[i].getAttribute('first'), 10);
                var second = parseInt(kernings[i].getAttribute('second'), 10);
                var amount = parseInt(kernings[i].getAttribute('amount'), 10);

                data.chars[second].kerning[first] = amount;

            }

            PIXI.BitmapText.fonts[data.font] = data;

            var scope = this;
            image.addEventListener('loaded', function() {
                scope.onLoaded();
            });
            image.load();
        }
    }
};

/**
 * Invoked when all files are loaded (xml/fnt and texture)
 *
 * @method onLoaded
 * @private
 */
PIXI.BitmapFontLoader.prototype.onLoaded = function()
{
    this.dispatchEvent({type: 'loaded', content: this});
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 * based on pixi impact spine implementation made by Eemeli Kelokorpi (@ekelokorpi) https://github.com/ekelokorpi
 *
 * Awesome JS run time provided by EsotericSoftware
 * https://github.com/EsotericSoftware/spine-runtimes
 *
 */

/**
 * The Spine loader is used to load in JSON spine data
 * To generate the data you need to use http://esotericsoftware.com/ and export in the "JSON" format
 * Due to a clash of names  You will need to change the extension of the spine file from *.json to *.anim for it to load
 * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source
 * You will need to generate a sprite sheet to accompany the spine data
 * When loaded this class will dispatch a "loaded" event
 *
 * @class Spine
 * @uses EventTarget
 * @constructor
 * @param url {String} The url of the JSON file
 * @param crossorigin {Boolean} Whether requests should be treated as crossorigin
 */
PIXI.SpineLoader = function(url, crossorigin)
{
    PIXI.EventTarget.call(this);

    /**
     * The url of the bitmap font data
     *
     * @property url
     * @type String
     */
    this.url = url;

    /**
     * Whether the requests should be treated as cross origin
     *
     * @property crossorigin
     * @type Boolean
     */
    this.crossorigin = crossorigin;

    /**
     * [read-only] Whether the data has loaded yet
     *
     * @property loaded
     * @type Boolean
     * @readOnly
     */
    this.loaded = false;
};

PIXI.SpineLoader.prototype.constructor = PIXI.SpineLoader;

/**
 * Loads the JSON data
 *
 * @method load
 */
PIXI.SpineLoader.prototype.load = function () {

    var scope = this;
    var jsonLoader = new PIXI.JsonLoader(this.url, this.crossorigin);
    jsonLoader.addEventListener("loaded", function (event) {
        scope.json = event.content.json;
        scope.onLoaded();
    });
    jsonLoader.load();
};

/**
 * Invoke when JSON file is loaded
 *
 * @method onLoaded
 * @private
 */
PIXI.SpineLoader.prototype.onLoaded = function () {
    this.loaded = true;
    this.dispatchEvent({type: "loaded", content: this});
};


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * This is the base class for creating a pixi.js filter. Currently only webGL supports filters.
 * If you want to make a custom filter this should be your base class.
 * @class AbstractFilter
 * @constructor
 * @param fragmentSrc
 * @param uniforms
 */
PIXI.AbstractFilter = function(fragmentSrc, uniforms)
{
    /**
    * An array of passes - some filters contain a few steps this array simply stores the steps in a liniear fashion.
    * For example the blur filter has two passes blurX and blurY.
    * @property passes
    * @type Array an array of filter objects
    * @private
    */
    this.passes = [this];

    /**
    * @property shaders
    * @type Array an array of shaders
    * @private
    */
    this.shaders = [];
    
    this.dirty = true;
    this.padding = 0;

    /**
    * @property uniforms
    * @type object
    * @private
    */
    this.uniforms = uniforms || {};
    /**
    * @property fragmentSrc
    * @type Array
    * @private
    */
    this.fragmentSrc = fragmentSrc || [];
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * The AlphaMaskFilter class uses the pixel values from the specified texture (called the displacement map) to perform a displacement of an object.
 * You can use this filter to apply all manor of crazy warping effects
 * Currently the r property of the texture is used to offset the x and the g propery of the texture is used to offset the y.
 * @class AlphaMaskFilter
 * @contructor
 * @param texture {Texture} The texture used for the displacemtent map * must be power of 2 texture at the moment
 */
PIXI.AlphaMaskFilter = function(texture)
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];
    texture.baseTexture._powerOf2 = true;

    // set the uniforms
    this.uniforms = {
        mask: {type: 'sampler2D', value:texture},
        mapDimensions:   {type: '2f', value:{x:1, y:5112}},
        dimensions:   {type: '4fv', value:[0,0,0,0]}
    };

    if(texture.baseTexture.hasLoaded)
    {
        this.uniforms.mask.value.x = texture.width;
        this.uniforms.mask.value.y = texture.height;
    }
    else
    {
        this.boundLoadedFunction = this.onTextureLoaded.bind(this);

        texture.baseTexture.on('loaded', this.boundLoadedFunction);
    }

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform sampler2D mask;',
        'uniform sampler2D uSampler;',
        'uniform vec2 offset;',
        'uniform vec4 dimensions;',
        'uniform vec2 mapDimensions;',

        'void main(void) {',
        '   vec2 mapCords = vTextureCoord.xy;',
        '   mapCords += (dimensions.zw + offset)/ dimensions.xy ;',
        '   mapCords.y *= -1.0;',
        '   mapCords.y += 1.0;',
        '   mapCords *= dimensions.xy / mapDimensions;',

        '   vec4 original =  texture2D(uSampler, vTextureCoord);',
        '   float maskAlpha =  texture2D(mask, mapCords).r;',
        '   original *= maskAlpha;',
        //'   original.rgb *= maskAlpha;',
        '   gl_FragColor =  original;',
        //'   gl_FragColor = gl_FragColor;',
        '}'
    ];
};

PIXI.AlphaMaskFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.AlphaMaskFilter.prototype.constructor = PIXI.AlphaMaskFilter;

PIXI.AlphaMaskFilter.prototype.onTextureLoaded = function()
{
    this.uniforms.mapDimensions.value.x = this.uniforms.mask.value.width;
    this.uniforms.mapDimensions.value.y = this.uniforms.mask.value.height;

    this.uniforms.mask.value.baseTexture.off('loaded', this.boundLoadedFunction);
};

/**
 * The texture used for the displacemtent map * must be power of 2 texture at the moment
 *
 * @property map
 * @type Texture
 */
Object.defineProperty(PIXI.AlphaMaskFilter.prototype, 'map', {
    get: function() {
        return this.uniforms.mask.value;
    },
    set: function(value) {
        this.uniforms.mask.value = value;
    }
});


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * The ColorMatrixFilter class lets you apply a 4x4 matrix transformation on the RGBA
 * color and alpha values of every pixel on your displayObject to produce a result
 * with a new set of RGBA color and alpha values. Its pretty powerful!
 * @class ColorMatrixFilter
 * @contructor
 */
PIXI.ColorMatrixFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        matrix: {type: 'mat4', value: [1,0,0,0,
                                       0,1,0,0,
                                       0,0,1,0,
                                       0,0,0,1]}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform float invert;',
        'uniform mat4 matrix;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '   gl_FragColor = texture2D(uSampler, vTextureCoord) * matrix;',
      //  '   gl_FragColor = gl_FragColor;',
        '}'
    ];
};

PIXI.ColorMatrixFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.ColorMatrixFilter.prototype.constructor = PIXI.ColorMatrixFilter;

/**
 * Sets the matrix of the color matrix filter
 *
 * @property matrix
 * @type Array and array of 26 numbers
 * @default [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]
 */
Object.defineProperty(PIXI.ColorMatrixFilter.prototype, 'matrix', {
    get: function() {
        return this.uniforms.matrix.value;
    },
    set: function(value) {
        this.uniforms.matrix.value = value;
    }
});
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * This turns your displayObjects to black and white.
 * @class GrayFilter
 * @contructor
 */
PIXI.GrayFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        gray: {type: '1f', value: 1}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform sampler2D uSampler;',
        'uniform float gray;',

        'void main(void) {',
        '   gl_FragColor = texture2D(uSampler, vTextureCoord);',
        '   gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.2126*gl_FragColor.r + 0.7152*gl_FragColor.g + 0.0722*gl_FragColor.b), gray);',
     //   '   gl_FragColor = gl_FragColor;',
        '}'
    ];
};

PIXI.GrayFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.GrayFilter.prototype.constructor = PIXI.GrayFilter;

/**
The strength of the gray. 1 will make the object black and white, 0 will make the object its normal color
@property gray
*/
Object.defineProperty(PIXI.GrayFilter.prototype, 'gray', {
    get: function() {
        return this.uniforms.gray.value;
    },
    set: function(value) {
        this.uniforms.gray.value = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * The DisplacementFilter class uses the pixel values from the specified texture (called the displacement map) to perform a displacement of an object.
 * You can use this filter to apply all manor of crazy warping effects
 * Currently the r property of the texture is used offset the x and the g propery of the texture is used to offset the y.
 * @class DisplacementFilter
 * @contructor
 * @param texture {Texture} The texture used for the displacemtent map * must be power of 2 texture at the moment
 */
PIXI.DisplacementFilter = function(texture)
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];
    texture.baseTexture._powerOf2 = true;

    // set the uniforms
    this.uniforms = {
        displacementMap: {type: 'sampler2D', value:texture},
        scale:           {type: '2f', value:{x:30, y:30}},
        offset:          {type: '2f', value:{x:0, y:0}},
        mapDimensions:   {type: '2f', value:{x:1, y:5112}},
        dimensions:   {type: '4fv', value:[0,0,0,0]}
    };

    if(texture.baseTexture.hasLoaded)
    {
        this.uniforms.mapDimensions.value.x = texture.width;
        this.uniforms.mapDimensions.value.y = texture.height;
    }
    else
    {
        this.boundLoadedFunction = this.onTextureLoaded.bind(this);

        texture.baseTexture.on('loaded', this.boundLoadedFunction);
    }

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform sampler2D displacementMap;',
        'uniform sampler2D uSampler;',
        'uniform vec2 scale;',
        'uniform vec2 offset;',
        'uniform vec4 dimensions;',
        'uniform vec2 mapDimensions;',// = vec2(256.0, 256.0);',
        // 'const vec2 textureDimensions = vec2(750.0, 750.0);',

        'void main(void) {',
        '   vec2 mapCords = vTextureCoord.xy;',
        //'   mapCords -= ;',
        '   mapCords += (dimensions.zw + offset)/ dimensions.xy ;',
        '   mapCords.y *= -1.0;',
        '   mapCords.y += 1.0;',
        '   vec2 matSample = texture2D(displacementMap, mapCords).xy;',
        '   matSample -= 0.5;',
        '   matSample *= scale;',
        '   matSample /= mapDimensions;',
        '   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x + matSample.x, vTextureCoord.y + matSample.y));',
        '   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb, 1.0);',
        '   vec2 cord = vTextureCoord;',

        //'   gl_FragColor =  texture2D(displacementMap, cord);',
     //   '   gl_FragColor = gl_FragColor;',
        '}'
    ];
};

PIXI.DisplacementFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.DisplacementFilter.prototype.constructor = PIXI.DisplacementFilter;

PIXI.DisplacementFilter.prototype.onTextureLoaded = function()
{
    this.uniforms.mapDimensions.value.x = this.uniforms.displacementMap.value.width;
    this.uniforms.mapDimensions.value.y = this.uniforms.displacementMap.value.height;

    this.uniforms.displacementMap.value.baseTexture.off('loaded', this.boundLoadedFunction);
};

/**
 * The texture used for the displacemtent map * must be power of 2 texture at the moment
 *
 * @property map
 * @type Texture
 */
Object.defineProperty(PIXI.DisplacementFilter.prototype, 'map', {
    get: function() {
        return this.uniforms.displacementMap.value;
    },
    set: function(value) {
        this.uniforms.displacementMap.value = value;
    }
});

/**
 * The multiplier used to scale the displacement result from the map calculation.
 *
 * @property scale
 * @type Point
 */
Object.defineProperty(PIXI.DisplacementFilter.prototype, 'scale', {
    get: function() {
        return this.uniforms.scale.value;
    },
    set: function(value) {
        this.uniforms.scale.value = value;
    }
});

/**
 * The offset used to move the displacement map.
 *
 * @property offset
 * @type Point
 */
Object.defineProperty(PIXI.DisplacementFilter.prototype, 'offset', {
    get: function() {
        return this.uniforms.offset.value;
    },
    set: function(value) {
        this.uniforms.offset.value = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * This filter applies a pixelate effect making display objects appear 'blocky'
 * @class PixelateFilter
 * @contructor
 */
PIXI.PixelateFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        invert: {type: '1f', value: 0},
        dimensions: {type: '4fv', value:new Float32Array([10000, 100, 10, 10])},
        pixelSize: {type: '2f', value:{x:10, y:10}}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform vec2 testDim;',
        'uniform vec4 dimensions;',
        'uniform vec2 pixelSize;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '   vec2 coord = vTextureCoord;',

        '   vec2 size = dimensions.xy/pixelSize;',

        '   vec2 color = floor( ( vTextureCoord * size ) ) / size + pixelSize/dimensions.xy * 0.5;',
        '   gl_FragColor = texture2D(uSampler, color);',
        '}'
    ];
};

PIXI.PixelateFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.PixelateFilter.prototype.constructor = PIXI.PixelateFilter;

/**
 *
 * This a point that describes the size of the blocs. x is the width of the block and y is the the height
 * @property size
 * @type Point
 */
Object.defineProperty(PIXI.PixelateFilter.prototype, 'size', {
    get: function() {
        return this.uniforms.pixelSize.value;
    },
    set: function(value) {
        this.dirty = true;
        this.uniforms.pixelSize.value = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

PIXI.BlurXFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        blur: {type: '1f', value: 1/512}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform float blur;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '   vec4 sum = vec4(0.0);',

        '   sum += texture2D(uSampler, vec2(vTextureCoord.x - 4.0*blur, vTextureCoord.y)) * 0.05;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x - 3.0*blur, vTextureCoord.y)) * 0.09;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x - 2.0*blur, vTextureCoord.y)) * 0.12;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x - blur, vTextureCoord.y)) * 0.15;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x + blur, vTextureCoord.y)) * 0.15;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x + 2.0*blur, vTextureCoord.y)) * 0.12;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x + 3.0*blur, vTextureCoord.y)) * 0.09;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x + 4.0*blur, vTextureCoord.y)) * 0.05;',

        '   gl_FragColor = sum;',
        '}'
    ];
};

PIXI.BlurXFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.BlurXFilter.prototype.constructor = PIXI.BlurXFilter;

Object.defineProperty(PIXI.BlurXFilter.prototype, 'blur', {
    get: function() {
        return this.uniforms.blur.value / (1/7000);
    },
    set: function(value) {

        this.dirty = true;
        this.uniforms.blur.value = (1/7000) * value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

PIXI.BlurYFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        blur: {type: '1f', value: 1/512}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform float blur;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '   vec4 sum = vec4(0.0);',

        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 4.0*blur)) * 0.05;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 3.0*blur)) * 0.09;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 2.0*blur)) * 0.12;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - blur)) * 0.15;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + blur)) * 0.15;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 2.0*blur)) * 0.12;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 3.0*blur)) * 0.09;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 4.0*blur)) * 0.05;',

        '   gl_FragColor = sum;',
        '}'
    ];
};

PIXI.BlurYFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.BlurYFilter.prototype.constructor = PIXI.BlurYFilter;

Object.defineProperty(PIXI.BlurYFilter.prototype, 'blur', {
    get: function() {
        return this.uniforms.blur.value / (1/7000);
    },
    set: function(value) {
        //this.padding = value;
        this.uniforms.blur.value = (1/7000) * value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * The BlurFilter applies a Gaussian blur to an object.
 * The strength of the blur can be set for x- and y-axis separately (always relative to the stage).
 *
 * @class BlurFilter
 * @contructor
 */
PIXI.BlurFilter = function()
{
    this.blurXFilter = new PIXI.BlurXFilter();
    this.blurYFilter = new PIXI.BlurYFilter();

    this.passes =[this.blurXFilter, this.blurYFilter];
};

/**
 * Sets the strength of both the blurX and blurY properties simultaneously
 *
 * @property blur
 * @type Number the strength of the blur
 * @default 2
 */
Object.defineProperty(PIXI.BlurFilter.prototype, 'blur', {
    get: function() {
        return this.blurXFilter.blur;
    },
    set: function(value) {
        this.blurXFilter.blur = this.blurYFilter.blur = value;
    }
});

/**
 * Sets the strength of the blurX property
 *
 * @property blurX
 * @type Number the strength of the blurX
 * @default 2
 */
Object.defineProperty(PIXI.BlurFilter.prototype, 'blurX', {
    get: function() {
        return this.blurXFilter.blur;
    },
    set: function(value) {
        this.blurXFilter.blur = value;
    }
});

/**
 * Sets the strength of the blurX property
 *
 * @property blurY
 * @type Number the strength of the blurY
 * @default 2
 */
Object.defineProperty(PIXI.BlurFilter.prototype, 'blurY', {
    get: function() {
        return this.blurYFilter.blur;
    },
    set: function(value) {
        this.blurYFilter.blur = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * This inverts your displayObjects colors.
 * @class InvertFilter
 * @contructor
 */
PIXI.InvertFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        invert: {type: '1f', value: 1}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform float invert;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '   gl_FragColor = texture2D(uSampler, vTextureCoord);',
        '   gl_FragColor.rgb = mix( (vec3(1)-gl_FragColor.rgb) * gl_FragColor.a, gl_FragColor.rgb, 1.0 - invert);',
        //'   gl_FragColor.rgb = gl_FragColor.rgb  * gl_FragColor.a;',
      //  '   gl_FragColor = gl_FragColor * vColor;',
        '}'
    ];
};

PIXI.InvertFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.InvertFilter.prototype.constructor = PIXI.InvertFilter;

/**
The strength of the invert. 1 will fully invert the colors, 0 will make the object its normal color
@property invert
*/
Object.defineProperty(PIXI.InvertFilter.prototype, 'invert', {
    get: function() {
        return this.uniforms.invert.value;
    },
    set: function(value) {
        this.uniforms.invert.value = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * This applies a sepia effect to your displayObjects.
 * @class SepiaFilter
 * @contructor
 */
PIXI.SepiaFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        sepia: {type: '1f', value: 1}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform float sepia;',
        'uniform sampler2D uSampler;',

        'const mat3 sepiaMatrix = mat3(0.3588, 0.7044, 0.1368, 0.2990, 0.5870, 0.1140, 0.2392, 0.4696, 0.0912);',

        'void main(void) {',
        '   gl_FragColor = texture2D(uSampler, vTextureCoord);',
        '   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb * sepiaMatrix, sepia);',
       // '   gl_FragColor = gl_FragColor * vColor;',
        '}'
    ];
};

PIXI.SepiaFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.SepiaFilter.prototype.constructor = PIXI.SepiaFilter;

/**
The strength of the sepia. 1 will apply the full sepia effect, 0 will make the object its normal color
@property sepia
*/
Object.defineProperty(PIXI.SepiaFilter.prototype, 'sepia', {
    get: function() {
        return this.uniforms.sepia.value;
    },
    set: function(value) {
        this.uniforms.sepia.value = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * This filter applies a twist effect making display objects appear twisted in the given direction
 * @class TwistFilter
 * @contructor
 */
PIXI.TwistFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        radius: {type: '1f', value:0.5},
        angle: {type: '1f', value:5},
        offset: {type: '2f', value:{x:0.5, y:0.5}}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform vec4 dimensions;',
        'uniform sampler2D uSampler;',

        'uniform float radius;',
        'uniform float angle;',
        'uniform vec2 offset;',

        'void main(void) {',
        '   vec2 coord = vTextureCoord - offset;',
        '   float distance = length(coord);',

        '   if (distance < radius) {',
        '       float ratio = (radius - distance) / radius;',
        '       float angleMod = ratio * ratio * angle;',
        '       float s = sin(angleMod);',
        '       float c = cos(angleMod);',
        '       coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);',
        '   }',

        '   gl_FragColor = texture2D(uSampler, coord+offset);',
        '}'
    ];
};

PIXI.TwistFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.TwistFilter.prototype.constructor = PIXI.TwistFilter;

/**
 *
 * This point describes the the offset of the twist
 * @property size
 * @type Point
 */
Object.defineProperty(PIXI.TwistFilter.prototype, 'offset', {
    get: function() {
        return this.uniforms.offset.value;
    },
    set: function(value) {
        this.dirty = true;
        this.uniforms.offset.value = value;
    }
});

/**
 *
 * This radius describes size of the twist
 * @property size
 * @type Number
 */
Object.defineProperty(PIXI.TwistFilter.prototype, 'radius', {
    get: function() {
        return this.uniforms.radius.value;
    },
    set: function(value) {
        this.dirty = true;
        this.uniforms.radius.value = value;
    }
});

/**
 *
 * This radius describes angle of the twist
 * @property angle
 * @type Number
 */
Object.defineProperty(PIXI.TwistFilter.prototype, 'angle', {
    get: function() {
        return this.uniforms.angle.value;
    },
    set: function(value) {
        this.dirty = true;
        this.uniforms.angle.value = value;
    }
});
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * This lowers the color depth of your image by the given amount, producing an image with a smaller palette.
 * @class ColorStepFilter
 * @contructor
 */
PIXI.ColorStepFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        step: {type: '1f', value: 5}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform sampler2D uSampler;',
        'uniform float step;',

        'void main(void) {',
        '   vec4 color = texture2D(uSampler, vTextureCoord);',
        '   color = floor(color * step) / step;',
        '   gl_FragColor = color;',
        '}'
    ];
};

PIXI.ColorStepFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.ColorStepFilter.prototype.constructor = PIXI.ColorStepFilter;

/**
The number of steps.
@property step
*/
Object.defineProperty(PIXI.ColorStepFilter.prototype, 'step', {
    get: function() {
        return this.uniforms.step.value;
    },
    set: function(value) {
        this.uniforms.step.value = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 * original filter: https://github.com/evanw/glfx.js/blob/master/src/filters/fun/dotscreen.js
 */

/**
 *
 * This filter applies a dotscreen effect making display objects appear to be made out of black and white halftone dots like an old printer
 * @class DotScreenFilter
 * @contructor
 */
PIXI.DotScreenFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        scale: {type: '1f', value:1},
        angle: {type: '1f', value:5},
        dimensions:   {type: '4fv', value:[0,0,0,0]}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform vec4 dimensions;',
        'uniform sampler2D uSampler;',

        'uniform float angle;',
        'uniform float scale;',

        'float pattern() {',
        '   float s = sin(angle), c = cos(angle);',
        '   vec2 tex = vTextureCoord * dimensions.xy;',
        '   vec2 point = vec2(',
        '       c * tex.x - s * tex.y,',
        '       s * tex.x + c * tex.y',
        '   ) * scale;',
        '   return (sin(point.x) * sin(point.y)) * 4.0;',
        '}',

        'void main() {',
        '   vec4 color = texture2D(uSampler, vTextureCoord);',
        '   float average = (color.r + color.g + color.b) / 3.0;',
        '   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);',
        '}'
    ];
};

PIXI.DotScreenFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.DotScreenFilter.prototype.constructor = PIXI.DotScreenFilter;

/**
 *
 * This describes the the scale
 * @property scale
 * @type Number
 */
Object.defineProperty(PIXI.DotScreenFilter.prototype, 'scale', {
    get: function() {
        return this.uniforms.scale.value;
    },
    set: function(value) {
        this.dirty = true;
        this.uniforms.scale.value = value;
    }
});

/**
 *
 * This radius describes angle
 * @property angle
 * @type Number
 */
Object.defineProperty(PIXI.DotScreenFilter.prototype, 'angle', {
    get: function() {
        return this.uniforms.angle.value;
    },
    set: function(value) {
        this.dirty = true;
        this.uniforms.angle.value = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

PIXI.CrossHatchFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        blur: {type: '1f', value: 1 / 512}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform float blur;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);',

        '    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);',

        '    if (lum < 1.00) {',
        '        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {',
        '            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',
        '        }',
        '    }',

        '    if (lum < 0.75) {',
        '        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {',
        '            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',
        '        }',
        '    }',

        '    if (lum < 0.50) {',
        '        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {',
        '            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',
        '        }',
        '    }',

        '    if (lum < 0.3) {',
        '        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {',
        '            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',
        '        }',
        '    }',
        '}'
    ];
};

PIXI.CrossHatchFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.CrossHatchFilter.prototype.constructor = PIXI.BlurYFilter;

Object.defineProperty(PIXI.CrossHatchFilter.prototype, 'blur', {
    get: function() {
        return this.uniforms.blur.value / (1/7000);
    },
    set: function(value) {
        //this.padding = value;
        this.uniforms.blur.value = (1/7000) * value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

PIXI.RGBSplitFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        red: {type: '2f', value: {x:20, y:20}},
        green: {type: '2f', value: {x:-20, y:20}},
        blue: {type: '2f', value: {x:20, y:-20}},
        dimensions:   {type: '4fv', value:[0,0,0,0]}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform vec2 red;',
        'uniform vec2 green;',
        'uniform vec2 blue;',
        'uniform vec4 dimensions;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/dimensions.xy).r;',
        '   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/dimensions.xy).g;',
        '   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/dimensions.xy).b;',
        '   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;',
        '}'
    ];
};

PIXI.RGBSplitFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.RGBSplitFilter.prototype.constructor = PIXI.RGBSplitFilter;

Object.defineProperty(PIXI.RGBSplitFilter.prototype, 'angle', {
    get: function() {
        return this.uniforms.blur.value / (1/7000);
    },
    set: function(value) {
        //this.padding = value;
        this.uniforms.blur.value = (1/7000) * value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

    if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = PIXI;
        }
        exports.PIXI = PIXI;
    } else if (typeof define !== 'undefined' && define.amd) {
        define(PIXI);
    } else {
        root.PIXI = PIXI;
    }
}).call(this);
},{}],"pixiapp":[function(require,module,exports){
(function() {

var PIXI;

if (typeof module !== 'undefined') {
	PIXI = require("pixi.js");
} else {
	PIXI = window.PIXI;
}
/**
 * AS3/jquery style event dispatcher. Slightly modified. The
 * jquery style on/off/trigger style of adding listeners is
 * currently the preferred one.
 *
 * The on method for adding listeners takes an extra parameter which is the
 * scope in which listeners should be called. So this:
 *
 *     object.on("event", listener, this);
 *
 * Has the same function when adding events as:
 *
 *     object.on("event", listener.bind(this));
 *
 * However, the difference is that if we use the second method it
 * will not be possible to remove the listeners later, unless
 * the closure created by bind is stored somewhere. If the
 * first method is used, we can remove the listener with:
 *
 *     object.off("event", listener, this);
 *
 * @class EventDispatcher
 * @internal
 */
function EventDispatcher() {
	this.listenerMap = {};
}

/**
 * Add event listener.
 * @method addEventListener
 */
EventDispatcher.prototype.addEventListener = function(eventType, listener, scope) {
	if (!this.listenerMap)
		this.listenerMap = {};

	if (!eventType)
		throw new Error("Event type required for event dispatcher");

	if (!listener)
		throw new Error("Listener required for event dispatcher");

	this.removeEventListener(eventType, listener, scope);

	if (!this.listenerMap.hasOwnProperty(eventType))
		this.listenerMap[eventType] = [];

	this.listenerMap[eventType].push({
		listener: listener,
		scope: scope
	});
}

/**
 * Remove event listener.
 * @method removeEventListener
 */
EventDispatcher.prototype.removeEventListener = function(eventType, listener, scope) {
	if (!this.listenerMap)
		this.listenerMap = {};

	if (!this.listenerMap.hasOwnProperty(eventType))
		return;

	var listeners = this.listenerMap[eventType];

	for (var i = 0; i < listeners.length; i++) {
		var listenerObj = listeners[i];

		if (listener == listenerObj.listener && scope == listenerObj.scope) {
			listeners.splice(i, 1);
			i--;
		}
	}

	if (!listeners.length)
		delete this.listenerMap[eventType];
}

/**
 * Dispatch event.
 * @method dispatchEvent
 */
EventDispatcher.prototype.dispatchEvent = function(event /* ... */ ) {
	if (!this.listenerMap)
		this.listenerMap = {};

	var eventType;
	var listenerParams;

	if (typeof event == "string") {
		eventType = event;
		listenerParams = Array.prototype.slice.call(arguments, 1);
	} else {
		eventType = event.type;
		event.target = this;
		listenerParams = [event];
	}

	if (!this.listenerMap.hasOwnProperty(eventType))
		return;

	for (var i in this.listenerMap[eventType]) {
		var listenerObj = this.listenerMap[eventType][i];
		listenerObj.listener.apply(listenerObj.scope, listenerParams);
	}
}

/**
 * Jquery style alias for addEventListener
 * @method on
 */
EventDispatcher.prototype.on = EventDispatcher.prototype.addEventListener;

/**
 * Jquery style alias for removeEventListener
 * @method off
 */
EventDispatcher.prototype.off = EventDispatcher.prototype.removeEventListener;

/**
 * Jquery style alias for dispatchEvent
 * @method trigger
 */
EventDispatcher.prototype.trigger = EventDispatcher.prototype.dispatchEvent;

/**
 * Make something an event dispatcher. Can be used for multiple inheritance.
 * @method init
 * @static
 */
EventDispatcher.init = function(cls) {
	cls.prototype.addEventListener = EventDispatcher.prototype.addEventListener;
	cls.prototype.removeEventListener = EventDispatcher.prototype.removeEventListener;
	cls.prototype.dispatchEvent = EventDispatcher.prototype.dispatchEvent;
	cls.prototype.on = EventDispatcher.prototype.on;
	cls.prototype.off = EventDispatcher.prototype.off;
	cls.prototype.trigger = EventDispatcher.prototype.trigger;
}

if (typeof module !== 'undefined') {
	module.exports = EventDispatcher;
}

/**
 * Keep content with a logic size inside boundaries.
 * @class ContentScaler
 * @internal
 */
function ContentScaler(content) {
	PIXI.DisplayObjectContainer.call(this);

	this.contentWidth = 100;
	this.contentHeight = 100;

	this.screenWidth = 100;
	this.screenHeight = 100;

	this.theMask = null;

	if (content)
		this.setContent(content);

	this.verticalAlign = ContentScaler.MIDDLE;
	this.horizontalAlign = ContentScaler.CENTER;
	this.scaleMode = ContentScaler.SHOW_ALL;

	this.minScale = -1;
	this.maxScale = -1;

	this.maskContentEnabled = false;
	this.maskColor = 0x000000;
}

ContentScaler.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
ContentScaler.prototype.constructor = ContentScaler;

ContentScaler.TOP = "top";
ContentScaler.MIDDLE = "middle";
ContentScaler.BOTTOM = "bottom";

ContentScaler.LEFT = "left";
ContentScaler.CENTER = "center";
ContentScaler.RIGHT = "right";

ContentScaler.NO_BORDER = "noBorder";
ContentScaler.NO_SCALE = "noScale";
ContentScaler.SHOW_ALL = "showAll";

/**
 * Should the content be masked?
 * @method setMaskContentEnabled
 */
ContentScaler.prototype.setMaskContentEnabled = function(value) {
	this.maskContentEnabled = value;
	this.updateScale();
}

/**
 * Set color of the mask.
 * @method setMaskColor
 */
ContentScaler.prototype.setMaskColor = function(value) {
	this.maskColor = value;
	this.updateScale();
}

/**
 * Set minimum value for scale.
 * @method setMinScale
 */
ContentScaler.prototype.setMinScale = function(minScale) {
	this.minScale = minScale;
	this.updateScale();
}

/**
 * Set maximum value for scale.
 * @method setMaxScale
 */
ContentScaler.prototype.setMaxScale = function(maxScale) {
	this.maxScale = maxScale;
	this.updateScale();
}

/**
 * Set content to use.
 * @method setContent
 */
ContentScaler.prototype.setContent = function(content) {
	if (this.content)
		throw new Error("Content already set.");

	this.content = content;
	this.addChild(this.content);

	if (this.theMask) {
		this.removeChild(this.theMask);
		this.theMask = null;
	}

	this.theMask = new PIXI.Graphics();
	this.addChild(this.theMask);

	this.updateScale();
}

/**
 * Set logic size of the content.
 * @method setContentSize
 */
ContentScaler.prototype.setContentSize = function(contentWidth, contentHeight) {
	this.contentWidth = contentWidth;
	this.contentHeight = contentHeight;
	this.updateScale();
}

/**
 * Set the actual screen size.
 * @method setScreenSize
 */
ContentScaler.prototype.setScreenSize = function(screenWidth, screenHeight) {
	this.screenWidth = screenWidth;
	this.screenHeight = screenHeight;
	this.updateScale();
}

/**
 * Set how the content should be aligned on the screen.
 * @method setVerticalAlign
 */
ContentScaler.prototype.setVerticalAlign = function(align) {
	this.verticalAlign = align;
	this.updateScale();
}

/**
 * Set how the content should be aligned on the screen.
 * @method setHorizontalAlign
 */
ContentScaler.prototype.setHorizontalAlign = function(align) {
	this.horizontalAlign = align;
	this.updateScale();
}

/**
 * Set scale mode.
 * @method setScaleMode
 */
ContentScaler.prototype.setScaleMode = function(scaleMode) {
	this.scaleMode = scaleMode;
	this.updateScale();
}

/**
 * Update the scaling.
 * @method updateScale
 * @private
 */
ContentScaler.prototype.updateScale = function() {
	var scale;

	if (this.scaleMode == ContentScaler.NO_SCALE) {
		scale = 1;
	} else if (this.scaleMode == ContentScaler.NO_BORDER) {
		if (this.screenWidth / this.contentWidth > this.screenHeight / this.contentHeight)
			scale = this.screenWidth / this.contentWidth;

		else
			scale = this.screenHeight / this.contentHeight;
	} else {
		if (this.screenWidth / this.contentWidth < this.screenHeight / this.contentHeight)
			scale = this.screenWidth / this.contentWidth;

		else
			scale = this.screenHeight / this.contentHeight;
	}

	if (this.minScale > 0 && scale < this.minScale)
		scale = this.minScale;

	if (this.maxScale > 0 && scale > this.maxScale)
		scale = this.maxScale;

	this.content.scale.x = scale;
	this.content.scale.y = scale;

	var scaledWidth = this.contentWidth * scale;
	var scaledHeight = this.contentHeight * scale;

	this.content.position.x = (this.screenWidth - scaledWidth) / 2;

	if (this.verticalAlign == ContentScaler.TOP)
		this.content.position.y = 0;

	else if (this.verticalAlign == ContentScaler.BOTTOM)
		this.content.position.y = this.screenHeight - scaledHeight;

	else
		this.content.position.y = (this.screenHeight - scaledHeight) / 2;

	if (this.horizontalAlign == ContentScaler.LEFT)
		this.content.position.x = 0;

	else if (this.horizontalAlign == ContentScaler.RIGHT)
		this.content.position.x = this.screenWidth - scaledWidth;

	else
		this.content.position.x = (this.screenWidth - scaledWidth) / 2;

	var r = new PIXI.Rectangle(this.content.position.x, this.content.position.y, scaledWidth, scaledHeight);
	var right = r.x + r.width;
	var bottom = r.y + r.height;

	this.theMask.clear();

	if (this.maskContentEnabled) {
		this.theMask.beginFill(this.maskColor, 1);
		this.theMask.drawRect(0, 0, this.screenWidth, r.y);
		this.theMask.drawRect(0, 0, r.x, this.screenHeight);
		this.theMask.drawRect(right, 0, this.screenWidth - right, this.screenHeight);
		this.theMask.drawRect(0, bottom, this.screenWidth, this.screenHeight - bottom);
		this.theMask.endFill();
	}
}

/**
 * Get visible rectangle.
 * @method getVisibleRect
 */
ContentScaler.prototype.getVisibleRect = function() {
	var x = -this.content.position.x / this.content.scale.x;
	var y = -this.content.position.y / this.content.scale.y;

	var width = this.screenWidth / this.content.scale.x;
	var height = this.screenHeight / this.content.scale.y;
	// this.content.position, this.content.position, this.screenWidth, this.screenHeight

	return new PIXI.Rectangle(x, y, width, height);
}
/**
 * Manages the main loop and scaling of a PIXI application.
 * The intended way of using this class is to extend it, for example:
 *
 *     var PIXI = require("pixi.js");
 *     var PixiApp = require("PixiApp");
 *     var inherits = require("inherits");
 *
 *     function MyApp() {
 *         PixiApp.call(this);
 *
 *         var t = new PIXI.Text("Hello PIXI.js!");
 *         this.addChild(t);
 *     }
 *
 *     inherits(MyApp, PixiApp);
 *
 *     new MyApp();
 * @class PixiApp
 */
function PixiApp(width, height) {
	PIXI.DisplayObjectContainer.call(this);

	this._applicationWidth = width;
	this._applicationHeight = height;
	this._backgroundColor = 0xffffff;

	setTimeout(this.onCheckReadyTimeout.bind(this), 0);

	this.contentScaler = new ContentScaler(this);
}

PixiApp.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
PixiApp.prototype.constructor = PixiApp;

EventDispatcher.init(PixiApp);

/**
 * Dispatched if the app is resized.
 * @event resize
 */

/**
 * Dispatched every frame before rendering.
 * The time is send to the listening function as parameter.
 * @event frame
 */

PixiApp.TOP = ContentScaler.TOP;
PixiApp.MIDDLE = ContentScaler.MIDDLE;
PixiApp.BOTTOM = ContentScaler.BOTTOM;

PixiApp.LEFT = ContentScaler.LEFT;
PixiApp.CENTER = ContentScaler.CENTER;
PixiApp.RIGHT = ContentScaler.RIGHT;

PixiApp.NO_BORDER = ContentScaler.NO_BORDER;
PixiApp.NO_SCALE = ContentScaler.NO_SCALE;
PixiApp.SHOW_ALL = ContentScaler.SHOW_ALL;

/**
 * Check if it's time to attach ourselves.
 * @method onCheckReadyTimeout
 * @private
 */
PixiApp.prototype.onCheckReadyTimeout = function() {
	if (this.attachedToElement)
		return;

	if (!document.body) {
		setTimeout(this.onCheckReadyTimeout.bind(this), 0);
		return;
	}

	this.attachToElement(document.body);
}

/**
 * Attach to an element in the document.
 * If this function is not called, the app will be attached
 * to entire browser window.
 * @method attachToElement
 * @param element {DOMElement} The element to attach to.
 */
PixiApp.prototype.attachToElement = function(element) {
	if (this.attachedToElement)
		throw new Error("Already attached!");

	if (typeof element == "string")
		element = document.getElementById(element);

	if (!element)
		throw new Error("That's not an element!");

	//console.log("** attaching to element, w=" + element.clientWidth + " h=" + element.clientHeight);

	this.containerElement = element;
	this.attachedToElement = true;

	var view;

	if (navigator.isCocoonJS)
		view = document.createElement('screencanvas');

	else
		view = document.createElement('canvas');

	view.style.margin = 0;
	view.style.padding = 0;

	if (this.containerElement == document.body) {
		//console.log("style: " + document.documentElement.style.height);

		view.style.position = "fixed";

		document.body.style.margin = 0;
		document.body.style.padding = 0;
		document.body.style.overflow = "hidden";

		document.body.onresize = this.onWindowResize.bind(this);
		window.onresize = this.onWindowResize.bind(this);
	}

	this.renderer = new PIXI.autoDetectRenderer(this.getElementWidth(), this.getElementHeight(), view);
	this.containerElement.appendChild(this.renderer.view);

	this.stage = new PIXI.Stage(this._backgroundColor);

	this.updateContentScaler();
	this.stage.addChild(this.contentScaler);

	this.renderer.render(this.stage);
	this.sizeDirty = false;

	window.requestAnimationFrame(this.onAnimationFrame.bind(this));
	this.trigger("resize");

	//console.log("attached...");
}

/**
 * Update the content scaler.
 * @method updateContentScaler
 * @private
 */
PixiApp.prototype.updateContentScaler = function() {
	this.contentScaler.setContentSize(this._applicationWidth, this._applicationHeight);
	this.contentScaler.setScreenSize(this.getElementWidth(), this.getElementHeight());
}

/**
 * Animation frame. Render ourselfs.
 * @method onAnimationFrame
 * @private
 */
PixiApp.prototype.onAnimationFrame = function(time) {
	//console.log("render");

	if (this.sizeDirty) {
		this.updateContentScaler();
		this.renderer.resize(this.getElementWidth(), this.getElementHeight());
		this.sizeDirty = false;
	}

	this.trigger("frame", time);

	this.renderer.render(this.stage);
	//TWEEN.update(time);

	window.requestAnimationFrame(this.onAnimationFrame.bind(this));
}

/**
 * Handle window resize.
 * @method onWindowResize
 * @private
 */
PixiApp.prototype.onWindowResize = function() {
	this.sizeDirty = true;
	this.trigger("resize");
}

/**
 * Get height of the element that we are attached to.
 * @method getElementHeight
 * @private
 */
PixiApp.prototype.getElementHeight = function() {
	if (this.containerElement == document.body)
		return window.innerHeight;

	return this.containerElement.clientHeight;
}

/**
 * Get height of the element that we are attached to.
 * @method getElementWidth
 * @private
 */
PixiApp.prototype.getElementWidth = function() {
	if (this.containerElement == document.body)
		return window.innerWidth;

	return this.containerElement.clientWidth;
}

/**
 * The logic width of the application.
 * @property applicationWidth
 */
Object.defineProperty(PixiApp.prototype, 'applicationWidth', {
	get: function() {
		return this._applicationWidth;
	},
	set: function(value) {
		this._applicationWidth = value;
		this.sizeDirty = true;
	}
});

/**
 * The logic height of the application.
 * @property applicationHeight
 */
Object.defineProperty(PixiApp.prototype, 'applicationHeight', {
	get: function() {
		return this._applicationHeight;
	},
	set: function(value) {
		this._applicationHeight = value;
		this.sizeDirty = true;
	}
});

/**
 * How the application should be vertically aligned in the window.
 * @property verticalAlign
 */
Object.defineProperty(PixiApp.prototype, "verticalAlign", {
	get: function() {
		return this.contentScaler.verticalAlign;
	},
	set: function(value) {
		this.contentScaler.setVerticalAlign(value)
	}
});

/**
 * How the application should be horizontally aligned in the window.
 * @property horizontalAlign
 */
Object.defineProperty(PixiApp.prototype, "horizontalAlign", {
	get: function() {
		return this.contentScaler.horizontalAlign;
	},
	set: function(value) {
		this.contentScaler.setHorizontalAlign(value)
	}
});

/**
 * How should the application be scaled to fit the window?
 * Available vaues are:
 * <ul>
 *   <li>
 *     `PixiApp.SHOW_ALL` - Ensure that the whole application as defined by
 *     `applicationWidth` and `applicationHeight` is visible on the screen.
 *   </li>
 *   <li>
 *     `PixiApp.NO_BORDER` - Show as much as possible of the application,
 *     but scale it so that there will be no border.
 *   </li>
 *   <li>
 *     `PixiApp.NO_SCALE` - Don't scale the application at all.
 *   </li>
 * </ul>
 * @property scaleMode
 */
Object.defineProperty(PixiApp.prototype, "scaleMode", {
	get: function() {
		return this.contentScaler.scaleMode;
	},
	set: function(value) {
		this.contentScaler.setScaleMode(value)
	}
});

/**
 * Get or set the minimum allowed scale value.
 * @property minScale
 */
Object.defineProperty(PixiApp.prototype, "minScale", {
	get: function() {
		return this.contentScaler.minScale;
	},
	set: function(value) {
		this.contentScaler.setMinScale(value)
	}
});

/**
 * Get or set the maximum allowed scale value.
 * @property minScale
 */
Object.defineProperty(PixiApp.prototype, "maxScale", {
	get: function() {
		return this.contentScaler.maxScale;
	},
	set: function(value) {
		this.contentScaler.setMaxScale(value)
	}
});

/**
 * Should there be a letterbox matte around the content? I.e.
 * should the content outside the application area be masked
 * away?
 * @property matte
 */
Object.defineProperty(PixiApp.prototype, "matte", {
	get: function() {
		return this.contentScaler.maskContentEnabled
	},
	set: function(value) {
		this.contentScaler.setMaskContentEnabled(value);
	}
});

/**
 * The color of the letterbox matte. This has effect only if the 
 * letter box matte is enabled using the matte property.
 * @property matteColor
 */
Object.defineProperty(PixiApp.prototype, "matteColor", {
	get: function() {
		return this.contentScaler.maskColor;
	},
	set: function(value) {
		this.contentScaler.setMaskColor(value);
	}
});

/**
 * Gets the rectangle on the screen that is currently visible.
 * The rectangle is represented in application coordinates.
 * @property visibleRect
 */
Object.defineProperty(PixiApp.prototype, "visibleRect", {
	get: function() {
		if (this.sizeDirty) {
			this.updateContentScaler();
			this.renderer.resize(this.getElementWidth(), this.getElementHeight());
			this.sizeDirty = false;
		}

		return this.contentScaler.getVisibleRect();
	},
});

/**
 * The background color for the application.
 * Default is 0xffffff, i.e. white.
 * @property backgroundColor
 */
Object.defineProperty(PixiApp.prototype, "backgroundColor", {
	get: function() {
		return this._backgroundColor;
	},
	set: function(value) {
		this._backgroundColor = value;
		if (this.stage)
			this.stage.setBackgroundColor(this._backgroundColor);
	}
});
if (typeof module !== 'undefined') {
	module.exports = PixiApp;
} else {
	window.PixiApp = PixiApp;
}

}).call(this);
},{"pixi.js":"pixi.js"}],"tinp":[function(require,module,exports){
(function (process){
/**
 * A subset of Promises/A+.
 * @class Thenable
 */
function Thenable() {
	if (!(this instanceof Thenable))
		return new Thenable();

	this.decided = false;
	this.handlersUsed = false;
}

/**
 * Then.
 * @method resolve
 */
Thenable.prototype.then = function(resolutionHandler, rejectionHandler) {
	if (this.handlersUsed)
		throw new Error("Handlers already registered or called.");

	this.handlersUsed = true;
	this.resolutionHandler = resolutionHandler;
	this.rejectionHandler = rejectionHandler;
}

/**
 * Resolve.
 * @method resolve
 */
Thenable.prototype.resolve = function(result) {
	if (this.decided)
		throw new Error("Already decided.");

	this.decided = true;
	process.nextTick(this.callHandler.bind(this, true, result));
}

/**
 * Reject.
 * @method resolve
 */
Thenable.prototype.reject = function(reason) {
	if (this.decided)
		throw new Error("Already decided.");

	this.decided = true;
	process.nextTick(this.callHandler.bind(this, false, reason));
}

/**
 * Call handler.
 * @method callHandler
 * @private
 */
Thenable.prototype.callHandler = function(resolved, parameter) {
	this.handlersUsed = true;

	var handler;

	if (resolved)
		handler = this.resolutionHandler;

	else
		handler = this.rejectionHandler;

	//console.log("in callHandler, handler=" + handler);

	if (handler) {
		try {
			handler(parameter);
		} catch (e) {
			console.error("Unhandled: " + e);
			console.log(e.stack);
			throw e;
		}
	}
}

/**
 * Return a resolved thenable.
 * @method resolved
 */
Thenable.resolved = function(parameter) {
	var t = new Thenable();
	t.resolve(parameter);
	return t;
}

/**
 * Return a rejected thenable.
 * @method rejected
 */
Thenable.rejected = function(parameter) {
	var t = new Thenable();
	t.reject(parameter);
	return t;
}

/**
 * Wait for all to resolve or any to reject.
 * @method all
 */
Thenable.all = function( /* ... */ ) {
	var thenable = new Thenable();
	var i;
	var thenables = [];
	var decided = false;
	var resolvedCount = 0;

	for (i = 0; i < arguments.length; i++)
		thenables = thenables.concat(arguments[i]);

	function onResolved() {
		resolvedCount++;

		if (!decided && resolvedCount >= thenables.length) {
			decided = true;
			thenable.resolve();
		}
	}

	function onRejected(e) {
		if (!decided) {
			decided = true;
			thenable.reject(e);
		}
	}

	for (i = 0; i < thenables.length; i++) {
		thenables[i].then(onResolved, onRejected);
	}

	return thenable;
}

/**
 * Wait for any to resolve or all to reject.
 * @method all
 */
Thenable.race = function( /* ... */ ) {
	var thenable = new Thenable();
	var i;
	var thenables = [];
	var decided = false;
	var resolvedCount = 0;

	for (i = 0; i < arguments.length; i++)
		thenables = thenables.concat(arguments[i]);

	function onRejected() {
		resolvedCount++;

		if (!decided && resolvedCount >= thenables.length) {
			decided = true;
			thenable.reject();
		}
	}

	function onResolved(r) {
		if (!decided) {
			decided = true;
			thenable.resolve(r);
		}
	}

	for (i = 0; i < thenables.length; i++) {
		thenables[i].then(onResolved, onRejected);
	}

	return thenable;
}

/**
 * Create a resolved Thenable.
 * @method resolved
 */
Thenable.resolved = function(result) {
	var t = new Thenable;
	t.resolve(result);

	return t;
}

/**
 * Create a rejected Thenable.
 * @method rejected
 */
Thenable.rejected = function(reason) {
	var t = new Thenable;
	t.reject(reason);

	return t;
}

module.exports = Thenable;
}).call(this,require('_process'))

},{"_process":1}]},{},[])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwibm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGl0ZXh0aW5wdXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGl4aXRleHRpbnB1dC9zcmMvUGl4aVRleHRJbnB1dC5qcyIsIm5vZGVfbW9kdWxlcy90d2Vlbi5qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy95YWVkL3NyYy9FdmVudERpc3BhdGNoZXIuanMiLCJzcmMvY2xpZW50L2NvbnRyb2xsZXIvSW50ZXJmYWNlQ29udHJvbGxlci5qcyIsInNyYy9jbGllbnQvY29udHJvbGxlci9NZXNzYWdlU2VxdWVuY2VJdGVtLmpzIiwic3JjL2NsaWVudC9jb250cm9sbGVyL01lc3NhZ2VTZXF1ZW5jZXIuanMiLCJzcmMvY2xpZW50L2NvbnRyb2xsZXIvTmV0UG9rZXJDbGllbnRDb250cm9sbGVyLmpzIiwic3JjL2NsaWVudC9jb250cm9sbGVyL1RhYmxlQ29udHJvbGxlci5qcyIsInNyYy9jbGllbnQvcmVzb3VyY2VzL0RlZmF1bHRTa2luLmpzIiwic3JjL2NsaWVudC9yZXNvdXJjZXMvVmlld0NvbmZpZy5qcyIsInNyYy9jbGllbnQvdmlldy9CaWdCdXR0b24uanMiLCJzcmMvY2xpZW50L3ZpZXcvQnV0dG9uc1ZpZXcuanMiLCJzcmMvY2xpZW50L3ZpZXcvQ2FyZEZyb250Vmlldy5qcyIsInNyYy9jbGllbnQvdmlldy9DYXJkVmlldy5qcyIsInNyYy9jbGllbnQvdmlldy9DaGF0Vmlldy5qcyIsInNyYy9jbGllbnQvdmlldy9DaGlwc1ZpZXcuanMiLCJzcmMvY2xpZW50L3ZpZXcvRGVhbGVyQnV0dG9uVmlldy5qcyIsInNyYy9jbGllbnQvdmlldy9EaWFsb2dCdXR0b24uanMiLCJzcmMvY2xpZW50L3ZpZXcvRGlhbG9nVmlldy5qcyIsInNyYy9jbGllbnQvdmlldy9Mb2FkaW5nU2NyZWVuLmpzIiwic3JjL2NsaWVudC92aWV3L05ldFBva2VyQ2xpZW50Vmlldy5qcyIsInNyYy9jbGllbnQvdmlldy9Qb3RWaWV3LmpzIiwic3JjL2NsaWVudC92aWV3L1ByZXNldEJ1dHRvbi5qcyIsInNyYy9jbGllbnQvdmlldy9QcmVzZXRCdXR0b25zVmlldy5qcyIsInNyYy9jbGllbnQvdmlldy9SYWlzZVNob3J0Y3V0QnV0dG9uLmpzIiwic3JjL2NsaWVudC92aWV3L1NlYXRWaWV3LmpzIiwic3JjL2NsaWVudC92aWV3L1NldHRpbmdzQ2hlY2tib3guanMiLCJzcmMvY2xpZW50L3ZpZXcvU2V0dGluZ3NWaWV3LmpzIiwic3JjL2NsaWVudC92aWV3L1RhYmxlSW5mb1ZpZXcuanMiLCJzcmMvY2xpZW50L3ZpZXcvVGltZXJWaWV3LmpzIiwic3JjL3Byb3RvL1Byb3RvQ29ubmVjdGlvbi5qcyIsInNyYy9wcm90by9kYXRhL0J1dHRvbkRhdGEuanMiLCJzcmMvcHJvdG8vZGF0YS9DYXJkRGF0YS5qcyIsInNyYy9wcm90by9tZXNzYWdlcy9BY3Rpb25NZXNzYWdlLmpzIiwic3JjL3Byb3RvL21lc3NhZ2VzL0JldE1lc3NhZ2UuanMiLCJzcmMvcHJvdG8vbWVzc2FnZXMvQmV0c1RvUG90TWVzc2FnZS5qcyIsInNyYy9wcm90by9tZXNzYWdlcy9CdXR0b25DbGlja01lc3NhZ2UuanMiLCJzcmMvcHJvdG8vbWVzc2FnZXMvQnV0dG9uc01lc3NhZ2UuanMiLCJzcmMvcHJvdG8vbWVzc2FnZXMvQ2hhdE1lc3NhZ2UuanMiLCJzcmMvcHJvdG8vbWVzc2FnZXMvQ2hlY2tib3hNZXNzYWdlLmpzIiwic3JjL3Byb3RvL21lc3NhZ2VzL0NsZWFyTWVzc2FnZS5qcyIsInNyYy9wcm90by9tZXNzYWdlcy9Db21tdW5pdHlDYXJkc01lc3NhZ2UuanMiLCJzcmMvcHJvdG8vbWVzc2FnZXMvRGVhbGVyQnV0dG9uTWVzc2FnZS5qcyIsInNyYy9wcm90by9tZXNzYWdlcy9EZWxheU1lc3NhZ2UuanMiLCJzcmMvcHJvdG8vbWVzc2FnZXMvRmFkZVRhYmxlTWVzc2FnZS5qcyIsInNyYy9wcm90by9tZXNzYWdlcy9Gb2xkQ2FyZHNNZXNzYWdlLmpzIiwic3JjL3Byb3RvL21lc3NhZ2VzL0hhbmRJbmZvTWVzc2FnZS5qcyIsInNyYy9wcm90by9tZXNzYWdlcy9Jbml0TWVzc2FnZS5qcyIsInNyYy9wcm90by9tZXNzYWdlcy9JbnRlcmZhY2VTdGF0ZU1lc3NhZ2UuanMiLCJzcmMvcHJvdG8vbWVzc2FnZXMvUGF5T3V0TWVzc2FnZS5qcyIsInNyYy9wcm90by9tZXNzYWdlcy9Qb2NrZXRDYXJkc01lc3NhZ2UuanMiLCJzcmMvcHJvdG8vbWVzc2FnZXMvUG90TWVzc2FnZS5qcyIsInNyYy9wcm90by9tZXNzYWdlcy9QcmVUb3VybmFtZW50SW5mb01lc3NhZ2UuanMiLCJzcmMvcHJvdG8vbWVzc2FnZXMvUHJlc2V0QnV0dG9uQ2xpY2tNZXNzYWdlLmpzIiwic3JjL3Byb3RvL21lc3NhZ2VzL1ByZXNldEJ1dHRvbnNNZXNzYWdlLmpzIiwic3JjL3Byb3RvL21lc3NhZ2VzL1NlYXRDbGlja01lc3NhZ2UuanMiLCJzcmMvcHJvdG8vbWVzc2FnZXMvU2VhdEluZm9NZXNzYWdlLmpzIiwic3JjL3Byb3RvL21lc3NhZ2VzL1Nob3dEaWFsb2dNZXNzYWdlLmpzIiwic3JjL3Byb3RvL21lc3NhZ2VzL1N0YXRlQ29tcGxldGVNZXNzYWdlLmpzIiwic3JjL3Byb3RvL21lc3NhZ2VzL1RhYmxlQnV0dG9uQ2xpY2tNZXNzYWdlLmpzIiwic3JjL3Byb3RvL21lc3NhZ2VzL1RhYmxlQnV0dG9uc01lc3NhZ2UuanMiLCJzcmMvcHJvdG8vbWVzc2FnZXMvVGFibGVJbmZvTWVzc2FnZS5qcyIsInNyYy9wcm90by9tZXNzYWdlcy9UZXN0Q2FzZVJlcXVlc3RNZXNzYWdlLmpzIiwic3JjL3Byb3RvL21lc3NhZ2VzL1RpbWVyTWVzc2FnZS5qcyIsInNyYy9wcm90by9tZXNzYWdlcy9Ub3VybmFtZW50UmVzdWx0TWVzc2FnZS5qcyIsInNyYy91dGlscy9DaGVja2JveC5qcyIsInNyYy91dGlscy9NZXNzYWdlUmVxdWVzdENvbm5lY3Rpb24uanMiLCJzcmMvdXRpbHMvTWVzc2FnZVdlYlNvY2tldENvbm5lY3Rpb24uanMiLCJzcmMvdXRpbHMvTW91c2VPdmVyR3JvdXAuanMiLCJzcmMvdXRpbHMvUG9pbnQuanMiLCJzcmMvdXRpbHMvU2VxdWVuY2VyLmpzIiwic3JjL3V0aWxzL1NsaWRlci5qcyIsInNyYy91dGlscy9VcmxVdGlsLmpzIiwic3JjL3V0aWxzL0J1dHRvbiIsInNyYy91dGlscy9Db3VudGRvd25UZXh0Iiwic3JjL3V0aWxzL0dyYWRpZW50Iiwic3JjL3V0aWxzL0h0dHBSZXF1ZXN0Iiwic3JjL2NsaWVudC9hcHAvTmV0UG9rZXJDbGllbnQiLCJzcmMvdXRpbHMvTmluZVNsaWNlIiwic3JjL2NsaWVudC9yZXNvdXJjZXMvUmVzb3VyY2VzIiwicGl4aS5qcyIsInBpeGlhcHAiLCJub2RlX21vZHVsZXMvdGlucC9zcmMvVGhlbmFibGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25zQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3B6ZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDandCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjMuMiBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS4zLjInLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiBpc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIWlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnkgY29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgdGhlIHBhcnQgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhcyBub24gQVNDSUkgY2hhcmFjdGVycy4gSS5lLiBpdCBkb3NlbnQgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBpbiBBU0NJSS5cbiAgICAgIHZhciBkb21haW5BcnJheSA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgIHZhciBuZXdPdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9tYWluQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHMgPSBkb21haW5BcnJheVtpXTtcbiAgICAgICAgbmV3T3V0LnB1c2gocy5tYXRjaCgvW15BLVphLXowLTlfLV0vKSA/XG4gICAgICAgICAgICAneG4tLScgKyBwdW55Y29kZS5lbmNvZGUocykgOiBzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBuZXdPdXQuam9pbignLicpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAoaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKGlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICBPYmplY3Qua2V5cyh0aGlzKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICByZXN1bHRba10gPSB0aGlzW2tdO1xuICB9LCB0aGlzKTtcblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIE9iamVjdC5rZXlzKHJlbGF0aXZlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIGlmIChrICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICB9KTtcblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICBPYmplY3Qua2V5cyhyZWxhdGl2ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfSk7XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCFpc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCFpc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0KSAmJiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8XG4gICAgICBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCFpc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiAgYXJnID09IG51bGw7XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsInZhciBQaXhpVGV4dElucHV0ID0gcmVxdWlyZShcIi4vc3JjL1BpeGlUZXh0SW5wdXRcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gUGl4aVRleHRJbnB1dDsiLCJpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0UElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xufVxuXG4vKipcbiAqIFRleHQgaW5wdXQgZmllbGQgZm9yIHBpeGkuanMuXG4gKiBBIHNpbXBsZSBleGFtcGxlOlxuICpcbiAqICAgICAvLyBXZSBuZWVkIGEgY29udGFpbmVyXG4gKiAgICAgdmFyIGNvbnRhaW5lciA9IG5ldyBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIoKTtcbiAqXG4gKiAgICAgLy8gU2FtZSBzdHlsZSBvcHRpb25zIGFzIFBJWEkuVGV4dFxuICogICAgIHZhciBzdHlsZT17IC4uLiB9O1xuICpcbiAqICAgICB2YXIgaW5wdXRGaWVsZCA9IG5ldyBQaXhpVGV4dElucHV0KFwiaGVsbG9cIixzdHlsZSk7XG4gKiAgICAgY29udGFpbmVyLmFkZENoaWxkKGlucHV0RmllbGQpO1xuICpcbiAqIFRoZSBzdHlsZSBkZWZpbml0aW9ucyBhY2NlcHRlZCBieSB0aGUgY29uc3RydWN0b3IgYXJlIHRoZSBzYW1lIGFzIHRob3NlIGFjY2VwdGVkIGJ5XG4gKiBbUElYSS5UZXh0XShodHRwOi8vd3d3Lmdvb2Rib3lkaWdpdGFsLmNvbS9waXhpanMvZG9jcy9jbGFzc2VzL1RleHQuaHRtbCkuXG4gKiBAY2xhc3MgUGl4aVRleHRJbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gW3RleHRdIFRoZSBpbml0aWFsIHRleHQuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0eWxlXSBTdHlsZSBkZWZpbml0aW9uLCBzYW1lIGFzIGZvciBQSVhJLlRleHRcbiAqL1xuZnVuY3Rpb24gUGl4aVRleHRJbnB1dCh0ZXh0LCBzdHlsZSkge1xuXHRQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIuY2FsbCh0aGlzKTtcblxuXHRpZiAoIXRleHQpXG5cdFx0dGV4dCA9IFwiXCI7XG5cblx0dGV4dCA9IHRleHQudG9TdHJpbmcoKTtcblxuXHRpZiAoc3R5bGUgJiYgc3R5bGUud29yZFdyYXApXG5cdFx0dGhyb3cgXCJ3b3JkV3JhcCBpcyBub3Qgc3VwcG9ydGVkIGZvciBpbnB1dCBmaWVsZHNcIjtcblxuXHR0aGlzLl90ZXh0ID0gdGV4dDtcblxuXHR0aGlzLmxvY2FsV2lkdGggPSAxMDA7XG5cdHRoaXMuX2JhY2tncm91bmRDb2xvciA9IDB4ZmZmZmZmO1xuXHR0aGlzLl9jYXJldENvbG9yID0gMHgwMDAwMDA7XG5cdHRoaXMuX2JhY2tncm91bmQgPSB0cnVlO1xuXG5cdHRoaXMuc3R5bGUgPSBzdHlsZTtcblx0dGhpcy50ZXh0RmllbGQgPSBuZXcgUElYSS5UZXh0KHRoaXMuX3RleHQsIHN0eWxlKTtcblxuXHR0aGlzLmxvY2FsSGVpZ2h0ID1cblx0XHR0aGlzLnRleHRGaWVsZC5kZXRlcm1pbmVGb250SGVpZ2h0KCdmb250OiAnICsgdGhpcy50ZXh0RmllbGQuc3R5bGUuZm9udCArICc7JykgK1xuXHRcdHRoaXMudGV4dEZpZWxkLnN0eWxlLnN0cm9rZVRoaWNrbmVzcztcblx0dGhpcy5iYWNrZ3JvdW5kR3JhcGhpY3MgPSBuZXcgUElYSS5HcmFwaGljcygpO1xuXHR0aGlzLnRleHRGaWVsZE1hc2sgPSBuZXcgUElYSS5HcmFwaGljcygpO1xuXHR0aGlzLmNhcmV0ID0gbmV3IFBJWEkuR3JhcGhpY3MoKTtcblx0dGhpcy5kcmF3RWxlbWVudHMoKTtcblxuXHR0aGlzLmFkZENoaWxkKHRoaXMuYmFja2dyb3VuZEdyYXBoaWNzKTtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLnRleHRGaWVsZCk7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5jYXJldCk7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy50ZXh0RmllbGRNYXNrKTtcblxuXHR0aGlzLnNjcm9sbEluZGV4ID0gMDtcblx0dGhpcy5fY2FyZXRJbmRleCA9IDA7XG5cdHRoaXMuY2FyZXRGbGFzaEludGVydmFsID0gbnVsbDtcblx0dGhpcy5ibHVyKCk7XG5cdHRoaXMudXBkYXRlQ2FyZXRQb3NpdGlvbigpO1xuXG5cdHRoaXMuYmFja2dyb3VuZEdyYXBoaWNzLmludGVyYWN0aXZlID0gdHJ1ZTtcblx0dGhpcy5iYWNrZ3JvdW5kR3JhcGhpY3MuYnV0dG9uTW9kZSA9IHRydWU7XG5cdHRoaXMuYmFja2dyb3VuZEdyYXBoaWNzLmRlZmF1bHRDdXJzb3IgPSBcInRleHRcIjtcblxuXHR0aGlzLmJhY2tncm91bmRHcmFwaGljcy5tb3VzZWRvd24gPSB0aGlzLm9uQmFja2dyb3VuZE1vdXNlRG93bi5iaW5kKHRoaXMpO1xuXHR0aGlzLmtleUV2ZW50Q2xvc3VyZSA9IHRoaXMub25LZXlFdmVudC5iaW5kKHRoaXMpO1xuXHR0aGlzLndpbmRvd0JsdXJDbG9zdXJlID0gdGhpcy5vbldpbmRvd0JsdXIuYmluZCh0aGlzKTtcblx0dGhpcy5kb2N1bWVudE1vdXNlRG93bkNsb3N1cmUgPSB0aGlzLm9uRG9jdW1lbnRNb3VzZURvd24uYmluZCh0aGlzKTtcblx0dGhpcy5pc0ZvY3VzQ2xpY2sgPSBmYWxzZTtcblxuXHR0aGlzLnVwZGF0ZVRleHQoKTtcblxuXHR0aGlzLnRleHRGaWVsZC5tYXNrID0gdGhpcy50ZXh0RmllbGRNYXNrO1xuXG5cdHRoaXMua2V5cHJlc3MgPSBudWxsO1xuXHR0aGlzLmtleWRvd24gPSBudWxsO1xuXHR0aGlzLmNoYW5nZSA9IG51bGw7XG59XG5cblBpeGlUZXh0SW5wdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlKTtcblBpeGlUZXh0SW5wdXQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGl4aVRleHRJbnB1dDtcblxuLyoqXG4gKiBTb21lb25lIGNsaWNrZWQuXG4gKiBAbWV0aG9kIG9uQmFja2dyb3VuZE1vdXNlRG93blxuICogQHByaXZhdGVcbiAqL1xuUGl4aVRleHRJbnB1dC5wcm90b3R5cGUub25CYWNrZ3JvdW5kTW91c2VEb3duID0gZnVuY3Rpb24oZSkge1xuXHR2YXIgeCA9IGUuZ2V0TG9jYWxQb3NpdGlvbih0aGlzKS54O1xuXHR0aGlzLl9jYXJldEluZGV4ID0gdGhpcy5nZXRDYXJldEluZGV4QnlDb29yZCh4KTtcblx0dGhpcy51cGRhdGVDYXJldFBvc2l0aW9uKCk7XG5cblx0dGhpcy5mb2N1cygpO1xuXG5cdHRoaXMuaXNGb2N1c0NsaWNrID0gdHJ1ZTtcblx0dmFyIHNjb3BlID0gdGhpcztcblx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRzY29wZS5pc0ZvY3VzQ2xpY2sgPSBmYWxzZTtcblx0fSwgMCk7XG59XG5cbi8qKlxuICogRm9jdXMgdGhpcyBpbnB1dCBmaWVsZC5cbiAqIEBtZXRob2QgZm9jdXNcbiAqL1xuUGl4aVRleHRJbnB1dC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5ibHVyKCk7XG5cblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5rZXlFdmVudENsb3N1cmUpO1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5cHJlc3NcIiwgdGhpcy5rZXlFdmVudENsb3N1cmUpO1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuZG9jdW1lbnRNb3VzZURvd25DbG9zdXJlKTtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMud2luZG93Qmx1ckNsb3N1cmUpO1xuXG5cdHRoaXMuc2hvd0NhcmV0KCk7XG59XG5cbi8qKlxuICogSGFuZGxlIGtleSBldmVudC5cbiAqIEBtZXRob2Qgb25LZXlFdmVudFxuICogQHByaXZhdGVcbiAqL1xuUGl4aVRleHRJbnB1dC5wcm90b3R5cGUub25LZXlFdmVudCA9IGZ1bmN0aW9uKGUpIHtcblx0Lypjb25zb2xlLmxvZyhcImtleSBldmVudFwiKTtcblx0Y29uc29sZS5sb2coZSk7Ki9cblxuXHRpZiAoZS50eXBlID09IFwia2V5cHJlc3NcIikge1xuXHRcdGlmIChlLmNoYXJDb2RlIDwgMzIpXG5cdFx0XHRyZXR1cm47XG5cblx0XHR0aGlzLl90ZXh0ID1cblx0XHRcdHRoaXMuX3RleHQuc3Vic3RyaW5nKDAsIHRoaXMuX2NhcmV0SW5kZXgpICtcblx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoZS5jaGFyQ29kZSkgK1xuXHRcdFx0dGhpcy5fdGV4dC5zdWJzdHJpbmcodGhpcy5fY2FyZXRJbmRleCk7XG5cblx0XHR0aGlzLl9jYXJldEluZGV4Kys7XG5cdFx0dGhpcy5lbnN1cmVDYXJldEluVmlldygpO1xuXHRcdHRoaXMuc2hvd0NhcmV0KCk7XG5cdFx0dGhpcy51cGRhdGVUZXh0KCk7XG5cdFx0dGhpcy50cmlnZ2VyKHRoaXMua2V5cHJlc3MsIGUpO1xuXHRcdHRoaXMudHJpZ2dlcih0aGlzLmNoYW5nZSk7XG5cdH1cblxuXHRpZiAoZS50eXBlID09IFwia2V5ZG93blwiKSB7XG5cdFx0c3dpdGNoIChlLmtleUNvZGUpIHtcblx0XHRcdGNhc2UgODpcblx0XHRcdFx0aWYgKHRoaXMuX2NhcmV0SW5kZXggPiAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGV4dCA9XG5cdFx0XHRcdFx0XHR0aGlzLl90ZXh0LnN1YnN0cmluZygwLCB0aGlzLl9jYXJldEluZGV4IC0gMSkgK1xuXHRcdFx0XHRcdFx0dGhpcy5fdGV4dC5zdWJzdHJpbmcodGhpcy5fY2FyZXRJbmRleCk7XG5cblx0XHRcdFx0XHR0aGlzLl9jYXJldEluZGV4LS07XG5cdFx0XHRcdFx0dGhpcy5lbnN1cmVDYXJldEluVmlldygpO1xuXHRcdFx0XHRcdHRoaXMuc2hvd0NhcmV0KCk7XG5cdFx0XHRcdFx0dGhpcy51cGRhdGVUZXh0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIodGhpcy5jaGFuZ2UpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSA0Njpcblx0XHRcdFx0dGhpcy5fdGV4dCA9XG5cdFx0XHRcdFx0dGhpcy5fdGV4dC5zdWJzdHJpbmcoMCwgdGhpcy5fY2FyZXRJbmRleCkgK1xuXHRcdFx0XHRcdHRoaXMuX3RleHQuc3Vic3RyaW5nKHRoaXMuX2NhcmV0SW5kZXggKyAxKTtcblxuXHRcdFx0XHR0aGlzLmVuc3VyZUNhcmV0SW5WaWV3KCk7XG5cdFx0XHRcdHRoaXMudXBkYXRlQ2FyZXRQb3NpdGlvbigpO1xuXHRcdFx0XHR0aGlzLnNob3dDYXJldCgpO1xuXHRcdFx0XHR0aGlzLnVwZGF0ZVRleHQoKTtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIodGhpcy5jaGFuZ2UpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAzOTpcblx0XHRcdFx0dGhpcy5fY2FyZXRJbmRleCsrO1xuXHRcdFx0XHRpZiAodGhpcy5fY2FyZXRJbmRleCA+IHRoaXMuX3RleHQubGVuZ3RoKVxuXHRcdFx0XHRcdHRoaXMuX2NhcmV0SW5kZXggPSB0aGlzLl90ZXh0Lmxlbmd0aDtcblxuXHRcdFx0XHR0aGlzLmVuc3VyZUNhcmV0SW5WaWV3KCk7XG5cdFx0XHRcdHRoaXMudXBkYXRlQ2FyZXRQb3NpdGlvbigpO1xuXHRcdFx0XHR0aGlzLnNob3dDYXJldCgpO1xuXHRcdFx0XHR0aGlzLnVwZGF0ZVRleHQoKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgMzc6XG5cdFx0XHRcdHRoaXMuX2NhcmV0SW5kZXgtLTtcblx0XHRcdFx0aWYgKHRoaXMuX2NhcmV0SW5kZXggPCAwKVxuXHRcdFx0XHRcdHRoaXMuX2NhcmV0SW5kZXggPSAwO1xuXG5cdFx0XHRcdHRoaXMuZW5zdXJlQ2FyZXRJblZpZXcoKTtcblx0XHRcdFx0dGhpcy51cGRhdGVDYXJldFBvc2l0aW9uKCk7XG5cdFx0XHRcdHRoaXMuc2hvd0NhcmV0KCk7XG5cdFx0XHRcdHRoaXMudXBkYXRlVGV4dCgpO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHR0aGlzLnRyaWdnZXIodGhpcy5rZXlkb3duLCBlKTtcblx0fVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGUgY2FyZXQgaXMgbm90IG91dHNpZGUgdGhlIGJvdW5kcy5cbiAqIEBtZXRob2QgZW5zdXJlQ2FyZXRJblZpZXdcbiAqIEBwcml2YXRlXG4gKi9cblBpeGlUZXh0SW5wdXQucHJvdG90eXBlLmVuc3VyZUNhcmV0SW5WaWV3ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMudXBkYXRlQ2FyZXRQb3NpdGlvbigpO1xuXG5cdHdoaWxlICh0aGlzLmNhcmV0LnBvc2l0aW9uLnggPj0gdGhpcy5sb2NhbFdpZHRoIC0gMSkge1xuXHRcdHRoaXMuc2Nyb2xsSW5kZXgrKztcblx0XHR0aGlzLnVwZGF0ZUNhcmV0UG9zaXRpb24oKTtcblx0fVxuXG5cdHdoaWxlICh0aGlzLmNhcmV0LnBvc2l0aW9uLnggPCAwKSB7XG5cdFx0dGhpcy5zY3JvbGxJbmRleCAtPSAyO1xuXHRcdGlmICh0aGlzLnNjcm9sbEluZGV4IDwgMClcblx0XHRcdHRoaXMuc2Nyb2xsSW5kZXggPSAwO1xuXHRcdHRoaXMudXBkYXRlQ2FyZXRQb3NpdGlvbigpO1xuXHR9XG59XG5cbi8qKlxuICogQmx1ciBvdXJzZWxmLlxuICogQG1ldGhvZCBibHVyXG4gKi9cblBpeGlUZXh0SW5wdXQucHJvdG90eXBlLmJsdXIgPSBmdW5jdGlvbigpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5rZXlFdmVudENsb3N1cmUpO1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5cHJlc3NcIiwgdGhpcy5rZXlFdmVudENsb3N1cmUpO1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuZG9jdW1lbnRNb3VzZURvd25DbG9zdXJlKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMud2luZG93Qmx1ckNsb3N1cmUpO1xuXG5cdHRoaXMuaGlkZUNhcmV0KCk7XG59XG5cbi8qKlxuICogV2luZG93IGJsdXIuXG4gKiBAbWV0aG9kIG9uRG9jdW1lbnRNb3VzZURvd25cbiAqIEBwcml2YXRlXG4gKi9cblBpeGlUZXh0SW5wdXQucHJvdG90eXBlLm9uRG9jdW1lbnRNb3VzZURvd24gPSBmdW5jdGlvbigpIHtcblx0aWYgKCF0aGlzLmlzRm9jdXNDbGljaylcblx0XHR0aGlzLmJsdXIoKTtcbn1cblxuLyoqXG4gKiBXaW5kb3cgYmx1ci5cbiAqIEBtZXRob2Qgb25XaW5kb3dCbHVyXG4gKiBAcHJpdmF0ZVxuICovXG5QaXhpVGV4dElucHV0LnByb3RvdHlwZS5vbldpbmRvd0JsdXIgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5ibHVyKCk7XG59XG5cbi8qKlxuICogVXBkYXRlIGNhcmV0IFBvc2l0aW9uLlxuICogQG1ldGhvZCB1cGRhdGVDYXJldFBvc2l0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5QaXhpVGV4dElucHV0LnByb3RvdHlwZS51cGRhdGVDYXJldFBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLl9jYXJldEluZGV4IDwgdGhpcy5zY3JvbGxJbmRleCkge1xuXHRcdHRoaXMuY2FyZXQucG9zaXRpb24ueCA9IC0xO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBzdWIgPSB0aGlzLl90ZXh0LnN1YnN0cmluZygwLCB0aGlzLl9jYXJldEluZGV4KS5zdWJzdHJpbmcodGhpcy5zY3JvbGxJbmRleCk7XG5cdHRoaXMuY2FyZXQucG9zaXRpb24ueCA9IHRoaXMudGV4dEZpZWxkLmNvbnRleHQubWVhc3VyZVRleHQoc3ViKS53aWR0aDtcbn1cblxuLyoqXG4gKiBVcGRhdGUgdGV4dC5cbiAqIEBtZXRob2QgdXBkYXRlVGV4dFxuICogQHByaXZhdGVcbiAqL1xuUGl4aVRleHRJbnB1dC5wcm90b3R5cGUudXBkYXRlVGV4dCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnRleHRGaWVsZC5zZXRUZXh0KHRoaXMuX3RleHQuc3Vic3RyaW5nKHRoaXMuc2Nyb2xsSW5kZXgpKTtcbn1cblxuLyoqXG4gKiBEcmF3IHRoZSBiYWNrZ3JvdW5kIGFuZCBjYXJldC5cbiAqIEBtZXRob2QgZHJhd0VsZW1lbnRzXG4gKiBAcHJpdmF0ZVxuICovXG5QaXhpVGV4dElucHV0LnByb3RvdHlwZS5kcmF3RWxlbWVudHMgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5iYWNrZ3JvdW5kR3JhcGhpY3MuY2xlYXIoKTtcblx0dGhpcy5iYWNrZ3JvdW5kR3JhcGhpY3MuYmVnaW5GaWxsKHRoaXMuX2JhY2tncm91bmRDb2xvcik7XG5cblx0aWYgKHRoaXMuX2JhY2tncm91bmQpXG5cdFx0dGhpcy5iYWNrZ3JvdW5kR3JhcGhpY3MuZHJhd1JlY3QoMCwgMCwgdGhpcy5sb2NhbFdpZHRoLCB0aGlzLmxvY2FsSGVpZ2h0KTtcblxuXHR0aGlzLmJhY2tncm91bmRHcmFwaGljcy5lbmRGaWxsKCk7XG5cdHRoaXMuYmFja2dyb3VuZEdyYXBoaWNzLmhpdEFyZWEgPSBuZXcgUElYSS5SZWN0YW5nbGUoMCwgMCwgdGhpcy5sb2NhbFdpZHRoLCB0aGlzLmxvY2FsSGVpZ2h0KTtcblxuXHR0aGlzLnRleHRGaWVsZE1hc2suY2xlYXIoKTtcblx0dGhpcy50ZXh0RmllbGRNYXNrLmJlZ2luRmlsbCh0aGlzLl9iYWNrZ3JvdW5kQ29sb3IpO1xuXHR0aGlzLnRleHRGaWVsZE1hc2suZHJhd1JlY3QoMCwgMCwgdGhpcy5sb2NhbFdpZHRoLCB0aGlzLmxvY2FsSGVpZ2h0KTtcblx0dGhpcy50ZXh0RmllbGRNYXNrLmVuZEZpbGwoKTtcblxuXHR0aGlzLmNhcmV0LmNsZWFyKCk7XG5cdHRoaXMuY2FyZXQuYmVnaW5GaWxsKHRoaXMuX2NhcmV0Q29sb3IpO1xuXHR0aGlzLmNhcmV0LmRyYXdSZWN0KDEsIDEsIDEsIHRoaXMubG9jYWxIZWlnaHQgLSAyKTtcblx0dGhpcy5jYXJldC5lbmRGaWxsKCk7XG59XG5cbi8qKlxuICogU2hvdyBjYXJldC5cbiAqIEBtZXRob2Qgc2hvd0NhcmV0XG4gKiBAcHJpdmF0ZVxuICovXG5QaXhpVGV4dElucHV0LnByb3RvdHlwZS5zaG93Q2FyZXQgPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuY2FyZXRGbGFzaEludGVydmFsKSB7XG5cdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLmNhcmV0Rmxhc2hJbnRlcnZhbCk7XG5cdFx0dGhpcy5jYXJldEZsYXNoSW50ZXJ2YWwgPSBudWxsO1xuXHR9XG5cblx0dGhpcy5jYXJldC52aXNpYmxlID0gdHJ1ZTtcblx0dGhpcy5jYXJldEZsYXNoSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLm9uQ2FyZXRGbGFzaEludGVydmFsLmJpbmQodGhpcyksIDUwMCk7XG59XG5cbi8qKlxuICogSGlkZSBjYXJldC5cbiAqIEBtZXRob2QgaGlkZUNhcmV0XG4gKiBAcHJpdmF0ZVxuICovXG5QaXhpVGV4dElucHV0LnByb3RvdHlwZS5oaWRlQ2FyZXQgPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuY2FyZXRGbGFzaEludGVydmFsKSB7XG5cdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLmNhcmV0Rmxhc2hJbnRlcnZhbCk7XG5cdFx0dGhpcy5jYXJldEZsYXNoSW50ZXJ2YWwgPSBudWxsO1xuXHR9XG5cblx0dGhpcy5jYXJldC52aXNpYmxlID0gZmFsc2U7XG59XG5cbi8qKlxuICogQ2FyZXQgZmxhc2ggaW50ZXJ2YWwuXG4gKiBAbWV0aG9kIG9uQ2FyZXRGbGFzaEludGVydmFsXG4gKiBAcHJpdmF0ZVxuICovXG5QaXhpVGV4dElucHV0LnByb3RvdHlwZS5vbkNhcmV0Rmxhc2hJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLmNhcmV0LnZpc2libGUgPSAhdGhpcy5jYXJldC52aXNpYmxlO1xufVxuXG4vKipcbiAqIE1hcCBwb3NpdGlvbiB0byBjYXJldCBpbmRleC5cbiAqIEBtZXRob2QgZ2V0Q2FyZXRJbmRleEJ5Q29vcmRcbiAqIEBwcml2YXRlXG4gKi9cblBpeGlUZXh0SW5wdXQucHJvdG90eXBlLmdldENhcmV0SW5kZXhCeUNvb3JkID0gZnVuY3Rpb24oeCkge1xuXHR2YXIgc21hbGxlc3QgPSAxMDAwMDtcblx0dmFyIGNhbmQgPSAwO1xuXHR2YXIgdmlzaWJsZSA9IHRoaXMuX3RleHQuc3Vic3RyaW5nKHRoaXMuc2Nyb2xsSW5kZXgpO1xuXG5cdGZvciAoaSA9IDA7IGkgPCB2aXNpYmxlLmxlbmd0aCArIDE7IGkrKykge1xuXHRcdHZhciBzdWIgPSB2aXNpYmxlLnN1YnN0cmluZygwLCBpKTtcblx0XHR2YXIgdyA9IHRoaXMudGV4dEZpZWxkLmNvbnRleHQubWVhc3VyZVRleHQoc3ViKS53aWR0aDtcblxuXHRcdGlmIChNYXRoLmFicyh3IC0geCkgPCBzbWFsbGVzdCkge1xuXHRcdFx0c21hbGxlc3QgPSBNYXRoLmFicyh3IC0geCk7XG5cdFx0XHRjYW5kID0gaTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5zY3JvbGxJbmRleCArIGNhbmQ7XG59XG5cbi8qKlxuICogVGhlIHdpZHRoIG9mIHRoZSBQaXhpVGV4dElucHV0LiBUaGlzIGlzIG92ZXJyaWRkZW4gdG8gaGF2ZSBhIHNsaWdodGx5XG4gKiBkaWZmZXJlbnQgYmVoYWl2b3VyIHRoYW4gdGhlIG90aGVyIERpc3BsYXlPYmplY3RzLiBTZXR0aW5nIHRoZVxuICogd2lkdGggb2YgdGhlIFBpeGlUZXh0SW5wdXQgZG9lcyBub3QgY2hhbmdlIHRoZSBzY2FsZSwgYnV0IGl0IHJhdGhlclxuICogbWFrZXMgdGhlIGZpZWxkIGxhcmdlci4gSWYgeW91IGFjdHVhbGx5IHdhbnQgdG8gc2NhbGUgaXQsXG4gKiB1c2UgdGhlIHNjYWxlIHByb3BlcnR5LlxuICogQHByb3BlcnR5IHdpZHRoXG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBpeGlUZXh0SW5wdXQucHJvdG90eXBlLCBcIndpZHRoXCIsIHtcblx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5zY2FsZS54ICogdGhpcy5nZXRMb2NhbEJvdW5kcygpLndpZHRoO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24odikge1xuXHRcdHRoaXMubG9jYWxXaWR0aCA9IHY7XG5cdFx0dGhpcy5kcmF3RWxlbWVudHMoKTtcblx0XHR0aGlzLmVuc3VyZUNhcmV0SW5WaWV3KCk7XG5cdFx0dGhpcy51cGRhdGVUZXh0KCk7XG5cdH1cbn0pO1xuXG4vKipcbiAqIFRoZSB0ZXh0IGluIHRoZSBpbnB1dCBmaWVsZC4gU2V0dGluZyB3aWxsIGhhdmUgdGhlIGltcGxpY2l0IGZ1bmN0aW9uIG9mIHJlc2V0dGluZyB0aGUgc2Nyb2xsXG4gKiBvZiB0aGUgaW5wdXQgZmllbGQgYW5kIHJlbW92aW5nIGZvY3VzLlxuICogQHByb3BlcnR5IHRleHRcbiAqIEB0eXBlIFN0cmluZ1xuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGl4aVRleHRJbnB1dC5wcm90b3R5cGUsIFwidGV4dFwiLCB7XG5cdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RleHQ7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih2KSB7XG5cdFx0dGhpcy5fdGV4dCA9IHYudG9TdHJpbmcoKTtcblx0XHR0aGlzLnNjcm9sbEluZGV4ID0gMDtcblx0XHR0aGlzLmNhcmV0SW5kZXggPSAwO1xuXHRcdHRoaXMuYmx1cigpO1xuXHRcdHRoaXMudXBkYXRlVGV4dCgpO1xuXHR9XG59KTtcblxuLyoqXG4gKiBUaGUgY29sb3Igb2YgdGhlIGJhY2tncm91bmQgZm9yIHRoZSBpbnB1dCBmaWVsZC5cbiAqIFRoaXMgbmVlZHMgdG8gYmUgc3BlY2lmaWVkIGFzIGFuIGludGVnZXIsIG5vdCB1c2luZyBIVE1MXG4gKiBub3RhdGlvbiwgZS5nLiBmb3IgcmVkIGJhY2tncm91bmQ6XG4gKlxuICogICAgIG15SW5wdXRUZXh0LmJhY2tncm91bmRDb2xvciA9IDB4ZmYwMDAwO1xuICpcbiAqIEluIG9yZGVyIGZvciB0aGUgYmFja2dyb3VuZCB0byBiZSBkcmF3biwgdGhlIGBiYWNrZ3JvdW5kYFxuICogcHJvcGVydHkgbmVlZHMgdG8gYmUgdHJ1ZS4gSWYgbm90LCB0aGlzIHByb3BlcnR5IHdpbGwgaGF2ZVxuICogbm8gZWZmZWN0LlxuICogQHByb3BlcnR5IGJhY2tncm91bmRDb2xvclxuICogQHR5cGUgSW50ZWdlclxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGl4aVRleHRJbnB1dC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZENvbG9yXCIsIHtcblx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYmFja2dyb3VuZENvbG9yO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24odikge1xuXHRcdHRoaXMuX2JhY2tncm91bmRDb2xvciA9IHY7XG5cdFx0dGhpcy5kcmF3RWxlbWVudHMoKTtcblx0fVxufSk7XG5cbi8qKlxuICogVGhlIGNvbG9yIG9mIHRoZSBjYXJldC5cbiAqIEBwcm9wZXJ0eSBjYXJldENvbG9yXG4gKiBAdHlwZSBJbnRlZ2VyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaXhpVGV4dElucHV0LnByb3RvdHlwZSwgXCJjYXJldENvbG9yXCIsIHtcblx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2FyZXRDb2xvcjtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHYpIHtcblx0XHR0aGlzLl9jYXJldENvbG9yID0gdjtcblx0XHR0aGlzLmRyYXdFbGVtZW50cygpO1xuXHR9XG59KTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBiYWNrZ3JvdW5kIHNob3VsZCBiZSBkcmF3biBiZWhpbmQgdGhlIHRleHQuXG4gKiBUaGUgY29sb3Igb2YgdGhlIGJhY2tncm91bmQgaXMgc3BlY2lmaWVkIHVzaW5nIHRoZSBiYWNrZ3JvdW5kQ29sb3JcbiAqIHByb3BlcnR5LlxuICogQHByb3BlcnR5IGJhY2tncm91bmRcbiAqIEB0eXBlIEJvb2xlYW5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBpeGlUZXh0SW5wdXQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwge1xuXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24odikge1xuXHRcdHRoaXMuX2JhY2tncm91bmQgPSB2O1xuXHRcdHRoaXMuZHJhd0VsZW1lbnRzKCk7XG5cdH1cbn0pO1xuXG4vKipcbiAqIFNldCB0ZXh0LlxuICogQG1ldGhvZCBzZXRUZXh0XG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgbmV3IHRleHQuXG4gKi9cblBpeGlUZXh0SW5wdXQucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbih2KSB7XG5cdHRoaXMudGV4dCA9IHY7XG59XG5cbi8qKlxuICogVHJpZ2dlciBhbiBldmVudCBmdW5jdGlvbiBpZiBpdCBleGlzdHMuXG4gKiBAbWV0aG9kIHRyaWdnZXJcbiAqIEBwcml2YXRlXG4gKi9cblBpeGlUZXh0SW5wdXQucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbihmbiwgZSkge1xuXHRpZiAoZm4pXG5cdFx0Zm4oZSk7XG59XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuXHRtb2R1bGUuZXhwb3J0cyA9IFBpeGlUZXh0SW5wdXQ7XG59IiwiLyoqXG4gKiBUd2Vlbi5qcyAtIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3NvbGUvdHdlZW4uanNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NvbGUvdHdlZW4uanMvZ3JhcGhzL2NvbnRyaWJ1dG9ycyBmb3IgdGhlIGZ1bGwgbGlzdCBvZiBjb250cmlidXRvcnMuXG4gKiBUaGFuayB5b3UgYWxsLCB5b3UncmUgYXdlc29tZSFcbiAqL1xuXG4vLyBEYXRlLm5vdyBzaGltIGZvciAoYWhlbSkgSW50ZXJuZXQgRXhwbG8oZHxyKWVyXG5pZiAoIERhdGUubm93ID09PSB1bmRlZmluZWQgKSB7XG5cblx0RGF0ZS5ub3cgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG5cblx0fTtcblxufVxuXG52YXIgVFdFRU4gPSBUV0VFTiB8fCAoIGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgX3R3ZWVucyA9IFtdO1xuXG5cdHJldHVybiB7XG5cblx0XHRSRVZJU0lPTjogJzE0JyxcblxuXHRcdGdldEFsbDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gX3R3ZWVucztcblxuXHRcdH0sXG5cblx0XHRyZW1vdmVBbGw6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0X3R3ZWVucyA9IFtdO1xuXG5cdFx0fSxcblxuXHRcdGFkZDogZnVuY3Rpb24gKCB0d2VlbiApIHtcblxuXHRcdFx0X3R3ZWVucy5wdXNoKCB0d2VlbiApO1xuXG5cdFx0fSxcblxuXHRcdHJlbW92ZTogZnVuY3Rpb24gKCB0d2VlbiApIHtcblxuXHRcdFx0dmFyIGkgPSBfdHdlZW5zLmluZGV4T2YoIHR3ZWVuICk7XG5cblx0XHRcdGlmICggaSAhPT0gLTEgKSB7XG5cblx0XHRcdFx0X3R3ZWVucy5zcGxpY2UoIGksIDEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24gKCB0aW1lICkge1xuXG5cdFx0XHRpZiAoIF90d2VlbnMubGVuZ3RoID09PSAwICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR2YXIgaSA9IDA7XG5cblx0XHRcdHRpbWUgPSB0aW1lICE9PSB1bmRlZmluZWQgPyB0aW1lIDogKCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGVyZm9ybWFuY2UgIT09IHVuZGVmaW5lZCAmJiB3aW5kb3cucGVyZm9ybWFuY2Uubm93ICE9PSB1bmRlZmluZWQgPyB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgOiBEYXRlLm5vdygpICk7XG5cblx0XHRcdHdoaWxlICggaSA8IF90d2VlbnMubGVuZ3RoICkge1xuXG5cdFx0XHRcdGlmICggX3R3ZWVuc1sgaSBdLnVwZGF0ZSggdGltZSApICkge1xuXG5cdFx0XHRcdFx0aSsrO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRfdHdlZW5zLnNwbGljZSggaSwgMSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblx0fTtcblxufSApKCk7XG5cblRXRUVOLlR3ZWVuID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0dmFyIF9vYmplY3QgPSBvYmplY3Q7XG5cdHZhciBfdmFsdWVzU3RhcnQgPSB7fTtcblx0dmFyIF92YWx1ZXNFbmQgPSB7fTtcblx0dmFyIF92YWx1ZXNTdGFydFJlcGVhdCA9IHt9O1xuXHR2YXIgX2R1cmF0aW9uID0gMTAwMDtcblx0dmFyIF9yZXBlYXQgPSAwO1xuXHR2YXIgX3lveW8gPSBmYWxzZTtcblx0dmFyIF9pc1BsYXlpbmcgPSBmYWxzZTtcblx0dmFyIF9yZXZlcnNlZCA9IGZhbHNlO1xuXHR2YXIgX2RlbGF5VGltZSA9IDA7XG5cdHZhciBfc3RhcnRUaW1lID0gbnVsbDtcblx0dmFyIF9lYXNpbmdGdW5jdGlvbiA9IFRXRUVOLkVhc2luZy5MaW5lYXIuTm9uZTtcblx0dmFyIF9pbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSBUV0VFTi5JbnRlcnBvbGF0aW9uLkxpbmVhcjtcblx0dmFyIF9jaGFpbmVkVHdlZW5zID0gW107XG5cdHZhciBfb25TdGFydENhbGxiYWNrID0gbnVsbDtcblx0dmFyIF9vblN0YXJ0Q2FsbGJhY2tGaXJlZCA9IGZhbHNlO1xuXHR2YXIgX29uVXBkYXRlQ2FsbGJhY2sgPSBudWxsO1xuXHR2YXIgX29uQ29tcGxldGVDYWxsYmFjayA9IG51bGw7XG5cdHZhciBfb25TdG9wQ2FsbGJhY2sgPSBudWxsO1xuXG5cdC8vIFNldCBhbGwgc3RhcnRpbmcgdmFsdWVzIHByZXNlbnQgb24gdGhlIHRhcmdldCBvYmplY3Rcblx0Zm9yICggdmFyIGZpZWxkIGluIG9iamVjdCApIHtcblxuXHRcdF92YWx1ZXNTdGFydFsgZmllbGQgXSA9IHBhcnNlRmxvYXQob2JqZWN0W2ZpZWxkXSwgMTApO1xuXG5cdH1cblxuXHR0aGlzLnRvID0gZnVuY3Rpb24gKCBwcm9wZXJ0aWVzLCBkdXJhdGlvbiApIHtcblxuXHRcdGlmICggZHVyYXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0X2R1cmF0aW9uID0gZHVyYXRpb247XG5cblx0XHR9XG5cblx0XHRfdmFsdWVzRW5kID0gcHJvcGVydGllcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5zdGFydCA9IGZ1bmN0aW9uICggdGltZSApIHtcblxuXHRcdFRXRUVOLmFkZCggdGhpcyApO1xuXG5cdFx0X2lzUGxheWluZyA9IHRydWU7XG5cblx0XHRfb25TdGFydENhbGxiYWNrRmlyZWQgPSBmYWxzZTtcblxuXHRcdF9zdGFydFRpbWUgPSB0aW1lICE9PSB1bmRlZmluZWQgPyB0aW1lIDogKCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGVyZm9ybWFuY2UgIT09IHVuZGVmaW5lZCAmJiB3aW5kb3cucGVyZm9ybWFuY2Uubm93ICE9PSB1bmRlZmluZWQgPyB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgOiBEYXRlLm5vdygpICk7XG5cdFx0X3N0YXJ0VGltZSArPSBfZGVsYXlUaW1lO1xuXG5cdFx0Zm9yICggdmFyIHByb3BlcnR5IGluIF92YWx1ZXNFbmQgKSB7XG5cblx0XHRcdC8vIGNoZWNrIGlmIGFuIEFycmF5IHdhcyBwcm92aWRlZCBhcyBwcm9wZXJ0eSB2YWx1ZVxuXHRcdFx0aWYgKCBfdmFsdWVzRW5kWyBwcm9wZXJ0eSBdIGluc3RhbmNlb2YgQXJyYXkgKSB7XG5cblx0XHRcdFx0aWYgKCBfdmFsdWVzRW5kWyBwcm9wZXJ0eSBdLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjcmVhdGUgYSBsb2NhbCBjb3B5IG9mIHRoZSBBcnJheSB3aXRoIHRoZSBzdGFydCB2YWx1ZSBhdCB0aGUgZnJvbnRcblx0XHRcdFx0X3ZhbHVlc0VuZFsgcHJvcGVydHkgXSA9IFsgX29iamVjdFsgcHJvcGVydHkgXSBdLmNvbmNhdCggX3ZhbHVlc0VuZFsgcHJvcGVydHkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdF92YWx1ZXNTdGFydFsgcHJvcGVydHkgXSA9IF9vYmplY3RbIHByb3BlcnR5IF07XG5cblx0XHRcdGlmKCAoIF92YWx1ZXNTdGFydFsgcHJvcGVydHkgXSBpbnN0YW5jZW9mIEFycmF5ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRfdmFsdWVzU3RhcnRbIHByb3BlcnR5IF0gKj0gMS4wOyAvLyBFbnN1cmVzIHdlJ3JlIHVzaW5nIG51bWJlcnMsIG5vdCBzdHJpbmdzXG5cdFx0XHR9XG5cblx0XHRcdF92YWx1ZXNTdGFydFJlcGVhdFsgcHJvcGVydHkgXSA9IF92YWx1ZXNTdGFydFsgcHJvcGVydHkgXSB8fCAwO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRpZiAoICFfaXNQbGF5aW5nICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0VFdFRU4ucmVtb3ZlKCB0aGlzICk7XG5cdFx0X2lzUGxheWluZyA9IGZhbHNlO1xuXG5cdFx0aWYgKCBfb25TdG9wQ2FsbGJhY2sgIT09IG51bGwgKSB7XG5cblx0XHRcdF9vblN0b3BDYWxsYmFjay5jYWxsKCBfb2JqZWN0ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnN0b3BDaGFpbmVkVHdlZW5zKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLnN0b3BDaGFpbmVkVHdlZW5zID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBudW1DaGFpbmVkVHdlZW5zID0gX2NoYWluZWRUd2VlbnMubGVuZ3RoOyBpIDwgbnVtQ2hhaW5lZFR3ZWVuczsgaSsrICkge1xuXG5cdFx0XHRfY2hhaW5lZFR3ZWVuc1sgaSBdLnN0b3AoKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMuZGVsYXkgPSBmdW5jdGlvbiAoIGFtb3VudCApIHtcblxuXHRcdF9kZWxheVRpbWUgPSBhbW91bnQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLnJlcGVhdCA9IGZ1bmN0aW9uICggdGltZXMgKSB7XG5cblx0XHRfcmVwZWF0ID0gdGltZXM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLnlveW8gPSBmdW5jdGlvbiggeW95byApIHtcblxuXHRcdF95b3lvID0geW95bztcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cblx0dGhpcy5lYXNpbmcgPSBmdW5jdGlvbiAoIGVhc2luZyApIHtcblxuXHRcdF9lYXNpbmdGdW5jdGlvbiA9IGVhc2luZztcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMuaW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uICggaW50ZXJwb2xhdGlvbiApIHtcblxuXHRcdF9pbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSBpbnRlcnBvbGF0aW9uO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5jaGFpbiA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdF9jaGFpbmVkVHdlZW5zID0gYXJndW1lbnRzO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5vblN0YXJ0ID0gZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdF9vblN0YXJ0Q2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMub25VcGRhdGUgPSBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0X29uVXBkYXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMub25Db21wbGV0ZSA9IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHRfb25Db21wbGV0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLm9uU3RvcCA9IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHRfb25TdG9wQ2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKCB0aW1lICkge1xuXG5cdFx0dmFyIHByb3BlcnR5O1xuXG5cdFx0aWYgKCB0aW1lIDwgX3N0YXJ0VGltZSApIHtcblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9XG5cblx0XHRpZiAoIF9vblN0YXJ0Q2FsbGJhY2tGaXJlZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGlmICggX29uU3RhcnRDYWxsYmFjayAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRfb25TdGFydENhbGxiYWNrLmNhbGwoIF9vYmplY3QgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfb25TdGFydENhbGxiYWNrRmlyZWQgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGVsYXBzZWQgPSAoIHRpbWUgLSBfc3RhcnRUaW1lICkgLyBfZHVyYXRpb247XG5cdFx0ZWxhcHNlZCA9IGVsYXBzZWQgPiAxID8gMSA6IGVsYXBzZWQ7XG5cblx0XHR2YXIgdmFsdWUgPSBfZWFzaW5nRnVuY3Rpb24oIGVsYXBzZWQgKTtcblxuXHRcdGZvciAoIHByb3BlcnR5IGluIF92YWx1ZXNFbmQgKSB7XG5cblx0XHRcdHZhciBzdGFydCA9IF92YWx1ZXNTdGFydFsgcHJvcGVydHkgXSB8fCAwO1xuXHRcdFx0dmFyIGVuZCA9IF92YWx1ZXNFbmRbIHByb3BlcnR5IF07XG5cblx0XHRcdGlmICggZW5kIGluc3RhbmNlb2YgQXJyYXkgKSB7XG5cblx0XHRcdFx0X29iamVjdFsgcHJvcGVydHkgXSA9IF9pbnRlcnBvbGF0aW9uRnVuY3Rpb24oIGVuZCwgdmFsdWUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBQYXJzZXMgcmVsYXRpdmUgZW5kIHZhbHVlcyB3aXRoIHN0YXJ0IGFzIGJhc2UgKGUuZy46ICsxMCwgLTMpXG5cdFx0XHRcdGlmICggdHlwZW9mKGVuZCkgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0ZW5kID0gc3RhcnQgKyBwYXJzZUZsb2F0KGVuZCwgMTApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcHJvdGVjdCBhZ2FpbnN0IG5vbiBudW1lcmljIHByb3BlcnRpZXMuXG5cdFx0XHRcdGlmICggdHlwZW9mKGVuZCkgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0X29iamVjdFsgcHJvcGVydHkgXSA9IHN0YXJ0ICsgKCBlbmQgLSBzdGFydCApICogdmFsdWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBfb25VcGRhdGVDYWxsYmFjayAhPT0gbnVsbCApIHtcblxuXHRcdFx0X29uVXBkYXRlQ2FsbGJhY2suY2FsbCggX29iamVjdCwgdmFsdWUgKTtcblxuXHRcdH1cblxuXHRcdGlmICggZWxhcHNlZCA9PSAxICkge1xuXG5cdFx0XHRpZiAoIF9yZXBlYXQgPiAwICkge1xuXG5cdFx0XHRcdGlmKCBpc0Zpbml0ZSggX3JlcGVhdCApICkge1xuXHRcdFx0XHRcdF9yZXBlYXQtLTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHJlYXNzaWduIHN0YXJ0aW5nIHZhbHVlcywgcmVzdGFydCBieSBtYWtpbmcgc3RhcnRUaW1lID0gbm93XG5cdFx0XHRcdGZvciggcHJvcGVydHkgaW4gX3ZhbHVlc1N0YXJ0UmVwZWF0ICkge1xuXG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YoIF92YWx1ZXNFbmRbIHByb3BlcnR5IF0gKSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRcdF92YWx1ZXNTdGFydFJlcGVhdFsgcHJvcGVydHkgXSA9IF92YWx1ZXNTdGFydFJlcGVhdFsgcHJvcGVydHkgXSArIHBhcnNlRmxvYXQoX3ZhbHVlc0VuZFsgcHJvcGVydHkgXSwgMTApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChfeW95bykge1xuXHRcdFx0XHRcdFx0dmFyIHRtcCA9IF92YWx1ZXNTdGFydFJlcGVhdFsgcHJvcGVydHkgXTtcblx0XHRcdFx0XHRcdF92YWx1ZXNTdGFydFJlcGVhdFsgcHJvcGVydHkgXSA9IF92YWx1ZXNFbmRbIHByb3BlcnR5IF07XG5cdFx0XHRcdFx0XHRfdmFsdWVzRW5kWyBwcm9wZXJ0eSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF92YWx1ZXNTdGFydFsgcHJvcGVydHkgXSA9IF92YWx1ZXNTdGFydFJlcGVhdFsgcHJvcGVydHkgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKF95b3lvKSB7XG5cdFx0XHRcdFx0X3JldmVyc2VkID0gIV9yZXZlcnNlZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9zdGFydFRpbWUgPSB0aW1lICsgX2RlbGF5VGltZTtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIF9vbkNvbXBsZXRlQ2FsbGJhY2sgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRfb25Db21wbGV0ZUNhbGxiYWNrLmNhbGwoIF9vYmplY3QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBudW1DaGFpbmVkVHdlZW5zID0gX2NoYWluZWRUd2VlbnMubGVuZ3RoOyBpIDwgbnVtQ2hhaW5lZFR3ZWVuczsgaSsrICkge1xuXG5cdFx0XHRcdFx0X2NoYWluZWRUd2VlbnNbIGkgXS5zdGFydCggdGltZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH07XG5cbn07XG5cblxuVFdFRU4uRWFzaW5nID0ge1xuXG5cdExpbmVhcjoge1xuXG5cdFx0Tm9uZTogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gaztcblxuXHRcdH1cblxuXHR9LFxuXG5cdFF1YWRyYXRpYzoge1xuXG5cdFx0SW46IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIGsgKiBrO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gayAqICggMiAtIGsgKTtcblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRpZiAoICggayAqPSAyICkgPCAxICkgcmV0dXJuIDAuNSAqIGsgKiBrO1xuXHRcdFx0cmV0dXJuIC0gMC41ICogKCAtLWsgKiAoIGsgLSAyICkgLSAxICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRDdWJpYzoge1xuXG5cdFx0SW46IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIGsgKiBrICogaztcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIC0tayAqIGsgKiBrICsgMTtcblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRpZiAoICggayAqPSAyICkgPCAxICkgcmV0dXJuIDAuNSAqIGsgKiBrICogaztcblx0XHRcdHJldHVybiAwLjUgKiAoICggayAtPSAyICkgKiBrICogayArIDIgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdFF1YXJ0aWM6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiBrICogayAqIGsgKiBrO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gMSAtICggLS1rICogayAqIGsgKiBrICk7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0aWYgKCAoIGsgKj0gMiApIDwgMSkgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGs7XG5cdFx0XHRyZXR1cm4gLSAwLjUgKiAoICggayAtPSAyICkgKiBrICogayAqIGsgLSAyICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRRdWludGljOiB7XG5cblx0XHRJbjogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gayAqIGsgKiBrICogayAqIGs7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiAtLWsgKiBrICogayAqIGsgKiBrICsgMTtcblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRpZiAoICggayAqPSAyICkgPCAxICkgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGsgKiBrO1xuXHRcdFx0cmV0dXJuIDAuNSAqICggKCBrIC09IDIgKSAqIGsgKiBrICogayAqIGsgKyAyICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRTaW51c29pZGFsOiB7XG5cblx0XHRJbjogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gMSAtIE1hdGguY29zKCBrICogTWF0aC5QSSAvIDIgKTtcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIE1hdGguc2luKCBrICogTWF0aC5QSSAvIDIgKTtcblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gMC41ICogKCAxIC0gTWF0aC5jb3MoIE1hdGguUEkgKiBrICkgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdEV4cG9uZW50aWFsOiB7XG5cblx0XHRJbjogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gayA9PT0gMCA/IDAgOiBNYXRoLnBvdyggMTAyNCwgayAtIDEgKTtcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIGsgPT09IDEgPyAxIDogMSAtIE1hdGgucG93KCAyLCAtIDEwICogayApO1xuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdGlmICggayA9PT0gMCApIHJldHVybiAwO1xuXHRcdFx0aWYgKCBrID09PSAxICkgcmV0dXJuIDE7XG5cdFx0XHRpZiAoICggayAqPSAyICkgPCAxICkgcmV0dXJuIDAuNSAqIE1hdGgucG93KCAxMDI0LCBrIC0gMSApO1xuXHRcdFx0cmV0dXJuIDAuNSAqICggLSBNYXRoLnBvdyggMiwgLSAxMCAqICggayAtIDEgKSApICsgMiApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Q2lyY3VsYXI6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiAxIC0gTWF0aC5zcXJ0KCAxIC0gayAqIGsgKTtcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIE1hdGguc3FydCggMSAtICggLS1rICogayApICk7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0aWYgKCAoIGsgKj0gMiApIDwgMSkgcmV0dXJuIC0gMC41ICogKCBNYXRoLnNxcnQoIDEgLSBrICogaykgLSAxKTtcblx0XHRcdHJldHVybiAwLjUgKiAoIE1hdGguc3FydCggMSAtICggayAtPSAyKSAqIGspICsgMSk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRFbGFzdGljOiB7XG5cblx0XHRJbjogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHR2YXIgcywgYSA9IDAuMSwgcCA9IDAuNDtcblx0XHRcdGlmICggayA9PT0gMCApIHJldHVybiAwO1xuXHRcdFx0aWYgKCBrID09PSAxICkgcmV0dXJuIDE7XG5cdFx0XHRpZiAoICFhIHx8IGEgPCAxICkgeyBhID0gMTsgcyA9IHAgLyA0OyB9XG5cdFx0XHRlbHNlIHMgPSBwICogTWF0aC5hc2luKCAxIC8gYSApIC8gKCAyICogTWF0aC5QSSApO1xuXHRcdFx0cmV0dXJuIC0gKCBhICogTWF0aC5wb3coIDIsIDEwICogKCBrIC09IDEgKSApICogTWF0aC5zaW4oICggayAtIHMgKSAqICggMiAqIE1hdGguUEkgKSAvIHAgKSApO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHR2YXIgcywgYSA9IDAuMSwgcCA9IDAuNDtcblx0XHRcdGlmICggayA9PT0gMCApIHJldHVybiAwO1xuXHRcdFx0aWYgKCBrID09PSAxICkgcmV0dXJuIDE7XG5cdFx0XHRpZiAoICFhIHx8IGEgPCAxICkgeyBhID0gMTsgcyA9IHAgLyA0OyB9XG5cdFx0XHRlbHNlIHMgPSBwICogTWF0aC5hc2luKCAxIC8gYSApIC8gKCAyICogTWF0aC5QSSApO1xuXHRcdFx0cmV0dXJuICggYSAqIE1hdGgucG93KCAyLCAtIDEwICogaykgKiBNYXRoLnNpbiggKCBrIC0gcyApICogKCAyICogTWF0aC5QSSApIC8gcCApICsgMSApO1xuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHZhciBzLCBhID0gMC4xLCBwID0gMC40O1xuXHRcdFx0aWYgKCBrID09PSAwICkgcmV0dXJuIDA7XG5cdFx0XHRpZiAoIGsgPT09IDEgKSByZXR1cm4gMTtcblx0XHRcdGlmICggIWEgfHwgYSA8IDEgKSB7IGEgPSAxOyBzID0gcCAvIDQ7IH1cblx0XHRcdGVsc2UgcyA9IHAgKiBNYXRoLmFzaW4oIDEgLyBhICkgLyAoIDIgKiBNYXRoLlBJICk7XG5cdFx0XHRpZiAoICggayAqPSAyICkgPCAxICkgcmV0dXJuIC0gMC41ICogKCBhICogTWF0aC5wb3coIDIsIDEwICogKCBrIC09IDEgKSApICogTWF0aC5zaW4oICggayAtIHMgKSAqICggMiAqIE1hdGguUEkgKSAvIHAgKSApO1xuXHRcdFx0cmV0dXJuIGEgKiBNYXRoLnBvdyggMiwgLTEwICogKCBrIC09IDEgKSApICogTWF0aC5zaW4oICggayAtIHMgKSAqICggMiAqIE1hdGguUEkgKSAvIHAgKSAqIDAuNSArIDE7XG5cblx0XHR9XG5cblx0fSxcblxuXHRCYWNrOiB7XG5cblx0XHRJbjogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0XHRyZXR1cm4gayAqIGsgKiAoICggcyArIDEgKSAqIGsgLSBzICk7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHZhciBzID0gMS43MDE1ODtcblx0XHRcdHJldHVybiAtLWsgKiBrICogKCAoIHMgKyAxICkgKiBrICsgcyApICsgMTtcblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHR2YXIgcyA9IDEuNzAxNTggKiAxLjUyNTtcblx0XHRcdGlmICggKCBrICo9IDIgKSA8IDEgKSByZXR1cm4gMC41ICogKCBrICogayAqICggKCBzICsgMSApICogayAtIHMgKSApO1xuXHRcdFx0cmV0dXJuIDAuNSAqICggKCBrIC09IDIgKSAqIGsgKiAoICggcyArIDEgKSAqIGsgKyBzICkgKyAyICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRCb3VuY2U6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiAxIC0gVFdFRU4uRWFzaW5nLkJvdW5jZS5PdXQoIDEgLSBrICk7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdGlmICggayA8ICggMSAvIDIuNzUgKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gNy41NjI1ICogayAqIGs7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGsgPCAoIDIgLyAyLjc1ICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqICggayAtPSAoIDEuNSAvIDIuNzUgKSApICogayArIDAuNzU7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGsgPCAoIDIuNSAvIDIuNzUgKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKCBrIC09ICggMi4yNSAvIDIuNzUgKSApICogayArIDAuOTM3NTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKCBrIC09ICggMi42MjUgLyAyLjc1ICkgKSAqIGsgKyAwLjk4NDM3NTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdGlmICggayA8IDAuNSApIHJldHVybiBUV0VFTi5FYXNpbmcuQm91bmNlLkluKCBrICogMiApICogMC41O1xuXHRcdFx0cmV0dXJuIFRXRUVOLkVhc2luZy5Cb3VuY2UuT3V0KCBrICogMiAtIDEgKSAqIDAuNSArIDAuNTtcblxuXHRcdH1cblxuXHR9XG5cbn07XG5cblRXRUVOLkludGVycG9sYXRpb24gPSB7XG5cblx0TGluZWFyOiBmdW5jdGlvbiAoIHYsIGsgKSB7XG5cblx0XHR2YXIgbSA9IHYubGVuZ3RoIC0gMSwgZiA9IG0gKiBrLCBpID0gTWF0aC5mbG9vciggZiApLCBmbiA9IFRXRUVOLkludGVycG9sYXRpb24uVXRpbHMuTGluZWFyO1xuXG5cdFx0aWYgKCBrIDwgMCApIHJldHVybiBmbiggdlsgMCBdLCB2WyAxIF0sIGYgKTtcblx0XHRpZiAoIGsgPiAxICkgcmV0dXJuIGZuKCB2WyBtIF0sIHZbIG0gLSAxIF0sIG0gLSBmICk7XG5cblx0XHRyZXR1cm4gZm4oIHZbIGkgXSwgdlsgaSArIDEgPiBtID8gbSA6IGkgKyAxIF0sIGYgLSBpICk7XG5cblx0fSxcblxuXHRCZXppZXI6IGZ1bmN0aW9uICggdiwgayApIHtcblxuXHRcdHZhciBiID0gMCwgbiA9IHYubGVuZ3RoIC0gMSwgcHcgPSBNYXRoLnBvdywgYm4gPSBUV0VFTi5JbnRlcnBvbGF0aW9uLlV0aWxzLkJlcm5zdGVpbiwgaTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDw9IG47IGkrKyApIHtcblx0XHRcdGIgKz0gcHcoIDEgLSBrLCBuIC0gaSApICogcHcoIGssIGkgKSAqIHZbIGkgXSAqIGJuKCBuLCBpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGI7XG5cblx0fSxcblxuXHRDYXRtdWxsUm9tOiBmdW5jdGlvbiAoIHYsIGsgKSB7XG5cblx0XHR2YXIgbSA9IHYubGVuZ3RoIC0gMSwgZiA9IG0gKiBrLCBpID0gTWF0aC5mbG9vciggZiApLCBmbiA9IFRXRUVOLkludGVycG9sYXRpb24uVXRpbHMuQ2F0bXVsbFJvbTtcblxuXHRcdGlmICggdlsgMCBdID09PSB2WyBtIF0gKSB7XG5cblx0XHRcdGlmICggayA8IDAgKSBpID0gTWF0aC5mbG9vciggZiA9IG0gKiAoIDEgKyBrICkgKTtcblxuXHRcdFx0cmV0dXJuIGZuKCB2WyAoIGkgLSAxICsgbSApICUgbSBdLCB2WyBpIF0sIHZbICggaSArIDEgKSAlIG0gXSwgdlsgKCBpICsgMiApICUgbSBdLCBmIC0gaSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKCBrIDwgMCApIHJldHVybiB2WyAwIF0gLSAoIGZuKCB2WyAwIF0sIHZbIDAgXSwgdlsgMSBdLCB2WyAxIF0sIC1mICkgLSB2WyAwIF0gKTtcblx0XHRcdGlmICggayA+IDEgKSByZXR1cm4gdlsgbSBdIC0gKCBmbiggdlsgbSBdLCB2WyBtIF0sIHZbIG0gLSAxIF0sIHZbIG0gLSAxIF0sIGYgLSBtICkgLSB2WyBtIF0gKTtcblxuXHRcdFx0cmV0dXJuIGZuKCB2WyBpID8gaSAtIDEgOiAwIF0sIHZbIGkgXSwgdlsgbSA8IGkgKyAxID8gbSA6IGkgKyAxIF0sIHZbIG0gPCBpICsgMiA/IG0gOiBpICsgMiBdLCBmIC0gaSApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0VXRpbHM6IHtcblxuXHRcdExpbmVhcjogZnVuY3Rpb24gKCBwMCwgcDEsIHQgKSB7XG5cblx0XHRcdHJldHVybiAoIHAxIC0gcDAgKSAqIHQgKyBwMDtcblxuXHRcdH0sXG5cblx0XHRCZXJuc3RlaW46IGZ1bmN0aW9uICggbiAsIGkgKSB7XG5cblx0XHRcdHZhciBmYyA9IFRXRUVOLkludGVycG9sYXRpb24uVXRpbHMuRmFjdG9yaWFsO1xuXHRcdFx0cmV0dXJuIGZjKCBuICkgLyBmYyggaSApIC8gZmMoIG4gLSBpICk7XG5cblx0XHR9LFxuXG5cdFx0RmFjdG9yaWFsOiAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGEgPSBbIDEgXTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICggbiApIHtcblxuXHRcdFx0XHR2YXIgcyA9IDEsIGk7XG5cdFx0XHRcdGlmICggYVsgbiBdICkgcmV0dXJuIGFbIG4gXTtcblx0XHRcdFx0Zm9yICggaSA9IG47IGkgPiAxOyBpLS0gKSBzICo9IGk7XG5cdFx0XHRcdHJldHVybiBhWyBuIF0gPSBzO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSApKCksXG5cblx0XHRDYXRtdWxsUm9tOiBmdW5jdGlvbiAoIHAwLCBwMSwgcDIsIHAzLCB0ICkge1xuXG5cdFx0XHR2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNSwgdjEgPSAoIHAzIC0gcDEgKSAqIDAuNSwgdDIgPSB0ICogdCwgdDMgPSB0ICogdDI7XG5cdFx0XHRyZXR1cm4gKCAyICogcDEgLSAyICogcDIgKyB2MCArIHYxICkgKiB0MyArICggLSAzICogcDEgKyAzICogcDIgLSAyICogdjAgLSB2MSApICogdDIgKyB2MCAqIHQgKyBwMTtcblxuXHRcdH1cblxuXHR9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzPVRXRUVOOyIsIi8qKlxuICogQVMzL2pxdWVyeSBzdHlsZSBldmVudCBkaXNwYXRjaGVyLiBTbGlnaHRseSBtb2RpZmllZC4gVGhlXG4gKiBqcXVlcnkgc3R5bGUgb24vb2ZmL3RyaWdnZXIgc3R5bGUgb2YgYWRkaW5nIGxpc3RlbmVycyBpc1xuICogY3VycmVudGx5IHRoZSBwcmVmZXJyZWQgb25lLlxuICpcbiAqIFRoZSBvbiBtZXRob2QgZm9yIGFkZGluZyBsaXN0ZW5lcnMgdGFrZXMgYW4gZXh0cmEgcGFyYW1ldGVyIHdoaWNoIGlzIHRoZVxuICogc2NvcGUgaW4gd2hpY2ggbGlzdGVuZXJzIHNob3VsZCBiZSBjYWxsZWQuIFNvIHRoaXM6XG4gKlxuICogICAgIG9iamVjdC5vbihcImV2ZW50XCIsIGxpc3RlbmVyLCB0aGlzKTtcbiAqXG4gKiBIYXMgdGhlIHNhbWUgZnVuY3Rpb24gd2hlbiBhZGRpbmcgZXZlbnRzIGFzOlxuICpcbiAqICAgICBvYmplY3Qub24oXCJldmVudFwiLCBsaXN0ZW5lci5iaW5kKHRoaXMpKTtcbiAqXG4gKiBIb3dldmVyLCB0aGUgZGlmZmVyZW5jZSBpcyB0aGF0IGlmIHdlIHVzZSB0aGUgc2Vjb25kIG1ldGhvZCBpdFxuICogd2lsbCBub3QgYmUgcG9zc2libGUgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgbGF0ZXIsIHVubGVzc1xuICogdGhlIGNsb3N1cmUgY3JlYXRlZCBieSBiaW5kIGlzIHN0b3JlZCBzb21ld2hlcmUuIElmIHRoZVxuICogZmlyc3QgbWV0aG9kIGlzIHVzZWQsIHdlIGNhbiByZW1vdmUgdGhlIGxpc3RlbmVyIHdpdGg6XG4gKlxuICogICAgIG9iamVjdC5vZmYoXCJldmVudFwiLCBsaXN0ZW5lciwgdGhpcyk7XG4gKlxuICogQGNsYXNzIEV2ZW50RGlzcGF0Y2hlclxuICovXG5mdW5jdGlvbiBFdmVudERpc3BhdGNoZXIoKSB7XG5cdHRoaXMubGlzdGVuZXJNYXAgPSB7fTtcbn1cblxuLyoqXG4gKiBBZGQgZXZlbnQgbGlzdGVuZXIuXG4gKiBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXJcbiAqL1xuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lciwgc2NvcGUpIHtcblx0aWYgKCF0aGlzLmxpc3RlbmVyTWFwKVxuXHRcdHRoaXMubGlzdGVuZXJNYXAgPSB7fTtcblxuXHRpZiAoIWV2ZW50VHlwZSlcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCB0eXBlIHJlcXVpcmVkIGZvciBldmVudCBkaXNwYXRjaGVyXCIpO1xuXG5cdGlmICghbGlzdGVuZXIpXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiTGlzdGVuZXIgcmVxdWlyZWQgZm9yIGV2ZW50IGRpc3BhdGNoZXJcIik7XG5cblx0dGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIHNjb3BlKTtcblxuXHRpZiAoIXRoaXMubGlzdGVuZXJNYXAuaGFzT3duUHJvcGVydHkoZXZlbnRUeXBlKSlcblx0XHR0aGlzLmxpc3RlbmVyTWFwW2V2ZW50VHlwZV0gPSBbXTtcblxuXHR0aGlzLmxpc3RlbmVyTWFwW2V2ZW50VHlwZV0ucHVzaCh7XG5cdFx0bGlzdGVuZXI6IGxpc3RlbmVyLFxuXHRcdHNjb3BlOiBzY29wZVxuXHR9KTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXIuXG4gKiBAbWV0aG9kIHJlbW92ZUV2ZW50TGlzdGVuZXJcbiAqL1xuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lciwgc2NvcGUpIHtcblx0aWYgKCF0aGlzLmxpc3RlbmVyTWFwKVxuXHRcdHRoaXMubGlzdGVuZXJNYXAgPSB7fTtcblxuXHRpZiAoIXRoaXMubGlzdGVuZXJNYXAuaGFzT3duUHJvcGVydHkoZXZlbnRUeXBlKSlcblx0XHRyZXR1cm47XG5cblx0dmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJNYXBbZXZlbnRUeXBlXTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBsaXN0ZW5lck9iaiA9IGxpc3RlbmVyc1tpXTtcblxuXHRcdGlmIChsaXN0ZW5lciA9PSBsaXN0ZW5lck9iai5saXN0ZW5lciAmJiBzY29wZSA9PSBsaXN0ZW5lck9iai5zY29wZSkge1xuXHRcdFx0bGlzdGVuZXJzLnNwbGljZShpLCAxKTtcblx0XHRcdGktLTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIWxpc3RlbmVycy5sZW5ndGgpXG5cdFx0ZGVsZXRlIHRoaXMubGlzdGVuZXJNYXBbZXZlbnRUeXBlXTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBldmVudC5cbiAqIEBtZXRob2QgZGlzcGF0Y2hFdmVudFxuICovXG5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudCAvKiAuLi4gKi8gKSB7XG5cdGlmICghdGhpcy5saXN0ZW5lck1hcClcblx0XHR0aGlzLmxpc3RlbmVyTWFwID0ge307XG5cblx0dmFyIGV2ZW50VHlwZTtcblx0dmFyIGxpc3RlbmVyUGFyYW1zO1xuXG5cdGlmICh0eXBlb2YgZXZlbnQgPT0gXCJzdHJpbmdcIikge1xuXHRcdGV2ZW50VHlwZSA9IGV2ZW50O1xuXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKVxuXHRcdFx0bGlzdGVuZXJQYXJhbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG5cdFx0ZWxzZSBsaXN0ZW5lclBhcmFtcyA9IFt7XG5cdFx0XHR0eXBlOiBldmVudFR5cGUsXG5cdFx0XHR0YXJnZXQ6IHRoaXNcblx0XHR9XTtcblx0fSBlbHNlIHtcblx0XHRldmVudFR5cGUgPSBldmVudC50eXBlO1xuXHRcdGV2ZW50LnRhcmdldCA9IHRoaXM7XG5cdFx0bGlzdGVuZXJQYXJhbXMgPSBbZXZlbnRdO1xuXHR9XG5cblx0aWYgKCF0aGlzLmxpc3RlbmVyTWFwLmhhc093blByb3BlcnR5KGV2ZW50VHlwZSkpXG5cdFx0cmV0dXJuO1xuXG5cdHZhciBtYXAgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpc3RlbmVyTWFwW2V2ZW50VHlwZV0ubGVuZ3RoOyBpKyspXG5cdFx0bWFwLnB1c2godGhpcy5saXN0ZW5lck1hcFtldmVudFR5cGVdW2ldKVxuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbWFwLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGxpc3RlbmVyT2JqID0gbWFwW2ldO1xuXHRcdGxpc3RlbmVyT2JqLmxpc3RlbmVyLmFwcGx5KGxpc3RlbmVyT2JqLnNjb3BlLCBsaXN0ZW5lclBhcmFtcyk7XG5cdH1cbn1cblxuLyoqXG4gKiBKcXVlcnkgc3R5bGUgYWxpYXMgZm9yIGFkZEV2ZW50TGlzdGVuZXJcbiAqIEBtZXRob2Qgb25cbiAqL1xuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcblxuLyoqXG4gKiBKcXVlcnkgc3R5bGUgYWxpYXMgZm9yIHJlbW92ZUV2ZW50TGlzdGVuZXJcbiAqIEBtZXRob2Qgb2ZmXG4gKi9cbkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUub2ZmID0gRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXG4vKipcbiAqIEpxdWVyeSBzdHlsZSBhbGlhcyBmb3IgZGlzcGF0Y2hFdmVudFxuICogQG1ldGhvZCB0cmlnZ2VyXG4gKi9cbkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUudHJpZ2dlciA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudDtcblxuLyoqXG4gKiBNYWtlIHNvbWV0aGluZyBhbiBldmVudCBkaXNwYXRjaGVyLiBDYW4gYmUgdXNlZCBmb3IgbXVsdGlwbGUgaW5oZXJpdGFuY2UuXG4gKiBAbWV0aG9kIGluaXRcbiAqIEBzdGF0aWNcbiAqL1xuRXZlbnREaXNwYXRjaGVyLmluaXQgPSBmdW5jdGlvbihjbHMpIHtcblx0Y2xzLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuXHRjbHMucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cdGNscy5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudDtcblx0Y2xzLnByb3RvdHlwZS5vbiA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUub247XG5cdGNscy5wcm90b3R5cGUub2ZmID0gRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5vZmY7XG5cdGNscy5wcm90b3R5cGUudHJpZ2dlciA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUudHJpZ2dlcjtcbn1cblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gRXZlbnREaXNwYXRjaGVyO1xufSIsIi8qKlxuICogQ2xpZW50LlxuICogQG1vZHVsZSBjbGllbnRcbiAqL1xuXG52YXIgU2hvd0RpYWxvZ01lc3NhZ2UgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vbWVzc2FnZXMvU2hvd0RpYWxvZ01lc3NhZ2VcIik7XG52YXIgQnV0dG9uc01lc3NhZ2UgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vbWVzc2FnZXMvQnV0dG9uc01lc3NhZ2VcIik7XG52YXIgQ2hhdE1lc3NhZ2UgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vbWVzc2FnZXMvQ2hhdE1lc3NhZ2VcIik7XG52YXIgVGFibGVJbmZvTWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9UYWJsZUluZm9NZXNzYWdlXCIpO1xudmFyIEhhbmRJbmZvTWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9IYW5kSW5mb01lc3NhZ2VcIik7XG52YXIgUHJlc2V0QnV0dG9uc01lc3NhZ2UgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vbWVzc2FnZXMvUHJlc2V0QnV0dG9uc01lc3NhZ2VcIik7XG52YXIgSW50ZXJmYWNlU3RhdGVNZXNzYWdlID0gcmVxdWlyZShcIi4uLy4uL3Byb3RvL21lc3NhZ2VzL0ludGVyZmFjZVN0YXRlTWVzc2FnZVwiKTtcbnZhciBDaGVja2JveE1lc3NhZ2UgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vbWVzc2FnZXMvQ2hlY2tib3hNZXNzYWdlXCIpO1xudmFyIFByZVRvdXJuYW1lbnRJbmZvTWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9QcmVUb3VybmFtZW50SW5mb01lc3NhZ2VcIik7XG5cbi8qKlxuICogQ29udHJvbCB1c2VyIGludGVyZmFjZS5cbiAqIEBjbGFzcyBJbnRlcmZhY2VDb250cm9sbGVyXG4gKi9cbmZ1bmN0aW9uIEludGVyZmFjZUNvbnRyb2xsZXIobWVzc2FnZVNlcXVlbmNlciwgdmlldykge1xuXHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIgPSBtZXNzYWdlU2VxdWVuY2VyO1xuXHR0aGlzLnZpZXcgPSB2aWV3O1xuXG5cdHRoaXMubWVzc2FnZVNlcXVlbmNlci5hZGRNZXNzYWdlSGFuZGxlcihCdXR0b25zTWVzc2FnZS5UWVBFLCB0aGlzLm9uQnV0dG9uc01lc3NhZ2UsIHRoaXMpO1xuXHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIuYWRkTWVzc2FnZUhhbmRsZXIoU2hvd0RpYWxvZ01lc3NhZ2UuVFlQRSwgdGhpcy5vblNob3dEaWFsb2dNZXNzYWdlLCB0aGlzKTtcblx0dGhpcy5tZXNzYWdlU2VxdWVuY2VyLmFkZE1lc3NhZ2VIYW5kbGVyKENoYXRNZXNzYWdlLlRZUEUsIHRoaXMub25DaGF0LCB0aGlzKTtcblx0dGhpcy5tZXNzYWdlU2VxdWVuY2VyLmFkZE1lc3NhZ2VIYW5kbGVyKFRhYmxlSW5mb01lc3NhZ2UuVFlQRSwgdGhpcy5vblRhYmxlSW5mb01lc3NhZ2UsIHRoaXMpO1xuXHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIuYWRkTWVzc2FnZUhhbmRsZXIoSGFuZEluZm9NZXNzYWdlLlRZUEUsIHRoaXMub25IYW5kSW5mb01lc3NhZ2UsIHRoaXMpO1xuXHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIuYWRkTWVzc2FnZUhhbmRsZXIoSW50ZXJmYWNlU3RhdGVNZXNzYWdlLlRZUEUsIHRoaXMub25JbnRlcmZhY2VTdGF0ZU1lc3NhZ2UsIHRoaXMpO1xuXHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIuYWRkTWVzc2FnZUhhbmRsZXIoQ2hlY2tib3hNZXNzYWdlLlRZUEUsIHRoaXMub25DaGVja2JveE1lc3NhZ2UsIHRoaXMpO1xuXHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIuYWRkTWVzc2FnZUhhbmRsZXIoUHJlVG91cm5hbWVudEluZm9NZXNzYWdlLlRZUEUsIHRoaXMub25QcmVUb3VybmFtZW50SW5mb01lc3NhZ2UsIHRoaXMpO1xuXG5cdHRoaXMubWVzc2FnZVNlcXVlbmNlci5hZGRNZXNzYWdlSGFuZGxlcihQcmVzZXRCdXR0b25zTWVzc2FnZS5UWVBFLCB0aGlzLm9uUHJlc2V0QnV0dG9ucywgdGhpcyk7XG59XG5cbi8qKlxuICogQnV0dG9ucyBtZXNzYWdlLlxuICogQG1ldGhvZCBvbkJ1dHRvbnNNZXNzYWdlXG4gKi9cbkludGVyZmFjZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uQnV0dG9uc01lc3NhZ2UgPSBmdW5jdGlvbihtKSB7XG5cdHZhciBidXR0b25zVmlldyA9IHRoaXMudmlldy5nZXRCdXR0b25zVmlldygpO1xuXG5cdGJ1dHRvbnNWaWV3LnNldEJ1dHRvbnMobS5nZXRCdXR0b25zKCksIG0uc2xpZGVyQnV0dG9uSW5kZXgsIHBhcnNlSW50KG0ubWluLCAxMCksIHBhcnNlSW50KG0ubWF4LCAxMCkpO1xufVxuXG4vKipcbiAqIFByZXNldEJ1dHRvbnMgbWVzc2FnZS5cbiAqIEBtZXRob2Qgb25QcmVzZXRCdXR0b25zXG4gKi9cbkludGVyZmFjZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uUHJlc2V0QnV0dG9ucyA9IGZ1bmN0aW9uKG0pIHtcblx0dmFyIHByZXNldEJ1dHRvbnNWaWV3ID0gdGhpcy52aWV3LmdldFByZXNldEJ1dHRvbnNWaWV3KCk7XG5cblx0dmFyIGJ1dHRvbnMgPSBwcmVzZXRCdXR0b25zVmlldy5nZXRCdXR0b25zKCk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYnV0dG9ucy5sZW5ndGg7IGkrKykge1xuXHRcdGlmIChpID4gbS5idXR0b25zLmxlbmd0aCkge1xuXHRcdFx0YnV0dG9uc1tpXS5oaWRlKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBkYXRhID0gbS5idXR0b25zW2ldO1xuXG5cdFx0XHRpZiAoZGF0YSA9PSBudWxsKSB7XG5cdFx0XHRcdGJ1dHRvbnNbaV0uaGlkZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnV0dG9uc1tpXS5zaG93KGRhdGEuYnV0dG9uLCBkYXRhLnZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwcmVzZXRCdXR0b25zVmlldy5zZXRDdXJyZW50KG0uY3VycmVudCk7XG59XG5cbi8qKlxuICogU2hvdyBkaWFsb2cuXG4gKiBAbWV0aG9kIG9uU2hvd0RpYWxvZ01lc3NhZ2VcbiAqL1xuSW50ZXJmYWNlQ29udHJvbGxlci5wcm90b3R5cGUub25TaG93RGlhbG9nTWVzc2FnZSA9IGZ1bmN0aW9uKG0pIHtcblx0dmFyIGRpYWxvZ1ZpZXcgPSB0aGlzLnZpZXcuZ2V0RGlhbG9nVmlldygpO1xuXG5cdGRpYWxvZ1ZpZXcuc2hvdyhtLmdldFRleHQoKSwgbS5nZXRCdXR0b25zKCksIG0uZ2V0RGVmYXVsdFZhbHVlKCkpO1xufVxuXG5cbi8qKlxuICogT24gY2hhdCBtZXNzYWdlLlxuICogQG1ldGhvZCBvbkNoYXRcbiAqL1xuSW50ZXJmYWNlQ29udHJvbGxlci5wcm90b3R5cGUub25DaGF0ID0gZnVuY3Rpb24obSkge1xuXHR0aGlzLnZpZXcuY2hhdFZpZXcuYWRkVGV4dChtLnVzZXIsIG0udGV4dCk7XG59XG5cbi8qKlxuICogSGFuZGxlIHRhYmxlIGluZm8gbWVzc2FnZS5cbiAqIEBtZXRob2Qgb25UYWJsZUluZm9NZXNzYWdlXG4gKi9cbkludGVyZmFjZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uVGFibGVJbmZvTWVzc2FnZSA9IGZ1bmN0aW9uKG0pIHtcblx0dmFyIHRhYmxlSW5mb1ZpZXcgPSB0aGlzLnZpZXcuZ2V0VGFibGVJbmZvVmlldygpO1xuXG5cdHRhYmxlSW5mb1ZpZXcuc2V0VGFibGVJbmZvVGV4dChtLmdldFRleHQoKSk7XG5cdHRhYmxlSW5mb1ZpZXcuc2V0Sm9pbkJ1dHRvblZpc2libGUobS5nZXRTaG93Sm9pbkJ1dHRvbigpKTtcblx0dGFibGVJbmZvVmlldy5zZXRMZWF2ZUJ1dHRvblZpc2libGUobS5nZXRTaG93TGVhdmVCdXR0b24oKSk7XG59XG5cbi8qKlxuICogSGFuZGxlIGhhbmQgaW5mbyBtZXNzYWdlLlxuICogQG1ldGhvZCBvbkhhbmRJbmZvTWVzc2FnZVxuICovXG5JbnRlcmZhY2VDb250cm9sbGVyLnByb3RvdHlwZS5vbkhhbmRJbmZvTWVzc2FnZSA9IGZ1bmN0aW9uKG0pIHtcblx0dmFyIHRhYmxlSW5mb1ZpZXcgPSB0aGlzLnZpZXcuZ2V0VGFibGVJbmZvVmlldygpO1xuXG5cdHRhYmxlSW5mb1ZpZXcuc2V0SGFuZEluZm9UZXh0KG0uZ2V0VGV4dCgpKTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgaW50ZXJmYWNlIHN0YXRlIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIG9uSW50ZXJmYWNlU3RhdGVNZXNzYWdlXG4gKi9cbkludGVyZmFjZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uSW50ZXJmYWNlU3RhdGVNZXNzYWdlID0gZnVuY3Rpb24obSkge1xuXHR2YXIgc2V0dGluZ3NWaWV3ID0gdGhpcy52aWV3LmdldFNldHRpbmdzVmlldygpO1xuXG5cdHNldHRpbmdzVmlldy5zZXRWaXNpYmxlQnV0dG9ucyhtLmdldFZpc2libGVCdXR0b25zKCkpO1xufVxuXG4vKipcbiAqIEhhbmRsZSBjaGVja2JveCBtZXNzYWdlLlxuICogQG1ldGhvZCBvbkNoZWNrYm94TWVzc2FnZVxuICovXG5JbnRlcmZhY2VDb250cm9sbGVyLnByb3RvdHlwZS5vbkNoZWNrYm94TWVzc2FnZSA9IGZ1bmN0aW9uKG0pIHtcblx0Y29uc29sZS5sb2cobSk7XG5cblx0dmFyIHNldHRpbmdzVmlldyA9IHRoaXMudmlldy5nZXRTZXR0aW5nc1ZpZXcoKTtcblxuXHRzZXR0aW5nc1ZpZXcuc2V0Q2hlY2tib3hDaGVja2VkKG0uZ2V0SWQoKSwgbS5nZXRDaGVja2VkKCkpO1xufVxuXG4vKipcbiAqIEhhbmRsZSBwcmUgdG9ydW5hbWVudCBpbmZvIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIG9uUHJlVG91cm5hbWVudEluZm9NZXNzYWdlXG4gKi9cbkludGVyZmFjZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uUHJlVG91cm5hbWVudEluZm9NZXNzYWdlID0gZnVuY3Rpb24obSkge1xuXHR2YXIgdGFibGVJbmZvVmlldyA9IHRoaXMudmlldy5nZXRUYWJsZUluZm9WaWV3KCk7XG5cblx0dGFibGVJbmZvVmlldy5zZXRQcmVUb3VybmFtZW50SW5mb1RleHQobS5nZXRUZXh0KCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyZmFjZUNvbnRyb2xsZXI7IiwiLyoqXG4gKiBDbGllbnQuXG4gKiBAbW9kdWxlIGNsaWVudFxuICovXG5cbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKFwieWFlZFwiKTtcbnZhciBTZXF1ZW5jZXIgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvU2VxdWVuY2VyXCIpO1xudmFyIGluaGVyaXRzPXJlcXVpcmUoXCJpbmhlcml0c1wiKTtcblxuLyoqXG4gKiBBbiBpdGVtIGluIGEgbWVzc2FnZSBzZXF1ZW5jZS5cbiAqIEBjbGFzcyBNZXNzYWdlU2VxdWVuY2VJdGVtXG4gKi9cbmZ1bmN0aW9uIE1lc3NhZ2VTZXF1ZW5jZUl0ZW0obWVzc2FnZSkge1xuXHRFdmVudERpc3BhdGNoZXIuY2FsbCh0aGlzKTtcblx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblx0dGhpcy53YWl0VGFyZ2V0ID0gbnVsbDtcblx0dGhpcy53YWl0RXZlbnQgPSBudWxsO1xuXHR0aGlzLndhaXRDbG9zdXJlID0gbnVsbDtcbn1cblxuaW5oZXJpdHMoTWVzc2FnZVNlcXVlbmNlSXRlbSwgRXZlbnREaXNwYXRjaGVyKTtcblxuLyoqXG4gKiBHZXQgbWVzc2FnZS5cbiAqIEBtZXRob2QgZ2V0TWVzc2FnZVxuICovXG5NZXNzYWdlU2VxdWVuY2VJdGVtLnByb3RvdHlwZS5nZXRNZXNzYWdlID0gZnVuY3Rpb24oKSB7XG5cdC8vY29uc29sZS5sb2coXCJnZXR0aW5nOiBcIiArIHRoaXMubWVzc2FnZS50eXBlKTtcblxuXHRyZXR1cm4gdGhpcy5tZXNzYWdlO1xufVxuXG4vKipcbiAqIEFyZSB3ZSB3YWl0aW5nIGZvciBhbiBldmVudD9cbiAqIEBtZXRob2QgaXNXYWl0aW5nXG4gKi9cbk1lc3NhZ2VTZXF1ZW5jZUl0ZW0ucHJvdG90eXBlLmlzV2FpdGluZyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy53YWl0RXZlbnQgIT0gbnVsbDtcbn1cblxuLyoqXG4gKiBOb3RpZnkgY29tcGxldGUuXG4gKiBAbWV0aG9kIG5vdGlmeUNvbXBsZXRlXG4gKi9cbk1lc3NhZ2VTZXF1ZW5jZUl0ZW0ucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMudHJpZ2dlcihTZXF1ZW5jZXIuQ09NUExFVEUpO1xufVxuXG4vKipcbiAqIFdhaXQgZm9yIGV2ZW50IGJlZm9yZSBwcm9jZXNzaW5nIG5leHQgbWVzc2FnZS5cbiAqIEBtZXRob2Qgd2FpdEZvclxuICovXG5NZXNzYWdlU2VxdWVuY2VJdGVtLnByb3RvdHlwZS53YWl0Rm9yID0gZnVuY3Rpb24odGFyZ2V0LCBldmVudCkge1xuXHR0aGlzLndhaXRUYXJnZXQgPSB0YXJnZXQ7XG5cdHRoaXMud2FpdEV2ZW50ID0gZXZlbnQ7XG5cdHRoaXMud2FpdENsb3N1cmUgPSB0aGlzLm9uVGFyZ2V0Q29tcGxldGUuYmluZCh0aGlzKTtcblxuXHR0aGlzLndhaXRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLndhaXRFdmVudCwgdGhpcy53YWl0Q2xvc3VyZSk7XG59XG5cbi8qKlxuICogV2FpdCB0YXJnZXQgY29tcGxldGUuXG4gKiBAbWV0aG9kIG9uVGFyZ2V0Q29tcGxldGVcbiAqIEBwcml2YXRlXG4gKi9cbk1lc3NhZ2VTZXF1ZW5jZUl0ZW0ucHJvdG90eXBlLm9uVGFyZ2V0Q29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0Ly9jb25zb2xlLmxvZyhcInRhcmdldCBpcyBjb21wbGV0ZVwiKTtcblx0dGhpcy53YWl0VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy53YWl0RXZlbnQsIHRoaXMud2FpdENsb3N1cmUpO1xuXHR0aGlzLm5vdGlmeUNvbXBsZXRlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZVNlcXVlbmNlSXRlbTsiLCIvKipcbiAqIENsaWVudC5cbiAqIEBtb2R1bGUgY2xpZW50XG4gKi9cblxudmFyIFNlcXVlbmNlciA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9TZXF1ZW5jZXJcIik7XG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZShcInlhZWRcIik7XG52YXIgTWVzc2FnZVNlcXVlbmNlSXRlbSA9IHJlcXVpcmUoXCIuL01lc3NhZ2VTZXF1ZW5jZUl0ZW1cIik7XG5cbi8qKlxuICogU2VxdWVuY2VzIG1lc3NhZ2VzLlxuICogQGNsYXNzIE1lc3NhZ2VTZXF1ZW5jZXJcbiAqL1xuZnVuY3Rpb24gTWVzc2FnZVNlcXVlbmNlcigpIHtcblx0dGhpcy5zZXF1ZW5jZXIgPSBuZXcgU2VxdWVuY2VyKCk7XG5cdHRoaXMubWVzc2FnZURpc3BhdGNoZXIgPSBuZXcgRXZlbnREaXNwYXRjaGVyKCk7XG5cdHRoaXMuY3VycmVudEl0ZW0gPSBudWxsO1xufVxuXG4vKipcbiAqIEFkZCBhIG1lc3NhZ2UgZm9yIHByb2Nlc2luZy5cbiAqIEBtZXRob2QgZW5xdWV1ZVxuICovXG5NZXNzYWdlU2VxdWVuY2VyLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXHRpZiAoIW1lc3NhZ2UudHlwZSlcblx0XHR0aHJvdyBcIk1lc3NhZ2UgZG9lc24ndCBoYXZlIGEgdHlwZVwiO1xuXG5cdHZhciBzZXF1ZW5jZUl0ZW0gPSBuZXcgTWVzc2FnZVNlcXVlbmNlSXRlbShtZXNzYWdlKTtcblxuXHRzZXF1ZW5jZUl0ZW0ub24oU2VxdWVuY2VyLlNUQVJULCB0aGlzLm9uU2VxdWVuY2VJdGVtU3RhcnQsIHRoaXMpO1xuXG5cdHRoaXMuc2VxdWVuY2VyLmVucXVldWUoc2VxdWVuY2VJdGVtKTtcbn1cblxuLyoqXG4gKiBTZXF1ZW5jZSBpdGVtIHN0YXJ0LlxuICogQG1ldGhvZCBvblNlcXVlbmNlSXRlbVN0YXJ0XG4gKiBAcHJpdmF0ZVxuICovXG5NZXNzYWdlU2VxdWVuY2VyLnByb3RvdHlwZS5vblNlcXVlbmNlSXRlbVN0YXJ0ID0gZnVuY3Rpb24oZSkge1xuXHQvL2NvbnNvbGUubG9nKFwic3RhcnRpbmcgaXRlbS4uLlwiKTtcblx0dmFyIGl0ZW0gPSBlLnRhcmdldDtcblxuXHRpdGVtLm9mZihTZXF1ZW5jZXIuU1RBUlQsIHRoaXMub25TZXF1ZW5jZUl0ZW1TdGFydCwgdGhpcyk7XG5cblx0dGhpcy5jdXJyZW50SXRlbSA9IGl0ZW07XG5cdHRoaXMubWVzc2FnZURpc3BhdGNoZXIudHJpZ2dlcihpdGVtLmdldE1lc3NhZ2UoKSk7XG5cdHRoaXMuY3VycmVudEl0ZW0gPSBudWxsO1xuXG5cdGlmICghaXRlbS5pc1dhaXRpbmcoKSlcblx0XHRpdGVtLm5vdGlmeUNvbXBsZXRlKCk7XG59XG5cbi8qKlxuICogQWRkIG1lc3NhZ2UgaGFuZGxlci5cbiAqIEBtZXRob2QgYWRkTWVzc2FnZUhhbmRsZXJcbiAqL1xuTWVzc2FnZVNlcXVlbmNlci5wcm90b3R5cGUuYWRkTWVzc2FnZUhhbmRsZXIgPSBmdW5jdGlvbihtZXNzYWdlVHlwZSwgaGFuZGxlciwgc2NvcGUpIHtcblx0dGhpcy5tZXNzYWdlRGlzcGF0Y2hlci5vbihtZXNzYWdlVHlwZSwgaGFuZGxlciwgc2NvcGUpO1xufVxuXG4vKipcbiAqIFdhaXQgZm9yIHRoZSB0YXJnZXQgdG8gZGlzcGF0Y2ggYW4gZXZlbnQgYmVmb3JlIGNvbnRpbnVpbmcgdG9cbiAqIHByb2Nlc3MgdGhlIG1lc3NhZ2VzIGluIHRoZSBxdWUuXG4gKiBAbWV0aG9kIHdhaXRGb3JcbiAqL1xuTWVzc2FnZVNlcXVlbmNlci5wcm90b3R5cGUud2FpdEZvciA9IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnQpIHtcblx0aWYgKCF0aGlzLmN1cnJlbnRJdGVtKVxuXHRcdHRocm93IFwiTm90IHdhaXRpbmcgZm9yIGV2ZW50XCI7XG5cblx0dGhpcy5jdXJyZW50SXRlbS53YWl0Rm9yKHRhcmdldCwgZXZlbnQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2VTZXF1ZW5jZXI7IiwiLyoqXG4gKiBDbGllbnQuXG4gKiBAbW9kdWxlIGNsaWVudFxuICovXG5cbnZhciBNZXNzYWdlU2VxdWVuY2VyID0gcmVxdWlyZShcIi4vTWVzc2FnZVNlcXVlbmNlclwiKTtcbnZhciBQcm90b0Nvbm5lY3Rpb24gPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vUHJvdG9Db25uZWN0aW9uXCIpO1xudmFyIEJ1dHRvbnNWaWV3ID0gcmVxdWlyZShcIi4uL3ZpZXcvQnV0dG9uc1ZpZXdcIik7XG52YXIgQnV0dG9uQ2xpY2tNZXNzYWdlID0gcmVxdWlyZShcIi4uLy4uL3Byb3RvL21lc3NhZ2VzL0J1dHRvbkNsaWNrTWVzc2FnZVwiKTtcbnZhciBTZWF0Q2xpY2tNZXNzYWdlID0gcmVxdWlyZShcIi4uLy4uL3Byb3RvL21lc3NhZ2VzL1NlYXRDbGlja01lc3NhZ2VcIik7XG52YXIgUHJlc2V0QnV0dG9uQ2xpY2tNZXNzYWdlID0gcmVxdWlyZShcIi4uLy4uL3Byb3RvL21lc3NhZ2VzL1ByZXNldEJ1dHRvbkNsaWNrTWVzc2FnZVwiKTtcbnZhciBOZXRQb2tlckNsaWVudFZpZXcgPSByZXF1aXJlKFwiLi4vdmlldy9OZXRQb2tlckNsaWVudFZpZXdcIik7XG52YXIgRGlhbG9nVmlldyA9IHJlcXVpcmUoXCIuLi92aWV3L0RpYWxvZ1ZpZXdcIik7XG52YXIgVGFibGVJbmZvVmlldyA9IHJlcXVpcmUoXCIuLi92aWV3L1RhYmxlSW5mb1ZpZXdcIik7XG52YXIgU2V0dGluZ3NWaWV3ID0gcmVxdWlyZShcIi4uL3ZpZXcvU2V0dGluZ3NWaWV3XCIpO1xudmFyIFRhYmxlQ29udHJvbGxlciA9IHJlcXVpcmUoXCIuL1RhYmxlQ29udHJvbGxlclwiKTtcbnZhciBJbnRlcmZhY2VDb250cm9sbGVyID0gcmVxdWlyZShcIi4vSW50ZXJmYWNlQ29udHJvbGxlclwiKTtcbnZhciBDaGF0TWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9DaGF0TWVzc2FnZVwiKTtcbnZhciBDaGVja2JveE1lc3NhZ2UgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vbWVzc2FnZXMvQ2hlY2tib3hNZXNzYWdlXCIpO1xudmFyIEJ1dHRvbkRhdGEgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vZGF0YS9CdXR0b25EYXRhXCIpO1xudmFyIFByZXNldEJ1dHRvbnNWaWV3ID0gcmVxdWlyZShcIi4uL3ZpZXcvUHJlc2V0QnV0dG9uc1ZpZXdcIik7XG5cbi8qKlxuICogTWFpbiBjb250cm9sbGVyXG4gKiBAY2xhc3MgTmV0UG9rZXJDbGllbnRDb250cm9sbGVyXG4gKi9cbmZ1bmN0aW9uIE5ldFBva2VyQ2xpZW50Q29udHJvbGxlcih2aWV3KSB7XG5cdHRoaXMubmV0UG9rZXJDbGllbnRWaWV3ID0gdmlldztcblx0dGhpcy5wcm90b0Nvbm5lY3Rpb24gPSBudWxsO1xuXHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIgPSBuZXcgTWVzc2FnZVNlcXVlbmNlcigpO1xuXG5cdHRoaXMudGFibGVDb250cm9sbGVyID0gbmV3IFRhYmxlQ29udHJvbGxlcih0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIsIHRoaXMubmV0UG9rZXJDbGllbnRWaWV3KTtcblx0dGhpcy5pbnRlcmZhY2VDb250cm9sbGVyID0gbmV3IEludGVyZmFjZUNvbnRyb2xsZXIodGhpcy5tZXNzYWdlU2VxdWVuY2VyLCB0aGlzLm5ldFBva2VyQ2xpZW50Vmlldyk7XG5cblx0Ly9jb25zb2xlLmxvZyh0aGlzLm5ldFBva2VyQ2xpZW50Vmlldy5nZXREaWFsb2dWaWV3KCkpO1xuXG5cdHRoaXMubmV0UG9rZXJDbGllbnRWaWV3LmdldEJ1dHRvbnNWaWV3KCkub24oQnV0dG9uc1ZpZXcuQlVUVE9OX0NMSUNLLCB0aGlzLm9uQnV0dG9uQ2xpY2ssIHRoaXMpO1xuXHR0aGlzLm5ldFBva2VyQ2xpZW50Vmlldy5nZXRUYWJsZUluZm9WaWV3KCkub24oVGFibGVJbmZvVmlldy5CVVRUT05fQ0xJQ0ssIHRoaXMub25CdXR0b25DbGljaywgdGhpcyk7XG5cdHRoaXMubmV0UG9rZXJDbGllbnRWaWV3LmdldERpYWxvZ1ZpZXcoKS5vbihEaWFsb2dWaWV3LkJVVFRPTl9DTElDSywgdGhpcy5vbkJ1dHRvbkNsaWNrLCB0aGlzKTtcblx0dGhpcy5uZXRQb2tlckNsaWVudFZpZXcub24oTmV0UG9rZXJDbGllbnRWaWV3LlNFQVRfQ0xJQ0ssIHRoaXMub25TZWF0Q2xpY2ssIHRoaXMpO1xuXG5cdHRoaXMubmV0UG9rZXJDbGllbnRWaWV3LmNoYXRWaWV3LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGF0XCIsIHRoaXMub25WaWV3Q2hhdCwgdGhpcyk7XG5cdHRoaXMubmV0UG9rZXJDbGllbnRWaWV3LnNldHRpbmdzVmlldy5hZGRFdmVudExpc3RlbmVyKFNldHRpbmdzVmlldy5CVVlfQ0hJUFNfQ0xJQ0ssIHRoaXMub25CdXlDaGlwc0J1dHRvbkNsaWNrLCB0aGlzKTtcblx0dGhpcy5uZXRQb2tlckNsaWVudFZpZXcuc2V0dGluZ3NWaWV3LmFkZEV2ZW50TGlzdGVuZXIoU2V0dGluZ3NWaWV3LkNIRUNLQk9YX0NIQU5HRSwgdGhpcy5vbkNoZWNrYm94Q2hhbmdlLCB0aGlzKTtcblxuXHR0aGlzLm5ldFBva2VyQ2xpZW50Vmlldy5nZXRQcmVzZXRCdXR0b25zVmlldygpLmFkZEV2ZW50TGlzdGVuZXIoUHJlc2V0QnV0dG9uc1ZpZXcuQ0hBTkdFLCB0aGlzLm9uUHJlc2V0QnV0dG9uc0NoYW5nZSwgdGhpcyk7XG59XG5cblxuLyoqXG4gKiBTZXQgY29ubmVjdGlvbi5cbiAqIEBtZXRob2Qgc2V0UHJvdG9Db25uZWN0aW9uXG4gKi9cbk5ldFBva2VyQ2xpZW50Q29udHJvbGxlci5wcm90b3R5cGUuc2V0UHJvdG9Db25uZWN0aW9uID0gZnVuY3Rpb24ocHJvdG9Db25uZWN0aW9uKSB7XG5cdGlmICh0aGlzLnByb3RvQ29ubmVjdGlvbikge1xuXHRcdHRoaXMucHJvdG9Db25uZWN0aW9uLm9mZihQcm90b0Nvbm5lY3Rpb24uTUVTU0FHRSwgdGhpcy5vblByb3RvQ29ubmVjdGlvbk1lc3NhZ2UsIHRoaXMpO1xuXHR9XG5cblx0dGhpcy5wcm90b0Nvbm5lY3Rpb24gPSBwcm90b0Nvbm5lY3Rpb247XG5cdHRoaXMubmV0UG9rZXJDbGllbnRWaWV3LmNsZWFyKCk7XG5cblx0aWYgKHRoaXMucHJvdG9Db25uZWN0aW9uKSB7XG5cdFx0dGhpcy5wcm90b0Nvbm5lY3Rpb24ub24oUHJvdG9Db25uZWN0aW9uLk1FU1NBR0UsIHRoaXMub25Qcm90b0Nvbm5lY3Rpb25NZXNzYWdlLCB0aGlzKTtcblx0fVxufVxuXG4vKipcbiAqIEluY29taW5nIG1lc3NhZ2UuXG4gKiBFbnF1ZXVlIGZvciBwcm9jZXNzaW5nLlxuICrCoEBtZXRob2Qgb25Qcm90b0Nvbm5lY3Rpb25NZXNzYWdlXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRQb2tlckNsaWVudENvbnRyb2xsZXIucHJvdG90eXBlLm9uUHJvdG9Db25uZWN0aW9uTWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcblx0dGhpcy5tZXNzYWdlU2VxdWVuY2VyLmVucXVldWUoZS5tZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBCdXR0b24gY2xpY2suXG4gKiBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgY2xpY2tzIGZyb20gYm90aCB0aGUgZGlhbG9nIGFuZCBnYW1lIHBsYXkgYnV0dG9ucy5cbiAqIEBtZXRob2Qgb25CdXR0b25DbGlja1xuICogQHByaXZhdGVcbiAqL1xuTmV0UG9rZXJDbGllbnRDb250cm9sbGVyLnByb3RvdHlwZS5vbkJ1dHRvbkNsaWNrID0gZnVuY3Rpb24oZSkge1xuXHRpZiAoIXRoaXMucHJvdG9Db25uZWN0aW9uKVxuXHRcdHJldHVybjtcblxuXHRjb25zb2xlLmxvZyhcImJ1dHRvbiBjbGljaywgdj1cIiArIGUudmFsdWUpO1xuXG5cdHZhciBtID0gbmV3IEJ1dHRvbkNsaWNrTWVzc2FnZShlLmJ1dHRvbiwgZS52YWx1ZSk7XG5cdHRoaXMucHJvdG9Db25uZWN0aW9uLnNlbmQobSk7XG59XG5cbi8qKlxuICogU2VhdCBjbGljay5cbiAqIEBtZXRob2Qgb25TZWF0Q2xpY2tcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFBva2VyQ2xpZW50Q29udHJvbGxlci5wcm90b3R5cGUub25TZWF0Q2xpY2sgPSBmdW5jdGlvbihlKSB7XG5cdHZhciBtID0gbmV3IFNlYXRDbGlja01lc3NhZ2UoZS5zZWF0SW5kZXgpO1xuXHR0aGlzLnByb3RvQ29ubmVjdGlvbi5zZW5kKG0pO1xufVxuXG4vKipcbiAqIE9uIHNlbmQgY2hhdCBtZXNzYWdlLlxuICogQG1ldGhvZCBvblZpZXdDaGF0XG4gKi9cbk5ldFBva2VyQ2xpZW50Q29udHJvbGxlci5wcm90b3R5cGUub25WaWV3Q2hhdCA9IGZ1bmN0aW9uKGUpIHtcblx0dmFyIG1lc3NhZ2UgPSBuZXcgQ2hhdE1lc3NhZ2UoKTtcblx0bWVzc2FnZS51c2VyID0gXCJcIjtcblx0bWVzc2FnZS50ZXh0ID0gZS50ZXh0O1xuXG5cdHRoaXMucHJvdG9Db25uZWN0aW9uLnNlbmQobWVzc2FnZSk7XG59XG5cbi8qKlxuICogT24gYnV5IGNoaXBzIGJ1dHRvbiBjbGljay5cbiAqIEBtZXRob2Qgb25CdXlDaGlwc0J1dHRvbkNsaWNrXG4gKi9cbk5ldFBva2VyQ2xpZW50Q29udHJvbGxlci5wcm90b3R5cGUub25CdXlDaGlwc0J1dHRvbkNsaWNrID0gZnVuY3Rpb24oKSB7XG5cdGNvbnNvbGUubG9nKFwiYnV5IGNoaXBzIGNsaWNrXCIpO1xuXG5cdHRoaXMucHJvdG9Db25uZWN0aW9uLnNlbmQobmV3IEJ1dHRvbkNsaWNrTWVzc2FnZShCdXR0b25EYXRhLkJVWV9DSElQUykpO1xufVxuXG4vKipcbiAqIFByZXNldEJ1dHRvbnMgY2hhbmdlIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIG9uUHJlc2V0QnV0dG9uc0NoYW5nZVxuICovXG5OZXRQb2tlckNsaWVudENvbnRyb2xsZXIucHJvdG90eXBlLm9uUHJlc2V0QnV0dG9uc0NoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgcHJlc2V0QnV0dG9uc1ZpZXcgPSB0aGlzLm5ldFBva2VyQ2xpZW50Vmlldy5nZXRQcmVzZXRCdXR0b25zVmlldygpO1xuXHR2YXIgbWVzc2FnZSA9IG5ldyBQcmVzZXRCdXR0b25DbGlja01lc3NhZ2UoKTtcblxuXHR2YXIgYyA9IHByZXNldEJ1dHRvbnNWaWV3LmdldEN1cnJlbnQoKTtcblx0aWYgKGMgIT0gbnVsbCkge1xuXHRcdG1lc3NhZ2UuYnV0dG9uID0gYy5pZDtcblx0XHRtZXNzYWdlLnZhbHVlID0gYy52YWx1ZTtcblx0fVxuXG5cdHRoaXMucHJvdG9Db25uZWN0aW9uLnNlbmQobWVzc2FnZSk7XG59XG5cbi8qKlxuICogQ2hlY2tib3ggY2hhbmdlLlxuICogQG1ldGhvZCBvbkNoZWNrYm94Q2hhbmdlXG4gKi9cbk5ldFBva2VyQ2xpZW50Q29udHJvbGxlci5wcm90b3R5cGUub25DaGVja2JveENoYW5nZSA9IGZ1bmN0aW9uKGV2KSB7XG5cdHRoaXMucHJvdG9Db25uZWN0aW9uLnNlbmQobmV3IENoZWNrYm94TWVzc2FnZShldi5jaGVja2JveElkLCBldi5jaGVja2VkKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTmV0UG9rZXJDbGllbnRDb250cm9sbGVyOyIsIi8qKlxuICogQ2xpZW50LlxuICogQG1vZHVsZSBjbGllbnRcbiAqL1xuXG52YXIgU2VhdEluZm9NZXNzYWdlID0gcmVxdWlyZShcIi4uLy4uL3Byb3RvL21lc3NhZ2VzL1NlYXRJbmZvTWVzc2FnZVwiKTtcbnZhciBDb21tdW5pdHlDYXJkc01lc3NhZ2UgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vbWVzc2FnZXMvQ29tbXVuaXR5Q2FyZHNNZXNzYWdlXCIpO1xudmFyIFBvY2tldENhcmRzTWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9Qb2NrZXRDYXJkc01lc3NhZ2VcIik7XG52YXIgRGVhbGVyQnV0dG9uTWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9EZWFsZXJCdXR0b25NZXNzYWdlXCIpO1xudmFyIEJldE1lc3NhZ2UgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vbWVzc2FnZXMvQmV0TWVzc2FnZVwiKTtcbnZhciBCZXRzVG9Qb3RNZXNzYWdlID0gcmVxdWlyZShcIi4uLy4uL3Byb3RvL21lc3NhZ2VzL0JldHNUb1BvdE1lc3NhZ2VcIik7XG52YXIgUG90TWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9Qb3RNZXNzYWdlXCIpO1xudmFyIFRpbWVyTWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9UaW1lck1lc3NhZ2VcIik7XG52YXIgQWN0aW9uTWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9BY3Rpb25NZXNzYWdlXCIpO1xudmFyIEZvbGRDYXJkc01lc3NhZ2UgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vbWVzc2FnZXMvRm9sZENhcmRzTWVzc2FnZVwiKTtcbnZhciBEZWxheU1lc3NhZ2UgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vbWVzc2FnZXMvRGVsYXlNZXNzYWdlXCIpO1xudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoXCJ5YWVkXCIpO1xudmFyIENsZWFyTWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9DbGVhck1lc3NhZ2VcIik7XG52YXIgUGF5T3V0TWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9QYXlPdXRNZXNzYWdlXCIpO1xuXG4vKipcbiAqIENvbnRyb2wgdGhlIHRhYmxlXG4gKiBAY2xhc3MgVGFibGVDb250cm9sbGVyXG4gKi9cbmZ1bmN0aW9uIFRhYmxlQ29udHJvbGxlcihtZXNzYWdlU2VxdWVuY2VyLCB2aWV3KSB7XG5cdHRoaXMubWVzc2FnZVNlcXVlbmNlciA9IG1lc3NhZ2VTZXF1ZW5jZXI7XG5cdHRoaXMudmlldyA9IHZpZXc7XG5cblx0dGhpcy5tZXNzYWdlU2VxdWVuY2VyLmFkZE1lc3NhZ2VIYW5kbGVyKFNlYXRJbmZvTWVzc2FnZS5UWVBFLCB0aGlzLm9uU2VhdEluZm9NZXNzYWdlLCB0aGlzKTtcblx0dGhpcy5tZXNzYWdlU2VxdWVuY2VyLmFkZE1lc3NhZ2VIYW5kbGVyKENvbW11bml0eUNhcmRzTWVzc2FnZS5UWVBFLCB0aGlzLm9uQ29tbXVuaXR5Q2FyZHNNZXNzYWdlLCB0aGlzKTtcblx0dGhpcy5tZXNzYWdlU2VxdWVuY2VyLmFkZE1lc3NhZ2VIYW5kbGVyKFBvY2tldENhcmRzTWVzc2FnZS5UWVBFLCB0aGlzLm9uUG9ja2V0Q2FyZHNNZXNzYWdlLCB0aGlzKTtcblx0dGhpcy5tZXNzYWdlU2VxdWVuY2VyLmFkZE1lc3NhZ2VIYW5kbGVyKERlYWxlckJ1dHRvbk1lc3NhZ2UuVFlQRSwgdGhpcy5vbkRlYWxlckJ1dHRvbk1lc3NhZ2UsIHRoaXMpO1xuXHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIuYWRkTWVzc2FnZUhhbmRsZXIoQmV0TWVzc2FnZS5UWVBFLCB0aGlzLm9uQmV0TWVzc2FnZSwgdGhpcyk7XG5cdHRoaXMubWVzc2FnZVNlcXVlbmNlci5hZGRNZXNzYWdlSGFuZGxlcihCZXRzVG9Qb3RNZXNzYWdlLlRZUEUsIHRoaXMub25CZXRzVG9Qb3QsIHRoaXMpO1xuXHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIuYWRkTWVzc2FnZUhhbmRsZXIoUG90TWVzc2FnZS5UWVBFLCB0aGlzLm9uUG90LCB0aGlzKTtcblx0dGhpcy5tZXNzYWdlU2VxdWVuY2VyLmFkZE1lc3NhZ2VIYW5kbGVyKFRpbWVyTWVzc2FnZS5UWVBFLCB0aGlzLm9uVGltZXIsIHRoaXMpO1xuXHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIuYWRkTWVzc2FnZUhhbmRsZXIoQWN0aW9uTWVzc2FnZS5UWVBFLCB0aGlzLm9uQWN0aW9uLCB0aGlzKTtcblx0dGhpcy5tZXNzYWdlU2VxdWVuY2VyLmFkZE1lc3NhZ2VIYW5kbGVyKEZvbGRDYXJkc01lc3NhZ2UuVFlQRSwgdGhpcy5vbkZvbGRDYXJkcywgdGhpcyk7XG5cdHRoaXMubWVzc2FnZVNlcXVlbmNlci5hZGRNZXNzYWdlSGFuZGxlcihEZWxheU1lc3NhZ2UuVFlQRSwgdGhpcy5vbkRlbGF5LCB0aGlzKTtcblx0dGhpcy5tZXNzYWdlU2VxdWVuY2VyLmFkZE1lc3NhZ2VIYW5kbGVyKENsZWFyTWVzc2FnZS5UWVBFLCB0aGlzLm9uQ2xlYXIsIHRoaXMpO1xuXHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIuYWRkTWVzc2FnZUhhbmRsZXIoUGF5T3V0TWVzc2FnZS5UWVBFLCB0aGlzLm9uUGF5T3V0LCB0aGlzKTtcbn1cbkV2ZW50RGlzcGF0Y2hlci5pbml0KFRhYmxlQ29udHJvbGxlcik7XG5cbi8qKlxuICogU2VhdCBpbmZvIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIG9uU2VhdEluZm9NZXNzYWdlXG4gKi9cblRhYmxlQ29udHJvbGxlci5wcm90b3R5cGUub25TZWF0SW5mb01lc3NhZ2UgPSBmdW5jdGlvbihtKSB7XG5cdHZhciBzZWF0VmlldyA9IHRoaXMudmlldy5nZXRTZWF0Vmlld0J5SW5kZXgobS5nZXRTZWF0SW5kZXgoKSk7XG5cblx0c2VhdFZpZXcuc2V0TmFtZShtLmdldE5hbWUoKSk7XG5cdHNlYXRWaWV3LnNldENoaXBzKG0uZ2V0Q2hpcHMoKSk7XG5cdHNlYXRWaWV3LnNldEFjdGl2ZShtLmlzQWN0aXZlKCkpO1xuXHRzZWF0Vmlldy5zZXRTaXRvdXQobS5pc1NpdG91dCgpKTtcbn1cblxuLyoqXG4gKiBTZWF0IGluZm8gbWVzc2FnZS5cbiAqIEBtZXRob2Qgb25Db21tdW5pdHlDYXJkc01lc3NhZ2VcbiAqL1xuVGFibGVDb250cm9sbGVyLnByb3RvdHlwZS5vbkNvbW11bml0eUNhcmRzTWVzc2FnZSA9IGZ1bmN0aW9uKG0pIHtcblx0dmFyIGk7XG5cblx0Y29uc29sZS5sb2coXCJnb3QgY29tbXVuaXR5IGNhcmRzIVwiKTtcblx0Y29uc29sZS5sb2cobSk7XG5cblx0Zm9yIChpID0gMDsgaSA8IG0uZ2V0Q2FyZHMoKS5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBjYXJkRGF0YSA9IG0uZ2V0Q2FyZHMoKVtpXTtcblx0XHR2YXIgY2FyZFZpZXcgPSB0aGlzLnZpZXcuZ2V0Q29tbXVuaXR5Q2FyZHMoKVttLmdldEZpcnN0SW5kZXgoKSArIGldO1xuXG5cdFx0Y2FyZFZpZXcuc2V0Q2FyZERhdGEoY2FyZERhdGEpO1xuXHRcdGNhcmRWaWV3LnNob3cobS5hbmltYXRlLCBpICogNTAwKTtcblx0fVxuXHRpZiAobS5nZXRDYXJkcygpLmxlbmd0aCA+IDApIHtcblx0XHR2YXIgY2FyZERhdGEgPSBtLmdldENhcmRzKClbbS5nZXRDYXJkcygpLmxlbmd0aCAtIDFdO1xuXHRcdHZhciBjYXJkVmlldyA9IHRoaXMudmlldy5nZXRDb21tdW5pdHlDYXJkcygpW20uZ2V0Rmlyc3RJbmRleCgpICsgbS5nZXRDYXJkcygpLmxlbmd0aCAtIDFdO1xuXHRcdGlmKG0uYW5pbWF0ZSlcblx0XHRcdHRoaXMubWVzc2FnZVNlcXVlbmNlci53YWl0Rm9yKGNhcmRWaWV3LCBcImFuaW1hdGlvbkRvbmVcIik7XG5cdH1cbn1cblxuLyoqXG4gKiBQb2NrZXQgY2FyZHMgbWVzc2FnZS5cbiAqIEBtZXRob2Qgb25Qb2NrZXRDYXJkc01lc3NhZ2VcbiAqL1xuVGFibGVDb250cm9sbGVyLnByb3RvdHlwZS5vblBvY2tldENhcmRzTWVzc2FnZSA9IGZ1bmN0aW9uKG0pIHtcblx0dmFyIHNlYXRWaWV3ID0gdGhpcy52aWV3LmdldFNlYXRWaWV3QnlJbmRleChtLmdldFNlYXRJbmRleCgpKTtcblx0dmFyIGk7XG5cblx0Zm9yIChpID0gMDsgaSA8IG0uZ2V0Q2FyZHMoKS5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBjYXJkRGF0YSA9IG0uZ2V0Q2FyZHMoKVtpXTtcblx0XHR2YXIgY2FyZFZpZXcgPSBzZWF0Vmlldy5nZXRQb2NrZXRDYXJkcygpW20uZ2V0Rmlyc3RJbmRleCgpICsgaV07XG5cblx0XHRpZihtLmFuaW1hdGUpXG5cdFx0XHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIud2FpdEZvcihjYXJkVmlldywgXCJhbmltYXRpb25Eb25lXCIpO1xuXHRcdGNhcmRWaWV3LnNldENhcmREYXRhKGNhcmREYXRhKTtcblx0XHRjYXJkVmlldy5zaG93KG0uYW5pbWF0ZSwgMTApO1xuXHR9XG59XG5cbi8qKlxuICogRGVhbGVyIGJ1dHRvbiBtZXNzYWdlLlxuICogQG1ldGhvZCBvbkRlYWxlckJ1dHRvbk1lc3NhZ2VcbiAqL1xuVGFibGVDb250cm9sbGVyLnByb3RvdHlwZS5vbkRlYWxlckJ1dHRvbk1lc3NhZ2UgPSBmdW5jdGlvbihtKSB7XG5cdHZhciBkZWFsZXJCdXR0b25WaWV3ID0gdGhpcy52aWV3LmdldERlYWxlckJ1dHRvblZpZXcoKTtcblxuXHRpZiAobS5zZWF0SW5kZXggPCAwKSB7XG5cdFx0ZGVhbGVyQnV0dG9uVmlldy5oaWRlKCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5tZXNzYWdlU2VxdWVuY2VyLndhaXRGb3IoZGVhbGVyQnV0dG9uVmlldywgXCJhbmltYXRpb25Eb25lXCIpO1xuXHRcdGRlYWxlckJ1dHRvblZpZXcuc2hvdyhtLmdldFNlYXRJbmRleCgpLCBtLmdldEFuaW1hdGUoKSk7XG5cdH1cbn07XG5cbi8qKlxuICogQmV0IG1lc3NhZ2UuXG4gKiBAbWV0aG9kIG9uQmV0TWVzc2FnZVxuICovXG5UYWJsZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uQmV0TWVzc2FnZSA9IGZ1bmN0aW9uKG0pIHtcblx0dGhpcy52aWV3LnNlYXRWaWV3c1ttLnNlYXRJbmRleF0uYmV0Q2hpcHMuc2V0VmFsdWUobS52YWx1ZSk7XG59O1xuXG4vKipcbiAqIEJldHMgdG8gcG90LlxuICogQG1ldGhvZCBvbkJldHNUb1BvdFxuICovXG5UYWJsZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uQmV0c1RvUG90ID0gZnVuY3Rpb24obSkge1xuXHR2YXIgaGF2ZUNoaXBzID0gZmFsc2U7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZpZXcuc2VhdFZpZXdzLmxlbmd0aDsgaSsrKVxuXHRcdGlmICh0aGlzLnZpZXcuc2VhdFZpZXdzW2ldLmJldENoaXBzLnZhbHVlID4gMClcblx0XHRcdGhhdmVDaGlwcyA9IHRydWU7XG5cblx0aWYgKCFoYXZlQ2hpcHMpXG5cdFx0cmV0dXJuO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52aWV3LnNlYXRWaWV3cy5sZW5ndGg7IGkrKylcblx0XHR0aGlzLnZpZXcuc2VhdFZpZXdzW2ldLmJldENoaXBzLmFuaW1hdGVJbigpO1xuXG5cdHRoaXMubWVzc2FnZVNlcXVlbmNlci53YWl0Rm9yKHRoaXMudmlldy5zZWF0Vmlld3NbMF0uYmV0Q2hpcHMsIFwiYW5pbWF0aW9uRG9uZVwiKTtcbn1cblxuLyoqXG4gKiBQb3QgbWVzc2FnZS5cbiAqIEBtZXRob2Qgb25Qb3RcbiAqL1xuVGFibGVDb250cm9sbGVyLnByb3RvdHlwZS5vblBvdCA9IGZ1bmN0aW9uKG0pIHtcblx0dGhpcy52aWV3LnBvdFZpZXcuc2V0VmFsdWVzKG0udmFsdWVzKTtcbn07XG5cbi8qKlxuICogVGltZXIgbWVzc2FnZS5cbiAqIEBtZXRob2Qgb25UaW1lclxuICovXG5UYWJsZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uVGltZXIgPSBmdW5jdGlvbihtKSB7XG5cdGlmIChtLnNlYXRJbmRleCA8IDApXG5cdFx0dGhpcy52aWV3LnRpbWVyVmlldy5oaWRlKCk7XG5cblx0ZWxzZSB7XG5cdFx0dGhpcy52aWV3LnRpbWVyVmlldy5zaG93KG0uc2VhdEluZGV4KTtcblx0XHR0aGlzLnZpZXcudGltZXJWaWV3LmNvdW50ZG93bihtLnRvdGFsVGltZSwgbS50aW1lTGVmdCk7XG5cdH1cbn07XG5cbi8qKlxuICogQWN0aW9uIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIG9uQWN0aW9uXG4gKi9cblRhYmxlQ29udHJvbGxlci5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihtKSB7XG5cdGlmIChtLnNlYXRJbmRleCA9PSBudWxsKVxuXHRcdG0uc2VhdEluZGV4ID0gMDtcblxuXHR0aGlzLnZpZXcuc2VhdFZpZXdzW20uc2VhdEluZGV4XS5hY3Rpb24obS5hY3Rpb24pO1xufTtcblxuLyoqXG4gKiBGb2xkIGNhcmRzIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIG9uRm9sZENhcmRzXG4gKi9cblRhYmxlQ29udHJvbGxlci5wcm90b3R5cGUub25Gb2xkQ2FyZHMgPSBmdW5jdGlvbihtKSB7XG5cdHRoaXMudmlldy5zZWF0Vmlld3NbbS5zZWF0SW5kZXhdLmZvbGRDYXJkcygpO1xuXG5cdHRoaXMubWVzc2FnZVNlcXVlbmNlci53YWl0Rm9yKHRoaXMudmlldy5zZWF0Vmlld3NbbS5zZWF0SW5kZXhdLCBcImFuaW1hdGlvbkRvbmVcIik7XG59O1xuXG4vKipcbiAqIERlbGF5IG1lc3NhZ2UuXG4gKiBAbWV0aG9kIG9uRGVsYXlcbiAqL1xuVGFibGVDb250cm9sbGVyLnByb3RvdHlwZS5vbkRlbGF5ID0gZnVuY3Rpb24obSkge1xuXHRjb25zb2xlLmxvZyhcImRlbGF5IGZvciAgPSBcIiArIG0uZGVsYXkpO1xuXG5cblx0dGhpcy5tZXNzYWdlU2VxdWVuY2VyLndhaXRGb3IodGhpcywgXCJ0aW1lckRvbmVcIik7XG5cdHNldFRpbWVvdXQodGhpcy5kaXNwYXRjaEV2ZW50LmJpbmQodGhpcywgXCJ0aW1lckRvbmVcIiksIG0uZGVsYXkpO1xuXG59O1xuXG4vKipcbiAqIENsZWFyIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIG9uQ2xlYXJcbiAqL1xuVGFibGVDb250cm9sbGVyLnByb3RvdHlwZS5vbkNsZWFyID0gZnVuY3Rpb24obSkge1xuXG5cdHZhciBjb21wb25lbnRzID0gbS5nZXRDb21wb25lbnRzKCk7XG5cblx0Zm9yKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRzd2l0Y2goY29tcG9uZW50c1tpXSkge1xuXHRcdFx0Y2FzZSBDbGVhck1lc3NhZ2UuUE9UOiB7XG5cdFx0XHRcdHRoaXMudmlldy5wb3RWaWV3LnNldFZhbHVlcyhbXSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0Y2FzZSBDbGVhck1lc3NhZ2UuQkVUUzoge1xuXHRcdFx0XHRmb3IodmFyIHMgPSAwOyBzIDwgdGhpcy52aWV3LnNlYXRWaWV3cy5sZW5ndGg7IHMrKykge1xuXHRcdFx0XHRcdHRoaXMudmlldy5zZWF0Vmlld3Nbc10uYmV0Q2hpcHMuc2V0VmFsdWUoMCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRjYXNlIENsZWFyTWVzc2FnZS5DQVJEUzoge1xuXHRcdFx0XHRmb3IodmFyIHMgPSAwOyBzIDwgdGhpcy52aWV3LnNlYXRWaWV3cy5sZW5ndGg7IHMrKykge1xuXHRcdFx0XHRcdGZvcih2YXIgYyA9IDA7IGMgPCB0aGlzLnZpZXcuc2VhdFZpZXdzW3NdLnBvY2tldENhcmRzLmxlbmd0aDsgYysrKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnZpZXcuc2VhdFZpZXdzW3NdLnBvY2tldENhcmRzW2NdLmhpZGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IodmFyIGMgPSAwOyBjIDwgdGhpcy52aWV3LmNvbW11bml0eUNhcmRzLmxlbmd0aDsgYysrKSB7XG5cdFx0XHRcdFx0dGhpcy52aWV3LmNvbW11bml0eUNhcmRzW2NdLmhpZGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGNhc2UgQ2xlYXJNZXNzYWdlLkNIQVQ6IHtcblx0XHRcdFx0dGhpcy52aWV3LmNoYXRWaWV3LmNsZWFyKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFBheSBvdXQgbWVzc2FnZS5cbiAqIEBtZXRob2Qgb25QYXlPdXRcbiAqL1xuVGFibGVDb250cm9sbGVyLnByb3RvdHlwZS5vblBheU91dCA9IGZ1bmN0aW9uKG0pIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtLnZhbHVlcy5sZW5ndGg7IGkrKylcblx0XHR0aGlzLnZpZXcuc2VhdFZpZXdzW2ldLmJldENoaXBzLnNldFZhbHVlKG0udmFsdWVzW2ldKTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmlldy5zZWF0Vmlld3MubGVuZ3RoOyBpKyspXG5cdFx0dGhpcy52aWV3LnNlYXRWaWV3c1tpXS5iZXRDaGlwcy5hbmltYXRlT3V0KCk7XG5cblx0dGhpcy5tZXNzYWdlU2VxdWVuY2VyLndhaXRGb3IodGhpcy52aWV3LnNlYXRWaWV3c1swXS5iZXRDaGlwcywgXCJhbmltYXRpb25Eb25lXCIpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFRhYmxlQ29udHJvbGxlcjsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJ0YWJsZUJhY2tncm91bmRcIjogXCJfX3RhYmxlLnBuZ1wiLFxuXHRcInNlYXRQbGF0ZVwiOiBcIl9fc2VhdFBsYXRlLnBuZ1wiLFxuXHRcInRpbWVyQmFja2dyb3VuZFwiOiBcIl9fdGltZXJCYWNrZ3JvdW5kLnBuZ1wiLFxuXHRcImRlYWxlckJ1dHRvblwiOiBcIl9fZGVhbGVyQnV0dG9uLnBuZ1wiLFxuXHRcImNhcmRGcmFtZVwiOiBcIl9fY2FyZEZyYW1lLnBuZ1wiLFxuXHRcImNhcmRCYWNrXCI6IFwiX19jYXJkQmFjay5wbmdcIixcblx0XCJzdWl0U3ltYm9sMFwiOiBcIl9fc3VpdFN5bWJvbDAucG5nXCIsXG5cdFwic3VpdFN5bWJvbDFcIjogXCJfX3N1aXRTeW1ib2wxLnBuZ1wiLFxuXHRcInN1aXRTeW1ib2wyXCI6IFwiX19zdWl0U3ltYm9sMi5wbmdcIixcblx0XCJzdWl0U3ltYm9sM1wiOiBcIl9fc3VpdFN5bWJvbDMucG5nXCIsXG5cdFwiY2hpcDBcIjogXCJfX2NoaXAwLnBuZ1wiLFxuXHRcImNoaXAxXCI6IFwiX19jaGlwMS5wbmdcIixcblx0XCJjaGlwMlwiOiBcIl9fY2hpcDIucG5nXCIsXG5cdFwiY2hpcDNcIjogXCJfX2NoaXAzLnBuZ1wiLFxuXHRcImNoaXA0XCI6IFwiX19jaGlwNC5wbmdcIixcblx0XCJkaXZpZGVyTGluZVwiOiBcIl9fZGl2aWRlckxpbmUucG5nXCIsXG5cdFwiZnJhbWVQbGF0ZVwiOiBcIl9fZnJhbWVQbGF0ZS5wbmdcIixcblx0XCJiaWdCdXR0b25cIjogXCJfX2JpZ0J1dHRvbi5wbmdcIixcblx0XCJkaWFsb2dCdXR0b25cIjogXCJfX2RpYWxvZ0J1dHRvbi5wbmdcIixcblx0XCJ0ZXh0U2Nyb2xsYmFyVHJhY2tcIjogXCJfX3RleHRTY3JvbGxiYXJUcmFjay5wbmdcIixcblx0XCJ0ZXh0U2Nyb2xsYmFyVGh1bWJcIjogXCJfX3RleHRTY3JvbGxiYXJUaHVtYi5wbmdcIixcblx0XCJ3cmVuY2hJY29uXCI6IFwiX193cmVuY2hJY29uLnBuZ1wiLFxuXHRcImNoYXRCYWNrZ3JvdW5kXCI6IFwiX19jaGF0QmFja2dyb3VuZC5wbmdcIixcblx0XCJjaGVja2JveEJhY2tncm91bmRcIjogXCJfX2NoZWNrYm94QmFja2dyb3VuZC5wbmdcIixcblx0XCJjaGVja2JveFRpY2tcIjogXCJfX2NoZWNrYm94VGljay5wbmdcIixcblx0XCJidXR0b25CYWNrZ3JvdW5kXCI6IFwiX19idXR0b25CYWNrZ3JvdW5kLnBuZ1wiLFxuXHRcInNsaWRlckJhY2tncm91bmRcIjogXCJfX3NsaWRlckJhY2tncm91bmQucG5nXCIsXG5cdFwic2xpZGVyS25vYlwiOiBcIl9fc2xpZGVyS25vYi5wbmdcIixcblx0XCJ1cEFycm93XCI6IFwiX191cEFycm93LnBuZ1wiLFxuXG5cdFwiY2hpcHNDb2xvcjBcIjogMHg0MDQwNDAsXG5cdFwiY2hpcHNDb2xvcjFcIjogMHgwMDgwMDAsXG5cdFwiY2hpcHNDb2xvcjJcIjogMHg4MDgwMDAsXG5cdFwiY2hpcHNDb2xvcjNcIjogMHgwMDAwODAsXG5cdFwiY2hpcHNDb2xvcjRcIjogMHhmZjAwMDAsXG5cblx0XCJjb21tdW5pdHlDYXJkTWFyZ2luXCI6IDEsXG5cdFwiYmV0QWxpZ25cIjogXCJMQ1JSUlJDTExMXCIsXG5cblx0XCJ0YWJsZVBvc2l0aW9uXCI6IFsxMDEsIDk0XSxcblx0XCJwb3RQb3NpdGlvblwiOiBbNDg1LCAzMTVdLFxuXG5cdFwidGltZXJPZmZzZXRcIjogWzU1LCAtMzBdLFxuXHRcImNvbW11bml0eUNhcmRzUG9zaXRpb25cIjogWzI1NSwgMTkwXSxcblxuXHRcInNlYXRQb3NpdGlvbjBcIjogWzI4NywgMTE4XSxcblx0XCJzZWF0UG9zaXRpb24xXCI6IFs0ODMsIDExMl0sXG5cdFwic2VhdFBvc2l0aW9uMlwiOiBbNjc2LCAxMThdLFxuXHRcInNlYXRQb3NpdGlvbjNcIjogWzg0NCwgMjQ3XSxcblx0XCJzZWF0UG9zaXRpb240XCI6IFs4MTcsIDQxM10sXG5cdFwic2VhdFBvc2l0aW9uNVwiOiBbNjc2LCA0OTBdLFxuXHRcInNlYXRQb3NpdGlvbjZcIjogWzQ4MywgNDk1XSxcblx0XCJzZWF0UG9zaXRpb243XCI6IFsyODcsIDQ5MF0sXG5cdFwic2VhdFBvc2l0aW9uOFwiOiBbMTQwLCA0MTNdLFxuXHRcInNlYXRQb3NpdGlvbjlcIjogWzEyMywgMjQ3XSxcblxuXHRcImRlYWxlckJ1dHRvblBvc2l0aW9uMFwiOiBbMzQ3LCAxMzNdLFxuXHRcImRlYWxlckJ1dHRvblBvc2l0aW9uMVwiOiBbMzk1LCAxMzNdLFxuXHRcImRlYWxlckJ1dHRvblBvc2l0aW9uMlwiOiBbNTc0LCAxMzNdLFxuXHRcImRlYWxlckJ1dHRvblBvc2l0aW9uM1wiOiBbNzYyLCAyNjddLFxuXHRcImRlYWxlckJ1dHRvblBvc2l0aW9uNFwiOiBbNzE1LCAzNThdLFxuXHRcImRlYWxlckJ1dHRvblBvc2l0aW9uNVwiOiBbNTc0LCA0MzRdLFxuXHRcImRlYWxlckJ1dHRvblBvc2l0aW9uNlwiOiBbNTM2LCA0MzJdLFxuXHRcImRlYWxlckJ1dHRvblBvc2l0aW9uN1wiOiBbMzUxLCA0MzJdLFxuXHRcImRlYWxlckJ1dHRvblBvc2l0aW9uOFwiOiBbMTkzLCAzNjJdLFxuXHRcImRlYWxlckJ1dHRvblBvc2l0aW9uOVwiOiBbMTY4LCAyNjZdLFxuXG5cdFwiYmV0UG9zaXRpb24wXCI6IFsyMjUsIDE1MF0sXG5cdFwiYmV0UG9zaXRpb24xXCI6IFs0NzgsIDE1MF0sXG5cdFwiYmV0UG9zaXRpb24yXCI6IFs3MzAsIDE1MF0sXG5cdFwiYmV0UG9zaXRpb24zXCI6IFs3NzgsIDE5Nl0sXG5cdFwiYmV0UG9zaXRpb240XCI6IFs3NDgsIDMyMl0sXG5cdFwiYmV0UG9zaXRpb241XCI6IFs3MTksIDM2MF0sXG5cdFwiYmV0UG9zaXRpb242XCI6IFs0ODEsIDM2MF0sXG5cdFwiYmV0UG9zaXRpb243XCI6IFsyMzIsIDM2MF0sXG5cdFwiYmV0UG9zaXRpb244XCI6IFsxOTksIDMyMl0sXG5cdFwiYmV0UG9zaXRpb245XCI6IFsxODEsIDIwMF0sXG5cblx0XCJiaWdCdXR0b25Qb3NpdGlvblwiOiBbMzY2LCA1NzVdXG59OyIsIi8qKlxuICogQ2xpZW50LlxuICogQG1vZHVsZSBjbGllbnRcbiAqL1xuXG4vKipcbiAqIFZpZXcgY29uZmlndXJhdGlvbi5cbiAqIEBjbGFzcyBWaWV3Q29uZmlnXG4gKi9cbmZ1bmN0aW9uIFZpZXdDb25maWcoKSB7XG5cdHRoaXMucGxheUFuaW1hdGlvbnMgPSB0cnVlO1xufVxuXG4vKipcbiAqIFNob3VsZCB3ZSBwbGF5IGFuaW1hdGlvbnM/XG4gKiBAbWV0aG9kIHNldFBsYXlBbmltYXRpb25zXG4gKi9cblZpZXdDb25maWcucHJvdG90eXBlLnNldFBsYXlBbmltYXRpb25zID0gZnVuY3Rpb24odmFsdWUpIHtcblx0dGhpcy5wbGF5QW5pbWF0aW9ucyA9IHZhbHVlO1xufVxuXG4vKipcbiAqIFNob3VsZCB3ZSBwbGF5IGFuaW1hdGlvbnM/XG4gKiBAbWV0aG9kIGdldFBsYXlBbmltYXRpb25zXG4gKi9cblZpZXdDb25maWcucHJvdG90eXBlLmdldFBsYXlBbmltYXRpb25zID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnBsYXlBbmltYXRpb25zO1xufVxuXG4vKipcbiAqIFNjYWxlIGFuaW1hdGlvbiB0aW1lLlxuICogQG1ldGhvZCBzY2FsZUFuaW1hdGlvblRpbWVcbiAqL1xuVmlld0NvbmZpZy5wcm90b3R5cGUuc2NhbGVBbmltYXRpb25UaW1lID0gZnVuY3Rpb24obWlsbGlzKSB7XG5cdGlmICh0aGlzLnBsYXlBbmltYXRpb25zKVxuXHRcdHJldHVybiBtaWxsaXM7XG5cblx0cmV0dXJuIDE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVmlld0NvbmZpZzsiLCIvKipcbiAqIENsaWVudC5cbiAqIEBtb2R1bGUgY2xpZW50XG4gKi9cblxudmFyIFBJWEkgPSByZXF1aXJlKFwicGl4aS5qc1wiKTtcbnZhciBCdXR0b24gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvQnV0dG9uXCIpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xuXG4vKipcbiAqIEJpZyBidXR0b24uXG4gKiBAY2xhc3MgQmlnQnV0dG9uXG4gKi9cbmZ1bmN0aW9uIEJpZ0J1dHRvbihyZXNvdXJjZXMpIHtcblx0QnV0dG9uLmNhbGwodGhpcyk7XG5cblx0dGhpcy5yZXNvdXJjZXMgPSByZXNvdXJjZXM7XG5cblx0dGhpcy5iaWdCdXR0b25UZXh0dXJlID0gdGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcImJpZ0J1dHRvblwiKTtcblxuXHR0aGlzLmFkZENoaWxkKG5ldyBQSVhJLlNwcml0ZSh0aGlzLmJpZ0J1dHRvblRleHR1cmUpKTtcblxuXHR2YXIgc3R5bGUgPSB7XG5cdFx0Zm9udDogXCJib2xkIDE4cHggQXJpYWxcIixcblx0XHQvL2ZpbGw6IFwiIzAwMDAwMFwiXG5cdH07XG5cblx0dGhpcy5sYWJlbEZpZWxkID0gbmV3IFBJWEkuVGV4dChcIltidXR0b25dXCIsIHN0eWxlKTtcblx0dGhpcy5sYWJlbEZpZWxkLnBvc2l0aW9uLnkgPSAzMDtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLmxhYmVsRmllbGQpO1xuXG5cdHZhciBzdHlsZSA9IHtcblx0XHRmb250OiBcImJvbGQgMTRweCBBcmlhbFwiXG5cdFx0Ly9maWxsOiBcIiMwMDAwMDBcIlxuXHR9O1xuXG5cdHRoaXMudmFsdWVGaWVsZCA9IG5ldyBQSVhJLlRleHQoXCJbdmFsdWVdXCIsIHN0eWxlKTtcblx0dGhpcy52YWx1ZUZpZWxkLnBvc2l0aW9uLnkgPSA1MDtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLnZhbHVlRmllbGQpO1xuXG5cdHRoaXMuc2V0TGFiZWwoXCJURVNUXCIpO1xuXHR0aGlzLnNldFZhbHVlKDEyMyk7XG59XG5cbmluaGVyaXRzKEJpZ0J1dHRvbiwgQnV0dG9uKTtcblxuLyoqXG4gKiBTZXQgbGFiZWwgZm9yIHRoZSBidXR0b24uXG4gKiBAbWV0aG9kIHNldExhYmVsXG4gKi9cbkJpZ0J1dHRvbi5wcm90b3R5cGUuc2V0TGFiZWwgPSBmdW5jdGlvbihsYWJlbCkge1xuXHR0aGlzLmxhYmVsRmllbGQuc2V0VGV4dChsYWJlbCk7XG5cdHRoaXMubGFiZWxGaWVsZC51cGRhdGVUcmFuc2Zvcm0oKTtcblx0dGhpcy5sYWJlbEZpZWxkLnggPSB0aGlzLmJpZ0J1dHRvblRleHR1cmUud2lkdGggLyAyIC0gdGhpcy5sYWJlbEZpZWxkLndpZHRoIC8gMjtcbn1cblxuLyoqXG4gKiBTZXQgdmFsdWUuXG4gKiBAbWV0aG9kIHNldFZhbHVlXG4gKi9cbkJpZ0J1dHRvbi5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRpZiAoIXZhbHVlKSB7XG5cdFx0dGhpcy52YWx1ZUZpZWxkLnZpc2libGUgPSBmYWxzZTtcblx0XHR2YWx1ZSA9IFwiXCI7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy52YWx1ZUZpZWxkLnZpc2libGUgPSB0cnVlO1xuXHR9XG5cblx0dGhpcy52YWx1ZUZpZWxkLnNldFRleHQodmFsdWUpO1xuXHR0aGlzLnZhbHVlRmllbGQudXBkYXRlVHJhbnNmb3JtKCk7XG5cdHRoaXMudmFsdWVGaWVsZC54ID0gdGhpcy5iaWdCdXR0b25UZXh0dXJlLndpZHRoIC8gMiAtIHRoaXMudmFsdWVGaWVsZC53aWR0aCAvIDI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQmlnQnV0dG9uOyIsIi8qKlxuICogQ2xpZW50LlxuICogQG1vZHVsZSBjbGllbnRcbiAqL1xuXG52YXIgUElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoXCJ5YWVkXCIpO1xudmFyIEJ1dHRvbiA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9CdXR0b25cIik7XG52YXIgU2xpZGVyID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL1NsaWRlclwiKTtcbnZhciBOaW5lU2xpY2UgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvTmluZVNsaWNlXCIpO1xudmFyIEJpZ0J1dHRvbiA9IHJlcXVpcmUoXCIuL0JpZ0J1dHRvblwiKTtcbnZhciBSYWlzZVNob3J0Y3V0QnV0dG9uID0gcmVxdWlyZShcIi4vUmFpc2VTaG9ydGN1dEJ1dHRvblwiKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCJpbmhlcml0c1wiKTtcblxuLyoqXG4gKiBCdXR0b25zXG4gKiBAY2xhc3MgQnV0dG9uc1ZpZXdcbiAqL1xuZnVuY3Rpb24gQnV0dG9uc1ZpZXcodmlld0NvbmZpZywgcmVzb3VyY2VzKSB7XG5cdFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKHRoaXMpO1xuXG5cdHRoaXMucmVzb3VyY2VzID0gcmVzb3VyY2VzO1xuXG5cdHRoaXMuYnV0dG9uSG9sZGVyID0gbmV3IFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcigpO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMuYnV0dG9uSG9sZGVyKTtcblxuXHR2YXIgc2xpZGVyQmFja2dyb3VuZCA9IG5ldyBOaW5lU2xpY2UodGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcInNsaWRlckJhY2tncm91bmRcIiksIDIwLCAwLCAyMCwgMCk7XG5cdHNsaWRlckJhY2tncm91bmQuc2V0TG9jYWxTaXplKDMwMCxzbGlkZXJCYWNrZ3JvdW5kLmhlaWdodCk7XG5cdC8vc2xpZGVyQmFja2dyb3VuZC53aWR0aCA9IDMwMDtcblxuXHR2YXIga25vYiA9IG5ldyBQSVhJLlNwcml0ZSh0aGlzLnJlc291cmNlcy5nZXRUZXh0dXJlKFwic2xpZGVyS25vYlwiKSk7XG5cblx0dGhpcy5zbGlkZXIgPSBuZXcgU2xpZGVyKHNsaWRlckJhY2tncm91bmQsIGtub2IpO1xuXHR2YXIgcG9zID0gdGhpcy5yZXNvdXJjZXMuZ2V0UG9pbnQoXCJiaWdCdXR0b25Qb3NpdGlvblwiKTtcblx0dGhpcy5zbGlkZXIucG9zaXRpb24ueCA9IHBvcy54O1xuXHR0aGlzLnNsaWRlci5wb3NpdGlvbi55ID0gcG9zLnkgLSAzNTtcblx0dGhpcy5zbGlkZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCB0aGlzLm9uU2xpZGVyQ2hhbmdlLCB0aGlzKTtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLnNsaWRlcik7XG5cblxuXHR0aGlzLmJ1dHRvbkhvbGRlci5wb3NpdGlvbi54ID0gMzY2O1xuXHR0aGlzLmJ1dHRvbkhvbGRlci5wb3NpdGlvbi55ID0gNTc1O1xuXG5cdHRoaXMuYnV0dG9ucyA9IFtdO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0dmFyIGJ1dHRvbiA9IG5ldyBCaWdCdXR0b24odGhpcy5yZXNvdXJjZXMpO1xuXHRcdGJ1dHRvbi5vbihCdXR0b24uQ0xJQ0ssIHRoaXMub25CdXR0b25DbGljaywgdGhpcyk7XG5cdFx0YnV0dG9uLnBvc2l0aW9uLnggPSBpICogMTA1O1xuXHRcdHRoaXMuYnV0dG9uSG9sZGVyLmFkZENoaWxkKGJ1dHRvbik7XG5cdFx0dGhpcy5idXR0b25zLnB1c2goYnV0dG9uKTtcblx0fVxuXG5cdHZhciByYWlzZVNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZSh0aGlzLnJlc291cmNlcy5nZXRUZXh0dXJlKFwic2xpZGVyS25vYlwiKSk7XG5cdHZhciBhcnJvd1Nwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZSh0aGlzLnJlc291cmNlcy5nZXRUZXh0dXJlKFwidXBBcnJvd1wiKSk7XG5cdGFycm93U3ByaXRlLnBvc2l0aW9uLnggPSAocmFpc2VTcHJpdGUud2lkdGggLSBhcnJvd1Nwcml0ZS53aWR0aCkqMC41IC0gMC41O1xuXHRhcnJvd1Nwcml0ZS5wb3NpdGlvbi55ID0gKHJhaXNlU3ByaXRlLmhlaWdodCAtIGFycm93U3ByaXRlLmhlaWdodCkqMC41IC0gMjtcblx0cmFpc2VTcHJpdGUuYWRkQ2hpbGQoYXJyb3dTcHJpdGUpO1xuXG5cdHRoaXMucmFpc2VNZW51QnV0dG9uID0gbmV3IEJ1dHRvbihyYWlzZVNwcml0ZSk7XG5cdHRoaXMucmFpc2VNZW51QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoQnV0dG9uLkNMSUNLLCB0aGlzLm9uUmFpc2VNZW51QnV0dG9uQ2xpY2ssIHRoaXMpO1xuXHR0aGlzLnJhaXNlTWVudUJ1dHRvbi5wb3NpdGlvbi54ID0gMioxMDUgKyA3MDtcblx0dGhpcy5yYWlzZU1lbnVCdXR0b24ucG9zaXRpb24ueSA9IC01O1xuXHR0aGlzLmJ1dHRvbkhvbGRlci5hZGRDaGlsZCh0aGlzLnJhaXNlTWVudUJ1dHRvbik7XG5cblx0dGhpcy5yYWlzZU1lbnVCdXR0b24udmlzaWJsZSA9IGZhbHNlO1xuXHR0aGlzLmNyZWF0ZVJhaXNlQW1vdW50TWVudSgpO1xuXG5cdHRoaXMuc2V0QnV0dG9ucyhbXSwgMCwgLTEsIC0xKTtcblxuXHR0aGlzLmJ1dHRvbnNEYXRhcyA9IFtdO1xufVxuXG5pbmhlcml0cyhCdXR0b25zVmlldywgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyKTtcbkV2ZW50RGlzcGF0Y2hlci5pbml0KEJ1dHRvbnNWaWV3KTtcblxuQnV0dG9uc1ZpZXcuQlVUVE9OX0NMSUNLID0gXCJidXR0b25DbGlja1wiO1xuXG5cbi8qKlxuICogQ3JlYXRlIHJhaXNlIGFtb3VudCBtZW51LlxuICogQG1ldGhvZCBjcmVhdGVSYWlzZUFtb3VudE1lbnVcbiAqL1xuQnV0dG9uc1ZpZXcucHJvdG90eXBlLmNyZWF0ZVJhaXNlQW1vdW50TWVudSA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnJhaXNlQW1vdW50TWVudSA9IG5ldyBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIoKTtcblxuXHR0aGlzLnJhaXNlTWVudUJhY2tncm91bmQgPSBuZXcgTmluZVNsaWNlKHRoaXMucmVzb3VyY2VzLmdldFRleHR1cmUoXCJjaGF0QmFja2dyb3VuZFwiKSwgMTAsIDEwLCAxMCwgMTApO1xuXHR0aGlzLnJhaXNlTWVudUJhY2tncm91bmQucG9zaXRpb24ueCA9IDA7XG5cdHRoaXMucmFpc2VNZW51QmFja2dyb3VuZC5wb3NpdGlvbi55ID0gMDtcblx0dGhpcy5yYWlzZU1lbnVCYWNrZ3JvdW5kLndpZHRoID0gMTI1O1xuXHR0aGlzLnJhaXNlTWVudUJhY2tncm91bmQuaGVpZ2h0ID0gMjIwO1xuXHR0aGlzLnJhaXNlQW1vdW50TWVudS5hZGRDaGlsZCh0aGlzLnJhaXNlTWVudUJhY2tncm91bmQpO1xuXG5cdHRoaXMucmFpc2VBbW91bnRNZW51LnggPSA2NDU7XG5cdHRoaXMucmFpc2VBbW91bnRNZW51LnkgPSA1NzAgLSB0aGlzLnJhaXNlQW1vdW50TWVudS5oZWlnaHQ7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5yYWlzZUFtb3VudE1lbnUpO1xuXG5cdHZhciBzdHlsZU9iamVjdCA9IHtcblx0XHRmb250OiBcImJvbGQgMThweCBBcmlhbFwiLFxuXHR9O1xuXG5cdHZhciB0ID0gbmV3IFBJWEkuVGV4dChcIlJBSVNFIFRPXCIsIHN0eWxlT2JqZWN0KTtcblx0dC5wb3NpdGlvbi54ID0gKDEyNSAtIHQud2lkdGgpKjAuNTtcblx0dC5wb3NpdGlvbi55ID0gMTA7XG5cdHRoaXMucmFpc2VBbW91bnRNZW51LmFkZENoaWxkKHQpO1xuXG5cdHRoaXMucmFpc2VTaG9ydGN1dEJ1dHRvbnMgPSBuZXcgQXJyYXkoKTtcblxuXHRmb3IodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG5cdFx0dmFyIGIgPSBuZXcgUmFpc2VTaG9ydGN1dEJ1dHRvbih0aGlzLnJlc291cmNlcyk7XG5cdFx0Yi5hZGRFdmVudExpc3RlbmVyKEJ1dHRvbi5DTElDSywgdGhpcy5vblJhaXNlU2hvcnRjdXRDbGljaywgdGhpcyk7XG5cdFx0Yi5wb3NpdGlvbi54ID0gMTA7XG5cdFx0Yi5wb3NpdGlvbi55ID0gMzUgKyBpKjMwO1xuXG5cdFx0dGhpcy5yYWlzZUFtb3VudE1lbnUuYWRkQ2hpbGQoYik7XG5cdFx0dGhpcy5yYWlzZVNob3J0Y3V0QnV0dG9ucy5wdXNoKGIpO1xuXHR9XG5cbi8qXG5cdFBpeGlUZXh0aW5wdXQgc2hvdWxkIGJlIHVzZWQuXG5cdHRoaXMucmFpc2VBbW91bnRNZW51SW5wdXQ9bmV3IFRleHRGaWVsZCgpO1xuXHR0aGlzLnJhaXNlQW1vdW50TWVudUlucHV0Lng9MTA7XG5cdHRoaXMucmFpc2VBbW91bnRNZW51SW5wdXQueT00MCszMCo1O1xuXHR0aGlzLnJhaXNlQW1vdW50TWVudUlucHV0LndpZHRoPTEwNTtcblx0dGhpcy5yYWlzZUFtb3VudE1lbnVJbnB1dC5oZWlnaHQ9MTk7XG5cdHRoaXMucmFpc2VBbW91bnRNZW51SW5wdXQuYm9yZGVyPXRydWU7XG5cdHRoaXMucmFpc2VBbW91bnRNZW51SW5wdXQuYm9yZGVyQ29sb3I9MHg0MDQwNDA7XG5cdHRoaXMucmFpc2VBbW91bnRNZW51SW5wdXQuYmFja2dyb3VuZD10cnVlO1xuXHR0aGlzLnJhaXNlQW1vdW50TWVudUlucHV0Lm11bHRpbGluZT1mYWxzZTtcblx0dGhpcy5yYWlzZUFtb3VudE1lbnVJbnB1dC50eXBlPVRleHRGaWVsZFR5cGUuSU5QVVQ7XG5cdHRoaXMucmFpc2VBbW91bnRNZW51SW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihFdmVudC5DSEFOR0Usb25SYWlzZUFtb3VudE1lbnVJbnB1dENoYW5nZSk7XG5cdHRoaXMucmFpc2VBbW91bnRNZW51SW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihLZXlib2FyZEV2ZW50LktFWV9ET1dOLG9uUmFpc2VBbW91bnRNZW51SW5wdXRLZXlEb3duKTtcblx0dGhpcy5yYWlzZUFtb3VudE1lbnUuYWRkQ2hpbGQodGhpcy5yYWlzZUFtb3VudE1lbnVJbnB1dCk7XG5cdCovXG5cblx0dGhpcy5yYWlzZUFtb3VudE1lbnUudmlzaWJsZSA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJhaXNlIGFtb3VudCBidXR0b24uXG4gKiBAbWV0aG9kIG9uUmFpc2VNZW51QnV0dG9uQ2xpY2tcbiAqL1xuQnV0dG9uc1ZpZXcucHJvdG90eXBlLm9uUmFpc2VTaG9ydGN1dENsaWNrID0gZnVuY3Rpb24oKSB7XG5cdC8qdmFyIGIgPSBjYXN0IGUudGFyZ2V0O1xuXG5cdF9yYWlzZUFtb3VudE1lbnUudmlzaWJsZT1mYWxzZTtcblxuXHRidXR0b25zW19zbGlkZXJJbmRleF0udmFsdWU9Yi52YWx1ZTtcblx0X3NsaWRlci52YWx1ZT0oYnV0dG9uc1tfc2xpZGVySW5kZXhdLnZhbHVlLV9zbGlkZXJNaW4pLyhfc2xpZGVyTWF4LV9zbGlkZXJNaW4pO1xuXHRfcmFpc2VBbW91bnRNZW51SW5wdXQudGV4dD1TdGQuc3RyaW5nKGJ1dHRvbnNbX3NsaWRlckluZGV4XS52YWx1ZSk7XG5cblx0dHJhY2UoXCJ2YWx1ZSBjbGljazogXCIrYi52YWx1ZSk7Ki9cbn1cblxuXG5cbi8qKlxuICogUmFpc2UgYW1vdW50IGJ1dHRvbi5cbiAqIEBtZXRob2Qgb25SYWlzZU1lbnVCdXR0b25DbGlja1xuICovXG5CdXR0b25zVmlldy5wcm90b3R5cGUub25SYWlzZU1lbnVCdXR0b25DbGljayA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnJhaXNlQW1vdW50TWVudS52aXNpYmxlID0gIXRoaXMucmFpc2VBbW91bnRNZW51LnZpc2libGU7XG4vKlxuXHRpZih0aGlzLnJhaXNlQW1vdW50TWVudS52aXNpYmxlKSB7XG5cdFx0dGhpcy5zdGFnZS5tb3VzZWRvd24gPSB0aGlzLm9uU3RhZ2VNb3VzZURvd24uYmluZCh0aGlzKTtcblx0XHQvLyB0aGlzLnJhaXNlQW1vdW50TWVudUlucHV0LmZvY3VzKCk7XG5cdFx0Ly8gdGhpcy5yYWlzZUFtb3VudE1lbnVJbnB1dC5TZWxlY3RBbGxcblx0fVxuXHRlbHNlIHtcblx0XHR0aGlzLnN0YWdlLm1vdXNlZG93biA9IG51bGw7XG5cdH0qL1xufVxuXG4vKipcbiAqIFNsaWRlciBjaGFuZ2UuXG4gKiBAbWV0aG9kIG9uU2xpZGVyQ2hhbmdlXG4gKi9cbkJ1dHRvbnNWaWV3LnByb3RvdHlwZS5vblNsaWRlckNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgbmV3VmFsdWUgPSBNYXRoLnJvdW5kKHRoaXMuc2xpZGVyTWluICsgdGhpcy5zbGlkZXIuZ2V0VmFsdWUoKSoodGhpcy5zbGlkZXJNYXggLSB0aGlzLnNsaWRlck1pbikpO1xuXHR0aGlzLmJ1dHRvbnNbdGhpcy5zbGlkZXJJbmRleF0uc2V0VmFsdWUobmV3VmFsdWUpO1xuXHR0aGlzLmJ1dHRvbkRhdGFzW3RoaXMuc2xpZGVySW5kZXhdLnZhbHVlID0gbmV3VmFsdWU7XG5cdGNvbnNvbGUubG9nKFwibmV3VmFsdWUgPSBcIiArIG5ld1ZhbHVlKTtcblxuXHQvL3RoaXMucmFpc2VBbW91bnRNZW51SW5wdXQuc2V0VGV4dChidXR0b25zW19zbGlkZXJJbmRleF0udmFsdWUudG9TdHJpbmcoKSk7XG59XG5cbi8qKlxuICogU2hvdyBzbGlkZXIuXG4gKiBAbWV0aG9kIHNob3dTbGlkZXJcbiAqL1xuQnV0dG9uc1ZpZXcucHJvdG90eXBlLnNob3dTbGlkZXIgPSBmdW5jdGlvbihpbmRleCwgbWluLCBtYXgpIHtcblx0Y29uc29sZS5sb2coXCJzaG93U2xpZGVyXCIpO1xuXHR0aGlzLnNsaWRlckluZGV4ID0gaW5kZXg7XG5cdHRoaXMuc2xpZGVyTWluID0gbWluO1xuXHR0aGlzLnNsaWRlck1heCA9IG1heDtcblxuXHRjb25zb2xlLmxvZyhcInRoaXMuYnV0dG9uRGF0YXNbXCIraW5kZXgrXCJdID0gXCIgKyB0aGlzLmJ1dHRvbkRhdGFzW2luZGV4XS5nZXRWYWx1ZSgpICsgXCIsIG1pbiA9IFwiICsgbWluICsgXCIsIG1heCA9IFwiICsgbWF4KTtcblx0dGhpcy5zbGlkZXIuc2V0VmFsdWUoKHRoaXMuYnV0dG9uRGF0YXNbaW5kZXhdLmdldFZhbHVlKCkgLSBtaW4pLyhtYXggLSBtaW4pKTtcblx0Y29uc29sZS5sb2coXCJ0aGlzLnNsaWRlci5nZXRWYWx1ZSgpID0gXCIgKyB0aGlzLnNsaWRlci5nZXRWYWx1ZSgpKTtcblx0dGhpcy5zbGlkZXIudmlzaWJsZSA9IHRydWU7XG5cdHRoaXMuc2xpZGVyLnNob3coKTtcbn1cblxuLyoqXG4gKiBDbGVhci5cbiAqIEBtZXRob2QgY2xlYXJcbiAqL1xuQnV0dG9uc1ZpZXcucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oYnV0dG9uRGF0YXMpIHtcblx0dGhpcy5zZXRCdXR0b25zKFtdLCAwLCAtMSwgLTEpO1xuXHR0aGlzLnNsaWRlci52aXNpYmxlID0gZmFsc2U7XG59XG5cbi8qKlxuICogU2V0IGJ1dHRvbiBkYXRhcy5cbiAqIEBtZXRob2Qgc2V0QnV0dG9uc1xuICovXG5CdXR0b25zVmlldy5wcm90b3R5cGUuc2V0QnV0dG9ucyA9IGZ1bmN0aW9uKGJ1dHRvbkRhdGFzLCBzbGlkZXJCdXR0b25JbmRleCwgbWluLCBtYXgpIHtcblx0dGhpcy5idXR0b25EYXRhcyA9IGJ1dHRvbkRhdGFzO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5idXR0b25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGJ1dHRvbiA9IHRoaXMuYnV0dG9uc1tpXTtcblx0XHRpZiAoaSA+PSBidXR0b25EYXRhcy5sZW5ndGgpIHtcblx0XHRcdGJ1dHRvbi52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHR2YXIgYnV0dG9uRGF0YSA9IGJ1dHRvbkRhdGFzW2ldO1xuXG5cdFx0YnV0dG9uLnZpc2libGUgPSB0cnVlO1xuXHRcdGJ1dHRvbi5zZXRMYWJlbChidXR0b25EYXRhLmdldEJ1dHRvblN0cmluZygpKTtcblx0XHRidXR0b24uc2V0VmFsdWUoYnV0dG9uRGF0YS5nZXRWYWx1ZSgpKTtcblxuXHR9XG5cblx0aWYoKG1pbiA+PSAwKSAmJiAobWF4ID49IDApKVxuXHRcdHRoaXMuc2hvd1NsaWRlcihzbGlkZXJCdXR0b25JbmRleCwgbWluLCBtYXgpO1xuXG5cdHRoaXMuYnV0dG9uSG9sZGVyLnBvc2l0aW9uLnggPSAzNjY7XG5cblx0aWYgKGJ1dHRvbkRhdGFzLmxlbmd0aCA8IDMpXG5cdFx0dGhpcy5idXR0b25Ib2xkZXIucG9zaXRpb24ueCArPSA0NTtcbn1cblxuLyoqXG4gKiBCdXR0b24gY2xpY2suXG4gKiBAbWV0aG9kIG9uQnV0dG9uQ2xpY2tcbiAqIEBwcml2YXRlXG4gKi9cbkJ1dHRvbnNWaWV3LnByb3RvdHlwZS5vbkJ1dHRvbkNsaWNrID0gZnVuY3Rpb24oZSkge1xuXHR2YXIgYnV0dG9uSW5kZXggPSAtMTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYnV0dG9ucy5sZW5ndGg7IGkrKykge1xuXHRcdHRoaXMuYnV0dG9uc1tpXS52aXNpYmxlID0gZmFsc2U7XG5cdFx0aWYgKGUudGFyZ2V0ID09IHRoaXMuYnV0dG9uc1tpXSlcblx0XHRcdGJ1dHRvbkluZGV4ID0gaTtcblx0fVxuXG5cdHRoaXMuc2xpZGVyLnZpc2libGUgPSBmYWxzZTtcblxuXHQvL2NvbnNvbGUubG9nKFwiYnV0dG9uIGNsaWNrOiBcIiArIGJ1dHRvbkluZGV4KTtcblx0dmFyIGJ1dHRvbkRhdGEgPSB0aGlzLmJ1dHRvbkRhdGFzW2J1dHRvbkluZGV4XTtcblxuXHR0aGlzLnRyaWdnZXIoe1xuXHRcdHR5cGU6IEJ1dHRvbnNWaWV3LkJVVFRPTl9DTElDSyxcblx0XHRidXR0b246IGJ1dHRvbkRhdGEuZ2V0QnV0dG9uKCksXG5cdFx0dmFsdWU6IGJ1dHRvbkRhdGEuZ2V0VmFsdWUoKVxuXHR9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCdXR0b25zVmlldzsiLCIvKipcbiAqIENsaWVudC5cbiAqIEBtb2R1bGUgY2xpZW50XG4gKi9cblxudmFyIFBJWEkgPSByZXF1aXJlKFwicGl4aS5qc1wiKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCJpbmhlcml0c1wiKTtcblxuLyoqXG4gKiBUaGUgZnJvbnQgdmlldyBvZiBhIGNhcmQuXG4gKiBAY2xhc3MgQ2FyZEZyb250Vmlld1xuICovXG5mdW5jdGlvbiBDYXJkRnJvbnRWaWV3KHZpZXdDb25maWcsIHJlc291cmNlcykge1xuXHRQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIuY2FsbCh0aGlzKTtcblxuXHR0aGlzLnJlc291cmNlcyA9IHJlc291cmNlcztcbn07XG5pbmhlcml0cyhDYXJkRnJvbnRWaWV3LCBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIpO1xuXG5cbkNhcmRGcm9udFZpZXcucHJvdG90eXBlLnNldENhcmREYXRhID0gZnVuY3Rpb24oY2FyZERhdGEpIHtcblx0dGhpcy5jYXJkRGF0YSA9IGNhcmREYXRhO1xuXG5cdC8vIGNhcmREaWFtb25kczIgY2FyZERpYW1vbmRzMyBjYXJkRGlhbW9uZHM0IGNhcmREaWFtb25kczUgLi4uICBjYXJkRGlhbW9uZHNRICBjYXJkRGlhbW9uZHNLICBjYXJkRGlhbW9uZHNBXG5cdHZhciBjYXJkVGV4dHVyZTtcblx0dmFyIGN1c3RvbU5hbWUgPSBcImNhcmRcIiArIHRoaXMuY2FyZERhdGEuZ2V0TG9uZ1N1aXRTdHJpbmcoKSArIHRoaXMuY2FyZERhdGEuZ2V0Q2FyZFZhbHVlU3RyaW5nKCk7XG5cblx0aWYgKHRoaXMucmVzb3VyY2VzLmtleUV4aXN0cyhjdXN0b21OYW1lKSlcblx0XHRjYXJkVGV4dHVyZSA9IHRoaXMucmVzb3VyY2VzLmdldFRleHR1cmUoY3VzdG9tTmFtZSk7XG5cblx0aWYgKGNhcmRUZXh0dXJlKSB7XG5cdFx0dGhpcy5mcmFtZSA9IG5ldyBQSVhJLlNwcml0ZShjYXJkVGV4dHVyZSk7XG5cdFx0dGhpcy5hZGRDaGlsZCh0aGlzLmZyYW1lKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLmZyYW1lID0gbmV3IFBJWEkuU3ByaXRlKHRoaXMucmVzb3VyY2VzLmdldFRleHR1cmUoXCJjYXJkRnJhbWVcIikpO1xuXHRcdHRoaXMuYWRkQ2hpbGQodGhpcy5mcmFtZSk7XG5cblxuXHRcdHRoaXMuc3VpdCA9IG5ldyBQSVhJLlNwcml0ZSh0aGlzLnJlc291cmNlcy5nZXRUZXh0dXJlKFwic3VpdFN5bWJvbFwiICsgdGhpcy5jYXJkRGF0YS5nZXRTdWl0SW5kZXgoKSkpO1xuXHRcdHRoaXMuc3VpdC5wb3NpdGlvbi54ID0gODtcblx0XHR0aGlzLnN1aXQucG9zaXRpb24ueSA9IDI1O1xuXHRcdHRoaXMuYWRkQ2hpbGQodGhpcy5zdWl0KTtcblxuXHRcdHZhciBzdHlsZSA9IHtcblx0XHRcdGZvbnQ6IFwiYm9sZCAxNnB4IEFyaWFsXCJcblx0XHR9O1xuXG5cdFx0dGhpcy52YWx1ZUZpZWxkID0gbmV3IFBJWEkuVGV4dChcIlt2YWxdXCIsIHN0eWxlKTtcblx0XHR0aGlzLmFkZENoaWxkKHRoaXMudmFsdWVGaWVsZCk7XG5cdFx0dGhpcy52YWx1ZUZpZWxkLnN0eWxlLmZpbGwgPSB0aGlzLmNhcmREYXRhLmdldENvbG9yKCk7XG5cblx0XHR0aGlzLnZhbHVlRmllbGQuc2V0VGV4dCh0aGlzLmNhcmREYXRhLmdldENhcmRWYWx1ZVN0cmluZygpKTtcblx0XHR0aGlzLnZhbHVlRmllbGQudXBkYXRlVHJhbnNmb3JtKCk7XG5cdFx0dGhpcy52YWx1ZUZpZWxkLnBvc2l0aW9uLnggPSAxNyAtIHRoaXMudmFsdWVGaWVsZC5jYW52YXMud2lkdGggLyAyO1xuXHRcdHRoaXMudmFsdWVGaWVsZC5wb3NpdGlvbi55ID0gNTtcblxuXHRcdHRoaXMuc3VpdC5zZXRUZXh0dXJlKHRoaXMucmVzb3VyY2VzLmdldFRleHR1cmUoXCJzdWl0U3ltYm9sXCIgKyB0aGlzLmNhcmREYXRhLmdldFN1aXRJbmRleCgpKSk7XG5cdH1cbn07XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IENhcmRGcm9udFZpZXc7IiwiLyoqXG4gKiBDbGllbnQuXG4gKiBAbW9kdWxlIGNsaWVudFxuICovXG5cbnZhciBQSVhJID0gcmVxdWlyZShcInBpeGkuanNcIik7XG52YXIgVFdFRU4gPSByZXF1aXJlKFwidHdlZW4uanNcIik7XG52YXIgQ2FyZEZyb250VmlldyA9IHJlcXVpcmUoXCIuL0NhcmRGcm9udFZpZXdcIik7XG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZShcInlhZWRcIik7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiaW5oZXJpdHNcIik7XG5cbi8qKlxuICogQSBjYXJkIHZpZXcuXG4gKiBAY2xhc3MgQ2FyZFZpZXdcbiAqL1xuZnVuY3Rpb24gQ2FyZFZpZXcodmlld0NvbmZpZywgcmVzb3VyY2VzKSB7XG5cdFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKHRoaXMpO1xuXHR0aGlzLnRhcmdldFBvc2l0aW9uID0gbnVsbDtcblxuXHR0aGlzLnZpZXdDb25maWcgPSB2aWV3Q29uZmlnO1xuXHR0aGlzLnJlc291cmNlcyA9IHJlc291cmNlcztcblxuXG5cdHRoaXMuZnJvbnQgPSBuZXcgQ2FyZEZyb250Vmlldyh0aGlzLnZpZXdDb25maWcsIHRoaXMucmVzb3VyY2VzKTsvL1BJWEkuU3ByaXRlKHRoaXMucmVzb3VyY2VzLmdldFRleHR1cmUoXCJjYXJkRnJhbWVcIikpO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMuZnJvbnQpO1xuLypcblx0dGhpcy5zdWl0ID0gbmV3IFBJWEkuU3ByaXRlKHRoaXMucmVzb3VyY2VzLmdldFRleHR1cmUoXCJzdWl0U3ltYm9sXCIgKyAwKSk7XG5cdHRoaXMuc3VpdC5wb3NpdGlvbi54ID0gODtcblx0dGhpcy5zdWl0LnBvc2l0aW9uLnkgPSAyNTtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLnN1aXQpO1xuKi9cbi8qXHR2YXIgc3R5bGUgPSB7XG5cdFx0Zm9udDogXCJib2xkIDE2cHggQXJpYWxcIlxuXHR9O1xuXG5cdHRoaXMudmFsdWVGaWVsZCA9IG5ldyBQSVhJLlRleHQoXCJbdmFsXVwiLCBzdHlsZSk7XG5cdHRoaXMudmFsdWVGaWVsZC5wb3NpdGlvbi54ID0gNjtcblx0dGhpcy52YWx1ZUZpZWxkLnBvc2l0aW9uLnkgPSA1O1xuXHR0aGlzLmFkZENoaWxkKHRoaXMudmFsdWVGaWVsZCk7XG4qL1xuXHR0aGlzLmJhY2sgPSBuZXcgUElYSS5TcHJpdGUodGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcImNhcmRCYWNrXCIpKTtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLmJhY2spO1xuXG5cblx0dGhpcy5tYXNrR3JhcGhpY3MgPSBuZXcgUElYSS5HcmFwaGljcygpO1xuXHR0aGlzLm1hc2tHcmFwaGljcy5iZWdpbkZpbGwoMHgwMDAwMDApO1xuXHR0aGlzLm1hc2tHcmFwaGljcy5kcmF3UmVjdCgwLCAwLCB0aGlzLmJhY2sud2lkdGgsIHRoaXMuYmFjay5oZWlnaHQpO1xuXHR0aGlzLm1hc2tHcmFwaGljcy5lbmRGaWxsKCk7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5tYXNrR3JhcGhpY3MpO1xuXG5cdHRoaXMubWFzayA9IHRoaXMubWFza0dyYXBoaWNzO1xufVxuXG5pbmhlcml0cyhDYXJkVmlldywgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyKTtcbkV2ZW50RGlzcGF0Y2hlci5pbml0KENhcmRWaWV3KTtcblxuLyoqXG4gKiBTZXQgY2FyZCBkYXRhLlxuICogQG1ldGhvZCBzZXRDYXJkRGF0YVxuICovXG5DYXJkVmlldy5wcm90b3R5cGUuc2V0Q2FyZERhdGEgPSBmdW5jdGlvbihjYXJkRGF0YSkge1xuXHR0aGlzLmNhcmREYXRhID0gY2FyZERhdGE7XG5cblxuXHRpZiAodGhpcy5jYXJkRGF0YS5pc1Nob3duKCkpIHtcblx0XHQvKlxuXHRcdHRoaXMuYmFjay52aXNpYmxlID0gZmFsc2U7XG5cdFx0dGhpcy5mcmFtZS52aXNpYmxlID0gdHJ1ZTtcbiovXG4vKlxuXHRcdHRoaXMudmFsdWVGaWVsZC5zdHlsZS5maWxsID0gdGhpcy5jYXJkRGF0YS5nZXRDb2xvcigpO1xuXG5cdFx0dGhpcy52YWx1ZUZpZWxkLnNldFRleHQodGhpcy5jYXJkRGF0YS5nZXRDYXJkVmFsdWVTdHJpbmcoKSk7XG5cdFx0dGhpcy52YWx1ZUZpZWxkLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXHRcdHRoaXMudmFsdWVGaWVsZC5wb3NpdGlvbi54ID0gMTcgLSB0aGlzLnZhbHVlRmllbGQuY2FudmFzLndpZHRoIC8gMjtcblxuXHRcdHRoaXMuc3VpdC5zZXRUZXh0dXJlKHRoaXMucmVzb3VyY2VzLmdldFRleHR1cmUoXCJzdWl0U3ltYm9sXCIgKyB0aGlzLmNhcmREYXRhLmdldFN1aXRJbmRleCgpKSk7XG5cdFx0Ki9cblx0XHR0aGlzLmZyb250LnNldENhcmREYXRhKHRoaXMuY2FyZERhdGEpO1xuXG5cdFx0dGhpcy5tYXNrR3JhcGhpY3MuYmVnaW5GaWxsKDB4MDAwMDAwKTtcblx0XHR0aGlzLm1hc2tHcmFwaGljcy5kcmF3UmVjdCgwLCAwLCB0aGlzLmZyb250LndpZHRoLCB0aGlzLmZyb250LmhlaWdodCk7XG5cdFx0dGhpcy5tYXNrR3JhcGhpY3MuZW5kRmlsbCgpO1xuXHR9XG5cdHRoaXMuYmFjay52aXNpYmxlID0gdHJ1ZTtcblx0dGhpcy5mcm9udC52aXNpYmxlID0gZmFsc2U7XG59XG5cbi8qKlxuICogU2V0IGNhcmQgZGF0YS5cbiAqIEBtZXRob2Qgc2V0Q2FyZERhdGFcbiAqL1xuQ2FyZFZpZXcucHJvdG90eXBlLnNldFRhcmdldFBvc2l0aW9uID0gZnVuY3Rpb24ocG9pbnQpIHtcblx0dGhpcy50YXJnZXRQb3NpdGlvbiA9IHBvaW50O1xuXG5cdHRoaXMucG9zaXRpb24ueCA9IHBvaW50Lng7XG5cdHRoaXMucG9zaXRpb24ueSA9IHBvaW50Lnk7XG59XG5cbi8qKlxuICogSGlkZS5cbiAqIEBtZXRob2QgaGlkZVxuICovXG5DYXJkVmlldy5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnZpc2libGUgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBTaG93LlxuICogQG1ldGhvZCBzaG93XG4gKi9cbkNhcmRWaWV3LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oYW5pbWF0ZSwgZGVsYXkpIHtcblx0LyppZihkZWxheSA9PSB1bmRlZmluZWQpXG5cdFx0ZGVsYXkgPSAxO1xuXHQqL1xuXHR0aGlzLm1hc2tHcmFwaGljcy5zY2FsZS55ID0gMTtcblx0dGhpcy5wb3NpdGlvbi54ID0gdGhpcy50YXJnZXRQb3NpdGlvbi54O1xuXHR0aGlzLnBvc2l0aW9uLnkgPSB0aGlzLnRhcmdldFBvc2l0aW9uLnk7XG5cdGlmICghYW5pbWF0ZSkge1xuXHRcdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cdFx0dGhpcy5vblNob3dDb21wbGV0ZSgpO1xuXHRcdHJldHVybjtcblx0fVxuXHR0aGlzLm1hc2suaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cblx0dmFyIGRlc3RpbmF0aW9uID0ge1xuXHRcdHg6IHRoaXMucG9zaXRpb24ueCxcblx0XHR5OiB0aGlzLnBvc2l0aW9uLnlcblx0fTtcblx0dGhpcy5wb3NpdGlvbi54ID0gKHRoaXMucGFyZW50LndpZHRoIC0gdGhpcy53aWR0aCkgKiAwLjU7XG5cdHRoaXMucG9zaXRpb24ueSA9IC10aGlzLmhlaWdodDtcblxuXHR2YXIgZGlmZlggPSB0aGlzLnBvc2l0aW9uLnggLSBkZXN0aW5hdGlvbi54O1xuXHR2YXIgZGlmZlkgPSB0aGlzLnBvc2l0aW9uLnkgLSBkZXN0aW5hdGlvbi55O1xuXHR2YXIgZGlmZiA9IE1hdGguc3FydChkaWZmWCAqIGRpZmZYICsgZGlmZlkgKiBkaWZmWSk7XG5cblx0dmFyIHR3ZWVuID0gbmV3IFRXRUVOLlR3ZWVuKHRoaXMucG9zaXRpb24pXG5cdFx0Ly8gICAgICAgICAgICAuZGVsYXkoZGVsYXkpXG5cdFx0LnRvKHtcblx0XHRcdHg6IGRlc3RpbmF0aW9uLngsXG5cdFx0XHR5OiBkZXN0aW5hdGlvbi55XG5cdFx0fSwgdGhpcy52aWV3Q29uZmlnLnNjYWxlQW5pbWF0aW9uVGltZSg1MDApKVxuXHRcdC5lYXNpbmcoVFdFRU4uRWFzaW5nLlF1YWRyYXRpYy5PdXQpXG5cdFx0Lm9uU3RhcnQodGhpcy5vblNob3dTdGFydC5iaW5kKHRoaXMpKVxuXHRcdC5vbkNvbXBsZXRlKHRoaXMub25TaG93Q29tcGxldGUuYmluZCh0aGlzKSlcblx0XHQuc3RhcnQoKTtcbn1cblxuLyoqXG4gKiBTaG93IGNvbXBsZXRlLlxuICogQG1ldGhvZCBvblNob3dDb21wbGV0ZVxuICovXG5DYXJkVmlldy5wcm90b3R5cGUub25TaG93U3RhcnQgPSBmdW5jdGlvbigpIHtcblx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBTaG93IGNvbXBsZXRlLlxuICogQG1ldGhvZCBvblNob3dDb21wbGV0ZVxuICovXG5DYXJkVmlldy5wcm90b3R5cGUub25TaG93Q29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuY2FyZERhdGEuaXNTaG93bigpKSB7XG5cdFx0dGhpcy5iYWNrLnZpc2libGUgPSBmYWxzZTtcblx0XHR0aGlzLmZyb250LnZpc2libGUgPSB0cnVlO1xuXHR9XG5cdHRoaXMuZGlzcGF0Y2hFdmVudChcImFuaW1hdGlvbkRvbmVcIiwgdGhpcyk7XG59XG5cbi8qKlxuICogRm9sZC5cbiAqIEBtZXRob2QgZm9sZFxuICovXG5DYXJkVmlldy5wcm90b3R5cGUuZm9sZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgbyA9IHtcblx0XHR4OiB0aGlzLnRhcmdldFBvc2l0aW9uLngsXG5cdFx0eTogdGhpcy50YXJnZXRQb3NpdGlvbi55ICsgODBcblx0fTtcblxuXHR2YXIgdGltZSA9IHRoaXMudmlld0NvbmZpZy5zY2FsZUFuaW1hdGlvblRpbWUoNTAwKTtcblx0dGhpcy50MCA9IG5ldyBUV0VFTi5Ud2Vlbih0aGlzLnBvc2l0aW9uKVxuXHRcdC50byhvLCB0aW1lKVxuXHRcdC5lYXNpbmcoVFdFRU4uRWFzaW5nLlF1YWRyYXRpYy5PdXQpXG5cdFx0Lm9uVXBkYXRlKHRoaXMub25Gb2xkVXBkYXRlLmJpbmQodGhpcykpXG5cdFx0Lm9uQ29tcGxldGUodGhpcy5vbkZvbGRDb21wbGV0ZS5iaW5kKHRoaXMpKVxuXHRcdC5zdGFydCgpO1xufVxuXG4vKipcbiAqIEZvbGQgYW5pbWF0aW9uIHVwZGF0ZS5cbiAqIEBtZXRob2Qgb25Gb2xkVXBkYXRlXG4gKi9cbkNhcmRWaWV3LnByb3RvdHlwZS5vbkZvbGRVcGRhdGUgPSBmdW5jdGlvbihwcm9ncmVzcykge1xuXHR0aGlzLm1hc2tHcmFwaGljcy5zY2FsZS55ID0gMSAtIHByb2dyZXNzO1xufVxuXG4vKipcbiAqIEZvbGQgYW5pbWF0aW9uIGNvbXBsZXRlLlxuICogQG1ldGhvZCBvbkZvbGRDb21wbGV0ZVxuICovXG5DYXJkVmlldy5wcm90b3R5cGUub25Gb2xkQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiYW5pbWF0aW9uRG9uZVwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDYXJkVmlldzsiLCIvKipcbiAqIENsaWVudC5cbiAqIEBtb2R1bGUgY2xpZW50XG4gKi9cblxudmFyIFBJWEkgPSByZXF1aXJlKFwicGl4aS5qc1wiKTtcbnZhciBOaW5lU2xpY2UgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvTmluZVNsaWNlXCIpO1xudmFyIFNsaWRlciA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9TbGlkZXJcIik7XG52YXIgUGl4aVRleHRJbnB1dCA9IHJlcXVpcmUoXCJwaXhpdGV4dGlucHV0XCIpO1xudmFyIE1vdXNlT3Zlckdyb3VwID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL01vdXNlT3Zlckdyb3VwXCIpO1xudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoXCJ5YWVkXCIpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xuXG4vKipcbiAqIENoYXQgdmlldy5cbiAqIEBjbGFzcyBDaGF0Vmlld1xuICovXG5mdW5jdGlvbiBDaGF0Vmlldyh2aWV3Q29uZmlnLCByZXNvdXJjZXMpIHtcblx0UElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLmNhbGwodGhpcyk7XG5cblx0dGhpcy5yZXNvdXJjZXMgPSByZXNvdXJjZXM7XG5cdHRoaXMubWFyZ2luID0gNTtcblxuXHRcblx0dmFyIGNoYXRQbGF0ZSA9IG5ldyBOaW5lU2xpY2UodGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcImZyYW1lUGxhdGVcIiksIDEwKTtcblx0Y2hhdFBsYXRlLnBvc2l0aW9uLnggPSAxMDtcblx0Y2hhdFBsYXRlLnBvc2l0aW9uLnkgPSA1NDA7XG5cdGNoYXRQbGF0ZS5zZXRMb2NhbFNpemUoMzMwLCAxMzApO1xuXHR0aGlzLmFkZENoaWxkKGNoYXRQbGF0ZSk7XG5cblx0dmFyIHMgPSBuZXcgTmluZVNsaWNlKHRoaXMucmVzb3VyY2VzLmdldFRleHR1cmUoXCJmcmFtZVBsYXRlXCIpLCAxMCk7XG5cdHMucG9zaXRpb24ueCA9IDEwO1xuXHRzLnBvc2l0aW9uLnkgPSA2NzU7XG5cdHMuc2V0TG9jYWxTaXplKDMzMCwgMzUpO1xuXHR0aGlzLmFkZENoaWxkKHMpO1xuXG5cdHZhciBzdHlsZU9iamVjdCA9IHtcblx0XHRmb250OiBcIjEycHggQXJpYWxcIixcblx0XHR3b3JkV3JhcFdpZHRoOiAzMTAsXG5cdFx0aGVpZ2h0OiAxMTQsXG5cdFx0Ym9yZGVyOiB0cnVlLFxuXHRcdGNvbG9yOiAweEZGRkZGRixcblx0XHRib3JkZXJDb2xvcjogMHg0MDQwNDAsXG5cdFx0d29yZFdyYXA6IHRydWUsXG5cdFx0bXVsdGlsaW5lOiB0cnVlXG5cdH07XG5cblx0dGhpcy5jb250YWluZXIgPSBuZXcgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyKCk7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5jb250YWluZXIpO1xuXHR0aGlzLmNvbnRhaW5lci5wb3NpdGlvbi54ID0gMjA7XG5cdHRoaXMuY29udGFpbmVyLnBvc2l0aW9uLnkgPSA1NDg7XG5cblx0dGhpcy5jaGF0TWFzayA9IG5ldyBQSVhJLkdyYXBoaWNzKCk7XG5cdHRoaXMuY2hhdE1hc2suYmVnaW5GaWxsKDEyMyk7XG5cdHRoaXMuY2hhdE1hc2suZHJhd1JlY3QoMCwgMCwgMzEwLCAxMTQpO1xuXHR0aGlzLmNoYXRNYXNrLmVuZEZpbGwoKTtcblx0dGhpcy5jb250YWluZXIuYWRkQ2hpbGQodGhpcy5jaGF0TWFzayk7XG5cblx0dGhpcy5jaGF0VGV4dCA9IG5ldyBQSVhJLlRleHQoXCJcIiwgc3R5bGVPYmplY3QpO1xuXHR0aGlzLmNvbnRhaW5lci5hZGRDaGlsZCh0aGlzLmNoYXRUZXh0KTtcblx0dGhpcy5jaGF0VGV4dC5tYXNrID0gdGhpcy5jaGF0TWFzaztcblxuXG5cblx0dmFyIHN0eWxlT2JqZWN0ID0ge1xuXHRcdGZvbnQ6IFwiMTRweCBBcmlhbFwiLFxuXHRcdHdpZHRoOiAzMTAsXG5cdFx0aGVpZ2h0OiAxOSxcblx0XHRib3JkZXI6IHRydWUsXG5cdFx0Ym9yZGVyQ29sb3I6IDB4NDA0MDQwLFxuXHRcdGJhY2tncm91bmQ6IHRydWUsXG5cdFx0bXVsdGlsaW5lOiB0cnVlXG5cdH07XG5cdHRoaXMuaW5wdXRGaWVsZCA9IG5ldyBQaXhpVGV4dElucHV0KFwiXCIsIHN0eWxlT2JqZWN0KTtcblx0dGhpcy5pbnB1dEZpZWxkLnBvc2l0aW9uLnggPSB0aGlzLmNvbnRhaW5lci5wb3NpdGlvbi54O1xuXHR0aGlzLmlucHV0RmllbGQucG9zaXRpb24ueSA9IDY4Mztcblx0dGhpcy5pbnB1dEZpZWxkLndpZHRoID0gMzEwO1xuXHR0aGlzLmlucHV0RmllbGQua2V5ZG93biA9IHRoaXMub25LZXlEb3duLmJpbmQodGhpcyk7XG5cblx0dmFyIGlucHV0U2hhZG93ID0gbmV3IFBJWEkuR3JhcGhpY3MoKTtcblx0aW5wdXRTaGFkb3cuYmVnaW5GaWxsKDB4MDAwMDAwKTtcblx0aW5wdXRTaGFkb3cuZHJhd1JlY3QoLTEsIC0xLCAzMTEsIDIwKTtcblx0aW5wdXRTaGFkb3cucG9zaXRpb24ueCA9IHRoaXMuaW5wdXRGaWVsZC5wb3NpdGlvbi54O1xuXHRpbnB1dFNoYWRvdy5wb3NpdGlvbi55ID0gdGhpcy5pbnB1dEZpZWxkLnBvc2l0aW9uLnk7XG5cdHRoaXMuYWRkQ2hpbGQoaW5wdXRTaGFkb3cpO1xuXG5cdHZhciBpbnB1dEJhY2tncm91bmQgPSBuZXcgUElYSS5HcmFwaGljcygpO1xuXHRpbnB1dEJhY2tncm91bmQuYmVnaW5GaWxsKDB4RkZGRkZGKTtcblx0aW5wdXRCYWNrZ3JvdW5kLmRyYXdSZWN0KDAsIDAsIDMxMCwgMTkpO1xuXHRpbnB1dEJhY2tncm91bmQucG9zaXRpb24ueCA9IHRoaXMuaW5wdXRGaWVsZC5wb3NpdGlvbi54O1xuXHRpbnB1dEJhY2tncm91bmQucG9zaXRpb24ueSA9IHRoaXMuaW5wdXRGaWVsZC5wb3NpdGlvbi55O1xuXHR0aGlzLmFkZENoaWxkKGlucHV0QmFja2dyb3VuZCk7XG5cblx0dGhpcy5hZGRDaGlsZCh0aGlzLmlucHV0RmllbGQpO1xuXG5cblxuXHR2YXIgc2xpZGVCYWNrID0gbmV3IE5pbmVTbGljZSh0aGlzLnJlc291cmNlcy5nZXRUZXh0dXJlKFwidGV4dFNjcm9sbGJhclRyYWNrXCIpLCAxMCwgMCwgMTAsIDApO1xuXHRzbGlkZUJhY2sud2lkdGggPSAxMDc7XG5cdHZhciBzbGlkZUtub2IgPSBuZXcgTmluZVNsaWNlKHRoaXMucmVzb3VyY2VzLmdldFRleHR1cmUoXCJ0ZXh0U2Nyb2xsYmFyVGh1bWJcIiksIDEwLCAwLCAxMCwgMCk7XG5cdHNsaWRlS25vYi53aWR0aCA9IDMwO1xuXG5cblx0dGhpcy5zbGlkZXIgPSBuZXcgU2xpZGVyKHNsaWRlQmFjaywgc2xpZGVLbm9iKTtcblx0dGhpcy5zbGlkZXIucm90YXRpb24gPSBNYXRoLlBJKjAuNTtcblx0dGhpcy5zbGlkZXIucG9zaXRpb24ueCA9IDMyNjtcblx0dGhpcy5zbGlkZXIucG9zaXRpb24ueSA9IDU1Mjtcblx0dGhpcy5zbGlkZXIuc2V0VmFsdWUoMSk7XG5cdHRoaXMuc2xpZGVyLnZpc2libGUgPSBmYWxzZTtcblx0dGhpcy5zbGlkZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCB0aGlzLm9uU2xpZGVyQ2hhbmdlLmJpbmQodGhpcykpO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMuc2xpZGVyKTtcblxuXG5cdHRoaXMubW91c2VPdmVyR3JvdXAgPSBuZXcgTW91c2VPdmVyR3JvdXAoKTtcblx0dGhpcy5tb3VzZU92ZXJHcm91cC5hZGREaXNwbGF5T2JqZWN0KHRoaXMuY2hhdFRleHQpO1xuXHR0aGlzLm1vdXNlT3Zlckdyb3VwLmFkZERpc3BsYXlPYmplY3QodGhpcy5zbGlkZXIpO1xuXHR0aGlzLm1vdXNlT3Zlckdyb3VwLmFkZERpc3BsYXlPYmplY3QodGhpcy5jaGF0TWFzayk7XG5cdHRoaXMubW91c2VPdmVyR3JvdXAuYWRkRGlzcGxheU9iamVjdChjaGF0UGxhdGUpO1xuXHR0aGlzLm1vdXNlT3Zlckdyb3VwLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIiwgdGhpcy5vbkNoYXRGaWVsZE1vdXNlT3ZlciwgdGhpcyk7XG5cdHRoaXMubW91c2VPdmVyR3JvdXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsIHRoaXMub25DaGF0RmllbGRNb3VzZU91dCwgdGhpcyk7XG5cdHRoaXMubW91c2VPdmVyR3JvdXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLm9uQ2hhdEZpZWxkTW91c2VEb3duLCB0aGlzKTtcblx0dGhpcy5tb3VzZU92ZXJHcm91cC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLm9uQ2hhdEZpZWxkTW91c2VVcCwgdGhpcyk7XG5cblx0Y2hhdFBsYXRlLnRvdWNoc3RhcnQgPSB0aGlzLm9uQ2hhdEZpZWxkTW91c2VEb3duLmJpbmQodGhpcyk7XG5cblxuXHR0aGlzLmNsZWFyKCk7XG59XG5cbmluaGVyaXRzKENoYXRWaWV3LCBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIpO1xuRXZlbnREaXNwYXRjaGVyLmluaXQoQ2hhdFZpZXcpO1xuXG5cblxuLyoqXG4gKiBDbGVhciBtZXNzYWdlcy5cbiAqIEBtZXRob2QgY2xlYXJcbiAqL1xuQ2hhdFZpZXcucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuY2hhdFRleHQuc2V0VGV4dChcIlwiKTtcbiBcdHRoaXMuY2hhdFRleHQueSA9IC1NYXRoLnJvdW5kKHRoaXMuc2xpZGVyLmdldFZhbHVlKCkqKHRoaXMuY2hhdFRleHQuaGVpZ2h0ICsgdGhpcy5tYXJnaW4gLSB0aGlzLmNoYXRNYXNrLmhlaWdodCApKTtcblx0dGhpcy5zbGlkZXIuc2V0VmFsdWUoMSk7XG59XG5cblxuLyoqXG4gKiAgQWRkIHRleHQuXG4gKiBAbWV0aG9kIGNsZWFyXG4gKi9cbkNoYXRWaWV3LnByb3RvdHlwZS5hZGRUZXh0ID0gZnVuY3Rpb24odXNlciwgdGV4dCkge1xuXHR0aGlzLmNoYXRUZXh0LnNldFRleHQodGhpcy5jaGF0VGV4dC50ZXh0ICsgdXNlciArIFwiOiBcIiArIHRleHQgKyBcIlxcblwiKTtcbiBcdHRoaXMuY2hhdFRleHQueSA9IC1NYXRoLnJvdW5kKHRoaXMuc2xpZGVyLmdldFZhbHVlKCkqKHRoaXMuY2hhdFRleHQuaGVpZ2h0ICsgdGhpcy5tYXJnaW4gLSB0aGlzLmNoYXRNYXNrLmhlaWdodCApKTtcblx0dGhpcy5zbGlkZXIuc2V0VmFsdWUoMSk7XG59XG5cbi8qKlxuICogT24gc2xpZGVyIHZhbHVlIGNoYW5nZVxuICogQG1ldGhvZCBvblNsaWRlckNoYW5nZVxuICovXG4gQ2hhdFZpZXcucHJvdG90eXBlLm9uU2xpZGVyQ2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gXHR0aGlzLmNoYXRUZXh0LnkgPSAtTWF0aC5yb3VuZCh0aGlzLnNsaWRlci5nZXRWYWx1ZSgpKih0aGlzLmNoYXRUZXh0LmhlaWdodCArIHRoaXMubWFyZ2luIC0gdGhpcy5jaGF0TWFzay5oZWlnaHQpKTtcbiB9XG5cblxuLyoqXG4gKiBPbiBtb3VzZSBvdmVyXG4gKiBAbWV0aG9kIG9uQ2hhdEZpZWxkTW91c2VPdmVyXG4gKi9cbiBDaGF0Vmlldy5wcm90b3R5cGUub25DaGF0RmllbGRNb3VzZU92ZXIgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5zbGlkZXIuc2hvdygpO1xuIH1cblxuXG4vKipcbiAqIE9uIG1vdXNlIG91dFxuICogQG1ldGhvZCBvbkNoYXRGaWVsZE1vdXNlT3V0XG4gKi9cbiBDaGF0Vmlldy5wcm90b3R5cGUub25DaGF0RmllbGRNb3VzZU91dCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnNsaWRlci5oaWRlKCk7XG4gfVxuXG4vKipcbiAqIE9uIG1vdXNlIGRvd25cbiAqIEBtZXRob2Qgb25DaGF0RmllbGRNb3VzZURvd25cbiAqL1xuQ2hhdFZpZXcucHJvdG90eXBlLm9uQ2hhdEZpZWxkTW91c2VEb3duID0gZnVuY3Rpb24oaW50ZXJhY3Rpb25fb2JqZWN0KSB7XG5cdGludGVyYWN0aW9uX29iamVjdC50YXJnZXQudG91Y2hlbmQgPSBpbnRlcmFjdGlvbl9vYmplY3QudGFyZ2V0LnRvdWNoZW5kb3V0c2lkZSA9IHRoaXMub25DaGF0RmllbGRNb3VzZVVwLmJpbmQodGhpcyk7XG5cdGludGVyYWN0aW9uX29iamVjdC50YXJnZXQudG91Y2htb3ZlID0gdGhpcy5vbkNoYXRGaWVsZE1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuXHR0aGlzLnN0YXJ0TW91c2VQb3MgPSBpbnRlcmFjdGlvbl9vYmplY3QuZ2xvYmFsLnk7XG5cdHRoaXMuc3RhcnRQb3MgPSB0aGlzLmNoYXRUZXh0Lnk7XG5cdHRoaXMuc2xpZGVyLnNob3coKTtcbn1cblxuLyoqXG4gKiBPbiBtb3VzZSB1cFxuICogQG1ldGhvZCBvbkNoYXRGaWVsZE1vdXNlVXBcbiAqL1xuQ2hhdFZpZXcucHJvdG90eXBlLm9uQ2hhdEZpZWxkTW91c2VVcCA9IGZ1bmN0aW9uKGludGVyYWN0aW9uX29iamVjdCkge1xuXHRpbnRlcmFjdGlvbl9vYmplY3QudGFyZ2V0LnRvdWNoZW5kID0gaW50ZXJhY3Rpb25fb2JqZWN0LnRhcmdldC50b3VjaGVuZG91dHNpZGUgPSBudWxsO1xuXHRpbnRlcmFjdGlvbl9vYmplY3QudGFyZ2V0LnRvdWNobW92ZSA9IG51bGw7XG5cdHRoaXMuc2xpZGVyLmhpZGUoKTtcbn1cblxuLyoqXG4gKiBPbiBtb3VzZSB1cFxuICogQG1ldGhvZCBvbkNoYXRGaWVsZE1vdXNlVXBcbiAqL1xuQ2hhdFZpZXcucHJvdG90eXBlLm9uQ2hhdEZpZWxkTW91c2VNb3ZlID0gZnVuY3Rpb24oaW50ZXJhY3Rpb25fb2JqZWN0KSB7XG5cdHZhciBwb3MgPSBpbnRlcmFjdGlvbl9vYmplY3QuZ2xvYmFsLnk7XG5cdHZhciBkaWZmID0gcG9zIC0gdGhpcy5zdGFydE1vdXNlUG9zO1xuXG5cdHRoaXMuc2xpZGVyLnNldFZhbHVlKCgtKHRoaXMuc3RhcnRQb3MgKyBkaWZmKSkgLyAodGhpcy5jaGF0VGV4dC5oZWlnaHQgKyB0aGlzLm1hcmdpbiAtIHRoaXMuY2hhdE1hc2suaGVpZ2h0KSk7XG4gXHR0aGlzLm9uU2xpZGVyQ2hhbmdlKCk7XG59XG5cbi8qKlxuICogT24ga2V5IGRvd25cbiAqIEBtZXRob2Qgb25LZXlEb3duXG4gKi9cbiBDaGF0Vmlldy5wcm90b3R5cGUub25LZXlEb3duID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0aWYoZXZlbnQua2V5Q29kZSA9PSAxMykge1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcImNoYXRcIiwge3RleHQ6IHRoaXMuaW5wdXRGaWVsZC50ZXh0fSk7XG5cdFx0XG5cdFx0dGhpcy5pbnB1dEZpZWxkLnNldFRleHQoXCJcIik7XG5cdFx0XG5cdH1cbiB9XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IENoYXRWaWV3O1xuIiwiLyoqXG4gKiBDbGllbnQuXG4gKiBAbW9kdWxlIGNsaWVudFxuICovXG5cbnZhciBQSVhJID0gcmVxdWlyZShcInBpeGkuanNcIik7XG52YXIgVFdFRU4gPSByZXF1aXJlKFwidHdlZW4uanNcIik7XG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZShcInlhZWRcIik7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiaW5oZXJpdHNcIik7XG5cbi8qKlxuICogQSBjaGlwcyB2aWV3LlxuICogQGNsYXNzIENoaXBzVmlld1xuICovXG5mdW5jdGlvbiBDaGlwc1ZpZXcodmlld0NvbmZpZywgcmVzb3VyY2VzLCBzaG93VG9vbFRpcCkge1xuXHRQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIuY2FsbCh0aGlzKTtcblx0dGhpcy50YXJnZXRQb3NpdGlvbiA9IG51bGw7XG5cblx0dGhpcy52aWV3Q29uZmlnID0gdmlld0NvbmZpZztcblx0dGhpcy5yZXNvdXJjZXMgPSByZXNvdXJjZXM7XG5cblx0dGhpcy5hbGlnbiA9IFwibGVmdFwiO1xuXG5cdHRoaXMudmFsdWUgPSAwO1xuXG5cdHRoaXMuZGVub21pbmF0aW9ucyA9IFs1MDAwMDAsIDEwMDAwMCwgMjUwMDAsIDUwMDAsIDEwMDAsIDUwMCwgMTAwLCAyNSwgNSwgMV07XG5cblx0dGhpcy5zdGFja0NsaXBzID0gbmV3IEFycmF5KCk7XG5cdHRoaXMuaG9sZGVyID0gbmV3IFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcigpO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMuaG9sZGVyKTtcblxuXHR0aGlzLnRvb2xUaXAgPSBudWxsO1xuXG5cdGlmIChzaG93VG9vbFRpcCkge1xuXHRcdHRoaXMudG9vbFRpcCA9IG5ldyBUb29sVGlwKCk7XG5cdFx0dGhpcy5hZGRDaGlsZCh0aGlzLnRvb2xUaXApO1xuXHR9XG5cbn1cblxuaW5oZXJpdHMoQ2hpcHNWaWV3LCBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIpO1xuRXZlbnREaXNwYXRjaGVyLmluaXQoQ2hpcHNWaWV3KTtcblxuLyoqXG4gKiBTZXQgYWxpZ25tZW50LlxuICogQG1ldGhvZCBzZXRDYXJkRGF0YVxuICovXG5DaGlwc1ZpZXcucHJvdG90eXBlLnNldEFsaWdubWVudCA9IGZ1bmN0aW9uKGFsaWduKSB7XG5cdGlmICghYWxpZ24pXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBhbGlnbm1lbnQ6IFwiICsgYWxpZ24pO1xuXG5cdHRoaXMuYWxpZ24gPSBhbGlnbjtcbn1cblxuLyoqXG4gKiBTZXQgdGFyZ2V0IHBvc2l0aW9uLlxuICogQG1ldGhvZCBzZXRUYXJnZXRQb3NpdGlvblxuICovXG5DaGlwc1ZpZXcucHJvdG90eXBlLnNldFRhcmdldFBvc2l0aW9uID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcblx0Ly9jb25zb2xlLmxvZyhcInNldHRpbmcgdGFyZ2V0IHBvc2l0aW9uOiBcIiArIEpTT04uc3RyaW5naWZ5KHBvc2l0aW9uKSk7XG5cblx0dGhpcy50YXJnZXRQb3NpdGlvbiA9IHBvc2l0aW9uO1xuXHR0aGlzLnBvc2l0aW9uLnggPSBwb3NpdGlvbi54O1xuXHR0aGlzLnBvc2l0aW9uLnkgPSBwb3NpdGlvbi55O1xufVxuXG4vKipcbiAqIFNldCB2YWx1ZS5cbiAqIEBtZXRob2Qgc2V0VmFsdWVcbiAqL1xuQ2hpcHNWaWV3LnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuXHR2YXIgc3ByaXRlO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdGFja0NsaXBzLmxlbmd0aDsgaSsrKVxuXHRcdHRoaXMuaG9sZGVyLnJlbW92ZUNoaWxkKHRoaXMuc3RhY2tDbGlwc1tpXSk7XG5cblx0dGhpcy5zdGFja0NsaXBzID0gbmV3IEFycmF5KCk7XG5cblx0aWYgKHRoaXMudG9vbFRpcCAhPSBudWxsKVxuXHRcdHRoaXMudG9vbFRpcC50ZXh0ID0gXCJCZXQ6IFwiICsgdGhpcy52YWx1ZS50b1N0cmluZygpO1xuXG5cdHZhciBpO1xuXHR2YXIgc3RhY2tDbGlwID0gbnVsbDtcblx0dmFyIHN0YWNrUG9zID0gMDtcblx0dmFyIGNoaXBQb3MgPSAwO1xuXG5cdGZvciAoaSA9IDA7IGkgPCB0aGlzLmRlbm9taW5hdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgZGVub21pbmF0aW9uID0gdGhpcy5kZW5vbWluYXRpb25zW2ldO1xuXG5cdFx0Y2hpcFBvcyA9IDA7XG5cdFx0c3RhY2tDbGlwID0gbnVsbDtcblx0XHR3aGlsZSAodmFsdWUgPj0gZGVub21pbmF0aW9uKSB7XG5cdFx0XHRpZiAoc3RhY2tDbGlwID09IG51bGwpIHtcblx0XHRcdFx0c3RhY2tDbGlwID0gbmV3IFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcigpO1xuXHRcdFx0XHRzdGFja0NsaXAueCA9IHN0YWNrUG9zO1xuXHRcdFx0XHRzdGFja1BvcyArPSA0MDtcblx0XHRcdFx0dGhpcy5ob2xkZXIuYWRkQ2hpbGQoc3RhY2tDbGlwKTtcblx0XHRcdFx0dGhpcy5zdGFja0NsaXBzLnB1c2goc3RhY2tDbGlwKTtcblx0XHRcdH1cblx0XHRcdHZhciB0ZXh0dXJlID0gdGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcImNoaXBcIiArIChpICUgNSkpO1xuXHRcdFx0dmFyIGNoaXAgPSBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XG5cdFx0XHRjaGlwLnBvc2l0aW9uLnkgPSBjaGlwUG9zO1xuXHRcdFx0Y2hpcFBvcyAtPSA1O1xuXHRcdFx0c3RhY2tDbGlwLmFkZENoaWxkKGNoaXApO1xuXHRcdFx0dmFsdWUgLT0gZGVub21pbmF0aW9uO1xuXG5cdFx0XHR2YXIgZGVub21pbmF0aW9uU3RyaW5nO1xuXG5cdFx0XHRpZiAoZGVub21pbmF0aW9uID49IDEwMDApXG5cdFx0XHRcdGRlbm9taW5hdGlvblN0cmluZyA9IE1hdGgucm91bmQoZGVub21pbmF0aW9uIC8gMTAwMCkgKyBcIktcIjtcblxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRkZW5vbWluYXRpb25TdHJpbmcgPSBkZW5vbWluYXRpb247XG5cblx0XHRcdGlmICgoc3RhY2tDbGlwICE9IG51bGwpICYmICh2YWx1ZSA8IGRlbm9taW5hdGlvbikpIHtcblxuXHRcdFx0XHR2YXIgdGV4dEZpZWxkID0gbmV3IFBJWEkuVGV4dChkZW5vbWluYXRpb25TdHJpbmcsIHtcblx0XHRcdFx0XHRmb250OiBcImJvbGQgMTJweCBBcmlhbFwiLFxuXHRcdFx0XHRcdGFsaWduOiBcImNlbnRlclwiLFxuXHRcdFx0XHRcdGZpbGw6IHRoaXMucmVzb3VyY2VzLmdldENvbG9yKFwiY2hpcHNDb2xvclwiICsgKGkgJSA1KSlcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRleHRGaWVsZC5wb3NpdGlvbi54ID0gKHN0YWNrQ2xpcC53aWR0aCAtIHRleHRGaWVsZC53aWR0aCkgKiAwLjU7XG5cdFx0XHRcdHRleHRGaWVsZC5wb3NpdGlvbi55ID0gY2hpcFBvcyArIDExO1xuXHRcdFx0XHR0ZXh0RmllbGQuYWxwaGEgPSAwLjU7XG5cdFx0XHRcdC8qXG5cdFx0XHRcdHRleHRGaWVsZC53aWR0aCA9IHN0YWNrQ2xpcC53aWR0aCAtIDE7XG5cdFx0XHRcdHRleHRGaWVsZC5oZWlnaHQgPSAyMDsqL1xuXG5cdFx0XHRcdHN0YWNrQ2xpcC5hZGRDaGlsZCh0ZXh0RmllbGQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHN3aXRjaCAodGhpcy5hbGlnbikge1xuXHRcdGNhc2UgXCJsZWZ0XCI6XG5cdFx0Y2FzZSBcIkxcIjpcblx0XHRcdHRoaXMuaG9sZGVyLnggPSAwO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIFwiY2VudGVyXCI6XG5cdFx0Y2FzZSBcIkNcIjpcblx0XHRcdHRoaXMuaG9sZGVyLnggPSAtdGhpcy5ob2xkZXIud2lkdGggLyAyO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIFwicmlnaHRcIjpcblx0XHRjYXNlIFwiUlwiOlxuXHRcdFx0dGhpcy5ob2xkZXIueCA9IC10aGlzLmhvbGRlci53aWR0aDtcblx0XHRcdGJyZWFrO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInVua25vd24gYWxpZ246IFwiICsgdGhpcy5hbGlnbik7XG5cdH1cbn1cblxuLyoqXG4gKiBIaWRlLlxuICogQG1ldGhvZCBoaWRlXG4gKi9cbkNoaXBzVmlldy5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnZpc2libGUgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBTaG93LlxuICogQG1ldGhvZCBzaG93XG4gKi9cbkNoaXBzVmlldy5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXG5cdHZhciBkZXN0aW5hdGlvbiA9IHtcblx0XHR4OiB0aGlzLnRhcmdldFBvc2l0aW9uLngsXG5cdFx0eTogdGhpcy50YXJnZXRQb3NpdGlvbi55XG5cdH07XG5cdHRoaXMucG9zaXRpb24ueCA9ICh0aGlzLnBhcmVudC53aWR0aCAtIHRoaXMud2lkdGgpICogMC41O1xuXHR0aGlzLnBvc2l0aW9uLnkgPSAtdGhpcy5oZWlnaHQ7XG5cblx0dmFyIGRpZmZYID0gdGhpcy5wb3NpdGlvbi54IC0gZGVzdGluYXRpb24ueDtcblx0dmFyIGRpZmZZID0gdGhpcy5wb3NpdGlvbi55IC0gZGVzdGluYXRpb24ueTtcblx0dmFyIGRpZmYgPSBNYXRoLnNxcnQoZGlmZlggKiBkaWZmWCArIGRpZmZZICogZGlmZlkpO1xuXG5cdHZhciB0d2VlbiA9IG5ldyBUV0VFTi5Ud2Vlbih0aGlzLnBvc2l0aW9uKVxuXHRcdC50byh7XG5cdFx0XHR4OiBkZXN0aW5hdGlvbi54LFxuXHRcdFx0eTogZGVzdGluYXRpb24ueVxuXHRcdH0sIDMgKiBkaWZmKVxuXHRcdC5lYXNpbmcoVFdFRU4uRWFzaW5nLlF1YWRyYXRpYy5PdXQpXG5cdFx0Lm9uQ29tcGxldGUodGhpcy5vblNob3dDb21wbGV0ZS5iaW5kKHRoaXMpKVxuXHRcdC5zdGFydCgpO1xufVxuXG4vKipcbiAqIFNob3cgY29tcGxldGUuXG4gKiBAbWV0aG9kIG9uU2hvd0NvbXBsZXRlXG4gKi9cbkNoaXBzVmlldy5wcm90b3R5cGUub25TaG93Q29tcGxldGUgPSBmdW5jdGlvbigpIHtcblxuXHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJhbmltYXRpb25Eb25lXCIsIHRoaXMpO1xufVxuXG4vKipcbiAqIEFuaW1hdGUgaW4uXG4gKiBAbWV0aG9kIGFuaW1hdGVJblxuICovXG5DaGlwc1ZpZXcucHJvdG90eXBlLmFuaW1hdGVJbiA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgbyA9IHtcblx0XHR5OiB0aGlzLnJlc291cmNlcy5nZXRQb2ludChcInBvdFBvc2l0aW9uXCIpLnlcblx0fTtcblxuXHRzd2l0Y2ggKHRoaXMuYWxpZ24pIHtcblx0XHRjYXNlIFwibGVmdFwiOlxuXHRcdGNhc2UgXCJMXCI6XG5cdFx0XHRvLnggPSB0aGlzLnJlc291cmNlcy5nZXRQb2ludChcInBvdFBvc2l0aW9uXCIpLnggLSB0aGlzLndpZHRoIC8gMjtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBcImNlbnRlclwiOlxuXHRcdGNhc2UgXCJDXCI6XG5cdFx0XHRvLnggPSB0aGlzLnJlc291cmNlcy5nZXRQb2ludChcInBvdFBvc2l0aW9uXCIpLng7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgXCJyaWdodFwiOlxuXHRcdGNhc2UgXCJSXCI6XG5cdFx0XHRvLnggPSB0aGlzLnJlc291cmNlcy5nZXRQb2ludChcInBvdFBvc2l0aW9uXCIpLnggKyB0aGlzLndpZHRoIC8gMjtcblx0XHRcdGJyZWFrO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInVua25vd24gYWxpZ246IFwiICsgdGhpcy5hbGlnbik7XG5cdFx0XHRicmVhaztcblx0fVxuXG5cdHZhciB0aW1lID0gdGhpcy52aWV3Q29uZmlnLnNjYWxlQW5pbWF0aW9uVGltZSg1MDApO1xuXHR2YXIgdHdlZW4gPSBuZXcgVFdFRU4uVHdlZW4odGhpcylcblx0XHQudG8oe1xuXHRcdFx0eTogdGhpcy5yZXNvdXJjZXMuZ2V0UG9pbnQoXCJwb3RQb3NpdGlvblwiKS55LFxuXHRcdFx0eDogby54XG5cdFx0fSwgdGltZSlcblx0XHQub25Db21wbGV0ZSh0aGlzLm9uSW5BbmltYXRpb25Db21wbGV0ZS5iaW5kKHRoaXMpKVxuXHRcdC5zdGFydCgpO1xufVxuXG4vKipcbiAqIEluIGFuaW1hdGlvbiBjb21wbGV0ZS5cbiAqIEBtZXRob2Qgb25JbkFuaW1hdGlvbkNvbXBsZXRlXG4gKi9cbkNoaXBzVmlldy5wcm90b3R5cGUub25JbkFuaW1hdGlvbkNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuc2V0VmFsdWUoMCk7XG5cblx0dGhpcy5wb3NpdGlvbi54ID0gdGhpcy50YXJnZXRQb3NpdGlvbi54O1xuXHR0aGlzLnBvc2l0aW9uLnkgPSB0aGlzLnRhcmdldFBvc2l0aW9uLnk7XG5cblx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiYW5pbWF0aW9uRG9uZVwiLCB0aGlzKTtcbn1cblxuLyoqXG4gKiBBbmltYXRlIG91dC5cbiAqIEBtZXRob2QgYW5pbWF0ZU91dFxuICovXG5DaGlwc1ZpZXcucHJvdG90eXBlLmFuaW1hdGVPdXQgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5wb3NpdGlvbi55ID0gdGhpcy5yZXNvdXJjZXMuZ2V0UG9pbnQoXCJwb3RQb3NpdGlvblwiKS55O1xuXG5cdHN3aXRjaCAodGhpcy5hbGlnbikge1xuXHRcdGNhc2UgXCJsZWZ0XCI6XG5cdFx0Y2FzZSBcIkxcIjpcblx0XHRcdHRoaXMucG9zaXRpb24ueCA9IHRoaXMucmVzb3VyY2VzLmdldFBvaW50KFwicG90UG9zaXRpb25cIikueCAtIHRoaXMud2lkdGggLyAyO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIFwiY2VudGVyXCI6XG5cdFx0Y2FzZSBcIkNcIjpcblx0XHRcdHRoaXMucG9zaXRpb24ueCA9IHRoaXMucmVzb3VyY2VzLmdldFBvaW50KFwicG90UG9zaXRpb25cIikueDtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBcInJpZ2h0XCI6XG5cdFx0Y2FzZSBcIlJcIjpcblx0XHRcdHRoaXMucG9zaXRpb24ueCA9IHRoaXMucmVzb3VyY2VzLmdldFBvaW50KFwicG90UG9zaXRpb25cIikueCArIHRoaXMud2lkdGggLyAyO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBhbGlnbjogXCIgKyB0aGlzLmFsaWduKTtcblx0XHRcdGJyZWFrO1xuXHR9XG5cblx0dmFyIG8gPSB7XG5cdFx0eDogdGhpcy50YXJnZXRQb3NpdGlvbi54LFxuXHRcdHk6IHRoaXMudGFyZ2V0UG9zaXRpb24ueVxuXHR9O1xuXG5cdHZhciB0aW1lID0gdGhpcy52aWV3Q29uZmlnLnNjYWxlQW5pbWF0aW9uVGltZSg1MDApO1xuXHR2YXIgdHdlZW4gPSBuZXcgVFdFRU4uVHdlZW4odGhpcylcblx0XHQudG8obywgdGltZSlcblx0XHQub25Db21wbGV0ZSh0aGlzLm9uT3V0QW5pbWF0aW9uQ29tcGxldGUuYmluZCh0aGlzKSlcblx0XHQuc3RhcnQoKTtcblxufVxuXG4vKipcbiAqIE91dCBhbmltYXRpb24gY29tcGxldGUuXG4gKiBAbWV0aG9kIG9uT3V0QW5pbWF0aW9uQ29tcGxldGVcbiAqL1xuQ2hpcHNWaWV3LnByb3RvdHlwZS5vbk91dEFuaW1hdGlvbkNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cblx0dmFyIHRpbWUgPSA1MDA7XG5cdHZhciB0d2VlbiA9IG5ldyBUV0VFTi5Ud2Vlbih7XG5cdFx0XHR4OiAwXG5cdFx0fSlcblx0XHQudG8oe1xuXHRcdFx0eDogMTBcblx0XHR9LCB0aW1lKVxuXHRcdC5vbkNvbXBsZXRlKHRoaXMub25PdXRXYWl0QW5pbWF0aW9uQ29tcGxldGUuYmluZCh0aGlzKSlcblx0XHQuc3RhcnQoKTtcblxuXHR0aGlzLnBvc2l0aW9uLnggPSB0aGlzLnRhcmdldFBvc2l0aW9uLng7XG5cdHRoaXMucG9zaXRpb24ueSA9IHRoaXMudGFyZ2V0UG9zaXRpb24ueTtcblxufVxuXG4vKipcbiAqIE91dCB3YWl0IGFuaW1hdGlvbiBjb21wbGV0ZS5cbiAqIEBtZXRob2Qgb25PdXRXYWl0QW5pbWF0aW9uQ29tcGxldGVcbiAqL1xuQ2hpcHNWaWV3LnByb3RvdHlwZS5vbk91dFdhaXRBbmltYXRpb25Db21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXG5cdHRoaXMuc2V0VmFsdWUoMCk7XG5cblx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiYW5pbWF0aW9uRG9uZVwiLCB0aGlzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDaGlwc1ZpZXc7IiwiLyoqXG4gKiBDbGllbnQuXG4gKiBAbW9kdWxlIGNsaWVudFxuICovXG5cbnZhciBQSVhJID0gcmVxdWlyZShcInBpeGkuanNcIik7XG52YXIgVFdFRU4gPSByZXF1aXJlKFwidHdlZW4uanNcIik7XG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZShcInlhZWRcIik7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiaW5oZXJpdHNcIik7XG5cbi8qKlxuICogRGlhbG9nIHZpZXcuXG4gKiBAY2xhc3MgRGVhbGVyQnV0dG9uVmlld1xuICovXG5mdW5jdGlvbiBEZWFsZXJCdXR0b25WaWV3KHZpZXdDb25maWcsIHJlc291cmNlcykge1xuXHRQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIuY2FsbCh0aGlzKTtcblxuXHR0aGlzLnZpZXdDb25maWcgPSB2aWV3Q29uZmlnO1xuXHR0aGlzLnJlc291cmNlcyA9IHJlc291cmNlcztcblxuXHR2YXIgZGVhbGVyQnV0dG9uVGV4dHVyZSA9IHRoaXMucmVzb3VyY2VzLmdldFRleHR1cmUoXCJkZWFsZXJCdXR0b25cIik7XG5cdHRoaXMuc3ByaXRlID0gbmV3IFBJWEkuU3ByaXRlKGRlYWxlckJ1dHRvblRleHR1cmUpO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMuc3ByaXRlKTtcblx0dGhpcy5oaWRlKCk7XG59XG5cbmluaGVyaXRzKERlYWxlckJ1dHRvblZpZXcsIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcik7XG5FdmVudERpc3BhdGNoZXIuaW5pdChEZWFsZXJCdXR0b25WaWV3KTtcblxuLyoqXG4gKiBTZXQgc2VhdCBpbmRleFxuICogQG1ldGhvZCBzZXRTZWF0SW5kZXhcbiAqL1xuRGVhbGVyQnV0dG9uVmlldy5wcm90b3R5cGUuc2V0U2VhdEluZGV4ID0gZnVuY3Rpb24oc2VhdEluZGV4KSB7XG5cdHRoaXMucG9zaXRpb24ueCA9IHRoaXMucmVzb3VyY2VzLmdldFBvaW50KFwiZGVhbGVyQnV0dG9uUG9zaXRpb25cIitzZWF0SW5kZXgpLng7XG5cdHRoaXMucG9zaXRpb24ueSA9IHRoaXMucmVzb3VyY2VzLmdldFBvaW50KFwiZGVhbGVyQnV0dG9uUG9zaXRpb25cIitzZWF0SW5kZXgpLnk7XG5cdHRoaXMuZGlzcGF0Y2hFdmVudChcImFuaW1hdGlvbkRvbmVcIiwgdGhpcyk7XG59O1xuXG4vKipcbiAqIEFuaW1hdGUgdG8gc2VhdCBpbmRleC5cbiAqIEBtZXRob2QgYW5pbWF0ZVRvU2VhdEluZGV4XG4gKi9cbkRlYWxlckJ1dHRvblZpZXcucHJvdG90eXBlLmFuaW1hdGVUb1NlYXRJbmRleCA9IGZ1bmN0aW9uKHNlYXRJbmRleCkge1xuXHRpZiAoIXRoaXMudmlzaWJsZSkge1xuXHRcdHRoaXMuc2V0U2VhdEluZGV4KHNlYXRJbmRleCk7XG5cdFx0Ly8gdG9kbyBkaXNwYXRjaCBldmVudCB0aGF0IGl0J3MgY29tcGxldGU/XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiYW5pbWF0aW9uRG9uZVwiLCB0aGlzKTtcblx0XHRyZXR1cm47XG5cdH1cblx0dmFyIGRlc3RpbmF0aW9uID0gdGhpcy5yZXNvdXJjZXMuZ2V0UG9pbnQoXCJkZWFsZXJCdXR0b25Qb3NpdGlvblwiK3NlYXRJbmRleCk7XG5cdHZhciBkaWZmWCA9IHRoaXMucG9zaXRpb24ueCAtIGRlc3RpbmF0aW9uLng7XG5cdHZhciBkaWZmWSA9IHRoaXMucG9zaXRpb24ueSAtIGRlc3RpbmF0aW9uLnk7XG5cdHZhciBkaWZmID0gTWF0aC5zcXJ0KGRpZmZYICogZGlmZlggKyBkaWZmWSAqIGRpZmZZKTtcblxuXHR2YXIgdHdlZW4gPSBuZXcgVFdFRU4uVHdlZW4odGhpcy5wb3NpdGlvbilcblx0XHQudG8oe1xuXHRcdFx0eDogZGVzdGluYXRpb24ueCxcblx0XHRcdHk6IGRlc3RpbmF0aW9uLnlcblx0XHR9LCB0aGlzLnZpZXdDb25maWcuc2NhbGVBbmltYXRpb25UaW1lKDUgKiBkaWZmKSlcblx0XHQuZWFzaW5nKFRXRUVOLkVhc2luZy5RdWFkcmF0aWMuT3V0KVxuXHRcdC5vbkNvbXBsZXRlKHRoaXMub25TaG93Q29tcGxldGUuYmluZCh0aGlzKSlcblx0XHQuc3RhcnQoKTtcbn07XG5cbi8qKlxuICogU2hvdyBDb21wbGV0ZS5cbiAqIEBtZXRob2Qgb25TaG93Q29tcGxldGVcbiAqL1xuRGVhbGVyQnV0dG9uVmlldy5wcm90b3R5cGUub25TaG93Q29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiYW5pbWF0aW9uRG9uZVwiLCB0aGlzKTtcbn1cblxuLyoqXG4gKiBIaWRlLlxuICogQG1ldGhvZCBoaWRlXG4gKi9cbkRlYWxlckJ1dHRvblZpZXcucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcblx0dGhpcy52aXNpYmxlID0gZmFsc2U7XG59XG5cbi8qKlxuICogU2hvdy5cbiAqIEBtZXRob2Qgc2hvd1xuICovXG5EZWFsZXJCdXR0b25WaWV3LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oc2VhdEluZGV4LCBhbmltYXRlKSB7XG5cdGlmICh0aGlzLnZpc2libGUgJiYgYW5pbWF0ZSkge1xuXHRcdHRoaXMuYW5pbWF0ZVRvU2VhdEluZGV4KHNlYXRJbmRleCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblx0XHR0aGlzLnNldFNlYXRJbmRleChzZWF0SW5kZXgpO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGVhbGVyQnV0dG9uVmlldzsiLCIvKipcbiAqIENsaWVudC5cbiAqIEBtb2R1bGUgY2xpZW50XG4gKi9cblxudmFyIFBJWEkgPSByZXF1aXJlKFwicGl4aS5qc1wiKTtcbnZhciBCdXR0b24gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvQnV0dG9uXCIpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xuXG4vKipcbiAqIERpYWxvZyBidXR0b24uXG4gKiBAY2xhc3MgRGlhbG9nQnV0dG9uXG4gKi9cbmZ1bmN0aW9uIERpYWxvZ0J1dHRvbihyZXNvdXJjZXMpIHtcblx0QnV0dG9uLmNhbGwodGhpcyk7XG5cblx0dGhpcy5idXR0b25UZXh0dXJlID0gcmVzb3VyY2VzLmdldFRleHR1cmUoXCJkaWFsb2dCdXR0b25cIik7XG5cdHRoaXMuYWRkQ2hpbGQobmV3IFBJWEkuU3ByaXRlKHRoaXMuYnV0dG9uVGV4dHVyZSkpO1xuXG5cdHZhciBzdHlsZSA9IHtcblx0XHRmb250OiBcIm5vcm1hbCAxNHB4IEFyaWFsXCIsXG5cdFx0ZmlsbDogXCIjZmZmZmZmXCJcblx0fTtcblxuXHR0aGlzLnRleHRGaWVsZCA9IG5ldyBQSVhJLlRleHQoXCJbdGVzdF1cIiwgc3R5bGUpO1xuXHR0aGlzLnRleHRGaWVsZC5wb3NpdGlvbi55ID0gMTU7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy50ZXh0RmllbGQpO1xuXG5cdHRoaXMuc2V0VGV4dChcIkJUTlwiKTtcbn1cblxuaW5oZXJpdHMoRGlhbG9nQnV0dG9uLCBCdXR0b24pO1xuXG4vKipcbiAqIFNldCB0ZXh0IGZvciB0aGUgYnV0dG9uLlxuICogQG1ldGhvZCBzZXRUZXh0XG4gKi9cbkRpYWxvZ0J1dHRvbi5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcblx0dGhpcy50ZXh0RmllbGQuc2V0VGV4dCh0ZXh0KTtcblx0dGhpcy50ZXh0RmllbGQudXBkYXRlVHJhbnNmb3JtKCk7XG5cdHRoaXMudGV4dEZpZWxkLnggPSB0aGlzLmJ1dHRvblRleHR1cmUud2lkdGggLyAyIC0gdGhpcy50ZXh0RmllbGQud2lkdGggLyAyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERpYWxvZ0J1dHRvbjsiLCIvKipcbiAqIENsaWVudC5cbiAqIEBtb2R1bGUgY2xpZW50XG4gKi9cblxudmFyIFBJWEkgPSByZXF1aXJlKFwicGl4aS5qc1wiKTtcbnZhciBOaW5lU2xpY2UgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvTmluZVNsaWNlXCIpO1xudmFyIERpYWxvZ0J1dHRvbiA9IHJlcXVpcmUoXCIuL0RpYWxvZ0J1dHRvblwiKTtcbnZhciBCdXR0b25EYXRhID0gcmVxdWlyZShcIi4uLy4uL3Byb3RvL2RhdGEvQnV0dG9uRGF0YVwiKTtcbnZhciBQaXhpVGV4dElucHV0ID0gcmVxdWlyZShcInBpeGl0ZXh0aW5wdXRcIik7XG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZShcInlhZWRcIik7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiaW5oZXJpdHNcIik7XG5cbi8qKlxuICogRGlhbG9nIHZpZXcuXG4gKiBAY2xhc3MgRGlhbG9nVmlld1xuICovXG5mdW5jdGlvbiBEaWFsb2dWaWV3KHZpZXdDb25maWcsIHJlc291cmNlcykge1xuXHRQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIuY2FsbCh0aGlzKTtcblxuXHR0aGlzLnJlc291cmNlcyA9IHJlc291cmNlcztcblxuXHR2YXIgY292ZXIgPSBuZXcgUElYSS5HcmFwaGljcygpO1xuXHRjb3Zlci5iZWdpbkZpbGwoMHgwMDAwMDAsIC41KTtcblx0Y292ZXIuZHJhd1JlY3QoLTEwMDAsIC0xMDAwLCA5NjAgKyAyMDAwLCA3MjAgKyAyMDAwKTtcblx0Y292ZXIuZW5kRmlsbCgpO1xuXHRjb3Zlci5pbnRlcmFjdGl2ZSA9IHRydWU7XG5cdC8vY292ZXIuYnV0dG9uTW9kZSA9IHRydWU7XG5cdGNvdmVyLmhpdEFyZWEgPSBuZXcgUElYSS5SZWN0YW5nbGUoMCwgMCwgOTYwLCA3MjApO1xuXHR0aGlzLmFkZENoaWxkKGNvdmVyKTtcblxuXHR2YXIgYiA9IG5ldyBOaW5lU2xpY2UodGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcImZyYW1lUGxhdGVcIiksIDEwKTtcblx0Yi5zZXRMb2NhbFNpemUoNDgwLCAyNzApO1xuXHRiLnBvc2l0aW9uLnggPSA0ODAgLSA0ODAgLyAyO1xuXHRiLnBvc2l0aW9uLnkgPSAzNjAgLSAyNzAgLyAyO1xuXHR0aGlzLmFkZENoaWxkKGIpO1xuXG5cdHN0eWxlID0ge1xuXHRcdGZvbnQ6IFwibm9ybWFsIDE0cHggQXJpYWxcIlxuXHR9O1xuXG5cdHRoaXMudGV4dEZpZWxkID0gbmV3IFBJWEkuVGV4dChcIlt0ZXh0XVwiLCBzdHlsZSk7XG5cdHRoaXMudGV4dEZpZWxkLnBvc2l0aW9uLnggPSBiLnBvc2l0aW9uLnggKyAyMDtcblx0dGhpcy50ZXh0RmllbGQucG9zaXRpb24ueSA9IGIucG9zaXRpb24ueSArIDIwO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMudGV4dEZpZWxkKTtcblxuXHR0aGlzLmJ1dHRvbnNIb2xkZXIgPSBuZXcgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyKCk7XG5cdHRoaXMuYnV0dG9uc0hvbGRlci5wb3NpdGlvbi55ID0gNDMwO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMuYnV0dG9uc0hvbGRlcik7XG5cdHRoaXMuYnV0dG9ucyA9IFtdO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG5cdFx0dmFyIGIgPSBuZXcgRGlhbG9nQnV0dG9uKHRoaXMucmVzb3VyY2VzKTtcblxuXHRcdGIucG9zaXRpb24ueCA9IGkgKiA5MDtcblx0XHRiLm9uKFwiY2xpY2tcIiwgdGhpcy5vbkJ1dHRvbkNsaWNrLCB0aGlzKTtcblx0XHR0aGlzLmJ1dHRvbnNIb2xkZXIuYWRkQ2hpbGQoYik7XG5cdFx0dGhpcy5idXR0b25zLnB1c2goYik7XG5cdH1cblxuXHRzdHlsZSA9IHtcblx0XHRmb250OiBcIm5vcm1hbCAxOHB4IEFyaWFsXCJcblx0fTtcblxuXHR0aGlzLmlucHV0RmllbGQgPSBuZXcgUGl4aVRleHRJbnB1dChcIlwiLCBzdHlsZSk7XG5cdHRoaXMuaW5wdXRGaWVsZC5wb3NpdGlvbi54ID0gdGhpcy50ZXh0RmllbGQucG9zaXRpb24ueDtcblxuXHR0aGlzLmlucHV0RnJhbWUgPSBuZXcgUElYSS5HcmFwaGljcygpO1xuXHR0aGlzLmlucHV0RnJhbWUuYmVnaW5GaWxsKDB4MDAwMDAwKTtcblx0dGhpcy5pbnB1dEZyYW1lLmRyYXdSZWN0KC0xLCAtMSwgMTAyLCAyMyk7XG5cdHRoaXMuaW5wdXRGcmFtZS5wb3NpdGlvbi54ID0gdGhpcy5pbnB1dEZpZWxkLnBvc2l0aW9uLng7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5pbnB1dEZyYW1lKTtcblxuXHR0aGlzLmFkZENoaWxkKHRoaXMuaW5wdXRGaWVsZCk7XG5cblx0dGhpcy5oaWRlKCk7XG59XG5cbmluaGVyaXRzKERpYWxvZ1ZpZXcsIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcik7XG5FdmVudERpc3BhdGNoZXIuaW5pdChEaWFsb2dWaWV3KTtcblxuRGlhbG9nVmlldy5CVVRUT05fQ0xJQ0sgPSBcImJ1dHRvbkNsaWNrXCI7XG5cbi8qKlxuICogSGlkZS5cbiAqIEBtZXRob2QgaGlkZVxuICovXG5EaWFsb2dWaWV3LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMudmlzaWJsZSA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFNob3cuXG4gKiBAbWV0aG9kIHNob3dcbiAqL1xuRGlhbG9nVmlldy5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKHRleHQsIGJ1dHRvbklkcywgZGVmYXVsdFZhbHVlKSB7XG5cdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cblx0dGhpcy5idXR0b25JZHMgPSBidXR0b25JZHM7XG5cblx0Zm9yIChpID0gMDsgaSA8IHRoaXMuYnV0dG9ucy5sZW5ndGg7IGkrKykge1xuXHRcdGlmIChpIDwgYnV0dG9uSWRzLmxlbmd0aCkge1xuXHRcdFx0dmFyIGJ1dHRvbiA9IHRoaXMuYnV0dG9uc1tpXVxuXHRcdFx0YnV0dG9uLnNldFRleHQoQnV0dG9uRGF0YS5nZXRCdXR0b25TdHJpbmdGb3JJZChidXR0b25JZHNbaV0pKTtcblx0XHRcdGJ1dHRvbi52aXNpYmxlID0gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5idXR0b25zW2ldLnZpc2libGUgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHR0aGlzLmJ1dHRvbnNIb2xkZXIueCA9IDQ4MCAtIGJ1dHRvbklkcy5sZW5ndGggKiA5MCAvIDI7XG5cdHRoaXMudGV4dEZpZWxkLnNldFRleHQodGV4dCk7XG5cblx0aWYgKGRlZmF1bHRWYWx1ZSkge1xuXHRcdHRoaXMuaW5wdXRGaWVsZC5wb3NpdGlvbi55ID0gdGhpcy50ZXh0RmllbGQucG9zaXRpb24ueSArIHRoaXMudGV4dEZpZWxkLmhlaWdodCArIDIwO1xuXHRcdHRoaXMuaW5wdXRGcmFtZS5wb3NpdGlvbi55ID0gdGhpcy5pbnB1dEZpZWxkLnBvc2l0aW9uLnk7XG5cdFx0dGhpcy5pbnB1dEZpZWxkLnZpc2libGUgPSB0cnVlO1xuXHRcdHRoaXMuaW5wdXRGcmFtZS52aXNpYmxlID0gdHJ1ZTtcblxuXHRcdHRoaXMuaW5wdXRGaWVsZC50ZXh0ID0gZGVmYXVsdFZhbHVlO1xuXHRcdHRoaXMuaW5wdXRGaWVsZC5mb2N1cygpO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuaW5wdXRGaWVsZC52aXNpYmxlID0gZmFsc2U7XG5cdFx0dGhpcy5pbnB1dEZyYW1lLnZpc2libGUgPSBmYWxzZTtcblx0fVxufVxuXG4vKipcbiAqIEhhbmRsZSBidXR0b24gY2xpY2suXG4gKiBAbWV0aG9kIG9uQnV0dG9uQ2xpY2tcbiAqL1xuRGlhbG9nVmlldy5wcm90b3R5cGUub25CdXR0b25DbGljayA9IGZ1bmN0aW9uKGUpIHtcblx0dmFyIGJ1dHRvbkluZGV4ID0gLTE7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJ1dHRvbnMubGVuZ3RoOyBpKyspXG5cdFx0aWYgKGUudGFyZ2V0ID09IHRoaXMuYnV0dG9uc1tpXSlcblx0XHRcdGJ1dHRvbkluZGV4ID0gaTtcblxuXHR2YXIgdmFsdWUgPSBudWxsO1xuXHRpZiAodGhpcy5pbnB1dEZpZWxkLnZpc2libGUpXG5cdFx0dmFsdWUgPSB0aGlzLmlucHV0RmllbGQudGV4dDtcblxuXHR2YXIgZXYgPSB7XG5cdFx0dHlwZTogRGlhbG9nVmlldy5CVVRUT05fQ0xJQ0ssXG5cdFx0YnV0dG9uOiB0aGlzLmJ1dHRvbklkc1tidXR0b25JbmRleF0sXG5cdFx0dmFsdWU6IHZhbHVlXG5cdH07XG5cblx0dGhpcy50cmlnZ2VyKGV2KTtcblx0dGhpcy5oaWRlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGlhbG9nVmlldzsiLCIvKipcbiAqIENsaWVudC5cbiAqIEBtb2R1bGUgY2xpZW50XG4gKi9cblxudmFyIFBJWEkgPSByZXF1aXJlKFwicGl4aS5qc1wiKTtcbnZhciBHcmFkaWVudCA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9HcmFkaWVudFwiKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCJpbmhlcml0c1wiKTtcblxuLyoqXG4gKiBMb2FkaW5nIHNjcmVlbi5cbiAqIEBjbGFzcyBMb2FkaW5nU2NyZWVuXG4gKi9cbmZ1bmN0aW9uIExvYWRpbmdTY3JlZW4oKSB7XG5cdFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKHRoaXMpO1xuXG5cdHZhciBncmFkaWVudCA9IG5ldyBHcmFkaWVudCgpO1xuXHRncmFkaWVudC5zZXRTaXplKDEwMCwgMTAwKTtcblx0Z3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIFwiI2ZmZmZmZlwiKTtcblx0Z3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIFwiI2MwYzBjMFwiKTtcblxuXHR2YXIgcyA9IGdyYWRpZW50LmNyZWF0ZVNwcml0ZSgpO1xuXHRzLnBvc2l0aW9uLng9LTEwMDA7XG5cdHMucG9zaXRpb24ueT0tMTAwMDtcblx0cy53aWR0aCA9IDk2MCsyMDAwO1xuXHRzLmhlaWdodCA9IDcyMCsyMDAwO1xuXHR0aGlzLmFkZENoaWxkKHMpO1xuXG5cdHZhciBzdHlsZSA9IHtcblx0XHRmb250OiBcImJvbGQgMjBweCBBcmlhbFwiLFxuXHRcdGZpbGw6IFwiIzgwODA4MFwiXG5cdH07XG5cblx0dGhpcy50ZXh0RmllbGQgPSBuZXcgUElYSS5UZXh0KFwiW3RleHRdXCIsIHN0eWxlKTtcblx0dGhpcy50ZXh0RmllbGQucG9zaXRpb24ueCA9IDk2MCAvIDI7XG5cdHRoaXMudGV4dEZpZWxkLnBvc2l0aW9uLnkgPSA3MjAgLyAyIC0gdGhpcy50ZXh0RmllbGQuaGVpZ2h0IC8gMjtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLnRleHRGaWVsZCk7XG59XG5cbmluaGVyaXRzKExvYWRpbmdTY3JlZW4sIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcik7XG5cbi8qKlxuICogU2hvdy5cbiAqIEBtZXRob2Qgc2hvd1xuICovXG5Mb2FkaW5nU2NyZWVuLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXHR0aGlzLnRleHRGaWVsZC5zZXRUZXh0KG1lc3NhZ2UpO1xuXHR0aGlzLnRleHRGaWVsZC51cGRhdGVUcmFuc2Zvcm0oKTtcblx0dGhpcy50ZXh0RmllbGQueCA9IDk2MCAvIDIgLSB0aGlzLnRleHRGaWVsZC53aWR0aCAvIDI7XG5cdHRoaXMudmlzaWJsZSA9IHRydWU7XG59XG5cbi8qKlxuICogSGlkZS5cbiAqIEBtZXRob2QgaGlkZVxuICovXG5Mb2FkaW5nU2NyZWVuLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMudmlzaWJsZSA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExvYWRpbmdTY3JlZW47IiwiLyoqXG4gKiBDbGllbnQuXG4gKiBAbW9kdWxlIGNsaWVudFxuICovXG5cbnZhciBQSVhJID0gcmVxdWlyZShcInBpeGkuanNcIik7XG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZShcInlhZWRcIik7XG52YXIgU2VhdFZpZXcgPSByZXF1aXJlKFwiLi9TZWF0Vmlld1wiKTtcbnZhciBDYXJkVmlldyA9IHJlcXVpcmUoXCIuL0NhcmRWaWV3XCIpO1xudmFyIENoYXRWaWV3ID0gcmVxdWlyZShcIi4vQ2hhdFZpZXdcIik7XG52YXIgUG9pbnQgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvUG9pbnRcIik7XG52YXIgR3JhZGllbnQgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvR3JhZGllbnRcIik7XG52YXIgQnV0dG9uc1ZpZXcgPSByZXF1aXJlKFwiLi9CdXR0b25zVmlld1wiKTtcbnZhciBEaWFsb2dWaWV3ID0gcmVxdWlyZShcIi4vRGlhbG9nVmlld1wiKTtcbnZhciBEZWFsZXJCdXR0b25WaWV3ID0gcmVxdWlyZShcIi4vRGVhbGVyQnV0dG9uVmlld1wiKTtcbnZhciBDaGlwc1ZpZXcgPSByZXF1aXJlKFwiLi9DaGlwc1ZpZXdcIik7XG52YXIgUG90VmlldyA9IHJlcXVpcmUoXCIuL1BvdFZpZXdcIik7XG52YXIgVGltZXJWaWV3ID0gcmVxdWlyZShcIi4vVGltZXJWaWV3XCIpO1xudmFyIFNldHRpbmdzVmlldyA9IHJlcXVpcmUoXCIuLi92aWV3L1NldHRpbmdzVmlld1wiKTtcbnZhciBUYWJsZUluZm9WaWV3ID0gcmVxdWlyZShcIi4uL3ZpZXcvVGFibGVJbmZvVmlld1wiKTtcbnZhciBQcmVzZXRCdXR0b25zVmlldyA9IHJlcXVpcmUoXCIuLi92aWV3L1ByZXNldEJ1dHRvbnNWaWV3XCIpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xuXG4vKipcbiAqIE5ldCBwb2tlciBjbGllbnQgdmlldy5cbiAqIEBjbGFzcyBOZXRQb2tlckNsaWVudFZpZXdcbiAqL1xuZnVuY3Rpb24gTmV0UG9rZXJDbGllbnRWaWV3KHZpZXdDb25maWcsIHJlc291cmNlcykge1xuXHRQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIuY2FsbCh0aGlzKTtcblxuXHR0aGlzLnZpZXdDb25maWcgPSB2aWV3Q29uZmlnO1xuXHR0aGlzLnJlc291cmNlcyA9IHJlc291cmNlcztcblx0dGhpcy5zZXR1cEJhY2tncm91bmQoKTtcblxuXHR0aGlzLnRhYmxlQ29udGFpbmVyID0gbmV3IFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcigpO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMudGFibGVDb250YWluZXIpO1xuXG5cdHRoaXMudGFibGVCYWNrZ3JvdW5kID0gbmV3IFBJWEkuU3ByaXRlKHRoaXMucmVzb3VyY2VzLmdldFRleHR1cmUoXCJ0YWJsZUJhY2tncm91bmRcIikpO1xuXHR0aGlzLnRhYmxlQ29udGFpbmVyLmFkZENoaWxkKHRoaXMudGFibGVCYWNrZ3JvdW5kKTtcblx0dGhpcy50YWJsZUJhY2tncm91bmQucG9zaXRpb24ueCA9IHRoaXMucmVzb3VyY2VzLmdldFBvaW50KFwidGFibGVQb3NpdGlvblwiKS54O1xuXHR0aGlzLnRhYmxlQmFja2dyb3VuZC5wb3NpdGlvbi55ID0gdGhpcy5yZXNvdXJjZXMuZ2V0UG9pbnQoXCJ0YWJsZVBvc2l0aW9uXCIpLnk7XG5cblx0dGhpcy5zZXR1cFNlYXRzKCk7XG5cdHRoaXMuc2V0dXBDb21tdW5pdHlDYXJkcygpO1xuXG5cdHRoaXMudGltZXJWaWV3ID0gbmV3IFRpbWVyVmlldyh0aGlzLnZpZXdDb25maWcsIHRoaXMucmVzb3VyY2VzKTtcblx0dGhpcy50YWJsZUNvbnRhaW5lci5hZGRDaGlsZCh0aGlzLnRpbWVyVmlldyk7XG5cblx0dGhpcy5jaGF0VmlldyA9IG5ldyBDaGF0Vmlldyh0aGlzLnZpZXdDb25maWcsIHRoaXMucmVzb3VyY2VzKTtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLmNoYXRWaWV3KTtcblxuXHR0aGlzLmJ1dHRvbnNWaWV3ID0gbmV3IEJ1dHRvbnNWaWV3KHRoaXMudmlld0NvbmZpZywgdGhpcy5yZXNvdXJjZXMpO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMuYnV0dG9uc1ZpZXcpO1xuXG5cdHRoaXMuZGVhbGVyQnV0dG9uVmlldyA9IG5ldyBEZWFsZXJCdXR0b25WaWV3KHRoaXMudmlld0NvbmZpZywgdGhpcy5yZXNvdXJjZXMpO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMuZGVhbGVyQnV0dG9uVmlldyk7XG5cblx0dGhpcy50YWJsZUluZm9WaWV3ID0gbmV3IFRhYmxlSW5mb1ZpZXcodGhpcy52aWV3Q29uZmlnLCB0aGlzLnJlc291cmNlcyk7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy50YWJsZUluZm9WaWV3KTtcblxuXHR0aGlzLnBvdFZpZXcgPSBuZXcgUG90Vmlldyh0aGlzLnZpZXdDb25maWcsIHRoaXMucmVzb3VyY2VzKTtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLnBvdFZpZXcpO1xuXHR0aGlzLnBvdFZpZXcucG9zaXRpb24ueCA9IHRoaXMucmVzb3VyY2VzLmdldFBvaW50KFwicG90UG9zaXRpb25cIikueDtcblx0dGhpcy5wb3RWaWV3LnBvc2l0aW9uLnkgPSB0aGlzLnJlc291cmNlcy5nZXRQb2ludChcInBvdFBvc2l0aW9uXCIpLnk7XG5cblx0dGhpcy5zZXR0aW5nc1ZpZXcgPSBuZXcgU2V0dGluZ3NWaWV3KHRoaXMudmlld0NvbmZpZywgdGhpcy5yZXNvdXJjZXMpO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMuc2V0dGluZ3NWaWV3KTtcblxuXHR0aGlzLmRpYWxvZ1ZpZXcgPSBuZXcgRGlhbG9nVmlldyh0aGlzLnZpZXdDb25maWcsIHRoaXMucmVzb3VyY2VzKTtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLmRpYWxvZ1ZpZXcpO1xuXG5cdHRoaXMucHJlc2V0QnV0dG9uc1ZpZXcgPSBuZXcgUHJlc2V0QnV0dG9uc1ZpZXcodGhpcy52aWV3Q29uZmlnLCB0aGlzLnJlc291cmNlcyk7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5wcmVzZXRCdXR0b25zVmlldyk7XG5cblx0dGhpcy5zZXR1cENoaXBzKCk7XG59XG5cbmluaGVyaXRzKE5ldFBva2VyQ2xpZW50VmlldywgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyKTtcbkV2ZW50RGlzcGF0Y2hlci5pbml0KE5ldFBva2VyQ2xpZW50Vmlldyk7XG5cbk5ldFBva2VyQ2xpZW50Vmlldy5TRUFUX0NMSUNLID0gXCJzZWF0Q2xpY2tcIjtcblxuLyoqXG4gKiBTZXR1cCBiYWNrZ3JvdW5kLlxuICogQG1ldGhvZCBzZXR1cEJhY2tncm91bmRcbiAqL1xuTmV0UG9rZXJDbGllbnRWaWV3LnByb3RvdHlwZS5zZXR1cEJhY2tncm91bmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIGcgPSBuZXcgUElYSS5HcmFwaGljcygpO1xuXHRnLmJlZ2luRmlsbCgweDA1MzkxZCwgMSk7XG5cdGcuZHJhd1JlY3QoLTEwMDAsIDAsIDk2MCArIDIwMDAsIDcyMCk7XG5cdGcuZW5kRmlsbCgpO1xuXHR0aGlzLmFkZENoaWxkKGcpO1xuXG5cdHZhciBnID0gbmV3IFBJWEkuR3JhcGhpY3MoKTtcblx0Zy5iZWdpbkZpbGwoMHg5MDkwOTAsIDEpO1xuXHRnLmRyYXdSZWN0KC0xMDAwLCA3MjAsIDk2MCArIDIwMDAsIDEwMDApO1xuXHRnLmVuZEZpbGwoKTtcblx0dGhpcy5hZGRDaGlsZChnKTtcblxuXHR2YXIgZ3JhZGllbnQgPSBuZXcgR3JhZGllbnQoKTtcblx0Z3JhZGllbnQuc2V0U2l6ZSgxMDAsIDEwMCk7XG5cdGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBcIiM2MDYwNjBcIik7XG5cdGdyYWRpZW50LmFkZENvbG9yU3RvcCguMDUsIFwiI2EwYTBhMFwiKTtcblx0Z3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIFwiIzkwOTA5MFwiKTtcblxuXHR2YXIgcyA9IGdyYWRpZW50LmNyZWF0ZVNwcml0ZSgpO1xuXHRzLnBvc2l0aW9uLnkgPSA1MzA7XG5cdHMucG9zaXRpb24ueCA9IC0xMDAwO1xuXHRzLndpZHRoID0gOTYwICsgMjAwMDtcblx0cy5oZWlnaHQgPSAxOTA7XG5cdHRoaXMuYWRkQ2hpbGQocyk7XG5cblx0dmFyIHMgPSBuZXcgUElYSS5TcHJpdGUodGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcImRpdmlkZXJMaW5lXCIpKTtcblx0cy54ID0gMzQ1O1xuXHRzLnkgPSA1NDA7XG5cdHRoaXMuYWRkQ2hpbGQocyk7XG5cblx0dmFyIHMgPSBuZXcgUElYSS5TcHJpdGUodGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcImRpdmlkZXJMaW5lXCIpKTtcblx0cy54ID0gNjkzO1xuXHRzLnkgPSA1NDA7XG5cdHRoaXMuYWRkQ2hpbGQocyk7XG59XG5cbi8qKlxuICogU2V0dXAgc2VhdHMuXG4gKiBAbWV0aG9kIHNlcnVwU2VhdHNcbiAqL1xuTmV0UG9rZXJDbGllbnRWaWV3LnByb3RvdHlwZS5zZXR1cFNlYXRzID0gZnVuY3Rpb24oKSB7XG5cdHZhciBpLCBqO1xuXHR2YXIgcG9ja2V0Q2FyZHM7XG5cblx0dGhpcy5zZWF0Vmlld3MgPSBbXTtcblxuXHRmb3IgKGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdHZhciBzZWF0VmlldyA9IG5ldyBTZWF0Vmlldyh0aGlzLnJlc291cmNlcywgaSk7XG5cdFx0dmFyIHAgPSBzZWF0Vmlldy5wb3NpdGlvbjtcblxuXHRcdGZvciAoaiA9IDA7IGogPCAyOyBqKyspIHtcblx0XHRcdHZhciBjID0gbmV3IENhcmRWaWV3KHRoaXMudmlld0NvbmZpZywgdGhpcy5yZXNvdXJjZXMpO1xuXHRcdFx0Yy5oaWRlKCk7XG5cdFx0XHRjLnNldFRhcmdldFBvc2l0aW9uKFBvaW50KHAueCArIGogKiAzMCAtIDYwLCBwLnkgLSAxMDApKTtcblx0XHRcdHRoaXMudGFibGVDb250YWluZXIuYWRkQ2hpbGQoYyk7XG5cdFx0XHRzZWF0Vmlldy5hZGRQb2NrZXRDYXJkKGMpO1xuXHRcdFx0c2VhdFZpZXcub24oXCJjbGlja1wiLCB0aGlzLm9uU2VhdENsaWNrLCB0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLnRhYmxlQ29udGFpbmVyLmFkZENoaWxkKHNlYXRWaWV3KTtcblx0XHR0aGlzLnNlYXRWaWV3cy5wdXNoKHNlYXRWaWV3KTtcblx0fVxufVxuXG4vKipcbiAqIFNldHVwIGNoaXBzLlxuICogQG1ldGhvZCBzZXJ1cFNlYXRzXG4gKi9cbk5ldFBva2VyQ2xpZW50Vmlldy5wcm90b3R5cGUuc2V0dXBDaGlwcyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgaTtcblx0Zm9yIChpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHR2YXIgY2hpcHNWaWV3ID0gbmV3IENoaXBzVmlldyh0aGlzLnZpZXdDb25maWcsIHRoaXMucmVzb3VyY2VzKTtcblx0XHR0aGlzLnNlYXRWaWV3c1tpXS5zZXRCZXRDaGlwc1ZpZXcoY2hpcHNWaWV3KTtcblxuXHRcdGNoaXBzVmlldy5zZXRBbGlnbm1lbnQodGhpcy5yZXNvdXJjZXMuZ2V0VmFsdWUoXCJiZXRBbGlnblwiKS5jaGFyQXQoaSkpO1xuXHRcdGNoaXBzVmlldy5zZXRUYXJnZXRQb3NpdGlvbih0aGlzLnJlc291cmNlcy5nZXRQb2ludChcImJldFBvc2l0aW9uXCIraSkpO1xuXHRcdHRoaXMudGFibGVDb250YWluZXIuYWRkQ2hpbGQoY2hpcHNWaWV3KTtcblx0fVxufVxuXG4vKipcbiAqIFNlYXQgY2xpY2suXG4gKiBAbWV0aG9kIG9uU2VhdENsaWNrXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRQb2tlckNsaWVudFZpZXcucHJvdG90eXBlLm9uU2VhdENsaWNrID0gZnVuY3Rpb24oZSkge1xuXHR2YXIgc2VhdEluZGV4ID0gLTE7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNlYXRWaWV3cy5sZW5ndGg7IGkrKylcblx0XHRpZiAoZS50YXJnZXQgPT0gdGhpcy5zZWF0Vmlld3NbaV0pXG5cdFx0XHRzZWF0SW5kZXggPSBpO1xuXG5cdGNvbnNvbGUubG9nKFwic2VhdCBjbGljazogXCIgKyBzZWF0SW5kZXgpO1xuXHR0aGlzLnRyaWdnZXIoe1xuXHRcdHR5cGU6IE5ldFBva2VyQ2xpZW50Vmlldy5TRUFUX0NMSUNLLFxuXHRcdHNlYXRJbmRleDogc2VhdEluZGV4XG5cdH0pO1xufVxuXG4vKipcbiAqIFNldHVwIGNvbW11bml0eSBjYXJkcy5cbiAqIEBtZXRob2Qgc2V0dXBDb21tdW5pdHlDYXJkc1xuICogQHByaXZhdGVcbiAqL1xuTmV0UG9rZXJDbGllbnRWaWV3LnByb3RvdHlwZS5zZXR1cENvbW11bml0eUNhcmRzID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuY29tbXVuaXR5Q2FyZHMgPSBbXTtcblxuXHR2YXIgcCA9IHRoaXMucmVzb3VyY2VzLmdldFBvaW50KFwiY29tbXVuaXR5Q2FyZHNQb3NpdGlvblwiKTtcblx0dmFyIG1hcmdpbiA9IHBhcnNlSW50KHRoaXMucmVzb3VyY2VzLmdldFZhbHVlKFwiY29tbXVuaXR5Q2FyZE1hcmdpblwiKSk7XG5cdGZvciAoaSA9IDA7IGkgPCA1OyBpKyspIHtcblx0XHR2YXIgY2FyZFZpZXcgPSBuZXcgQ2FyZFZpZXcodGhpcy52aWV3Q29uZmlnLCB0aGlzLnJlc291cmNlcyk7XG5cdFx0Y2FyZFZpZXcuaGlkZSgpO1xuXHRcdGNhcmRWaWV3LnNldFRhcmdldFBvc2l0aW9uKFBvaW50KHAueCArIGkgKiAoY2FyZFZpZXcuYmFjay53aWR0aCArIG1hcmdpbiksIHAueSkpO1xuXG5cdFx0dGhpcy5jb21tdW5pdHlDYXJkcy5wdXNoKGNhcmRWaWV3KTtcblx0XHR0aGlzLnRhYmxlQ29udGFpbmVyLmFkZENoaWxkKGNhcmRWaWV3KTtcblx0fVxufVxuXG4vKipcbiAqIEdldCBzZWF0IHZpZXcgYnkgaW5kZXguXG4gKiBAbWV0aG9kIGdldFNlYXRWaWV3QnlJbmRleFxuICovXG5OZXRQb2tlckNsaWVudFZpZXcucHJvdG90eXBlLmdldFNlYXRWaWV3QnlJbmRleCA9IGZ1bmN0aW9uKGluZGV4KSB7XG5cdHJldHVybiB0aGlzLnNlYXRWaWV3c1tpbmRleF07XG59XG5cbi8qKlxuICogR2V0IGNvbW11bml0eSBjYXJkcy5cbiAqIEBtZXRob2QgZ2V0Q29tbXVuaXR5Q2FyZHNcbiAqL1xuTmV0UG9rZXJDbGllbnRWaWV3LnByb3RvdHlwZS5nZXRDb21tdW5pdHlDYXJkcyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5jb21tdW5pdHlDYXJkcztcbn1cblxuLyoqXG4gKiBHZXQgYnV0dG9ucyB2aWV3LlxuICogQG1ldGhvZCBnZXRCdXR0b25zVmlld1xuICovXG5OZXRQb2tlckNsaWVudFZpZXcucHJvdG90eXBlLmdldEJ1dHRvbnNWaWV3ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmJ1dHRvbnNWaWV3O1xufVxuXG4vKipcbiAqIEdldCBwcmVzZXQgYnV0dG9ucyB2aWV3LlxuICogQG1ldGhvZCBwcmVzZXRCdXR0b25zVmlld1xuICovXG5OZXRQb2tlckNsaWVudFZpZXcucHJvdG90eXBlLmdldFByZXNldEJ1dHRvbnNWaWV3ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnByZXNldEJ1dHRvbnNWaWV3O1xufVxuXG4vKipcbiAqIEdldCBkaWFsb2cgdmlldy5cbiAqIEBtZXRob2QgZ2V0RGlhbG9nVmlld1xuICovXG5OZXRQb2tlckNsaWVudFZpZXcucHJvdG90eXBlLmdldERpYWxvZ1ZpZXcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuZGlhbG9nVmlldztcbn1cblxuLyoqXG4gKiBHZXQgZGlhbG9nIHZpZXcuXG4gKiBAbWV0aG9kIGdldERlYWxlckJ1dHRvblZpZXdcbiAqL1xuTmV0UG9rZXJDbGllbnRWaWV3LnByb3RvdHlwZS5nZXREZWFsZXJCdXR0b25WaWV3ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmRlYWxlckJ1dHRvblZpZXc7XG59XG5cbi8qKlxuICogR2V0IHRhYmxlIGluZm8gdmlldy5cbiAqIEBtZXRob2QgZ2V0VGFibGVJbmZvVmlld1xuICovXG5OZXRQb2tlckNsaWVudFZpZXcucHJvdG90eXBlLmdldFRhYmxlSW5mb1ZpZXcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMudGFibGVJbmZvVmlldztcbn1cblxuLyoqXG4gKiBHZXQgc2V0dGluZ3Mgdmlldy5cbiAqIEBtZXRob2QgZ2V0U2V0dGluZ3NWaWV3XG4gKi9cbk5ldFBva2VyQ2xpZW50Vmlldy5wcm90b3R5cGUuZ2V0U2V0dGluZ3NWaWV3ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnNldHRpbmdzVmlldztcbn1cblxuLyoqXG4gKiBDbGVhciBldmVyeXRoaW5nIHRvIGFuIGVtcHR5IHN0YXRlLlxuICogQG1ldGhvZCBjbGVhclxuICovXG5OZXRQb2tlckNsaWVudFZpZXcucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdHZhciBpO1xuXG5cdGZvciAoaSA9IDA7IGkgPCB0aGlzLmNvbW11bml0eUNhcmRzLmxlbmd0aDsgaSsrKVxuXHRcdHRoaXMuY29tbXVuaXR5Q2FyZHNbaV0uaGlkZSgpO1xuXG5cdGZvciAoaSA9IDA7IGkgPCB0aGlzLnNlYXRWaWV3cy5sZW5ndGg7IGkrKylcblx0XHR0aGlzLnNlYXRWaWV3c1tpXS5jbGVhcigpO1xuXG5cdHRoaXMudGltZXJWaWV3LmhpZGUoKTtcblx0dGhpcy5wb3RWaWV3LnNldFZhbHVlcyhuZXcgQXJyYXkoKSk7XG5cdHRoaXMuZGVhbGVyQnV0dG9uVmlldy5oaWRlKCk7XG5cdHRoaXMuY2hhdFZpZXcuY2xlYXIoKTtcblxuXHR0aGlzLnByZXNldEJ1dHRvbnNWaWV3LmhpZGUoKTtcblxuXHR0aGlzLmRpYWxvZ1ZpZXcuaGlkZSgpO1xuXHR0aGlzLmJ1dHRvbnNWaWV3LmNsZWFyKCk7XG5cblx0dGhpcy50YWJsZUluZm9WaWV3LmNsZWFyKCk7XG5cdHRoaXMuc2V0dGluZ3NWaWV3LmNsZWFyKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTmV0UG9rZXJDbGllbnRWaWV3OyIsIi8qKlxuICogQ2xpZW50LlxuICogQG1vZHVsZSBjbGllbnRcbiAqL1xuXG52YXIgUElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xudmFyIFRXRUVOID0gcmVxdWlyZShcInR3ZWVuLmpzXCIpO1xudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoXCJ5YWVkXCIpO1xudmFyIENoaXBzVmlldyA9IHJlcXVpcmUoXCIuL0NoaXBzVmlld1wiKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCJpbmhlcml0c1wiKTtcblxuLyoqXG4gKiBBIHBvdCB2aWV3XG4gKiBAY2xhc3MgUG90Vmlld1xuICovXG5mdW5jdGlvbiBQb3RWaWV3KHZpZXdDb25maWcsIHJlc291cmNlcykge1xuXHRQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIuY2FsbCh0aGlzKTtcblx0XG5cdHRoaXMudmlld0NvbmZpZyA9IHZpZXdDb25maWdcblx0dGhpcy5yZXNvdXJjZXMgPSByZXNvdXJjZXM7XG5cdHRoaXMudmFsdWUgPSAwO1xuXG5cdHRoaXMuaG9sZGVyID0gbmV3IFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcigpO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMuaG9sZGVyKTtcblxuXHR0aGlzLnN0YWNrcyA9IG5ldyBBcnJheSgpO1xufVxuXG5pbmhlcml0cyhQb3RWaWV3LCBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIpO1xuRXZlbnREaXNwYXRjaGVyLmluaXQoUG90Vmlldyk7XG5cbi8qKlxuICogU2V0IHZhbHVlLlxuICogQG1ldGhvZCBzZXRWYWx1ZVxuICovXG5Qb3RWaWV3LnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbih2YWx1ZXMpIHtcblx0XG5cdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnN0YWNrcy5sZW5ndGg7IGkrKylcblx0XHR0aGlzLmhvbGRlci5yZW1vdmVDaGlsZCh0aGlzLnN0YWNrc1tpXSk7XG5cblx0dGhpcy5zdGFja3MgPSBuZXcgQXJyYXkoKTtcblxuXHR2YXIgcG9zID0gMDtcblxuXHRmb3IodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGNoaXBzID0gbmV3IENoaXBzVmlldyh0aGlzLnZpZXdDb25maWcsIHRoaXMucmVzb3VyY2VzLCBmYWxzZSk7XG5cdFx0dGhpcy5zdGFja3MucHVzaChjaGlwcyk7XG5cdFx0dGhpcy5ob2xkZXIuYWRkQ2hpbGQoY2hpcHMpO1xuXHRcdGNoaXBzLnNldFZhbHVlKHZhbHVlc1tpXSk7XG5cdFx0Y2hpcHMueCA9IHBvcztcblx0XHRwb3MgKz0gTWF0aC5mbG9vcihjaGlwcy53aWR0aCArIDIwKTtcblxuXHRcdHZhciB0ZXh0RmllbGQgPSBuZXcgUElYSS5UZXh0KHZhbHVlc1tpXSwge1xuXHRcdFx0Zm9udDogXCJib2xkIDEycHggQXJpYWxcIixcblx0XHRcdGFsaWduOiBcImNlbnRlclwiLFxuXHRcdFx0ZmlsbDogXCIjZmZmZmZmXCJcblx0XHR9KTtcblxuXHRcdHRleHRGaWVsZC5wb3NpdGlvbi54ID0gKGNoaXBzLndpZHRoIC0gdGV4dEZpZWxkLndpZHRoKSowLjU7XG5cdFx0dGV4dEZpZWxkLnBvc2l0aW9uLnkgPSAzMDtcblxuXHRcdGNoaXBzLmFkZENoaWxkKHRleHRGaWVsZCk7XG5cdH1cblxuXHR0aGlzLmhvbGRlci54ID0gLXRoaXMuaG9sZGVyLndpZHRoKjAuNTtcbn1cblxuLyoqXG4gKiBIaWRlLlxuICogQG1ldGhvZCBoaWRlXG4gKi9cblBvdFZpZXcucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcblx0dGhpcy52aXNpYmxlID0gZmFsc2U7XG59XG5cbi8qKlxuICogU2hvdy5cbiAqIEBtZXRob2Qgc2hvd1xuICovXG5Qb3RWaWV3LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQb3RWaWV3OyIsIi8qKlxuICogQ2xpZW50LlxuICogQG1vZHVsZSBjbGllbnRcbiAqL1xuXG52YXIgUElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xudmFyIFRXRUVOID0gcmVxdWlyZShcInR3ZWVuLmpzXCIpO1xudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoXCJ5YWVkXCIpO1xudmFyIENoZWNrYm94ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL0NoZWNrYm94XCIpO1xudmFyIEJ1dHRvbkRhdGEgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vZGF0YS9CdXR0b25EYXRhXCIpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xuXG4vKipcbiAqIEEgcG90IHZpZXdcbiAqIEBjbGFzcyBQcmVzZXRCdXR0b25cbiAqL1xuZnVuY3Rpb24gUHJlc2V0QnV0dG9uKHJlc291cmNlcykge1xuXHRQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIuY2FsbCh0aGlzKTtcblx0XG5cdHRoaXMucmVzb3VyY2VzID0gcmVzb3VyY2VzO1xuXG5cdHRoaXMuaWQgPSBudWxsO1xuXHR0aGlzLnZpc2libGUgPSBmYWxzZTtcblx0dGhpcy52YWx1ZSA9IDA7XG5cblx0dmFyIGIgPSBuZXcgUElYSS5TcHJpdGUodGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcImNoZWNrYm94QmFja2dyb3VuZFwiKSk7XG5cdHZhciB0ID0gbmV3IFBJWEkuU3ByaXRlKHRoaXMucmVzb3VyY2VzLmdldFRleHR1cmUoXCJjaGVja2JveFRpY2tcIikpO1xuXHR0LnggPSAxO1xuXG5cdHRoaXMuY2hlY2tib3ggPSBuZXcgQ2hlY2tib3goYix0KTtcblx0dGhpcy5jaGVja2JveC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMub25DaGVja2JveENoYW5nZSwgdGhpcyk7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5jaGVja2JveCk7XG5cblx0dmFyIHN0eWxlT2JqZWN0ID0ge1xuXHRcdGZvbnQ6IFwiYm9sZCAxMnB4IEFyaWFsXCIsXG5cdFx0d29yZFdyYXA6IHRydWUsXG5cdFx0d29yZFdyYXBXaWR0aDogMjUwLFxuXHRcdGZpbGw6IFwid2hpdGVcIlxuXHR9O1xuXG5cdHRoaXMubGFiZWxGaWVsZCA9IG5ldyBQSVhJLlRleHQoXCJcIiwgc3R5bGVPYmplY3QpO1xuXHR0aGlzLmxhYmVsRmllbGQucG9zaXRpb24ueCA9IDI1O1xuXG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5sYWJlbEZpZWxkKTtcbn1cblxuaW5oZXJpdHMoUHJlc2V0QnV0dG9uLCBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIpO1xuRXZlbnREaXNwYXRjaGVyLmluaXQoUHJlc2V0QnV0dG9uKTtcblxuXG5QcmVzZXRCdXR0b24uQ0hBTkdFID0gXCJjaGFuZ2VcIjtcblxuLyoqXG4gKiBQcmVzZXQgYnV0dG9uIGNoYW5nZS5cbiAqIEBtZXRob2Qgb25QcmVzZXRCdXR0b25DaGFuZ2VcbiAqL1xuUHJlc2V0QnV0dG9uLnByb3RvdHlwZS5vbkNoZWNrYm94Q2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuZGlzcGF0Y2hFdmVudChQcmVzZXRCdXR0b24uQ0hBTkdFKTtcbn1cblxuLyoqXG4gKiBTZXQgbGFiZWwuXG4gKiBAbWV0aG9kIHNldExhYmVsXG4gKi9cblByZXNldEJ1dHRvbi5wcm90b3R5cGUuc2V0TGFiZWwgPSBmdW5jdGlvbihsYWJlbCkge1xuXHR0aGlzLmxhYmVsRmllbGQuc2V0VGV4dChsYWJlbCk7XG5cdHJldHVybiBsYWJlbDtcbn1cblxuLyoqXG4gKiBTaG93LlxuICogQG1ldGhvZCBzaG93XG4gKi9cblByZXNldEJ1dHRvbi5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKGlkLCB2YWx1ZSkge1xuXHR0aGlzLmlkID0gaWQ7XG5cdHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuXHRpZih0aGlzLnZhbHVlID4gMClcblx0XHR0aGlzLnNldExhYmVsKEJ1dHRvbkRhdGEuZ2V0QnV0dG9uU3RyaW5nRm9ySWQoaWQpK1wiIChcIit0aGlzLnZhbHVlK1wiKVwiKTtcblxuXHRlbHNlXG5cdFx0dGhpcy5zZXRMYWJlbChCdXR0b25EYXRhLmdldEJ1dHRvblN0cmluZ0ZvcklkKGlkKSk7XG5cblx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBIaWRlLlxuICogQG1ldGhvZCBoaWRlXG4gKi9cblByZXNldEJ1dHRvbi5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLmlkID0gbnVsbDtcblx0dGhpcy52aXNpYmxlID0gZmFsc2U7XG5cdHRoaXMudmFsdWUgPSAwO1xuXHR0aGlzLnNldENoZWNrZWQoZmFsc2UpO1xufVxuXG4vKipcbiAqIEdldCBjaGVja2VkLlxuICogQG1ldGhvZCBnZXRDaGVja2VkXG4gKi9cblByZXNldEJ1dHRvbi5wcm90b3R5cGUuZ2V0Q2hlY2tlZCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5jaGVja2JveC5nZXRDaGVja2VkKCk7XG59XG5cbi8qKlxuICogU2V0IGNoZWNrZWQuXG4gKiBAbWV0aG9kIHNldENoZWNrZWRcbiAqL1xuUHJlc2V0QnV0dG9uLnByb3RvdHlwZS5zZXRDaGVja2VkID0gZnVuY3Rpb24oYikge1xuXHR0aGlzLmNoZWNrYm94LnNldENoZWNrZWQoYik7XG5cblx0cmV0dXJuIHRoaXMuY2hlY2tib3guZ2V0Q2hlY2tlZCgpO1xufVxuXG4vKipcbiAqIEdldCB2YWx1ZS5cbiAqIEBtZXRob2QgZ2V0VmFsdWVcbiAqL1xuUHJlc2V0QnV0dG9uLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy52YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQcmVzZXRCdXR0b247IiwiLyoqXG4gKiBDbGllbnQuXG4gKiBAbW9kdWxlIGNsaWVudFxuICovXG5cbnZhciBQSVhJID0gcmVxdWlyZShcInBpeGkuanNcIik7XG52YXIgVFdFRU4gPSByZXF1aXJlKFwidHdlZW4uanNcIik7XG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZShcInlhZWRcIik7XG52YXIgUHJlc2V0QnV0dG9uID0gcmVxdWlyZShcIi4vUHJlc2V0QnV0dG9uXCIpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xuXG4vKipcbiAqIEEgcG90IHZpZXdcbiAqIEBjbGFzcyBQcmVzZXRCdXR0b25zVmlld1xuICovXG5mdW5jdGlvbiBQcmVzZXRCdXR0b25zVmlldyh2aWV3Q29uZmlnLCByZXNvdXJjZXMpIHtcblx0UElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLmNhbGwodGhpcyk7XG5cblx0dGhpcy5yZXNvdXJjZXMgPSByZXNvdXJjZXM7XG5cblx0dGhpcy5idXR0b25zID0gbmV3IEFycmF5KCk7XG5cdHZhciBvcmlnaW4gPSB0aGlzLnJlc291cmNlcy5nZXRQb2ludChcImJpZ0J1dHRvblBvc2l0aW9uXCIpO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG5cdFx0dmFyIHAgPSBuZXcgUHJlc2V0QnV0dG9uKHRoaXMucmVzb3VyY2VzKTtcblx0XHRwLmFkZEV2ZW50TGlzdGVuZXIoUHJlc2V0QnV0dG9uLkNIQU5HRSwgdGhpcy5vblByZXNldEJ1dHRvbkNoYW5nZSwgdGhpcyk7XG5cdFx0cC54ID0gb3JpZ2luLnggKyAzMCArIDE0MCAqIChpICUgMik7XG5cdFx0cC55ID0gb3JpZ2luLnkgKyAzNSAqIE1hdGguZmxvb3IoaSAvIDIpO1xuXHRcdHRoaXMuYWRkQ2hpbGQocCk7XG5cdFx0dGhpcy5idXR0b25zLnB1c2gocCk7XG5cdH1cblxuXHR0aGlzLmhpZGUoKTtcbn1cblxuaW5oZXJpdHMoUHJlc2V0QnV0dG9uc1ZpZXcsIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcik7XG5FdmVudERpc3BhdGNoZXIuaW5pdChQcmVzZXRCdXR0b25zVmlldyk7XG5cblByZXNldEJ1dHRvbnNWaWV3LkNIQU5HRSA9IFwiY2hhbmdlXCI7XG5cbi8qKlxuICogUHJlc2V0IGJ1dHRvbiBjaGFuZ2UuXG4gKiBAbWV0aG9kIG9uUHJlc2V0QnV0dG9uQ2hhbmdlXG4gKi9cblByZXNldEJ1dHRvbnNWaWV3LnByb3RvdHlwZS5vblByZXNldEJ1dHRvbkNoYW5nZSA9IGZ1bmN0aW9uKGV2KSB7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJ1dHRvbnMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgYiA9IHRoaXMuYnV0dG9uc1tpXTtcblx0XHRpZiAoYiAhPSBldi50YXJnZXQpIHtcblx0XHRcdGIuc2V0Q2hlY2tlZChmYWxzZSk7XG5cdFx0fVxuXHR9XG5cblx0dGhpcy5kaXNwYXRjaEV2ZW50KFByZXNldEJ1dHRvbnNWaWV3LkNIQU5HRSk7XG59XG5cbi8qKlxuICogSGlkZS5cbiAqIEBtZXRob2QgaGlkZVxuICovXG5QcmVzZXRCdXR0b25zVmlldy5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYnV0dG9ucy5sZW5ndGg7IGkrKykge1xuXHRcdHRoaXMuYnV0dG9uc1tpXS5oaWRlKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBTaG93LlxuICogQG1ldGhvZCBzaG93XG4gKi9cblByZXNldEJ1dHRvbnNWaWV3LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cbn1cblxuLyoqXG4gKiBHZXQgYnV0dG9ucy5cbiAqIEBtZXRob2QgZ2V0QnV0dG9uc1xuICovXG5QcmVzZXRCdXR0b25zVmlldy5wcm90b3R5cGUuZ2V0QnV0dG9ucyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5idXR0b25zO1xufVxuXG4vKipcbiAqIEdldCBjdXJyZW50IHByZXNldCBidXR0b24uXG4gKiBAbWV0aG9kIGdldEN1cnJlbnRcbiAqL1xuUHJlc2V0QnV0dG9uc1ZpZXcucHJvdG90eXBlLmdldEN1cnJlbnQgPSBmdW5jdGlvbigpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJ1dHRvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAodGhpcy5idXR0b25zW2ldLmdldENoZWNrZWQoKSA9PSB0cnVlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5idXR0b25zW2ldO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBHZXQgY3VycmVudCBwcmVzZXQgYnV0dG9uLlxuICogQG1ldGhvZCBzZXRDdXJyZW50XG4gKi9cblByZXNldEJ1dHRvbnNWaWV3LnByb3RvdHlwZS5zZXRDdXJyZW50ID0gZnVuY3Rpb24oaWQpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJ1dHRvbnMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgYiA9IHRoaXMuYnV0dG9uc1tpXTtcblx0XHRpZiAoKGlkICE9IG51bGwpICYmIChiLmlkID09IGlkKSkge1xuXHRcdFx0Yi5zZXRDaGVja2VkKHRydWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRiLnNldENoZWNrZWQoZmFsc2UpO1xuXHRcdH1cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByZXNldEJ1dHRvbnNWaWV3OyIsIi8qKlxuICogQ2xpZW50LlxuICogQG1vZHVsZSBjbGllbnRcbiAqL1xuXG52YXIgUElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xudmFyIFRXRUVOID0gcmVxdWlyZShcInR3ZWVuLmpzXCIpO1xudmFyIEJ1dHRvbiA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9CdXR0b25cIik7XG52YXIgTmluZVNsaWNlID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL05pbmVTbGljZVwiKTtcbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKFwieWFlZFwiKTtcbnZhciBDaGVja2JveCA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9DaGVja2JveFwiKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCJpbmhlcml0c1wiKTtcblxuLyoqXG4gKiBSYWlzZSBzaG9ydGN1dCBidXR0b25cbiAqIEBjbGFzcyBSYWlzZVNob3J0Y3V0QnV0dG9uXG4gKi9cbmZ1bmN0aW9uIFJhaXNlU2hvcnRjdXRCdXR0b24ocmVzb3VyY2VzKSB7XG5cdHZhciBiYWNrZ3JvdW5kID0gbmV3IE5pbmVTbGljZShyZXNvdXJjZXMuZ2V0VGV4dHVyZShcImJ1dHRvbkJhY2tncm91bmRcIiksIDEwLCA1LCAxMCwgNSk7XG5cdGJhY2tncm91bmQuc2V0TG9jYWxTaXplKDEwNSwgMjUpO1xuXHRCdXR0b24uY2FsbCh0aGlzLCBiYWNrZ3JvdW5kKTtcblxuXHR2YXIgc3R5bGVPYmplY3QgPSB7XG5cdFx0d2lkdGg6IDEwNSxcblx0XHRoZWlnaHQ6IDIwLFxuXHRcdGZvbnQ6IFwiYm9sZCAxNHB4IEFyaWFsXCIsXG5cdFx0Y29sb3I6IFwid2hpdGVcIlxuXHR9O1xuXHR0aGlzLmxhYmVsID0gbmV3IFBJWEkuVGV4dChcIlwiLCBzdHlsZU9iamVjdCk7XG5cdHRoaXMubGFiZWwucG9zaXRpb24ueCA9IDg7XG5cdHRoaXMubGFiZWwucG9zaXRpb24ueSA9IDQ7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5sYWJlbCk7XG59XG5cbmluaGVyaXRzKFJhaXNlU2hvcnRjdXRCdXR0b24sIEJ1dHRvbik7XG5FdmVudERpc3BhdGNoZXIuaW5pdChSYWlzZVNob3J0Y3V0QnV0dG9uKTtcblxuLyoqXG4gKiBTZXR0ZXIuXG4gKiBAbWV0aG9kIHNldFRleHRcbiAqL1xuUmFpc2VTaG9ydGN1dEJ1dHRvbi5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uKHN0cmluZykge1xuXHR0aGlzLmxhYmVsLnNldFRleHQoc3RyaW5nKTtcblx0cmV0dXJuIHN0cmluZztcbn1cblxuLyoqXG4gKiBTZXQgZW5hYmxlZC5cbiAqIEBtZXRob2Qgc2V0RW5hYmxlZFxuICovXG5SYWlzZVNob3J0Y3V0QnV0dG9uLnByb3RvdHlwZS5zZXRFbmFibGVkID0gZnVuY3Rpb24odmFsdWUpIHtcblx0aWYgKHZhbHVlKSB7XG5cdFx0dGhpcy5hbHBoYSA9IDE7XG5cdFx0dGhpcy5pbnRlcmFjdGl2ZSA9IHRydWU7XG5cdFx0dGhpcy5idXR0b25Nb2RlID0gdHJ1ZTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLmFscGhhID0gMC41O1xuXHRcdHRoaXMuaW50ZXJhY3RpdmUgPSBmYWxzZTtcblx0XHR0aGlzLmJ1dHRvbk1vZGUgPSBmYWxzZTtcblx0fVxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmFpc2VTaG9ydGN1dEJ1dHRvbjsiLCIvKipcbiAqIENsaWVudC5cbiAqIEBtb2R1bGUgY2xpZW50XG4gKi9cblxudmFyIFBJWEkgPSByZXF1aXJlKFwicGl4aS5qc1wiKTtcbnZhciBUV0VFTiA9IHJlcXVpcmUoXCJ0d2Vlbi5qc1wiKTtcbnZhciBCdXR0b24gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvQnV0dG9uXCIpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xuXG4vKipcbiAqIEEgc2VhdCB2aWV3LlxuICogQGNsYXNzIFNlYXRWaWV3XG4gKi9cbmZ1bmN0aW9uIFNlYXRWaWV3KHJlc291cmNlcywgc2VhdEluZGV4KSB7XG5cdEJ1dHRvbi5jYWxsKHRoaXMpO1xuXG5cdHRoaXMucG9ja2V0Q2FyZHMgPSBbXTtcblx0dGhpcy5yZXNvdXJjZXMgPSByZXNvdXJjZXM7XG5cdHRoaXMuc2VhdEluZGV4ID0gc2VhdEluZGV4O1xuXG5cdHZhciBzZWF0VGV4dHVyZSA9IHRoaXMucmVzb3VyY2VzLmdldFRleHR1cmUoXCJzZWF0UGxhdGVcIik7XG5cdHZhciBzZWF0U3ByaXRlID0gbmV3IFBJWEkuU3ByaXRlKHNlYXRUZXh0dXJlKTtcblxuXHRzZWF0U3ByaXRlLnBvc2l0aW9uLnggPSAtc2VhdFRleHR1cmUud2lkdGggLyAyO1xuXHRzZWF0U3ByaXRlLnBvc2l0aW9uLnkgPSAtc2VhdFRleHR1cmUuaGVpZ2h0IC8gMjtcblxuXHR0aGlzLmFkZENoaWxkKHNlYXRTcHJpdGUpO1xuXG5cdHZhciBwb3MgPSB0aGlzLnJlc291cmNlcy5nZXRQb2ludChcInNlYXRQb3NpdGlvblwiICsgdGhpcy5zZWF0SW5kZXgpO1xuXG5cdHRoaXMucG9zaXRpb24ueCA9IHBvcy54O1xuXHR0aGlzLnBvc2l0aW9uLnkgPSBwb3MueTtcblxuXHR2YXIgc3R5bGU7XG5cblx0c3R5bGUgPSB7XG5cdFx0Zm9udDogXCJib2xkIDIwcHggQXJpYWxcIlxuXHR9O1xuXG5cdHRoaXMubmFtZUZpZWxkID0gbmV3IFBJWEkuVGV4dChcIltuYW1lXVwiLCBzdHlsZSk7XG5cdHRoaXMubmFtZUZpZWxkLnBvc2l0aW9uLnkgPSAtMjA7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5uYW1lRmllbGQpO1xuXG5cdHN0eWxlID0ge1xuXHRcdGZvbnQ6IFwibm9ybWFsIDEycHggQXJpYWxcIlxuXHR9O1xuXG5cdHRoaXMuY2hpcHNGaWVsZCA9IG5ldyBQSVhJLlRleHQoXCJbbmFtZV1cIiwgc3R5bGUpO1xuXHR0aGlzLmNoaXBzRmllbGQucG9zaXRpb24ueSA9IDU7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5jaGlwc0ZpZWxkKTtcblxuXHRzdHlsZSA9IHtcblx0XHRmb250OiBcImJvbGQgMjBweCBBcmlhbFwiXG5cdH07XG5cblx0dGhpcy5hY3Rpb25GaWVsZCA9IG5ldyBQSVhJLlRleHQoXCJhY3Rpb25cIiwgc3R5bGUpO1xuXHR0aGlzLmFjdGlvbkZpZWxkLnBvc2l0aW9uLnkgPSAtMTM7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5hY3Rpb25GaWVsZCk7XG5cdHRoaXMuYWN0aW9uRmllbGQuYWxwaGEgPSAwO1xuXG5cdHRoaXMuc2V0TmFtZShcIlwiKTtcblx0dGhpcy5zZXRDaGlwcyhcIlwiKTtcblxuXHR0aGlzLmJldENoaXBzID0gbnVsbDtcbn1cblxuaW5oZXJpdHMoU2VhdFZpZXcsIEJ1dHRvbik7XG5cbi8qKlxuICogU2V0IHJlZmVyZW5jZSB0byBiZXQgY2hpcHMuXG4gKiBAbWV0aG9kIHNldEJldENoaXBzVmlld1xuICovXG5TZWF0Vmlldy5wcm90b3R5cGUuc2V0QmV0Q2hpcHNWaWV3ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0dGhpcy5iZXRDaGlwcyA9IHZhbHVlO1xufVxuXG4vKipcbiAqIFNldCBuYW1lLlxuICogQG1ldGhvZCBzZXROYW1lXG4gKi9cblNlYXRWaWV3LnByb3RvdHlwZS5zZXROYW1lID0gZnVuY3Rpb24obmFtZSkge1xuXHR0aGlzLm5hbWVGaWVsZC5zZXRUZXh0KG5hbWUpO1xuXHR0aGlzLm5hbWVGaWVsZC51cGRhdGVUcmFuc2Zvcm0oKTtcblxuXHR0aGlzLm5hbWVGaWVsZC5wb3NpdGlvbi54ID0gLXRoaXMubmFtZUZpZWxkLmNhbnZhcy53aWR0aCAvIDI7XG59XG5cbi8qKlxuICogU2V0IG5hbWUuXG4gKiBAbWV0aG9kIHNldENoaXBzXG4gKi9cblNlYXRWaWV3LnByb3RvdHlwZS5zZXRDaGlwcyA9IGZ1bmN0aW9uKGNoaXBzKSB7XG5cdHRoaXMuY2hpcHNGaWVsZC5zZXRUZXh0KGNoaXBzKTtcblx0dGhpcy5jaGlwc0ZpZWxkLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXG5cdHRoaXMuY2hpcHNGaWVsZC5wb3NpdGlvbi54ID0gLXRoaXMuY2hpcHNGaWVsZC5jYW52YXMud2lkdGggLyAyO1xufVxuXG4vKipcbiAqIFNldCBzaXRvdXQuXG4gKiBAbWV0aG9kIHNldFNpdG91dFxuICovXG5TZWF0Vmlldy5wcm90b3R5cGUuc2V0U2l0b3V0ID0gZnVuY3Rpb24oc2l0b3V0KSB7XG5cdGlmIChzaXRvdXQpXG5cdFx0dGhpcy5hbHBoYSA9IC41O1xuXG5cdGVsc2Vcblx0XHR0aGlzLmFscGhhID0gMTtcbn1cblxuLyoqXG4gKiBTZXQgc2l0b3V0LlxuICogQG1ldGhvZCBzZXRBY3RpdmVcbiAqL1xuU2VhdFZpZXcucHJvdG90eXBlLnNldEFjdGl2ZSA9IGZ1bmN0aW9uKGFjdGl2ZSkge1xuXHR0aGlzLnZpc2libGUgPSBhY3RpdmU7XG59XG5cbi8qKlxuICogQWRkIHBvY2tldCBjYXJkLlxuICogQG1ldGhvZCBhZGRQb2NrZXRDYXJkXG4gKi9cblNlYXRWaWV3LnByb3RvdHlwZS5hZGRQb2NrZXRDYXJkID0gZnVuY3Rpb24oY2FyZFZpZXcpIHtcblx0dGhpcy5wb2NrZXRDYXJkcy5wdXNoKGNhcmRWaWV3KTtcbn1cblxuLyoqXG4gKiBHZXQgcG9ja2V0IGNhcmRzLlxuICogQG1ldGhvZCBnZXRQb2NrZXRDYXJkc1xuICovXG5TZWF0Vmlldy5wcm90b3R5cGUuZ2V0UG9ja2V0Q2FyZHMgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMucG9ja2V0Q2FyZHM7XG59XG5cbi8qKlxuICogRm9sZCBjYXJkcy5cbiAqIEBtZXRob2QgZm9sZENhcmRzXG4gKi9cblNlYXRWaWV3LnByb3RvdHlwZS5mb2xkQ2FyZHMgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5wb2NrZXRDYXJkc1swXS5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uRG9uZVwiLCB0aGlzLm9uRm9sZENvbXBsZXRlLCB0aGlzKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvY2tldENhcmRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dGhpcy5wb2NrZXRDYXJkc1tpXS5mb2xkKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBGb2xkIGNvbXBsZXRlLlxuICogQG1ldGhvZCBvbkZvbGRDb21wbGV0ZVxuICovXG5TZWF0Vmlldy5wcm90b3R5cGUub25Gb2xkQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5wb2NrZXRDYXJkc1swXS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uRG9uZVwiLCB0aGlzLm9uRm9sZENvbXBsZXRlLCB0aGlzKTtcblx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiYW5pbWF0aW9uRG9uZVwiKTtcbn1cblxuLyoqXG4gKiBTaG93IHVzZXIgYWN0aW9uLlxuICogQG1ldGhvZCBhY3Rpb25cbiAqL1xuU2VhdFZpZXcucHJvdG90eXBlLmFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbikge1xuXHR0aGlzLmFjdGlvbkZpZWxkLnNldFRleHQoYWN0aW9uKTtcblx0dGhpcy5hY3Rpb25GaWVsZC5wb3NpdGlvbi54ID0gLXRoaXMuYWN0aW9uRmllbGQuY2FudmFzLndpZHRoIC8gMjtcblxuXHR0aGlzLmFjdGlvbkZpZWxkLmFscGhhID0gMTtcblx0dGhpcy5uYW1lRmllbGQuYWxwaGEgPSAwO1xuXHR0aGlzLmNoaXBzRmllbGQuYWxwaGEgPSAwO1xuXG5cdHNldFRpbWVvdXQodGhpcy5vblRpbWVyLmJpbmQodGhpcyksIDEwMDApO1xufVxuXG4vKipcbiAqIFNob3cgdXNlciBhY3Rpb24uXG4gKiBAbWV0aG9kIGFjdGlvblxuICovXG5TZWF0Vmlldy5wcm90b3R5cGUub25UaW1lciA9IGZ1bmN0aW9uKGFjdGlvbikge1xuXG5cdHZhciB0MSA9IG5ldyBUV0VFTi5Ud2Vlbih0aGlzLmFjdGlvbkZpZWxkKVxuXHRcdC50byh7XG5cdFx0XHRhbHBoYTogMFxuXHRcdH0sIDEwMDApXG5cdFx0LnN0YXJ0KCk7XG5cdHZhciB0MiA9IG5ldyBUV0VFTi5Ud2Vlbih0aGlzLm5hbWVGaWVsZClcblx0XHQudG8oe1xuXHRcdFx0YWxwaGE6IDFcblx0XHR9LCAxMDAwKVxuXHRcdC5zdGFydCgpO1xuXHR2YXIgdDMgPSBuZXcgVFdFRU4uVHdlZW4odGhpcy5jaGlwc0ZpZWxkKVxuXHRcdC50byh7XG5cdFx0XHRhbHBoYTogMVxuXHRcdH0sIDEwMDApXG5cdFx0LnN0YXJ0KCk7XG5cbn1cblxuLyoqXG4gKiBDbGVhci5cbiAqIEBtZXRob2QgY2xlYXJcbiAqL1xuU2VhdFZpZXcucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdHZhciBpO1xuXG5cdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cdHRoaXMuc2l0b3V0ID0gZmFsc2U7XG5cdHRoaXMuYmV0Q2hpcHMuc2V0VmFsdWUoMCk7XG5cdHRoaXMuc2V0TmFtZShcIlwiKTtcblx0dGhpcy5zZXRDaGlwcyhcIlwiKTtcblxuXHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5wb2NrZXRDYXJkcy5sZW5ndGg7IGkrKylcblx0XHR0aGlzLnBvY2tldENhcmRzW2ldLmhpZGUoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZWF0VmlldzsiLCIvKipcbiAqIENsaWVudC5cbiAqIEBtb2R1bGUgY2xpZW50XG4gKi9cblxudmFyIFBJWEkgPSByZXF1aXJlKFwicGl4aS5qc1wiKTtcbnZhciBUV0VFTiA9IHJlcXVpcmUoXCJ0d2Vlbi5qc1wiKTtcbnZhciBCdXR0b24gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvQnV0dG9uXCIpO1xudmFyIE5pbmVTbGljZSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9OaW5lU2xpY2VcIik7XG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZShcInlhZWRcIik7XG52YXIgQ2hlY2tib3ggPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvQ2hlY2tib3hcIik7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiaW5oZXJpdHNcIik7XG5cbi8qKlxuICogQ2hlY2tib3hlcyB2aWV3XG4gKiBAY2xhc3MgU2V0dGluZ3NDaGVja2JveFxuICovXG5mdW5jdGlvbiBTZXR0aW5nc0NoZWNrYm94KHJlc291cmNlcywgaWQsIHN0cmluZykge1xuIFx0UElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLmNhbGwodGhpcyk7XG5cbiBcdHRoaXMucmVzb3VyY2VzID0gcmVzb3VyY2VzO1xuIFx0dGhpcy5pZCA9IGlkO1xuXG4gXHR2YXIgeSA9IDA7XG5cbiBcdHZhciBzdHlsZU9iamVjdCA9IHtcbiBcdFx0d2lkdGg6IDIwMCxcbiBcdFx0aGVpZ2h0OiAyNSxcbiBcdFx0Zm9udDogXCJib2xkIDEzcHggQXJpYWxcIixcbiBcdFx0Y29sb3I6IFwid2hpdGVcIlxuIFx0fTtcbiBcdHRoaXMubGFiZWwgPSBuZXcgUElYSS5UZXh0KHN0cmluZywgc3R5bGVPYmplY3QpO1xuIFx0dGhpcy5sYWJlbC5wb3NpdGlvbi54ID0gMjU7XG4gXHR0aGlzLmxhYmVsLnBvc2l0aW9uLnkgPSB5ICsgMTtcbiBcdHRoaXMuYWRkQ2hpbGQodGhpcy5sYWJlbCk7XG5cbiBcdHZhciBiYWNrZ3JvdW5kID0gbmV3IFBJWEkuU3ByaXRlKHRoaXMucmVzb3VyY2VzLmdldFRleHR1cmUoXCJjaGVja2JveEJhY2tncm91bmRcIikpO1xuIFx0dmFyIHRpY2sgPSBuZXcgUElYSS5TcHJpdGUodGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcImNoZWNrYm94VGlja1wiKSk7XG4gXHR0aWNrLnggPSAxO1xuXG4gXHR0aGlzLmNoZWNrYm94ID0gbmV3IENoZWNrYm94KGJhY2tncm91bmQsIHRpY2spO1xuIFx0dGhpcy5jaGVja2JveC5wb3NpdGlvbi55ID0geTtcbiBcdHRoaXMuYWRkQ2hpbGQodGhpcy5jaGVja2JveCk7XG5cbiBcdHRoaXMuY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCB0aGlzLm9uQ2hlY2tib3hDaGFuZ2UsIHRoaXMpO1xufVxuXG5pbmhlcml0cyhTZXR0aW5nc0NoZWNrYm94LCBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIpO1xuRXZlbnREaXNwYXRjaGVyLmluaXQoU2V0dGluZ3NDaGVja2JveCk7XG5cbi8qKlxuICogQ2hlY2tib3ggY2hhbmdlLlxuICogQG1ldGhvZCBvbkNoZWNrYm94Q2hhbmdlXG4gKi9cblNldHRpbmdzQ2hlY2tib3gucHJvdG90eXBlLm9uQ2hlY2tib3hDaGFuZ2UgPSBmdW5jdGlvbihpbnRlcmFjdGlvbl9vYmplY3QpIHtcblx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiY2hhbmdlXCIsIHRoaXMpO1xufVxuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0Q2hlY2tlZFxuICovXG5TZXR0aW5nc0NoZWNrYm94LnByb3RvdHlwZS5nZXRDaGVja2VkID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmNoZWNrYm94LmdldENoZWNrZWQoKTtcbn1cblxuLyoqXG4gKiBTZXR0ZXIuXG4gKiBAbWV0aG9kIHNldENoZWNrZWRcbiAqL1xuU2V0dGluZ3NDaGVja2JveC5wcm90b3R5cGUuc2V0Q2hlY2tlZCA9IGZ1bmN0aW9uKGNoZWNrZWQpIHtcblx0dGhpcy5jaGVja2JveC5zZXRDaGVja2VkKGNoZWNrZWQpO1xuXHRyZXR1cm4gY2hlY2tlZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZXR0aW5nc0NoZWNrYm94OyIsIi8qKlxuICogQ2xpZW50LlxuICogQG1vZHVsZSBjbGllbnRcbiAqL1xuXG52YXIgUElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xudmFyIFRXRUVOID0gcmVxdWlyZShcInR3ZWVuLmpzXCIpO1xudmFyIEJ1dHRvbiA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9CdXR0b25cIik7XG52YXIgTmluZVNsaWNlID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL05pbmVTbGljZVwiKTtcbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKFwieWFlZFwiKTtcbnZhciBTZXR0aW5nc0NoZWNrYm94ID0gcmVxdWlyZShcIi4vU2V0dGluZ3NDaGVja2JveFwiKTtcbnZhciBSYWlzZVNob3J0Y3V0QnV0dG9uID0gcmVxdWlyZShcIi4vUmFpc2VTaG9ydGN1dEJ1dHRvblwiKTtcbnZhciBDaGVja2JveE1lc3NhZ2UgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vbWVzc2FnZXMvQ2hlY2tib3hNZXNzYWdlXCIpO1xudmFyIEJ1dHRvbkRhdGEgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vZGF0YS9CdXR0b25EYXRhXCIpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xuXG4vKipcbiAqIEEgc2V0dGluZ3Mgdmlld1xuICogQGNsYXNzIFNldHRpbmdzVmlld1xuICovXG5mdW5jdGlvbiBTZXR0aW5nc1ZpZXcodmlld0NvbmZpZywgcmVzb3VyY2VzKSB7XG5cdFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKHRoaXMpO1xuXG5cdHRoaXMudmlld0NvbmZpZyA9IHZpZXdDb25maWc7XG5cdHRoaXMucmVzb3VyY2VzID0gcmVzb3VyY2VzO1xuXG5cdHZhciBvYmplY3QgPSBuZXcgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyKCk7XG5cdHZhciBiZyA9IG5ldyBOaW5lU2xpY2UodGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcImNoYXRCYWNrZ3JvdW5kXCIpLCAxMCwgMTAsIDEwLCAxMCk7XG5cdGJnLnNldExvY2FsU2l6ZSgzMCwgMzApO1xuXHRvYmplY3QuYWRkQ2hpbGQoYmcpO1xuXG5cdHZhciBzcHJpdGUgPSBuZXcgUElYSS5TcHJpdGUodGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcIndyZW5jaEljb25cIikpO1xuXHRzcHJpdGUueCA9IDU7XG5cdHNwcml0ZS55ID0gNTtcblx0b2JqZWN0LmFkZENoaWxkKHNwcml0ZSk7XG5cblx0dGhpcy5zZXR0aW5nc0J1dHRvbiA9IG5ldyBCdXR0b24ob2JqZWN0KTtcblx0dGhpcy5zZXR0aW5nc0J1dHRvbi5wb3NpdGlvbi54ID0gOTYwIC0gMTAgLSB0aGlzLnNldHRpbmdzQnV0dG9uLndpZHRoO1xuXHR0aGlzLnNldHRpbmdzQnV0dG9uLnBvc2l0aW9uLnkgPSA1NDM7XG5cdHRoaXMuc2V0dGluZ3NCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihCdXR0b24uQ0xJQ0ssIHRoaXMub25TZXR0aW5nc0J1dHRvbkNsaWNrLCB0aGlzKTtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLnNldHRpbmdzQnV0dG9uKTtcblxuXHR0aGlzLnNldHRpbmdzTWVudSA9IG5ldyBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIoKTtcblxuXHR2YXIgbWJnID0gbmV3IE5pbmVTbGljZSh0aGlzLnJlc291cmNlcy5nZXRUZXh0dXJlKFwiY2hhdEJhY2tncm91bmRcIiksIDEwLCAxMCwgMTAsIDEwKTtcblx0bWJnLnNldExvY2FsU2l6ZSgyNTAsIDEwMCk7XG5cdHRoaXMuc2V0dGluZ3NNZW51LmFkZENoaWxkKG1iZyk7XG5cblx0dmFyIHN0eWxlT2JqZWN0ID0ge1xuXHRcdGZvbnQ6IFwiYm9sZCAxNHB4IEFyaWFsXCIsXG5cdFx0Y29sb3I6IFwiI0ZGRkZGRlwiLFxuXHRcdHdpZHRoOiAyMDAsXG5cdFx0aGVpZ2h0OiAyMFxuXHR9O1xuXHR2YXIgbGFiZWwgPSBuZXcgUElYSS5UZXh0KFwiU2V0dGluZ3NcIiwgc3R5bGVPYmplY3QpO1xuXHRsYWJlbC5wb3NpdGlvbi54ID0gMTY7XG5cdGxhYmVsLnBvc2l0aW9uLnkgPSAxMDtcblxuXHR0aGlzLnNldHRpbmdzTWVudS5hZGRDaGlsZChsYWJlbCk7XG5cdHRoaXMuc2V0dGluZ3NNZW51LnBvc2l0aW9uLnggPSA5NjAgLSAxMCAtIHRoaXMuc2V0dGluZ3NNZW51LndpZHRoO1xuXHR0aGlzLnNldHRpbmdzTWVudS5wb3NpdGlvbi55ID0gNTM4IC0gdGhpcy5zZXR0aW5nc01lbnUuaGVpZ2h0O1xuXHR0aGlzLmFkZENoaWxkKHRoaXMuc2V0dGluZ3NNZW51KTtcblxuXHR0aGlzLnNldHRpbmdzID0ge307XG5cblx0Ly9jb25zb2xlLmxvZyhcInNldHRpbmcgdXAgc2V0dGluZ3MsIHZpZXdjb25maWc9XCIgKyB0aGlzLnZpZXdDb25maWcpO1xuXG5cdHRoaXMuY3JlYXRlTWVudVNldHRpbmcoXCJwbGF5QW5pbWF0aW9uc1wiLCBcIlBsYXkgYW5pbWF0aW9uc1wiLCA0MCwgdGhpcy52aWV3Q29uZmlnLmdldFBsYXlBbmltYXRpb25zKCkpO1xuXHR0aGlzLmNyZWF0ZU1lbnVTZXR0aW5nKENoZWNrYm94TWVzc2FnZS5BVVRPX01VQ0tfTE9TSU5HLCBcIk11Y2sgbG9zaW5nIGhhbmRzXCIsIDY1KTtcblxuXHR0aGlzLmNyZWF0ZVNldHRpbmcoQ2hlY2tib3hNZXNzYWdlLkFVVE9fUE9TVF9CTElORFMsIFwiUG9zdCBibGluZHNcIiwgMCk7XG5cdHRoaXMuY3JlYXRlU2V0dGluZyhDaGVja2JveE1lc3NhZ2UuU0lUT1VUX05FWFQsIFwiU2l0IG91dFwiLCAyNSk7XG5cblx0dGhpcy5zZXR0aW5nc01lbnUudmlzaWJsZSA9IGZhbHNlO1xuXG5cdHRoaXMuYnV5Q2hpcHNCdXR0b24gPSBuZXcgUmFpc2VTaG9ydGN1dEJ1dHRvbih0aGlzLnJlc291cmNlcyk7XG5cdHRoaXMuYnV5Q2hpcHNCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMub25CdXlDaGlwc0NsaWNrLCB0aGlzKTtcblx0dGhpcy5idXlDaGlwc0J1dHRvbi54ID0gNzAwO1xuXHR0aGlzLmJ1eUNoaXBzQnV0dG9uLnkgPSA2MzU7XG5cdHRoaXMuYnV5Q2hpcHNCdXR0b24uc2V0VGV4dChcIkJ1eSBjaGlwc1wiKTtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLmJ1eUNoaXBzQnV0dG9uKTtcblxuXHR0aGlzLmJ1eUNoaXBzQnV0dG9uLnZpc2libGUgPSBmYWxzZTtcblxuXHQvLyBQcmV2ZW50IG1vdXNlIG92ZXIgZnJvbSBmYWxsaW5nIHRocm91Z2gsIGRvZXNuJ3Qgd29yay5cblx0Lyp0aGlzLnNldHRpbmdzTWVudS5pbnRlcmFjdGl2ZSA9IHRydWU7XG5cdHRoaXMuc2V0dGluZ3NNZW51LmJ1dHRvbk1vZGUgPSB0cnVlO1xuXHR0aGlzLnNldHRpbmdzTWVudS5tb3VzZW92ZXIgPSBmdW5jdGlvbigpIHsgY29uc29sZS5sb2coXCJ0ZXN0XCIpOyB9O1xuXHR0aGlzLnNldHRpbmdzTWVudS5tb3VzZW91dCA9IGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZyhcInRlc3RcIik7IH07XG5cdHRoaXMuc2V0dGluZ3NNZW51Lm1vdXNlZG93biA9IGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZyhcInRlc3RcIik7IH07XG5cdHRoaXMuc2V0dGluZ3NNZW51Lm1vdXNldXAgPSBmdW5jdGlvbigpIHsgY29uc29sZS5sb2coXCJ0ZXN0XCIpOyB9O1xuXHR0aGlzLnNldHRpbmdzTWVudS5jbGljayA9IGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZyhcInRlc3RcIik7IH07Ki9cbn1cblxuaW5oZXJpdHMoU2V0dGluZ3NWaWV3LCBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIpO1xuRXZlbnREaXNwYXRjaGVyLmluaXQoU2V0dGluZ3NWaWV3KTtcblxuU2V0dGluZ3NWaWV3LkJVWV9DSElQU19DTElDSyA9IFwiYnV5Q2hpcHNDbGlja1wiO1xuU2V0dGluZ3NWaWV3LkNIRUNLQk9YX0NIQU5HRSA9IFwiY2hlY2tib3hDaGFuZ2VcIjtcblxuLyoqXG4gKiBPbiBidXkgY2hpcHMgYnV0dG9uIGNsaWNrZWQuXG4gKiBAbWV0aG9kIG9uQnV5Q2hpcHNDbGlja1xuICovXG5TZXR0aW5nc1ZpZXcucHJvdG90eXBlLm9uQnV5Q2hpcHNDbGljayA9IGZ1bmN0aW9uKGludGVyYWN0aW9uX29iamVjdCkge1xuXHRjb25zb2xlLmxvZyhcImJ1eSBjaGlwcyBjbGlja1wiKTtcblx0dGhpcy5kaXNwYXRjaEV2ZW50KFNldHRpbmdzVmlldy5CVVlfQ0hJUFNfQ0xJQ0spO1xufVxuXG4vKipcbiAqIENyZWF0ZSBjaGVja2JveC5cbiAqIEBtZXRob2QgY3JlYXRlTWVudVNldHRpbmdcbiAqL1xuU2V0dGluZ3NWaWV3LnByb3RvdHlwZS5jcmVhdGVNZW51U2V0dGluZyA9IGZ1bmN0aW9uKGlkLCBzdHJpbmcsIHksIGRlZikge1xuXHR2YXIgc2V0dGluZyA9IG5ldyBTZXR0aW5nc0NoZWNrYm94KHRoaXMucmVzb3VyY2VzLCBpZCwgc3RyaW5nKTtcblxuXHRzZXR0aW5nLnkgPSB5O1xuXHRzZXR0aW5nLnggPSAxNjtcblx0dGhpcy5zZXR0aW5nc01lbnUuYWRkQ2hpbGQoc2V0dGluZyk7XG5cblx0c2V0dGluZy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMub25DaGVja2JveENoYW5nZSwgdGhpcylcblxuXHR0aGlzLnNldHRpbmdzW2lkXSA9IHNldHRpbmc7XG5cdHNldHRpbmcuc2V0Q2hlY2tlZChkZWYpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBzZXR0aW5nLlxuICogQG1ldGhvZCBjcmVhdGVTZXR0aW5nXG4gKi9cblNldHRpbmdzVmlldy5wcm90b3R5cGUuY3JlYXRlU2V0dGluZyA9IGZ1bmN0aW9uKGlkLCBzdHJpbmcsIHkpIHtcblx0dmFyIHNldHRpbmcgPSBuZXcgU2V0dGluZ3NDaGVja2JveCh0aGlzLnJlc291cmNlcywgaWQsIHN0cmluZyk7XG5cblx0c2V0dGluZy55ID0gNTQ1ICsgeTtcblx0c2V0dGluZy54ID0gNzAwO1xuXHR0aGlzLmFkZENoaWxkKHNldHRpbmcpO1xuXG5cdHNldHRpbmcuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCB0aGlzLm9uQ2hlY2tib3hDaGFuZ2UsIHRoaXMpXG5cblx0dGhpcy5zZXR0aW5nc1tpZF0gPSBzZXR0aW5nO1xufVxuXG4vKipcbiAqIENoZWNrYm94IGNoYW5nZS5cbiAqIEBtZXRob2Qgb25DaGVja2JveENoYW5nZVxuICovXG5TZXR0aW5nc1ZpZXcucHJvdG90eXBlLm9uQ2hlY2tib3hDaGFuZ2UgPSBmdW5jdGlvbihjaGVja2JveCkge1xuXHRpZiAoY2hlY2tib3guaWQgPT0gXCJwbGF5QW5pbWF0aW9uc1wiKSB7XG5cdFx0dGhpcy52aWV3Q29uZmlnLnNldFBsYXlBbmltYXRpb25zKGNoZWNrYm94LmdldENoZWNrZWQoKSk7XG5cdFx0Y29uc29sZS5sb2coXCJhbmltcyBjaGFuZ2VkLi5cIik7XG5cdH1cblxuXHR0aGlzLmRpc3BhdGNoRXZlbnQoU2V0dGluZ3NWaWV3LkNIRUNLQk9YX0NIQU5HRSwge1xuXHRcdGNoZWNrYm94SWQ6IGNoZWNrYm94LmlkLFxuXHRcdGNoZWNrZWQ6IGNoZWNrYm94LmdldENoZWNrZWQoKVxuXHR9KTtcbn1cblxuLyoqXG4gKiBTZXR0aW5ncyBidXR0b24gY2xpY2suXG4gKiBAbWV0aG9kIG9uU2V0dGluZ3NCdXR0b25DbGlja1xuICovXG5TZXR0aW5nc1ZpZXcucHJvdG90eXBlLm9uU2V0dGluZ3NCdXR0b25DbGljayA9IGZ1bmN0aW9uKGludGVyYWN0aW9uX29iamVjdCkge1xuXHRjb25zb2xlLmxvZyhcIlNldHRpbmdzVmlldy5wcm90b3R5cGUub25TZXR0aW5nc0J1dHRvbkNsaWNrXCIpO1xuXHR0aGlzLnNldHRpbmdzTWVudS52aXNpYmxlID0gIXRoaXMuc2V0dGluZ3NNZW51LnZpc2libGU7XG5cblx0aWYgKHRoaXMuc2V0dGluZ3NNZW51LnZpc2libGUpIHtcblx0XHR0aGlzLnN0YWdlLm1vdXNlZG93biA9IHRoaXMuc3RhZ2UudG91Y2hzdGFydCA9IHRoaXMub25TdGFnZU1vdXNlRG93bi5iaW5kKHRoaXMpO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuc3RhZ2UubW91c2Vkb3duID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIFN0YWdlIG1vdXNlIGRvd24uXG4gKiBAbWV0aG9kIG9uU3RhZ2VNb3VzZURvd25cbiAqL1xuU2V0dGluZ3NWaWV3LnByb3RvdHlwZS5vblN0YWdlTW91c2VEb3duID0gZnVuY3Rpb24oaW50ZXJhY3Rpb25fb2JqZWN0KSB7XG5cdGNvbnNvbGUubG9nKFwiU2V0dGluZ3NWaWV3LnByb3RvdHlwZS5vblN0YWdlTW91c2VEb3duXCIpO1xuXHRpZiAoKHRoaXMuaGl0VGVzdCh0aGlzLnNldHRpbmdzTWVudSwgaW50ZXJhY3Rpb25fb2JqZWN0KSkgfHwgKHRoaXMuaGl0VGVzdCh0aGlzLnNldHRpbmdzQnV0dG9uLCBpbnRlcmFjdGlvbl9vYmplY3QpKSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHRoaXMuc3RhZ2UubW91c2Vkb3duID0gbnVsbDtcblx0dGhpcy5zZXR0aW5nc01lbnUudmlzaWJsZSA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEhpdCB0ZXN0LlxuICogQG1ldGhvZCBoaXRUZXN0XG4gKi9cblNldHRpbmdzVmlldy5wcm90b3R5cGUuaGl0VGVzdCA9IGZ1bmN0aW9uKG9iamVjdCwgaW50ZXJhY3Rpb25fb2JqZWN0KSB7XG5cdGlmICgoaW50ZXJhY3Rpb25fb2JqZWN0Lmdsb2JhbC54ID4gb2JqZWN0LmdldEJvdW5kcygpLngpICYmIChpbnRlcmFjdGlvbl9vYmplY3QuZ2xvYmFsLnggPCAob2JqZWN0LmdldEJvdW5kcygpLnggKyBvYmplY3QuZ2V0Qm91bmRzKCkud2lkdGgpKSAmJlxuXHRcdChpbnRlcmFjdGlvbl9vYmplY3QuZ2xvYmFsLnkgPiBvYmplY3QuZ2V0Qm91bmRzKCkueSkgJiYgKGludGVyYWN0aW9uX29iamVjdC5nbG9iYWwueSA8IChvYmplY3QuZ2V0Qm91bmRzKCkueSArIG9iamVjdC5nZXRCb3VuZHMoKS5oZWlnaHQpKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXNldC5cbiAqIEBtZXRob2QgY2xlYXJcbiAqL1xuU2V0dGluZ3NWaWV3LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLmJ1eUNoaXBzQnV0dG9uLmVuYWJsZWQgPSB0cnVlO1xuXHR0aGlzLnNldFZpc2libGVCdXR0b25zKFtdKTtcblxuXHR0aGlzLnNldENoZWNrYm94Q2hlY2tlZChDaGVja2JveE1lc3NhZ2UuQVVUT19QT1NUX0JMSU5EUywgZmFsc2UpO1xuXHR0aGlzLnNldENoZWNrYm94Q2hlY2tlZChDaGVja2JveE1lc3NhZ2UuQVVUT19NVUNLX0xPU0lORywgZmFsc2UpO1xuXHR0aGlzLnNldENoZWNrYm94Q2hlY2tlZChDaGVja2JveE1lc3NhZ2UuU0lUT1VUX05FWFQsIGZhbHNlKTtcblxuXHR0aGlzLnNldHRpbmdzTWVudS52aXNpYmxlID0gZmFsc2U7XG5cdGlmICh0aGlzLnNldHRpbmdzTWVudS52aXNpYmxlKVxuXHRcdHRoaXMuc3RhZ2UubW91c2Vkb3duID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTZXQgdmlzaWJsZSBidXR0b25zLlxuICogQG1ldGhvZCBzZXRWaXNpYmxlQnV0dG9uc1xuICovXG5TZXR0aW5nc1ZpZXcucHJvdG90eXBlLnNldFZpc2libGVCdXR0b25zID0gZnVuY3Rpb24oYnV0dG9ucykge1xuXHR0aGlzLmJ1eUNoaXBzQnV0dG9uLnZpc2libGUgPSBidXR0b25zLmluZGV4T2YoQnV0dG9uRGF0YS5CVVlfQ0hJUFMpICE9IC0xO1xuXHR0aGlzLnNldHRpbmdzW0NoZWNrYm94TWVzc2FnZS5BVVRPX1BPU1RfQkxJTkRTXS52aXNpYmxlID0gYnV0dG9ucy5pbmRleE9mKENoZWNrYm94TWVzc2FnZS5BVVRPX1BPU1RfQkxJTkRTKSA+PSAwO1xuXHR0aGlzLnNldHRpbmdzW0NoZWNrYm94TWVzc2FnZS5TSVRPVVRfTkVYVF0udmlzaWJsZSA9IGJ1dHRvbnMuaW5kZXhPZihDaGVja2JveE1lc3NhZ2UuU0lUT1VUX05FWFQpID49IDA7XG5cblx0dmFyIHlwID0gNTQzO1xuXG5cdGlmICh0aGlzLmJ1eUNoaXBzQnV0dG9uLnZpc2libGUpIHtcblx0XHR0aGlzLmJ1eUNoaXBzQnV0dG9uLnkgPSB5cDtcblx0XHR5cCArPSAzNTtcblx0fSBlbHNlIHtcblx0XHR5cCArPSAyO1xuXHR9XG5cblx0aWYgKHRoaXMuc2V0dGluZ3NbQ2hlY2tib3hNZXNzYWdlLkFVVE9fUE9TVF9CTElORFNdLnZpc2libGUpIHtcblx0XHR0aGlzLnNldHRpbmdzW0NoZWNrYm94TWVzc2FnZS5BVVRPX1BPU1RfQkxJTkRTXS55ID0geXA7XG5cdFx0eXAgKz0gMjU7XG5cdH1cblxuXHRpZiAodGhpcy5zZXR0aW5nc1tDaGVja2JveE1lc3NhZ2UuU0lUT1VUX05FWFRdLnZpc2libGUpIHtcblx0XHR0aGlzLnNldHRpbmdzW0NoZWNrYm94TWVzc2FnZS5TSVRPVVRfTkVYVF0ueSA9IHlwO1xuXHRcdHlwICs9IDI1O1xuXHR9XG59XG5cbi8qKlxuICogU2V0IGNoZWNrYm94IHN0YXRlLlxuICogQG1ldGhvZCBzZXRDaGVja2JveENoZWNrZWRcbiAqL1xuU2V0dGluZ3NWaWV3LnByb3RvdHlwZS5zZXRDaGVja2JveENoZWNrZWQgPSBmdW5jdGlvbihpZCwgY2hlY2tlZCkge1xuXHQvL2NvbnNvbGUubG9nKFwic2V0dGluZyBjaGVja2JveCBzdGF0ZSBmb3I6IFwiICsgaWQpO1xuXG5cdHRoaXMuc2V0dGluZ3NbaWRdLnNldENoZWNrZWQoY2hlY2tlZCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0dGluZ3NWaWV3OyIsIi8qKlxuICogQ2xpZW50LlxuICogQG1vZHVsZSBjbGllbnRcbiAqL1xuXG52YXIgUElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoXCJ5YWVkXCIpO1xudmFyIERpYWxvZ0J1dHRvbiA9IHJlcXVpcmUoXCIuL0RpYWxvZ0J1dHRvblwiKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCJpbmhlcml0c1wiKTtcbnZhciBCdXR0b25EYXRhID0gcmVxdWlyZShcIi4uLy4uL3Byb3RvL2RhdGEvQnV0dG9uRGF0YVwiKTtcblxuLyoqXG4gKiBTaG93IHRhYmxlIGluZm8uXG4gKiBAY2xhc3MgVGFibGVJbmZvVmlld1xuICovXG5mdW5jdGlvbiBUYWJsZUluZm9WaWV3KHZpZXdDb25maWcsIHJlc291cmNlcykge1xuXHRQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIuY2FsbCh0aGlzKTtcblxuXHR0aGlzLnZpZXdDb25maWcgPSB2aWV3Q29uZmlnO1xuXHR0aGlzLnJlc291cmNlcyA9IHJlc291cmNlcztcblxuXHR2YXIgc3R5bGUgPSB7XG5cdFx0Zm9udDogXCJib2xkIDI0cHggVGltZXMgTmV3IFJvbWFuXCIsXG5cdFx0ZmlsbDogXCIjZmZmZmZmXCIsXG5cdFx0ZHJvcFNoYWRvdzogdHJ1ZSxcblx0XHRkcm9wU2hhZG93Q29sb3I6IFwiIzAwMDAwMFwiLFxuXHRcdGRyb3BTaGFkb3dEaXN0YW5jZTogMixcblx0XHRzdHJva2U6IFwiIzAwMDAwMFwiLFxuXHRcdHN0cm9rZVRoaWNrbmVzczogMixcblx0XHR3b3JkV3JhcDogdHJ1ZSxcblx0XHR3b3JkV3JhcFdpZHRoOiAzMDBcblx0fTtcblxuXHR0aGlzLnRhYmxlSW5mb1RleHQgPSBuZXcgUElYSS5UZXh0KFwiPFRhYmxlSW5mb1RleHQ+XCIsIHN0eWxlKTtcblx0dGhpcy50YWJsZUluZm9UZXh0LnBvc2l0aW9uLnggPSAzNTU7XG5cdHRoaXMudGFibGVJbmZvVGV4dC5wb3NpdGlvbi55ID0gNTQwO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMudGFibGVJbmZvVGV4dCk7XG5cblx0dmFyIHN0eWxlID0ge1xuXHRcdGZvbnQ6IFwiYm9sZCAyNHB4IFRpbWVzIE5ldyBSb21hblwiLFxuXHRcdGZpbGw6IFwiI2ZmZmZmZlwiLFxuXHRcdGFsaWduOiBcImNlbnRlclwiXG5cdH07XG5cblx0dGhpcy5wcmVUb3VybmFtZW50SW5mb1RleHQgPSBuZXcgUElYSS5UZXh0KFwiPFByZVRvdXJuYW1lbnRJbmZvVGV4dD5cIiwgc3R5bGUpO1xuXHR0aGlzLnByZVRvdXJuYW1lbnRJbmZvVGV4dC5wb3NpdGlvbi55ID0gMzYwO1xuXHQvL3RoaXMucHJlVG91cm5hbWVudEluZm9UZXh0LnBvc2l0aW9uLnkgPSAyODA7XG5cdHRoaXMucHJlVG91cm5hbWVudEluZm9UZXh0LnBvc2l0aW9uLnggPSBNYXRoLnJvdW5kKDk2MCAtIDMwMCkgLyAyO1xuXHR0aGlzLnByZVRvdXJuYW1lbnRJbmZvVGV4dC5hbHBoYSA9IC4yNTtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLnByZVRvdXJuYW1lbnRJbmZvVGV4dCk7XG5cblx0dmFyIHN0eWxlID0ge1xuXHRcdGZvbnQ6IFwiYm9sZCAxMnB4IEFyaWFsXCIsXG5cdFx0ZmlsbDogXCIjZmZmZmZmXCIsXG5cdFx0ZHJvcFNoYWRvdzogdHJ1ZSxcblx0XHRkcm9wU2hhZG93Q29sb3I6IFwiIzAwMDAwMFwiLFxuXHRcdGRyb3BTaGFkb3dEaXN0YW5jZTogMSxcblx0XHRzdHJva2U6IFwiIzAwMDAwMFwiLFxuXHRcdHN0cm9rZVRoaWNrbmVzczogMSxcblx0fTtcblxuXHR0aGlzLmhhbmRJbmZvVGV4dCA9IG5ldyBQSVhJLlRleHQoXCI8SGFuZEluZm9UZXh0PlwiLCBzdHlsZSk7XG5cdHRoaXMuaGFuZEluZm9UZXh0LnBvc2l0aW9uLnkgPSAxMDtcblx0dGhpcy5oYW5kSW5mb1RleHQucG9zaXRpb24ueCA9IDk2MCAtIHRoaXMuaGFuZEluZm9UZXh0LndpZHRoO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMuaGFuZEluZm9UZXh0KTtcblxuXHR0aGlzLmpvaW5CdXR0b24gPSBuZXcgRGlhbG9nQnV0dG9uKHRoaXMucmVzb3VyY2VzKTtcblx0dGhpcy5qb2luQnV0dG9uLnBvc2l0aW9uLnggPSAzNTU7XG5cdHRoaXMuam9pbkJ1dHRvbi5zZXRUZXh0KFwiSk9JTlwiKTtcblx0dGhpcy5qb2luQnV0dG9uLnZpc2libGUgPSBmYWxzZTtcblx0dGhpcy5qb2luQnV0dG9uLm9uKFwiY2xpY2tcIiwgdGhpcy5vbkJ1dHRvbkNsaWNrLCB0aGlzKTtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLmpvaW5CdXR0b24pO1xuXG5cdHRoaXMubGVhdmVCdXR0b24gPSBuZXcgRGlhbG9nQnV0dG9uKHRoaXMucmVzb3VyY2VzKTtcblx0dGhpcy5sZWF2ZUJ1dHRvbi5wb3NpdGlvbi54ID0gMzU1O1xuXHR0aGlzLmxlYXZlQnV0dG9uLnNldFRleHQoXCJMRUFWRVwiKTtcblx0dGhpcy5sZWF2ZUJ1dHRvbi52aXNpYmxlID0gZmFsc2U7XG5cdHRoaXMubGVhdmVCdXR0b24ub24oXCJjbGlja1wiLCB0aGlzLm9uQnV0dG9uQ2xpY2ssIHRoaXMpO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMubGVhdmVCdXR0b24pO1xufVxuXG5pbmhlcml0cyhUYWJsZUluZm9WaWV3LCBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIpO1xuRXZlbnREaXNwYXRjaGVyLmluaXQoVGFibGVJbmZvVmlldyk7XG5cblRhYmxlSW5mb1ZpZXcuQlVUVE9OX0NMSUNLID0gXCJidXR0b25DbGlja1wiO1xuXG4vKipcbiAqIFNldCB0YWJsZSBpbmZvIHRleHQuXG4gKiBAbWV0aG9kIHNldFRhYmxlSW5mb1RleHRcbiAqL1xuVGFibGVJbmZvVmlldy5wcm90b3R5cGUuc2V0VGFibGVJbmZvVGV4dCA9IGZ1bmN0aW9uKHMpIHtcblx0aWYgKCFzKVxuXHRcdHMgPSBcIlwiO1xuXG5cdHRoaXMudGFibGVJbmZvVGV4dC5zZXRUZXh0KHMpO1xuXHR0aGlzLmpvaW5CdXR0b24ucG9zaXRpb24ueSA9IHRoaXMudGFibGVJbmZvVGV4dC5wb3NpdGlvbi55ICsgdGhpcy50YWJsZUluZm9UZXh0LmhlaWdodCArIDU7XG5cdHRoaXMubGVhdmVCdXR0b24ucG9zaXRpb24ueSA9IHRoaXMudGFibGVJbmZvVGV4dC5wb3NpdGlvbi55ICsgdGhpcy50YWJsZUluZm9UZXh0LmhlaWdodCArIDU7XG59XG5cbi8qKlxuICogU2V0IHByZSB0b3VybmFtZW50IGluZm8gdGV4dC5cbiAqIEBtZXRob2Qgc2V0UHJlVG91cm5hbWVudEluZm9UZXh0XG4gKi9cblRhYmxlSW5mb1ZpZXcucHJvdG90eXBlLnNldFByZVRvdXJuYW1lbnRJbmZvVGV4dCA9IGZ1bmN0aW9uKHMpIHtcblx0aWYgKCFzKVxuXHRcdHMgPSBcIlwiO1xuXG5cdHRoaXMucHJlVG91cm5hbWVudEluZm9UZXh0LnNldFRleHQocyk7XG5cdHRoaXMucHJlVG91cm5hbWVudEluZm9UZXh0LnBvc2l0aW9uLnggPSA5NjAgLyAyIC0gdGhpcy5wcmVUb3VybmFtZW50SW5mb1RleHQud2lkdGggLyAyO1xufVxuXG4vKipcbiAqIEpvaW4gYnV0dG9uLlxuICogQG1ldGhvZCBzZXRKb2luQnV0dG9uVmlzaWJsZVxuICovXG5UYWJsZUluZm9WaWV3LnByb3RvdHlwZS5zZXRKb2luQnV0dG9uVmlzaWJsZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdHRoaXMuam9pbkJ1dHRvbi52aXNpYmxlID0gdmFsdWU7XG59XG5cbi8qKlxuICogSm9pbiBidXR0b25cbiAqIEBtZXRob2Qgc2V0TGVhdmVCdXR0b25WaXNpYmxlXG4gKi9cblRhYmxlSW5mb1ZpZXcucHJvdG90eXBlLnNldExlYXZlQnV0dG9uVmlzaWJsZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdHRoaXMubGVhdmVCdXR0b24udmlzaWJsZSA9IHZhbHVlO1xufVxuXG4vKipcbiAqIFNldCBoYW5kIGluZm8gdGV4dC5cbiAqIEBtZXRob2Qgc2V0VGFibGVJbmZvVGV4dFxuICovXG5UYWJsZUluZm9WaWV3LnByb3RvdHlwZS5zZXRIYW5kSW5mb1RleHQgPSBmdW5jdGlvbihzKSB7XG5cdGlmICghcylcblx0XHRzID0gXCJcIjtcblxuXHR0aGlzLmhhbmRJbmZvVGV4dC5zZXRUZXh0KHMpO1xuXHR0aGlzLmhhbmRJbmZvVGV4dC51cGRhdGVUcmFuc2Zvcm0oKTtcblx0dGhpcy5oYW5kSW5mb1RleHQucG9zaXRpb24ueCA9IDk2MCAtIHRoaXMuaGFuZEluZm9UZXh0LndpZHRoIC0gMTA7XG59XG5cbi8qKlxuICogQ2xlYXIuXG4gKiBAbWV0aG9kIGNsZWFyXG4gKi9cblRhYmxlSW5mb1ZpZXcucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMudGFibGVJbmZvVGV4dC5zZXRUZXh0KFwiXCIpO1xuXHR0aGlzLmhhbmRJbmZvVGV4dC5zZXRUZXh0KFwiXCIpO1xuXHR0aGlzLnByZVRvdXJuYW1lbnRJbmZvVGV4dC5zZXRUZXh0KFwiXCIpO1xuXHR0aGlzLmpvaW5CdXR0b24udmlzaWJsZSA9IGZhbHNlO1xuXHR0aGlzLmxlYXZlQnV0dG9uLnZpc2libGUgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBCdXR0b24gY2xpY2tcbiAqIEBtZXRob2Qgb25CdXR0b25DbGlja1xuICogQHByaXZhdGVcbiAqL1xuVGFibGVJbmZvVmlldy5wcm90b3R5cGUub25CdXR0b25DbGljayA9IGZ1bmN0aW9uKGUpIHtcblx0dGhpcy5qb2luQnV0dG9uLnZpc2libGUgPSBmYWxzZTtcblx0dGhpcy5sZWF2ZUJ1dHRvbi52aXNpYmxlID0gZmFsc2U7XG5cblx0dmFyIGV2ID0ge1xuXHRcdHR5cGU6IFRhYmxlSW5mb1ZpZXcuQlVUVE9OX0NMSUNLXG5cdH07XG5cblx0aWYgKGUudGFyZ2V0ID09IHRoaXMuam9pbkJ1dHRvbilcblx0XHRldi5idXR0b24gPSBCdXR0b25EYXRhLkpPSU5fVE9VUk5BTUVOVDtcblxuXHRpZiAoZS50YXJnZXQgPT0gdGhpcy5sZWF2ZUJ1dHRvbilcblx0XHRldi5idXR0b24gPSBCdXR0b25EYXRhLkxFQVZFX1RPVVJOQU1FTlQ7XG5cblx0Y29uc29sZS5sb2coXCJidXR0b24gY2xpY2tcIik7XG5cdHRoaXMudHJpZ2dlcihldik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGFibGVJbmZvVmlldzsiLCIvKipcbiAqIENsaWVudC5cbiAqIEBtb2R1bGUgY2xpZW50XG4gKi9cblxudmFyIFBJWEkgPSByZXF1aXJlKFwicGl4aS5qc1wiKTtcbnZhciBUV0VFTiA9IHJlcXVpcmUoXCJ0d2Vlbi5qc1wiKTtcbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKFwieWFlZFwiKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCJpbmhlcml0c1wiKTtcblxuLyoqXG4gKiBBIHRpbWVyIHZpZXdcbiAqIEBjbGFzcyBUaW1lclZpZXdcbiAqL1xuZnVuY3Rpb24gVGltZXJWaWV3KHZpZXdDb25maWcsIHJlc291cmNlcykge1xuXHRQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIuY2FsbCh0aGlzKTtcblxuXHR0aGlzLnJlc291cmNlcyA9IHJlc291cmNlc1xuXG5cdHRoaXMudGltZXJDbGlwID0gbmV3IFBJWEkuU3ByaXRlKHRoaXMucmVzb3VyY2VzLmdldFRleHR1cmUoXCJ0aW1lckJhY2tncm91bmRcIikpO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMudGltZXJDbGlwKTtcblxuXG5cdHRoaXMuY2FudmFzID0gbmV3IFBJWEkuR3JhcGhpY3MoKTtcblx0dGhpcy5jYW52YXMueCA9IHRoaXMudGltZXJDbGlwLndpZHRoICogMC41O1xuXHR0aGlzLmNhbnZhcy55ID0gdGhpcy50aW1lckNsaXAuaGVpZ2h0ICogMC41O1xuXHR0aGlzLnRpbWVyQ2xpcC5hZGRDaGlsZCh0aGlzLmNhbnZhcyk7XG5cblx0dGhpcy50aW1lckNsaXAudmlzaWJsZSA9IGZhbHNlO1xuXG5cdHRoaXMudHdlZW4gPSBudWxsO1xuXG5cdC8vdGhpcy5zaG93UGVyY2VudCgzMCk7XG59XG5cbmluaGVyaXRzKFRpbWVyVmlldywgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyKTtcbkV2ZW50RGlzcGF0Y2hlci5pbml0KFRpbWVyVmlldyk7XG5cbi8qKlxuICogSGlkZS5cbiAqIEBtZXRob2QgaGlkZVxuICovXG5UaW1lclZpZXcucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcblx0dGhpcy50aW1lckNsaXAudmlzaWJsZSA9IGZhbHNlO1xuXHR0aGlzLnN0b3AoKTtcbn1cblxuLyoqXG4gKiBTaG93LlxuICogQG1ldGhvZCBzaG93XG4gKi9cblRpbWVyVmlldy5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKHNlYXRJbmRleCkge1xuXG5cdHRoaXMudGltZXJDbGlwLnZpc2libGUgPSB0cnVlO1xuXG5cdHZhciBzZWF0UG9zaXRpb24gPSB0aGlzLnJlc291cmNlcy5nZXRQb2ludChcInNlYXRQb3NpdGlvblwiICsgc2VhdEluZGV4KTtcblx0dmFyIHRpbWVyT2Zmc2V0ID0gdGhpcy5yZXNvdXJjZXMuZ2V0UG9pbnQoXCJ0aW1lck9mZnNldFwiKTtcblxuXHR0aGlzLnRpbWVyQ2xpcC54ID0gc2VhdFBvc2l0aW9uLnggKyB0aW1lck9mZnNldC54O1xuXHR0aGlzLnRpbWVyQ2xpcC55ID0gc2VhdFBvc2l0aW9uLnkgKyB0aW1lck9mZnNldC55O1xuXG5cdHRoaXMuc3RvcCgpO1xuXG59XG5cbi8qKlxuICogU3RvcC5cbiAqIEBtZXRob2Qgc3RvcFxuICovXG5UaW1lclZpZXcucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbihzZWF0SW5kZXgpIHtcblx0aWYgKHRoaXMudHdlZW4gIT0gbnVsbClcblx0XHR0aGlzLnR3ZWVuLnN0b3AoKTtcblxufVxuXG4vKipcbiAqIENvdW50ZG93bi5cbiAqIEBtZXRob2QgY291bnRkb3duXG4gKi9cblRpbWVyVmlldy5wcm90b3R5cGUuY291bnRkb3duID0gZnVuY3Rpb24odG90YWxUaW1lLCB0aW1lTGVmdCkge1xuXHR0aGlzLnN0b3AoKTtcblxuXHR0b3RhbFRpbWUgKj0gMTAwMDtcblx0dGltZUxlZnQgKj0gMTAwMDtcblxuXHR2YXIgdGltZSA9IERhdGUubm93KCk7XG5cdHRoaXMuc3RhcnRBdCA9IHRpbWUgKyB0aW1lTGVmdCAtIHRvdGFsVGltZTtcblx0dGhpcy5zdG9wQXQgPSB0aW1lICsgdGltZUxlZnQ7XG5cblx0dGhpcy50d2VlbiA9IG5ldyBUV0VFTi5Ud2Vlbih7XG5cdFx0XHR0aW1lOiB0aW1lXG5cdFx0fSlcblx0XHQudG8oe1xuXHRcdFx0dGltZTogdGhpcy5zdG9wQXRcblx0XHR9LCB0aW1lTGVmdClcblx0XHQub25VcGRhdGUodGhpcy5vblVwZGF0ZS5iaW5kKHRoaXMpKVxuXHRcdC5vbkNvbXBsZXRlKHRoaXMub25Db21wbGV0ZS5iaW5kKHRoaXMpKVxuXHRcdC5zdGFydCgpO1xuXG59XG5cbi8qKlxuICogT24gdHdlZW4gdXBkYXRlLlxuICogQG1ldGhvZCBvblVwZGF0ZVxuICovXG5UaW1lclZpZXcucHJvdG90eXBlLm9uVXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lID0gRGF0ZS5ub3coKTtcblx0dmFyIHBlcmNlbnQgPSAxMDAgKiAodGltZSAtIHRoaXMuc3RhcnRBdCkgLyAodGhpcy5zdG9wQXQgLSB0aGlzLnN0YXJ0QXQpO1xuXG5cdC8vXHRjb25zb2xlLmxvZyhcInAgPSBcIiArIHBlcmNlbnQpO1xuXG5cdHRoaXMuc2hvd1BlcmNlbnQocGVyY2VudCk7XG59XG5cbi8qKlxuICogT24gdHdlZW4gdXBkYXRlLlxuICogQG1ldGhvZCBvblVwZGF0ZVxuICovXG5UaW1lclZpZXcucHJvdG90eXBlLm9uQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWUgPSBEYXRlLm5vdygpO1xuXHR2YXIgcGVyY2VudCA9IDEwMDtcblx0dGhpcy5zaG93UGVyY2VudChwZXJjZW50KTtcblx0dGhpcy50d2VlbiA9IG51bGw7XG59XG5cbi8qKlxuICogU2hvdyBwZXJjZW50LlxuICogQG1ldGhvZCBzaG93UGVyY2VudFxuICovXG5UaW1lclZpZXcucHJvdG90eXBlLnNob3dQZXJjZW50ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0aWYgKHZhbHVlIDwgMClcblx0XHR2YWx1ZSA9IDA7XG5cblx0aWYgKHZhbHVlID4gMTAwKVxuXHRcdHZhbHVlID0gMTAwO1xuXG5cdHRoaXMuY2FudmFzLmNsZWFyKCk7XG5cblx0dGhpcy5jYW52YXMuYmVnaW5GaWxsKDB4YzAwMDAwKTtcblx0dGhpcy5jYW52YXMuZHJhd0NpcmNsZSgwLCAwLCAxMCk7XG5cdHRoaXMuY2FudmFzLmVuZEZpbGwoKTtcblxuXHR0aGlzLmNhbnZhcy5iZWdpbkZpbGwoMHhmZmZmZmYpO1xuXHR0aGlzLmNhbnZhcy5tb3ZlVG8oMCwgMCk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgMzM7IGkrKykge1xuXHRcdHRoaXMuY2FudmFzLmxpbmVUbyhcblx0XHRcdDEwICogTWF0aC5jb3MoaSAqIHZhbHVlICogMiAqIE1hdGguUEkgLyAoMzIgKiAxMDApIC0gTWF0aC5QSSAvIDIpLFxuXHRcdFx0MTAgKiBNYXRoLnNpbihpICogdmFsdWUgKiAyICogTWF0aC5QSSAvICgzMiAqIDEwMCkgLSBNYXRoLlBJIC8gMilcblx0XHQpO1xuXHR9XG5cblx0dGhpcy5jYW52YXMubGluZVRvKDAsIDApO1xuXHR0aGlzLmNhbnZhcy5lbmRGaWxsKCk7XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lclZpZXc7IiwiLyoqXG4gKiBQcm90b2NvbC5cbiAqIEBtb2R1bGUgcHJvdG9cbiAqL1xuXG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZShcInlhZWRcIik7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiaW5oZXJpdHNcIik7XG5cbnZhciBJbml0TWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL0luaXRNZXNzYWdlXCIpO1xudmFyIFN0YXRlQ29tcGxldGVNZXNzYWdlID0gcmVxdWlyZShcIi4vbWVzc2FnZXMvU3RhdGVDb21wbGV0ZU1lc3NhZ2VcIik7XG52YXIgU2VhdEluZm9NZXNzYWdlID0gcmVxdWlyZShcIi4vbWVzc2FnZXMvU2VhdEluZm9NZXNzYWdlXCIpO1xudmFyIENvbW11bml0eUNhcmRzTWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL0NvbW11bml0eUNhcmRzTWVzc2FnZVwiKTtcbnZhciBQb2NrZXRDYXJkc01lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9Qb2NrZXRDYXJkc01lc3NhZ2VcIik7XG52YXIgU2VhdENsaWNrTWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL1NlYXRDbGlja01lc3NhZ2VcIik7XG52YXIgU2hvd0RpYWxvZ01lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9TaG93RGlhbG9nTWVzc2FnZVwiKTtcbnZhciBCdXR0b25DbGlja01lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9CdXR0b25DbGlja01lc3NhZ2VcIik7XG52YXIgQnV0dG9uc01lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9CdXR0b25zTWVzc2FnZVwiKTtcbnZhciBEZWxheU1lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9EZWxheU1lc3NhZ2VcIik7XG52YXIgQ2xlYXJNZXNzYWdlID0gcmVxdWlyZShcIi4vbWVzc2FnZXMvQ2xlYXJNZXNzYWdlXCIpO1xudmFyIERlYWxlckJ1dHRvbk1lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9EZWFsZXJCdXR0b25NZXNzYWdlXCIpO1xudmFyIEJldE1lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9CZXRNZXNzYWdlXCIpO1xudmFyIEJldHNUb1BvdE1lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9CZXRzVG9Qb3RNZXNzYWdlXCIpO1xuXG52YXIgQWN0aW9uTWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL0FjdGlvbk1lc3NhZ2VcIik7XG52YXIgQ2hhdE1lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9DaGF0TWVzc2FnZVwiKTtcbnZhciBDaGVja2JveE1lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9DaGVja2JveE1lc3NhZ2VcIik7XG52YXIgRmFkZVRhYmxlTWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL0ZhZGVUYWJsZU1lc3NhZ2VcIik7XG52YXIgSGFuZEluZm9NZXNzYWdlID0gcmVxdWlyZShcIi4vbWVzc2FnZXMvSGFuZEluZm9NZXNzYWdlXCIpO1xudmFyIEludGVyZmFjZVN0YXRlTWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL0ludGVyZmFjZVN0YXRlTWVzc2FnZVwiKTtcbnZhciBQYXlPdXRNZXNzYWdlID0gcmVxdWlyZShcIi4vbWVzc2FnZXMvUGF5T3V0TWVzc2FnZVwiKTtcbnZhciBQb3RNZXNzYWdlID0gcmVxdWlyZShcIi4vbWVzc2FnZXMvUG90TWVzc2FnZVwiKTtcbnZhciBQcmVzZXRCdXR0b25DbGlja01lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9QcmVzZXRCdXR0b25DbGlja01lc3NhZ2VcIik7XG52YXIgUHJlc2V0QnV0dG9uc01lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9QcmVzZXRCdXR0b25zTWVzc2FnZVwiKTtcbnZhciBQcmVUb3VybmFtZW50SW5mb01lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9QcmVUb3VybmFtZW50SW5mb01lc3NhZ2VcIik7XG52YXIgVGFibGVCdXR0b25DbGlja01lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9UYWJsZUJ1dHRvbkNsaWNrTWVzc2FnZVwiKTtcbnZhciBUYWJsZUJ1dHRvbnNNZXNzYWdlID0gcmVxdWlyZShcIi4vbWVzc2FnZXMvVGFibGVCdXR0b25zTWVzc2FnZVwiKTtcbnZhciBUYWJsZUluZm9NZXNzYWdlID0gcmVxdWlyZShcIi4vbWVzc2FnZXMvVGFibGVJbmZvTWVzc2FnZVwiKTtcbnZhciBUZXN0Q2FzZVJlcXVlc3RNZXNzYWdlID0gcmVxdWlyZShcIi4vbWVzc2FnZXMvVGVzdENhc2VSZXF1ZXN0TWVzc2FnZVwiKTtcbnZhciBUaW1lck1lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9UaW1lck1lc3NhZ2VcIik7XG52YXIgVG91cm5hbWVudFJlc3VsdE1lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9Ub3VybmFtZW50UmVzdWx0TWVzc2FnZVwiKTtcbnZhciBGb2xkQ2FyZHNNZXNzYWdlID0gcmVxdWlyZShcIi4vbWVzc2FnZXMvRm9sZENhcmRzTWVzc2FnZVwiKTtcblxuLyoqXG4gKiBBIHByb3RvY29sIGNvbm5lY3Rpb24gd2l0aCBhbiB1bmRlcmx5aW5nIGNvbm5lY3Rpb24uXG4gKlxuICogVGhlcmUgYXJlIHR3byB3YXlzIHRvIGxpdGVuIGZvciBjb25uZWN0aW9ucywgdGhlIGZpcnN0IG9uZSBhbmQgbW9zdCBzdHJhaWdodFxuICogZm9yd2FyZCBpcyB0aGUgYWRkTWVzc2FnZUhhbmRsZXIsIHdoaWNoIHJlZ2lzdGVycyBhIGxpc3RlbmVyIGZvciBhXG4gKiBwYXJ0aWN1bGFyIG5ldHdvcmsgbWVzc2FnZS4gVGhlIGZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSB0aGUgbWVzc2FnZVxuICogY2xhc3MgdG8gbGlzdGVuIGZvcjpcbiAqXG4gKiAgICAgZnVuY3Rpb24gb25TZWF0SW5mb01lc3NhZ2UobSkge1xuICogICAgICAgICAvLyBDaGVjayBpZiB0aGUgc2VhdCBpcyBhY3RpdmUuXG4gKiAgICAgICAgIG0uaXNBY3RpdmUoKTtcbiAqICAgICB9XG4gKlxuICogICAgIHByb3RvQ29ubmVjdGlvbi5hZGRNZXNzYWdlSGFuZGxlcihTZWF0SW5mb01lc3NhZ2UsIG9uU2VhdEluZm9NZXNzYWdlKTtcbiAqXG4gKiBUaGUgc2Vjb25kIG1ldGhvZCBpcyB0byBsaXN0ZW4gdG8gdGhlIFByb3RvQ29ubmVjdGlvbi5NRVNTQUdFIGRpc3BhdGNoZWRcbiAqIGJ5IHRoZSBpbnN0YW5jZSBvZiB0aGUgUHJvdG9Db25uZWN0aW9uLiBJbiB0aGlzIGNhc2UsIHRoZSBsaXN0ZW5lclxuICogd2lsbCBiZSBjYWxsZWQgZm9yIGFsbCBtZXNzYWdlcyByZWNlaXZlZCBvbiB0aGUgY29ubmVjdGlvbi5cbiAqXG4gKiAgICAgZnVuY3Rpb24gb25NZXNzYWdlKGUpIHtcbiAqICAgICAgICAgdmFyIG1lc3NhZ2U9ZS5tZXNzYWdlO1xuICpcbiAqICAgICAgICAgLy8gSXMgaXQgYSBTZWF0SW5mb01lc3NhZ2U/XG4gKiAgICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgU2VhdEluZm9NZXNzYWdlKSB7XG4gKiAgICAgICAgICAgICAvLyAuLi5cbiAqICAgICAgICAgfVxuICogICAgIH1cbiAqXG4gKiAgICAgcHJvdG9Db25uZWN0aW9uLmFkZE1lc3NhZ2VIYW5kbGVyKFNlYXRJbmZvTWVzc2FnZSwgb25NZXNzYWdlKTtcbiAqXG4gKiBUaGUgdW5kZXJseWluZyBjb25uZWN0aW9uIHNob3VsZCBiZSBhbiBvYmplY3QgdGhhdCBpbXBsZW1lbnRzIGFuIFwiaW50ZXJmYWNlXCJcbiAqIG9mIGEgY29ubmVjdGlvbi4gSXQgaXMgbm90IGFuIGludGVyZmFjZSBwZXIgc2UsIHNpbmNlIEphdmFTY3JpcHQgZG9lc24ndCBzdXBwb3J0XG4gKiBpdC4gQW55d2F5LCB0aGUgc2lnbmF0dXJlIG9mIHRoaXMgaW50ZXJmYWNlLCBpcyB0aGF0IHRoZSBjb25uZWN0aW9uIG9iamVjdFxuICogc2hvdWxkIGhhdmUgYSBgc2VuZGAgbWV0aG9kIHdoaWNoIHJlY2VpdmVzIGEgb2JqZWN0IHRvIGJlIHNlbmQuIEl0IHNob3VsZCBhbHNvXG4gKiBkaXNwYXRjaCBcIm1lc3NhZ2VcIiBldmVudHMgYXMgbWVzc2FnZXMgYXJlIHJlY2VpdmVkLCBhbmQgXCJjbG9zZVwiIGV2ZW50cyBpZiB0aGVcbiAqIGNvbm5lY3Rpb24gaXMgY2xvc2VkIGJ5IHRoZSByZW1vdGUgcGFydHkuXG4gKlxuICogQGNsYXNzIFByb3RvQ29ubmVjdGlvblxuICogQGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSBjb25uZWN0aW9uIFRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb24gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBQcm90b0Nvbm5lY3Rpb24oY29ubmVjdGlvbikge1xuXHRFdmVudERpc3BhdGNoZXIuY2FsbCh0aGlzKTtcblxuXHR0aGlzLmxvZ01lc3NhZ2VzID0gZmFsc2U7XG5cdHRoaXMubWVzc2FnZURpc3BhdGNoZXIgPSBuZXcgRXZlbnREaXNwYXRjaGVyKCk7XG5cdHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG5cdHRoaXMuY29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLm9uQ29ubmVjdGlvbk1lc3NhZ2UsIHRoaXMpO1xuXHR0aGlzLmNvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIHRoaXMub25Db25uZWN0aW9uQ2xvc2UsIHRoaXMpO1xufVxuXG5pbmhlcml0cyhQcm90b0Nvbm5lY3Rpb24sIEV2ZW50RGlzcGF0Y2hlcik7XG5cbi8qKlxuICogVHJpZ2dlcnMgaWYgdGhlIHJlbW90ZSBwYXJ0eSBjbG9zZXMgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvbi5cbiAqIEBldmVudCBQcm90b0Nvbm5lY3Rpb24uQ0xPU0VcbiAqL1xuUHJvdG9Db25uZWN0aW9uLkNMT1NFID0gXCJjbG9zZVwiO1xuXG4vKipcbiAqIFRyaWdnZXJzIHdoZW4gd2UgcmVjZWl2ZSBhIG1lc3NhZ2UgZnJvbSB0aGUgcmVtb3RlIHBhcnR5LlxuICogQGV2ZW50IFByb3RvQ29ubmVjdGlvbi5NRVNTQUdFXG4gKiBAcGFyYW0ge09iamVjdH0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0aGF0IHdhcyByZWNlaXZlZC5cbiAqL1xuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0UgPSBcIm1lc3NhZ2VcIjtcblxuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVMgPSB7fTtcblByb3RvQ29ubmVjdGlvbi5NRVNTQUdFX1RZUEVTW0luaXRNZXNzYWdlLlRZUEVdID0gSW5pdE1lc3NhZ2U7XG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tTdGF0ZUNvbXBsZXRlTWVzc2FnZS5UWVBFXSA9IFN0YXRlQ29tcGxldGVNZXNzYWdlO1xuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVNbU2VhdEluZm9NZXNzYWdlLlRZUEVdID0gU2VhdEluZm9NZXNzYWdlO1xuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVNbQ29tbXVuaXR5Q2FyZHNNZXNzYWdlLlRZUEVdID0gQ29tbXVuaXR5Q2FyZHNNZXNzYWdlO1xuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVNbUG9ja2V0Q2FyZHNNZXNzYWdlLlRZUEVdID0gUG9ja2V0Q2FyZHNNZXNzYWdlO1xuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVNbU2VhdENsaWNrTWVzc2FnZS5UWVBFXSA9IFNlYXRDbGlja01lc3NhZ2U7XG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tTaG93RGlhbG9nTWVzc2FnZS5UWVBFXSA9IFNob3dEaWFsb2dNZXNzYWdlO1xuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVNbQnV0dG9uQ2xpY2tNZXNzYWdlLlRZUEVdID0gQnV0dG9uQ2xpY2tNZXNzYWdlO1xuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVNbQnV0dG9uc01lc3NhZ2UuVFlQRV0gPSBCdXR0b25zTWVzc2FnZTtcblByb3RvQ29ubmVjdGlvbi5NRVNTQUdFX1RZUEVTW0RlbGF5TWVzc2FnZS5UWVBFXSA9IERlbGF5TWVzc2FnZTtcblByb3RvQ29ubmVjdGlvbi5NRVNTQUdFX1RZUEVTW0NsZWFyTWVzc2FnZS5UWVBFXSA9IENsZWFyTWVzc2FnZTtcblByb3RvQ29ubmVjdGlvbi5NRVNTQUdFX1RZUEVTW0RlYWxlckJ1dHRvbk1lc3NhZ2UuVFlQRV0gPSBEZWFsZXJCdXR0b25NZXNzYWdlO1xuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVNbQmV0TWVzc2FnZS5UWVBFXSA9IEJldE1lc3NhZ2U7XG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tCZXRzVG9Qb3RNZXNzYWdlLlRZUEVdID0gQmV0c1RvUG90TWVzc2FnZTtcblxuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVNbQWN0aW9uTWVzc2FnZS5UWVBFXSA9IEFjdGlvbk1lc3NhZ2U7XG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tDaGF0TWVzc2FnZS5UWVBFXSA9IENoYXRNZXNzYWdlO1xuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVNbQ2hlY2tib3hNZXNzYWdlLlRZUEVdID0gQ2hlY2tib3hNZXNzYWdlO1xuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVNbRmFkZVRhYmxlTWVzc2FnZS5UWVBFXSA9IEZhZGVUYWJsZU1lc3NhZ2U7XG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tIYW5kSW5mb01lc3NhZ2UuVFlQRV0gPSBIYW5kSW5mb01lc3NhZ2U7XG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tJbnRlcmZhY2VTdGF0ZU1lc3NhZ2UuVFlQRV0gPSBJbnRlcmZhY2VTdGF0ZU1lc3NhZ2U7XG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tQYXlPdXRNZXNzYWdlLlRZUEVdID0gUGF5T3V0TWVzc2FnZTtcblByb3RvQ29ubmVjdGlvbi5NRVNTQUdFX1RZUEVTW1BvdE1lc3NhZ2UuVFlQRV0gPSBQb3RNZXNzYWdlO1xuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVNbUHJlc2V0QnV0dG9uQ2xpY2tNZXNzYWdlLlRZUEVdID0gUHJlc2V0QnV0dG9uQ2xpY2tNZXNzYWdlO1xuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVNbUHJlc2V0QnV0dG9uc01lc3NhZ2UuVFlQRV0gPSBQcmVzZXRCdXR0b25zTWVzc2FnZTtcblByb3RvQ29ubmVjdGlvbi5NRVNTQUdFX1RZUEVTW1ByZVRvdXJuYW1lbnRJbmZvTWVzc2FnZS5UWVBFXSA9IFByZVRvdXJuYW1lbnRJbmZvTWVzc2FnZTtcblByb3RvQ29ubmVjdGlvbi5NRVNTQUdFX1RZUEVTW1RhYmxlQnV0dG9uQ2xpY2tNZXNzYWdlLlRZUEVdID0gVGFibGVCdXR0b25DbGlja01lc3NhZ2U7XG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tUYWJsZUJ1dHRvbnNNZXNzYWdlLlRZUEVdID0gVGFibGVCdXR0b25zTWVzc2FnZTtcblByb3RvQ29ubmVjdGlvbi5NRVNTQUdFX1RZUEVTW1RhYmxlSW5mb01lc3NhZ2UuVFlQRV0gPSBUYWJsZUluZm9NZXNzYWdlO1xuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVNbVGVzdENhc2VSZXF1ZXN0TWVzc2FnZS5UWVBFXSA9IFRlc3RDYXNlUmVxdWVzdE1lc3NhZ2U7XG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tUaW1lck1lc3NhZ2UuVFlQRV0gPSBUaW1lck1lc3NhZ2U7XG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tUb3VybmFtZW50UmVzdWx0TWVzc2FnZS5UWVBFXSA9IFRvdXJuYW1lbnRSZXN1bHRNZXNzYWdlO1xuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVNbRm9sZENhcmRzTWVzc2FnZS5UWVBFXSA9IEZvbGRDYXJkc01lc3NhZ2U7XG5cbi8qKlxuICogQWRkIG1lc3NhZ2UgaGFuZGxlci5cbiAqIEBtZXRob2QgYWRkTWVzc2FnZUhhbmRsZXJcbiAqL1xuUHJvdG9Db25uZWN0aW9uLnByb3RvdHlwZS5hZGRNZXNzYWdlSGFuZGxlciA9IGZ1bmN0aW9uKG1lc3NhZ2VUeXBlLCBoYW5kbGVyLCBzY29wZSkge1xuXHRpZiAobWVzc2FnZVR5cGUuaGFzT3duUHJvcGVydHkoXCJUWVBFXCIpKVxuXHRcdG1lc3NhZ2VUeXBlID0gbWVzc2FnZVR5cGUuVFlQRTtcblxuXHR0aGlzLm1lc3NhZ2VEaXNwYXRjaGVyLm9uKG1lc3NhZ2VUeXBlLCBoYW5kbGVyLCBzY29wZSk7XG59XG5cbi8qKlxuICogUmVtb3ZlIG1lc3NhZ2UgaGFuZGxlci5cbiAqIEBtZXRob2QgcmVtb3ZlTWVzc2FnZUhhbmRsZXJcbiAqL1xuUHJvdG9Db25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVNZXNzYWdlSGFuZGxlciA9IGZ1bmN0aW9uKG1lc3NhZ2VUeXBlLCBoYW5kbGVyLCBzY29wZSkge1xuXHRpZiAobWVzc2FnZVR5cGUuaGFzT3duUHJvcGVydHkoXCJUWVBFXCIpKVxuXHRcdG1lc3NhZ2VUeXBlID0gbWVzc2FnZVR5cGUuVFlQRTtcblxuXHR0aGlzLm1lc3NhZ2VEaXNwYXRjaGVyLm9mZihtZXNzYWdlVHlwZSwgaGFuZGxlciwgc2NvcGUpO1xufVxuXG4vKipcbiAqIENvbm5lY3Rpb24gbWVzc2FnZS5cbiAqIEBtZXRob2Qgb25Db25uZWN0aW9uTWVzc2FnZVxuICogQHByaXZhdGVcbiAqL1xuUHJvdG9Db25uZWN0aW9uLnByb3RvdHlwZS5vbkNvbm5lY3Rpb25NZXNzYWdlID0gZnVuY3Rpb24oZXYpIHtcblx0dmFyIG1lc3NhZ2UgPSBldi5tZXNzYWdlO1xuXHR2YXIgY29uc3RydWN0b3I7XG5cblx0aWYgKHRoaXMubG9nTWVzc2FnZXMpXG5cdFx0Y29uc29sZS5sb2coXCI9PT4gXCIgKyBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSk7XG5cblx0Zm9yICh0eXBlIGluIFByb3RvQ29ubmVjdGlvbi5NRVNTQUdFX1RZUEVTKSB7XG5cdFx0aWYgKG1lc3NhZ2UudHlwZSA9PSB0eXBlKVxuXHRcdFx0Y29uc3RydWN0b3IgPSBQcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1t0eXBlXVxuXHR9XG5cblx0aWYgKCFjb25zdHJ1Y3Rvcikge1xuXHRcdGNvbnNvbGUud2FybihcInVua25vd24gbWVzc2FnZTogXCIgKyBtZXNzYWdlLnR5cGUpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBvID0gbmV3IGNvbnN0cnVjdG9yKCk7XG5cdG8udW5zZXJpYWxpemUobWVzc2FnZSk7XG5cdG8udHlwZSA9IG1lc3NhZ2UudHlwZTtcblxuXHR0aGlzLm1lc3NhZ2VEaXNwYXRjaGVyLnRyaWdnZXIobyk7XG5cblx0dGhpcy50cmlnZ2VyKHtcblx0XHR0eXBlOiBQcm90b0Nvbm5lY3Rpb24uTUVTU0FHRSxcblx0XHRtZXNzYWdlOiBvXG5cdH0pO1xufVxuXG4vKipcbiAqIENvbm5lY3Rpb24gY2xvc2UuXG4gKiBAbWV0aG9kIG9uQ29ubmVjdGlvbkNsb3NlXG4gKiBAcHJpdmF0ZVxuICovXG5Qcm90b0Nvbm5lY3Rpb24ucHJvdG90eXBlLm9uQ29ubmVjdGlvbkNsb3NlID0gZnVuY3Rpb24oZXYpIHtcblx0dGhpcy5jb25uZWN0aW9uLm9mZihcIm1lc3NhZ2VcIiwgdGhpcy5vbkNvbm5lY3Rpb25NZXNzYWdlLCB0aGlzKTtcblx0dGhpcy5jb25uZWN0aW9uLm9mZihcImNsb3NlXCIsIHRoaXMub25Db25uZWN0aW9uQ2xvc2UsIHRoaXMpO1xuXG5cdHRoaXMuY2xvc2UoKTtcblxuXHR0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuXG5cdHRoaXMudHJpZ2dlcihQcm90b0Nvbm5lY3Rpb24uQ0xPU0UpO1xufVxuXG4vKipcbiAqIFNlbmQgYSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZW5kXG4gKi9cblByb3RvQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0dmFyIHNlcmlhbGl6ZWQgPSBtZXNzYWdlLnNlcmlhbGl6ZSgpO1xuXG5cdGZvciAodHlwZSBpbiBQcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFUykge1xuXHRcdGlmIChtZXNzYWdlIGluc3RhbmNlb2YgUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVNbdHlwZV0pXG5cdFx0XHRzZXJpYWxpemVkLnR5cGUgPSB0eXBlO1xuXHR9XG5cblx0aWYgKCFzZXJpYWxpemVkLnR5cGUpXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBtZXNzYWdlIHR5cGUgZm9yIHNlbmQsIG1lc3NhZ2U9XCIgKyBtZXNzYWdlLmNvbnN0cnVjdG9yLm5hbWUpO1xuXG5cdC8vXHRjb25zb2xlLmxvZyhcInNlbmRpbmc6IFwiK3NlcmlhbGl6ZWQpO1xuXG5cdHRoaXMuY29ubmVjdGlvbi5zZW5kKHNlcmlhbGl6ZWQpO1xufVxuXG4vKipcbiAqIFNob3VsZCBtZXNzYWdlcyBiZSBsb2dnZWQgdG8gY29uc29sZT9cbiAqIEBtZXRob2Qgc2V0TG9nTWVzc2FnZXNcbiAqL1xuUHJvdG9Db25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2dNZXNzYWdlcyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdHRoaXMubG9nTWVzc2FnZXMgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDbG9zZSB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uLiBPbmx5IGNsb3NlIGl0IGlmIHRoZSByZWFkeVN0YXRlIGlzIHVuZGVmaW5lZCxcbiAqIGkuZS4gd2UgYXJlIGluIGEgbm9kZS5qcyBlbnZpcm9ubWVudCwgb3IgaWYgaXQgc2F5cyB0aGF0IGl0IGlzIGFjdHVhbGx5IG9wZW4uXG4gKiBAbWV0aG9kIGNsb3NlXG4gKi9cblByb3RvQ29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcblx0aWYgKCF0aGlzLmNvbm5lY3Rpb24pXG5cdFx0cmV0dXJuO1xuXG5cdGlmICh0aGlzLmNvbm5lY3Rpb24ucmVhZHlTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0dGhpcy5jb25uZWN0aW9uLnJlYWR5U3RhdGUgPT0gMSlcblx0XHR0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKTtcbn1cblxuLyoqXG4gKiBHZXQgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICogQG1ldGhvZCB0b1N0cmluZ1xuICovXG5Qcm90b0Nvbm5lY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBcIjxQcm90b0Nvbm5lY3Rpb24+XCI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvdG9Db25uZWN0aW9uOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxuLyoqXG4gKiBCdXR0b24gZGF0YS5cbiAqIEBjbGFzcyBCdXR0b25EYXRhXG4gKi9cbmZ1bmN0aW9uIEJ1dHRvbkRhdGEoYnV0dG9uLCB2YWx1ZSkge1xuXHR0aGlzLmJ1dHRvbiA9IGJ1dHRvbjtcblx0dGhpcy52YWx1ZSA9IHZhbHVlO1xufVxuXG5CdXR0b25EYXRhLlJBSVNFID0gXCJyYWlzZVwiO1xuQnV0dG9uRGF0YS5GT0xEID0gXCJmb2xkXCI7XG5CdXR0b25EYXRhLkJFVCA9IFwiYmV0XCI7XG5CdXR0b25EYXRhLlNJVF9PVVQgPSBcInNpdE91dFwiO1xuQnV0dG9uRGF0YS5TSVRfSU4gPSBcInNpdEluXCI7XG5CdXR0b25EYXRhLkNBTEwgPSBcImNhbGxcIjtcbkJ1dHRvbkRhdGEuUE9TVF9CQiA9IFwicG9zdEJCXCI7XG5CdXR0b25EYXRhLlBPU1RfU0IgPSBcInBvc3RTQlwiO1xuQnV0dG9uRGF0YS5DQU5DRUwgPSBcImNhbmNlbFwiO1xuQnV0dG9uRGF0YS5DSEVDSyA9IFwiY2hlY2tcIjtcbkJ1dHRvbkRhdGEuU0hPVyA9IFwic2hvd1wiO1xuQnV0dG9uRGF0YS5NVUNLID0gXCJtdWNrXCI7XG5CdXR0b25EYXRhLk9LID0gXCJva1wiO1xuQnV0dG9uRGF0YS5JTV9CQUNLID0gXCJpbUJhY2tcIjtcbkJ1dHRvbkRhdGEuTEVBVkUgPSBcImxlYXZlXCI7XG5CdXR0b25EYXRhLkNIRUNLX0ZPTEQgPSBcImNoZWNrRm9sZFwiO1xuQnV0dG9uRGF0YS5DQUxMX0FOWSA9IFwiY2FsbEFueVwiO1xuQnV0dG9uRGF0YS5SQUlTRV9BTlkgPSBcInJhaXNlQW55XCI7XG5CdXR0b25EYXRhLkJVWV9JTiA9IFwiYnV5SW5cIjtcbkJ1dHRvbkRhdGEuUkVfQlVZID0gXCJyZUJ1eVwiO1xuQnV0dG9uRGF0YS5KT0lOX1RPVVJOQU1FTlQgPSBcImpvaW5Ub3VybmFtZW50XCI7XG5CdXR0b25EYXRhLkxFQVZFX1RPVVJOQU1FTlQgPSBcImxlYXZlVG91cm5hbWVudFwiO1xuXG4vKipcbiAqIEdldCBidXR0b24uXG4gKiBAbWV0aG9kIGdldEJ1dHRvblxuICovXG5CdXR0b25EYXRhLnByb3RvdHlwZS5nZXRCdXR0b24gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuYnV0dG9uO1xufVxuXG4vKipcbiAqIEdldCBidXR0b24gc3RyaW5nIGZvciB0aGlzIGJ1dHRvbi5cbiAqIEBtZXRob2QgZ2V0QnV0dG9uU3RyaW5nXG4gKi9cbkJ1dHRvbkRhdGEucHJvdG90eXBlLmdldEJ1dHRvblN0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gQnV0dG9uRGF0YS5nZXRCdXR0b25TdHJpbmdGb3JJZCh0aGlzLmJ1dHRvbik7XG59XG5cbi8qKlxuICogR2V0IHZhbHVlLlxuICogQG1ldGhvZCBnZXRWYWx1ZVxuICovXG5CdXR0b25EYXRhLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy52YWx1ZTtcbn1cblxuLyoqXG4gKiBHZXQgYnV0dG9uIHN0cmluZyBmb3IgaWQuXG4gKiBAbWV0aG9kIGdldEJ1dHRvblN0cmluZ0ZvcklkXG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvbkRhdGEuZ2V0QnV0dG9uU3RyaW5nRm9ySWQgPSBmdW5jdGlvbihiKSB7XG5cdHN3aXRjaCAoYikge1xuXHRcdGNhc2UgQnV0dG9uRGF0YS5GT0xEOlxuXHRcdFx0cmV0dXJuIFwiRk9MRFwiO1xuXG5cdFx0Y2FzZSBCdXR0b25EYXRhLkNBTEw6XG5cdFx0XHRyZXR1cm4gXCJDQUxMXCI7XG5cblx0XHRjYXNlIEJ1dHRvbkRhdGEuUkFJU0U6XG5cdFx0XHRyZXR1cm4gXCJSQUlTRSBUT1wiO1xuXG5cdFx0Y2FzZSBCdXR0b25EYXRhLkJFVDpcblx0XHRcdHJldHVybiBcIkJFVFwiO1xuXG5cdFx0Y2FzZSBCdXR0b25EYXRhLlNJVF9PVVQ6XG5cdFx0XHRyZXR1cm4gXCJTSVQgT1VUXCI7XG5cblx0XHRjYXNlIEJ1dHRvbkRhdGEuUE9TVF9CQjpcblx0XHRcdHJldHVybiBcIlBPU1QgQkJcIjtcblxuXHRcdGNhc2UgQnV0dG9uRGF0YS5QT1NUX1NCOlxuXHRcdFx0cmV0dXJuIFwiUE9TVCBTQlwiO1xuXG5cdFx0Y2FzZSBCdXR0b25EYXRhLlNJVF9JTjpcblx0XHRcdHJldHVybiBcIlNJVCBJTlwiO1xuXG5cdFx0Y2FzZSBCdXR0b25EYXRhLkNBTkNFTDpcblx0XHRcdHJldHVybiBcIkNBTkNFTFwiO1xuXG5cdFx0Y2FzZSBCdXR0b25EYXRhLkNIRUNLOlxuXHRcdFx0cmV0dXJuIFwiQ0hFQ0tcIjtcblxuXHRcdGNhc2UgQnV0dG9uRGF0YS5TSE9XOlxuXHRcdFx0cmV0dXJuIFwiU0hPV1wiO1xuXG5cdFx0Y2FzZSBCdXR0b25EYXRhLk1VQ0s6XG5cdFx0XHRyZXR1cm4gXCJNVUNLXCI7XG5cblx0XHRjYXNlIEJ1dHRvbkRhdGEuT0s6XG5cdFx0XHRyZXR1cm4gXCJPS1wiO1xuXG5cdFx0Y2FzZSBCdXR0b25EYXRhLklNX0JBQ0s6XG5cdFx0XHRyZXR1cm4gXCJJJ00gQkFDS1wiO1xuXG5cdFx0Y2FzZSBCdXR0b25EYXRhLkxFQVZFOlxuXHRcdFx0cmV0dXJuIFwiTEVBVkVcIjtcblxuXHRcdGNhc2UgQnV0dG9uRGF0YS5DSEVDS19GT0xEOlxuXHRcdFx0cmV0dXJuIFwiQ0hFQ0sgLyBGT0xEXCI7XG5cblx0XHRjYXNlIEJ1dHRvbkRhdGEuQ0FMTF9BTlk6XG5cdFx0XHRyZXR1cm4gXCJDQUxMIEFOWVwiO1xuXG5cdFx0Y2FzZSBCdXR0b25EYXRhLlJBSVNFX0FOWTpcblx0XHRcdHJldHVybiBcIlJBSVNFIEFOWVwiO1xuXG5cdFx0Y2FzZSBCdXR0b25EYXRhLlJFX0JVWTpcblx0XHRcdHJldHVybiBcIlJFLUJVWVwiO1xuXG5cdFx0Y2FzZSBCdXR0b25EYXRhLkJVWV9JTjpcblx0XHRcdHJldHVybiBcIkJVWSBJTlwiO1xuXHR9XG5cblx0cmV0dXJuIFwiXCI7XG59XG5cbkJ1dHRvbkRhdGEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBcIjxCdXR0b25EYXRhIGJ1dHRvbj1cIiArIHRoaXMuYnV0dG9uICsgXCIsIHZhbHVlPVwiICsgdGhpcy52YWx1ZSArIFwiPlwiO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1dHRvbkRhdGE7IiwiLyoqXG4gKiBQcm90b2NvbC5cbiAqIEBtb2R1bGUgcHJvdG9cbiAqL1xuXG4vKipcbiAqIENhcmQgZGF0YS5cbiAqIEBjbGFzcyBDYXJkRGF0YVxuICovXG5mdW5jdGlvbiBDYXJkRGF0YSh2YWx1ZSkge1xuXHR0aGlzLnZhbHVlID0gdmFsdWU7XG59XG5cbkNhcmREYXRhLkNBUkRfVkFMVUVfU1RSSU5HUyA9XG5cdFtcIjJcIiwgXCIzXCIsIFwiNFwiLCBcIjVcIiwgXCI2XCIsIFwiN1wiLCBcIjhcIiwgXCI5XCIsIFwiMTBcIiwgXCJKXCIsIFwiUVwiLCBcIktcIiwgXCJBXCJdO1xuXG5DYXJkRGF0YS5TVUlUX1NUUklOR1MgPVxuXHRbXCJEXCIsIFwiQ1wiLCBcIkhcIiwgXCJTXCJdO1xuQ2FyZERhdGEuTE9OR19TVUlUX1NUUklOR1MgPVxuXHRbXCJEaWFtb25kc1wiLCBcIkNsdWJzXCIsIFwiSGVhcnRzXCIsIFwiU3BhZGVzXCJdO1xuXG5DYXJkRGF0YS5ISURERU4gPSAtMTtcblxuLyoqXG4gKiBEb2VzIHRoaXMgQ2FyZERhdGEgcmVwcmVzZW50IGEgc2hvdyBjYXJkP1xuICogSWYgbm90IGl0IHNob3VsZCBiZSByZW5kZXJlZCB3aXRoIGl0cyBiYWNrc2lkZS5cbiAqIEBtZXRob2QgaXNTaG93blxuICovXG5DYXJkRGF0YS5wcm90b3R5cGUuaXNTaG93biA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy52YWx1ZSA+PSAwO1xufVxuXG4vKipcbiAqIEdldCBjYXJkIHZhbHVlLlxuICogVGhpcyB2YWx1ZSByZXByZXNlbnRzIHRoZSByYW5rIG9mIHRoZSBjYXJkLCBidXQgc3RhcnRzIG9uIDAuXG4gKiBAbWV0aG9kIGdldENhcmRWYWx1ZVxuICovXG5DYXJkRGF0YS5wcm90b3R5cGUuZ2V0Q2FyZFZhbHVlID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnZhbHVlICUgMTM7XG59XG5cbi8qKlxuICogR2V0IGNhcmQgdmFsdWUgc3RyaW5nLlxuICogQG1ldGhvZCBnZXRDYXJkVmFsdWVTdHJpbmdcbiAqL1xuQ2FyZERhdGEucHJvdG90eXBlLmdldENhcmRWYWx1ZVN0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gQ2FyZERhdGEuQ0FSRF9WQUxVRV9TVFJJTkdTW3RoaXMudmFsdWUgJSAxM107XG59XG5cbi8qKlxuICogR2V0IHN1aXQgaW5kZXguXG4gKiBAbWV0aG9kIGdldFN1aXRJbmRleFxuICovXG5DYXJkRGF0YS5wcm90b3R5cGUuZ2V0U3VpdEluZGV4ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWUgLyAxMyk7XG59XG5cbi8qKlxuICogR2V0IHN1aXQgc3RyaW5nLlxuICogQG1ldGhvZCBnZXRTdWl0U3RyaW5nXG4gKi9cbkNhcmREYXRhLnByb3RvdHlwZS5nZXRTdWl0U3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBDYXJkRGF0YS5TVUlUX1NUUklOR1NbdGhpcy5nZXRTdWl0SW5kZXgoKV07XG59XG5cbi8qKlxuICogR2V0IGxvbmcgc3VpdCBzdHJpbmcuXG4gKiBAbWV0aG9kIGdldExvbmdTdWl0U3RyaW5nXG4gKi9cbkNhcmREYXRhLnByb3RvdHlwZS5nZXRMb25nU3VpdFN0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gQ2FyZERhdGEuTE9OR19TVUlUX1NUUklOR1NbdGhpcy5nZXRTdWl0SW5kZXgoKV07XG59XG5cbi8qKlxuICogR2V0IGNvbG9yLlxuICogQG1ldGhvZCBnZXRDb2xvclxuICovXG5DYXJkRGF0YS5wcm90b3R5cGUuZ2V0Q29sb3IgPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuZ2V0U3VpdEluZGV4KCkgJSAyICE9IDApXG5cdFx0cmV0dXJuIFwiIzAwMDAwMFwiO1xuXG5cdGVsc2Vcblx0XHRyZXR1cm4gXCIjZmYwMDAwXCI7XG59XG5cbi8qKlxuICogVG8gc3RyaW5nLlxuICogQG1ldGhvZCB0b1N0cmluZ1xuICovXG5DYXJkRGF0YS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMudmFsdWUgPCAwKVxuXHRcdHJldHVybiBcIlhYXCI7XG5cblx0Ly9cdHJldHVybiBcIjxjYXJkIFwiICsgdGhpcy5nZXRDYXJkVmFsdWVTdHJpbmcoKSArIHRoaXMuZ2V0U3VpdFN0cmluZygpICsgXCI+XCI7XG5cdHJldHVybiB0aGlzLmdldENhcmRWYWx1ZVN0cmluZygpICsgdGhpcy5nZXRTdWl0U3RyaW5nKCk7XG59XG5cbi8qKlxuICogR2V0IHZhbHVlIG9mIHRoZSBjYXJkLlxuICogQG1ldGhvZCBnZXRWYWx1ZVxuICovXG5DYXJkRGF0YS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMudmFsdWU7XG59XG5cbi8qKlxuICogQ29tcGFyZSB3aXRoIHJlc3BlY3QgdG8gdmFsdWUuIE5vdCByZWFsbHkgdXNlZnVsIGV4Y2VwdCBmb3IgZGVidWdnaW5nIVxuICogQG1ldGhvZCBjb21wYXJlVmFsdWVcbiAqIEBzdGF0aWNcbiAqL1xuQ2FyZERhdGEuY29tcGFyZVZhbHVlID0gZnVuY3Rpb24oYSwgYikge1xuXHRpZiAoIShhIGluc3RhbmNlb2YgQ2FyZERhdGEpIHx8ICEoYiBpbnN0YW5jZW9mIENhcmREYXRhKSlcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJOb3QgY29tcGFyaW5nIGNhcmQgZGF0YVwiKTtcblxuXHRpZiAoYS5nZXRWYWx1ZSgpID4gYi5nZXRWYWx1ZSgpKVxuXHRcdHJldHVybiAxO1xuXG5cdGlmIChhLmdldFZhbHVlKCkgPCBiLmdldFZhbHVlKCkpXG5cdFx0cmV0dXJuIC0xO1xuXG5cdHJldHVybiAwO1xufVxuXG4vKipcbiAqIENvbXBhcmUgd2l0aCByZXNwZWN0IHRvIGNhcmQgdmFsdWUuXG4gKiBAbWV0aG9kIGNvbXBhcmVDYXJkVmFsdWVcbiAqIEBzdGF0aWNcbiAqL1xuQ2FyZERhdGEuY29tcGFyZUNhcmRWYWx1ZSA9IGZ1bmN0aW9uKGEsIGIpIHtcblx0aWYgKCEoYSBpbnN0YW5jZW9mIENhcmREYXRhKSB8fCAhKGIgaW5zdGFuY2VvZiBDYXJkRGF0YSkpXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiTm90IGNvbXBhcmluZyBjYXJkIGRhdGFcIik7XG5cblx0aWYgKGEuZ2V0Q2FyZFZhbHVlKCkgPiBiLmdldENhcmRWYWx1ZSgpKVxuXHRcdHJldHVybiAxO1xuXG5cdGlmIChhLmdldENhcmRWYWx1ZSgpIDwgYi5nZXRDYXJkVmFsdWUoKSlcblx0XHRyZXR1cm4gLTE7XG5cblx0cmV0dXJuIDA7XG59XG5cbi8qKlxuICogQ29tcGFyZSB3aXRoIHJlc3BlY3QgdG8gc3VpdC5cbiAqIEBtZXRob2QgY29tcGFyZVN1aXRcbiAqIEBzdGF0aWNcbiAqL1xuQ2FyZERhdGEuY29tcGFyZVN1aXRJbmRleCA9IGZ1bmN0aW9uKGEsIGIpIHtcblx0aWYgKCEoYSBpbnN0YW5jZW9mIENhcmREYXRhKSB8fCAhKGIgaW5zdGFuY2VvZiBDYXJkRGF0YSkpXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiTm90IGNvbXBhcmluZyBjYXJkIGRhdGFcIik7XG5cblx0aWYgKGEuZ2V0U3VpdEluZGV4KCkgPiBiLmdldFN1aXRJbmRleCgpKVxuXHRcdHJldHVybiAxO1xuXG5cdGlmIChhLmdldFN1aXRJbmRleCgpIDwgYi5nZXRTdWl0SW5kZXgoKSlcblx0XHRyZXR1cm4gLTE7XG5cblx0cmV0dXJuIDA7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FyZCBkYXRhIGZyb20gYSBzdHJpbmcuXG4gKiBAbWV0aG9kIGZyb21TdHJpbmdcbiAqIEBzdGF0aWNcbiAqL1xuQ2FyZERhdGEuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHMpIHtcblx0dmFyIGk7XG5cblx0dmFyIGNhcmRWYWx1ZSA9IC0xO1xuXHRmb3IgKGkgPSAwOyBpIDwgQ2FyZERhdGEuQ0FSRF9WQUxVRV9TVFJJTkdTLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGNhbmQgPSBDYXJkRGF0YS5DQVJEX1ZBTFVFX1NUUklOR1NbaV07XG5cblx0XHRpZiAocy5zdWJzdHJpbmcoMCwgY2FuZC5sZW5ndGgpLnRvVXBwZXJDYXNlKCkgPT0gY2FuZClcblx0XHRcdGNhcmRWYWx1ZSA9IGk7XG5cdH1cblxuXHRpZiAoY2FyZFZhbHVlIDwgMClcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSB2YWxpZCBjYXJkIHN0cmluZzogXCIgKyBzKTtcblxuXHR2YXIgc3VpdFN0cmluZyA9IHMuc3Vic3RyaW5nKENhcmREYXRhLkNBUkRfVkFMVUVfU1RSSU5HU1tjYXJkVmFsdWVdLmxlbmd0aCk7XG5cblx0dmFyIHN1aXRJbmRleCA9IC0xO1xuXHRmb3IgKGkgPSAwOyBpIDwgQ2FyZERhdGEuU1VJVF9TVFJJTkdTLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGNhbmQgPSBDYXJkRGF0YS5TVUlUX1NUUklOR1NbaV07XG5cblx0XHRpZiAoc3VpdFN0cmluZy50b1VwcGVyQ2FzZSgpID09IGNhbmQpXG5cdFx0XHRzdWl0SW5kZXggPSBpO1xuXHR9XG5cblx0aWYgKHN1aXRJbmRleCA8IDApXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiTm90IGEgdmFsaWQgY2FyZCBzdHJpbmc6IFwiICsgcyk7XG5cblx0cmV0dXJuIG5ldyBDYXJkRGF0YShzdWl0SW5kZXggKiAxMyArIGNhcmRWYWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FyZERhdGE7IiwiLyoqXG4gKiBQcm90b2NvbC5cbiAqIEBtb2R1bGUgcHJvdG9cbiAqL1xuXG4vKipcbiAqIFJlY2VpdmVkIHdoZW4gcGxheWVyIG1hZGUgYW4gYWN0aW9uLlxuICogQGNsYXNzIEFjdGlvbk1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gQWN0aW9uTWVzc2FnZShzZWF0SW5kZXgsIGFjdGlvbikge1xuXHR0aGlzLnNlYXRJbmRleCA9IHNlYXRJbmRleDtcblx0dGhpcy5hY3Rpb24gPSBhY3Rpb247XG59XG5cbkFjdGlvbk1lc3NhZ2UuVFlQRSA9IFwiYWN0aW9uXCI7XG5cbkFjdGlvbk1lc3NhZ2UuRk9MRCA9IFwiZm9sZFwiO1xuQWN0aW9uTWVzc2FnZS5DQUxMID0gXCJjYWxsXCI7XG5BY3Rpb25NZXNzYWdlLlJBSVNFID0gXCJyYWlzZVwiO1xuQWN0aW9uTWVzc2FnZS5DSEVDSyA9IFwiY2hlY2tcIjtcbkFjdGlvbk1lc3NhZ2UuQkVUID0gXCJiZXRcIjtcbkFjdGlvbk1lc3NhZ2UuTVVDSyA9IFwibXVja1wiO1xuQWN0aW9uTWVzc2FnZS5BTlRFID0gXCJhbnRlXCI7XG5cbi8qKlxuICogU2VhdCBpbmRleC5cbiAqIEBtZXRob2QgZ2V0U2VhdEluZGV4XG4gKi9cbkFjdGlvbk1lc3NhZ2UucHJvdG90eXBlLmdldFNlYXRJbmRleCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5zZWF0SW5kZXg7XG59XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRBY3Rpb25cbiAqL1xuQWN0aW9uTWVzc2FnZS5wcm90b3R5cGUuZ2V0QWN0aW9uID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmFjdGlvbjtcbn1cblxuLyoqXG4gKiBVbi1zZXJpYWxpemUuXG4gKiBAbWV0aG9kIHVuc2VyaWFsaXplXG4gKi9cbkFjdGlvbk1lc3NhZ2UucHJvdG90eXBlLnVuc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge1xuXHR0aGlzLnNlYXRJbmRleCA9IGRhdGEuc2VhdEluZGV4O1xuXHR0aGlzLmFjdGlvbiA9IGRhdGEuYWN0aW9uO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZXJpYWxpemVcbiAqL1xuQWN0aW9uTWVzc2FnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB7XG5cdFx0c2VhdEluZGV4OiB0aGlzLnNlYXRJbmRleCxcblx0XHRhY3Rpb246IHRoaXMuYWN0aW9uXG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWN0aW9uTWVzc2FnZTsiLCIvKipcbiAqIFByb3RvY29sLlxuICogQG1vZHVsZSBwcm90b1xuICovXG5cbi8qKlxuICogUmVjZWl2ZWQgd2hlbiBwbGF5ZXIgaGFzIHBsYWNlZCBhIGJldC5cbiAqIEBjbGFzcyBCZXRNZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIEJldE1lc3NhZ2Uoc2VhdEluZGV4LCB2YWx1ZSkge1xuXHR0aGlzLnNlYXRJbmRleCA9IHNlYXRJbmRleDtcblx0dGhpcy52YWx1ZSA9IHZhbHVlO1xufVxuXG5CZXRNZXNzYWdlLlRZUEUgPSBcImJldFwiO1xuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0U2VhdEluZGV4XG4gKi9cbkJldE1lc3NhZ2UucHJvdG90eXBlLmdldFNlYXRJbmRleCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5zZWF0SW5kZXg7XG59XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRWYWx1ZVxuICovXG5CZXRNZXNzYWdlLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy52YWx1ZTtcbn1cblxuLyoqXG4gKiBVbi1zZXJpYWxpemUuXG4gKiBAbWV0aG9kIHVuc2VyaWFsaXplXG4gKi9cbkJldE1lc3NhZ2UucHJvdG90eXBlLnVuc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge1xuXHR0aGlzLnNlYXRJbmRleCA9IGRhdGEuc2VhdEluZGV4O1xuXHR0aGlzLnZhbHVlID0gZGF0YS52YWx1ZTtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgbWVzc2FnZS5cbiAqIEBtZXRob2Qgc2VyaWFsaXplXG4gKi9cbkJldE1lc3NhZ2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4ge1xuXHRcdHNlYXRJbmRleDogdGhpcy5zZWF0SW5kZXgsXG5cdFx0dmFsdWU6IHRoaXMudmFsdWVcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCZXRNZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxuLyoqXG4gKiBSZWNlaXZlZCB3aGVuIGJldHMgc2hvdWxkIGJlIHBsYWNlZCBpbiBwb3QuXG4gKiBAY2xhc3MgQmV0c1RvUG90TWVzc2FnZVxuICovXG5mdW5jdGlvbiBCZXRzVG9Qb3RNZXNzYWdlKCkge1xufVxuXG5CZXRzVG9Qb3RNZXNzYWdlLlRZUEUgPSBcImJldHNUb1BvdFwiO1xuXG4vKipcbiAqIFVuLXNlcmlhbGl6ZS5cbiAqIEBtZXRob2QgdW5zZXJpYWxpemVcbiAqL1xuQmV0c1RvUG90TWVzc2FnZS5wcm90b3R5cGUudW5zZXJpYWxpemUgPSBmdW5jdGlvbihkYXRhKSB7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIHNlcmlhbGl6ZVxuICovXG5CZXRzVG9Qb3RNZXNzYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJldHNUb1BvdE1lc3NhZ2U7IiwiLyoqXG4gKiBQcm90b2NvbC5cbiAqIEBtb2R1bGUgcHJvdG9cbiAqL1xuXG4vKipcbiAqIFNlbnQgd2hlbiB0aGUgdXNlciBjbGlja3MgYSBidXR0b24sIGVpdGhlciBpbiBhIGRpYWxvZyBvclxuICogZm9yIGEgZ2FtZSBhY3Rpb24uXG4gKiBAY2xhc3MgQnV0dG9uQ2xpY2tNZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIEJ1dHRvbkNsaWNrTWVzc2FnZShidXR0b24sIHZhbHVlKSB7XG5cdHRoaXMuYnV0dG9uID0gYnV0dG9uO1xuXHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cbi8vXHRjb25zb2xlLmxvZyhcIkNyZWF0aW5nIGJ1dHRvbiBjbGljayBtZXNzYWdlLCB2YWx1ZT1cIiArIHZhbHVlKTtcbn1cblxuQnV0dG9uQ2xpY2tNZXNzYWdlLlRZUEUgPSBcImJ1dHRvbkNsaWNrXCI7XG5cbi8qKlxuICogVGhlIHRoZSBidXR0b24gdGhhdCB3YXMgcHJlc3NlZC5cbiAqIEBtZXRob2QgZ2V0QnV0dG9uXG4gKi9cbkJ1dHRvbkNsaWNrTWVzc2FnZS5wcm90b3R5cGUuZ2V0QnV0dG9uID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmJ1dHRvbjtcbn1cblxuLyoqXG4gKiBTZXR0ZXIuXG4gKiBAbWV0aG9kIGdldFZhbHVlXG4gKi9cbkJ1dHRvbkNsaWNrTWVzc2FnZS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMudmFsdWU7XG59XG5cbi8qKlxuICogVW4tc2VyaWFsaXplLlxuICogQG1ldGhvZCB1bnNlcmlhbGl6ZVxuICovXG5CdXR0b25DbGlja01lc3NhZ2UucHJvdG90eXBlLnVuc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge1xuXHR0aGlzLmJ1dHRvbiA9IGRhdGEuYnV0dG9uO1xuXHR0aGlzLnZhbHVlID0gZGF0YS52YWx1ZTtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgbWVzc2FnZS5cbiAqIEBtZXRob2Qgc2VyaWFsaXplXG4gKi9cbkJ1dHRvbkNsaWNrTWVzc2FnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB7XG5cdFx0YnV0dG9uOiB0aGlzLmJ1dHRvbixcblx0XHR2YWx1ZTogdGhpcy52YWx1ZVxuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1dHRvbkNsaWNrTWVzc2FnZTsiLCIvKipcbiAqIFByb3RvY29sLlxuICogQG1vZHVsZSBwcm90b1xuICovXG5cbnZhciBCdXR0b25EYXRhID0gcmVxdWlyZShcIi4uL2RhdGEvQnV0dG9uRGF0YVwiKTtcblxuLyoqXG4gKiBNZXNzYWdlIHNlbnQgd2hlbiB0aGUgY2xpZW50IHNob3VsZCBzaG93IGdhbWUgYWN0aW9uIGJ1dHRvbnMsXG4gKiBGT0xELCBSQUlTRSBldGMuXG4gKiBAY2xhc3MgQnV0dG9uc01lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gQnV0dG9uc01lc3NhZ2UoKSB7XG5cdHRoaXMuYnV0dG9ucyA9IFtdO1xuXHR0aGlzLnNsaWRlckJ1dHRvbkluZGV4ID0gMDtcblx0dGhpcy5taW4gPSAtMTtcblx0dGhpcy5tYXggPSAtMTtcbn1cblxuQnV0dG9uc01lc3NhZ2UuVFlQRSA9IFwiYnV0dG9uc1wiO1xuXG4vKipcbiAqIEdldCBhbiBhcnJheSBvZiBCdXR0b25EYXRhIGluZGljYXRpbmcgd2hpY2ggYnV0dG9ucyB0byBzaG93LlxuICogQG1ldGhvZCBnZXRCdXR0b25zXG4gKi9cbkJ1dHRvbnNNZXNzYWdlLnByb3RvdHlwZS5nZXRCdXR0b25zID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmJ1dHRvbnM7XG59XG5cbi8qKlxuICogQWRkIGEgYnV0dG9uIHRvIGJlIHNlbnQuXG4gKiBAbWV0aG9kIGFkZEJ1dHRvblxuICovXG5CdXR0b25zTWVzc2FnZS5wcm90b3R5cGUuYWRkQnV0dG9uID0gZnVuY3Rpb24oYnV0dG9uKSB7XG5cdHRoaXMuYnV0dG9ucy5wdXNoKGJ1dHRvbik7XG59XG5cbi8qKlxuICogVW4tc2VyaWFsaXplLlxuICogQG1ldGhvZCB1bnNlcmlhbGl6ZS5cbiAqL1xuQnV0dG9uc01lc3NhZ2UucHJvdG90eXBlLnVuc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge1xuXHR0aGlzLmJ1dHRvbnMgPSBbXTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuYnV0dG9ucy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBidXR0b24gPSBkYXRhLmJ1dHRvbnNbaV07XG5cdFx0dmFyIGJ1dHRvbkRhdGEgPSBuZXcgQnV0dG9uRGF0YShidXR0b24uYnV0dG9uLCBidXR0b24udmFsdWUpO1xuXHRcdHRoaXMuYWRkQnV0dG9uKGJ1dHRvbkRhdGEpO1xuXHR9XG5cdHRoaXMuc2xpZGVyQnV0dG9uSW5kZXggPSBkYXRhLnNsaWRlckJ1dHRvbkluZGV4O1xuXHR0aGlzLm1pbiA9IGRhdGEubWluO1xuXHR0aGlzLm1heCA9IGRhdGEubWF4O1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZXJpYWxpemVcbiAqL1xuQnV0dG9uc01lc3NhZ2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgYnV0dG9ucyA9IFtdO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5idXR0b25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGJ1dHRvbiA9IHt9O1xuXHRcdGJ1dHRvbi5idXR0b24gPSB0aGlzLmJ1dHRvbnNbaV0uZ2V0QnV0dG9uKCk7XG5cdFx0YnV0dG9uLnZhbHVlID0gdGhpcy5idXR0b25zW2ldLmdldFZhbHVlKCk7XG5cdFx0YnV0dG9ucy5wdXNoKGJ1dHRvbik7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGJ1dHRvbnM6IGJ1dHRvbnMsXG5cdFx0c2xpZGVyQnV0dG9uSW5kZXg6IHRoaXMuc2xpZGVyQnV0dG9uSW5kZXgsXG5cdFx0bWluOiB0aGlzLm1pbixcblx0XHRtYXg6IHRoaXMubWF4XG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQnV0dG9uc01lc3NhZ2U7IiwiLyoqXG4gKiBQcm90b2NvbC5cbiAqIEBtb2R1bGUgcHJvdG9cbiAqL1xuXG4vKipcbiAqIFJlY2VpdmVkIHdoZW4gc29tZXRoaW5nIGhhcyBvY2N1cnJlZCBpbiB0aGUgY2hhdC5cbiAqIEBjbGFzcyBDaGF0TWVzc2FnZVxuICovXG5mdW5jdGlvbiBDaGF0TWVzc2FnZSh1c2VyLCB0ZXh0KSB7XG5cdHRoaXMudXNlciA9IHVzZXI7XG5cdHRoaXMudGV4dCA9IHRleHQ7XG59XG5cbkNoYXRNZXNzYWdlLlRZUEUgPSBcImNoYXRcIjtcblxuLyoqXG4gKiBHZXQgdGV4dC5cbiAqIEBtZXRob2QgZ2V0VGV4dFxuICovXG5DaGF0TWVzc2FnZS5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy50ZXh0O1xufVxuXG4vKipcbiAqIEdldCB1c2VyLlxuICogQG1ldGhvZCBnZXRVc2VyXG4gKi9cbkNoYXRNZXNzYWdlLnByb3RvdHlwZS5nZXRVc2VyID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnVzZXI7XG59XG5cbi8qKlxuICogVW4tc2VyaWFsaXplLlxuICogQG1ldGhvZCB1bnNlcmlhbGl6ZVxuICovXG5DaGF0TWVzc2FnZS5wcm90b3R5cGUudW5zZXJpYWxpemUgPSBmdW5jdGlvbihkYXRhKSB7XG5cdHRoaXMudGV4dCA9IGRhdGEudGV4dDtcblx0dGhpcy51c2VyID0gZGF0YS51c2VyO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZXJpYWxpemVcbiAqL1xuQ2hhdE1lc3NhZ2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4ge1xuXHRcdHRleHQ6IHRoaXMudGV4dCxcblx0XHR1c2VyOiB0aGlzLnVzZXJcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDaGF0TWVzc2FnZTsiLCIvKipcbiAqIFByb3RvY29sLlxuICogQG1vZHVsZSBwcm90b1xuICovXG5cbi8qKlxuICogU2VudCB3aGVuIHBsYXllciBoYXMgY2hlY2tlZCBhIGNoZWNrYm94LlxuICogQGNsYXNzIENoZWNrYm94TWVzc2FnZVxuICovXG5mdW5jdGlvbiBDaGVja2JveE1lc3NhZ2UoaWQsIGNoZWNrZWQpIHtcblx0dGhpcy5pZCA9IGlkO1xuXHR0aGlzLmNoZWNrZWQgPSBjaGVja2VkO1xufVxuXG5DaGVja2JveE1lc3NhZ2UuVFlQRSA9IFwiY2hlY2tib3hcIjtcblxuQ2hlY2tib3hNZXNzYWdlLkFVVE9fUE9TVF9CTElORFMgPSBcImF1dG9Qb3N0QmxpbmRzXCI7XG5DaGVja2JveE1lc3NhZ2UuQVVUT19NVUNLX0xPU0lORyA9IFwiYXV0b011Y2tMb3NpbmdcIjtcbkNoZWNrYm94TWVzc2FnZS5TSVRPVVRfTkVYVCA9IFwic2l0b3V0TmV4dFwiO1xuXG4vKipcbiAqIElkIG9mIGNoZWNrYm94LlxuICogQG1ldGhvZCBnZXRJZFxuICovXG5DaGVja2JveE1lc3NhZ2UucHJvdG90eXBlLmdldElkID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmlkO1xufVxuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0VmFsdWVcbiAqL1xuQ2hlY2tib3hNZXNzYWdlLnByb3RvdHlwZS5nZXRDaGVja2VkID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmNoZWNrZWQ7XG59XG5cbi8qKlxuICogVW4tc2VyaWFsaXplLlxuICogQG1ldGhvZCB1bnNlcmlhbGl6ZVxuICovXG5DaGVja2JveE1lc3NhZ2UucHJvdG90eXBlLnVuc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge1xuXHR0aGlzLmlkID0gZGF0YS5pZDtcblx0dGhpcy5jaGVja2VkID0gZGF0YS5jaGVja2VkO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZXJpYWxpemVcbiAqL1xuQ2hlY2tib3hNZXNzYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHtcblx0XHRpZDogdGhpcy5pZCxcblx0XHRjaGVja2VkOiB0aGlzLmNoZWNrZWRcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDaGVja2JveE1lc3NhZ2U7IiwiLyoqXG4gKiBQcm90b2NvbC5cbiAqIEBtb2R1bGUgcHJvdG9cbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBDbGVhck1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gQ2xlYXJNZXNzYWdlKGNvbXBvbmVudHMpIHtcblx0aWYgKCFjb21wb25lbnRzKVxuXHRcdGNvbXBvbmVudHMgPSBbXTtcblxuXHR0aGlzLmNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xufVxuXG5DbGVhck1lc3NhZ2UuVFlQRSA9IFwiY2xlYXJcIjtcblxuQ2xlYXJNZXNzYWdlLkNBUkRTID0gXCJjYXJkc1wiO1xuQ2xlYXJNZXNzYWdlLkJFVFMgPSBcImJldHNcIjtcbkNsZWFyTWVzc2FnZS5QT1QgPSBcInBvdFwiO1xuQ2xlYXJNZXNzYWdlLkNIQVQgPSBcImNoYXRcIjtcblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldENvbXBvbmVudHNcbiAqL1xuQ2xlYXJNZXNzYWdlLnByb3RvdHlwZS5nZXRDb21wb25lbnRzID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmNvbXBvbmVudHM7XG59XG5cbi8qKlxuICogVW4tc2VyaWFsaXplLlxuICogQG1ldGhvZCB1bnNlcmlhbGl6ZVxuICovXG5DbGVhck1lc3NhZ2UucHJvdG90eXBlLnVuc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge1xuXHR0aGlzLmNvbXBvbmVudHMgPSBkYXRhLmNvbXBvbmVudHM7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIHNlcmlhbGl6ZVxuICovXG5DbGVhck1lc3NhZ2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4ge1xuXHRcdGNvbXBvbmVudHM6IHRoaXMuY29tcG9uZW50c1xuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENsZWFyTWVzc2FnZTsiLCIvKipcbiAqIFByb3RvY29sLlxuICogQG1vZHVsZSBwcm90b1xuICovXG5cbnZhciBDYXJkRGF0YSA9IHJlcXVpcmUoXCIuLi9kYXRhL0NhcmREYXRhXCIpO1xuXG4vKipcbiAqIFNob3cgY29tbXVuaXR5IGNhcmRzLlxuICogQGNsYXNzIENvbW11bml0eUNhcmRzTWVzc2FnZVxuICovXG5mdW5jdGlvbiBDb21tdW5pdHlDYXJkc01lc3NhZ2UoY2FyZHMpIHtcblx0aWYgKCFjYXJkcylcblx0XHRjYXJkcyA9IFtdO1xuXG5cdHRoaXMuYW5pbWF0ZSA9IGZhbHNlO1xuXHR0aGlzLmNhcmRzID0gY2FyZHM7XG5cdHRoaXMuZmlyc3RJbmRleCA9IDA7XG59XG5cbkNvbW11bml0eUNhcmRzTWVzc2FnZS5UWVBFID0gXCJjb21tdW5pdHlDYXJkc1wiO1xuXG4vKipcbiAqIEFuaW1hdGlvbiBvciBub3Q/XG4gKiBAbWV0aG9kIHNldEFuaW1hdGVcbiAqL1xuQ29tbXVuaXR5Q2FyZHNNZXNzYWdlLnByb3RvdHlwZS5zZXRBbmltYXRlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0cmV0dXJuIHRoaXMuYW5pbWF0ZSA9IHZhbHVlO1xufVxuXG4vKipcbiAqIFNldCBmaXJzdCBpbmRleC5cbiAqIEBtZXRob2Qgc2V0Rmlyc3RJbmRleFxuICovXG5Db21tdW5pdHlDYXJkc01lc3NhZ2UucHJvdG90eXBlLnNldEZpcnN0SW5kZXggPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRyZXR1cm4gdGhpcy5maXJzdEluZGV4ID0gdmFsdWU7XG59XG5cbi8qKlxuICogQWRkIGNhcmQuXG4gKiBAbWV0aG9kIGFkZENhcmRcbiAqL1xuQ29tbXVuaXR5Q2FyZHNNZXNzYWdlLnByb3RvdHlwZS5hZGRDYXJkID0gZnVuY3Rpb24oYykge1xuXHR0aGlzLmNhcmRzLnB1c2goYyk7XG59XG5cbi8qKlxuICogR2V0IGNhcmQgZGF0YS5cbiAqIEBtZXRob2QgZ2V0Q2FyZHNcbiAqL1xuQ29tbXVuaXR5Q2FyZHNNZXNzYWdlLnByb3RvdHlwZS5nZXRDYXJkcyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5jYXJkcztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjYXJkIHRvIGJlIHNob3duIGluIHRoZSBzZXF1ZW5jZS5cbiAqIEBtZXRob2QgZ2V0Rmlyc3RJbmRleFxuICovXG5Db21tdW5pdHlDYXJkc01lc3NhZ2UucHJvdG90eXBlLmdldEZpcnN0SW5kZXggPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuZmlyc3RJbmRleDtcbn1cblxuLyoqXG4gKiBVbi1zZXJpYWxpemUuXG4gKiBAbWV0aG9kIHVuc2VyaWFsaXplLlxuICovXG5Db21tdW5pdHlDYXJkc01lc3NhZ2UucHJvdG90eXBlLnVuc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge1xuXHR2YXIgaTtcblxuXHR0aGlzLmFuaW1hdGUgPSBkYXRhLmFuaW1hdGU7XG5cdHRoaXMuZmlyc3RJbmRleCA9IHBhcnNlSW50KGRhdGEuZmlyc3RJbmRleCk7XG5cdHRoaXMuY2FyZHMgPSBbXTtcblxuXHRmb3IgKGkgPSAwOyBpIDwgZGF0YS5jYXJkcy5sZW5ndGg7IGkrKylcblx0XHR0aGlzLmNhcmRzLnB1c2gobmV3IENhcmREYXRhKGRhdGEuY2FyZHNbaV0pKTtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgbWVzc2FnZS5cbiAqIEBtZXRob2Qgc2VyaWFsaXplXG4gKi9cbkNvbW11bml0eUNhcmRzTWVzc2FnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdHZhciBjYXJkcyA9IFtdO1xuXG5cdGZvciAoaSA9IDA7IGkgPCB0aGlzLmNhcmRzLmxlbmd0aDsgaSsrKVxuXHRcdGNhcmRzLnB1c2godGhpcy5jYXJkc1tpXS5nZXRWYWx1ZSgpKTtcblxuXHRyZXR1cm4ge1xuXHRcdGFuaW1hdGU6IHRoaXMuYW5pbWF0ZSxcblx0XHRmaXJzdEluZGV4OiB0aGlzLmZpcnN0SW5kZXgsXG5cdFx0Y2FyZHM6IGNhcmRzXG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tbXVuaXR5Q2FyZHNNZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgRGVhbGVyQnV0dG9uTWVzc2FnZVxuICovXG5mdW5jdGlvbiBEZWFsZXJCdXR0b25NZXNzYWdlKHNlYXRJbmRleCwgYW5pbWF0ZSkge1xuXHR0aGlzLnNlYXRJbmRleCA9IHNlYXRJbmRleDtcblx0dGhpcy5hbmltYXRlID0gYW5pbWF0ZTtcbn1cblxuRGVhbGVyQnV0dG9uTWVzc2FnZS5UWVBFID0gXCJkZWFsZXJCdXR0b25cIjtcblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldFNlYXRJbmRleFxuICovXG5EZWFsZXJCdXR0b25NZXNzYWdlLnByb3RvdHlwZS5nZXRTZWF0SW5kZXggPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuc2VhdEluZGV4O1xufVxuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0QW5pbWF0ZVxuICovXG5EZWFsZXJCdXR0b25NZXNzYWdlLnByb3RvdHlwZS5nZXRBbmltYXRlID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmFuaW1hdGU7XG59XG5cbi8qKlxuICogVW4tc2VyaWFsaXplLlxuICogQG1ldGhvZCB1bnNlcmlhbGl6ZVxuICovXG5EZWFsZXJCdXR0b25NZXNzYWdlLnByb3RvdHlwZS51bnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0dGhpcy5zZWF0SW5kZXggPSBkYXRhLnNlYXRJbmRleDtcblx0dGhpcy5hbmltYXRlID0gZGF0YS5hbmltYXRlO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZXJpYWxpemVcbiAqL1xuRGVhbGVyQnV0dG9uTWVzc2FnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB7XG5cdFx0c2VhdEluZGV4OiB0aGlzLnNlYXRJbmRleCxcblx0XHRhbmltYXRlOiB0aGlzLmFuaW1hdGVcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEZWFsZXJCdXR0b25NZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgRGVsYXlNZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIERlbGF5TWVzc2FnZShkZWxheSkge1xuXHR0aGlzLmRlbGF5ID0gZGVsYXk7XG59XG5cbkRlbGF5TWVzc2FnZS5UWVBFID0gXCJkZWxheVwiO1xuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0RGVsYXlcbiAqL1xuRGVsYXlNZXNzYWdlLnByb3RvdHlwZS5nZXREZWxheSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5kZWxheTtcbn1cblxuLyoqXG4gKiBVbi1zZXJpYWxpemUuXG4gKiBAbWV0aG9kIHVuc2VyaWFsaXplXG4gKi9cbkRlbGF5TWVzc2FnZS5wcm90b3R5cGUudW5zZXJpYWxpemUgPSBmdW5jdGlvbihkYXRhKSB7XG5cdHRoaXMuZGVsYXkgPSBkYXRhLmRlbGF5O1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZXJpYWxpemVcbiAqL1xuRGVsYXlNZXNzYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHtcblx0XHRkZWxheTogdGhpcy5kZWxheVxuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERlbGF5TWVzc2FnZTsiLCIvKipcbiAqIFByb3RvY29sLlxuICogQG1vZHVsZSBwcm90b1xuICovXG5cbi8qKlxuICogUmVjZWl2ZWQgdGFibGUgc2hvdWxkIGZhZGUuXG4gKiBAY2xhc3MgRmFkZVRhYmxlTWVzc2FnZVxuICovXG5mdW5jdGlvbiBGYWRlVGFibGVNZXNzYWdlKHZpc2libGUsIGRpcmVjdGlvbikge1xuXHR0aGlzLnZpc2libGUgPSB2aXNpYmxlO1xuXHR0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbn1cblxuRmFkZVRhYmxlTWVzc2FnZS5UWVBFID0gXCJmYWRlVGFibGVcIjtcblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldFZpc2libGVcbiAqL1xuRmFkZVRhYmxlTWVzc2FnZS5wcm90b3R5cGUuZ2V0VmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy52aXNpYmxlO1xufVxuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0RGlyZWN0aW9uXG4gKi9cbkZhZGVUYWJsZU1lc3NhZ2UucHJvdG90eXBlLmdldERpcmVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5kaXJlY3Rpb247XG59XG5cbi8qKlxuICogVW4tc2VyaWFsaXplLlxuICogQG1ldGhvZCB1bnNlcmlhbGl6ZVxuICovXG5GYWRlVGFibGVNZXNzYWdlLnByb3RvdHlwZS51bnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0dGhpcy52aXNpYmxlID0gZGF0YS52aXNpYmxlO1xuXHR0aGlzLmRpcmVjdGlvbiA9IGRhdGEuZGlyZWN0aW9uO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZXJpYWxpemVcbiAqL1xuRmFkZVRhYmxlTWVzc2FnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB7XG5cdFx0dmlzaWJsZTogdGhpcy52aXNpYmxlLFxuXHRcdGRpcmVjdGlvbjogdGhpcy5kaXJlY3Rpb25cblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGYWRlVGFibGVNZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxuLyoqXG4gKiBSZWNlaXZlZCBwbGF5ZXIgaGFzIGZvbGRlZC5cbiAqIEBjbGFzcyBGb2xkQ2FyZHNNZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIEZvbGRDYXJkc01lc3NhZ2Uoc2VhdEluZGV4KSB7XG5cdHRoaXMuc2VhdEluZGV4ID0gc2VhdEluZGV4O1xufVxuXG5Gb2xkQ2FyZHNNZXNzYWdlLlRZUEUgPSBcImZvbGRDYXJkc1wiO1xuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0U2VhdEluZGV4XG4gKi9cbkZvbGRDYXJkc01lc3NhZ2UucHJvdG90eXBlLmdldFNlYXRJbmRleCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5zZWF0SW5kZXg7XG59XG5cbi8qKlxuICogVW4tc2VyaWFsaXplLlxuICogQG1ldGhvZCB1bnNlcmlhbGl6ZVxuICovXG5Gb2xkQ2FyZHNNZXNzYWdlLnByb3RvdHlwZS51bnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0dGhpcy5zZWF0SW5kZXggPSBkYXRhLnNlYXRJbmRleDtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgbWVzc2FnZS5cbiAqIEBtZXRob2Qgc2VyaWFsaXplXG4gKi9cbkZvbGRDYXJkc01lc3NhZ2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4ge1xuXHRcdHNlYXRJbmRleDogdGhpcy5zZWF0SW5kZXhcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGb2xkQ2FyZHNNZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxuLyoqXG4gKiBSZWNlaXZlZCB3aGVuID8uXG4gKiBAY2xhc3MgSGFuZEluZm9NZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIEhhbmRJbmZvTWVzc2FnZSh0ZXh0LCBjb3VudGRvd24pIHtcblx0dGhpcy50ZXh0ID0gdGV4dDtcblx0dGhpcy5jb3VudGRvd24gPSBjb3VudGRvd247XG59XG5cbkhhbmRJbmZvTWVzc2FnZS5UWVBFID0gXCJoYW5kSW5mb1wiO1xuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0U2VhdEluZGV4XG4gKi9cbkhhbmRJbmZvTWVzc2FnZS5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy50ZXh0O1xufVxuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0VmFsdWVcbiAqL1xuSGFuZEluZm9NZXNzYWdlLnByb3RvdHlwZS5nZXRDb3VudGRvd24gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuY291bnRkb3duO1xufVxuXG4vKipcbiAqIFVuLXNlcmlhbGl6ZS5cbiAqIEBtZXRob2QgdW5zZXJpYWxpemVcbiAqL1xuSGFuZEluZm9NZXNzYWdlLnByb3RvdHlwZS51bnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0dGhpcy50ZXh0ID0gZGF0YS50ZXh0O1xuXHR0aGlzLmNvdW50ZG93biA9IGRhdGEuY291bnRkb3duO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZXJpYWxpemVcbiAqL1xuSGFuZEluZm9NZXNzYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHtcblx0XHR0ZXh0OiB0aGlzLnRleHQsXG5cdFx0Y291bnRkb3duOiB0aGlzLmNvdW50ZG93blxuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRJbmZvTWVzc2FnZTsiLCIvKipcbiAqIFByb3RvY29sLlxuICogQG1vZHVsZSBwcm90b1xuICovXG5cbi8qKlxuICogQGNsYXNzIEluaXRNZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIEluaXRNZXNzYWdlKHRva2VuKSB7XG5cdHRoaXMudG9rZW4gPSB0b2tlbjtcblx0dGhpcy50YWJsZUlkID0gbnVsbDtcblx0dGhpcy52aWV3Q2FzZSA9IG51bGw7XG5cdHRoaXMudG91cm5hbWVudElkID0gbnVsbDtcbn1cblxuSW5pdE1lc3NhZ2UuVFlQRSA9IFwiaW5pdFwiO1xuXG4vKipcbiAqIGdldCB0b2tlbi5cbiAqIEBtZXRob2QgZ2V0VG9rZW5cbiAqL1xuSW5pdE1lc3NhZ2UucHJvdG90eXBlLmdldFRva2VuID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnRva2VuO1xufVxuXG4vKipcbiAqIFNldCB0YWJsZSBpZC5cbiAqIEBtZXRob2Qgc2V0VGFibGVJZFxuICovXG5Jbml0TWVzc2FnZS5wcm90b3R5cGUuc2V0VGFibGVJZCA9IGZ1bmN0aW9uKGlkKSB7XG5cdHRoaXMudGFibGVJZCA9IGlkO1xufVxuXG4vKipcbiAqIEdldCB0YWJsZSBpZC5cbiAqIEBtZXRob2QgZ2V0VGFibGVJZFxuICovXG5Jbml0TWVzc2FnZS5wcm90b3R5cGUuZ2V0VGFibGVJZCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy50YWJsZUlkO1xufVxuXG4vKipcbiAqIFNldCB0YWJsZSBpZC5cbiAqIEBtZXRob2Qgc2V0VG91cm5hbWVudElkXG4gKi9cbkluaXRNZXNzYWdlLnByb3RvdHlwZS5zZXRUb3VybmFtZW50SWQgPSBmdW5jdGlvbihpZCkge1xuXHR0aGlzLnRvdXJuYW1lbnRJZCA9IGlkO1xufVxuXG4vKipcbiAqIEdldCB0YWJsZSBpZC5cbiAqIEBtZXRob2QgZ2V0VG91cm5hbWVudElkXG4gKi9cbkluaXRNZXNzYWdlLnByb3RvdHlwZS5nZXRUb3VybmFtZW50SWQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMudG91cm5hbWVudElkO1xufVxuXG4vKipcbiAqIFNldCB2aWV3IGNhc2UuXG4gKiBAbWV0aG9kIHNldFRhYmxlSWRcbiAqL1xuSW5pdE1lc3NhZ2UucHJvdG90eXBlLnNldFZpZXdDYXNlID0gZnVuY3Rpb24odmlld0Nhc2UpIHtcblx0dGhpcy52aWV3Q2FzZSA9IHZpZXdDYXNlO1xufVxuXG4vKipcbiAqIEdldCB2aWV3IGNhc2UuXG4gKiBAbWV0aG9kIGdldFRhYmxlSWRcbiAqL1xuSW5pdE1lc3NhZ2UucHJvdG90eXBlLmdldFZpZXdDYXNlID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnZpZXdDYXNlO1xufVxuXG4vKipcbiAqIFVuLXNlcmlhbGl6ZS5cbiAqIEBtZXRob2QgdW5zZXJpYWxpemUuXG4gKi9cbkluaXRNZXNzYWdlLnByb3RvdHlwZS51bnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0dGhpcy50b2tlbiA9IGRhdGEudG9rZW47XG5cdHRoaXMudGFibGVJZCA9IGRhdGEudGFibGVJZDtcblx0dGhpcy52aWV3Q2FzZSA9IGRhdGEudmlld0Nhc2U7XG5cdHRoaXMudG91cm5hbWVudElkID0gZGF0YS50b3VybmFtZW50SWQ7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIHNlcmlhbGl6ZVxuICovXG5Jbml0TWVzc2FnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB7XG5cdFx0dG9rZW46IHRoaXMudG9rZW4sXG5cdFx0dGFibGVJZDogdGhpcy50YWJsZUlkLFxuXHRcdHZpZXdDYXNlOiB0aGlzLnZpZXdDYXNlLFxuXHRcdHRvdXJuYW1lbnRJZDogdGhpcy50b3VybmFtZW50SWRcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJbml0TWVzc2FnZTsiLCIvKipcbiAqIFByb3RvY29sLlxuICogQG1vZHVsZSBwcm90b1xuICovXG5cbi8qKlxuICogUmVjZWl2ZWQgd2hlbiBpbnRlcmZhY2Ugc3RhdGUgaGFzIGNoYW5nZWQuXG4gKiBAY2xhc3MgSW50ZXJmYWNlU3RhdGVNZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIEludGVyZmFjZVN0YXRlTWVzc2FnZSh2aXNpYmxlQnV0dG9ucykge1xuXHRpZiAoIXZpc2libGVCdXR0b25zKVxuXHRcdHZpc2libGVCdXR0b25zID0gW107XG5cblx0dGhpcy52aXNpYmxlQnV0dG9ucyA9IHZpc2libGVCdXR0b25zO1xufVxuXG5JbnRlcmZhY2VTdGF0ZU1lc3NhZ2UuVFlQRSA9IFwiaW50ZXJmYWNlU3RhdGVcIjtcblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldFZpc2libGVCdXR0b25zXG4gKi9cbkludGVyZmFjZVN0YXRlTWVzc2FnZS5wcm90b3R5cGUuZ2V0VmlzaWJsZUJ1dHRvbnMgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMudmlzaWJsZUJ1dHRvbnM7XG59XG5cbi8qKlxuICogQWRkIGEgYnV0dG9uIHRvIGJlIHNob3duLlxuICogQG1ldGhvZCBhZGRWaXNpYmxlQnV0dG9uXG4gKi9cbkludGVyZmFjZVN0YXRlTWVzc2FnZS5wcm90b3R5cGUuYWRkVmlzaWJsZUJ1dHRvbj1mdW5jdGlvbihidXR0b25JZCkge1xuXHR0aGlzLnZpc2libGVCdXR0b25zLnB1c2goYnV0dG9uSWQpO1xufVxuXG4vKipcbiAqIFVuLXNlcmlhbGl6ZS5cbiAqIEBtZXRob2QgdW5zZXJpYWxpemVcbiAqL1xuSW50ZXJmYWNlU3RhdGVNZXNzYWdlLnByb3RvdHlwZS51bnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0dGhpcy52aXNpYmxlQnV0dG9ucyA9IGRhdGEudmlzaWJsZUJ1dHRvbnM7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIHNlcmlhbGl6ZVxuICovXG5JbnRlcmZhY2VTdGF0ZU1lc3NhZ2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4ge1xuXHRcdHZpc2libGVCdXR0b25zOiB0aGlzLnZpc2libGVCdXR0b25zXG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJmYWNlU3RhdGVNZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxuLyoqXG4gKiBSZWNlaXZlZCB3aGVuIHBsYXllciBoYXMgcGxhY2VkIGEgYmV0LlxuICogQGNsYXNzIFBheU91dE1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gUGF5T3V0TWVzc2FnZSgpIHtcblx0dGhpcy52YWx1ZXMgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG59XG5cblBheU91dE1lc3NhZ2UuVFlQRSA9IFwicGF5T3V0XCI7XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRWYWx1ZXNcbiAqL1xuUGF5T3V0TWVzc2FnZS5wcm90b3R5cGUuZ2V0VmFsdWVzID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnZhbHVlcztcbn1cblxuLyoqXG4gKiBTZXQgdmFsdWUgYXQuXG4gKiBAbWV0aG9kIHNldFZhbHVlQXRcbiAqL1xuUGF5T3V0TWVzc2FnZS5wcm90b3R5cGUuc2V0VmFsdWVBdCA9IGZ1bmN0aW9uKHNlYXRJbmRleCwgdmFsdWUpIHtcblx0dGhpcy52YWx1ZXNbc2VhdEluZGV4XSA9IHZhbHVlO1xufVxuXG4vKipcbiAqIFVuLXNlcmlhbGl6ZS5cbiAqIEBtZXRob2QgdW5zZXJpYWxpemVcbiAqL1xuUGF5T3V0TWVzc2FnZS5wcm90b3R5cGUudW5zZXJpYWxpemUgPSBmdW5jdGlvbihkYXRhKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS52YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0XHR0aGlzLnZhbHVlc1tpXSA9IGRhdGEudmFsdWVzW2ldO1xuXHR9XG59XG5cbi8qKlxuICogU2VyaWFsaXplIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIHNlcmlhbGl6ZVxuICovXG5QYXlPdXRNZXNzYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHtcblx0XHR2YWx1ZXM6IHRoaXMudmFsdWVzXG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGF5T3V0TWVzc2FnZTsiLCIvKipcbiAqIFByb3RvY29sLlxuICogQG1vZHVsZSBwcm90b1xuICovXG5cbnZhciBDYXJkRGF0YSA9IHJlcXVpcmUoXCIuLi9kYXRhL0NhcmREYXRhXCIpO1xuXG4vKipcbiAqIFNob3cgcG9ja2V0IGNhcmRzLlxuICogQGNsYXNzIFBvY2tldENhcmRzTWVzc2FnZVxuICovXG5mdW5jdGlvbiBQb2NrZXRDYXJkc01lc3NhZ2Uoc2VhdEluZGV4KSB7XG5cdHRoaXMuYW5pbWF0ZSA9IGZhbHNlO1xuXHR0aGlzLmNhcmRzID0gW107XG5cdHRoaXMuZmlyc3RJbmRleCA9IDA7XG5cdHRoaXMuc2VhdEluZGV4ID0gc2VhdEluZGV4O1xufVxuXG5Qb2NrZXRDYXJkc01lc3NhZ2UuVFlQRSA9IFwicG9ja2V0Q2FyZHNcIjtcblxuLyoqXG4gKiBBbmltYXRpb24/XG4gKiBAbWV0aG9kIHNldEFuaW1hdGVcbiAqL1xuUG9ja2V0Q2FyZHNNZXNzYWdlLnByb3RvdHlwZS5zZXRBbmltYXRlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0dGhpcy5hbmltYXRlID0gdmFsdWU7XG59XG5cbi8qKlxuICogU2V0IGZpcnN0IGluZGV4LlxuICogQG1ldGhvZCBzZXRGaXJzdEluZGV4XG4gKi9cblBvY2tldENhcmRzTWVzc2FnZS5wcm90b3R5cGUuc2V0Rmlyc3RJbmRleCA9IGZ1bmN0aW9uKGluZGV4KSB7XG5cdHRoaXMuZmlyc3RJbmRleCA9IGluZGV4O1xufVxuXG4vKipcbiAqIEdldCBhcnJheSBvZiBDYXJkRGF0YS5cbiAqIEBtZXRob2QgZ2V0Q2FyZHNcbiAqL1xuUG9ja2V0Q2FyZHNNZXNzYWdlLnByb3RvdHlwZS5nZXRDYXJkcyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5jYXJkcztcbn1cblxuLyoqXG4gKiBBZGQgYSBjYXJkLlxuICogQG1ldGhvZCBhZGRDYXJkXG4gKi9cblBvY2tldENhcmRzTWVzc2FnZS5wcm90b3R5cGUuYWRkQ2FyZCA9IGZ1bmN0aW9uKGMpIHtcblx0dGhpcy5jYXJkcy5wdXNoKGMpO1xufVxuXG4vKipcbiAqIEdldCBmaXJzdCBpbmRleC5cbiAqIEBtZXRob2QgZ2V0Rmlyc3RJbmRleFxuICovXG5Qb2NrZXRDYXJkc01lc3NhZ2UucHJvdG90eXBlLmdldEZpcnN0SW5kZXggPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuZmlyc3RJbmRleDtcbn1cblxuLyoqXG4gKiBHZXQgc2VhdCBpbmRleC5cbiAqIEBtZXRob2QgZ2V0U2VhdEluZGV4XG4gKi9cblBvY2tldENhcmRzTWVzc2FnZS5wcm90b3R5cGUuZ2V0U2VhdEluZGV4ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnNlYXRJbmRleDtcbn1cblxuLyoqXG4gKiBVbi1zZXJpYWxpemUuXG4gKiBAbWV0aG9kIHVuc2VyaWFsaXplLlxuICovXG5Qb2NrZXRDYXJkc01lc3NhZ2UucHJvdG90eXBlLnVuc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge1xuXHR2YXIgaTtcblxuXHR0aGlzLmFuaW1hdGUgPSBkYXRhLmFuaW1hdGU7XG5cdHRoaXMuZmlyc3RJbmRleCA9IHBhcnNlSW50KGRhdGEuZmlyc3RJbmRleCk7XG5cdHRoaXMuY2FyZHMgPSBbXTtcblx0dGhpcy5zZWF0SW5kZXggPSBkYXRhLnNlYXRJbmRleDtcblxuXHRmb3IgKGkgPSAwOyBpIDwgZGF0YS5jYXJkcy5sZW5ndGg7IGkrKylcblx0XHR0aGlzLmNhcmRzLnB1c2gobmV3IENhcmREYXRhKGRhdGEuY2FyZHNbaV0pKTtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgbWVzc2FnZS5cbiAqIEBtZXRob2Qgc2VyaWFsaXplXG4gKi9cblBvY2tldENhcmRzTWVzc2FnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdHZhciBjYXJkcyA9IFtdO1xuXG5cdGZvciAoaSA9IDA7IGkgPCB0aGlzLmNhcmRzLmxlbmd0aDsgaSsrKVxuXHRcdGNhcmRzLnB1c2godGhpcy5jYXJkc1tpXS5nZXRWYWx1ZSgpKTtcblxuXHRyZXR1cm4ge1xuXHRcdGFuaW1hdGU6IHRoaXMuYW5pbWF0ZSxcblx0XHRmaXJzdEluZGV4OiB0aGlzLmZpcnN0SW5kZXgsXG5cdFx0Y2FyZHM6IGNhcmRzLFxuXHRcdHNlYXRJbmRleDogdGhpcy5zZWF0SW5kZXhcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQb2NrZXRDYXJkc01lc3NhZ2U7IiwiLyoqXG4gKiBQcm90b2NvbC5cbiAqIEBtb2R1bGUgcHJvdG9cbiAqL1xuXG4vKipcbiAqIFJlY2VpdmVkIHdoZW4gcGxheWVyIHBvdCBoYXMgY2hhbmdlZC5cbiAqIEBjbGFzcyBQb3RNZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIFBvdE1lc3NhZ2UodmFsdWVzKSB7XG5cdHRoaXMudmFsdWVzID0gdmFsdWVzID09IG51bGwgPyBuZXcgQXJyYXkoKSA6IHZhbHVlcztcbn1cblxuUG90TWVzc2FnZS5UWVBFID0gXCJwb3RcIjtcblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldFZhbHVlc1xuICovXG5Qb3RNZXNzYWdlLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMudmFsdWVzO1xufVxuXG4vKipcbiAqIFVuLXNlcmlhbGl6ZS5cbiAqIEBtZXRob2QgdW5zZXJpYWxpemVcbiAqL1xuUG90TWVzc2FnZS5wcm90b3R5cGUudW5zZXJpYWxpemUgPSBmdW5jdGlvbihkYXRhKSB7XG5cdHRoaXMudmFsdWVzID0gZGF0YS52YWx1ZXM7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIHNlcmlhbGl6ZVxuICovXG5Qb3RNZXNzYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHtcblx0XHR2YWx1ZXM6IHRoaXMudmFsdWVzXG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUG90TWVzc2FnZTsiLCIvKipcbiAqIFByb3RvY29sLlxuICogQG1vZHVsZSBwcm90b1xuICovXG5cbi8qKlxuICogUmVjZWl2ZWQgd2hlbiBQcmUgdG91cm5hbWVudCBpbmZvIG1lc3NhZ2UgaXMgZGlzcGF0Y2hlZC5cbiAqIEBjbGFzcyBQcmVUb3VybmFtZW50SW5mb01lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gUHJlVG91cm5hbWVudEluZm9NZXNzYWdlKHRleHQsIGNvdW50ZG93bikge1xuXHR0aGlzLnRleHQgPSB0ZXh0O1xuXHR0aGlzLmNvdW50ZG93biA9IGNvdW50ZG93bjtcbn1cblxuUHJlVG91cm5hbWVudEluZm9NZXNzYWdlLlRZUEUgPSBcInByZVRvdXJuYW1lbnRJbmZvXCI7XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRUZXh0XG4gKi9cblByZVRvdXJuYW1lbnRJbmZvTWVzc2FnZS5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy50ZXh0O1xufVxuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0Q291bnRkb3duXG4gKi9cblByZVRvdXJuYW1lbnRJbmZvTWVzc2FnZS5wcm90b3R5cGUuZ2V0Q291bnRkb3duID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmNvdW50ZG93bjtcbn1cblxuLyoqXG4gKiBVbi1zZXJpYWxpemUuXG4gKiBAbWV0aG9kIHVuc2VyaWFsaXplXG4gKi9cblByZVRvdXJuYW1lbnRJbmZvTWVzc2FnZS5wcm90b3R5cGUudW5zZXJpYWxpemUgPSBmdW5jdGlvbihkYXRhKSB7XG5cdHRoaXMudGV4dCA9IGRhdGEudGV4dDtcblx0dGhpcy5jb3VudGRvd24gPSBkYXRhLmNvdW50ZG93bjtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgbWVzc2FnZS5cbiAqIEBtZXRob2Qgc2VyaWFsaXplXG4gKi9cblByZVRvdXJuYW1lbnRJbmZvTWVzc2FnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLmNvdW50ZG93biA8IDApXG5cdFx0dGhpcy5jb3VudGRvd24gPSAwO1xuXG5cdHJldHVybiB7XG5cdFx0dGV4dDogdGhpcy50ZXh0LFxuXHRcdGNvdW50ZG93bjogdGhpcy5jb3VudGRvd25cblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQcmVUb3VybmFtZW50SW5mb01lc3NhZ2U7IiwiLyoqXG4gKiBQcm90b2NvbC5cbiAqIEBtb2R1bGUgcHJvdG9cbiAqL1xuXG4vKipcbiAqIFJlY2VpdmVkIHdoZW4gPy5cbiAqIEBjbGFzcyBQcmVzZXRCdXR0b25DbGlja01lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gUHJlc2V0QnV0dG9uQ2xpY2tNZXNzYWdlKGJ1dHRvbiwgdmFsdWUpIHtcblx0aWYgKCF2YWx1ZSlcblx0XHR2YWx1ZSA9IG51bGw7XG5cblx0dGhpcy5idXR0b24gPSBidXR0b247XG5cdHRoaXMudmFsdWUgPSB2YWx1ZTtcbn1cblxuUHJlc2V0QnV0dG9uQ2xpY2tNZXNzYWdlLlRZUEUgPSBcInByZXNldEJ1dHRvbkNsaWNrXCI7XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRCdXR0b25cbiAqL1xuUHJlc2V0QnV0dG9uQ2xpY2tNZXNzYWdlLnByb3RvdHlwZS5nZXRCdXR0b24gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuYnV0dG9uO1xufVxuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0VmFsdWVcbiAqL1xuUHJlc2V0QnV0dG9uQ2xpY2tNZXNzYWdlLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy52YWx1ZTtcbn1cblxuLyoqXG4gKiBVbi1zZXJpYWxpemUuXG4gKiBAbWV0aG9kIHVuc2VyaWFsaXplXG4gKi9cblByZXNldEJ1dHRvbkNsaWNrTWVzc2FnZS5wcm90b3R5cGUudW5zZXJpYWxpemUgPSBmdW5jdGlvbihkYXRhKSB7XG5cdHRoaXMuYnV0dG9uID0gZGF0YS5idXR0b247XG5cdHRoaXMudmFsdWUgPSBkYXRhLnZhbHVlO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZXJpYWxpemVcbiAqL1xuUHJlc2V0QnV0dG9uQ2xpY2tNZXNzYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHtcblx0XHRidXR0b246IHRoaXMuYnV0dG9uLFxuXHRcdHZhbHVlOiB0aGlzLnZhbHVlXG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHJlc2V0QnV0dG9uQ2xpY2tNZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxudmFyIEJ1dHRvbkRhdGEgPSByZXF1aXJlKFwiLi4vZGF0YS9CdXR0b25EYXRhXCIpO1xuXG4vKipcbiAqIFJlY2VpdmVkIHdoZW4gPy5cbiAqIEBjbGFzcyBQcmVzZXRCdXR0b25zTWVzc2FnZVxuICovXG5mdW5jdGlvbiBQcmVzZXRCdXR0b25zTWVzc2FnZSgpIHtcblx0dGhpcy5idXR0b25zID0gbmV3IEFycmF5KDcpO1xuXHR0aGlzLmN1cnJlbnQgPSBudWxsO1xufVxuXG5QcmVzZXRCdXR0b25zTWVzc2FnZS5UWVBFID0gXCJwcmVzZXRCdXR0b25zXCI7XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRCdXR0b25zXG4gKi9cblByZXNldEJ1dHRvbnNNZXNzYWdlLnByb3RvdHlwZS5nZXRCdXR0b25zID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmJ1dHRvbnM7XG59XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRDdXJyZW50XG4gKi9cblByZXNldEJ1dHRvbnNNZXNzYWdlLnByb3RvdHlwZS5nZXRDdXJyZW50ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmN1cnJlbnQ7XG59XG5cbi8qKlxuICogU2V0IGJ1dG9uIGRhdGEuXG4gKiBAbWV0aG9kXG4gKi9cblByZXNldEJ1dHRvbnNNZXNzYWdlLnByb3RvdHlwZS5zZXRCdXR0b25EYXRhQXQgPSBmdW5jdGlvbihpbmRleCwgYnV0dG9uRGF0YSkge1xuXHR0aGlzLmJ1dHRvbnNbaW5kZXhdID0gYnV0dG9uRGF0YTtcbn1cblxuLyoqXG4gKiBVbi1zZXJpYWxpemUuXG4gKiBAbWV0aG9kIHVuc2VyaWFsaXplXG4gKi9cblByZXNldEJ1dHRvbnNNZXNzYWdlLnByb3RvdHlwZS51bnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0dGhpcy5jdXJyZW50ID0gZGF0YS5jdXJyZW50O1xuXG5cdHRoaXMuYnV0dG9ucyA9IG5ldyBBcnJheSgpO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5idXR0b25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGJ1dHRvbiA9IGRhdGEuYnV0dG9uc1tpXTtcblx0XHR2YXIgYnV0dG9uRGF0YSA9IG51bGw7XG5cblx0XHRpZiAoYnV0dG9uICE9IG51bGwpIHtcblx0XHRcdGJ1dHRvbkRhdGEgPSBuZXcgQnV0dG9uRGF0YShidXR0b24uYnV0dG9uLCBidXR0b24udmFsdWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuYnV0dG9ucy5wdXNoKGJ1dHRvbkRhdGEpO1xuXHR9XG59XG5cbi8qKlxuICogU2VyaWFsaXplIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIHNlcmlhbGl6ZVxuICovXG5QcmVzZXRCdXR0b25zTWVzc2FnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvYmplY3QgPSB7XG5cdFx0YnV0dG9uczogW10sXG5cdFx0Y3VycmVudDogdGhpcy5jdXJyZW50XG5cdH07XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJ1dHRvbnMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgYnV0dG9uRGF0YSA9IHRoaXMuYnV0dG9uc1tpXTtcblx0XHRpZiAoYnV0dG9uRGF0YSAhPSBudWxsKVxuXHRcdFx0b2JqZWN0LmJ1dHRvbnMucHVzaCh7XG5cdFx0XHRcdGJ1dHRvbjogYnV0dG9uRGF0YS5idXR0b24sXG5cdFx0XHRcdHZhbHVlOiBidXR0b25EYXRhLnZhbHVlXG5cdFx0XHR9KTtcblxuXHRcdGVsc2Vcblx0XHRcdG9iamVjdC5idXR0b25zLnB1c2gobnVsbCk7XG5cdH1cblxuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByZXNldEJ1dHRvbnNNZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxuLyoqXG4gKiBNZXNzYWdlIGluZGljYXRpbmcgdGhhdCB0aGUgdXNlciBoYXMgY2xpY2tlZCBhIHNlYXQuXG4gKiBAY2xhc3MgU2VhdENsaWNrTWVzc2FnZVxuICovXG5mdW5jdGlvbiBTZWF0Q2xpY2tNZXNzYWdlKHNlYXRJbmRleCkge1xuXHR0aGlzLnNlYXRJbmRleD1zZWF0SW5kZXg7XG59XG5cblNlYXRDbGlja01lc3NhZ2UuVFlQRSA9IFwic2VhdENsaWNrXCI7XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRTZWF0SW5kZXhcbiAqL1xuU2VhdENsaWNrTWVzc2FnZS5wcm90b3R5cGUuZ2V0U2VhdEluZGV4ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnNlYXRJbmRleDtcbn1cblxuLyoqXG4gKiBVbi1zZXJpYWxpemUuXG4gKiBAbWV0aG9kIHVuc2VyaWFsaXplLlxuICovXG5TZWF0Q2xpY2tNZXNzYWdlLnByb3RvdHlwZS51bnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0dGhpcy5zZWF0SW5kZXggPSBkYXRhLnNlYXRJbmRleDtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgbWVzc2FnZS5cbiAqIEBtZXRob2Qgc2VyaWFsaXplXG4gKi9cblNlYXRDbGlja01lc3NhZ2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4ge1xuXHRcdHNlYXRJbmRleDogdGhpcy5zZWF0SW5kZXgsXG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VhdENsaWNrTWVzc2FnZTsiLCIvKipcbiAqIFByb3RvY29sLlxuICogQG1vZHVsZSBwcm90b1xuICovXG5cbi8qKlxuICogU2hvdyB1c2VybmFtZSBhbmQgY2hpcHMgb24gc2VhdC5cbiAqIEBjbGFzcyBTZWF0SW5mb01lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gU2VhdEluZm9NZXNzYWdlKHNlYXRJbmRleCkge1xuXHR0aGlzLnNlYXRJbmRleCA9IHNlYXRJbmRleDtcblx0dGhpcy5hY3RpdmUgPSB0cnVlO1xuXHR0aGlzLnNpdG91dCA9IGZhbHNlO1xuXHR0aGlzLm5hbWUgPSBcIlwiO1xuXHR0aGlzLmNoaXBzID0gXCJcIjtcbn1cblxuU2VhdEluZm9NZXNzYWdlLlRZUEUgPSBcInNlYXRJbmZvXCI7XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRTZWF0SW5kZXhcbiAqL1xuU2VhdEluZm9NZXNzYWdlLnByb3RvdHlwZS5nZXRTZWF0SW5kZXggPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuc2VhdEluZGV4O1xufVxuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0TmFtZVxuICovXG5TZWF0SW5mb01lc3NhZ2UucHJvdG90eXBlLmdldE5hbWUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMubmFtZTtcbn1cblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldENoaXBzXG4gKi9cblNlYXRJbmZvTWVzc2FnZS5wcm90b3R5cGUuZ2V0Q2hpcHMgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuY2hpcHM7XG59XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBpc1NpdG91dFxuICovXG5TZWF0SW5mb01lc3NhZ2UucHJvdG90eXBlLmlzU2l0b3V0ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnNpdG91dDtcbn1cblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGlzQWN0aXZlXG4gKi9cblNlYXRJbmZvTWVzc2FnZS5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuYWN0aXZlO1xufVxuXG4vKipcbiAqIFNldHRlci5cbiAqIEBtZXRob2Qgc2V0QWN0aXZlXG4gKi9cblNlYXRJbmZvTWVzc2FnZS5wcm90b3R5cGUuc2V0QWN0aXZlID0gZnVuY3Rpb24odikge1xuXHR0aGlzLmFjdGl2ZSA9IHY7XG59XG5cbi8qKlxuICogU2V0IHNpdG91dC5cbiAqIEBtZXRob2Qgc2V0U2l0b3V0XG4gKi9cblNlYXRJbmZvTWVzc2FnZS5wcm90b3R5cGUuc2V0U2l0b3V0ID0gZnVuY3Rpb24odikge1xuXHR0aGlzLnNpdG91dCA9IHY7XG59XG5cbi8qKlxuICogU2V0dGVyLlxuICogQG1ldGhvZCBzZXROYW1lXG4gKi9cblNlYXRJbmZvTWVzc2FnZS5wcm90b3R5cGUuc2V0TmFtZSA9IGZ1bmN0aW9uKHYpIHtcblx0dGhpcy5uYW1lID0gdjtcbn1cblxuLyoqXG4gKiBTZXR0ZXIuXG4gKiBAbWV0aG9kIHNldENoaXBzXG4gKi9cblNlYXRJbmZvTWVzc2FnZS5wcm90b3R5cGUuc2V0Q2hpcHMgPSBmdW5jdGlvbih2KSB7XG5cdHRoaXMuY2hpcHMgPSB2O1xufVxuXG4vKipcbiAqIFVuLXNlcmlhbGl6ZS5cbiAqIEBtZXRob2QgdW5zZXJpYWxpemVcbiAqL1xuU2VhdEluZm9NZXNzYWdlLnByb3RvdHlwZS51bnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0dGhpcy5zZWF0SW5kZXggPSBkYXRhLnNlYXRJbmRleDtcblx0dGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuXHR0aGlzLmNoaXBzID0gZGF0YS5jaGlwcztcblx0dGhpcy5zaXRvdXQgPSBkYXRhLnNpdG91dDtcblx0dGhpcy5hY3RpdmUgPSBkYXRhLmFjdGl2ZTtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgbWVzc2FnZS5cbiAqIEBtZXRob2Qgc2VyaWFsaXplXG4gKi9cblNlYXRJbmZvTWVzc2FnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB7XG5cdFx0c2VhdEluZGV4OiB0aGlzLnNlYXRJbmRleCxcblx0XHRuYW1lOiB0aGlzLm5hbWUsXG5cdFx0Y2hpcHM6IHRoaXMuY2hpcHMsXG5cdFx0c2l0b3V0OiB0aGlzLnNpdG91dCxcblx0XHRhY3RpdmU6IHRoaXMuYWN0aXZlXG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VhdEluZm9NZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxuLyoqXG4gKiBTaG93IGRpYWxvZywgZm9yIGUuZy4gYnV5IGluLlxuICogQGNsYXNzIFNob3dEaWFsb2dNZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIFNob3dEaWFsb2dNZXNzYWdlKCkge1xuXHR0aGlzLnRleHQgPSBcIlwiO1xuXHR0aGlzLmJ1dHRvbnMgPSBbXTtcblx0dGhpcy5kZWZhdWx0VmFsdWUgPSBudWxsO1xufVxuXG5TaG93RGlhbG9nTWVzc2FnZS5UWVBFID0gXCJzaG93RGlhbG9nXCI7XG5cbi8qKlxuICogQWRkIGEgYnV0dG9uIHRvIHRoZSBkaWFsb2cuXG4gKiBAbWV0aG9kIGFkZEJ1dHRvblxuICovXG5TaG93RGlhbG9nTWVzc2FnZS5wcm90b3R5cGUuYWRkQnV0dG9uID0gZnVuY3Rpb24oYnV0dG9uKSB7XG5cdHRoaXMuYnV0dG9ucy5wdXNoKGJ1dHRvbik7XG59XG5cbi8qKlxuICogR2V0IHRleHQgb2YgdGhlIGRpYWxvZy5cbiAqIEBtZXRob2QgZ2V0VGV4dFxuICovXG5TaG93RGlhbG9nTWVzc2FnZS5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy50ZXh0O1xufVxuXG4vKipcbiAqIEdldCBhcnJheSBvZiBCdXR0b25EYXRhIHRvIGJlIHNob3duIGluIHRoZSBkaWFsb2cuXG4gKiBAbWV0aG9kIGdldEJ1dHRvbnNcbiAqL1xuU2hvd0RpYWxvZ01lc3NhZ2UucHJvdG90eXBlLmdldEJ1dHRvbnMgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuYnV0dG9ucztcbn1cblxuLyoqXG4gKiBHZXQgZGVmYXVsdCB2YWx1ZS5cbiAqIEBtZXRob2QgZ2V0QnV0dG9uc1xuICovXG5TaG93RGlhbG9nTWVzc2FnZS5wcm90b3R5cGUuZ2V0RGVmYXVsdFZhbHVlID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmRlZmF1bHRWYWx1ZTtcbn1cblxuLyoqXG4gKiBTZXQgZGVmYXVsdCB2YWx1ZS5cbiAqIEBtZXRob2Qgc2V0RGVmYXVsdFZhbHVlXG4gKi9cblNob3dEaWFsb2dNZXNzYWdlLnByb3RvdHlwZS5zZXREZWZhdWx0VmFsdWUgPSBmdW5jdGlvbih2KSB7XG5cdHRoaXMuZGVmYXVsdFZhbHVlPXY7XG59XG5cbi8qKlxuICogU2V0IHRleHQgaW4gdGhlIGRpYWxvZy5cbiAqIEBtZXRob2Qgc2V0VGV4dFxuICovXG5TaG93RGlhbG9nTWVzc2FnZS5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcblx0dGhpcy50ZXh0ID0gdGV4dDtcbn1cblxuLyoqXG4gKiBVbi1zZXJpYWxpemUuXG4gKiBAbWV0aG9kIHVuc2VyaWFsaXplLlxuICovXG5TaG93RGlhbG9nTWVzc2FnZS5wcm90b3R5cGUudW5zZXJpYWxpemUgPSBmdW5jdGlvbihkYXRhKSB7XG5cdHRoaXMudGV4dCA9IGRhdGEudGV4dDtcblx0dGhpcy5idXR0b25zID0gZGF0YS5idXR0b25zO1xuXHR0aGlzLmRlZmF1bHRWYWx1ZSA9IGRhdGEuZGVmYXVsdFZhbHVlO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZXJpYWxpemVcbiAqL1xuU2hvd0RpYWxvZ01lc3NhZ2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4ge1xuXHRcdHRleHQ6IHRoaXMudGV4dCxcblx0XHRidXR0b25zOiB0aGlzLmJ1dHRvbnMsXG5cdFx0ZGVmYXVsdFZhbHVlOiB0aGlzLmRlZmF1bHRWYWx1ZVxuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNob3dEaWFsb2dNZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgU3RhdGVDb21wbGV0ZU1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gU3RhdGVDb21wbGV0ZU1lc3NhZ2UoKSB7fVxuXG5TdGF0ZUNvbXBsZXRlTWVzc2FnZS5UWVBFID0gXCJzdGF0ZUNvbXBsZXRlXCI7XG5cbi8qKlxuICogVW4tc2VyaWFsaXplLlxuICogQG1ldGhvZCB1bnNlcmlhbGl6ZS5cbiAqL1xuU3RhdGVDb21wbGV0ZU1lc3NhZ2UucHJvdG90eXBlLnVuc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge31cblxuLyoqXG4gKiBTZXJpYWxpemUgbWVzc2FnZS5cbiAqIEBtZXRob2Qgc2VyaWFsaXplXG4gKi9cblN0YXRlQ29tcGxldGVNZXNzYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlQ29tcGxldGVNZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxuLyoqXG4gKiBSZWNlaXZlZCB3aGVuIHRhYmxlIGJ1dHRvbiBjbGlja2VkLlxuICogQGNsYXNzIFRhYmxlQnV0dG9uQ2xpY2tNZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIFRhYmxlQnV0dG9uQ2xpY2tNZXNzYWdlKHRhYmxlSW5kZXgpIHtcblx0dGhpcy50YWJsZUluZGV4ID0gdGFibGVJbmRleDtcbn1cblxuVGFibGVCdXR0b25DbGlja01lc3NhZ2UuVFlQRSA9IFwidGFibGVCdXR0b25DbGlja1wiO1xuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0VGFibGVJbmRleFxuICovXG5UYWJsZUJ1dHRvbkNsaWNrTWVzc2FnZS5wcm90b3R5cGUuZ2V0VGFibGVJbmRleCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy50YWJsZUluZGV4O1xufVxuXG4vKipcbiAqIFVuLXNlcmlhbGl6ZS5cbiAqIEBtZXRob2QgdW5zZXJpYWxpemVcbiAqL1xuVGFibGVCdXR0b25DbGlja01lc3NhZ2UucHJvdG90eXBlLnVuc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge1xuXHR0aGlzLnRhYmxlSW5kZXggPSBkYXRhLnRhYmxlSW5kZXg7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIHNlcmlhbGl6ZVxuICovXG5UYWJsZUJ1dHRvbkNsaWNrTWVzc2FnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB7XG5cdFx0dGFibGVJbmRleDogdGhpcy50YWJsZUluZGV4XG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGFibGVCdXR0b25DbGlja01lc3NhZ2U7IiwiLyoqXG4gKiBQcm90b2NvbC5cbiAqIEBtb2R1bGUgcHJvdG9cbiAqL1xuXG4vKipcbiAqIFJlY2VpdmVkIHdoZW4gPy5cbiAqIEBjbGFzcyBUYWJsZUJ1dHRvbnNNZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIFRhYmxlQnV0dG9uc01lc3NhZ2UoKSB7XG5cdHRoaXMuZW5hYmxlZCA9IG5ldyBBcnJheSgpO1xuXHR0aGlzLmN1cnJlbnRJbmRleCA9IC0xO1xuXHR0aGlzLnBsYXllckluZGV4ID0gLTE7XG5cdHRoaXMuaW5mb0xpbmsgPSBcIlwiO1xufVxuXG5UYWJsZUJ1dHRvbnNNZXNzYWdlLlRZUEUgPSBcInRhYmxlQnV0dG9uc1wiO1xuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0RW5hYmxlZFxuICovXG5UYWJsZUJ1dHRvbnNNZXNzYWdlLnByb3RvdHlwZS5nZXRFbmFibGVkID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmVuYWJsZWQ7XG59XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRDdXJyZW50SW5kZXhcbiAqL1xuVGFibGVCdXR0b25zTWVzc2FnZS5wcm90b3R5cGUuZ2V0Q3VycmVudEluZGV4ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmN1cnJlbnRJbmRleDtcbn1cblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldFBsYXllckluZGV4XG4gKi9cblRhYmxlQnV0dG9uc01lc3NhZ2UucHJvdG90eXBlLmdldFBsYXllckluZGV4ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnBsYXllckluZGV4O1xufVxuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0SW5mb0xpbmtcbiAqL1xuVGFibGVCdXR0b25zTWVzc2FnZS5wcm90b3R5cGUuZ2V0SW5mb0xpbmsgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuaW5mb0xpbms7XG59XG5cbi8qKlxuICogVW4tc2VyaWFsaXplLlxuICogQG1ldGhvZCB1bnNlcmlhbGl6ZVxuICovXG5UYWJsZUJ1dHRvbnNNZXNzYWdlLnByb3RvdHlwZS51bnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0dGhpcy5wbGF5ZXJJbmRleCA9IGRhdGEucGxheWVySW5kZXg7XG5cdHRoaXMuY3VycmVudEluZGV4ID0gZGF0YS5jdXJyZW50SW5kZXg7XG5cdHRoaXMuaW5mb0xpbmsgPSBkYXRhLmluZm9MaW5rO1xuXG5cdHRoaXMuZW5hYmxlZCA9IG5ldyBBcnJheSgpO1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgZGF0YS5lbmFibGVkLmxlbmd0aDsgaSsrKVxuXHRcdHRoaXMuZW5hYmxlZC5wdXNoKGRhdGEuZW5hYmxlZFtpXSk7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIHNlcmlhbGl6ZVxuICovXG5UYWJsZUJ1dHRvbnNNZXNzYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9iamVjdCA9IHtcblx0XHRjdXJyZW50SW5kZXg6IHRoaXMuY3VycmVudEluZGV4LFxuXHRcdHBsYXllckluZGV4OiB0aGlzLnBsYXllckluZGV4LFxuXHRcdGVuYWJsZWQ6IFtdLFxuXHRcdGluZm9MaW5rOiB0aGlzLmluZm9MaW5rXG5cdH07XG5cblx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMuZW5hYmxlZC5sZW5ndGg7IGkrKylcblx0XHRvYmplY3QuZW5hYmxlZC5wdXNoKHRoaXMuZW5hYmxlZFtpXSk7XG5cblx0cmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUYWJsZUJ1dHRvbnNNZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxuLyoqXG4gKiBTZXQgdGhlIGJpZyB0ZXh0IHRoYXQgY2FsbHMgZm9yIHVzZXIgYWN0aW9uLFxuICogc3VjaCBhcyBcIldlbGNvbWUsIHBsZWFzZSB0YWtlIGEgc2VhdCFcIi5cbiAqIEBjbGFzcyBUYWJsZUluZm9NZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIFRhYmxlSW5mb01lc3NhZ2UodGV4dCwgY291bnRkb3duKSB7XG5cdHRoaXMuY291bnRkb3duID0gY291bnRkb3duO1xuXHR0aGlzLnRleHQgPSB0ZXh0O1xuXHR0aGlzLnNob3dKb2luQnV0dG9uID0gZmFsc2U7XG5cdHRoaXMuc2hvd0xlYXZlQnV0dG9uID0gZmFsc2U7XG5cdHRoaXMuaW5mb0xpbmsgPSBudWxsO1xuXHR0aGlzLmluZm9MaW5rVGV4dCA9IG51bGw7XG59XG5cblRhYmxlSW5mb01lc3NhZ2UuVFlQRSA9IFwidGFibGVJbmZvXCI7XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRDb3VudGRvd25cbiAqL1xuVGFibGVJbmZvTWVzc2FnZS5wcm90b3R5cGUuZ2V0Q291bnRkb3duID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmNvdW50ZG93bjtcbn1cblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldFRleHRcbiAqL1xuVGFibGVJbmZvTWVzc2FnZS5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy50ZXh0O1xufVxuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0U2hvd0pvaW5CdXR0b25cbiAqL1xuVGFibGVJbmZvTWVzc2FnZS5wcm90b3R5cGUuZ2V0U2hvd0pvaW5CdXR0b24gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuc2hvd0pvaW5CdXR0b247XG59XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRTaG93TGVhdmVCdXR0b25cbiAqL1xuVGFibGVJbmZvTWVzc2FnZS5wcm90b3R5cGUuZ2V0U2hvd0xlYXZlQnV0dG9uID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnNob3dMZWF2ZUJ1dHRvbjtcbn1cblxuLyoqXG4gKiBTZXR0ZXIuXG4gKiBAbWV0aG9kIGdldFNob3dKb2luQnV0dG9uXG4gKi9cblRhYmxlSW5mb01lc3NhZ2UucHJvdG90eXBlLnNldFNob3dKb2luQnV0dG9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0dGhpcy5zaG93Sm9pbkJ1dHRvbiA9IHZhbHVlO1xufVxuXG4vKipcbiAqIFNldHRlci5cbiAqIEBtZXRob2QgZ2V0U2hvd0xlYXZlQnV0dG9uXG4gKi9cblRhYmxlSW5mb01lc3NhZ2UucHJvdG90eXBlLnNldFNob3dMZWF2ZUJ1dHRvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdHRoaXMuc2hvd0xlYXZlQnV0dG9uID0gdmFsdWU7XG59XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRJbmZvTGlua1xuICovXG5UYWJsZUluZm9NZXNzYWdlLnByb3RvdHlwZS5nZXRJbmZvTGluayA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5pbmZvTGluaztcbn1cblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldEluZm9MaW5rVGV4dFxuICovXG5UYWJsZUluZm9NZXNzYWdlLnByb3RvdHlwZS5nZXRJbmZvTGlua1RleHQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuaW5mb0xpbmtUZXh0O1xufVxuXG4vKipcbiAqIFVuLXNlcmlhbGl6ZS5cbiAqIEBtZXRob2QgdW5zZXJpYWxpemVcbiAqL1xuVGFibGVJbmZvTWVzc2FnZS5wcm90b3R5cGUudW5zZXJpYWxpemUgPSBmdW5jdGlvbihkYXRhKSB7XG5cdGlmIChkYXRhLnRleHQgIT0gbnVsbClcblx0XHR0aGlzLnRleHQgPSBkYXRhLnRleHQ7XG5cblx0aWYgKGRhdGEuY291bnRkb3duICE9IG51bGwpXG5cdFx0dGhpcy5jb3VudGRvd24gPSBkYXRhLmNvdW50ZG93bjtcblxuXHRpZiAoZGF0YS5zaG93Sm9pbkJ1dHRvbiAhPSBudWxsKVxuXHRcdHRoaXMuc2hvd0pvaW5CdXR0b24gPSBkYXRhLnNob3dKb2luQnV0dG9uO1xuXG5cdGlmIChkYXRhLnNob3dMZWF2ZUJ1dHRvbiAhPSBudWxsKVxuXHRcdHRoaXMuc2hvd0xlYXZlQnV0dG9uID0gZGF0YS5zaG93TGVhdmVCdXR0b247XG5cblx0aWYgKGRhdGEuaW5mb0xpbmsgIT0gbnVsbClcblx0XHR0aGlzLmluZm9MaW5rID0gZGF0YS5pbmZvTGluaztcblxuXHRpZiAoZGF0YS5pbmZvTGlua1RleHQgIT0gbnVsbClcblx0XHR0aGlzLmluZm9MaW5rVGV4dCA9IGRhdGEuaW5mb0xpbmtUZXh0O1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZXJpYWxpemVcbiAqL1xuVGFibGVJbmZvTWVzc2FnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB7XG5cdFx0dGV4dDogdGhpcy50ZXh0LFxuXHRcdGNvdW50ZG93bjogdGhpcy5jb3VudGRvd24sXG5cdFx0c2hvd0pvaW5CdXR0b246IHRoaXMuc2hvd0pvaW5CdXR0b24sXG5cdFx0c2hvd0xlYXZlQnV0dG9uOiB0aGlzLnNob3dMZWF2ZUJ1dHRvbixcblx0XHRpbmZvTGluazogdGhpcy5pbmZvTGluayxcblx0XHRpbmZvTGlua1RleHQ6IHRoaXMuaW5mb0xpbmtUZXh0XG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGFibGVJbmZvTWVzc2FnZTsiLCIvKipcbiAqIFByb3RvY29sLlxuICogQG1vZHVsZSBwcm90b1xuICovXG5cbi8qKlxuICogUmVjZWl2ZWQgd2hlbiA/LlxuICogQGNsYXNzIFRlc3RDYXNlUmVxdWVzdE1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gVGVzdENhc2VSZXF1ZXN0TWVzc2FnZSh0ZXN0Q2FzZSkge1xuXHR0aGlzLnRlc3RDYXNlID0gdGVzdENhc2U7XG59XG5cblRlc3RDYXNlUmVxdWVzdE1lc3NhZ2UuVFlQRSA9IFwidGVzdENhc2VSZXF1ZXN0XCI7XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRUZXN0Q2FzZVxuICovXG5UZXN0Q2FzZVJlcXVlc3RNZXNzYWdlLnByb3RvdHlwZS5nZXRUZXN0Q2FzZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy50ZXN0Q2FzZTtcbn1cblxuLyoqXG4gKiBVbi1zZXJpYWxpemUuXG4gKiBAbWV0aG9kIHVuc2VyaWFsaXplXG4gKi9cblRlc3RDYXNlUmVxdWVzdE1lc3NhZ2UucHJvdG90eXBlLnVuc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge1xuXHR0aGlzLnRlc3RDYXNlID0gZGF0YS50ZXN0Q2FzZTtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgbWVzc2FnZS5cbiAqIEBtZXRob2Qgc2VyaWFsaXplXG4gKi9cblRlc3RDYXNlUmVxdWVzdE1lc3NhZ2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4ge1xuXHRcdHRlc3RDYXNlOiB0aGlzLnRlc3RDYXNlXG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGVzdENhc2VSZXF1ZXN0TWVzc2FnZTsiLCIvKipcbiAqIFByb3RvY29sLlxuICogQG1vZHVsZSBwcm90b1xuICovXG5cbi8qKlxuICogUmVjZWl2ZWQgd2hlbiA/LlxuICogQGNsYXNzIFRpbWVyTWVzc2FnZVxuICovXG5mdW5jdGlvbiBUaW1lck1lc3NhZ2UoKSB7XG5cdHRoaXMuc2VhdEluZGV4ID0gLTE7XG5cdHRoaXMudG90YWxUaW1lID0gLTE7XG5cdHRoaXMudGltZUxlZnQgPSAtMTtcbn1cblxuVGltZXJNZXNzYWdlLlRZUEUgPSBcInRpbWVyXCI7XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRTZWF0SW5kZXhcbiAqL1xuVGltZXJNZXNzYWdlLnByb3RvdHlwZS5nZXRTZWF0SW5kZXggPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuc2VhdEluZGV4O1xufVxuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0VG90YWxUaW1lXG4gKi9cblRpbWVyTWVzc2FnZS5wcm90b3R5cGUuZ2V0VG90YWxUaW1lID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnRvdGFsVGltZTtcbn1cblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldFRpbWVMZWZ0XG4gKi9cblRpbWVyTWVzc2FnZS5wcm90b3R5cGUuZ2V0VGltZUxlZnQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMudGltZUxlZnQ7XG59XG5cbi8qKlxuICogU2V0dGVyLlxuICogQG1ldGhvZCBzZXRTZWF0SW5kZXhcbiAqL1xuVGltZXJNZXNzYWdlLnByb3RvdHlwZS5zZXRTZWF0SW5kZXggPSBmdW5jdGlvbih2YWx1ZSkge1xuXHR0aGlzLnNlYXRJbmRleCA9IHZhbHVlO1xufVxuXG4vKipcbiAqIFNldHRlci5cbiAqIEBtZXRob2Qgc2V0VG90YWxUaW1lXG4gKi9cblRpbWVyTWVzc2FnZS5wcm90b3R5cGUuc2V0VG90YWxUaW1lID0gZnVuY3Rpb24odmFsdWUpIHtcblx0dGhpcy50b3RhbFRpbWUgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBTZXR0ZXIuXG4gKiBAbWV0aG9kIHNldFRpbWVMZWZ0XG4gKi9cblRpbWVyTWVzc2FnZS5wcm90b3R5cGUuc2V0VGltZUxlZnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHR0aGlzLnRpbWVMZWZ0ID0gdmFsdWU7XG59XG5cbi8qKlxuICogVW4tc2VyaWFsaXplLlxuICogQG1ldGhvZCB1bnNlcmlhbGl6ZVxuICovXG5UaW1lck1lc3NhZ2UucHJvdG90eXBlLnVuc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge1xuXHR0aGlzLnNlYXRJbmRleCA9IGRhdGEuc2VhdEluZGV4O1xuXHR0aGlzLnRvdGFsVGltZSA9IGRhdGEudG90YWxUaW1lO1xuXHR0aGlzLnRpbWVMZWZ0ID0gZGF0YS50aW1lTGVmdDtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgbWVzc2FnZS5cbiAqIEBtZXRob2Qgc2VyaWFsaXplXG4gKi9cblRpbWVyTWVzc2FnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB7XG5cdFx0c2VhdEluZGV4OiB0aGlzLnNlYXRJbmRleCxcblx0XHR0b3RhbFRpbWU6IHRoaXMudG90YWxUaW1lLFxuXHRcdHRpbWVMZWZ0OiB0aGlzLnRpbWVMZWZ0XG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZXJNZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxuLyoqXG4gKiBSZWNlaXZlZCB3aGVuIHRvdXJuYW1lbnQgcmVzdWx0IG1lc3NhZ2UgaXMgZGlzcGF0Y2hlZC5cbiAqIEBjbGFzcyBUb3VybmFtZW50UmVzdWx0TWVzc2FnZVxuICovXG5mdW5jdGlvbiBUb3VybmFtZW50UmVzdWx0TWVzc2FnZSh0ZXh0LCByaWdodENvbHVtblRleHQpIHtcblx0dGhpcy50ZXh0ID0gdGV4dDtcblx0dGhpcy5yaWdodENvbHVtblRleHQgPSByaWdodENvbHVtblRleHQ7XG59XG5cblRvdXJuYW1lbnRSZXN1bHRNZXNzYWdlLlRZUEUgPSBcInRvdXJuYW1lbnRSZXN1bHRcIjtcblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldFRleHRcbiAqL1xuVG91cm5hbWVudFJlc3VsdE1lc3NhZ2UucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMudGV4dDtcbn1cblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldFJpZ2h0Q29sdW1uVGV4dFxuICovXG5Ub3VybmFtZW50UmVzdWx0TWVzc2FnZS5wcm90b3R5cGUuZ2V0UmlnaHRDb2x1bW5UZXh0ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnJpZ2h0Q29sdW1uVGV4dDtcbn1cblxuLyoqXG4gKiBVbi1zZXJpYWxpemUuXG4gKiBAbWV0aG9kIHVuc2VyaWFsaXplXG4gKi9cblRvdXJuYW1lbnRSZXN1bHRNZXNzYWdlLnByb3RvdHlwZS51bnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0dGhpcy50ZXh0ID0gZGF0YS50ZXh0O1xuXHR0aGlzLnJpZ2h0Q29sdW1uVGV4dCA9IGRhdGEucmlnaHRDb2x1bW5UZXh0O1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZXJpYWxpemVcbiAqL1xuVG91cm5hbWVudFJlc3VsdE1lc3NhZ2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4ge1xuXHRcdHRleHQ6IHRoaXMudGV4dCxcblx0XHRyaWdodENvbHVtblRleHQ6IHRoaXMucmlnaHRDb2x1bW5UZXh0XG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVG91cm5hbWVudFJlc3VsdE1lc3NhZ2U7IiwiLyoqXG4gKiBVdGlsaXRpZXMuXG4gKiBAbW9kdWxlIHV0aWxzXG4gKi9cblxudmFyIFBJWEkgPSByZXF1aXJlKFwicGl4aS5qc1wiKTtcbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKFwieWFlZFwiKTtcbnZhciBCdXR0b24gPSByZXF1aXJlKFwiLi9CdXR0b25cIik7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiaW5oZXJpdHNcIik7XG5cbi8qKlxuICogQ2hlY2tib3guXG4gKiBAY2xhc3MgQ2hlY2tib3hcbiAqL1xuZnVuY3Rpb24gQ2hlY2tib3goYmFja2dyb3VuZCwgdGljaykge1xuXHRQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIuY2FsbCh0aGlzKTtcblxuXHR0aGlzLmJ1dHRvbiA9IG5ldyBCdXR0b24oYmFja2dyb3VuZCk7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5idXR0b24pO1xuXG5cdHRoaXMuY2hlY2sgPSB0aWNrO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMuY2hlY2spO1xuXG5cdHRoaXMuYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLm9uQnV0dG9uQ2xpY2ssIHRoaXMpO1xuXG5cdHRoaXMuc2V0Q2hlY2tlZChmYWxzZSk7XG59XG5cbmluaGVyaXRzKENoZWNrYm94LCBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIpO1xuRXZlbnREaXNwYXRjaGVyLmluaXQoQ2hlY2tib3gpO1xuXG4vKipcbiAqIEJ1dHRvbiBjbGljay5cbiAqIEBtZXRob2Qgb25CdXR0b25DbGlja1xuICogQHByaXZhdGVcbiAqL1xuQ2hlY2tib3gucHJvdG90eXBlLm9uQnV0dG9uQ2xpY2sgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5jaGVjay52aXNpYmxlID0gIXRoaXMuY2hlY2sudmlzaWJsZTtcblxuXHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJjaGFuZ2VcIik7XG59XG5cbi8qKlxuICogU2V0dGVyLlxuICogQG1ldGhvZCBzZXRDaGVja2VkXG4gKi9cbkNoZWNrYm94LnByb3RvdHlwZS5zZXRDaGVja2VkID0gZnVuY3Rpb24odmFsdWUpIHtcblx0dGhpcy5jaGVjay52aXNpYmxlID0gdmFsdWU7XG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldENoZWNrZWRcbiAqL1xuQ2hlY2tib3gucHJvdG90eXBlLmdldENoZWNrZWQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuY2hlY2sudmlzaWJsZTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IENoZWNrYm94OyIsIi8qKlxuICogVXRpbGl0aWVzLlxuICogQG1vZHVsZSB1dGlsc1xuICovXG5cbnZhciBUaGVuYWJsZSA9IHJlcXVpcmUoXCJ0aW5wXCIpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoXCJ5YWVkXCIpO1xudmFyIEh0dHBSZXF1ZXN0ID0gcmVxdWlyZShcIi4uL3V0aWxzL0h0dHBSZXF1ZXN0XCIpO1xuXG4vKipcbiAqIEEgXCJjb25uZWN0aW9uXCIgdGhhdCBsb2FkcyBpdHMgbWVzc2FnZXMgZnJvbSBhIGpzb24gZmlsZSByYXRoZXIgdGhhblxuICogYWN0dWFsbHkgY29ubmVjdGluZy5cbiAqIEBjbGFzcyBNZXNzYWdlUmVxdWVzdENvbm5lY3Rpb25cbiAqL1xuZnVuY3Rpb24gTWVzc2FnZVJlcXVlc3RDb25uZWN0aW9uKCkge1xuXHRFdmVudERpc3BhdGNoZXIuY2FsbCh0aGlzKTtcblx0dGhpcy50ZXN0ID0gMTtcbn1cblxuaW5oZXJpdHMoTWVzc2FnZVJlcXVlc3RDb25uZWN0aW9uLCBFdmVudERpc3BhdGNoZXIpO1xuXG5NZXNzYWdlUmVxdWVzdENvbm5lY3Rpb24uQ09OTkVDVCA9IFwiY29ubmVjdFwiO1xuTWVzc2FnZVJlcXVlc3RDb25uZWN0aW9uLk1FU1NBR0UgPSBcIm1lc3NhZ2VcIjtcbk1lc3NhZ2VSZXF1ZXN0Q29ubmVjdGlvbi5DTE9TRSA9IFwiY2xvc2VcIjtcblxuLyoqXG4gKiBDb25uZWN0LlxuICogQG1ldGhvZCBjb25uZWN0XG4gKi9cbk1lc3NhZ2VSZXF1ZXN0Q29ubmVjdGlvbi5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKHVybCkge1xuXHR2YXIgcmVxdWVzdCA9IG5ldyBIdHRwUmVxdWVzdCh1cmwpO1xuXG5cdHJlcXVlc3Quc2VuZCgpLnRoZW4oXG5cdFx0dGhpcy5vblJlcXVlc3RDb21wbGV0ZS5iaW5kKHRoaXMpLFxuXHRcdHRoaXMub25SZXF1ZXN0RXJyb3IuYmluZCh0aGlzKVxuXHQpO1xufVxuXG4vKipcbiAqIEBtZXRob2Qgb25SZXF1ZXN0Q29tcGxldGVcbiAqwqBAcHJpdmF0ZVxuICovXG5NZXNzYWdlUmVxdWVzdENvbm5lY3Rpb24ucHJvdG90eXBlLm9uUmVxdWVzdENvbXBsZXRlID0gZnVuY3Rpb24oYm9keSkge1xuXHR0aGlzLnRyaWdnZXIoTWVzc2FnZVJlcXVlc3RDb25uZWN0aW9uLkNPTk5FQ1QpO1xuXG5cdHZhciBsaW5lcyA9IGJvZHkudG9TdHJpbmcoKS5zcGxpdChcIlxcblwiKTtcblxuXHQvL2NvbnNvbGUubG9nKFwiTWVzc2FnZVJlcXVlc3RDb25uZWN0aW9uOiBsaW5lcz1cIitsaW5lcy5sZW5ndGgpO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgbGluZSA9IGxpbmVzW2ldO1xuXG5cdFx0Ly9jb25zb2xlLmxvZyhcImxpbmU6IFwiK2xpbmUpO1xuXG5cdFx0aWYgKGxpbmUubGVuZ3RoICYmIGxpbmVbMF0gIT0gXCIvXCIpIHtcblx0XHRcdGNvbnNvbGUubG9nKFwidHJpZ2dlciBtZXNzYWdlOiBcIiArIGxpbmUpO1xuXHRcdFx0dGhpcy50cmlnZ2VyKHtcblx0XHRcdFx0dHlwZTogTWVzc2FnZVJlcXVlc3RDb25uZWN0aW9uLk1FU1NBR0UsXG5cdFx0XHRcdG1lc3NhZ2U6IEpTT04ucGFyc2UobGluZSlcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBtZXRob2Qgb25SZXF1ZXN0Q29tcGxldGVcbiAqwqBAcHJpdmF0ZVxuICovXG5NZXNzYWdlUmVxdWVzdENvbm5lY3Rpb24ucHJvdG90eXBlLm9uUmVxdWVzdEVycm9yID0gZnVuY3Rpb24oZSkge1xuXHRjb25zb2xlLmxvZyhcImVycm9yIGluIHJlcXVlc3QgY29ubmVjdGlvblwiKTtcblx0Y29uc29sZS5sb2coZSk7XG5cdHRoaXMudHJpZ2dlcihNZXNzYWdlUmVxdWVzdENvbm5lY3Rpb24uQ0xPU0UpO1xufVxuXG4vKipcbiAqIFNlbmQuXG4gKiBAbWV0aG9kIHNlbmRcbiAqL1xuTWVzc2FnZVJlcXVlc3RDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obSkge1xuXHRjb25zb2xlLmxvZygnaWdub3JpbmcgXCJzZW5kXCIgZm9yIE1lc3NhZ2VSZXF1ZXN0Q29ubmVjdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2VSZXF1ZXN0Q29ubmVjdGlvbjsiLCIvKipcbiAqIFV0aWxpdGllcy5cbiAqIEBtb2R1bGUgdXRpbHNcbiAqL1xuXG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZShcInlhZWRcIik7XG52YXIgVGhlbmFibGUgPSByZXF1aXJlKFwidGlucFwiKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCJpbmhlcml0c1wiKTtcblxuLyoqXG4gKiBNZXNzYWdlIGNvbm5lY3Rpb24gaW4gYSBicm93c2VyLlxuICogQGNsYXNzIE1lc3NhZ2VXZWJTb2NrZXRDb25uZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIE1lc3NhZ2VXZWJTb2NrZXRDb25uZWN0aW9uKCkge1xuXHRFdmVudERpc3BhdGNoZXIuY2FsbCh0aGlzKTtcblx0dGhpcy50ZXN0ID0gMTtcbn1cblxuaW5oZXJpdHMoTWVzc2FnZVdlYlNvY2tldENvbm5lY3Rpb24sIEV2ZW50RGlzcGF0Y2hlcik7XG5cbk1lc3NhZ2VXZWJTb2NrZXRDb25uZWN0aW9uLkNPTk5FQ1QgPSBcImNvbm5lY3RcIjtcbk1lc3NhZ2VXZWJTb2NrZXRDb25uZWN0aW9uLk1FU1NBR0UgPSBcIm1lc3NhZ2VcIjtcbk1lc3NhZ2VXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFID0gXCJjbG9zZVwiO1xuXG4vKipcbiAqIENvbm5lY3QuXG4gKiBAbWV0aG9kIGNvbm5lY3RcbiAqL1xuTWVzc2FnZVdlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbih1cmwpIHtcblx0dGhpcy53ZWJTb2NrZXQgPSBuZXcgV2ViU29ja2V0KHVybCk7XG5cblx0dGhpcy53ZWJTb2NrZXQub25vcGVuID0gdGhpcy5vbldlYlNvY2tldE9wZW4uYmluZCh0aGlzKTtcblx0dGhpcy53ZWJTb2NrZXQub25tZXNzYWdlID0gdGhpcy5vbldlYlNvY2tldE1lc3NhZ2UuYmluZCh0aGlzKTtcblx0dGhpcy53ZWJTb2NrZXQub25jbG9zZSA9IHRoaXMub25XZWJTb2NrZXRDbG9zZS5iaW5kKHRoaXMpO1xuXHR0aGlzLndlYlNvY2tldC5vbmVycm9yID0gdGhpcy5vbldlYlNvY2tldEVycm9yLmJpbmQodGhpcyk7XG59XG5cbi8qKlxuICogU2VuZC5cbiAqIEBtZXRob2Qgc2VuZFxuICovXG5NZXNzYWdlV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG0pIHtcblx0dGhpcy53ZWJTb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShtKSk7XG59XG5cbi8qKlxuICogV2ViIHNvY2tldCBvcGVuLlxuICogQG1ldGhvZCBvbldlYlNvY2tldE9wZW5cbiAqIEBwcml2YXRlXG4gKi9cbk1lc3NhZ2VXZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5vbldlYlNvY2tldE9wZW4gPSBmdW5jdGlvbigpIHtcblx0dGhpcy50cmlnZ2VyKE1lc3NhZ2VXZWJTb2NrZXRDb25uZWN0aW9uLkNPTk5FQ1QpO1xufVxuXG4vKipcbiAqIFdlYiBzb2NrZXQgbWVzc2FnZS5cbiAqIEBtZXRob2Qgb25XZWJTb2NrZXRNZXNzYWdlXG4gKiBAcHJpdmF0ZVxuICovXG5NZXNzYWdlV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUub25XZWJTb2NrZXRNZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuXHR2YXIgbWVzc2FnZSA9IEpTT04ucGFyc2UoZS5kYXRhKTtcblxuXHR0aGlzLnRyaWdnZXIoe1xuXHRcdHR5cGU6IE1lc3NhZ2VXZWJTb2NrZXRDb25uZWN0aW9uLk1FU1NBR0UsXG5cdFx0bWVzc2FnZTogbWVzc2FnZVxuXHR9KTtcbn1cblxuLyoqXG4gKiBXZWIgc29ja2V0IGNsb3NlLlxuICogQG1ldGhvZCBvbldlYlNvY2tldENsb3NlXG4gKiBAcHJpdmF0ZVxuICovXG5NZXNzYWdlV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUub25XZWJTb2NrZXRDbG9zZSA9IGZ1bmN0aW9uKCkge1xuXHRjb25zb2xlLmxvZyhcIndlYiBzb2NrZXQgY2xvc2UsIHdzPVwiICsgdGhpcy53ZWJTb2NrZXQgKyBcIiB0aGlzPVwiICsgdGhpcy50ZXN0KTtcblx0dGhpcy53ZWJTb2NrZXQuY2xvc2UoKTtcblx0dGhpcy5jbGVhcldlYlNvY2tldCgpO1xuXG5cdHRoaXMudHJpZ2dlcihNZXNzYWdlV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRSk7XG59XG5cbi8qKlxuICogV2ViIHNvY2tldCBlcnJvci5cbiAqIEBtZXRob2Qgb25XZWJTb2NrZXRFcnJvclxuICogQHByaXZhdGVcbiAqL1xuTWVzc2FnZVdlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLm9uV2ViU29ja2V0RXJyb3IgPSBmdW5jdGlvbigpIHtcblx0Y29uc29sZS5sb2coXCJ3ZWIgc29ja2V0IGVycm9yLCB3cz1cIiArIHRoaXMud2ViU29ja2V0ICsgXCIgdGhpcz1cIiArIHRoaXMudGVzdCk7XG5cblx0dGhpcy53ZWJTb2NrZXQuY2xvc2UoKTtcblx0dGhpcy5jbGVhcldlYlNvY2tldCgpO1xuXG5cdHRoaXMudHJpZ2dlcihNZXNzYWdlV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRSk7XG59XG5cbi8qKlxuICogQ2xlYXIgdGhlIGN1cnJlbnQgd2ViIHNvY2tldC5cbiAqIEBtZXRob2QgY2xlYXJXZWJTb2NrZXRcbiAqL1xuTWVzc2FnZVdlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmNsZWFyV2ViU29ja2V0ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMud2ViU29ja2V0Lm9ub3BlbiA9IG51bGw7XG5cdHRoaXMud2ViU29ja2V0Lm9ubWVzc2FnZSA9IG51bGw7XG5cdHRoaXMud2ViU29ja2V0Lm9uY2xvc2UgPSBudWxsO1xuXHR0aGlzLndlYlNvY2tldC5vbmVycm9yID0gbnVsbDtcblxuXHR0aGlzLndlYlNvY2tldCA9IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZVdlYlNvY2tldENvbm5lY3Rpb247IiwiLyoqXG4gKiBVdGlsaXRpZXMuXG4gKiBAbW9kdWxlIHV0aWxzXG4gKi9cblxudmFyIFBJWEkgPSByZXF1aXJlKFwicGl4aS5qc1wiKTtcbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKFwieWFlZFwiKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCJpbmhlcml0c1wiKTtcblxuLyoqXG4gKiBNb3VzZU92ZXJHcm91cC4gVGhpcyBpcyB0aGUgY2xhc3MgZm9yIHRoZSBNb3VzZU92ZXJHcm91cC5cbiAqIEBjbGFzcyBNb3VzZU92ZXJHcm91cFxuICovXG5mdW5jdGlvbiBNb3VzZU92ZXJHcm91cCgpIHtcblx0dGhpcy5vYmplY3RzID0gbmV3IEFycmF5KCk7XG5cdHRoaXMuY3VycmVudGx5T3ZlciA9IGZhbHNlO1xuXHR0aGlzLm1vdXNlRG93biA9IGZhbHNlO1xuXG59XG5pbmhlcml0cyhNb3VzZU92ZXJHcm91cCwgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyKTtcbkV2ZW50RGlzcGF0Y2hlci5pbml0KE1vdXNlT3Zlckdyb3VwKTtcblxuXG4vKipcbiAqIEFkZCBkaXNwbGF5b2JqZWN0IHRvIHdhdGNobGlzdC5cbiAqIEBtZXRob2QgYWRkRGlzcGxheU9iamVjdFxuICovXG5Nb3VzZU92ZXJHcm91cC5wcm90b3R5cGUuYWRkRGlzcGxheU9iamVjdCA9IGZ1bmN0aW9uKGRpc3BsYXlPYmplY3QpIHtcblxuXHRkaXNwbGF5T2JqZWN0LmludGVyYWN0aXZlID0gdHJ1ZTtcblx0ZGlzcGxheU9iamVjdC5tb3VzZW92ZXJFbmFibGVkID0gdHJ1ZTtcblx0ZGlzcGxheU9iamVjdC5tb3VzZW92ZXIgPSB0aGlzLm9uT2JqZWN0TW91c2VPdmVyLmJpbmQodGhpcyk7XG5cdGRpc3BsYXlPYmplY3QubW91c2VvdXQgPSB0aGlzLm9uT2JqZWN0TW91c2VPdXQuYmluZCh0aGlzKTtcblx0ZGlzcGxheU9iamVjdC5tb3VzZWRvd24gPSB0aGlzLm9uT2JqZWN0TW91c2VEb3duLmJpbmQodGhpcyk7XG5cdHRoaXMub2JqZWN0cy5wdXNoKGRpc3BsYXlPYmplY3QpO1xuXG59XG5cblxuLyoqXG4gKiBNb3VzZSBvdmVyIG9iamVjdC5cbiAqIEBtZXRob2Qgb25PYmplY3RNb3VzZU92ZXJcbiAqL1xuTW91c2VPdmVyR3JvdXAucHJvdG90eXBlLm9uT2JqZWN0TW91c2VPdmVyID0gZnVuY3Rpb24oaW50ZXJhY3Rpb25fb2JqZWN0KSB7XG5cdGlmKHRoaXMuY3VycmVudGx5T3Zlcilcblx0XHRyZXR1cm47XG5cblx0dGhpcy5jdXJyZW50bHlPdmVyID0gdHJ1ZTtcblx0dGhpcy5kaXNwYXRjaEV2ZW50KFwibW91c2VvdmVyXCIpO1xufVxuXG5cbi8qKlxuICogTW91c2Ugb3V0IG9iamVjdC5cbiAqIEBtZXRob2Qgb25PYmplY3RNb3VzZU91dFxuICovXG5Nb3VzZU92ZXJHcm91cC5wcm90b3R5cGUub25PYmplY3RNb3VzZU91dCA9IGZ1bmN0aW9uKGludGVyYWN0aW9uX29iamVjdCkge1xuXHRpZighdGhpcy5jdXJyZW50bHlPdmVyIHx8IHRoaXMubW91c2VEb3duKVxuXHRcdHJldHVybjtcblxuXHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5vYmplY3RzLmxlbmd0aDsgaSsrKVxuXHRcdGlmKHRoaXMuaGl0VGVzdCh0aGlzLm9iamVjdHNbaV0sIGludGVyYWN0aW9uX29iamVjdCkpXG5cdFx0XHRyZXR1cm47XG5cblx0dGhpcy5jdXJyZW50bHlPdmVyID0gZmFsc2U7XG5cdHRoaXMuZGlzcGF0Y2hFdmVudChcIm1vdXNlb3V0XCIpO1xufVxuXG5cbi8qKlxuICogSGl0IHRlc3QuXG4gKiBAbWV0aG9kIGhpdFRlc3RcbiAqL1xuTW91c2VPdmVyR3JvdXAucHJvdG90eXBlLmhpdFRlc3QgPSBmdW5jdGlvbihvYmplY3QsIGludGVyYWN0aW9uX29iamVjdCkge1xuXHRpZigoaW50ZXJhY3Rpb25fb2JqZWN0Lmdsb2JhbC54ID4gb2JqZWN0LmdldEJvdW5kcygpLnggKSAmJiAoaW50ZXJhY3Rpb25fb2JqZWN0Lmdsb2JhbC54IDwgKG9iamVjdC5nZXRCb3VuZHMoKS54ICsgb2JqZWN0LmdldEJvdW5kcygpLndpZHRoKSkgJiZcblx0XHQoaW50ZXJhY3Rpb25fb2JqZWN0Lmdsb2JhbC55ID4gb2JqZWN0LmdldEJvdW5kcygpLnkpICYmIChpbnRlcmFjdGlvbl9vYmplY3QuZ2xvYmFsLnkgPCAob2JqZWN0LmdldEJvdW5kcygpLnkgKyBvYmplY3QuZ2V0Qm91bmRzKCkuaGVpZ2h0KSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcdFx0XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufVxuXG5cbi8qKlxuICogTW91c2UgZG93biBvYmplY3QuXG4gKiBAbWV0aG9kIG9uT2JqZWN0TW91c2VEb3duXG4gKi9cbk1vdXNlT3Zlckdyb3VwLnByb3RvdHlwZS5vbk9iamVjdE1vdXNlRG93biA9IGZ1bmN0aW9uKGludGVyYWN0aW9uX29iamVjdCkge1xuXHR0aGlzLm1vdXNlRG93biA9IHRydWU7XG5cdGludGVyYWN0aW9uX29iamVjdC50YXJnZXQubW91c2V1cCA9IGludGVyYWN0aW9uX29iamVjdC50YXJnZXQubW91c2V1cG91dHNpZGUgPSB0aGlzLm9uU3RhZ2VNb3VzZVVwLmJpbmQodGhpcyk7XG59XG5cblxuLyoqXG4gKiBNb3VzZSB1cCBzdGFnZS5cbiAqIEBtZXRob2Qgb25TdGFnZU1vdXNlVXBcbiAqL1xuTW91c2VPdmVyR3JvdXAucHJvdG90eXBlLm9uU3RhZ2VNb3VzZVVwID0gZnVuY3Rpb24oaW50ZXJhY3Rpb25fb2JqZWN0KSB7XG5cdGludGVyYWN0aW9uX29iamVjdC50YXJnZXQubW91c2V1cCA9IGludGVyYWN0aW9uX29iamVjdC50YXJnZXQubW91c2V1cG91dHNpZGUgPSBudWxsO1xuXHR0aGlzLm1vdXNlRG93biA9IGZhbHNlO1xuXG5cdGlmKHRoaXMuY3VycmVudGx5T3Zlcikge1xuXHRcdHZhciBvdmVyID0gZmFsc2U7XG5cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5vYmplY3RzLmxlbmd0aDsgaSsrKVxuXHRcdFx0aWYodGhpcy5oaXRUZXN0KHRoaXMub2JqZWN0c1tpXSwgaW50ZXJhY3Rpb25fb2JqZWN0KSlcblx0XHRcdFx0b3ZlciA9IHRydWU7XG5cblx0XHRpZighb3Zlcikge1xuXHRcdFx0dGhpcy5jdXJyZW50bHlPdmVyID0gZmFsc2U7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJtb3VzZW91dFwiKTtcblx0XHR9XG5cdH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vdXNlT3Zlckdyb3VwO1xuXG4iLCIvKipcbiAqIFV0aWxpdGllcy5cbiAqIEBtb2R1bGUgdXRpbHNcbiAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBwb2ludC5cbiAqIEBjbGFzcyBQb2ludFxuICogQG1vZHVsZSB1dGlsc1xuICovXG5mdW5jdGlvbiBQb2ludCh4LCB5KSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBQb2ludCkpXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh4LCB5KTtcblxuXHR0aGlzLnggPSB4O1xuXHR0aGlzLnkgPSB5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50OyIsIi8qKlxuICogVXRpbGl0aWVzLlxuICogQG1vZHVsZSB1dGlsc1xuICovXG5cbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKFwieWFlZFwiKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCJpbmhlcml0c1wiKTtcblxuLyoqXG4gKiBQZXJmb3JtIHRhc2tzIGluIGEgc2VxdWVuY2UuXG4gKiBUYXNrcywgd2hpY2ggc2hvdWxkIGJlIGV2ZW50IGRpc3BhdGNoZXJzLFxuICogYXJlIGV1cXVldWVkIHdpdGggdGhlIGVucXVldWUgZnVuY3Rpb24sXG4gKiBhIFNUQVJUIGV2ZW50IGlzIGRpc3BhdGNoZXIgdXBvbiB0YXNrXG4gKiBzdGFydCwgYW5kIHRoZSB0YXNrIGlzIGNvbnNpZGVyZWQgY29tcGxldGVcbiAqIGFzIGl0IGRpc3BhdGNoZXMgYSBDT01QTEVURSBldmVudC5cbiAqIEBjbGFzcyBTZXF1ZW5jZXJcbiAqL1xuZnVuY3Rpb24gU2VxdWVuY2VyKCkge1xuXHRFdmVudERpc3BhdGNoZXIuY2FsbCh0aGlzKTtcblxuXHR0aGlzLnF1ZXVlID0gW107XG5cdHRoaXMuY3VycmVudFRhc2sgPSBudWxsO1xuXHR0aGlzLm9uVGFza0NvbXBsZXRlQ2xvc3VyZSA9IHRoaXMub25UYXNrQ29tcGxldGUuYmluZCh0aGlzKTtcbn1cblxuaW5oZXJpdHMoU2VxdWVuY2VyLCBFdmVudERpc3BhdGNoZXIpO1xuXG5TZXF1ZW5jZXIuU1RBUlQgPSBcInN0YXJ0XCI7XG5TZXF1ZW5jZXIuQ09NUExFVEUgPSBcImNvbXBsZXRlXCI7XG5cbi8qKlxuICogRW5xdWV1ZSBhIHRhc2sgdG8gYmUgcGVyZm9ybWVkLlxuICogQG1ldGhvZCBlbnF1ZXVlXG4gKi9cblNlcXVlbmNlci5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uKHRhc2spIHtcblx0aWYgKCF0aGlzLmN1cnJlbnRUYXNrKVxuXHRcdHRoaXMuc3RhcnRUYXNrKHRhc2spXG5cblx0ZWxzZVxuXHRcdHRoaXMucXVldWUucHVzaCh0YXNrKTtcbn1cblxuLyoqXG4gKiBTdGFydCB0aGUgdGFzay5cbiAqIEBtZXRob2Qgc3RhcnRUYXNrXG4gKiBAcHJpdmF0ZVxuICovXG5TZXF1ZW5jZXIucHJvdG90eXBlLnN0YXJ0VGFzayA9IGZ1bmN0aW9uKHRhc2spIHtcblx0dGhpcy5jdXJyZW50VGFzayA9IHRhc2s7XG5cblx0dGhpcy5jdXJyZW50VGFzay5hZGRFdmVudExpc3RlbmVyKFNlcXVlbmNlci5DT01QTEVURSwgdGhpcy5vblRhc2tDb21wbGV0ZUNsb3N1cmUpO1xuXHR0aGlzLmN1cnJlbnRUYXNrLmRpc3BhdGNoRXZlbnQoe1xuXHRcdHR5cGU6IFNlcXVlbmNlci5TVEFSVFxuXHR9KTtcbn1cblxuLyoqXG4gKiBUaGUgY3VycmVudCB0YXNrIGlzIGNvbXBsZXRlLlxuICogQG1ldGhvZCBvblRhc2tDb21wbGV0ZVxuICrCoEBwcml2YXRlXG4gKi9cblNlcXVlbmNlci5wcm90b3R5cGUub25UYXNrQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5jdXJyZW50VGFzay5yZW1vdmVFdmVudExpc3RlbmVyKFNlcXVlbmNlci5DT01QTEVURSwgdGhpcy5vblRhc2tDb21wbGV0ZUNsb3N1cmUpO1xuXHR0aGlzLmN1cnJlbnRUYXNrID0gbnVsbDtcblxuXHRpZiAodGhpcy5xdWV1ZS5sZW5ndGggPiAwKVxuXHRcdHRoaXMuc3RhcnRUYXNrKHRoaXMucXVldWUuc2hpZnQoKSk7XG5cblx0ZWxzZVxuXHRcdHRoaXMudHJpZ2dlcihTZXF1ZW5jZXIuQ09NUExFVEUpO1xuXG59XG5cbi8qKlxuICogQWJvcnQgdGhlIHNlcXVlbmNlLlxuICogQG1ldGhvZCBhYm9ydFxuICovXG5TZXF1ZW5jZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLmN1cnJlbnRUYXNrKSB7XG5cdFx0dGhpcy5jdXJyZW50VGFzay5yZW1vdmVFdmVudExpc3RlbmVyKFNlcXVlbmNlci5DT01QTEVURSwgdGhpcy5vblRhc2tDb21wbGV0ZUNsb3N1cmUpO1xuXHRcdHRoaXMuY3VycmVudFRhc2sgPSBudWxsO1xuXHR9XG5cblx0dGhpcy5xdWV1ZSA9IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcXVlbmNlcjsiLCIvKipcbiAqIFV0aWxpdGllcy5cbiAqIEBtb2R1bGUgdXRpbHNcbiAqL1xuXG52YXIgUElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xudmFyIFRXRUVOID0gcmVxdWlyZShcInR3ZWVuLmpzXCIpO1xudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoXCJ5YWVkXCIpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xuXG4vKipcbiAqIFNsaWRlci4gVGhpcyBpcyB0aGUgY2xhc3MgZm9yIHRoZSBzbGlkZXIuXG4gKiBAY2xhc3MgU2xpZGVyXG4gKi9cbmZ1bmN0aW9uIFNsaWRlcihiYWNrZ3JvdW5kLCBrbm9iKSB7XG5cdFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKHRoaXMpO1xuXG5cdHRoaXMuYmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG5cdHRoaXMua25vYiA9IGtub2I7XG5cblx0dGhpcy5hZGRDaGlsZCh0aGlzLmJhY2tncm91bmQpO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMua25vYik7XG5cblxuXHR0aGlzLmtub2IuYnV0dG9uTW9kZSA9IHRydWU7XG5cdHRoaXMua25vYi5pbnRlcmFjdGl2ZSA9IHRydWU7XG5cdHRoaXMua25vYi5tb3VzZWRvd24gPSB0aGlzLm9uS25vYk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuXG5cdHRoaXMuYmFja2dyb3VuZC5idXR0b25Nb2RlID0gdHJ1ZTtcblx0dGhpcy5iYWNrZ3JvdW5kLmludGVyYWN0aXZlID0gdHJ1ZTtcblx0dGhpcy5iYWNrZ3JvdW5kLm1vdXNlZG93biA9IHRoaXMub25CYWNrZ3JvdW5kTW91c2VEb3duLmJpbmQodGhpcyk7XG5cblx0dGhpcy5mYWRlVHdlZW4gPSBudWxsO1xuXHR0aGlzLmFscGhhID0gMDtcbn1cblxuaW5oZXJpdHMoU2xpZGVyLCBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIpO1xuRXZlbnREaXNwYXRjaGVyLmluaXQoU2xpZGVyKTtcblxuXG4vKipcbiAqIE1vdXNlIGRvd24gb24ga25vYi5cbiAqIEBtZXRob2Qgb25Lbm9iTW91c2VEb3duXG4gKi9cblNsaWRlci5wcm90b3R5cGUub25Lbm9iTW91c2VEb3duID0gZnVuY3Rpb24oaW50ZXJhY3Rpb25fb2JqZWN0KSB7XG5cdHRoaXMuZG93blBvcyA9IHRoaXMua25vYi5wb3NpdGlvbi54O1xuXHR0aGlzLmRvd25YID0gaW50ZXJhY3Rpb25fb2JqZWN0LmdldExvY2FsUG9zaXRpb24odGhpcykueDtcblxuXHR0aGlzLnN0YWdlLm1vdXNldXAgPSB0aGlzLm9uU3RhZ2VNb3VzZVVwLmJpbmQodGhpcyk7XG5cdHRoaXMuc3RhZ2UubW91c2Vtb3ZlID0gdGhpcy5vblN0YWdlTW91c2VNb3ZlLmJpbmQodGhpcyk7XG59XG5cblxuLyoqXG4gKiBNb3VzZSBkb3duIG9uIGJhY2tncm91bmQuXG4gKiBAbWV0aG9kIG9uQmFja2dyb3VuZE1vdXNlRG93blxuICovXG5TbGlkZXIucHJvdG90eXBlLm9uQmFja2dyb3VuZE1vdXNlRG93biA9IGZ1bmN0aW9uKGludGVyYWN0aW9uX29iamVjdCkge1xuXHR0aGlzLmRvd25YID0gaW50ZXJhY3Rpb25fb2JqZWN0LmdldExvY2FsUG9zaXRpb24odGhpcykueDtcblx0dGhpcy5rbm9iLnggPSBpbnRlcmFjdGlvbl9vYmplY3QuZ2V0TG9jYWxQb3NpdGlvbih0aGlzKS54IC0gdGhpcy5rbm9iLndpZHRoKjAuNTtcblxuXHR0aGlzLnZhbGlkYXRlVmFsdWUoKTtcblxuXHR0aGlzLmRvd25Qb3MgPSB0aGlzLmtub2IucG9zaXRpb24ueDtcblxuXHR0aGlzLnN0YWdlLm1vdXNldXAgPSB0aGlzLm9uU3RhZ2VNb3VzZVVwLmJpbmQodGhpcyk7XG5cdHRoaXMuc3RhZ2UubW91c2Vtb3ZlID0gdGhpcy5vblN0YWdlTW91c2VNb3ZlLmJpbmQodGhpcyk7XG5cblx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiY2hhbmdlXCIpO1xufVxuXG5cbi8qKlxuICogTW91c2UgdXAuXG4gKiBAbWV0aG9kIG9uU3RhZ2VNb3VzZVVwXG4gKi9cblNsaWRlci5wcm90b3R5cGUub25TdGFnZU1vdXNlVXAgPSBmdW5jdGlvbihpbnRlcmFjdGlvbl9vYmplY3QpIHtcblx0dGhpcy5zdGFnZS5tb3VzZXVwID0gbnVsbDtcblx0dGhpcy5zdGFnZS5tb3VzZW1vdmUgPSBudWxsO1xufVxuXG5cbi8qKlxuICogTW91c2UgbW92ZS5cbiAqIEBtZXRob2Qgb25TdGFnZU1vdXNlTW92ZVxuICovXG5TbGlkZXIucHJvdG90eXBlLm9uU3RhZ2VNb3VzZU1vdmUgPSBmdW5jdGlvbihpbnRlcmFjdGlvbl9vYmplY3QpIHtcblx0dGhpcy5rbm9iLnggPSB0aGlzLmRvd25Qb3MgKyAoaW50ZXJhY3Rpb25fb2JqZWN0LmdldExvY2FsUG9zaXRpb24odGhpcykueCAtIHRoaXMuZG93blgpO1xuXG5cdHRoaXMudmFsaWRhdGVWYWx1ZSgpO1xuXG5cdHRoaXMuZGlzcGF0Y2hFdmVudChcImNoYW5nZVwiKTtcbn1cblxuXG4vKipcbiAqIFZhbGlkYXRlIHBvc2l0aW9uLlxuICogQG1ldGhvZCB2YWxpZGF0ZVZhbHVlXG4gKi9cblNsaWRlci5wcm90b3R5cGUudmFsaWRhdGVWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuXG5cdGlmKHRoaXMua25vYi54IDwgMClcblx0XHR0aGlzLmtub2IueCA9IDA7XG5cblx0aWYodGhpcy5rbm9iLnggPiAodGhpcy5iYWNrZ3JvdW5kLndpZHRoIC0gdGhpcy5rbm9iLndpZHRoKSlcblx0XHR0aGlzLmtub2IueCA9IHRoaXMuYmFja2dyb3VuZC53aWR0aCAtIHRoaXMua25vYi53aWR0aDtcbn1cblxuXG4vKipcbiAqIEdldCB2YWx1ZS5cbiAqIEBtZXRob2QgZ2V0VmFsdWVcbiAqL1xuU2xpZGVyLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhY3Rpb24gPSB0aGlzLmtub2IucG9zaXRpb24ueC8odGhpcy5iYWNrZ3JvdW5kLndpZHRoIC0gdGhpcy5rbm9iLndpZHRoKTtcblxuXHRyZXR1cm4gZnJhY3Rpb247XG59XG5cblxuLyoqXG4gKiBHZXQgdmFsdWUuXG4gKiBAbWV0aG9kIGdldFZhbHVlXG4gKi9cblNsaWRlci5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHR0aGlzLmtub2IueCA9IHRoaXMuYmFja2dyb3VuZC5wb3NpdGlvbi54ICsgdmFsdWUqKHRoaXMuYmFja2dyb3VuZC53aWR0aCAtIHRoaXMua25vYi53aWR0aCk7XG5cblx0dGhpcy52YWxpZGF0ZVZhbHVlKCk7XG5cdHJldHVybiB0aGlzLmdldFZhbHVlKCk7XG59XG5cblxuLyoqXG4gKiBTaG93LlxuICogQG1ldGhvZCBzaG93XG4gKi9cblNsaWRlci5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXHRpZih0aGlzLmZhZGVUd2VlbiAhPSBudWxsKVxuXHRcdHRoaXMuZmFkZVR3ZWVuLnN0b3AoKTtcblx0dGhpcy5mYWRlVHdlZW4gPSBuZXcgVFdFRU4uVHdlZW4odGhpcylcblx0XHRcdC50byh7YWxwaGE6IDF9LCAyNTApXG5cdFx0XHQuc3RhcnQoKTtcbn1cblxuLyoqXG4gKiBIaWRlLlxuICogQG1ldGhvZCBoaWRlXG4gKi9cblNsaWRlci5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuXHRpZih0aGlzLmZhZGVUd2VlbiAhPSBudWxsKVxuXHRcdHRoaXMuZmFkZVR3ZWVuLnN0b3AoKTtcblx0dGhpcy5mYWRlVHdlZW4gPSBuZXcgVFdFRU4uVHdlZW4odGhpcylcblx0XHRcdC50byh7YWxwaGE6IDB9LCAyNTApXG5cdFx0XHQub25Db21wbGV0ZSh0aGlzLm9uSGlkZGVuLmJpbmQodGhpcykpXG5cdFx0XHQuc3RhcnQoKTtcbn1cblxuLyoqXG4gKiBPbiBoaWRkZW4uXG4gKiBAbWV0aG9kIG9uSGlkZGVuXG4gKi9cblNsaWRlci5wcm90b3R5cGUub25IaWRkZW4gPSBmdW5jdGlvbigpIHtcblx0dGhpcy52aXNpYmxlID0gZmFsc2U7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTbGlkZXI7XG4iLCJ2YXIgdXJsID0gcmVxdWlyZShcInVybFwiKTtcblxuLyoqXG4gKiBVUkwgdXRpbGl0eS5cbiAqIEBjbGFzcyBVcmxVdGlsXG4gKi9cbmZ1bmN0aW9uIFVybFV0aWwoKSB7XG5cdHRocm93IG5ldyBFcnJvcihcInN0YXRpY1wiKTtcbn1cblxuLyoqXG4gKiBNYWtlIGFic29sdXRlIHVybC5cbiAqIEBtZXRob2QgbWFrZUFic29sdXRlXG4gKi9cblVybFV0aWwubWFrZUFic29sdXRlID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdHZhciBwYXJzZWRVcmwgPSB1cmwucGFyc2UodGFyZ2V0KTtcblxuXHRpZiAocGFyc2VkVXJsLnByb3RvY29sKVxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0aWYgKHRhcmdldC5jaGFyQXQoMCkgPT0gXCIvXCIpIHtcblx0XHR2YXIgdSA9IHVybC5wYXJzZSh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cblx0XHR1LnBhdGhuYW1lID0gdGFyZ2V0O1xuXG5cdFx0cmV0dXJuIHVybC5mb3JtYXQodSk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIHBhdGg7XG5cdFx0cGF0aCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLnN1YnN0cmluZygwLCB3aW5kb3cubG9jYXRpb24uaHJlZi5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcblx0XHRyZXR1cm4gcGF0aCArIHRhcmdldDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFVybFV0aWw7IiwiLyoqXG4gKiBVdGlsaXRpZXMuXG4gKiBAbW9kdWxlIHV0aWxzXG4gKi9cblxudmFyIFBJWEkgPSByZXF1aXJlKFwicGl4aS5qc1wiKTtcbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKFwieWFlZFwiKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCJpbmhlcml0c1wiKTtcblxuLyoqXG4gKiBCdXR0b24uXG4gKiBAY2xhc3MgQnV0dG9uXG4gKi9cbmZ1bmN0aW9uIEJ1dHRvbihjb250ZW50KSB7XG5cdFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKHRoaXMpO1xuXG5cdGlmIChjb250ZW50KVxuXHRcdHRoaXMuYWRkQ2hpbGQoY29udGVudCk7XG5cblx0dGhpcy5pbnRlcmFjdGl2ZSA9IHRydWU7XG5cdHRoaXMuYnV0dG9uTW9kZSA9IHRydWU7XG5cblx0dGhpcy5tb3VzZW92ZXIgPSB0aGlzLm9uTW91c2VvdmVyLmJpbmQodGhpcyk7XG5cdHRoaXMubW91c2VvdXQgPSB0aGlzLnRvdWNoZW5kID0gdGhpcy50b3VjaGVuZG91dHNpZGUgPSB0aGlzLm9uTW91c2VvdXQuYmluZCh0aGlzKTtcblx0dGhpcy5tb3VzZWRvd24gPSB0aGlzLnRvdWNoc3RhcnQgPSB0aGlzLm9uTW91c2Vkb3duLmJpbmQodGhpcyk7XG5cdHRoaXMubW91c2V1cCA9IHRoaXMub25Nb3VzZXVwLmJpbmQodGhpcyk7XG5cdHRoaXMuY2xpY2sgPSB0aGlzLnRhcCA9IHRoaXMub25DbGljay5iaW5kKHRoaXMpO1xuXG5cdHRoaXMuY29sb3JNYXRyaXhGaWx0ZXIgPSBuZXcgUElYSS5Db2xvck1hdHJpeEZpbHRlcigpO1xuXHR0aGlzLmNvbG9yTWF0cml4RmlsdGVyLm1hdHJpeCA9IFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcblxuXHR0aGlzLmZpbHRlcnMgPSBbdGhpcy5jb2xvck1hdHJpeEZpbHRlcl07XG59XG5cbmluaGVyaXRzKEJ1dHRvbiwgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyKTtcbkV2ZW50RGlzcGF0Y2hlci5pbml0KEJ1dHRvbik7XG5cbkJ1dHRvbi5MSUdIVF9NQVRSSVggPSBbMS41LCAwLCAwLCAwLCAwLCAxLjUsIDAsIDAsIDAsIDAsIDEuNSwgMCwgMCwgMCwgMCwgMV07XG5CdXR0b24uREFSS19NQVRSSVggPSBbLjc1LCAwLCAwLCAwLCAwLCAuNzUsIDAsIDAsIDAsIDAsIC43NSwgMCwgMCwgMCwgMCwgMV07XG5CdXR0b24uREVGQVVMVF9NQVRSSVggPSBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV07XG5cbkJ1dHRvbi5DTElDSyA9IFwiY2xpY2tcIjtcblxuLyoqXG4gKiBNb3VzZSBvdmVyLlxuICogQG1ldGhvZCBvbk1vdXNlb3ZlclxuICogQHByaXZhdGVcbiAqL1xuQnV0dG9uLnByb3RvdHlwZS5vbk1vdXNlb3ZlciA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLmNvbG9yTWF0cml4RmlsdGVyLm1hdHJpeCA9IEJ1dHRvbi5MSUdIVF9NQVRSSVg7XG59XG5cbi8qKlxuICogTW91c2Ugb3V0LlxuICogQG1ldGhvZCBvbk1vdXNlb3V0XG4gKiBAcHJpdmF0ZVxuICovXG5CdXR0b24ucHJvdG90eXBlLm9uTW91c2VvdXQgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5jb2xvck1hdHJpeEZpbHRlci5tYXRyaXggPSBCdXR0b24uREVGQVVMVF9NQVRSSVg7XG59XG5cbi8qKlxuICogTW91c2UgZG93bi5cbiAqIEBtZXRob2Qgb25Nb3VzZWRvd25cbiAqIEBwcml2YXRlXG4gKi9cbkJ1dHRvbi5wcm90b3R5cGUub25Nb3VzZWRvd24gPSBmdW5jdGlvbigpIHtcblx0dGhpcy5jb2xvck1hdHJpeEZpbHRlci5tYXRyaXggPSBCdXR0b24uREFSS19NQVRSSVg7XG59XG5cbi8qKlxuICogTW91c2UgdXAuXG4gKiBAbWV0aG9kIG9uTW91c2V1cFxuICogQHByaXZhdGVcbiAqL1xuQnV0dG9uLnByb3RvdHlwZS5vbk1vdXNldXAgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5jb2xvck1hdHJpeEZpbHRlci5tYXRyaXggPSBCdXR0b24uTElHSFRfTUFUUklYO1xufVxuXG4vKipcbiAqIENsaWNrLlxuICogQG1ldGhvZCBvbkNsaWNrXG4gKiBAcHJpdmF0ZVxuICovXG5CdXR0b24ucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbigpIHtcblx0dGhpcy50cmlnZ2VyKEJ1dHRvbi5DTElDSyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQnV0dG9uOyIsIi8qKlxuICogVXRpbGl0aWVzLlxuICogQG1vZHVsZSB1dGlsc1xuICovXG5cbnZhciBQSVhJID0gcmVxdWlyZShcInBpeGkuanNcIik7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiaW5oZXJpdHNcIik7XG5cbi8qKlxuICogQSB0ZXh0IHRoYXQgY291bnRzIGRvd24uXG4gKiBAY2xhc3MgQ291bnRkb3duVGV4dFxuICovXG5mdW5jdGlvbiBDb3VudGRvd25UZXh0KHRleHQsIHN0eWxlKSB7XG5cdFBJWEkuVGV4dC5jYWxsKHRoaXMsIHRleHQsIHN0eWxlKTtcblxuXHR0aGlzLnRpbWVMZWZ0ID0gMDtcblx0dGhpcy50aW1lckludGVydmFsID0gbnVsbDtcblx0dGhpcy5zZXRUZXh0KHRleHQpO1xufVxuXG5pbmhlcml0cyhDb3VudGRvd25UZXh0LCBQSVhJLlRleHQpO1xuXG4vKipcbiAqIE92ZXJyaWRlIHRoZSBzZXRUZXh0IGZ1bmN0aW9uLlxuICogQG1ldGhvZCBzZXRUZXh0XG4gKi9cbkNvdW50ZG93blRleHQucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG5cdHRoaXMuZm9ybWF0ID0gdGV4dDtcblxuXHR0aGlzLnVwZGF0ZUZvcm1hdHRlZFRleHQoKTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgdGhlIGFjdHVhbCB0ZXh0LlxuICogQG1ldGhvZCB1cGRhdGVGb3JtYXR0ZWRUZXh0XG4gKi9cbkNvdW50ZG93blRleHQucHJvdG90eXBlLnVwZGF0ZUZvcm1hdHRlZFRleHQgPSBmdW5jdGlvbigpIHtcblx0dmFyIHMgPSAodGhpcy50aW1lTGVmdCAlIDYwKS50b1N0cmluZygpO1xuXHR2YXIgbSA9IChNYXRoLmZsb29yKHRoaXMudGltZUxlZnQgLyA2MCkgJSA2MCkudG9TdHJpbmcoKTtcblx0dmFyIGggPSAoTWF0aC5mbG9vcih0aGlzLnRpbWVMZWZ0IC8gKDYwICogNjApKSkudG9TdHJpbmcoKTtcblxuXHRpZiAocy5sZW5ndGggPCAyKVxuXHRcdHMgPSBcIjBcIiArIHM7XG5cblx0aWYgKG0ubGVuZ3RoIDwgMilcblx0XHRtID0gXCIwXCIgKyBtO1xuXG5cdGlmIChoID09IFwiMFwiKVxuXHRcdGggPSBcIlwiO1xuXG5cdGVsc2Uge1xuXHRcdGlmIChoLmxlbmd0aCA8IDIpXG5cdFx0XHRoID0gXCIwXCIgKyBoO1xuXG5cdFx0aCArPSBcIjpcIjtcblx0fVxuXG5cdHZhciB0ZXh0ID0gdGhpcy5mb3JtYXQudG9TdHJpbmcoKS5yZXBsYWNlKFwiJXRcIiwgaCArIG0gKyBcIjpcIiArIHMpO1xuXG5cdC8vY29uc29sZS5sb2coXCJ1cGRhdGUgdGV4dDogXCIgKyB0ZXh0KTtcblxuXHRQSVhJLlRleHQucHJvdG90eXBlLnNldFRleHQuY2FsbCh0aGlzLCB0ZXh0KTtcbn1cblxuLyoqXG4gKiBTZXQgdGltZSBsZWZ0LlxuICogQG1ldGhvZCBzZXRUaW1lTGVmdFxuICovXG5Db3VudGRvd25UZXh0LnByb3RvdHlwZS5zZXRUaW1lTGVmdCA9IGZ1bmN0aW9uKHRpbWVMZWZ0KSB7XG5cdGlmICh0aW1lTGVmdCA8IDApXG5cdFx0dGltZUxlZnQgPSAwO1xuXG5cdGlmICh0aGlzLnRpbWVySW50ZXJ2YWwpIHtcblx0XHRjbGVhckludGVydmFsKHRoaXMudGltZXJJbnRlcnZhbCk7XG5cdFx0dGhpcy50aW1lckludGVydmFsID0gbnVsbDtcblx0fVxuXG5cdHRoaXMudGltZUxlZnQgPSB0aW1lTGVmdDtcblxuXHRpZiAodGhpcy50aW1lTGVmdCA+IDApIHtcblx0XHR0aGlzLnRpbWVySW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLm9uVGltZXJJbnRlcnZhbC5iaW5kKHRoaXMpLCAxMDAwKTtcblx0fVxuXG5cdHRoaXMudXBkYXRlRm9ybWF0dGVkVGV4dCgpO1xufVxuXG4vKipcbiAqIFRpbWVyIGludGVydmFsLlxuICogQG1ldGhvZCBvblRpbWVySW50ZXJ2YWxcbiAqL1xuQ291bnRkb3duVGV4dC5wcm90b3R5cGUub25UaW1lckludGVydmFsID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMudGltZUxlZnQtLTtcblxuXHRpZiAodGhpcy50aW1lTGVmdCA8PSAwKSB7XG5cdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVySW50ZXJ2YWwpO1xuXHRcdHRoaXMudGltZXJJbnRlcnZhbCA9IG51bGw7XG5cdH1cblxuXHR0aGlzLnVwZGF0ZUZvcm1hdHRlZFRleHQoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb3VudGRvd25UZXh0OyIsIi8qKlxuICogVXRpbGl0aWVzLlxuICogQG1vZHVsZSB1dGlsc1xuICovXG5cbnZhciBQSVhJID0gcmVxdWlyZShcInBpeGkuanNcIik7XG5cbi8qKlxuICogQ3JlYXRlIGEgc3ByaXRlIHdpdGggYSBncmFkaWVudC5cbiAqIEBjbGFzcyBHcmFkaWVudFxuICovXG5mdW5jdGlvbiBHcmFkaWVudCgpIHtcblx0dGhpcy53aWR0aCA9IDEwMDtcblx0dGhpcy5oZWlnaHQgPSAxMDA7XG5cdHRoaXMuc3RvcHMgPSBbXTtcbn1cblxuLyoqXG4gKiBTZXQgc2l6ZSBvZiB0aGUgZ3JhZGllbnQuXG4gKiBAbWV0aG9kIHNldFNpemVcbiAqL1xuR3JhZGllbnQucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbih3LCBoKSB7XG5cdHRoaXMud2lkdGggPSB3O1xuXHR0aGlzLmhlaWdodCA9IGg7XG59XG5cbi8qKlxuICogQWRkIGNvbG9yIHN0b3AuXG4gKiBAbWV0aG9kIGFkZENvbG9yU3RvcFxuICovXG5HcmFkaWVudC5wcm90b3R5cGUuYWRkQ29sb3JTdG9wID0gZnVuY3Rpb24od2VpZ2h0LCBjb2xvcikge1xuXHR0aGlzLnN0b3BzLnB1c2goe1xuXHRcdHdlaWdodDogd2VpZ2h0LFxuXHRcdGNvbG9yOiBjb2xvclxuXHR9KTtcbn1cblxuLyoqXG4gKiBSZW5kZXIgdGhlIHNwcml0ZS5cbiAqIEBtZXRob2QgY3JlYXRlU3ByaXRlXG4gKi9cbkdyYWRpZW50LnByb3RvdHlwZS5jcmVhdGVTcHJpdGUgPSBmdW5jdGlvbigpIHtcblx0Ly9jb25zb2xlLmxvZyhcInJlbmRlcmluZyBncmFkaWVudC4uLlwiKTtcblx0dmFyIGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXHRjLndpZHRoID0gdGhpcy53aWR0aDtcblx0Yy5oZWlnaHQgPSB0aGlzLmhlaWdodDtcblxuXHR2YXIgY3R4ID0gYy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdHZhciBncmQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgMCwgdGhpcy5oZWlnaHQpO1xuXHR2YXIgaTtcblxuXHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5zdG9wcy5sZW5ndGg7IGkrKylcblx0XHRncmQuYWRkQ29sb3JTdG9wKHRoaXMuc3RvcHNbaV0ud2VpZ2h0LCB0aGlzLnN0b3BzW2ldLmNvbG9yKTtcblxuXHRjdHguZmlsbFN0eWxlID0gZ3JkO1xuXHRjdHguZmlsbFJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG5cdHJldHVybiBuZXcgUElYSS5TcHJpdGUoUElYSS5UZXh0dXJlLmZyb21DYW52YXMoYykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdyYWRpZW50OyIsInZhciBUaGVuYWJsZSA9IHJlcXVpcmUoXCJ0aW5wXCIpO1xuXG4vKipcbiAqIFdyYXBzIFhNTEh0dHBSZXF1ZXN0LlxuICogQGNsYXNzIEh0dHBSZXF1ZXN0XG4gKi9cbmZ1bmN0aW9uIEh0dHBSZXF1ZXN0KHVybCkge1xuXHR0aGlzLnVybCA9IHVybDtcblx0dGhpcy50aGVuYWJsZSA9IG51bGw7XG5cdHRoaXMucmVzdWx0VHlwZSA9IG51bGw7XG59XG5cbi8qKlxuICogU2V0IHJlc3VsdCB0eXBlLlxuICogQG1ldGhvZCBzZXRSZXN1bHRUeXBlXG4gKi9cbkh0dHBSZXF1ZXN0LnByb3RvdHlwZS5zZXRSZXN1bHRUeXBlID0gZnVuY3Rpb24odHlwZSkge1xuXHR0aGlzLnJlc3VsdFR5cGUgPSB0eXBlO1xufVxuXG4vKipcbiAqIFNldCB1cmwuXG4gKiBAbWV0aG9kIHNldFVybFxuICovXG5IdHRwUmVxdWVzdC5wcm90b3R5cGUuc2V0VXJsID0gZnVuY3Rpb24odXJsKSB7XG5cdHRoaXMudXJsID0gdXJsO1xufVxuXG4vKipcbiAqIFNlbmQuXG4gKiBAbWV0aG9kIHNlbmRcbiAqL1xuSHR0cFJlcXVlc3QucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbih1cmwpIHtcblx0aWYgKHRoaXMudGhlbmFibGUpXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdCBhbHJlYWR5IHNlbnRcIik7XG5cblx0aWYgKHVybClcblx0XHR0aGlzLnVybCA9IHVybDtcblxuXHR0aGlzLnRoZW5hYmxlID0gbmV3IFRoZW5hYmxlKCk7XG5cblx0dGhpcy5yZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdHRoaXMucmVxdWVzdC5vcGVuKFwiR0VUXCIsIHRoaXMudXJsLCB0cnVlKTtcblxuXHR0aGlzLnJlcXVlc3Qub25sb2FkID0gdGhpcy5vblJlcXVlc3RMb2FkLmJpbmQodGhpcyk7XG5cdHRoaXMucmVxdWVzdC5vbmVycm9yID0gdGhpcy5vblJlcXVlc3RFcnJvci5iaW5kKHRoaXMpO1xuXG5cdHRoaXMucmVxdWVzdC5zZW5kKCk7XG5cblx0cmV0dXJuIHRoaXMudGhlbmFibGU7XG59XG5cbi8qKlxuICogQG1ldGhvZCBvblJlcXVlc3RMb2FkXG4gKiBAcHJpdmF0ZVxuICovXG5IdHRwUmVxdWVzdC5wcm90b3R5cGUub25SZXF1ZXN0TG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5yZXF1ZXN0LnN0YXR1cyAhPSAyMDApIHtcblx0XHR0aGlzLnRoZW5hYmxlLnJlamVjdCh0aGlzLnJlcXVlc3Quc3RhdHVzKTtcblx0XHR0aGlzLnRoZW5hYmxlID0gbnVsbDtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgcmVzdWx0ID0gdGhpcy5yZXF1ZXN0LnJlc3BvbnNlVGV4dDtcblxuXHRzd2l0Y2ggKHRoaXMucmVzdWx0VHlwZSkge1xuXHRcdGNhc2UgXCJqc29uXCI6XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXN1bHQgPSBKU09OLnBhcnNlKHRoaXMucmVxdWVzdC5yZXNwb25zZVRleHQpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHR0aGlzLnRoZW5hYmxlLnJlamVjdChcIkpTT04ucGFyc2U6IFwiK2UpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0fVxuXG5cdHRoaXMudGhlbmFibGUucmVzb2x2ZShyZXN1bHQpO1xufVxuXG4vKipcbiAqIEBtZXRob2Qgb25SZXF1ZXN0RXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbkh0dHBSZXF1ZXN0LnByb3RvdHlwZS5vblJlcXVlc3RFcnJvciA9IGZ1bmN0aW9uKGUpIHtcblx0dGhpcy5yZXF1ZXN0ID0gbnVsbDtcblxuXHR0aGlzLnRoZW5hYmxlLnJlamVjdChlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIdHRwUmVxdWVzdDsiLCIvKipcbiAqIENsaWVudC5cbiAqIEBtb2R1bGUgY2xpZW50XG4gKi9cblxudmFyIFBJWEkgPSByZXF1aXJlKFwicGl4aS5qc1wiKTtcbnZhciBQaXhpQXBwID0gcmVxdWlyZShcInBpeGlhcHBcIik7XG52YXIgTmV0UG9rZXJDbGllbnRWaWV3ID0gcmVxdWlyZShcIi4uL3ZpZXcvTmV0UG9rZXJDbGllbnRWaWV3XCIpO1xudmFyIE5ldFBva2VyQ2xpZW50Q29udHJvbGxlciA9IHJlcXVpcmUoXCIuLi9jb250cm9sbGVyL05ldFBva2VyQ2xpZW50Q29udHJvbGxlclwiKTtcbnZhciBNZXNzYWdlV2ViU29ja2V0Q29ubmVjdGlvbiA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9NZXNzYWdlV2ViU29ja2V0Q29ubmVjdGlvblwiKTtcbnZhciBNZXNzYWdlUmVxdWVzdENvbm5lY3Rpb24gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvTWVzc2FnZVJlcXVlc3RDb25uZWN0aW9uXCIpO1xudmFyIFByb3RvQ29ubmVjdGlvbiA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9Qcm90b0Nvbm5lY3Rpb25cIik7XG52YXIgTG9hZGluZ1NjcmVlbiA9IHJlcXVpcmUoXCIuLi92aWV3L0xvYWRpbmdTY3JlZW5cIik7XG52YXIgU3RhdGVDb21wbGV0ZU1lc3NhZ2UgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vbWVzc2FnZXMvU3RhdGVDb21wbGV0ZU1lc3NhZ2VcIik7XG52YXIgSW5pdE1lc3NhZ2UgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vbWVzc2FnZXMvSW5pdE1lc3NhZ2VcIik7XG52YXIgUmVzb3VyY2VzID0gcmVxdWlyZShcIi4uL3Jlc291cmNlcy9SZXNvdXJjZXNcIik7XG52YXIgVmlld0NvbmZpZyA9IHJlcXVpcmUoXCIuLi9yZXNvdXJjZXMvVmlld0NvbmZpZ1wiKTtcbnZhciB1cmwgPSByZXF1aXJlKFwidXJsXCIpO1xudmFyIFRXRUVOID0gcmVxdWlyZShcInR3ZWVuLmpzXCIpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xudmFyIFVybFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvVXJsVXRpbFwiKTtcbnZhciBEZWZhdWx0U2tpbiA9IHJlcXVpcmUoXCIuLi9yZXNvdXJjZXMvRGVmYXVsdFNraW5cIik7XG5cbi8qKlxuICogTWFpbiBlbnRyeSBwb2ludCBmb3IgY2xpZW50LlxuICogQGNsYXNzIE5ldFBva2VyQ2xpZW50XG4gKi9cbmZ1bmN0aW9uIE5ldFBva2VyQ2xpZW50KCkge1xuXHRQaXhpQXBwLmNhbGwodGhpcywgOTYwLCA3MjApO1xuXG5cdHRoaXMudmVydGljYWxBbGlnbiA9IFBpeGlBcHAuVE9QO1xuXG5cdHRoaXMucmVzb3VyY2VzID0gbmV3IFJlc291cmNlcygpO1xuXHR0aGlzLnJlc291cmNlcy5hZGRTa2luU291cmNlKERlZmF1bHRTa2luKTtcblx0dGhpcy5yZXNvdXJjZXMuYWRkU3ByaXRlU2hlZXQoXCJuZXRwb2tlcmNsaWVudC5zcHJpdGVzaGVldC5qc29uXCIpO1xuXG5cdHRoaXMubG9hZGluZ1NjcmVlbiA9IG5ldyBMb2FkaW5nU2NyZWVuKCk7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5sb2FkaW5nU2NyZWVuKTtcblx0dGhpcy5lbnRlckFwcFN0YXRlKFwiTE9BRElOR1wiLCAwKTtcblx0dGhpcy5sb2FkaW5nU2NyZWVuLnNob3coXCJMT0FESU5HXCIpO1xuXG5cdHRoaXMudXJsID0gbnVsbDtcblx0dGhpcy50YWJsZUlkID0gbnVsbDtcblx0dGhpcy50b3VybmFtZW50SWQgPSBudWxsO1xuXHR0aGlzLnZpZXdDb25maWcgPSBuZXcgVmlld0NvbmZpZygpO1xuXG5cdHRoaXMub24oXCJmcmFtZVwiLCBUV0VFTi51cGRhdGUpO1xufVxuXG5pbmhlcml0cyhOZXRQb2tlckNsaWVudCwgUGl4aUFwcCk7XG5cbi8qKlxuICogU2V0IHVybC5cbiAqIEBtZXRob2Qgc2V0VXJsXG4gKi9cbk5ldFBva2VyQ2xpZW50LnByb3RvdHlwZS5zZXRVcmwgPSBmdW5jdGlvbih1cmwpIHtcblx0dGhpcy51cmwgPSB1cmw7XG59XG5cbi8qKlxuICogU2V0IHRhYmxlIGlkLlxuICogQG1ldGhvZCBzZXRUYWJsZUlkXG4gKi9cbk5ldFBva2VyQ2xpZW50LnByb3RvdHlwZS5zZXRUYWJsZUlkID0gZnVuY3Rpb24odGFibGVJZCkge1xuXHR0aGlzLnRhYmxlSWQgPSB0YWJsZUlkO1xufVxuXG4vKipcbiAqIFNldCB0b3VybmFtZW50IGlkLlxuICogQG1ldGhvZCBzZXRUb3VybmFtZW50SWRcbiAqL1xuTmV0UG9rZXJDbGllbnQucHJvdG90eXBlLnNldFRvdXJuYW1lbnRJZCA9IGZ1bmN0aW9uKHRvdXJuYW1lbnRJZCkge1xuXHR0aGlzLnRvdXJuYW1lbnRJZCA9IHRvdXJuYW1lbnRJZDtcbn1cblxuLyoqXG4gKiBTZXQgdmlldyBjYXNlLlxuICogQG1ldGhvZCBzZXRWaWV3Q2FzZVxuICovXG5OZXRQb2tlckNsaWVudC5wcm90b3R5cGUuc2V0Vmlld0Nhc2UgPSBmdW5jdGlvbih2aWV3Q2FzZSkge1xuXHRjb25zb2xlLmxvZyhcIioqKioqKiBydW5uaW5nIHZpZXcgY2FzZTogXCIgKyB2aWV3Q2FzZSk7XG5cdHRoaXMudmlld0Nhc2UgPSB2aWV3Q2FzZTtcbn1cblxuLyoqXG4gKiBTZXQgdG9rZW4uXG4gKiBAbWV0aG9kIHNldFRva2VuXG4gKi9cbk5ldFBva2VyQ2xpZW50LnByb3RvdHlwZS5zZXRUb2tlbiA9IGZ1bmN0aW9uKHRva2VuKSB7XG5cdHRoaXMudG9rZW4gPSB0b2tlbjtcbn1cblxuLyoqXG4gKiBBZGQgc2tpbiBzb3VyY2UuXG4gKiBAbWV0aG9kIGFkZFNraW5Tb3VyY2VcbiAqL1xuTmV0UG9rZXJDbGllbnQucHJvdG90eXBlLmFkZFNraW5Tb3VyY2UgPSBmdW5jdGlvbihza2luKSB7XG5cdHRoaXMucmVzb3VyY2VzLmFkZFNraW5Tb3VyY2Uoc2tpbik7XG59XG5cbi8qKlxuICogQWRkIHNwcml0ZSBzaGVldC5cbiAqIEBtZXRob2QgYWRkU3ByaXRlU2hlZXRcbiAqL1xuTmV0UG9rZXJDbGllbnQucHJvdG90eXBlLmFkZFNwcml0ZVNoZWV0ID0gZnVuY3Rpb24oc3ByaXRlU2hlZXQpIHtcblx0dGhpcy5yZXNvdXJjZXMuYWRkU3ByaXRlU2hlZXQoc3ByaXRlU2hlZXQpO1xufVxuXG4vKipcbiAqIFNldCBzcHJpdGUgc2hlZXQuXG4gKiBAbWV0aG9kIHNldFNwcml0ZVNoZWV0XG4gKi9cbk5ldFBva2VyQ2xpZW50LnByb3RvdHlwZS5zZXRTcHJpdGVTaGVldCA9IGZ1bmN0aW9uKHNwcml0ZVNoZWV0KSB7XG5cdHRoaXMucmVzb3VyY2VzLnNldFNwcml0ZVNoZWV0KHNwcml0ZVNoZWV0KTtcbn1cblxuLyoqXG4gKiBSdW4uXG4gKiBAbWV0aG9kIHJ1blxuICovXG5OZXRQb2tlckNsaWVudC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG5cdC8vY29uc29sZS5sb2coXCJsb2FkaW5nIHJlc291cmNlcy4uLi4uXCIpO1xuXHR0aGlzLmVudGVyQXBwU3RhdGUoXCJMT0FESU5HIFJFU09VUkNFU1wiLCA1MCk7XG5cblx0dGhpcy5yZXNvdXJjZXMubG9hZCgpLnRoZW4oXG5cdFx0dGhpcy5vblJlc291cmNlc0xvYWRlZC5iaW5kKHRoaXMpLFxuXHRcdHRoaXMub25SZXNvdXJjZXNFcnJvci5iaW5kKHRoaXMpXG5cdCk7XG59XG5cbi8qKlxuICogRXJyb3Igd2hpbGUgbG9hZGluZyByZXNvdXJjZXMuXG4gKiBAbWV0aG9kIG9uUmVzb3VyY2VzRXJyb3JcbiAqL1xuTmV0UG9rZXJDbGllbnQucHJvdG90eXBlLm9uUmVzb3VyY2VzRXJyb3IgPSBmdW5jdGlvbigpIHtcblx0Y29uc29sZS5sb2coXCJyZXNvdXJjZSBlcnJvclwiKTtcblxuXHR0aGlzLmVudGVyQXBwU3RhdGUoXCJFUlJPUiBMT0FESU5HIFJFU09VUkNFU1wiKTtcbn1cblxuLyoqXG4gKiBBc3NldHMgbG9hZGVkLCBjb25uZWN0LlxuICogQG1ldGhvZCBvbkFzc2V0TG9hZGVyQ29tcGxldGVcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFBva2VyQ2xpZW50LnByb3RvdHlwZS5vblJlc291cmNlc0xvYWRlZCA9IGZ1bmN0aW9uKCkge1xuXHQvL2NvbnNvbGUubG9nKFwicmVzb3VyY2VzIGxvYWRlZCBjb21wbGV0ZS4uLlwiKTtcblxuXHR0aGlzLm5ldFBva2VyQ2xpZW50VmlldyA9IG5ldyBOZXRQb2tlckNsaWVudFZpZXcodGhpcy52aWV3Q29uZmlnLCB0aGlzLnJlc291cmNlcyk7XG5cdHRoaXMuYWRkQ2hpbGRBdCh0aGlzLm5ldFBva2VyQ2xpZW50VmlldywgMCk7XG5cblx0dGhpcy5uZXRQb2tlckNsaWVudENvbnRyb2xsZXIgPSBuZXcgTmV0UG9rZXJDbGllbnRDb250cm9sbGVyKHRoaXMubmV0UG9rZXJDbGllbnRWaWV3KTtcblx0dGhpcy5jb25uZWN0KCk7XG59XG5cbi8qKlxuICogQ29ubmVjdC5cbiAqIEBtZXRob2QgY29ubmVjdFxuICogQHByaXZhdGVcbiAqL1xuTmV0UG9rZXJDbGllbnQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbigpIHtcblx0aWYgKCF0aGlzLnVybCkge1xuXHRcdHRoaXMuZW50ZXJBcHBTdGF0ZShcIk5FRUQgVVJMXCIpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBwYXJzZWRVcmwgPSB1cmwucGFyc2UodGhpcy51cmwpO1xuXG5cdGNvbnNvbGUubG9nKHBhcnNlZFVybCk7XG5cblx0aWYgKCFwYXJzZWRVcmwucHJvdG9jb2wgfHwgcGFyc2VkVXJsLnByb3RvY29sID09IFwiaHR0cDpcIiB8fCBwYXJzZWRVcmwucHJvdG9jb2wgPT0gXCJodHRwczpcIikge1xuXHRcdHRoaXMudXJsID0gVXJsVXRpbC5tYWtlQWJzb2x1dGUodGhpcy51cmwpO1xuXHRcdHRoaXMuY29ubmVjdGlvbiA9IG5ldyBNZXNzYWdlUmVxdWVzdENvbm5lY3Rpb24oKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLmNvbm5lY3Rpb24gPSBuZXcgTWVzc2FnZVdlYlNvY2tldENvbm5lY3Rpb24oKTtcblx0fVxuXG5cdHRoaXMuY29ubmVjdGlvbi5vbihNZXNzYWdlV2ViU29ja2V0Q29ubmVjdGlvbi5DT05ORUNULCB0aGlzLm9uQ29ubmVjdGlvbkNvbm5lY3QsIHRoaXMpO1xuXHR0aGlzLmNvbm5lY3Rpb24ub24oTWVzc2FnZVdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0UsIHRoaXMub25Db25uZWN0aW9uQ2xvc2UsIHRoaXMpO1xuXG5cdGNvbnNvbGUubG9nKFwiQ29ubmVjdGluZyB0bzogXCIgKyB0aGlzLnVybCk7XG5cblx0dGhpcy5lbnRlckFwcFN0YXRlKFwiQ09OTkVDVElOR1wiLCA2NSk7XG5cdHRoaXMuY29ubmVjdGlvbi5jb25uZWN0KHRoaXMudXJsKTtcbn1cblxuLyoqXG4gKiBDb25uZWN0aW9uIGNvbXBsZXRlLlxuICogQG1ldGhvZCBvbkNvbm5lY3Rpb25Db25uZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5OZXRQb2tlckNsaWVudC5wcm90b3R5cGUub25Db25uZWN0aW9uQ29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuXHRjb25zb2xlLmxvZyhcIioqKiogY29ubmVjdGVkXCIpO1xuXHR0aGlzLnByb3RvQ29ubmVjdGlvbiA9IG5ldyBQcm90b0Nvbm5lY3Rpb24odGhpcy5jb25uZWN0aW9uKTtcblx0dGhpcy5wcm90b0Nvbm5lY3Rpb24uYWRkTWVzc2FnZUhhbmRsZXIoU3RhdGVDb21wbGV0ZU1lc3NhZ2UsIHRoaXMub25TdGF0ZUNvbXBsZXRlTWVzc2FnZSwgdGhpcyk7XG5cdHRoaXMubmV0UG9rZXJDbGllbnRDb250cm9sbGVyLnNldFByb3RvQ29ubmVjdGlvbih0aGlzLnByb3RvQ29ubmVjdGlvbik7XG5cdHRoaXMuZW50ZXJBcHBTdGF0ZShcIklOSVRJQUxJWklOR1wiLCA4MCk7XG5cblx0dmFyIGluaXRNZXNzYWdlID0gbmV3IEluaXRNZXNzYWdlKHRoaXMudG9rZW4pO1xuXG5cdGlmICh0aGlzLnRhYmxlSWQpXG5cdFx0aW5pdE1lc3NhZ2Uuc2V0VGFibGVJZCh0aGlzLnRhYmxlSWQpO1xuXG5cdGlmICh0aGlzLnRvdXJuYW1lbnRJZClcblx0XHRpbml0TWVzc2FnZS5zZXRUb3VybmFtZW50SWQodGhpcy50b3VybmFtZW50SWQpO1xuXG5cdGlmICh0aGlzLnZpZXdDYXNlKVxuXHRcdGluaXRNZXNzYWdlLnNldFZpZXdDYXNlKHRoaXMudmlld0Nhc2UpO1xuXG5cdHRoaXMucHJvdG9Db25uZWN0aW9uLnNlbmQoaW5pdE1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIFN0YXRlIGNvbXBsZXRlLlxuICogQG1ldGhvZCBvblN0YXRlQ29tcGxldGVNZXNzYWdlXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRQb2tlckNsaWVudC5wcm90b3R5cGUub25TdGF0ZUNvbXBsZXRlTWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLmVudGVyQXBwU3RhdGUobnVsbCk7XG59XG5cbi8qKlxuICogQ29ubmVjdGlvbiBjbG9zZWQuXG4gKiBAbWV0aG9kIG9uQ29ubmVjdGlvbkNsb3NlXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRQb2tlckNsaWVudC5wcm90b3R5cGUub25Db25uZWN0aW9uQ2xvc2UgPSBmdW5jdGlvbigpIHtcblx0Y29uc29sZS5sb2coXCIqKioqIGNvbm5lY3Rpb24gY2xvc2VkXCIpO1xuXHRpZiAodGhpcy5wcm90b0Nvbm5lY3Rpb24pXG5cdFx0dGhpcy5wcm90b0Nvbm5lY3Rpb24ucmVtb3ZlTWVzc2FnZUhhbmRsZXIoU3RhdGVDb21wbGV0ZU1lc3NhZ2UsIHRoaXMub25TdGF0ZUNvbXBsZXRlTWVzc2FnZSwgdGhpcyk7XG5cblx0dGhpcy5wcm90b0Nvbm5lY3Rpb24gPSBudWxsO1xuXHR0aGlzLm5ldFBva2VyQ2xpZW50Q29udHJvbGxlci5zZXRQcm90b0Nvbm5lY3Rpb24obnVsbCk7XG5cdHRoaXMuZW50ZXJBcHBTdGF0ZShcIkNPTk5FQ1RJT04gRVJST1JcIik7XG5cdHNldFRpbWVvdXQodGhpcy5jb25uZWN0LmJpbmQodGhpcyksIDMwMDApO1xufVxuXG4vKipcbiAqIEVudGVyIGFwcCBzdGF0ZS5cbiAqIEBtZXRob2QgZW50ZXJBcHBTdGF0ZVxuICogQHByaXZhdGVcbiAqL1xuTmV0UG9rZXJDbGllbnQucHJvdG90eXBlLmVudGVyQXBwU3RhdGUgPSBmdW5jdGlvbihtZXNzYWdlLCBwcm9ncmVzcykge1xuXHRpZiAobWVzc2FnZSlcblx0XHR0aGlzLmxvYWRpbmdTY3JlZW4uc2hvdyhtZXNzYWdlKTtcblxuXHRlbHNlXG5cdFx0dGhpcy5sb2FkaW5nU2NyZWVuLmhpZGUoKTtcblxuXHR0aGlzLnRyaWdnZXIoe1xuXHRcdHR5cGU6IFwiYXBwU3RhdGVDaGFuZ2VcIixcblx0XHRtZXNzYWdlOiBtZXNzYWdlLFxuXHRcdHByb2dyZXNzOiBwcm9ncmVzc1xuXHR9KTtcbn1cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGdldCBhbGwgcXVlcnkgc3RyaW5nIHBhcmFtcy5cbiAqIEBtZXRob2QgZ2V0UXVlcnlTdHJpbmdQYXJhbXNcbiAqIEBzdGF0aWNcbiAqL1xuTmV0UG9rZXJDbGllbnQuZ2V0UXVlcnlTdHJpbmdQYXJhbXMgPSBmdW5jdGlvbigpIHtcblx0dmFyIHBhcmFtcyA9IHt9O1xuXHQoZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgbWF0Y2gsXG5cdFx0XHRwbCA9IC9cXCsvZywgLy8gUmVnZXggZm9yIHJlcGxhY2luZyBhZGRpdGlvbiBzeW1ib2wgd2l0aCBhIHNwYWNlXG5cdFx0XHRzZWFyY2ggPSAvKFteJj1dKyk9PyhbXiZdKikvZyxcblx0XHRcdGRlY29kZSA9IGZ1bmN0aW9uKHMpIHtcblx0XHRcdFx0cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzLnJlcGxhY2UocGwsIFwiIFwiKSk7XG5cdFx0XHR9LFxuXHRcdFx0cXVlcnkgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKS5yZXBsYWNlKC9hbXA7L2csIFwiXCIpO1xuXG5cdFx0d2hpbGUgKG1hdGNoID0gc2VhcmNoLmV4ZWMocXVlcnkpKVxuXHRcdFx0cGFyYW1zW2RlY29kZShtYXRjaFsxXSldID0gZGVjb2RlKG1hdGNoWzJdKTtcblx0fSkoKTtcblxuXHRyZXR1cm4gcGFyYW1zO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE5ldFBva2VyQ2xpZW50OyIsIi8qKlxuICogVXRpbGl0aWVzLlxuICogQG1vZHVsZSB1dGlsc1xuICovXG5cbnZhciBQSVhJID0gcmVxdWlyZShcInBpeGkuanNcIik7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiaW5oZXJpdHNcIik7XG5cbi8qKlxuICogTmluZSBzbGljZS4gVGhpcyBpcyBhIHNwcml0ZSB0aGF0IGlzIGEgZ3JpZCwgYW5kIG9ubHkgdGhlXG4gKiBtaWRkbGUgcGFydCBzdHJldGNoZXMgd2hlbiBzY2FsaW5nLlxuICogQGNsYXNzIE5pbmVTbGljZVxuICovXG5mdW5jdGlvbiBOaW5lU2xpY2UodGV4dHVyZSwgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tKSB7XG5cdFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKHRoaXMpO1xuXG5cdHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG5cblx0aWYgKCF0b3ApXG5cdFx0dG9wID0gbGVmdDtcblxuXHRpZiAoIXJpZ2h0KVxuXHRcdHJpZ2h0ID0gbGVmdDtcblxuXHRpZiAoIWJvdHRvbSlcblx0XHRib3R0b20gPSB0b3A7XG5cblx0dGhpcy5sZWZ0ID0gbGVmdDtcblx0dGhpcy50b3AgPSB0b3A7XG5cdHRoaXMucmlnaHQgPSByaWdodDtcblx0dGhpcy5ib3R0b20gPSBib3R0b207XG5cblx0dGhpcy5sb2NhbFdpZHRoID0gdGV4dHVyZS53aWR0aDtcblx0dGhpcy5sb2NhbEhlaWdodCA9IHRleHR1cmUuaGVpZ2h0O1xuXG5cdHRoaXMuYnVpbGRQYXJ0cygpO1xuXHR0aGlzLnVwZGF0ZVNpemVzKCk7XG59XG5cbmluaGVyaXRzKE5pbmVTbGljZSwgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyKTtcblxuLyoqXG4gKiBCdWlsZCB0aGUgcGFydHMgZm9yIHRoZSBzbGljZXMuXG4gKiBAbWV0aG9kIGJ1aWxkUGFydHNcbiAqIEBwcml2YXRlXG4gKi9cbk5pbmVTbGljZS5wcm90b3R5cGUuYnVpbGRQYXJ0cyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgeHAgPSBbMCwgdGhpcy5sZWZ0LCB0aGlzLnRleHR1cmUud2lkdGggLSB0aGlzLnJpZ2h0LCB0aGlzLnRleHR1cmUud2lkdGhdO1xuXHR2YXIgeXAgPSBbMCwgdGhpcy50b3AsIHRoaXMudGV4dHVyZS5oZWlnaHQgLSB0aGlzLmJvdHRvbSwgdGhpcy50ZXh0dXJlLmhlaWdodF07XG5cdHZhciBoaSwgdmk7XG5cblx0dGhpcy5wYXJ0cyA9IFtdO1xuXG5cdGZvciAodmkgPSAwOyB2aSA8IDM7IHZpKyspIHtcblx0XHRmb3IgKGhpID0gMDsgaGkgPCAzOyBoaSsrKSB7XG5cdFx0XHR2YXIgdyA9IHhwW2hpICsgMV0gLSB4cFtoaV07XG5cdFx0XHR2YXIgaCA9IHlwW3ZpICsgMV0gLSB5cFt2aV07XG5cblx0XHRcdGlmICh3ICE9IDAgJiYgaCAhPSAwKSB7XG5cdFx0XHRcdHZhciB0ZXh0dXJlUGFydCA9IHRoaXMuY3JlYXRlVGV4dHVyZVBhcnQoeHBbaGldLCB5cFt2aV0sIHcsIGgpO1xuXHRcdFx0XHR2YXIgcyA9IG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlUGFydCk7XG5cdFx0XHRcdHRoaXMuYWRkQ2hpbGQocyk7XG5cblx0XHRcdFx0dGhpcy5wYXJ0cy5wdXNoKHMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5wYXJ0cy5wdXNoKG51bGwpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFVwZGF0ZSBzaXplcy5cbiAqIEBtZXRob2QgdXBkYXRlU2l6ZXNcbiAqIEBwcml2YXRlXG4gKi9cbk5pbmVTbGljZS5wcm90b3R5cGUudXBkYXRlU2l6ZXMgPSBmdW5jdGlvbigpIHtcblx0dmFyIHhwID0gWzAsIHRoaXMubGVmdCwgdGhpcy5sb2NhbFdpZHRoIC0gdGhpcy5yaWdodCwgdGhpcy5sb2NhbFdpZHRoXTtcblx0dmFyIHlwID0gWzAsIHRoaXMudG9wLCB0aGlzLmxvY2FsSGVpZ2h0IC0gdGhpcy5ib3R0b20sIHRoaXMubG9jYWxIZWlnaHRdO1xuXHR2YXIgaGksIHZpLCBpID0gMDtcblxuXHRmb3IgKHZpID0gMDsgdmkgPCAzOyB2aSsrKSB7XG5cdFx0Zm9yIChoaSA9IDA7IGhpIDwgMzsgaGkrKykge1xuXHRcdFx0aWYgKHRoaXMucGFydHNbaV0pIHtcblx0XHRcdFx0dmFyIHBhcnQgPSB0aGlzLnBhcnRzW2ldO1xuXG5cdFx0XHRcdHBhcnQucG9zaXRpb24ueCA9IHhwW2hpXTtcblx0XHRcdFx0cGFydC5wb3NpdGlvbi55ID0geXBbdmldO1xuXHRcdFx0XHRwYXJ0LndpZHRoID0geHBbaGkgKyAxXSAtIHhwW2hpXTtcblx0XHRcdFx0cGFydC5oZWlnaHQgPSB5cFt2aSArIDFdIC0geXBbdmldO1xuXHRcdFx0fVxuXG5cdFx0XHRpKys7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogU2V0IGxvY2FsIHNpemUuXG4gKiBAbWV0aG9kIHNldExvY2FsU2l6ZVxuICovXG5OaW5lU2xpY2UucHJvdG90eXBlLnNldExvY2FsU2l6ZSA9IGZ1bmN0aW9uKHcsIGgpIHtcblx0dGhpcy5sb2NhbFdpZHRoID0gdztcblx0dGhpcy5sb2NhbEhlaWdodCA9IGg7XG5cdHRoaXMudXBkYXRlU2l6ZXMoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgdGV4dHVyZSBwYXJ0LlxuICogQG1ldGhvZCBjcmVhdGVUZXh0dXJlUGFydFxuICogQHByaXZhdGVcbiAqL1xuTmluZVNsaWNlLnByb3RvdHlwZS5jcmVhdGVUZXh0dXJlUGFydCA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0dmFyIGZyYW1lID0ge1xuXHRcdHg6IHRoaXMudGV4dHVyZS5mcmFtZS54ICsgeCxcblx0XHR5OiB0aGlzLnRleHR1cmUuZnJhbWUueSArIHksXG5cdFx0d2lkdGg6IHdpZHRoLFxuXHRcdGhlaWdodDogaGVpZ2h0XG5cdH07XG5cblx0cmV0dXJuIG5ldyBQSVhJLlRleHR1cmUodGhpcy50ZXh0dXJlLCBmcmFtZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTmluZVNsaWNlOyIsInZhciBUaGVuYWJsZSA9IHJlcXVpcmUoXCJ0aW5wXCIpO1xudmFyIFBJWEkgPSByZXF1aXJlKFwicGl4aS5qc1wiKTtcbnZhciBVcmxVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL1VybFV0aWxcIik7XG52YXIgSHR0cFJlcXVlc3QgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvSHR0cFJlcXVlc3RcIik7XG5cbi8qKlxuICogUmVzb3VyY2VzXG4gKiBAY2xhc3MgUmVzb3VyY2VzXG4gKi9cbmZ1bmN0aW9uIFJlc291cmNlcygpIHtcblx0dGhpcy5zcHJpdGVTaGVldHMgPSBbXTtcblx0dGhpcy5za2luU291cmNlcyA9IFtdO1xuXHR0aGlzLmRhdGEgPSBbXTtcblx0dGhpcy5sb2FkVGhlbmFibGUgPSBudWxsO1xuXHR0aGlzLnNraW5Tb3VyY2VJbmRleCA9IDA7XG59XG5cbi8qKlxuICogU2V0IHNwcml0ZSBzaGVldC5cbiAqIEBtZXRob2Qgc2V0U3ByaXRlU2hlZXRcbiAqL1xuUmVzb3VyY2VzLnByb3RvdHlwZS5zZXRTcHJpdGVTaGVldCA9IGZ1bmN0aW9uKHNwcml0ZVNoZWV0KSB7XG5cdHRoaXMuc3ByaXRlU2hlZXRzID0gW3Nwcml0ZVNoZWV0XTtcbn1cblxuLyoqXG4gKiBBZGQgYSBzcHJpdGUgc2hlZXQuXG4gKiBAbWV0aG9kIGFkZFNwcml0ZVNoZWV0XG4gKi9cblJlc291cmNlcy5wcm90b3R5cGUuYWRkU3ByaXRlU2hlZXQgPSBmdW5jdGlvbihzcHJpdGVTaGVldCkge1xuXHR0aGlzLnNwcml0ZVNoZWV0cy5wdXNoKHNwcml0ZVNoZWV0KTtcbn1cblxuLyoqXG4gKiBBZGQgYSBjYXNjYWRpbmcgc2tpbiBzb3VyY2UuXG4gKiBPYmplY3Qgb3IgdXJsLlxuICogQG1ldGhvZCBzb3VyY2VcbiAqL1xuUmVzb3VyY2VzLnByb3RvdHlwZS5hZGRTa2luU291cmNlID0gZnVuY3Rpb24oc291cmNlKSB7XG5cdHRoaXMuc2tpblNvdXJjZXMucHVzaChzb3VyY2UpO1xufVxuXG4vKipcbiAqIEdldCBhIFBvaW50IHJlc291cmNlLlxuICogQG1ldGhvZCBnZXRQb2ludFxuICovXG5SZXNvdXJjZXMucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24oaWQpIHtcblx0dGhpcy5hc3NlcnRLZXlFeGlzdHMoaWQpO1xuXG5cdHJldHVybiBuZXcgUElYSS5Qb2ludCh0aGlzLmRhdGFbaWRdWzBdLCB0aGlzLmRhdGFbaWRdWzFdKTtcbn1cblxuLyoqXG4gKiBHZXQgYSBzdHJpbmcgcmVzb3VyY2UuXG4gKiBAbWV0aG9kIGdldFN0cmluZ1xuICovXG5SZXNvdXJjZXMucHJvdG90eXBlLmdldFN0cmluZyA9IGZ1bmN0aW9uKGlkKSB7XG5cdHRoaXMuYXNzZXJ0S2V5RXhpc3RzKGlkKTtcblxuXHRyZXR1cm4gdGhpcy5kYXRhW2lkXS50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIEdldCB2YWx1ZS5cbiAqIEBtZXRob2QgZ2V0VmFsdWVcbiAqL1xuUmVzb3VyY2VzLnByb3RvdHlwZS5nZXRWYWx1ZSA9IFJlc291cmNlcy5wcm90b3R5cGUuZ2V0U3RyaW5nO1xuXG4vKipcbiAqIEdldCBjb2xvci5cbiAqIEBtZXRob2QgZ2V0VmFsdWVcbiAqL1xuUmVzb3VyY2VzLnByb3RvdHlwZS5nZXRDb2xvciA9IFJlc291cmNlcy5wcm90b3R5cGUuZ2V0U3RyaW5nO1xuXG4vKipcbiAqIEdldCBUZXh0dXJlLlxuICogQG1ldGhvZCBnZXRUZXh0dXJlXG4gKi9cblJlc291cmNlcy5wcm90b3R5cGUuZ2V0VGV4dHVyZSA9IGZ1bmN0aW9uKGlkKSB7XG5cdHZhciB0ZXh0dXJlID0gUElYSS5UZXh0dXJlLmZyb21GcmFtZSh0aGlzLmdldFN0cmluZyhpZCkpO1xuXG5cdHJldHVybiB0ZXh0dXJlO1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBrZXkgZXhpc3RzLlxuICogQG1ldGhvZCBhc3NlcnRLZXlFeGlzdHNcbiAqIEBwcml2YXRlXG4gKi9cblJlc291cmNlcy5wcm90b3R5cGUuYXNzZXJ0S2V5RXhpc3RzID0gZnVuY3Rpb24oaWQpIHtcblx0aWYgKCF0aGlzLmRhdGEuaGFzT3duUHJvcGVydHkoaWQpKVxuXHRcdHRocm93IG5ldyBFcnJvcihcIk5vIHN1Y2ggcmVzb3VyY2U6IFwiICsgaWQpO1xufVxuXG4vKipcbiAqIERvZXMgdGhpcyBrZXkgZXhpc3Q/XG4gKiBAbWV0aG9kIGtleUV4aXN0c1xuICovXG5SZXNvdXJjZXMucHJvdG90eXBlLmtleUV4aXN0cyA9IGZ1bmN0aW9uKGlkKSB7XG5cdHJldHVybiB0aGlzLmRhdGEuaGFzT3duUHJvcGVydHkoaWQpO1xufVxuXG4vKipcbiAqIExvYWQgcmVzb3VyY2VzLlxuICogQG1ldGhvZCBsb2FkXG4gKi9cblJlc291cmNlcy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5sb2FkVGhlbmFibGUpXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBsb2FkaW5nXCIpO1xuXG5cdHRoaXMubG9hZFRoZW5hYmxlID0gbmV3IFRoZW5hYmxlKCk7XG5cdHRoaXMuc2tpblNvdXJjZUluZGV4ID0gMDtcblxuXHRpZiAodGhpcy5zcHJpdGVTaGVldHMubGVuZ3RoKSB7XG5cdFx0dGhpcy5hc3NldExvYWRlciA9IG5ldyBQSVhJLkFzc2V0TG9hZGVyKHRoaXMuc3ByaXRlU2hlZXRzKTtcblx0XHR0aGlzLmFzc2V0TG9hZGVyLm9uKFwib25Db21wbGV0ZVwiLCB0aGlzLm9uQXNzZXRMb2FkZXJDb21wbGV0ZS5iaW5kKHRoaXMpKTtcblx0XHR0aGlzLmFzc2V0TG9hZGVyLm9uKFwib25Qcm9ncmVzc1wiLCB0aGlzLm9uQXNzZXRMb2FkZXJQcm9ncmVzcy5iaW5kKHRoaXMpKTtcblx0XHQvL2NvbnNvbGUubG9nKFwibG9hZGluZyBhc3NldHM6IFwiK3RoaXMuc3ByaXRlU2hlZXRzKTtcblx0XHR0aGlzLmFzc2V0TG9hZGVyLmxvYWQoKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLmxvYWROZXh0U2tpblNvdXJjZSgpO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMubG9hZFRoZW5hYmxlO1xufVxuXG4vKipcbiAqIEFzc2V0IGxvYWRlciBwcm9ncmVzcy5cbiAqIEBtZXRob2Qgb25Bc3NldExvYWRlclByb2dyZXNzXG4gKi9cblJlc291cmNlcy5wcm90b3R5cGUub25Bc3NldExvYWRlclByb2dyZXNzID0gZnVuY3Rpb24oZXYpIHtcblx0Y29uc29sZS5sb2coXCJhc3NldCBsb2FkZXIgcHJvZ3Jlc3NcIik7XG5cdC8qXHRjb25zb2xlLmxvZyhldik7XG5cblx0XHRldi5sb2FkZXIuYWpheFJlcXVlc3Qub25wcm9ncmVzcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29uc29sZS5sb2coXCJyZXF1ZXN0IHByb2dyZXMuLi5cIik7XG5cdFx0fTtcblxuXHRcdGV2LmxvYWRlci5hamF4UmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcInByb2dyZXNzLi4uXCIpO1xuXHRcdH0pOyovXG59XG5cbi8qKlxuICogQXNzZXQgbG9hZGVyIGNvbXBsZXRlLlxuICogQG1ldGhvZCBvbkFzc2V0TG9hZGVyQ29tcGxldGVcbiAqL1xuUmVzb3VyY2VzLnByb3RvdHlwZS5vbkFzc2V0TG9hZGVyQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0Ly9jb25zb2xlLmxvZyhcImFzc2V0IGxvYWRlciBjb21wbGV0ZSwgbG9hZGluZyBza2luXCIpO1xuXHR0aGlzLmxvYWROZXh0U2tpblNvdXJjZSgpO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgbmV4dCBza2luIHNvdXJjZSBpbiBzZXF1ZW5jZS5cbiAqIEBtZXRob2QgbG9hZE5leHRTa2luU291cmNlXG4gKiBAcHJpdmF0ZVxuICovXG5SZXNvdXJjZXMucHJvdG90eXBlLmxvYWROZXh0U2tpblNvdXJjZSA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5za2luU291cmNlSW5kZXggPj0gdGhpcy5za2luU291cmNlcy5sZW5ndGgpIHtcblx0XHQvL2NvbnNvbGUubG9nKFwicmVzb2x2aW5nIHRoZW5hYmxlLi4uXCIpO1xuXHRcdHRoaXMubG9hZFRoZW5hYmxlLnJlc29sdmUoKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgbyA9IHRoaXMuc2tpblNvdXJjZXNbdGhpcy5za2luU291cmNlSW5kZXhdO1xuXG5cdGlmICh0eXBlb2YgbyA9PSBcIm9iamVjdFwiKSB7XG5cdFx0dGhpcy5wcm9jZXNzU2tpbkRhdGEobyk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIHJlcXVlc3QgPSBuZXcgSHR0cFJlcXVlc3QoVXJsVXRpbC5tYWtlQWJzb2x1dGUobykpO1xuXHRyZXF1ZXN0LnNldFJlc3VsdFR5cGUoXCJqc29uXCIpO1xuXG5cdHJlcXVlc3Quc2VuZCgpLnRoZW4oXG5cdFx0dGhpcy5vblNraW5Tb3VyY2VMb2FkZWQuYmluZCh0aGlzKSxcblx0XHR0aGlzLm9uU2tpblNvdXJjZUxvYWRFcnJvci5iaW5kKHRoaXMpXG5cdCk7XG59XG5cbi8qKlxuICogU2tpbiBzb3VyY2UgbG9hZGVkLlxuICogQG1ldGhvZCBvblNraW5Tb3VyY2VMb2FkZWRcbiAqL1xuUmVzb3VyY2VzLnByb3RvdHlwZS5vblNraW5Tb3VyY2VMb2FkZWQgPSBmdW5jdGlvbihkYXRhKSB7XG5cdHRoaXMucHJvY2Vzc1NraW5EYXRhKGRhdGEpO1xufVxuXG4vKipcbiAqIFNraW4gc291cmNlIGxvYWQgZXJyb3IuXG4gKiBAbWV0aG9kIG9uU2tpblNvdXJjZUxvYWRFcnJvclxuICovXG5SZXNvdXJjZXMucHJvdG90eXBlLm9uU2tpblNvdXJjZUxvYWRFcnJvciA9IGZ1bmN0aW9uKGVycm9yKSB7XG5cdHRoaXMubG9hZFRoZW5hYmxlLnJlamVjdChlcnJvcik7XG59XG5cbi8qKlxuICogUHJvY2VzcyBza2luIGRhdGEuXG4gKiBAbWV0aG9kIHByb2Nlc3NTa2luRGF0YVxuICovXG5SZXNvdXJjZXMucHJvdG90eXBlLnByb2Nlc3NTa2luRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0Zm9yIChpIGluIGRhdGEpXG5cdFx0dGhpcy5kYXRhW2ldID0gZGF0YVtpXTtcblxuXHR0aGlzLnNraW5Tb3VyY2VJbmRleCsrO1xuXHR0aGlzLmxvYWROZXh0U2tpblNvdXJjZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlc291cmNlczsiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBwaXhpLmpzIC0gdjEuNi4wXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgTWF0IEdyb3Zlc1xuICogaHR0cDovL2dvb2Rib3lkaWdpdGFsLmNvbS9cbiAqXG4gKiBDb21waWxlZDogMjAxNC0wNy0xOFxuICpcbiAqIHBpeGkuanMgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAqL1xuLyoqXHJcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xyXG4gKi9cclxuXHJcbihmdW5jdGlvbigpe1xyXG5cclxuICAgIHZhciByb290ID0gdGhpcztcclxuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogQG1vZHVsZSBQSVhJXG4gKi9cbnZhciBQSVhJID0gUElYSSB8fCB7fTtcblxuLyogXG4qIFxuKiBUaGlzIGZpbGUgY29udGFpbnMgYSBsb3Qgb2YgcGl4aSBjb25zdHMgd2hpY2ggYXJlIHVzZWQgYWNyb3NzIHRoZSByZW5kZXJpbmcgZW5naW5lXG4qIEBjbGFzcyBDb25zdHNcbiovXG5QSVhJLldFQkdMX1JFTkRFUkVSID0gMDtcblBJWEkuQ0FOVkFTX1JFTkRFUkVSID0gMTtcblxuLy8gdXNlZnVsIGZvciB0ZXN0aW5nIGFnYWluc3QgaWYgeW91ciBsaWIgaXMgdXNpbmcgcGl4aS5cblBJWEkuVkVSU0lPTiA9IFwidjEuNi4xXCI7XG5cblxuLy8gdGhlIHZhcmlvdXMgYmxlbmQgbW9kZXMgc3VwcG9ydGVkIGJ5IHBpeGlcblBJWEkuYmxlbmRNb2RlcyA9IHtcbiAgICBOT1JNQUw6MCxcbiAgICBBREQ6MSxcbiAgICBNVUxUSVBMWToyLFxuICAgIFNDUkVFTjozLFxuICAgIE9WRVJMQVk6NCxcbiAgICBEQVJLRU46NSxcbiAgICBMSUdIVEVOOjYsXG4gICAgQ09MT1JfRE9ER0U6NyxcbiAgICBDT0xPUl9CVVJOOjgsXG4gICAgSEFSRF9MSUdIVDo5LFxuICAgIFNPRlRfTElHSFQ6MTAsXG4gICAgRElGRkVSRU5DRToxMSxcbiAgICBFWENMVVNJT046MTIsXG4gICAgSFVFOjEzLFxuICAgIFNBVFVSQVRJT046MTQsXG4gICAgQ09MT1I6MTUsXG4gICAgTFVNSU5PU0lUWToxNlxufTtcblxuLy8gdGhlIHNjYWxlIG1vZGVzXG5QSVhJLnNjYWxlTW9kZXMgPSB7XG4gICAgREVGQVVMVDowLFxuICAgIExJTkVBUjowLFxuICAgIE5FQVJFU1Q6MVxufTtcblxuLy8gdXNlZCB0byBjcmVhdGUgdWlkcyBmb3IgdmFyaW91cyBwaXhpIG9iamVjdHMuLlxuUElYSS5fVUlEID0gMDtcblxuaWYodHlwZW9mKEZsb2F0MzJBcnJheSkgIT0gJ3VuZGVmaW5lZCcpXG57XG4gICAgUElYSS5GbG9hdDMyQXJyYXkgPSBGbG9hdDMyQXJyYXk7XG4gICAgUElYSS5VaW50MTZBcnJheSA9IFVpbnQxNkFycmF5O1xufVxuZWxzZVxue1xuICAgIFBJWEkuRmxvYXQzMkFycmF5ID0gQXJyYXk7XG4gICAgUElYSS5VaW50MTZBcnJheSA9IEFycmF5O1xufVxuXG4vLyBpbnRlcmFjdGlvbiBmcmVxdWVuY3kgXG5QSVhJLklOVEVSQUNUSU9OX0ZSRVFVRU5DWSA9IDMwO1xuUElYSS5BVVRPX1BSRVZFTlRfREVGQVVMVCA9IHRydWU7XG5cblBJWEkuUkFEX1RPX0RFRyA9IDE4MCAvIE1hdGguUEk7XG5QSVhJLkRFR19UT19SQUQgPSBNYXRoLlBJIC8gMTgwO1xuXG5cblBJWEkuZG9udFNheUhlbGxvID0gZmFsc2U7XG5cblBJWEkuc2F5SGVsbG8gPSBmdW5jdGlvbiAodHlwZSkgXG57XG4gICAgaWYoUElYSS5kb250U2F5SGVsbG8pcmV0dXJuO1xuXG4gICAgaWYgKCBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignY2hyb21lJykgPiAtMSApXG4gICAge1xuICAgICAgICB2YXIgYXJncyA9IFtcbiAgICAgICAgICAgICclYyAlYyAlYyBQaXhpLmpzICcgKyBQSVhJLlZFUlNJT04gKyAnIC0gJyArIHR5cGUgKyAnICAlYyAnICsgJyAlYyAnICsgJyBodHRwOi8vd3d3LnBpeGlqcy5jb20vICAlYyAlYyDimaUlY+KZpSVj4pmlICcsXG4gICAgICAgICAgICAnYmFja2dyb3VuZDogI2ZmNjZhNScsXG4gICAgICAgICAgICAnYmFja2dyb3VuZDogI2ZmNjZhNScsXG4gICAgICAgICAgICAnY29sb3I6ICNmZjY2YTU7IGJhY2tncm91bmQ6ICMwMzAzMDc7JyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kOiAjZmY2NmE1JyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kOiAjZmZjM2RjJyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kOiAjZmY2NmE1JyxcbiAgICAgICAgICAgICdjb2xvcjogI2ZmMjQyNDsgYmFja2dyb3VuZDogI2ZmZicsXG4gICAgICAgICAgICAnY29sb3I6ICNmZjI0MjQ7IGJhY2tncm91bmQ6ICNmZmYnLFxuICAgICAgICAgICAgJ2NvbG9yOiAjZmYyNDI0OyBiYWNrZ3JvdW5kOiAjZmZmJ1xuICAgICAgICBdO1xuXG4gICAgICAgXG5cbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHdpbmRvd1snY29uc29sZSddKVxuICAgIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1BpeGkuanMgJyArIFBJWEkuVkVSU0lPTiArICcgLSBodHRwOi8vd3d3LnBpeGlqcy5jb20vJyk7XG4gICAgfVxuXG4gICAgUElYSS5kb250U2F5SGVsbG8gPSB0cnVlO1xufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqIFRoZSBQb2ludCBvYmplY3QgcmVwcmVzZW50cyBhIGxvY2F0aW9uIGluIGEgdHdvLWRpbWVuc2lvbmFsIGNvb3JkaW5hdGUgc3lzdGVtLCB3aGVyZSB4IHJlcHJlc2VudHMgdGhlIGhvcml6b250YWwgYXhpcyBhbmQgeSByZXByZXNlbnRzIHRoZSB2ZXJ0aWNhbCBheGlzLlxuICpcbiAqIEBjbGFzcyBQb2ludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0geCB7TnVtYmVyfSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHggYXhpc1xuICogQHBhcmFtIHkge051bWJlcn0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB5IGF4aXNcbiAqL1xuUElYSS5Qb2ludCA9IGZ1bmN0aW9uKHgsIHkpXG57XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy54ID0geCB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHlcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy55ID0geSB8fCAwO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBwb2ludFxuICpcbiAqIEBtZXRob2QgY2xvbmVcbiAqIEByZXR1cm4ge1BvaW50fSBhIGNvcHkgb2YgdGhlIHBvaW50XG4gKi9cblBJWEkuUG9pbnQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKVxue1xuICAgIHJldHVybiBuZXcgUElYSS5Qb2ludCh0aGlzLngsIHRoaXMueSk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHBvaW50IHRvIGEgbmV3IHggYW5kIHkgcG9zaXRpb24uXG4gKiBJZiB5IGlzIG9tbWl0ZWQsIGJvdGggeCBhbmQgeSB3aWxsIGJlIHNldCB0byB4LlxuICogXG4gKiBAbWV0aG9kIHNldFxuICogQHBhcmFtIFt4PTBdIHtOdW1iZXJ9IHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeCBheGlzXG4gKiBAcGFyYW0gW3k9MF0ge051bWJlcn0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB5IGF4aXNcbiAqL1xuUElYSS5Qb2ludC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oeCwgeSlcbntcbiAgICB0aGlzLnggPSB4IHx8IDA7XG4gICAgdGhpcy55ID0geSB8fCAoICh5ICE9PSAwKSA/IHRoaXMueCA6IDAgKSA7XG59O1xuXG4vLyBjb25zdHJ1Y3RvclxuUElYSS5Qb2ludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLlBvaW50O1xuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vXG4gKi9cblxuLyoqXG4gKiB0aGUgUmVjdGFuZ2xlIG9iamVjdCBpcyBhbiBhcmVhIGRlZmluZWQgYnkgaXRzIHBvc2l0aW9uLCBhcyBpbmRpY2F0ZWQgYnkgaXRzIHRvcC1sZWZ0IGNvcm5lciBwb2ludCAoeCwgeSkgYW5kIGJ5IGl0cyB3aWR0aCBhbmQgaXRzIGhlaWdodC5cbiAqXG4gKiBAY2xhc3MgUmVjdGFuZ2xlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB4IHtOdW1iZXJ9IFRoZSBYIGNvb3JkIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0geSB7TnVtYmVyfSBUaGUgWSBjb29yZCBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IFRoZSBvdmVyYWxsIHdpZHRoIG9mIHRoaXMgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gaGVpZ2h0IHtOdW1iZXJ9IFRoZSBvdmVyYWxsIGhlaWdodCBvZiB0aGlzIHJlY3RhbmdsZVxuICovXG5QSVhJLlJlY3RhbmdsZSA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpXG57XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy54ID0geCB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHlcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy55ID0geSB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHdpZHRoXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGhlaWdodFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAwO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBSZWN0YW5nbGVcbiAqXG4gKiBAbWV0aG9kIGNsb25lXG4gKiBAcmV0dXJuIHtSZWN0YW5nbGV9IGEgY29weSBvZiB0aGUgcmVjdGFuZ2xlXG4gKi9cblBJWEkuUmVjdGFuZ2xlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKClcbntcbiAgICByZXR1cm4gbmV3IFBJWEkuUmVjdGFuZ2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG59O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgUmVjdGFuZ2xlXG4gKlxuICogQG1ldGhvZCBjb250YWluc1xuICogQHBhcmFtIHgge051bWJlcn0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICogQHBhcmFtIHkge051bWJlcn0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgeC95IGNvb3JkcyBhcmUgd2l0aGluIHRoaXMgUmVjdGFuZ2xlXG4gKi9cblBJWEkuUmVjdGFuZ2xlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKHgsIHkpXG57XG4gICAgaWYodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHZhciB4MSA9IHRoaXMueDtcbiAgICBpZih4ID49IHgxICYmIHggPD0geDEgKyB0aGlzLndpZHRoKVxuICAgIHtcbiAgICAgICAgdmFyIHkxID0gdGhpcy55O1xuXG4gICAgICAgIGlmKHkgPj0geTEgJiYgeSA8PSB5MSArIHRoaXMuaGVpZ2h0KVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLlJlY3RhbmdsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLlJlY3RhbmdsZTtcblxuUElYSS5FbXB0eVJlY3RhbmdsZSA9IG5ldyBQSVhJLlJlY3RhbmdsZSgwLDAsMCwwKTtcbi8qKlxuICogQGF1dGhvciBBZHJpZW4gQnJhdWx0IDxhZHJpZW4uYnJhdWx0QGdtYWlsLmNvbT5cbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBQb2x5Z29uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSBwb2ludHMqIHtBcnJheTxQb2ludD58QXJyYXk8TnVtYmVyPnxQb2ludC4uLnxOdW1iZXIuLi59IFRoaXMgY2FuIGJlIGFuIGFycmF5IG9mIFBvaW50cyB0aGF0IGZvcm0gdGhlIHBvbHlnb24sXG4gKiAgICAgIGEgZmxhdCBhcnJheSBvZiBudW1iZXJzIHRoYXQgd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBbeCx5LCB4LHksIC4uLl0sIG9yIHRoZSBhcmd1bWVudHMgcGFzc2VkIGNhbiBiZVxuICogICAgICBhbGwgdGhlIHBvaW50cyBvZiB0aGUgcG9seWdvbiBlLmcuIGBuZXcgUElYSS5Qb2x5Z29uKG5ldyBQSVhJLlBvaW50KCksIG5ldyBQSVhJLlBvaW50KCksIC4uLilgLCBvciB0aGVcbiAqICAgICAgYXJndW1lbnRzIHBhc3NlZCBjYW4gYmUgZmxhdCB4LHkgdmFsdWVzIGUuZy4gYG5ldyBQSVhJLlBvbHlnb24oeCx5LCB4LHksIHgseSwgLi4uKWAgd2hlcmUgYHhgIGFuZCBgeWAgYXJlXG4gKiAgICAgIE51bWJlcnMuXG4gKi9cblBJWEkuUG9seWdvbiA9IGZ1bmN0aW9uKHBvaW50cylcbntcbiAgICAvL2lmIHBvaW50cyBpc24ndCBhbiBhcnJheSwgdXNlIGFyZ3VtZW50cyBhcyB0aGUgYXJyYXlcbiAgICBpZighKHBvaW50cyBpbnN0YW5jZW9mIEFycmF5KSlcbiAgICAgICAgcG9pbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIC8vaWYgdGhpcyBpcyBhIGZsYXQgYXJyYXkgb2YgbnVtYmVycywgY29udmVydCBpdCB0byBwb2ludHNcbiAgICBpZih0eXBlb2YgcG9pbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgcCA9IFtdO1xuICAgICAgICBmb3IodmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSs9Mikge1xuICAgICAgICAgICAgcC5wdXNoKFxuICAgICAgICAgICAgICAgIG5ldyBQSVhJLlBvaW50KHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBwb2ludHMgPSBwO1xuICAgIH1cblxuICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBwb2x5Z29uXG4gKlxuICogQG1ldGhvZCBjbG9uZVxuICogQHJldHVybiB7UG9seWdvbn0gYSBjb3B5IG9mIHRoZSBwb2x5Z29uXG4gKi9cblBJWEkuUG9seWdvbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLnBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwb2ludHMucHVzaCh0aGlzLnBvaW50c1tpXS5jbG9uZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFBJWEkuUG9seWdvbihwb2ludHMpO1xufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIHBvbHlnb25cbiAqXG4gKiBAbWV0aG9kIGNvbnRhaW5zXG4gKiBAcGFyYW0geCB7TnVtYmVyfSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gKiBAcGFyYW0geSB7TnVtYmVyfSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIHBvbHlnb25cbiAqL1xuUElYSS5Qb2x5Z29uLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKHgsIHkpXG57XG4gICAgdmFyIGluc2lkZSA9IGZhbHNlO1xuXG4gICAgLy8gdXNlIHNvbWUgcmF5Y2FzdGluZyB0byB0ZXN0IGhpdHNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svcG9pbnQtaW4tcG9seWdvbi9ibG9iL21hc3Rlci9pbmRleC5qc1xuICAgIGZvcih2YXIgaSA9IDAsIGogPSB0aGlzLnBvaW50cy5sZW5ndGggLSAxOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBqID0gaSsrKSB7XG4gICAgICAgIHZhciB4aSA9IHRoaXMucG9pbnRzW2ldLngsIHlpID0gdGhpcy5wb2ludHNbaV0ueSxcbiAgICAgICAgICAgIHhqID0gdGhpcy5wb2ludHNbal0ueCwgeWogPSB0aGlzLnBvaW50c1tqXS55LFxuICAgICAgICAgICAgaW50ZXJzZWN0ID0gKCh5aSA+IHkpICE9PSAoeWogPiB5KSkgJiYgKHggPCAoeGogLSB4aSkgKiAoeSAtIHlpKSAvICh5aiAtIHlpKSArIHhpKTtcblxuICAgICAgICBpZihpbnRlcnNlY3QpIGluc2lkZSA9ICFpbnNpZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc2lkZTtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLlBvbHlnb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5Qb2x5Z29uO1xuXG4vKipcbiAqIEBhdXRob3IgQ2hhZCBFbmdsZXIgPGNoYWRAcGFudGhlcmRldi5jb20+XG4gKi9cblxuLyoqXG4gKiBUaGUgQ2lyY2xlIG9iamVjdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGEgaGl0IGFyZWEgZm9yIGRpc3BsYXlPYmplY3RzXG4gKlxuICogQGNsYXNzIENpcmNsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0geCB7TnVtYmVyfSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhpcyBjaXJjbGVcbiAqIEBwYXJhbSB5IHtOdW1iZXJ9IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGlzIGNpcmNsZVxuICogQHBhcmFtIHJhZGl1cyB7TnVtYmVyfSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAqL1xuUElYSS5DaXJjbGUgPSBmdW5jdGlvbih4LCB5LCByYWRpdXMpXG57XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy54ID0geCB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHlcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy55ID0geSB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHJhZGl1c1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cyB8fCAwO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBDaXJjbGUgaW5zdGFuY2VcbiAqXG4gKiBAbWV0aG9kIGNsb25lXG4gKiBAcmV0dXJuIHtDaXJjbGV9IGEgY29weSBvZiB0aGUgcG9seWdvblxuICovXG5QSVhJLkNpcmNsZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpXG57XG4gICAgcmV0dXJuIG5ldyBQSVhJLkNpcmNsZSh0aGlzLngsIHRoaXMueSwgdGhpcy5yYWRpdXMpO1xufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgeCwgYW5kIHkgY29vcmRpbmF0ZXMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBjaXJjbGVcbiAqXG4gKiBAbWV0aG9kIGNvbnRhaW5zXG4gKiBAcGFyYW0geCB7TnVtYmVyfSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gKiBAcGFyYW0geSB7TnVtYmVyfSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIHBvbHlnb25cbiAqL1xuUElYSS5DaXJjbGUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oeCwgeSlcbntcbiAgICBpZih0aGlzLnJhZGl1cyA8PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgZHggPSAodGhpcy54IC0geCksXG4gICAgICAgIGR5ID0gKHRoaXMueSAtIHkpLFxuICAgICAgICByMiA9IHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXM7XG5cbiAgICBkeCAqPSBkeDtcbiAgICBkeSAqPSBkeTtcblxuICAgIHJldHVybiAoZHggKyBkeSA8PSByMik7XG59O1xuXG4vKipcbiogUmV0dXJucyB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhlIGNpcmNsZSBhcyBhIFBJWEkuUmVjdGFuZ2xlIG9iamVjdFxuKlxuKiBAbWV0aG9kIGdldEJvdW5kc1xuKiBAcmV0dXJuIHtSZWN0YW5nbGV9IHRoZSBmcmFtaW5nIHJlY3RhbmdsZVxuKi9cblBJWEkuQ2lyY2xlLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbigpXG57XG4gICAgcmV0dXJuIG5ldyBQSVhJLlJlY3RhbmdsZSh0aGlzLnggLSB0aGlzLnJhZGl1cywgdGhpcy55IC0gdGhpcy5yYWRpdXMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLkNpcmNsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkNpcmNsZTtcblxuXG4vKipcbiAqIEBhdXRob3IgQ2hhZCBFbmdsZXIgPGNoYWRAcGFudGhlcmRldi5jb20+XG4gKi9cblxuLyoqXG4gKiBUaGUgRWxsaXBzZSBvYmplY3QgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSBhIGhpdCBhcmVhIGZvciBkaXNwbGF5T2JqZWN0c1xuICpcbiAqIEBjbGFzcyBFbGxpcHNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB4IHtOdW1iZXJ9IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZVxuICogQHBhcmFtIHkge051bWJlcn0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlXG4gKiBAcGFyYW0gd2lkdGgge051bWJlcn0gVGhlIGhhbGYgd2lkdGggb2YgdGhpcyBlbGxpcHNlXG4gKiBAcGFyYW0gaGVpZ2h0IHtOdW1iZXJ9IFRoZSBoYWxmIGhlaWdodCBvZiB0aGlzIGVsbGlwc2VcbiAqL1xuUElYSS5FbGxpcHNlID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodClcbntcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgeFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnggPSB4IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgeVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnkgPSB5IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgd2lkdGhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaGVpZ2h0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDA7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIEVsbGlwc2UgaW5zdGFuY2VcbiAqXG4gKiBAbWV0aG9kIGNsb25lXG4gKiBAcmV0dXJuIHtFbGxpcHNlfSBhIGNvcHkgb2YgdGhlIGVsbGlwc2VcbiAqL1xuUElYSS5FbGxpcHNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKClcbntcbiAgICByZXR1cm4gbmV3IFBJWEkuRWxsaXBzZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIGVsbGlwc2VcbiAqXG4gKiBAbWV0aG9kIGNvbnRhaW5zXG4gKiBAcGFyYW0geCB7TnVtYmVyfSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gKiBAcGFyYW0geSB7TnVtYmVyfSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRzIGFyZSB3aXRoaW4gdGhpcyBlbGxpcHNlXG4gKi9cblBJWEkuRWxsaXBzZS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbih4LCB5KVxue1xuICAgIGlmKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAvL25vcm1hbGl6ZSB0aGUgY29vcmRzIHRvIGFuIGVsbGlwc2Ugd2l0aCBjZW50ZXIgMCwwXG4gICAgdmFyIG5vcm14ID0gKCh4IC0gdGhpcy54KSAvIHRoaXMud2lkdGgpLFxuICAgICAgICBub3JteSA9ICgoeSAtIHRoaXMueSkgLyB0aGlzLmhlaWdodCk7XG5cbiAgICBub3JteCAqPSBub3JteDtcbiAgICBub3JteSAqPSBub3JteTtcblxuICAgIHJldHVybiAobm9ybXggKyBub3JteSA8PSAxKTtcbn07XG5cbi8qKlxuKiBSZXR1cm5zIHRoZSBmcmFtaW5nIHJlY3RhbmdsZSBvZiB0aGUgZWxsaXBzZSBhcyBhIFBJWEkuUmVjdGFuZ2xlIG9iamVjdFxuKlxuKiBAbWV0aG9kIGdldEJvdW5kc1xuKiBAcmV0dXJuIHtSZWN0YW5nbGV9IHRoZSBmcmFtaW5nIHJlY3RhbmdsZVxuKi9cblBJWEkuRWxsaXBzZS5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24oKVxue1xuICAgIHJldHVybiBuZXcgUElYSS5SZWN0YW5nbGUodGhpcy54IC0gdGhpcy53aWR0aCwgdGhpcy55IC0gdGhpcy5oZWlnaHQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLkVsbGlwc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5FbGxpcHNlO1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogVGhlIE1hdHJpeCBjbGFzcyBpcyBub3cgYW4gb2JqZWN0LCB3aGljaCBtYWtlcyBpdCBhIGxvdCBmYXN0ZXIsIFxuICogaGVyZSBpcyBhIHJlcHJlc2VudGF0aW9uIG9mIGl0IDogXG4gKiB8IGEgfCBiIHwgdHh8XG4gKiB8IGMgfCBkIHwgdHl8XG4gKiB8IDAgfCAwIHwgMSB8XG4gKlxuICogQGNsYXNzIE1hdHJpeFxuICogQGNvbnN0cnVjdG9yXG4gKi9cblBJWEkuTWF0cml4ID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuYSA9IDE7XG4gICAgdGhpcy5iID0gMDtcbiAgICB0aGlzLmMgPSAwO1xuICAgIHRoaXMuZCA9IDE7XG4gICAgdGhpcy50eCA9IDA7XG4gICAgdGhpcy50eSA9IDA7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBwaXhpIG1hdHJpeCBvYmplY3QgYmFzZWQgb24gdGhlIGFycmF5IGdpdmVuIGFzIGEgcGFyYW1ldGVyXG4gKlxuICogQG1ldGhvZCBmcm9tQXJyYXlcbiAqIEBwYXJhbSBhcnJheSB7QXJyYXl9IFRoZSBhcnJheSB0aGF0IHRoZSBtYXRyaXggd2lsbCBiZSBmaWxsZWQgd2l0aFxuICovXG5QSVhJLk1hdHJpeC5wcm90b3R5cGUuZnJvbUFycmF5ID0gZnVuY3Rpb24oYXJyYXkpXG57XG4gICAgdGhpcy5hID0gYXJyYXlbMF07XG4gICAgdGhpcy5iID0gYXJyYXlbMV07XG4gICAgdGhpcy5jID0gYXJyYXlbM107XG4gICAgdGhpcy5kID0gYXJyYXlbNF07XG4gICAgdGhpcy50eCA9IGFycmF5WzJdO1xuICAgIHRoaXMudHkgPSBhcnJheVs1XTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBmcm9tIHRoZSBjdXJyZW50IE1hdHJpeCBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIHRvQXJyYXlcbiAqIEBwYXJhbSB0cmFuc3Bvc2Uge0Jvb2xlYW59IFdoZXRoZXIgd2UgbmVlZCB0byB0cmFuc3Bvc2UgdGhlIG1hdHJpeCBvciBub3RcbiAqIEByZXR1cm4ge0FycmF5fSB0aGUgbmV3bHkgY3JlYXRlZCBhcnJheSB3aGljaCBjb250YWlucyB0aGUgbWF0cml4XG4gKi9cblBJWEkuTWF0cml4LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24odHJhbnNwb3NlKVxue1xuICAgIGlmKCF0aGlzLmFycmF5KSB0aGlzLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSg5KTtcbiAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuXG4gICAgaWYodHJhbnNwb3NlKVxuICAgIHtcbiAgICAgICAgYXJyYXlbMF0gPSB0aGlzLmE7XG4gICAgICAgIGFycmF5WzFdID0gdGhpcy5jO1xuICAgICAgICBhcnJheVsyXSA9IDA7XG4gICAgICAgIGFycmF5WzNdID0gdGhpcy5iO1xuICAgICAgICBhcnJheVs0XSA9IHRoaXMuZDtcbiAgICAgICAgYXJyYXlbNV0gPSAwO1xuICAgICAgICBhcnJheVs2XSA9IHRoaXMudHg7XG4gICAgICAgIGFycmF5WzddID0gdGhpcy50eTtcbiAgICAgICAgYXJyYXlbOF0gPSAxO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBhcnJheVswXSA9IHRoaXMuYTtcbiAgICAgICAgYXJyYXlbMV0gPSB0aGlzLmI7XG4gICAgICAgIGFycmF5WzJdID0gdGhpcy50eDtcbiAgICAgICAgYXJyYXlbM10gPSB0aGlzLmM7XG4gICAgICAgIGFycmF5WzRdID0gdGhpcy5kO1xuICAgICAgICBhcnJheVs1XSA9IHRoaXMudHk7XG4gICAgICAgIGFycmF5WzZdID0gMDtcbiAgICAgICAgYXJyYXlbN10gPSAwO1xuICAgICAgICBhcnJheVs4XSA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xufTtcblxuUElYSS5pZGVudGl0eU1hdHJpeCA9IG5ldyBQSVhJLk1hdHJpeCgpO1xuXG5QSVhJLmRldGVybWluZU1hdHJpeEFycmF5VHlwZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG59O1xuXG4vKipcbiAqIFRoZSBNYXRyaXgyIGNsYXNzIHdpbGwgY2hvb3NlIHRoZSBiZXN0IHR5cGUgb2YgYXJyYXkgdG8gdXNlIGJldHdlZW5cbiAqIGEgcmVndWxhciBqYXZhc2NyaXB0IEFycmF5IGFuZCBhIEZsb2F0MzJBcnJheSBpZiB0aGUgbGF0dGVyIGlzIGF2YWlsYWJsZVxuICpcbiAqIEBjbGFzcyBNYXRyaXgyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuUElYSS5NYXRyaXgyID0gUElYSS5kZXRlcm1pbmVNYXRyaXhBcnJheVR5cGUoKTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBhbGwgb2JqZWN0cyB0aGF0IGFyZSByZW5kZXJlZCBvbiB0aGUgc2NyZWVuLiBcbiAqIFRoaXMgaXMgYW4gYWJzdHJhY3QgY2xhc3MgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBvbiBpdHMgb3duIHJhdGhlciBpdCBzaG91bGQgYmUgZXh0ZW5kZWQuXG4gKlxuICogQGNsYXNzIERpc3BsYXlPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5QSVhJLkRpc3BsYXlPYmplY3QgPSBmdW5jdGlvbigpXG57XG4gICAgLyoqXG4gICAgICogVGhlIGNvb3JkaW5hdGUgb2YgdGhlIG9iamVjdCByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwb3NpdGlvblxuICAgICAqIEB0eXBlIFBvaW50XG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBQSVhJLlBvaW50KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NhbGUgZmFjdG9yIG9mIHRoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgc2NhbGVcbiAgICAgKiBAdHlwZSBQb2ludFxuICAgICAqL1xuICAgIHRoaXMuc2NhbGUgPSBuZXcgUElYSS5Qb2ludCgxLDEpOy8ve3g6MSwgeToxfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwaXZvdCBwb2ludCBvZiB0aGUgZGlzcGxheU9iamVjdCB0aGF0IGl0IHJvdGF0ZXMgYXJvdW5kXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcGl2b3RcbiAgICAgKiBAdHlwZSBQb2ludFxuICAgICAqL1xuICAgIHRoaXMucGl2b3QgPSBuZXcgUElYSS5Qb2ludCgwLDApO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJvdGF0aW9uIG9mIHRoZSBvYmplY3QgaW4gcmFkaWFucy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByb3RhdGlvblxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMucm90YXRpb24gPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wYWNpdHkgb2YgdGhlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBhbHBoYVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuYWxwaGEgPSAxO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZpc2liaWxpdHkgb2YgdGhlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBkZWZpbmVkIGFyZWEgdGhhdCB3aWxsIHBpY2sgdXAgbW91c2UgLyB0b3VjaCBldmVudHMuIEl0IGlzIG51bGwgYnkgZGVmYXVsdC5cbiAgICAgKiBTZXR0aW5nIGl0IGlzIGEgbmVhdCB3YXkgb2Ygb3B0aW1pc2luZyB0aGUgaGl0VGVzdCBmdW5jdGlvbiB0aGF0IHRoZSBpbnRlcmFjdGlvbk1hbmFnZXIgd2lsbCB1c2UgKGFzIGl0IHdpbGwgbm90IG5lZWQgdG8gaGl0IHRlc3QgYWxsIHRoZSBjaGlsZHJlbilcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBoaXRBcmVhXG4gICAgICogQHR5cGUgUmVjdGFuZ2xlfENpcmNsZXxFbGxpcHNlfFBvbHlnb25cbiAgICAgKi9cbiAgICB0aGlzLmhpdEFyZWEgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB1c2VkIHRvIGluZGljYXRlIGlmIHRoZSBkaXNwbGF5T2JqZWN0IHNob3VsZCBkaXNwbGF5IGEgbW91c2UgaGFuZCBjdXJzb3Igb24gcm9sbG92ZXJcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBidXR0b25Nb2RlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMuYnV0dG9uTW9kZSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2FuIHRoaXMgb2JqZWN0IGJlIHJlbmRlcmVkXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyYWJsZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmFibGUgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFtyZWFkLW9ubHldIFRoZSBkaXNwbGF5IG9iamVjdCBjb250YWluZXIgdGhhdCBjb250YWlucyB0aGlzIGRpc3BsYXkgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBhcmVudFxuICAgICAqIEB0eXBlIERpc3BsYXlPYmplY3RDb250YWluZXJcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBbcmVhZC1vbmx5XSBUaGUgc3RhZ2UgdGhlIGRpc3BsYXkgb2JqZWN0IGlzIGNvbm5lY3RlZCB0bywgb3IgdW5kZWZpbmVkIGlmIGl0IGlzIG5vdCBjb25uZWN0ZWQgdG8gdGhlIHN0YWdlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHN0YWdlXG4gICAgICogQHR5cGUgU3RhZ2VcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLnN0YWdlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFtyZWFkLW9ubHldIFRoZSBtdWx0aXBsaWVkIGFscGhhIG9mIHRoZSBkaXNwbGF5T2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgd29ybGRBbHBoYVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMud29ybGRBbHBoYSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBbcmVhZC1vbmx5XSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGludGVyYWN0aXZlLCBkbyBub3QgdG9nZ2xlIGRpcmVjdGx5ISB1c2UgdGhlIGBpbnRlcmFjdGl2ZWAgcHJvcGVydHlcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBfaW50ZXJhY3RpdmVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHJlYWRPbmx5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9pbnRlcmFjdGl2ZSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgY3Vyc29yIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gdGhlIG1vdXNlIGlzIG92ZXIgdGhpcyBvYmplY3QuIFRvIGVuYWJsZSB0aGlzIHRoZSBlbGVtZW50IG11c3QgaGF2ZSBpbnRlcmFjdGlvbiA9IHRydWUgYW5kIGJ1dHRvbk1vZGUgPSB0cnVlXG4gICAgICogXG4gICAgICogQHByb3BlcnR5IGRlZmF1bHRDdXJzb3JcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKlxuICAgICovXG4gICAgdGhpcy5kZWZhdWx0Q3Vyc29yID0gJ3BvaW50ZXInO1xuXG4gICAgLyoqXG4gICAgICogW3JlYWQtb25seV0gQ3VycmVudCB0cmFuc2Zvcm0gb2YgdGhlIG9iamVjdCBiYXNlZCBvbiB3b3JsZCAocGFyZW50KSBmYWN0b3JzXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgd29ybGRUcmFuc2Zvcm1cbiAgICAgKiBAdHlwZSBNYXQzXG4gICAgICogQHJlYWRPbmx5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtID0gbmV3IFBJWEkuTWF0cml4KCk7XG5cbiAgICAvKipcbiAgICAgKiBbTllJXSBVbmtub3duXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29sb3JcbiAgICAgKiBAdHlwZSBBcnJheTw+XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNvbG9yID0gW107XG5cbiAgICAvKipcbiAgICAgKiBbTllJXSBIb2xkcyB3aGV0aGVyIG9yIG5vdCB0aGlzIG9iamVjdCBpcyBkeW5hbWljLCBmb3IgcmVuZGVyaW5nIG9wdGltaXphdGlvblxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGR5bmFtaWNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmR5bmFtaWMgPSB0cnVlO1xuXG4gICAgLy8gY2FjaGVkIHNpbiByb3RhdGlvbiBhbmQgY29zIHJvdGF0aW9uXG4gICAgdGhpcy5fc3IgPSAwO1xuICAgIHRoaXMuX2NyID0gMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcmVhIHRoZSBmaWx0ZXIgaXMgYXBwbGllZCB0byBsaWtlIHRoZSBoaXRBcmVhIHRoaXMgaXMgdXNlZCBhcyBtb3JlIG9mIGFuIG9wdGltaXNhdGlvblxuICAgICAqIHJhdGhlciB0aGFuIGZpZ3VyaW5nIG91dCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgZGlzcGxheU9iamVjdCBlYWNoIGZyYW1lIHlvdSBjYW4gc2V0IHRoaXMgcmVjdGFuZ2xlXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZmlsdGVyQXJlYVxuICAgICAqIEB0eXBlIFJlY3RhbmdsZVxuICAgICAqL1xuICAgIHRoaXMuZmlsdGVyQXJlYSA9IG51bGw7Ly9uZXcgUElYSS5SZWN0YW5nbGUoMCwwLDEsMSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3JpZ2luYWwsIGNhY2hlZCBib3VuZHMgb2YgdGhlIG9iamVjdFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IF9ib3VuZHNcbiAgICAgKiBAdHlwZSBSZWN0YW5nbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2JvdW5kcyA9IG5ldyBQSVhJLlJlY3RhbmdsZSgwLCAwLCAxLCAxKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9zdCB1cC10by1kYXRlIGJvdW5kcyBvZiB0aGUgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgX2N1cnJlbnRCb3VuZHNcbiAgICAgKiBAdHlwZSBSZWN0YW5nbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2N1cnJlbnRCb3VuZHMgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIFRoZSBvcmlnaW5hbCwgY2FjaGVkIG1hc2sgb2YgdGhlIG9iamVjdFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IF9jdXJyZW50Qm91bmRzXG4gICAgICogQHR5cGUgUmVjdGFuZ2xlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9tYXNrID0gbnVsbDtcblxuICAgIHRoaXMuX2NhY2hlQXNCaXRtYXAgPSBmYWxzZTtcbiAgICB0aGlzLl9jYWNoZUlzRGlydHkgPSBmYWxzZTtcblxuXG4gICAgLypcbiAgICAgKiBNT1VTRSBDYWxsYmFja3NcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgY2FsbGJhY2sgdGhhdCBpcyB1c2VkIHdoZW4gdGhlIHVzZXJzIGNsaWNrcyBvbiB0aGUgZGlzcGxheU9iamVjdCB3aXRoIHRoZWlyIG1vdXNlXG4gICAgICogQG1ldGhvZCBjbGlja1xuICAgICAqIEBwYXJhbSBpbnRlcmFjdGlvbkRhdGEge0ludGVyYWN0aW9uRGF0YX1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgY2FsbGJhY2sgdGhhdCBpcyB1c2VkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBtb3VzZSBkb3duIG92ZXIgdGhlIHNwcml0ZVxuICAgICAqIEBtZXRob2QgbW91c2Vkb3duXG4gICAgICogQHBhcmFtIGludGVyYWN0aW9uRGF0YSB7SW50ZXJhY3Rpb25EYXRhfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBjYWxsYmFjayB0aGF0IGlzIHVzZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyB0aGUgbW91c2UgdGhhdCB3YXMgb3ZlciB0aGUgZGlzcGxheU9iamVjdFxuICAgICAqIGZvciB0aGlzIGNhbGxiYWNrIHRvIGJlIGZpcmVkIHRoZSBtb3VzZSBtdXN0IGhhdmUgYmVlbiBwcmVzc2VkIGRvd24gb3ZlciB0aGUgZGlzcGxheU9iamVjdFxuICAgICAqIEBtZXRob2QgbW91c2V1cFxuICAgICAqIEBwYXJhbSBpbnRlcmFjdGlvbkRhdGEge0ludGVyYWN0aW9uRGF0YX1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgY2FsbGJhY2sgdGhhdCBpcyB1c2VkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgdGhlIG1vdXNlIHRoYXQgd2FzIG92ZXIgdGhlIGRpc3BsYXlPYmplY3QgYnV0IGlzIG5vIGxvbmdlciBvdmVyIHRoZSBkaXNwbGF5T2JqZWN0XG4gICAgICogZm9yIHRoaXMgY2FsbGJhY2sgdG8gYmUgZmlyZWQsIFRoZSB0b3VjaCBtdXN0IGhhdmUgc3RhcnRlZCBvdmVyIHRoZSBkaXNwbGF5T2JqZWN0XG4gICAgICogQG1ldGhvZCBtb3VzZXVwb3V0c2lkZVxuICAgICAqIEBwYXJhbSBpbnRlcmFjdGlvbkRhdGEge0ludGVyYWN0aW9uRGF0YX1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgY2FsbGJhY2sgdGhhdCBpcyB1c2VkIHdoZW4gdGhlIHVzZXJzIG1vdXNlIHJvbGxzIG92ZXIgdGhlIGRpc3BsYXlPYmplY3RcbiAgICAgKiBAbWV0aG9kIG1vdXNlb3ZlclxuICAgICAqIEBwYXJhbSBpbnRlcmFjdGlvbkRhdGEge0ludGVyYWN0aW9uRGF0YX1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgY2FsbGJhY2sgdGhhdCBpcyB1c2VkIHdoZW4gdGhlIHVzZXJzIG1vdXNlIGxlYXZlcyB0aGUgZGlzcGxheU9iamVjdFxuICAgICAqIEBtZXRob2QgbW91c2VvdXRcbiAgICAgKiBAcGFyYW0gaW50ZXJhY3Rpb25EYXRhIHtJbnRlcmFjdGlvbkRhdGF9XG4gICAgICovXG5cblxuICAgIC8qXG4gICAgICogVE9VQ0ggQ2FsbGJhY2tzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGNhbGxiYWNrIHRoYXQgaXMgdXNlZCB3aGVuIHRoZSB1c2VycyB0YXBzIG9uIHRoZSBzcHJpdGUgd2l0aCB0aGVpciBmaW5nZXJcbiAgICAgKiBiYXNpY2FsbHkgYSB0b3VjaCB2ZXJzaW9uIG9mIGNsaWNrXG4gICAgICogQG1ldGhvZCB0YXBcbiAgICAgKiBAcGFyYW0gaW50ZXJhY3Rpb25EYXRhIHtJbnRlcmFjdGlvbkRhdGF9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGNhbGxiYWNrIHRoYXQgaXMgdXNlZCB3aGVuIHRoZSB1c2VyIHRvdWNoZXMgb3ZlciB0aGUgZGlzcGxheU9iamVjdFxuICAgICAqIEBtZXRob2QgdG91Y2hzdGFydFxuICAgICAqIEBwYXJhbSBpbnRlcmFjdGlvbkRhdGEge0ludGVyYWN0aW9uRGF0YX1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgY2FsbGJhY2sgdGhhdCBpcyB1c2VkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgYSB0b3VjaCBvdmVyIHRoZSBkaXNwbGF5T2JqZWN0XG4gICAgICogQG1ldGhvZCB0b3VjaGVuZFxuICAgICAqIEBwYXJhbSBpbnRlcmFjdGlvbkRhdGEge0ludGVyYWN0aW9uRGF0YX1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgY2FsbGJhY2sgdGhhdCBpcyB1c2VkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgdGhlIHRvdWNoIHRoYXQgd2FzIG92ZXIgdGhlIGRpc3BsYXlPYmplY3RcbiAgICAgKiBmb3IgdGhpcyBjYWxsYmFjayB0byBiZSBmaXJlZCwgVGhlIHRvdWNoIG11c3QgaGF2ZSBzdGFydGVkIG92ZXIgdGhlIHNwcml0ZVxuICAgICAqIEBtZXRob2QgdG91Y2hlbmRvdXRzaWRlXG4gICAgICogQHBhcmFtIGludGVyYWN0aW9uRGF0YSB7SW50ZXJhY3Rpb25EYXRhfVxuICAgICAqL1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkRpc3BsYXlPYmplY3Q7XG5cbi8qKlxuICogW0RlcHJlY2F0ZWRdIEluZGljYXRlcyBpZiB0aGUgc3ByaXRlIHdpbGwgaGF2ZSB0b3VjaCBhbmQgbW91c2UgaW50ZXJhY3Rpdml0eS4gSXQgaXMgZmFsc2UgYnkgZGVmYXVsdFxuICogSW5zdGVhZCBvZiB1c2luZyB0aGlzIGZ1bmN0aW9uIHlvdSBjYW4gbm93IHNpbXBseSBzZXQgdGhlIGludGVyYWN0aXZlIHByb3BlcnR5IHRvIHRydWUgb3IgZmFsc2VcbiAqXG4gKiBAbWV0aG9kIHNldEludGVyYWN0aXZlXG4gKiBAcGFyYW0gaW50ZXJhY3RpdmUge0Jvb2xlYW59XG4gKiBAZGVwcmVjYXRlZCBTaW1wbHkgc2V0IHRoZSBgaW50ZXJhY3RpdmVgIHByb3BlcnR5IGRpcmVjdGx5XG4gKi9cblBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuc2V0SW50ZXJhY3RpdmUgPSBmdW5jdGlvbihpbnRlcmFjdGl2ZSlcbntcbiAgICB0aGlzLmludGVyYWN0aXZlID0gaW50ZXJhY3RpdmU7XG59O1xuXG4vKipcbiAqIEluZGljYXRlcyBpZiB0aGUgc3ByaXRlIHdpbGwgaGF2ZSB0b3VjaCBhbmQgbW91c2UgaW50ZXJhY3Rpdml0eS4gSXQgaXMgZmFsc2UgYnkgZGVmYXVsdFxuICpcbiAqIEBwcm9wZXJ0eSBpbnRlcmFjdGl2ZVxuICogQHR5cGUgQm9vbGVhblxuICogQGRlZmF1bHQgZmFsc2VcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUsICdpbnRlcmFjdGl2ZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJhY3RpdmU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2ludGVyYWN0aXZlID0gdmFsdWU7XG5cbiAgICAgICAgLy8gVE9ETyBtb3JlIHRvIGJlIGRvbmUgaGVyZS4uXG4gICAgICAgIC8vIG5lZWQgdG8gc29ydCBvdXQgYSByZS1jcmF3bCFcbiAgICAgICAgaWYodGhpcy5zdGFnZSl0aGlzLnN0YWdlLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBbcmVhZC1vbmx5XSBJbmRpY2F0ZXMgaWYgdGhlIHNwcml0ZSBpcyBnbG9iYWx5IHZpc2libGUuXG4gKlxuICogQHByb3BlcnR5IHdvcmxkVmlzaWJsZVxuICogQHR5cGUgQm9vbGVhblxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZSwgJ3dvcmxkVmlzaWJsZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXM7XG5cbiAgICAgICAgZG9cbiAgICAgICAge1xuICAgICAgICAgICAgaWYoIWl0ZW0udmlzaWJsZSlyZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpdGVtID0gaXRlbS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUoaXRlbSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogU2V0cyBhIG1hc2sgZm9yIHRoZSBkaXNwbGF5T2JqZWN0LiBBIG1hc2sgaXMgYW4gb2JqZWN0IHRoYXQgbGltaXRzIHRoZSB2aXNpYmlsaXR5IG9mIGFuIG9iamVjdCB0byB0aGUgc2hhcGUgb2YgdGhlIG1hc2sgYXBwbGllZCB0byBpdC5cbiAqIEluIFBJWEkgYSByZWd1bGFyIG1hc2sgbXVzdCBiZSBhIFBJWEkuR3JhcGhpY3Mgb2JqZWN0LiBUaGlzIGFsbG93cyBmb3IgbXVjaCBmYXN0ZXIgbWFza2luZyBpbiBjYW52YXMgYXMgaXQgdXRpbGlzZXMgc2hhcGUgY2xpcHBpbmcuXG4gKiBUbyByZW1vdmUgYSBtYXNrLCBzZXQgdGhpcyBwcm9wZXJ0eSB0byBudWxsLlxuICpcbiAqIEBwcm9wZXJ0eSBtYXNrXG4gKiBAdHlwZSBHcmFwaGljc1xuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZSwgJ21hc2snLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hc2s7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cbiAgICAgICAgaWYodGhpcy5fbWFzayl0aGlzLl9tYXNrLmlzTWFzayA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9tYXNrID0gdmFsdWU7XG4gICAgICAgIGlmKHRoaXMuX21hc2spdGhpcy5fbWFzay5pc01hc2sgPSB0cnVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFNldHMgdGhlIGZpbHRlcnMgZm9yIHRoZSBkaXNwbGF5T2JqZWN0LlxuICogKiBJTVBPUlRBTlQ6IFRoaXMgaXMgYSB3ZWJHTCBvbmx5IGZlYXR1cmUgYW5kIHdpbGwgYmUgaWdub3JlZCBieSB0aGUgY2FudmFzIHJlbmRlcmVyLlxuICogVG8gcmVtb3ZlIGZpbHRlcnMgc2ltcGx5IHNldCB0aGlzIHByb3BlcnR5IHRvICdudWxsJ1xuICogQHByb3BlcnR5IGZpbHRlcnNcbiAqIEB0eXBlIEFycmF5IEFuIGFycmF5IG9mIGZpbHRlcnNcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUsICdmaWx0ZXJzJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXG4gICAgICAgIGlmKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBub3cgcHV0IGFsbCB0aGUgcGFzc2VzIGluIG9uZSBwbGFjZS4uXG4gICAgICAgICAgICB2YXIgcGFzc2VzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJQYXNzZXMgPSB2YWx1ZVtpXS5wYXNzZXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmaWx0ZXJQYXNzZXMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwYXNzZXMucHVzaChmaWx0ZXJQYXNzZXNbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ETyBjaGFuZ2UgdGhpcyBhcyBpdCBpcyBsZWdhY3lcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlckJsb2NrID0ge3RhcmdldDp0aGlzLCBmaWx0ZXJQYXNzZXM6cGFzc2VzfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZpbHRlcnMgPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBTZXQgd2VhdGhlciBvciBub3QgYSB0aGUgZGlzcGxheSBvYmplY3RzIGlzIGNhY2hlZCBhcyBhIGJpdG1hcC5cbiAqIFRoaXMgYmFzaWNhbGx5IHRha2VzIGEgc25hcCBzaG90IG9mIHRoZSBkaXNwbGF5IG9iamVjdCBhcyBpdCBpcyBhdCB0aGF0IG1vbWVudC4gSXQgY2FuIHByb3ZpZGUgYSBwZXJmb3JtYW5jZSBiZW5lZml0IGZvciBjb21wbGV4IHN0YXRpYyBkaXNwbGF5T2JqZWN0c1xuICogVG8gcmVtb3ZlIGZpbHRlcnMgc2ltcGx5IHNldCB0aGlzIHByb3BlcnR5IHRvICdudWxsJ1xuICogQHByb3BlcnR5IGNhY2hlQXNCaXRtYXBcbiAqIEB0eXBlIEJvb2xlYW5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUsICdjYWNoZUFzQml0bWFwJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAgdGhpcy5fY2FjaGVBc0JpdG1hcDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcblxuICAgICAgICBpZih0aGlzLl9jYWNoZUFzQml0bWFwID09PSB2YWx1ZSlyZXR1cm47XG5cbiAgICAgICAgaWYodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vdGhpcy5fY2FjaGVJc0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlQ2FjaGVkU3ByaXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95Q2FjaGVkU3ByaXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jYWNoZUFzQml0bWFwID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qXG4gKiBVcGRhdGVzIHRoZSBvYmplY3QgdHJhbnNmb3JtIGZvciByZW5kZXJpbmdcbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVRyYW5zZm9ybVxuICogQHByaXZhdGVcbiAqL1xuUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbigpXG57XG4gICAgLy8gVE9ETyBPUFRJTUlaRSBUSElTISEgd2l0aCBkaXJ0eVxuICAgIGlmKHRoaXMucm90YXRpb24gIT09IHRoaXMucm90YXRpb25DYWNoZSlcbiAgICB7XG5cbiAgICAgICAgdGhpcy5yb3RhdGlvbkNhY2hlID0gdGhpcy5yb3RhdGlvbjtcbiAgICAgICAgdGhpcy5fc3IgPSAgTWF0aC5zaW4odGhpcy5yb3RhdGlvbik7XG4gICAgICAgIHRoaXMuX2NyID0gIE1hdGguY29zKHRoaXMucm90YXRpb24pO1xuICAgIH1cblxuICAgLy8gdmFyIGxvY2FsVHJhbnNmb3JtID0gdGhpcy5sb2NhbFRyYW5zZm9ybS8vLnRvQXJyYXkoKTtcbiAgICB2YXIgcGFyZW50VHJhbnNmb3JtID0gdGhpcy5wYXJlbnQud29ybGRUcmFuc2Zvcm07Ly8udG9BcnJheSgpO1xuICAgIHZhciB3b3JsZFRyYW5zZm9ybSA9IHRoaXMud29ybGRUcmFuc2Zvcm07Ly8udG9BcnJheSgpO1xuXG4gICAgdmFyIHB4ID0gdGhpcy5waXZvdC54O1xuICAgIHZhciBweSA9IHRoaXMucGl2b3QueTtcblxuICAgIHZhciBhMDAgPSB0aGlzLl9jciAqIHRoaXMuc2NhbGUueCxcbiAgICAgICAgYTAxID0gLXRoaXMuX3NyICogdGhpcy5zY2FsZS55LFxuICAgICAgICBhMTAgPSB0aGlzLl9zciAqIHRoaXMuc2NhbGUueCxcbiAgICAgICAgYTExID0gdGhpcy5fY3IgKiB0aGlzLnNjYWxlLnksXG4gICAgICAgIGEwMiA9IHRoaXMucG9zaXRpb24ueCAtIGEwMCAqIHB4IC0gcHkgKiBhMDEsXG4gICAgICAgIGExMiA9IHRoaXMucG9zaXRpb24ueSAtIGExMSAqIHB5IC0gcHggKiBhMTAsXG4gICAgICAgIGIwMCA9IHBhcmVudFRyYW5zZm9ybS5hLCBiMDEgPSBwYXJlbnRUcmFuc2Zvcm0uYixcbiAgICAgICAgYjEwID0gcGFyZW50VHJhbnNmb3JtLmMsIGIxMSA9IHBhcmVudFRyYW5zZm9ybS5kO1xuXG4gICAgd29ybGRUcmFuc2Zvcm0uYSA9IGIwMCAqIGEwMCArIGIwMSAqIGExMDtcbiAgICB3b3JsZFRyYW5zZm9ybS5iID0gYjAwICogYTAxICsgYjAxICogYTExO1xuICAgIHdvcmxkVHJhbnNmb3JtLnR4ID0gYjAwICogYTAyICsgYjAxICogYTEyICsgcGFyZW50VHJhbnNmb3JtLnR4O1xuXG4gICAgd29ybGRUcmFuc2Zvcm0uYyA9IGIxMCAqIGEwMCArIGIxMSAqIGExMDtcbiAgICB3b3JsZFRyYW5zZm9ybS5kID0gYjEwICogYTAxICsgYjExICogYTExO1xuICAgIHdvcmxkVHJhbnNmb3JtLnR5ID0gYjEwICogYTAyICsgYjExICogYTEyICsgcGFyZW50VHJhbnNmb3JtLnR5O1xuXG4gICAgdGhpcy53b3JsZEFscGhhID0gdGhpcy5hbHBoYSAqIHRoaXMucGFyZW50LndvcmxkQWxwaGE7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgYm91bmRzIG9mIHRoZSBkaXNwbGF5T2JqZWN0IGFzIGEgcmVjdGFuZ2xlIG9iamVjdFxuICpcbiAqIEBtZXRob2QgZ2V0Qm91bmRzXG4gKiBAcmV0dXJuIHtSZWN0YW5nbGV9IHRoZSByZWN0YW5ndWxhciBib3VuZGluZyBhcmVhXG4gKi9cblBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24oIG1hdHJpeCApXG57XG4gICAgbWF0cml4ID0gbWF0cml4Oy8vanVzdCB0byBnZXQgcGFzc2VkIGpzIGhpbnRpbmcgKGFuZCBwcmVzZXJ2ZSBpbmhlcml0YW5jZSlcbiAgICByZXR1cm4gUElYSS5FbXB0eVJlY3RhbmdsZTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBsb2NhbCBib3VuZHMgb2YgdGhlIGRpc3BsYXlPYmplY3QgYXMgYSByZWN0YW5nbGUgb2JqZWN0XG4gKlxuICogQG1ldGhvZCBnZXRMb2NhbEJvdW5kc1xuICogQHJldHVybiB7UmVjdGFuZ2xlfSB0aGUgcmVjdGFuZ3VsYXIgYm91bmRpbmcgYXJlYVxuICovXG5QSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLmdldExvY2FsQm91bmRzID0gZnVuY3Rpb24oKVxue1xuICAgIHJldHVybiB0aGlzLmdldEJvdW5kcyhQSVhJLmlkZW50aXR5TWF0cml4KTsvLy9QSVhJLkVtcHR5UmVjdGFuZ2xlKCk7XG59O1xuXG5cbi8qKlxuICogU2V0cyB0aGUgb2JqZWN0J3Mgc3RhZ2UgcmVmZXJlbmNlLCB0aGUgc3RhZ2UgdGhpcyBvYmplY3QgaXMgY29ubmVjdGVkIHRvXG4gKlxuICogQG1ldGhvZCBzZXRTdGFnZVJlZmVyZW5jZVxuICogQHBhcmFtIHN0YWdlIHtTdGFnZX0gdGhlIHN0YWdlIHRoYXQgdGhlIG9iamVjdCB3aWxsIGhhdmUgYXMgaXRzIGN1cnJlbnQgc3RhZ2UgcmVmZXJlbmNlXG4gKi9cblBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuc2V0U3RhZ2VSZWZlcmVuY2UgPSBmdW5jdGlvbihzdGFnZSlcbntcbiAgICB0aGlzLnN0YWdlID0gc3RhZ2U7XG4gICAgaWYodGhpcy5faW50ZXJhY3RpdmUpdGhpcy5zdGFnZS5kaXJ0eSA9IHRydWU7XG59O1xuXG5QSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLmdlbmVyYXRlVGV4dHVyZSA9IGZ1bmN0aW9uKHJlbmRlcmVyKVxue1xuICAgIHZhciBib3VuZHMgPSB0aGlzLmdldExvY2FsQm91bmRzKCk7XG5cbiAgICB2YXIgcmVuZGVyVGV4dHVyZSA9IG5ldyBQSVhJLlJlbmRlclRleHR1cmUoYm91bmRzLndpZHRoIHwgMCwgYm91bmRzLmhlaWdodCB8IDAsIHJlbmRlcmVyKTtcbiAgICByZW5kZXJUZXh0dXJlLnJlbmRlcih0aGlzLCBuZXcgUElYSS5Qb2ludCgtYm91bmRzLngsIC1ib3VuZHMueSkgKTtcblxuICAgIHJldHVybiByZW5kZXJUZXh0dXJlO1xufTtcblxuUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS51cGRhdGVDYWNoZSA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLl9nZW5lcmF0ZUNhY2hlZFNwcml0ZSgpO1xufTtcblxuUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fcmVuZGVyQ2FjaGVkU3ByaXRlID0gZnVuY3Rpb24ocmVuZGVyU2Vzc2lvbilcbntcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUud29ybGRBbHBoYSA9IHRoaXMud29ybGRBbHBoYTtcbiAgIFxuICAgIGlmKHJlbmRlclNlc3Npb24uZ2wpXG4gICAge1xuICAgICAgICBQSVhJLlNwcml0ZS5wcm90b3R5cGUuX3JlbmRlcldlYkdMLmNhbGwodGhpcy5fY2FjaGVkU3ByaXRlLCByZW5kZXJTZXNzaW9uKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgUElYSS5TcHJpdGUucHJvdG90eXBlLl9yZW5kZXJDYW52YXMuY2FsbCh0aGlzLl9jYWNoZWRTcHJpdGUsIHJlbmRlclNlc3Npb24pO1xuICAgIH1cbn07XG5cblBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2dlbmVyYXRlQ2FjaGVkU3ByaXRlID0gZnVuY3Rpb24oKS8vcmVuZGVyU2Vzc2lvbilcbntcbiAgICB0aGlzLl9jYWNoZUFzQml0bWFwID0gZmFsc2U7XG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKTtcbiAgIFxuICAgIGlmKCF0aGlzLl9jYWNoZWRTcHJpdGUpXG4gICAge1xuICAgICAgICB2YXIgcmVuZGVyVGV4dHVyZSA9IG5ldyBQSVhJLlJlbmRlclRleHR1cmUoYm91bmRzLndpZHRoIHwgMCwgYm91bmRzLmhlaWdodCB8IDApOy8vLCByZW5kZXJTZXNzaW9uLnJlbmRlcmVyKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2NhY2hlZFNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZShyZW5kZXJUZXh0dXJlKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkU3ByaXRlLndvcmxkVHJhbnNmb3JtID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkU3ByaXRlLnRleHR1cmUucmVzaXplKGJvdW5kcy53aWR0aCB8IDAsIGJvdW5kcy5oZWlnaHQgfCAwKTtcbiAgICB9XG5cbiAgICAvL1JFTU9WRSBmaWx0ZXIhXG4gICAgdmFyIHRlbXBGaWx0ZXJzID0gdGhpcy5fZmlsdGVycztcbiAgICB0aGlzLl9maWx0ZXJzID0gbnVsbDtcblxuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5maWx0ZXJzID0gdGVtcEZpbHRlcnM7XG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLnRleHR1cmUucmVuZGVyKHRoaXMsIG5ldyBQSVhJLlBvaW50KC1ib3VuZHMueCwgLWJvdW5kcy55KSApO1xuXG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLmFuY2hvci54ID0gLSggYm91bmRzLnggLyBib3VuZHMud2lkdGggKTtcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUuYW5jaG9yLnkgPSAtKCBib3VuZHMueSAvIGJvdW5kcy5oZWlnaHQgKTtcblxuICAgIHRoaXMuX2ZpbHRlcnMgPSB0ZW1wRmlsdGVycztcblxuICAgIHRoaXMuX2NhY2hlQXNCaXRtYXAgPSB0cnVlO1xufTtcblxuLyoqXG4qIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbipcbiogQG1ldGhvZCBfcmVuZGVyV2ViR0xcbiogQHBhcmFtIHJlbmRlclNlc3Npb24ge1JlbmRlclNlc3Npb259IFxuKiBAcHJpdmF0ZVxuKi9cblBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2Rlc3Ryb3lDYWNoZWRTcHJpdGUgPSBmdW5jdGlvbigpXG57XG4gICAgaWYoIXRoaXMuX2NhY2hlZFNwcml0ZSlyZXR1cm47XG5cbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUudGV4dHVyZS5kZXN0cm95KHRydWUpO1xuICAvLyAgY29uc29sZS5sb2coXCJERVNUUk9ZXCIpXG4gICAgLy8gbGV0IHRoZSBnYyBjb2xsZWN0IHRoZSB1bnVzZWQgc3ByaXRlXG4gICAgLy8gVE9ETyBjb3VsZCBiZSBvYmplY3QgcG9vbGVkIVxuICAgIHRoaXMuX2NhY2hlZFNwcml0ZSA9IG51bGw7XG59O1xuXG5cblBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX3JlbmRlcldlYkdMID0gZnVuY3Rpb24ocmVuZGVyU2Vzc2lvbilcbntcbiAgICAvLyBPVkVSV1JJVEU7XG4gICAgLy8gdGhpcyBsaW5lIGlzIGp1c3QgaGVyZSB0byBwYXNzIGpzaGludGluZyA6KVxuICAgIHJlbmRlclNlc3Npb24gPSByZW5kZXJTZXNzaW9uO1xufTtcblxuLyoqXG4qIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgQ2FudmFzIHJlbmRlcmVyXG4qXG4qIEBtZXRob2QgX3JlbmRlckNhbnZhc1xuKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7UmVuZGVyU2Vzc2lvbn0gXG4qIEBwcml2YXRlXG4qL1xuUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzID0gZnVuY3Rpb24ocmVuZGVyU2Vzc2lvbilcbntcbiAgICAvLyBPVkVSV1JJVEU7XG4gICAgLy8gdGhpcyBsaW5lIGlzIGp1c3QgaGVyZSB0byBwYXNzIGpzaGludGluZyA6KVxuICAgIHJlbmRlclNlc3Npb24gPSByZW5kZXJTZXNzaW9uO1xufTtcblxuLyoqXG4gKiBUaGUgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXlPYmplY3Qgb24gdGhlIHggYXhpcyByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cbiAqXG4gKiBAcHJvcGVydHkgeFxuICogQHR5cGUgTnVtYmVyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLCAneCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIHRoaXMucG9zaXRpb24ueDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi54ID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogVGhlIHBvc2l0aW9uIG9mIHRoZSBkaXNwbGF5T2JqZWN0IG9uIHRoZSB5IGF4aXMgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXJlbnQuXG4gKlxuICogQHByb3BlcnR5IHlcbiAqIEB0eXBlIE51bWJlclxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZSwgJ3knLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICB0aGlzLnBvc2l0aW9uLnk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24ueSA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cblxuLyoqXG4gKiBBIERpc3BsYXlPYmplY3RDb250YWluZXIgcmVwcmVzZW50cyBhIGNvbGxlY3Rpb24gb2YgZGlzcGxheSBvYmplY3RzLlxuICogSXQgaXMgdGhlIGJhc2UgY2xhc3Mgb2YgYWxsIGRpc3BsYXkgb2JqZWN0cyB0aGF0IGFjdCBhcyBhIGNvbnRhaW5lciBmb3Igb3RoZXIgb2JqZWN0cy5cbiAqXG4gKiBAY2xhc3MgRGlzcGxheU9iamVjdENvbnRhaW5lclxuICogQGV4dGVuZHMgRGlzcGxheU9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lciA9IGZ1bmN0aW9uKClcbntcbiAgICBQSVhJLkRpc3BsYXlPYmplY3QuY2FsbCggdGhpcyApO1xuXG4gICAgLyoqXG4gICAgICogW3JlYWQtb25seV0gVGhlIGFycmF5IG9mIGNoaWxkcmVuIG9mIHRoaXMgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNoaWxkcmVuXG4gICAgICogQHR5cGUgQXJyYXk8RGlzcGxheU9iamVjdD5cbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG59O1xuXG4vLyBjb25zdHJ1Y3RvclxuUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUgKTtcblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXI7XG5cbi8qKlxuICogVGhlIHdpZHRoIG9mIHRoZSBkaXNwbGF5T2JqZWN0Q29udGFpbmVyLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxuICpcbiAqIEBwcm9wZXJ0eSB3aWR0aFxuICogQHR5cGUgTnVtYmVyXG4gKi9cblxuIFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUsICd3aWR0aCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZS54ICogdGhpcy5nZXRMb2NhbEJvdW5kcygpLndpZHRoO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpLndpZHRoO1xuXG4gICAgICAgIGlmKHdpZHRoICE9PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlLnggPSB2YWx1ZSAvICggd2lkdGgvdGhpcy5zY2FsZS54ICk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlLnggPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgXG4gICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgfVxufSk7XG5cblxuLyoqXG4gKiBUaGUgaGVpZ2h0IG9mIHRoZSBkaXNwbGF5T2JqZWN0Q29udGFpbmVyLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxuICpcbiAqIEBwcm9wZXJ0eSBoZWlnaHRcbiAqIEB0eXBlIE51bWJlclxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLCAnaGVpZ2h0Jywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAgdGhpcy5zY2FsZS55ICogdGhpcy5nZXRMb2NhbEJvdW5kcygpLmhlaWdodDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcblxuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpLmhlaWdodDtcblxuICAgICAgICBpZihoZWlnaHQgIT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGUueSA9IHZhbHVlIC8gKCBoZWlnaHQvdGhpcy5zY2FsZS55ICk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlLnkgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gICAgfVxufSk7XG5cblxuLyoqXG4gKiBBZGRzIGEgY2hpbGQgdG8gdGhlIGNvbnRhaW5lci5cbiAqXG4gKiBAbWV0aG9kIGFkZENoaWxkXG4gKiBAcGFyYW0gY2hpbGQge0Rpc3BsYXlPYmplY3R9IFRoZSBEaXNwbGF5T2JqZWN0IHRvIGFkZCB0byB0aGUgY29udGFpbmVyXG4gKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbihjaGlsZClcbntcbiAgICByZXR1cm4gdGhpcy5hZGRDaGlsZEF0KGNoaWxkLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBjaGlsZCB0byB0aGUgY29udGFpbmVyIGF0IGEgc3BlY2lmaWVkIGluZGV4LiBJZiB0aGUgaW5kZXggaXMgb3V0IG9mIGJvdW5kcyBhbiBlcnJvciB3aWxsIGJlIHRocm93blxuICpcbiAqIEBtZXRob2QgYWRkQ2hpbGRBdFxuICogQHBhcmFtIGNoaWxkIHtEaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgdG8gYWRkXG4gKiBAcGFyYW0gaW5kZXgge051bWJlcn0gVGhlIGluZGV4IHRvIHBsYWNlIHRoZSBjaGlsZCBpblxuICovXG5QSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLmFkZENoaWxkQXQgPSBmdW5jdGlvbihjaGlsZCwgaW5kZXgpXG57XG4gICAgaWYoaW5kZXggPj0gMCAmJiBpbmRleCA8PSB0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICB7XG4gICAgICAgIGlmKGNoaWxkLnBhcmVudClcbiAgICAgICAge1xuICAgICAgICAgICAgY2hpbGQucGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcblxuICAgICAgICBpZih0aGlzLnN0YWdlKWNoaWxkLnNldFN0YWdlUmVmZXJlbmNlKHRoaXMuc3RhZ2UpO1xuXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNoaWxkICsgJyBUaGUgaW5kZXggJysgaW5kZXggKycgc3VwcGxpZWQgaXMgb3V0IG9mIGJvdW5kcyAnICsgdGhpcy5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogW05ZSV0gU3dhcHMgdGhlIGRlcHRoIG9mIDIgZGlzcGxheU9iamVjdHNcbiAqXG4gKiBAbWV0aG9kIHN3YXBDaGlsZHJlblxuICogQHBhcmFtIGNoaWxkIHtEaXNwbGF5T2JqZWN0fVxuICogQHBhcmFtIGNoaWxkMiB7RGlzcGxheU9iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUuc3dhcENoaWxkcmVuID0gZnVuY3Rpb24oY2hpbGQsIGNoaWxkMilcbntcbiAgICBpZihjaGlsZCA9PT0gY2hpbGQyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXgxID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgICB2YXIgaW5kZXgyID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkMik7XG5cbiAgICBpZihpbmRleDEgPCAwIHx8IGluZGV4MiA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzd2FwQ2hpbGRyZW46IEJvdGggdGhlIHN1cHBsaWVkIERpc3BsYXlPYmplY3RzIG11c3QgYmUgYSBjaGlsZCBvZiB0aGUgY2FsbGVyLicpO1xuICAgIH1cblxuICAgIHRoaXMuY2hpbGRyZW5baW5kZXgxXSA9IGNoaWxkMjtcbiAgICB0aGlzLmNoaWxkcmVuW2luZGV4Ml0gPSBjaGlsZDtcbiAgICBcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY2hpbGQgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICpcbiAqIEBtZXRob2QgZ2V0Q2hpbGRBdFxuICogQHBhcmFtIGluZGV4IHtOdW1iZXJ9IFRoZSBpbmRleCB0byBnZXQgdGhlIGNoaWxkIGZyb21cbiAqL1xuUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZS5nZXRDaGlsZEF0ID0gZnVuY3Rpb24oaW5kZXgpXG57XG4gICAgaWYoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baW5kZXhdO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBsaWVkIGluZGV4IGRvZXMgbm90IGV4aXN0IGluIHRoZSBjaGlsZCBsaXN0LCBvciB0aGUgc3VwcGxpZWQgRGlzcGxheU9iamVjdCBtdXN0IGJlIGEgY2hpbGQgb2YgdGhlIGNhbGxlcicpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIGNoaWxkIGZyb20gdGhlIGNvbnRhaW5lci5cbiAqXG4gKiBAbWV0aG9kIHJlbW92ZUNoaWxkXG4gKiBAcGFyYW0gY2hpbGQge0Rpc3BsYXlPYmplY3R9IFRoZSBEaXNwbGF5T2JqZWN0IHRvIHJlbW92ZVxuICovXG5QSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24oY2hpbGQpXG57XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlQ2hpbGRBdCggdGhpcy5jaGlsZHJlbi5pbmRleE9mKCBjaGlsZCApICk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBjaGlsZCBmcm9tIHRoZSBzcGVjaWZpZWQgaW5kZXggcG9zaXRpb24gaW4gdGhlIGNoaWxkIGxpc3Qgb2YgdGhlIGNvbnRhaW5lci5cbiAqXG4gKiBAbWV0aG9kIHJlbW92ZUNoaWxkQXRcbiAqIEBwYXJhbSBpbmRleCB7TnVtYmVyfSBUaGUgaW5kZXggdG8gZ2V0IHRoZSBjaGlsZCBmcm9tXG4gKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUucmVtb3ZlQ2hpbGRBdCA9IGZ1bmN0aW9uKGluZGV4KVxue1xuICAgIHZhciBjaGlsZCA9IHRoaXMuZ2V0Q2hpbGRBdCggaW5kZXggKTtcbiAgICBpZih0aGlzLnN0YWdlKVxuICAgICAgICBjaGlsZC5yZW1vdmVTdGFnZVJlZmVyZW5jZSgpO1xuXG4gICAgY2hpbGQucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKCBpbmRleCwgMSApO1xuICAgIHJldHVybiBjaGlsZDtcbn07XG5cbi8qKlxuKiBSZW1vdmVzIGFsbCBjaGlsZCBpbnN0YW5jZXMgZnJvbSB0aGUgY2hpbGQgbGlzdCBvZiB0aGUgY29udGFpbmVyLlxuKlxuKiBAbWV0aG9kIHJlbW92ZUNoaWxkcmVuXG4qIEBwYXJhbSBiZWdpbkluZGV4IHtOdW1iZXJ9IFRoZSBiZWdpbm5pbmcgcG9zaXRpb24uIFByZWRlZmluZWQgdmFsdWUgaXMgMC5cbiogQHBhcmFtIGVuZEluZGV4IHtOdW1iZXJ9IFRoZSBlbmRpbmcgcG9zaXRpb24uIFByZWRlZmluZWQgdmFsdWUgaXMgY2hpbGRyZW4ncyBhcnJheSBsZW5ndGguXG4qL1xuUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZS5yZW1vdmVDaGlsZHJlbiA9IGZ1bmN0aW9uKGJlZ2luSW5kZXgsIGVuZEluZGV4KVxue1xuICAgIHZhciBiZWdpbiA9IGJlZ2luSW5kZXggfHwgMDtcbiAgICB2YXIgZW5kID0gdHlwZW9mIGVuZEluZGV4ID09PSAnbnVtYmVyJyA/IGVuZEluZGV4IDogdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgdmFyIHJhbmdlID0gZW5kIC0gYmVnaW47XG5cbiAgICBpZiAocmFuZ2UgPiAwICYmIHJhbmdlIDw9IGVuZClcbiAgICB7XG4gICAgICAgIHZhciByZW1vdmVkID0gdGhpcy5jaGlsZHJlbi5zcGxpY2UoYmVnaW4sIHJhbmdlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1vdmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSByZW1vdmVkW2ldO1xuICAgICAgICAgICAgaWYodGhpcy5zdGFnZSlcbiAgICAgICAgICAgICAgICBjaGlsZC5yZW1vdmVTdGFnZVJlZmVyZW5jZSgpO1xuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICdSYW5nZSBFcnJvciwgbnVtZXJpYyB2YWx1ZXMgYXJlIG91dHNpZGUgdGhlIGFjY2VwdGFibGUgcmFuZ2UnICk7XG4gICAgfVxufTtcblxuLypcbiAqIFVwZGF0ZXMgdGhlIGNvbnRhaW5lcidzIGNoaWxkcmVucyB0cmFuc2Zvcm0gZm9yIHJlbmRlcmluZ1xuICpcbiAqIEBtZXRob2QgdXBkYXRlVHJhbnNmb3JtXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uKClcbntcbiAgICAvL3RoaXMuX2N1cnJlbnRCb3VuZHMgPSBudWxsO1xuXG4gICAgaWYoIXRoaXMudmlzaWJsZSlyZXR1cm47XG5cbiAgICBQSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybS5jYWxsKCB0aGlzICk7XG5cbiAgICBpZih0aGlzLl9jYWNoZUFzQml0bWFwKXJldHVybjtcblxuICAgIGZvcih2YXIgaT0wLGo9dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGk8ajsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgYm91bmRzIG9mIHRoZSBkaXNwbGF5T2JqZWN0Q29udGFpbmVyIGFzIGEgcmVjdGFuZ2xlIG9iamVjdFxuICpcbiAqIEBtZXRob2QgZ2V0Qm91bmRzXG4gKiBAcmV0dXJuIHtSZWN0YW5nbGV9IHRoZSByZWN0YW5ndWxhciBib3VuZGluZyBhcmVhXG4gKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24obWF0cml4KVxue1xuICAgIGlmKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKXJldHVybiBQSVhJLkVtcHR5UmVjdGFuZ2xlO1xuXG4gICAgLy8gVE9ETyB0aGUgYm91bmRzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGN1bGF0ZWQgdGhpcyByZW5kZXIgc2Vzc2lvbiBzbyByZXR1cm4gd2hhdCB3ZSBoYXZlXG4gICAgaWYobWF0cml4KVxuICAgIHtcbiAgICAgICAgdmFyIG1hdHJpeENhY2hlID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgdGhpcy53b3JsZFRyYW5zZm9ybSA9IG1hdHJpeDtcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy53b3JsZFRyYW5zZm9ybSA9IG1hdHJpeENhY2hlO1xuICAgIH1cblxuICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgdmFyIG1pblkgPSBJbmZpbml0eTtcblxuICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xuICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xuXG4gICAgdmFyIGNoaWxkQm91bmRzO1xuICAgIHZhciBjaGlsZE1heFg7XG4gICAgdmFyIGNoaWxkTWF4WTtcblxuICAgIHZhciBjaGlsZFZpc2libGUgPSBmYWxzZTtcblxuICAgIGZvcih2YXIgaT0wLGo9dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGk8ajsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgXG4gICAgICAgIGlmKCFjaGlsZC52aXNpYmxlKWNvbnRpbnVlO1xuXG4gICAgICAgIGNoaWxkVmlzaWJsZSA9IHRydWU7XG5cbiAgICAgICAgY2hpbGRCb3VuZHMgPSB0aGlzLmNoaWxkcmVuW2ldLmdldEJvdW5kcyggbWF0cml4ICk7XG4gICAgIFxuICAgICAgICBtaW5YID0gbWluWCA8IGNoaWxkQm91bmRzLnggPyBtaW5YIDogY2hpbGRCb3VuZHMueDtcbiAgICAgICAgbWluWSA9IG1pblkgPCBjaGlsZEJvdW5kcy55ID8gbWluWSA6IGNoaWxkQm91bmRzLnk7XG5cbiAgICAgICAgY2hpbGRNYXhYID0gY2hpbGRCb3VuZHMud2lkdGggKyBjaGlsZEJvdW5kcy54O1xuICAgICAgICBjaGlsZE1heFkgPSBjaGlsZEJvdW5kcy5oZWlnaHQgKyBjaGlsZEJvdW5kcy55O1xuXG4gICAgICAgIG1heFggPSBtYXhYID4gY2hpbGRNYXhYID8gbWF4WCA6IGNoaWxkTWF4WDtcbiAgICAgICAgbWF4WSA9IG1heFkgPiBjaGlsZE1heFkgPyBtYXhZIDogY2hpbGRNYXhZO1xuICAgIH1cblxuICAgIGlmKCFjaGlsZFZpc2libGUpXG4gICAgICAgIHJldHVybiBQSVhJLkVtcHR5UmVjdGFuZ2xlO1xuXG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuX2JvdW5kcztcblxuICAgIGJvdW5kcy54ID0gbWluWDtcbiAgICBib3VuZHMueSA9IG1pblk7XG4gICAgYm91bmRzLndpZHRoID0gbWF4WCAtIG1pblg7XG4gICAgYm91bmRzLmhlaWdodCA9IG1heFkgLSBtaW5ZO1xuXG4gICAgLy8gVE9ETzogc3RvcmUgYSByZWZlcmVuY2Ugc28gdGhhdCBpZiB0aGlzIGZ1bmN0aW9uIGdldHMgY2FsbGVkIGFnYWluIGluIHRoZSByZW5kZXIgY3ljbGUgd2UgZG8gbm90IGhhdmUgdG8gcmVjYWxjdWxhdGVcbiAgICAvL3RoaXMuX2N1cnJlbnRCb3VuZHMgPSBib3VuZHM7XG4gICBcbiAgICByZXR1cm4gYm91bmRzO1xufTtcblxuUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZS5nZXRMb2NhbEJvdW5kcyA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgbWF0cml4Q2FjaGUgPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgdGhpcy53b3JsZFRyYW5zZm9ybSA9IFBJWEkuaWRlbnRpdHlNYXRyaXg7XG5cbiAgICBmb3IodmFyIGk9MCxqPXRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpPGo7IGkrKylcbiAgICB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0udXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgfVxuXG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XG5cbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtID0gbWF0cml4Q2FjaGU7XG5cbiAgICByZXR1cm4gYm91bmRzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb250YWluZXIncyBzdGFnZSByZWZlcmVuY2UsIHRoZSBzdGFnZSB0aGlzIG9iamVjdCBpcyBjb25uZWN0ZWQgdG9cbiAqXG4gKiBAbWV0aG9kIHNldFN0YWdlUmVmZXJlbmNlXG4gKiBAcGFyYW0gc3RhZ2Uge1N0YWdlfSB0aGUgc3RhZ2UgdGhhdCB0aGUgY29udGFpbmVyIHdpbGwgaGF2ZSBhcyBpdHMgY3VycmVudCBzdGFnZSByZWZlcmVuY2VcbiAqL1xuUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZS5zZXRTdGFnZVJlZmVyZW5jZSA9IGZ1bmN0aW9uKHN0YWdlKVxue1xuICAgIHRoaXMuc3RhZ2UgPSBzdGFnZTtcbiAgICBpZih0aGlzLl9pbnRlcmFjdGl2ZSl0aGlzLnN0YWdlLmRpcnR5ID0gdHJ1ZTtcblxuICAgIGZvcih2YXIgaT0wLGo9dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGk8ajsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgY2hpbGQuc2V0U3RhZ2VSZWZlcmVuY2Uoc3RhZ2UpO1xuICAgIH1cbn07XG5cbi8qKlxuICogcmVtb3ZlcyB0aGUgY3VycmVudCBzdGFnZSByZWZlcmVuY2Ugb2YgdGhlIGNvbnRhaW5lclxuICpcbiAqIEBtZXRob2QgcmVtb3ZlU3RhZ2VSZWZlcmVuY2VcbiAqL1xuUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZS5yZW1vdmVTdGFnZVJlZmVyZW5jZSA9IGZ1bmN0aW9uKClcbntcblxuICAgIGZvcih2YXIgaT0wLGo9dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGk8ajsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgY2hpbGQucmVtb3ZlU3RhZ2VSZWZlcmVuY2UoKTtcbiAgICB9XG5cbiAgICBpZih0aGlzLl9pbnRlcmFjdGl2ZSl0aGlzLnN0YWdlLmRpcnR5ID0gdHJ1ZTtcbiAgICBcbiAgICB0aGlzLnN0YWdlID0gbnVsbDtcbn07XG5cbi8qKlxuKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyXG4qXG4qIEBtZXRob2QgX3JlbmRlcldlYkdMXG4qIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtSZW5kZXJTZXNzaW9ufSBcbiogQHByaXZhdGVcbiovXG5QSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLl9yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uKHJlbmRlclNlc3Npb24pXG57XG4gICAgaWYoIXRoaXMudmlzaWJsZSB8fCB0aGlzLmFscGhhIDw9IDApcmV0dXJuO1xuICAgIFxuICAgIGlmKHRoaXMuX2NhY2hlQXNCaXRtYXApXG4gICAge1xuICAgICAgICB0aGlzLl9yZW5kZXJDYWNoZWRTcHJpdGUocmVuZGVyU2Vzc2lvbik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgdmFyIGksajtcblxuICAgIGlmKHRoaXMuX21hc2sgfHwgdGhpcy5fZmlsdGVycylcbiAgICB7XG4gICAgICAgIFxuICAgICAgICAvLyBwdXNoIGZpbHRlciBmaXJzdCBhcyB3ZSBuZWVkIHRvIGVuc3VyZSB0aGUgc3RlbmNpbCBidWZmZXIgaXMgY29ycmVjdCBmb3IgYW55IG1hc2tpbmdcbiAgICAgICAgaWYodGhpcy5fZmlsdGVycylcbiAgICAgICAge1xuICAgICAgICAgICAgcmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaC5mbHVzaCgpO1xuICAgICAgICAgICAgcmVuZGVyU2Vzc2lvbi5maWx0ZXJNYW5hZ2VyLnB1c2hGaWx0ZXIodGhpcy5fZmlsdGVyQmxvY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5fbWFzaylcbiAgICAgICAge1xuICAgICAgICAgICAgcmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaC5zdG9wKCk7XG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLm1hc2tNYW5hZ2VyLnB1c2hNYXNrKHRoaXMubWFzaywgcmVuZGVyU2Vzc2lvbik7XG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLnN0YXJ0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaW1wbGUgcmVuZGVyIGNoaWxkcmVuIVxuICAgICAgICBmb3IoaT0wLGo9dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGk8ajsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLl9yZW5kZXJXZWJHTChyZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2guc3RvcCgpO1xuXG4gICAgICAgIGlmKHRoaXMuX21hc2spcmVuZGVyU2Vzc2lvbi5tYXNrTWFuYWdlci5wb3BNYXNrKHRoaXMuX21hc2ssIHJlbmRlclNlc3Npb24pO1xuICAgICAgICBpZih0aGlzLl9maWx0ZXJzKXJlbmRlclNlc3Npb24uZmlsdGVyTWFuYWdlci5wb3BGaWx0ZXIoKTtcbiAgICAgICAgXG4gICAgICAgIHJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2guc3RhcnQoKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgLy8gc2ltcGxlIHJlbmRlciBjaGlsZHJlbiFcbiAgICAgICAgZm9yKGk9MCxqPXRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpPGo7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5fcmVuZGVyV2ViR0wocmVuZGVyU2Vzc2lvbik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbipcbiogQG1ldGhvZCBfcmVuZGVyQ2FudmFzXG4qIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtSZW5kZXJTZXNzaW9ufSBcbiogQHByaXZhdGVcbiovXG5QSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLl9yZW5kZXJDYW52YXMgPSBmdW5jdGlvbihyZW5kZXJTZXNzaW9uKVxue1xuICAgIGlmKHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgfHwgdGhpcy5hbHBoYSA9PT0gMClyZXR1cm47XG5cbiAgICBpZih0aGlzLl9jYWNoZUFzQml0bWFwKVxuICAgIHtcblxuICAgICAgICB0aGlzLl9yZW5kZXJDYWNoZWRTcHJpdGUocmVuZGVyU2Vzc2lvbik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZih0aGlzLl9tYXNrKVxuICAgIHtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5tYXNrTWFuYWdlci5wdXNoTWFzayh0aGlzLl9tYXNrLCByZW5kZXJTZXNzaW9uLmNvbnRleHQpO1xuICAgIH1cblxuICAgIGZvcih2YXIgaT0wLGo9dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGk8ajsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgY2hpbGQuX3JlbmRlckNhbnZhcyhyZW5kZXJTZXNzaW9uKTtcbiAgICB9XG5cbiAgICBpZih0aGlzLl9tYXNrKVxuICAgIHtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5tYXNrTWFuYWdlci5wb3BNYXNrKHJlbmRlclNlc3Npb24uY29udGV4dCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqIFRoZSBTcHJpdGUgb2JqZWN0IGlzIHRoZSBiYXNlIGZvciBhbGwgdGV4dHVyZWQgb2JqZWN0cyB0aGF0IGFyZSByZW5kZXJlZCB0byB0aGUgc2NyZWVuXG4gKlxuICogQGNsYXNzIFNwcml0ZVxuICogQGV4dGVuZHMgRGlzcGxheU9iamVjdENvbnRhaW5lclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gdGV4dHVyZSB7VGV4dHVyZX0gVGhlIHRleHR1cmUgZm9yIHRoaXMgc3ByaXRlXG4gKiBcbiAqIEEgc3ByaXRlIGNhbiBiZSBjcmVhdGVkIGRpcmVjdGx5IGZyb20gYW4gaW1hZ2UgbGlrZSB0aGlzIDogXG4gKiB2YXIgc3ByaXRlID0gbmV3IFBJWEkuU3ByaXRlLmZyb21JbWFnZSgnYXNzZXRzL2ltYWdlLnBuZycpO1xuICogeW91clN0YWdlLmFkZENoaWxkKHNwcml0ZSk7XG4gKiB0aGVuIG9idmlvdXNseSBkb24ndCBmb3JnZXQgdG8gYWRkIGl0IHRvIHRoZSBzdGFnZSB5b3UgaGF2ZSBhbHJlYWR5IGNyZWF0ZWRcbiAqL1xuUElYSS5TcHJpdGUgPSBmdW5jdGlvbih0ZXh0dXJlKVxue1xuICAgIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKCB0aGlzICk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYW5jaG9yIHNldHMgdGhlIG9yaWdpbiBwb2ludCBvZiB0aGUgdGV4dHVyZS5cbiAgICAgKiBUaGUgZGVmYXVsdCBpcyAwLDAgdGhpcyBtZWFucyB0aGUgdGV4dHVyZSdzIG9yaWdpbiBpcyB0aGUgdG9wIGxlZnRcbiAgICAgKiBTZXR0aW5nIHRoYW4gYW5jaG9yIHRvIDAuNSwwLjUgbWVhbnMgdGhlIHRleHR1cmVzIG9yaWdpbiBpcyBjZW50cmVkXG4gICAgICogU2V0dGluZyB0aGUgYW5jaG9yIHRvIDEsMSB3b3VsZCBtZWFuIHRoZSB0ZXh0dXJlcyBvcmlnaW4gcG9pbnRzIHdpbGwgYmUgdGhlIGJvdHRvbSByaWdodCBjb3JuZXJcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBhbmNob3JcbiAgICAgKiBAdHlwZSBQb2ludFxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yID0gbmV3IFBJWEkuUG9pbnQoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0dXJlIHRoYXQgdGhlIHNwcml0ZSBpcyB1c2luZ1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRleHR1cmVcbiAgICAgKiBAdHlwZSBUZXh0dXJlXG4gICAgICovXG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgc3ByaXRlICh0aGlzIGlzIGluaXRpYWxseSBzZXQgYnkgdGhlIHRleHR1cmUpXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgX3dpZHRoXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl93aWR0aCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBzcHJpdGUgKHRoaXMgaXMgaW5pdGlhbGx5IHNldCBieSB0aGUgdGV4dHVyZSlcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBfaGVpZ2h0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9oZWlnaHQgPSAwO1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGludCBhcHBsaWVkIHRvIHRoZSBzcHJpdGUuIFRoaXMgaXMgYSBoZXggdmFsdWVcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0aW50XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMHhGRkZGRkZcbiAgICAgKi9cbiAgICB0aGlzLnRpbnQgPSAweEZGRkZGRjsvLyAqIE1hdGgucmFuZG9tKCk7XG4gICAgXG4gICAgLyoqXG4gICAgICogVGhlIGJsZW5kIG1vZGUgdG8gYmUgYXBwbGllZCB0byB0aGUgc3ByaXRlXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYmxlbmRNb2RlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgUElYSS5ibGVuZE1vZGVzLk5PUk1BTDtcbiAgICAgKi9cbiAgICB0aGlzLmJsZW5kTW9kZSA9IFBJWEkuYmxlbmRNb2Rlcy5OT1JNQUw7XG5cbiAgICBpZih0ZXh0dXJlLmJhc2VUZXh0dXJlLmhhc0xvYWRlZClcbiAgICB7XG4gICAgICAgIHRoaXMub25UZXh0dXJlVXBkYXRlKCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMub25UZXh0dXJlVXBkYXRlQmluZCA9IHRoaXMub25UZXh0dXJlVXBkYXRlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCAndXBkYXRlJywgdGhpcy5vblRleHR1cmVVcGRhdGVCaW5kICk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJhYmxlID0gdHJ1ZTtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLlNwcml0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlICk7XG5QSVhJLlNwcml0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLlNwcml0ZTtcblxuLyoqXG4gKiBUaGUgd2lkdGggb2YgdGhlIHNwcml0ZSwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcbiAqXG4gKiBAcHJvcGVydHkgd2lkdGhcbiAqIEB0eXBlIE51bWJlclxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5TcHJpdGUucHJvdG90eXBlLCAnd2lkdGgnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUueCAqIHRoaXMudGV4dHVyZS5mcmFtZS53aWR0aDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5zY2FsZS54ID0gdmFsdWUgLyB0aGlzLnRleHR1cmUuZnJhbWUud2lkdGg7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogVGhlIGhlaWdodCBvZiB0aGUgc3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxuICpcbiAqIEBwcm9wZXJ0eSBoZWlnaHRcbiAqIEB0eXBlIE51bWJlclxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5TcHJpdGUucHJvdG90eXBlLCAnaGVpZ2h0Jywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAgdGhpcy5zY2FsZS55ICogdGhpcy50ZXh0dXJlLmZyYW1lLmhlaWdodDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5zY2FsZS55ID0gdmFsdWUgLyB0aGlzLnRleHR1cmUuZnJhbWUuaGVpZ2h0O1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBTZXRzIHRoZSB0ZXh0dXJlIG9mIHRoZSBzcHJpdGVcbiAqXG4gKiBAbWV0aG9kIHNldFRleHR1cmVcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfSBUaGUgUElYSSB0ZXh0dXJlIHRoYXQgaXMgZGlzcGxheWVkIGJ5IHRoZSBzcHJpdGVcbiAqL1xuUElYSS5TcHJpdGUucHJvdG90eXBlLnNldFRleHR1cmUgPSBmdW5jdGlvbih0ZXh0dXJlKVxue1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgdGhpcy5jYWNoZWRUaW50ID0gMHhGRkZGRkY7XG59O1xuXG4vKipcbiAqIFdoZW4gdGhlIHRleHR1cmUgaXMgdXBkYXRlZCwgdGhpcyBldmVudCB3aWxsIGZpcmUgdG8gdXBkYXRlIHRoZSBzY2FsZSBhbmQgZnJhbWVcbiAqXG4gKiBAbWV0aG9kIG9uVGV4dHVyZVVwZGF0ZVxuICogQHBhcmFtIGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlNwcml0ZS5wcm90b3R5cGUub25UZXh0dXJlVXBkYXRlID0gZnVuY3Rpb24oKVxue1xuICAgIC8vIHNvIGlmIF93aWR0aCBpcyAwIHRoZW4gd2lkdGggd2FzIG5vdCBzZXQuLlxuICAgIGlmKHRoaXMuX3dpZHRoKXRoaXMuc2NhbGUueCA9IHRoaXMuX3dpZHRoIC8gdGhpcy50ZXh0dXJlLmZyYW1lLndpZHRoO1xuICAgIGlmKHRoaXMuX2hlaWdodCl0aGlzLnNjYWxlLnkgPSB0aGlzLl9oZWlnaHQgLyB0aGlzLnRleHR1cmUuZnJhbWUuaGVpZ2h0O1xuXG5cbiAgICAvL3RoaXMudXBkYXRlRnJhbWUgPSB0cnVlO1xufTtcblxuLyoqXG4qIFJldHVybnMgdGhlIGZyYW1pbmcgcmVjdGFuZ2xlIG9mIHRoZSBzcHJpdGUgYXMgYSBQSVhJLlJlY3RhbmdsZSBvYmplY3RcbipcbiogQG1ldGhvZCBnZXRCb3VuZHNcbiogQHBhcmFtIG1hdHJpeCB7TWF0cml4fSB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IG9mIHRoZSBzcHJpdGVcbiogQHJldHVybiB7UmVjdGFuZ2xlfSB0aGUgZnJhbWluZyByZWN0YW5nbGVcbiovXG5QSVhJLlNwcml0ZS5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24obWF0cml4KVxue1xuXG4gICAgdmFyIHdpZHRoID0gdGhpcy50ZXh0dXJlLmZyYW1lLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLnRleHR1cmUuZnJhbWUuaGVpZ2h0O1xuXG4gICAgdmFyIHcwID0gd2lkdGggKiAoMS10aGlzLmFuY2hvci54KTtcbiAgICB2YXIgdzEgPSB3aWR0aCAqIC10aGlzLmFuY2hvci54O1xuXG4gICAgdmFyIGgwID0gaGVpZ2h0ICogKDEtdGhpcy5hbmNob3IueSk7XG4gICAgdmFyIGgxID0gaGVpZ2h0ICogLXRoaXMuYW5jaG9yLnk7XG5cbiAgICB2YXIgd29ybGRUcmFuc2Zvcm0gPSBtYXRyaXggfHwgdGhpcy53b3JsZFRyYW5zZm9ybSA7XG5cbiAgICB2YXIgYSA9IHdvcmxkVHJhbnNmb3JtLmE7XG4gICAgdmFyIGIgPSB3b3JsZFRyYW5zZm9ybS5jO1xuICAgIHZhciBjID0gd29ybGRUcmFuc2Zvcm0uYjtcbiAgICB2YXIgZCA9IHdvcmxkVHJhbnNmb3JtLmQ7XG4gICAgdmFyIHR4ID0gd29ybGRUcmFuc2Zvcm0udHg7XG4gICAgdmFyIHR5ID0gd29ybGRUcmFuc2Zvcm0udHk7XG5cbiAgICB2YXIgeDEgPSBhICogdzEgKyBjICogaDEgKyB0eDtcbiAgICB2YXIgeTEgPSBkICogaDEgKyBiICogdzEgKyB0eTtcblxuICAgIHZhciB4MiA9IGEgKiB3MCArIGMgKiBoMSArIHR4O1xuICAgIHZhciB5MiA9IGQgKiBoMSArIGIgKiB3MCArIHR5O1xuXG4gICAgdmFyIHgzID0gYSAqIHcwICsgYyAqIGgwICsgdHg7XG4gICAgdmFyIHkzID0gZCAqIGgwICsgYiAqIHcwICsgdHk7XG5cbiAgICB2YXIgeDQgPSAgYSAqIHcxICsgYyAqIGgwICsgdHg7XG4gICAgdmFyIHk0ID0gIGQgKiBoMCArIGIgKiB3MSArIHR5O1xuXG4gICAgdmFyIG1heFggPSAtSW5maW5pdHk7XG4gICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICB2YXIgbWluWCA9IEluZmluaXR5O1xuICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG5cbiAgICBtaW5YID0geDEgPCBtaW5YID8geDEgOiBtaW5YO1xuICAgIG1pblggPSB4MiA8IG1pblggPyB4MiA6IG1pblg7XG4gICAgbWluWCA9IHgzIDwgbWluWCA/IHgzIDogbWluWDtcbiAgICBtaW5YID0geDQgPCBtaW5YID8geDQgOiBtaW5YO1xuXG4gICAgbWluWSA9IHkxIDwgbWluWSA/IHkxIDogbWluWTtcbiAgICBtaW5ZID0geTIgPCBtaW5ZID8geTIgOiBtaW5ZO1xuICAgIG1pblkgPSB5MyA8IG1pblkgPyB5MyA6IG1pblk7XG4gICAgbWluWSA9IHk0IDwgbWluWSA/IHk0IDogbWluWTtcblxuICAgIG1heFggPSB4MSA+IG1heFggPyB4MSA6IG1heFg7XG4gICAgbWF4WCA9IHgyID4gbWF4WCA/IHgyIDogbWF4WDtcbiAgICBtYXhYID0geDMgPiBtYXhYID8geDMgOiBtYXhYO1xuICAgIG1heFggPSB4NCA+IG1heFggPyB4NCA6IG1heFg7XG5cbiAgICBtYXhZID0geTEgPiBtYXhZID8geTEgOiBtYXhZO1xuICAgIG1heFkgPSB5MiA+IG1heFkgPyB5MiA6IG1heFk7XG4gICAgbWF4WSA9IHkzID4gbWF4WSA/IHkzIDogbWF4WTtcbiAgICBtYXhZID0geTQgPiBtYXhZID8geTQgOiBtYXhZO1xuXG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuX2JvdW5kcztcblxuICAgIGJvdW5kcy54ID0gbWluWDtcbiAgICBib3VuZHMud2lkdGggPSBtYXhYIC0gbWluWDtcblxuICAgIGJvdW5kcy55ID0gbWluWTtcbiAgICBib3VuZHMuaGVpZ2h0ID0gbWF4WSAtIG1pblk7XG5cbiAgICAvLyBzdG9yZSBhIHJlZmVyZW5jZSBzbyB0aGF0IGlmIHRoaXMgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgYWdhaW4gaW4gdGhlIHJlbmRlciBjeWNsZSB3ZSBkbyBub3QgaGF2ZSB0byByZWNhbGN1bGF0ZVxuICAgIHRoaXMuX2N1cnJlbnRCb3VuZHMgPSBib3VuZHM7XG5cbiAgICByZXR1cm4gYm91bmRzO1xufTtcblxuLyoqXG4qIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbipcbiogQG1ldGhvZCBfcmVuZGVyV2ViR0xcbiogQHBhcmFtIHJlbmRlclNlc3Npb24ge1JlbmRlclNlc3Npb259IFxuKiBAcHJpdmF0ZVxuKi9cblBJWEkuU3ByaXRlLnByb3RvdHlwZS5fcmVuZGVyV2ViR0wgPSBmdW5jdGlvbihyZW5kZXJTZXNzaW9uKVxue1xuICAgIC8vIGlmIHRoZSBzcHJpdGUgaXMgbm90IHZpc2libGUgb3IgdGhlIGFscGhhIGlzIDAgdGhlbiBubyBuZWVkIHRvIHJlbmRlciB0aGlzIGVsZW1lbnRcbiAgICBpZighdGhpcy52aXNpYmxlIHx8IHRoaXMuYWxwaGEgPD0gMClyZXR1cm47XG4gICAgXG4gICAgdmFyIGksajtcblxuICAgIC8vIGRvIGEgcXVpY2sgY2hlY2sgdG8gc2VlIGlmIHRoaXMgZWxlbWVudCBoYXMgYSBtYXNrIG9yIGEgZmlsdGVyLlxuICAgIGlmKHRoaXMuX21hc2sgfHwgdGhpcy5fZmlsdGVycylcbiAgICB7XG4gICAgICAgIHZhciBzcHJpdGVCYXRjaCA9ICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoO1xuXG4gICAgICAgIC8vIHB1c2ggZmlsdGVyIGZpcnN0IGFzIHdlIG5lZWQgdG8gZW5zdXJlIHRoZSBzdGVuY2lsIGJ1ZmZlciBpcyBjb3JyZWN0IGZvciBhbnkgbWFza2luZ1xuICAgICAgICBpZih0aGlzLl9maWx0ZXJzKVxuICAgICAgICB7XG4gICAgICAgICAgICBzcHJpdGVCYXRjaC5mbHVzaCgpO1xuICAgICAgICAgICAgcmVuZGVyU2Vzc2lvbi5maWx0ZXJNYW5hZ2VyLnB1c2hGaWx0ZXIodGhpcy5fZmlsdGVyQmxvY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5fbWFzaylcbiAgICAgICAge1xuICAgICAgICAgICAgc3ByaXRlQmF0Y2guc3RvcCgpO1xuICAgICAgICAgICAgcmVuZGVyU2Vzc2lvbi5tYXNrTWFuYWdlci5wdXNoTWFzayh0aGlzLm1hc2ssIHJlbmRlclNlc3Npb24pO1xuICAgICAgICAgICAgc3ByaXRlQmF0Y2guc3RhcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0aGlzIHNwcml0ZSB0byB0aGUgYmF0Y2hcbiAgICAgICAgc3ByaXRlQmF0Y2gucmVuZGVyKHRoaXMpO1xuXG4gICAgICAgIC8vIG5vdyBsb29wIHRocm91Z2ggdGhlIGNoaWxkcmVuIGFuZCBtYWtlIHN1cmUgdGhleSBnZXQgcmVuZGVyZWRcbiAgICAgICAgZm9yKGk9MCxqPXRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpPGo7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5fcmVuZGVyV2ViR0wocmVuZGVyU2Vzc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aW1lIHRvIHN0b3AgdGhlIHNwcml0ZSBiYXRjaCBhcyBlaXRoZXIgYSBtYXNrIGVsZW1lbnQgb3IgYSBmaWx0ZXIgZHJhdyB3aWxsIGhhcHBlbiBuZXh0XG4gICAgICAgIHNwcml0ZUJhdGNoLnN0b3AoKTtcblxuICAgICAgICBpZih0aGlzLl9tYXNrKXJlbmRlclNlc3Npb24ubWFza01hbmFnZXIucG9wTWFzayh0aGlzLl9tYXNrLCByZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgaWYodGhpcy5fZmlsdGVycylyZW5kZXJTZXNzaW9uLmZpbHRlck1hbmFnZXIucG9wRmlsdGVyKCk7XG4gICAgICAgIFxuICAgICAgICBzcHJpdGVCYXRjaC5zdGFydCgpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLnJlbmRlcih0aGlzKTtcblxuICAgICAgICAvLyBzaW1wbGUgcmVuZGVyIGNoaWxkcmVuIVxuICAgICAgICBmb3IoaT0wLGo9dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGk8ajsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLl9yZW5kZXJXZWJHTChyZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgXG4gICAgLy9UT0RPIGNoZWNrIGN1bGxpbmcgIFxufTtcblxuLyoqXG4qIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgQ2FudmFzIHJlbmRlcmVyXG4qXG4qIEBtZXRob2QgX3JlbmRlckNhbnZhc1xuKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7UmVuZGVyU2Vzc2lvbn0gXG4qIEBwcml2YXRlXG4qL1xuUElYSS5TcHJpdGUucHJvdG90eXBlLl9yZW5kZXJDYW52YXMgPSBmdW5jdGlvbihyZW5kZXJTZXNzaW9uKVxue1xuICAgIC8vIElmIHRoZSBzcHJpdGUgaXMgbm90IHZpc2libGUgb3IgdGhlIGFscGhhIGlzIDAgdGhlbiBubyBuZWVkIHRvIHJlbmRlciB0aGlzIGVsZW1lbnRcbiAgICBpZiAodGhpcy52aXNpYmxlID09PSBmYWxzZSB8fCB0aGlzLmFscGhhID09PSAwKSByZXR1cm47XG4gICAgXG4gICAgaWYgKHRoaXMuYmxlbmRNb2RlICE9PSByZW5kZXJTZXNzaW9uLmN1cnJlbnRCbGVuZE1vZGUpXG4gICAge1xuICAgICAgICByZW5kZXJTZXNzaW9uLmN1cnJlbnRCbGVuZE1vZGUgPSB0aGlzLmJsZW5kTW9kZTtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5jb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tyZW5kZXJTZXNzaW9uLmN1cnJlbnRCbGVuZE1vZGVdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9tYXNrKVxuICAgIHtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5tYXNrTWFuYWdlci5wdXNoTWFzayh0aGlzLl9tYXNrLCByZW5kZXJTZXNzaW9uLmNvbnRleHQpO1xuICAgIH1cblxuICAgIC8vICBJZ25vcmUgbnVsbCBzb3VyY2VzXG4gICAgaWYgKHRoaXMudGV4dHVyZS52YWxpZClcbiAgICB7XG4gICAgICAgIHJlbmRlclNlc3Npb24uY29udGV4dC5nbG9iYWxBbHBoYSA9IHRoaXMud29ybGRBbHBoYTtcblxuICAgICAgICAvLyAgQWxsb3cgZm9yIHBpeGVsIHJvdW5kaW5nXG4gICAgICAgIGlmIChyZW5kZXJTZXNzaW9uLnJvdW5kUGl4ZWxzKVxuICAgICAgICB7XG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLmNvbnRleHQuc2V0VHJhbnNmb3JtKFxuICAgICAgICAgICAgICAgIHRoaXMud29ybGRUcmFuc2Zvcm0uYSxcbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmMsXG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZFRyYW5zZm9ybS5iLFxuICAgICAgICAgICAgICAgIHRoaXMud29ybGRUcmFuc2Zvcm0uZCxcbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtLnR4IHwgMCxcbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtLnR5IHwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLmNvbnRleHQuc2V0VHJhbnNmb3JtKFxuICAgICAgICAgICAgICAgIHRoaXMud29ybGRUcmFuc2Zvcm0uYSxcbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmMsXG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZFRyYW5zZm9ybS5iLFxuICAgICAgICAgICAgICAgIHRoaXMud29ybGRUcmFuc2Zvcm0uZCxcbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtLnR4LFxuICAgICAgICAgICAgICAgIHRoaXMud29ybGRUcmFuc2Zvcm0udHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gIElmIHNtb290aGluZ0VuYWJsZWQgaXMgc3VwcG9ydGVkIGFuZCB3ZSBuZWVkIHRvIGNoYW5nZSB0aGUgc21vb3RoaW5nIHByb3BlcnR5IGZvciB0aGlzIHRleHR1cmVcbiAgICAgICAgaWYgKHJlbmRlclNlc3Npb24uc21vb3RoUHJvcGVydHkgJiYgcmVuZGVyU2Vzc2lvbi5zY2FsZU1vZGUgIT09IHRoaXMudGV4dHVyZS5iYXNlVGV4dHVyZS5zY2FsZU1vZGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24uc2NhbGVNb2RlID0gdGhpcy50ZXh0dXJlLmJhc2VUZXh0dXJlLnNjYWxlTW9kZTtcbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24uY29udGV4dFtyZW5kZXJTZXNzaW9uLnNtb290aFByb3BlcnR5XSA9IChyZW5kZXJTZXNzaW9uLnNjYWxlTW9kZSA9PT0gUElYSS5zY2FsZU1vZGVzLkxJTkVBUik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAgSWYgdGhlIHRleHR1cmUgaXMgdHJpbW1lZCB3ZSBvZmZzZXQgYnkgdGhlIHRyaW0geC95LCBvdGhlcndpc2Ugd2UgdXNlIHRoZSBmcmFtZSBkaW1lbnNpb25zXG4gICAgICAgIHZhciBkeCA9ICh0aGlzLnRleHR1cmUudHJpbSkgPyB0aGlzLnRleHR1cmUudHJpbS54IC0gdGhpcy5hbmNob3IueCAqIHRoaXMudGV4dHVyZS50cmltLndpZHRoIDogdGhpcy5hbmNob3IueCAqIC10aGlzLnRleHR1cmUuZnJhbWUud2lkdGg7XG4gICAgICAgIHZhciBkeSA9ICh0aGlzLnRleHR1cmUudHJpbSkgPyB0aGlzLnRleHR1cmUudHJpbS55IC0gdGhpcy5hbmNob3IueSAqIHRoaXMudGV4dHVyZS50cmltLmhlaWdodCA6IHRoaXMuYW5jaG9yLnkgKiAtdGhpcy50ZXh0dXJlLmZyYW1lLmhlaWdodDtcblxuICAgICAgICBpZiAodGhpcy50aW50ICE9PSAweEZGRkZGRilcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FjaGVkVGludCAhPT0gdGhpcy50aW50KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkVGludCA9IHRoaXMudGludDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyAgVE9ETyBjbGVhbiB1cCBjYWNoaW5nIC0gaG93IHRvIGNsZWFuIHVwIHRoZSBjYWNoZXM/XG4gICAgICAgICAgICAgICAgdGhpcy50aW50ZWRUZXh0dXJlID0gUElYSS5DYW52YXNUaW50ZXIuZ2V0VGludGVkVGV4dHVyZSh0aGlzLCB0aGlzLnRpbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLmNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbnRlZFRleHR1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZS5jcm9wLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUuY3JvcC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlLmNyb3Aud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZS5jcm9wLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLmNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUuYmFzZVRleHR1cmUuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUuY3JvcC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUuY3JvcC55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUuY3JvcC53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlLmNyb3AuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZS5jcm9wLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUuY3JvcC5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gT1ZFUldSSVRFXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKylcbiAgICB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0uX3JlbmRlckNhbnZhcyhyZW5kZXJTZXNzaW9uKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbWFzaylcbiAgICB7XG4gICAgICAgIHJlbmRlclNlc3Npb24ubWFza01hbmFnZXIucG9wTWFzayhyZW5kZXJTZXNzaW9uLmNvbnRleHQpO1xuICAgIH1cbn07XG5cbi8vIHNvbWUgaGVscGVyIGZ1bmN0aW9ucy4uXG5cbi8qKlxuICpcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBzcHJpdGUgdGhhdCB3aWxsIGNvbnRhaW4gYSB0ZXh0dXJlIGZyb20gdGhlIFRleHR1cmVDYWNoZSBiYXNlZCBvbiB0aGUgZnJhbWVJZFxuICogVGhlIGZyYW1lIGlkcyBhcmUgY3JlYXRlZCB3aGVuIGEgVGV4dHVyZSBwYWNrZXIgZmlsZSBoYXMgYmVlbiBsb2FkZWRcbiAqXG4gKiBAbWV0aG9kIGZyb21GcmFtZVxuICogQHN0YXRpY1xuICogQHBhcmFtIGZyYW1lSWQge1N0cmluZ30gVGhlIGZyYW1lIElkIG9mIHRoZSB0ZXh0dXJlIGluIHRoZSBjYWNoZVxuICogQHJldHVybiB7U3ByaXRlfSBBIG5ldyBTcHJpdGUgdXNpbmcgYSB0ZXh0dXJlIGZyb20gdGhlIHRleHR1cmUgY2FjaGUgbWF0Y2hpbmcgdGhlIGZyYW1lSWRcbiAqL1xuUElYSS5TcHJpdGUuZnJvbUZyYW1lID0gZnVuY3Rpb24oZnJhbWVJZClcbntcbiAgICB2YXIgdGV4dHVyZSA9IFBJWEkuVGV4dHVyZUNhY2hlW2ZyYW1lSWRdO1xuICAgIGlmKCF0ZXh0dXJlKSB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBmcmFtZUlkIFwiJyArIGZyYW1lSWQgKyAnXCIgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHRleHR1cmUgY2FjaGUnICsgdGhpcyk7XG4gICAgcmV0dXJuIG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlKTtcbn07XG5cbi8qKlxuICpcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBzcHJpdGUgdGhhdCB3aWxsIGNvbnRhaW4gYSB0ZXh0dXJlIGJhc2VkIG9uIGFuIGltYWdlIHVybFxuICogSWYgdGhlIGltYWdlIGlzIG5vdCBpbiB0aGUgdGV4dHVyZSBjYWNoZSBpdCB3aWxsIGJlIGxvYWRlZFxuICpcbiAqIEBtZXRob2QgZnJvbUltYWdlXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gaW1hZ2VJZCB7U3RyaW5nfSBUaGUgaW1hZ2UgdXJsIG9mIHRoZSB0ZXh0dXJlXG4gKiBAcmV0dXJuIHtTcHJpdGV9IEEgbmV3IFNwcml0ZSB1c2luZyBhIHRleHR1cmUgZnJvbSB0aGUgdGV4dHVyZSBjYWNoZSBtYXRjaGluZyB0aGUgaW1hZ2UgaWRcbiAqL1xuUElYSS5TcHJpdGUuZnJvbUltYWdlID0gZnVuY3Rpb24oaW1hZ2VJZCwgY3Jvc3NvcmlnaW4sIHNjYWxlTW9kZSlcbntcbiAgICB2YXIgdGV4dHVyZSA9IFBJWEkuVGV4dHVyZS5mcm9tSW1hZ2UoaW1hZ2VJZCwgY3Jvc3NvcmlnaW4sIHNjYWxlTW9kZSk7XG4gICAgcmV0dXJuIG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlKTtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tL1xuICovXG5cbi8qKlxuICogVGhlIFNwcml0ZUJhdGNoIGNsYXNzIGlzIGEgcmVhbGx5IGZhc3QgdmVyc2lvbiBvZiB0aGUgRGlzcGxheU9iamVjdENvbnRhaW5lciBcbiAqIGJ1aWx0IHNvbGVseSBmb3Igc3BlZWQsIHNvIHVzZSB3aGVuIHlvdSBuZWVkIGEgbG90IG9mIHNwcml0ZXMgb3IgcGFydGljbGVzLlxuICogQW5kIGl0J3MgZXh0cmVtZWx5IGVhc3kgdG8gdXNlIDogXG5cbiAgICB2YXIgY29udGFpbmVyID0gbmV3IFBJWEkuU3ByaXRlQmF0Y2goKTtcbiBcbiAgICBzdGFnZS5hZGRDaGlsZChjb250YWluZXIpO1xuIFxuICAgIGZvcih2YXIgaSAgPSAwOyBpIDwgMTAwOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgc3ByaXRlID0gbmV3IFBJWEkuU3ByaXRlLmZyb21JbWFnZShcIm15SW1hZ2UucG5nXCIpO1xuICAgICAgICBjb250YWluZXIuYWRkQ2hpbGQoc3ByaXRlKTtcbiAgICB9XG4gKiBBbmQgaGVyZSB5b3UgaGF2ZSBhIGh1bmRyZWQgc3ByaXRlcyB0aGF0IHdpbGwgYmUgcmVuZGVyZXIgYXQgdGhlIHNwZWVkIG9mIGxpZ2h0XG4gKlxuICogQGNsYXNzIFNwcml0ZUJhdGNoXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfVxuICovXG5QSVhJLlNwcml0ZUJhdGNoID0gZnVuY3Rpb24odGV4dHVyZSlcbntcbiAgICBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIuY2FsbCggdGhpcyk7XG5cbiAgICB0aGlzLnRleHR1cmVUaGluZyA9IHRleHR1cmU7XG5cbiAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG59O1xuXG5QSVhJLlNwcml0ZUJhdGNoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZSk7XG5QSVhJLlNwcml0ZUJhdGNoLmNvbnN0cnVjdG9yID0gUElYSS5TcHJpdGVCYXRjaDtcblxuLypcbiAqIEluaXRpYWxpc2VzIHRoZSBzcHJpdGVCYXRjaFxuICpcbiAqIEBtZXRob2QgaW5pdFdlYkdMXG4gKiBAcGFyYW0gZ2wge1dlYkdMQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4gKi9cblBJWEkuU3ByaXRlQmF0Y2gucHJvdG90eXBlLmluaXRXZWJHTCA9IGZ1bmN0aW9uKGdsKVxue1xuICAgIC8vIFRPRE8gb25seSBvbmUgbmVlZGVkIGZvciB0aGUgd2hvbGUgZW5naW5lIHJlYWxseT9cbiAgICB0aGlzLmZhc3RTcHJpdGVCYXRjaCA9IG5ldyBQSVhJLldlYkdMRmFzdFNwcml0ZUJhdGNoKGdsKTtcblxuICAgIHRoaXMucmVhZHkgPSB0cnVlO1xufTtcblxuLypcbiAqIFVwZGF0ZXMgdGhlIG9iamVjdCB0cmFuc2Zvcm0gZm9yIHJlbmRlcmluZ1xuICpcbiAqIEBtZXRob2QgdXBkYXRlVHJhbnNmb3JtXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlNwcml0ZUJhdGNoLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbigpXG57XG4gICAvLyBUT0RPIGRvbnQgbmVlZCB0byFcbiAgICBQSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybS5jYWxsKCB0aGlzICk7XG4gIC8vICBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybS5jYWxsKCB0aGlzICk7XG59O1xuXG4vKipcbiogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuKlxuKiBAbWV0aG9kIF9yZW5kZXJXZWJHTFxuKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7UmVuZGVyU2Vzc2lvbn0gXG4qIEBwcml2YXRlXG4qL1xuUElYSS5TcHJpdGVCYXRjaC5wcm90b3R5cGUuX3JlbmRlcldlYkdMID0gZnVuY3Rpb24ocmVuZGVyU2Vzc2lvbilcbntcbiAgICBpZighdGhpcy52aXNpYmxlIHx8IHRoaXMuYWxwaGEgPD0gMCB8fCAhdGhpcy5jaGlsZHJlbi5sZW5ndGgpcmV0dXJuO1xuXG4gICAgaWYoIXRoaXMucmVhZHkpdGhpcy5pbml0V2ViR0woIHJlbmRlclNlc3Npb24uZ2wgKTtcbiAgICBcbiAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLnN0b3AoKTtcbiAgICBcbiAgICByZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIuc2V0U2hhZGVyKHJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlci5mYXN0U2hhZGVyKTtcbiAgICBcbiAgICB0aGlzLmZhc3RTcHJpdGVCYXRjaC5iZWdpbih0aGlzLCByZW5kZXJTZXNzaW9uKTtcbiAgICB0aGlzLmZhc3RTcHJpdGVCYXRjaC5yZW5kZXIodGhpcyk7XG5cbiAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLnN0YXJ0KCk7XG4gXG59O1xuXG4vKipcbiogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbipcbiogQG1ldGhvZCBfcmVuZGVyQ2FudmFzXG4qIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtSZW5kZXJTZXNzaW9ufSBcbiogQHByaXZhdGVcbiovXG5QSVhJLlNwcml0ZUJhdGNoLnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzID0gZnVuY3Rpb24ocmVuZGVyU2Vzc2lvbilcbntcbiAgICB2YXIgY29udGV4dCA9IHJlbmRlclNlc3Npb24uY29udGV4dDtcbiAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gdGhpcy53b3JsZEFscGhhO1xuXG4gICAgUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0uY2FsbCh0aGlzKTtcblxuICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuICAgIC8vIGFsb3cgZm9yIHRyaW1taW5nXG4gICAgICAgXG4gICAgdmFyIGlzUm90YXRlZCA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICBcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcblxuICAgICAgICBpZighY2hpbGQudmlzaWJsZSljb250aW51ZTtcblxuICAgICAgICB2YXIgdGV4dHVyZSA9IGNoaWxkLnRleHR1cmU7XG4gICAgICAgIHZhciBmcmFtZSA9IHRleHR1cmUuZnJhbWU7XG5cbiAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IHRoaXMud29ybGRBbHBoYSAqIGNoaWxkLmFscGhhO1xuXG4gICAgICAgIGlmKGNoaWxkLnJvdGF0aW9uICUgKE1hdGguUEkgKiAyKSA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYoaXNSb3RhdGVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKHRyYW5zZm9ybS5hLCB0cmFuc2Zvcm0uYywgdHJhbnNmb3JtLmIsIHRyYW5zZm9ybS5kLCB0cmFuc2Zvcm0udHgsIHRyYW5zZm9ybS50eSk7XG4gICAgICAgICAgICAgICAgaXNSb3RhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGZhc3Rlc3QgIHdheSB0byBvcHRpbWlzZSEgLSBpZiByb3RhdGlvbiBpcyAwIHRoZW4gd2UgY2FuIGF2b2lkIGFueSBraW5kIG9mIHNldFRyYW5zZm9ybSBjYWxsXG4gICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGNoaWxkLmFuY2hvci54KSAqICgtZnJhbWUud2lkdGggKiBjaGlsZC5zY2FsZS54KSArIGNoaWxkLnBvc2l0aW9uLnggICsgMC41KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGNoaWxkLmFuY2hvci55KSAqICgtZnJhbWUuaGVpZ2h0ICogY2hpbGQuc2NhbGUueSkgKyBjaGlsZC5wb3NpdGlvbi55ICArIDAuNSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUud2lkdGggKiBjaGlsZC5zY2FsZS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUuaGVpZ2h0ICogY2hpbGQuc2NhbGUueSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBpZighaXNSb3RhdGVkKWlzUm90YXRlZCA9IHRydWU7XG4gICAgXG4gICAgICAgICAgICBQSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybS5jYWxsKGNoaWxkKTtcbiAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgY2hpbGRUcmFuc2Zvcm0gPSBjaGlsZC53b3JsZFRyYW5zZm9ybTtcblxuICAgICAgICAgICAgLy8gYWxsb3cgZm9yIHRyaW1taW5nXG4gICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHJlbmRlclNlc3Npb24ucm91bmRQaXhlbHMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oY2hpbGRUcmFuc2Zvcm0uYSwgY2hpbGRUcmFuc2Zvcm0uYywgY2hpbGRUcmFuc2Zvcm0uYiwgY2hpbGRUcmFuc2Zvcm0uZCwgY2hpbGRUcmFuc2Zvcm0udHggfCAwLCBjaGlsZFRyYW5zZm9ybS50eSB8IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKGNoaWxkVHJhbnNmb3JtLmEsIGNoaWxkVHJhbnNmb3JtLmMsIGNoaWxkVHJhbnNmb3JtLmIsIGNoaWxkVHJhbnNmb3JtLmQsIGNoaWxkVHJhbnNmb3JtLnR4LCBjaGlsZFRyYW5zZm9ybS50eSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHRleHR1cmUuYmFzZVRleHR1cmUuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoY2hpbGQuYW5jaG9yLngpICogKC1mcmFtZS53aWR0aCkgKyAwLjUpIHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoY2hpbGQuYW5jaG9yLnkpICogKC1mcmFtZS5oZWlnaHQpICsgMC41KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLmhlaWdodCk7XG4gICAgICAgICAgIFxuXG4gICAgICAgIH1cblxuICAgICAgIC8vIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cblxuLy8gICAgY29udGV4dC5yZXN0b3JlKCk7XG59O1xuXG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKiBBIE1vdmllQ2xpcCBpcyBhIHNpbXBsZSB3YXkgdG8gZGlzcGxheSBhbiBhbmltYXRpb24gZGVwaWN0ZWQgYnkgYSBsaXN0IG9mIHRleHR1cmVzLlxuICpcbiAqIEBjbGFzcyBNb3ZpZUNsaXBcbiAqIEBleHRlbmRzIFNwcml0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gdGV4dHVyZXMge0FycmF5PFRleHR1cmU+fSBhbiBhcnJheSBvZiB7VGV4dHVyZX0gb2JqZWN0cyB0aGF0IG1ha2UgdXAgdGhlIGFuaW1hdGlvblxuICovXG5QSVhJLk1vdmllQ2xpcCA9IGZ1bmN0aW9uKHRleHR1cmVzKVxue1xuICAgIFBJWEkuU3ByaXRlLmNhbGwodGhpcywgdGV4dHVyZXNbMF0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFycmF5IG9mIHRleHR1cmVzIHRoYXQgbWFrZSB1cCB0aGUgYW5pbWF0aW9uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdGV4dHVyZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHRoaXMudGV4dHVyZXMgPSB0ZXh0dXJlcztcblxuICAgIC8qKlxuICAgICAqIFRoZSBzcGVlZCB0aGF0IHRoZSBNb3ZpZUNsaXAgd2lsbCBwbGF5IGF0LiBIaWdoZXIgaXMgZmFzdGVyLCBsb3dlciBpcyBzbG93ZXJcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBhbmltYXRpb25TcGVlZFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cbiAgICB0aGlzLmFuaW1hdGlvblNwZWVkID0gMTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBtb3ZpZSBjbGlwIHJlcGVhdHMgYWZ0ZXIgcGxheWluZy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBsb29wXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLmxvb3AgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gY2FsbCB3aGVuIGEgTW92aWVDbGlwIGZpbmlzaGVzIHBsYXlpbmdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvbkNvbXBsZXRlXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLm9uQ29tcGxldGUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogW3JlYWQtb25seV0gVGhlIE1vdmllQ2xpcHMgY3VycmVudCBmcmFtZSBpbmRleCAodGhpcyBtYXkgbm90IGhhdmUgdG8gYmUgYSB3aG9sZSBudW1iZXIpXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY3VycmVudEZyYW1lXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcblxuICAgIC8qKlxuICAgICAqIFtyZWFkLW9ubHldIEluZGljYXRlcyBpZiB0aGUgTW92aWVDbGlwIGlzIGN1cnJlbnRseSBwbGF5aW5nXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcGxheWluZ1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLk1vdmllQ2xpcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQSVhJLlNwcml0ZS5wcm90b3R5cGUgKTtcblBJWEkuTW92aWVDbGlwLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuTW92aWVDbGlwO1xuXG4vKipcbiogW3JlYWQtb25seV0gdG90YWxGcmFtZXMgaXMgdGhlIHRvdGFsIG51bWJlciBvZiBmcmFtZXMgaW4gdGhlIE1vdmllQ2xpcC4gVGhpcyBpcyB0aGUgc2FtZSBhcyBudW1iZXIgb2YgdGV4dHVyZXNcbiogYXNzaWduZWQgdG8gdGhlIE1vdmllQ2xpcC5cbipcbiogQHByb3BlcnR5IHRvdGFsRnJhbWVzXG4qIEB0eXBlIE51bWJlclxuKiBAZGVmYXVsdCAwXG4qIEByZWFkT25seVxuKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSggUElYSS5Nb3ZpZUNsaXAucHJvdG90eXBlLCAndG90YWxGcmFtZXMnLCB7XG5cdGdldDogZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlcy5sZW5ndGg7XG5cdH1cbn0pO1xuXG5cbi8qKlxuICogU3RvcHMgdGhlIE1vdmllQ2xpcFxuICpcbiAqIEBtZXRob2Qgc3RvcFxuICovXG5QSVhJLk1vdmllQ2xpcC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogUGxheXMgdGhlIE1vdmllQ2xpcFxuICpcbiAqIEBtZXRob2QgcGxheVxuICovXG5QSVhJLk1vdmllQ2xpcC5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLnBsYXlpbmcgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBTdG9wcyB0aGUgTW92aWVDbGlwIGFuZCBnb2VzIHRvIGEgc3BlY2lmaWMgZnJhbWVcbiAqXG4gKiBAbWV0aG9kIGdvdG9BbmRTdG9wXG4gKiBAcGFyYW0gZnJhbWVOdW1iZXIge051bWJlcn0gZnJhbWUgaW5kZXggdG8gc3RvcCBhdFxuICovXG5QSVhJLk1vdmllQ2xpcC5wcm90b3R5cGUuZ290b0FuZFN0b3AgPSBmdW5jdGlvbihmcmFtZU51bWJlcilcbntcbiAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IGZyYW1lTnVtYmVyO1xuICAgIHZhciByb3VuZCA9ICh0aGlzLmN1cnJlbnRGcmFtZSArIDAuNSkgfCAwO1xuICAgIHRoaXMuc2V0VGV4dHVyZSh0aGlzLnRleHR1cmVzW3JvdW5kICUgdGhpcy50ZXh0dXJlcy5sZW5ndGhdKTtcbn07XG5cbi8qKlxuICogR29lcyB0byBhIHNwZWNpZmljIGZyYW1lIGFuZCBiZWdpbnMgcGxheWluZyB0aGUgTW92aWVDbGlwXG4gKlxuICogQG1ldGhvZCBnb3RvQW5kUGxheVxuICogQHBhcmFtIGZyYW1lTnVtYmVyIHtOdW1iZXJ9IGZyYW1lIGluZGV4IHRvIHN0YXJ0IGF0XG4gKi9cblBJWEkuTW92aWVDbGlwLnByb3RvdHlwZS5nb3RvQW5kUGxheSA9IGZ1bmN0aW9uKGZyYW1lTnVtYmVyKVxue1xuICAgIHRoaXMuY3VycmVudEZyYW1lID0gZnJhbWVOdW1iZXI7XG4gICAgdGhpcy5wbGF5aW5nID0gdHJ1ZTtcbn07XG5cbi8qXG4gKiBVcGRhdGVzIHRoZSBvYmplY3QgdHJhbnNmb3JtIGZvciByZW5kZXJpbmdcbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVRyYW5zZm9ybVxuICogQHByaXZhdGVcbiAqL1xuUElYSS5Nb3ZpZUNsaXAucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uKClcbntcbiAgICBQSVhJLlNwcml0ZS5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtLmNhbGwodGhpcyk7XG5cbiAgICBpZighdGhpcy5wbGF5aW5nKXJldHVybjtcblxuICAgIHRoaXMuY3VycmVudEZyYW1lICs9IHRoaXMuYW5pbWF0aW9uU3BlZWQ7XG5cbiAgICB2YXIgcm91bmQgPSAodGhpcy5jdXJyZW50RnJhbWUgKyAwLjUpIHwgMDtcblxuICAgIHRoaXMuY3VycmVudEZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWUgJSB0aGlzLnRleHR1cmVzLmxlbmd0aDtcblxuICAgIGlmKHRoaXMubG9vcCB8fCByb3VuZCA8IHRoaXMudGV4dHVyZXMubGVuZ3RoKVxuICAgIHtcbiAgICAgICAgdGhpcy5zZXRUZXh0dXJlKHRoaXMudGV4dHVyZXNbcm91bmQgJSB0aGlzLnRleHR1cmVzLmxlbmd0aF0pO1xuICAgIH1cbiAgICBlbHNlIGlmKHJvdW5kID49IHRoaXMudGV4dHVyZXMubGVuZ3RoKVxuICAgIHtcbiAgICAgICAgdGhpcy5nb3RvQW5kU3RvcCh0aGlzLnRleHR1cmVzLmxlbmd0aCAtIDEpO1xuICAgICAgICBpZih0aGlzLm9uQ29tcGxldGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMub25Db21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBBIHNob3J0IGhhbmQgd2F5IG9mIGNyZWF0aW5nIGEgbW92aWVjbGlwIGZyb20gYW4gYXJyYXkgb2YgZnJhbWUgaWRzXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBmcm9tRnJhbWVzXG4gKiBAcGFyYW0gZnJhbWVzIHtBcnJheX0gdGhlIGFycmF5IG9mIGZyYW1lcyBpZHMgdGhlIG1vdmllY2xpcCB3aWxsIHVzZSBhcyBpdHMgdGV4dHVyZSBmcmFtZXNcbiAqL1xuUElYSS5Nb3ZpZUNsaXAuZnJvbUZyYW1lcyA9IGZ1bmN0aW9uKGZyYW1lcylcbntcbiAgICB2YXIgdGV4dHVyZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdGV4dHVyZXMucHVzaChuZXcgUElYSS5UZXh0dXJlLmZyb21GcmFtZShmcmFtZXNbaV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFBJWEkuTW92aWVDbGlwKHRleHR1cmVzKTtcbn07XG5cbi8qKlxuICogQSBzaG9ydCBoYW5kIHdheSBvZiBjcmVhdGluZyBhIG1vdmllY2xpcCBmcm9tIGFuIGFycmF5IG9mIGltYWdlIGlkc1xuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZnJvbUZyYW1lc1xuICogQHBhcmFtIGZyYW1lcyB7QXJyYXl9IHRoZSBhcnJheSBvZiBpbWFnZSBpZHMgdGhlIG1vdmllY2xpcCB3aWxsIHVzZSBhcyBpdHMgdGV4dHVyZSBmcmFtZXNcbiAqL1xuUElYSS5Nb3ZpZUNsaXAuZnJvbUltYWdlcyA9IGZ1bmN0aW9uKGltYWdlcylcbntcbiAgICB2YXIgdGV4dHVyZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW1hZ2VzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdGV4dHVyZXMucHVzaChuZXcgUElYSS5UZXh0dXJlLmZyb21JbWFnZShpbWFnZXNbaV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFBJWEkuTW92aWVDbGlwKHRleHR1cmVzKTtcbn07XG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cblxuUElYSS5GaWx0ZXJCbG9jayA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMucmVuZGVyYWJsZSA9IHRydWU7XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICogLSBNb2RpZmllZCBieSBUb20gU2xlemFrb3dza2kgaHR0cDovL3d3dy50b21zbGV6YWtvd3NraS5jb20gQFRvbVNsZXpha293c2tpICgyNC8wMy8yMDE0KSAtIEFkZGVkIGRyb3BTaGFkb3dDb2xvci5cbiAqL1xuXG4vKipcbiAqIEEgVGV4dCBPYmplY3Qgd2lsbCBjcmVhdGUgYSBsaW5lKHMpIG9mIHRleHQuIFRvIHNwbGl0IGEgbGluZSB5b3UgY2FuIHVzZSAnXFxuJyBcbiAqIG9yIGFkZCBhIHdvcmRXcmFwIHByb3BlcnR5IHNldCB0byB0cnVlIGFuZCBhbmQgd29yZFdyYXBXaWR0aCBwcm9wZXJ0eSB3aXRoIGEgdmFsdWVcbiAqIGluIHRoZSBzdHlsZSBvYmplY3RcbiAqXG4gKiBAY2xhc3MgVGV4dFxuICogQGV4dGVuZHMgU3ByaXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB0ZXh0IHtTdHJpbmd9IFRoZSBjb3B5IHRoYXQgeW91IHdvdWxkIGxpa2UgdGhlIHRleHQgdG8gZGlzcGxheVxuICogQHBhcmFtIFtzdHlsZV0ge09iamVjdH0gVGhlIHN0eWxlIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSBbc3R5bGUuZm9udF0ge1N0cmluZ30gZGVmYXVsdCAnYm9sZCAyMHB4IEFyaWFsJyBUaGUgc3R5bGUgYW5kIHNpemUgb2YgdGhlIGZvbnRcbiAqIEBwYXJhbSBbc3R5bGUuZmlsbD0nYmxhY2snXSB7U3RyaW5nfE51bWJlcn0gQSBjYW52YXMgZmlsbHN0eWxlIHRoYXQgd2lsbCBiZSB1c2VkIG9uIHRoZSB0ZXh0IGUuZyAncmVkJywgJyMwMEZGMDAnXG4gKiBAcGFyYW0gW3N0eWxlLmFsaWduPSdsZWZ0J10ge1N0cmluZ30gQWxpZ25tZW50IGZvciBtdWx0aWxpbmUgdGV4dCAoJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnKSwgZG9lcyBub3QgYWZmZWN0IHNpbmdsZSBsaW5lIHRleHRcbiAqIEBwYXJhbSBbc3R5bGUuc3Ryb2tlXSB7U3RyaW5nfE51bWJlcn0gQSBjYW52YXMgZmlsbHN0eWxlIHRoYXQgd2lsbCBiZSB1c2VkIG9uIHRoZSB0ZXh0IHN0cm9rZSBlLmcgJ2JsdWUnLCAnI0ZDRkYwMCdcbiAqIEBwYXJhbSBbc3R5bGUuc3Ryb2tlVGhpY2tuZXNzPTBdIHtOdW1iZXJ9IEEgbnVtYmVyIHRoYXQgcmVwcmVzZW50cyB0aGUgdGhpY2tuZXNzIG9mIHRoZSBzdHJva2UuIERlZmF1bHQgaXMgMCAobm8gc3Ryb2tlKVxuICogQHBhcmFtIFtzdHlsZS53b3JkV3JhcD1mYWxzZV0ge0Jvb2xlYW59IEluZGljYXRlcyBpZiB3b3JkIHdyYXAgc2hvdWxkIGJlIHVzZWRcbiAqIEBwYXJhbSBbc3R5bGUud29yZFdyYXBXaWR0aD0xMDBdIHtOdW1iZXJ9IFRoZSB3aWR0aCBhdCB3aGljaCB0ZXh0IHdpbGwgd3JhcCwgaXQgbmVlZHMgd29yZFdyYXAgdG8gYmUgc2V0IHRvIHRydWVcbiAqIEBwYXJhbSBbc3R5bGUuZHJvcFNoYWRvdz1mYWxzZV0ge0Jvb2xlYW59IFNldCBhIGRyb3Agc2hhZG93IGZvciB0aGUgdGV4dFxuICogQHBhcmFtIFtzdHlsZS5kcm9wU2hhZG93Q29sb3I9JyMwMDAwMDAnXSB7U3RyaW5nfSBBIGZpbGwgc3R5bGUgdG8gYmUgdXNlZCBvbiB0aGUgZHJvcHNoYWRvdyBlLmcgJ3JlZCcsICcjMDBGRjAwJ1xuICogQHBhcmFtIFtzdHlsZS5kcm9wU2hhZG93QW5nbGU9TWF0aC5QSS80XSB7TnVtYmVyfSBTZXQgYSBhbmdsZSBvZiB0aGUgZHJvcCBzaGFkb3dcbiAqIEBwYXJhbSBbc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlPTVdIHtOdW1iZXJ9IFNldCBhIGRpc3RhbmNlIG9mIHRoZSBkcm9wIHNoYWRvd1xuICovXG5QSVhJLlRleHQgPSBmdW5jdGlvbih0ZXh0LCBzdHlsZSlcbntcbiAgICAvKipcbiAgICAgKiBUaGUgY2FudmFzIGVsZW1lbnQgdGhhdCBldmVyeXRoaW5nIGlzIGRyYXduIHRvXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY2FudmFzXG4gICAgICogQHR5cGUgSFRNTENhbnZhc0VsZW1lbnRcbiAgICAgKi9cbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNhbnZhcyAyZCBjb250ZXh0IHRoYXQgZXZlcnl0aGluZyBpcyBkcmF3biB3aXRoXG4gICAgICogQHByb3BlcnR5IGNvbnRleHRcbiAgICAgKiBAdHlwZSBIVE1MQ2FudmFzRWxlbWVudCAyZCBDb250ZXh0XG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIFBJWEkuU3ByaXRlLmNhbGwodGhpcywgUElYSS5UZXh0dXJlLmZyb21DYW52YXModGhpcy5jYW52YXMpKTtcblxuICAgIHRoaXMuc2V0VGV4dCh0ZXh0KTtcbiAgICB0aGlzLnNldFN0eWxlKHN0eWxlKTtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLlRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQSVhJLlNwcml0ZS5wcm90b3R5cGUpO1xuUElYSS5UZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuVGV4dDtcblxuXG4vKipcbiAqIFRoZSB3aWR0aCBvZiB0aGUgc3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxuICpcbiAqIEBwcm9wZXJ0eSB3aWR0aFxuICogQHR5cGUgTnVtYmVyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLlRleHQucHJvdG90eXBlLCAnd2lkdGgnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZih0aGlzLmRpcnR5KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRleHQoKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUueCAqIHRoaXMudGV4dHVyZS5mcmFtZS53aWR0aDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5zY2FsZS54ID0gdmFsdWUgLyB0aGlzLnRleHR1cmUuZnJhbWUud2lkdGg7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogVGhlIGhlaWdodCBvZiB0aGUgVGV4dCwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcbiAqXG4gKiBAcHJvcGVydHkgaGVpZ2h0XG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuVGV4dC5wcm90b3R5cGUsICdoZWlnaHQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZih0aGlzLmRpcnR5KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRleHQoKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuICB0aGlzLnNjYWxlLnkgKiB0aGlzLnRleHR1cmUuZnJhbWUuaGVpZ2h0O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnNjYWxlLnkgPSB2YWx1ZSAvIHRoaXMudGV4dHVyZS5mcmFtZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG5cbi8qKlxuICogU2V0IHRoZSBzdHlsZSBvZiB0aGUgdGV4dFxuICpcbiAqIEBtZXRob2Qgc2V0U3R5bGVcbiAqIEBwYXJhbSBbc3R5bGVdIHtPYmplY3R9IFRoZSBzdHlsZSBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0gW3N0eWxlLmZvbnQ9J2JvbGQgMjBwdCBBcmlhbCddIHtTdHJpbmd9IFRoZSBzdHlsZSBhbmQgc2l6ZSBvZiB0aGUgZm9udFxuICogQHBhcmFtIFtzdHlsZS5maWxsPSdibGFjayddIHtPYmplY3R9IEEgY2FudmFzIGZpbGxzdHlsZSB0aGF0IHdpbGwgYmUgdXNlZCBvbiB0aGUgdGV4dCBlZyAncmVkJywgJyMwMEZGMDAnXG4gKiBAcGFyYW0gW3N0eWxlLmFsaWduPSdsZWZ0J10ge1N0cmluZ30gQWxpZ25tZW50IGZvciBtdWx0aWxpbmUgdGV4dCAoJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnKSwgZG9lcyBub3QgYWZmZWN0IHNpbmdsZSBsaW5lIHRleHRcbiAqIEBwYXJhbSBbc3R5bGUuc3Ryb2tlPSdibGFjayddIHtTdHJpbmd9IEEgY2FudmFzIGZpbGxzdHlsZSB0aGF0IHdpbGwgYmUgdXNlZCBvbiB0aGUgdGV4dCBzdHJva2UgZWcgJ2JsdWUnLCAnI0ZDRkYwMCdcbiAqIEBwYXJhbSBbc3R5bGUuc3Ryb2tlVGhpY2tuZXNzPTBdIHtOdW1iZXJ9IEEgbnVtYmVyIHRoYXQgcmVwcmVzZW50cyB0aGUgdGhpY2tuZXNzIG9mIHRoZSBzdHJva2UuIERlZmF1bHQgaXMgMCAobm8gc3Ryb2tlKVxuICogQHBhcmFtIFtzdHlsZS53b3JkV3JhcD1mYWxzZV0ge0Jvb2xlYW59IEluZGljYXRlcyBpZiB3b3JkIHdyYXAgc2hvdWxkIGJlIHVzZWRcbiAqIEBwYXJhbSBbc3R5bGUud29yZFdyYXBXaWR0aD0xMDBdIHtOdW1iZXJ9IFRoZSB3aWR0aCBhdCB3aGljaCB0ZXh0IHdpbGwgd3JhcFxuICogQHBhcmFtIFtzdHlsZS5kcm9wU2hhZG93PWZhbHNlXSB7Qm9vbGVhbn0gU2V0IGEgZHJvcCBzaGFkb3cgZm9yIHRoZSB0ZXh0XG4gKiBAcGFyYW0gW3N0eWxlLmRyb3BTaGFkb3dDb2xvcj0nIzAwMDAwMCddIHtTdHJpbmd9IEEgZmlsbCBzdHlsZSB0byBiZSB1c2VkIG9uIHRoZSBkcm9wc2hhZG93IGUuZyAncmVkJywgJyMwMEZGMDAnXG4gKiBAcGFyYW0gW3N0eWxlLmRyb3BTaGFkb3dBbmdsZT1NYXRoLlBJLzRdIHtOdW1iZXJ9IFNldCBhIGFuZ2xlIG9mIHRoZSBkcm9wIHNoYWRvd1xuICogQHBhcmFtIFtzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U9NV0ge051bWJlcn0gU2V0IGEgZGlzdGFuY2Ugb2YgdGhlIGRyb3Agc2hhZG93XG4gKi9cblBJWEkuVGV4dC5wcm90b3R5cGUuc2V0U3R5bGUgPSBmdW5jdGlvbihzdHlsZSlcbntcbiAgICBzdHlsZSA9IHN0eWxlIHx8IHt9O1xuICAgIHN0eWxlLmZvbnQgPSBzdHlsZS5mb250IHx8ICdib2xkIDIwcHQgQXJpYWwnO1xuICAgIHN0eWxlLmZpbGwgPSBzdHlsZS5maWxsIHx8ICdibGFjayc7XG4gICAgc3R5bGUuYWxpZ24gPSBzdHlsZS5hbGlnbiB8fCAnbGVmdCc7XG4gICAgc3R5bGUuc3Ryb2tlID0gc3R5bGUuc3Ryb2tlIHx8ICdibGFjayc7IC8vcHJvdmlkZSBhIGRlZmF1bHQsIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0dvb2RCb3lEaWdpdGFsL3BpeGkuanMvaXNzdWVzLzEzNlxuICAgIHN0eWxlLnN0cm9rZVRoaWNrbmVzcyA9IHN0eWxlLnN0cm9rZVRoaWNrbmVzcyB8fCAwO1xuICAgIHN0eWxlLndvcmRXcmFwID0gc3R5bGUud29yZFdyYXAgfHwgZmFsc2U7XG4gICAgc3R5bGUud29yZFdyYXBXaWR0aCA9IHN0eWxlLndvcmRXcmFwV2lkdGggfHwgMTAwO1xuICAgIHN0eWxlLndvcmRXcmFwV2lkdGggPSBzdHlsZS53b3JkV3JhcFdpZHRoIHx8IDEwMDtcbiAgICBcbiAgICBzdHlsZS5kcm9wU2hhZG93ID0gc3R5bGUuZHJvcFNoYWRvdyB8fCBmYWxzZTtcbiAgICBzdHlsZS5kcm9wU2hhZG93QW5nbGUgPSBzdHlsZS5kcm9wU2hhZG93QW5nbGUgfHwgTWF0aC5QSSAvIDY7XG4gICAgc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlID0gc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlIHx8IDQ7XG4gICAgc3R5bGUuZHJvcFNoYWRvd0NvbG9yID0gc3R5bGUuZHJvcFNoYWRvd0NvbG9yIHx8ICdibGFjayc7XG5cbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29weSBmb3IgdGhlIHRleHQgb2JqZWN0LiBUbyBzcGxpdCBhIGxpbmUgeW91IGNhbiB1c2UgJ1xcbidcbiAqXG4gKiBAbWV0aG9kIHNldFRleHRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSBjb3B5IHRoYXQgeW91IHdvdWxkIGxpa2UgdGhlIHRleHQgdG8gZGlzcGxheVxuICovXG5QSVhJLlRleHQucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbih0ZXh0KVxue1xuICAgIHRoaXMudGV4dCA9IHRleHQudG9TdHJpbmcoKSB8fCAnICc7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbn07XG5cbi8qKlxuICogUmVuZGVycyB0ZXh0IGFuZCB1cGRhdGVzIGl0IHdoZW4gbmVlZGVkXG4gKlxuICogQG1ldGhvZCB1cGRhdGVUZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlRleHQucHJvdG90eXBlLnVwZGF0ZVRleHQgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5jb250ZXh0LmZvbnQgPSB0aGlzLnN0eWxlLmZvbnQ7XG5cbiAgICB2YXIgb3V0cHV0VGV4dCA9IHRoaXMudGV4dDtcblxuICAgIC8vIHdvcmQgd3JhcFxuICAgIC8vIHByZXNlcnZlIG9yaWdpbmFsIHRleHRcbiAgICBpZih0aGlzLnN0eWxlLndvcmRXcmFwKW91dHB1dFRleHQgPSB0aGlzLndvcmRXcmFwKHRoaXMudGV4dCk7XG5cbiAgICAvL3NwbGl0IHRleHQgaW50byBsaW5lc1xuICAgIHZhciBsaW5lcyA9IG91dHB1dFRleHQuc3BsaXQoLyg/OlxcclxcbnxcXHJ8XFxuKS8pO1xuXG4gICAgLy9jYWxjdWxhdGUgdGV4dCB3aWR0aFxuICAgIHZhciBsaW5lV2lkdGhzID0gW107XG4gICAgdmFyIG1heExpbmVXaWR0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBsaW5lV2lkdGggPSB0aGlzLmNvbnRleHQubWVhc3VyZVRleHQobGluZXNbaV0pLndpZHRoO1xuICAgICAgICBsaW5lV2lkdGhzW2ldID0gbGluZVdpZHRoO1xuICAgICAgICBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIGxpbmVXaWR0aCk7XG4gICAgfVxuXG4gICAgdmFyIHdpZHRoID0gbWF4TGluZVdpZHRoICsgdGhpcy5zdHlsZS5zdHJva2VUaGlja25lc3M7XG4gICAgaWYodGhpcy5zdHlsZS5kcm9wU2hhZG93KXdpZHRoICs9IHRoaXMuc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlO1xuXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB3aWR0aCArIHRoaXMuY29udGV4dC5saW5lV2lkdGg7XG4gICAgLy9jYWxjdWxhdGUgdGV4dCBoZWlnaHRcbiAgICB2YXIgbGluZUhlaWdodCA9IHRoaXMuZGV0ZXJtaW5lRm9udEhlaWdodCgnZm9udDogJyArIHRoaXMuc3R5bGUuZm9udCAgKyAnOycpICsgdGhpcy5zdHlsZS5zdHJva2VUaGlja25lc3M7XG4gICAgXG4gICAgdmFyIGhlaWdodCA9IGxpbmVIZWlnaHQgKiBsaW5lcy5sZW5ndGg7XG4gICAgaWYodGhpcy5zdHlsZS5kcm9wU2hhZG93KWhlaWdodCArPSB0aGlzLnN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZTtcblxuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIGlmKG5hdmlnYXRvci5pc0NvY29vbkpTKSB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KDAsMCx0aGlzLmNhbnZhcy53aWR0aCx0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgIFxuICAgIHRoaXMuY29udGV4dC5mb250ID0gdGhpcy5zdHlsZS5mb250O1xuICAgIHRoaXMuY29udGV4dC5zdHJva2VTdHlsZSA9IHRoaXMuc3R5bGUuc3Ryb2tlO1xuICAgIHRoaXMuY29udGV4dC5saW5lV2lkdGggPSB0aGlzLnN0eWxlLnN0cm9rZVRoaWNrbmVzcztcbiAgICB0aGlzLmNvbnRleHQudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG5cbiAgICB2YXIgbGluZVBvc2l0aW9uWDtcbiAgICB2YXIgbGluZVBvc2l0aW9uWTtcblxuICAgIGlmKHRoaXMuc3R5bGUuZHJvcFNoYWRvdylcbiAgICB7XG4gICAgICAgIHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLnN0eWxlLmRyb3BTaGFkb3dDb2xvcjtcblxuICAgICAgICB2YXIgeFNoYWRvd09mZnNldCA9IE1hdGguc2luKHRoaXMuc3R5bGUuZHJvcFNoYWRvd0FuZ2xlKSAqIHRoaXMuc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICAgICAgICB2YXIgeVNoYWRvd09mZnNldCA9IE1hdGguY29zKHRoaXMuc3R5bGUuZHJvcFNoYWRvd0FuZ2xlKSAqIHRoaXMuc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgbGluZVBvc2l0aW9uWCA9IHRoaXMuc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMjtcbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblkgPSB0aGlzLnN0eWxlLnN0cm9rZVRoaWNrbmVzcyAvIDIgKyBpICogbGluZUhlaWdodDtcblxuICAgICAgICAgICAgaWYodGhpcy5zdHlsZS5hbGlnbiA9PT0gJ3JpZ2h0JylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsaW5lUG9zaXRpb25YICs9IG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMuc3R5bGUuYWxpZ24gPT09ICdjZW50ZXInKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaV0pIC8gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodGhpcy5zdHlsZS5maWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsVGV4dChsaW5lc1tpXSwgbGluZVBvc2l0aW9uWCArIHhTaGFkb3dPZmZzZXQsIGxpbmVQb3NpdGlvblkgKyB5U2hhZG93T2Zmc2V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIC8vICBpZihkcm9wU2hhZG93KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9zZXQgY2FudmFzIHRleHQgc3R5bGVzXG4gICAgdGhpcy5jb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuc3R5bGUuZmlsbDtcbiAgICBcbiAgICAvL2RyYXcgbGluZXMgbGluZSBieSBsaW5lXG4gICAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgbGluZVBvc2l0aW9uWCA9IHRoaXMuc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMjtcbiAgICAgICAgbGluZVBvc2l0aW9uWSA9IHRoaXMuc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMiArIGkgKiBsaW5lSGVpZ2h0O1xuXG4gICAgICAgIGlmKHRoaXMuc3R5bGUuYWxpZ24gPT09ICdyaWdodCcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHRoaXMuc3R5bGUuYWxpZ24gPT09ICdjZW50ZXInKVxuICAgICAgICB7XG4gICAgICAgICAgICBsaW5lUG9zaXRpb25YICs9IChtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2ldKSAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLnN0eWxlLnN0cm9rZSAmJiB0aGlzLnN0eWxlLnN0cm9rZVRoaWNrbmVzcylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnN0cm9rZVRleHQobGluZXNbaV0sIGxpbmVQb3NpdGlvblgsIGxpbmVQb3NpdGlvblkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5zdHlsZS5maWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFRleHQobGluZXNbaV0sIGxpbmVQb3NpdGlvblgsIGxpbmVQb3NpdGlvblkpO1xuICAgICAgICB9XG5cbiAgICAgIC8vICBpZihkcm9wU2hhZG93KVxuICAgIH1cblxuXG4gICAgdGhpcy51cGRhdGVUZXh0dXJlKCk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGV4dHVyZSBzaXplIGJhc2VkIG9uIGNhbnZhcyBzaXplXG4gKlxuICogQG1ldGhvZCB1cGRhdGVUZXh0dXJlXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlRleHQucHJvdG90eXBlLnVwZGF0ZVRleHR1cmUgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy50ZXh0dXJlLmJhc2VUZXh0dXJlLndpZHRoID0gdGhpcy5jYW52YXMud2lkdGg7XG4gICAgdGhpcy50ZXh0dXJlLmJhc2VUZXh0dXJlLmhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodDtcbiAgICB0aGlzLnRleHR1cmUuY3JvcC53aWR0aCA9IHRoaXMudGV4dHVyZS5mcmFtZS53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoO1xuICAgIHRoaXMudGV4dHVyZS5jcm9wLmhlaWdodCA9IHRoaXMudGV4dHVyZS5mcmFtZS5oZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQ7XG5cbiAgICB0aGlzLl93aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoO1xuICAgIHRoaXMuX2hlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodDtcblxuICAgIHRoaXMucmVxdWlyZXNVcGRhdGUgPSAgdHJ1ZTtcbn07XG5cbi8qKlxuKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyXG4qXG4qIEBtZXRob2QgX3JlbmRlcldlYkdMXG4qIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtSZW5kZXJTZXNzaW9ufSBcbiogQHByaXZhdGVcbiovXG5QSVhJLlRleHQucHJvdG90eXBlLl9yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uKHJlbmRlclNlc3Npb24pXG57XG4gICAgaWYodGhpcy5yZXF1aXJlc1VwZGF0ZSlcbiAgICB7XG4gICAgICAgIHRoaXMucmVxdWlyZXNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgUElYSS51cGRhdGVXZWJHTFRleHR1cmUodGhpcy50ZXh0dXJlLmJhc2VUZXh0dXJlLCByZW5kZXJTZXNzaW9uLmdsKTtcbiAgICB9XG5cbiAgICBQSVhJLlNwcml0ZS5wcm90b3R5cGUuX3JlbmRlcldlYkdMLmNhbGwodGhpcywgcmVuZGVyU2Vzc2lvbik7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHRyYW5zZm9ybSBvZiB0aGlzIG9iamVjdFxuICpcbiAqIEBtZXRob2QgdXBkYXRlVHJhbnNmb3JtXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlRleHQucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uKClcbntcbiAgICBpZih0aGlzLmRpcnR5KVxuICAgIHtcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KCk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBQSVhJLlNwcml0ZS5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtLmNhbGwodGhpcyk7XG59O1xuXG4vKlxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3VzZXJzLzM0NDQxL2VsbGlzYmJlblxuICogZ3JlYXQgc29sdXRpb24gdG8gdGhlIHByb2JsZW0hXG4gKiByZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIGdpdmVuIGZvbnRcbiAqXG4gKiBAbWV0aG9kIGRldGVybWluZUZvbnRIZWlnaHRcbiAqIEBwYXJhbSBmb250U3R5bGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuVGV4dC5wcm90b3R5cGUuZGV0ZXJtaW5lRm9udEhlaWdodCA9IGZ1bmN0aW9uKGZvbnRTdHlsZSlcbntcbiAgICAvLyBidWlsZCBhIGxpdHRsZSByZWZlcmVuY2UgZGljdGlvbmFyeSBzbyBpZiB0aGUgZm9udCBzdHlsZSBoYXMgYmVlbiB1c2VkIHJldHVybiBhXG4gICAgLy8gY2FjaGVkIHZlcnNpb24uLi5cbiAgICB2YXIgcmVzdWx0ID0gUElYSS5UZXh0LmhlaWdodENhY2hlW2ZvbnRTdHlsZV07XG5cbiAgICBpZighcmVzdWx0KVxuICAgIHtcbiAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdO1xuICAgICAgICB2YXIgZHVtbXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdmFyIGR1bW15VGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdNJyk7XG4gICAgICAgIGR1bW15LmFwcGVuZENoaWxkKGR1bW15VGV4dCk7XG4gICAgICAgIGR1bW15LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBmb250U3R5bGUgKyAnO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MCcpO1xuICAgICAgICBib2R5LmFwcGVuZENoaWxkKGR1bW15KTtcblxuICAgICAgICByZXN1bHQgPSBkdW1teS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIFBJWEkuVGV4dC5oZWlnaHRDYWNoZVtmb250U3R5bGVdID0gcmVzdWx0O1xuXG4gICAgICAgIGJvZHkucmVtb3ZlQ2hpbGQoZHVtbXkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgbmV3bGluZXMgdG8gYSBzdHJpbmcgdG8gaGF2ZSBpdCBvcHRpbWFsbHkgZml0IGludG8gdGhlIGhvcml6b250YWxcbiAqIGJvdW5kcyBzZXQgYnkgdGhlIFRleHQgb2JqZWN0J3Mgd29yZFdyYXBXaWR0aCBwcm9wZXJ0eS5cbiAqXG4gKiBAbWV0aG9kIHdvcmRXcmFwXG4gKiBAcGFyYW0gdGV4dCB7U3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuUElYSS5UZXh0LnByb3RvdHlwZS53b3JkV3JhcCA9IGZ1bmN0aW9uKHRleHQpXG57XG4gICAgLy8gR3JlZWR5IHdyYXBwaW5nIGFsZ29yaXRobSB0aGF0IHdpbGwgd3JhcCB3b3JkcyBhcyB0aGUgbGluZSBncm93cyBsb25nZXJcbiAgICAvLyB0aGFuIGl0cyBob3Jpem9udGFsIGJvdW5kcy5cbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBzcGFjZUxlZnQgPSB0aGlzLnN0eWxlLndvcmRXcmFwV2lkdGg7XG4gICAgICAgIHZhciB3b3JkcyA9IGxpbmVzW2ldLnNwbGl0KCcgJyk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgd29yZHMubGVuZ3RoOyBqKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB3b3JkV2lkdGggPSB0aGlzLmNvbnRleHQubWVhc3VyZVRleHQod29yZHNbal0pLndpZHRoO1xuICAgICAgICAgICAgdmFyIHdvcmRXaWR0aFdpdGhTcGFjZSA9IHdvcmRXaWR0aCArIHRoaXMuY29udGV4dC5tZWFzdXJlVGV4dCgnICcpLndpZHRoO1xuICAgICAgICAgICAgaWYoaiA9PT0gMCB8fCB3b3JkV2lkdGhXaXRoU3BhY2UgPiBzcGFjZUxlZnQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCBwcmludGluZyB0aGUgbmV3bGluZSBpZiBpdCdzIHRoZSBmaXJzdCB3b3JkIG9mIHRoZSBsaW5lIHRoYXQgaXNcbiAgICAgICAgICAgICAgICAvLyBncmVhdGVyIHRoYW4gdGhlIHdvcmQgd3JhcCB3aWR0aC5cbiAgICAgICAgICAgICAgICBpZihqID4gMClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdvcmRzW2pdO1xuICAgICAgICAgICAgICAgIHNwYWNlTGVmdCA9IHRoaXMuc3R5bGUud29yZFdyYXBXaWR0aCAtIHdvcmRXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzcGFjZUxlZnQgLT0gd29yZFdpZHRoV2l0aFNwYWNlO1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnICcgKyB3b3Jkc1tqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpIDwgbGluZXMubGVuZ3RoLTEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGlzIHRleHQgb2JqZWN0XG4gKlxuICogQG1ldGhvZCBkZXN0cm95XG4gKiBAcGFyYW0gZGVzdHJveUJhc2VUZXh0dXJlIHtCb29sZWFufSB3aGV0aGVyIHRvIGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBhcyB3ZWxsXG4gKi9cblBJWEkuVGV4dC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKGRlc3Ryb3lCYXNlVGV4dHVyZSlcbntcbiAgICAvLyBtYWtlIHN1cmUgdG8gcmVzZXQgdGhlIHRoZSBjb250ZXh0IGFuZCBjYW52YXMuLiBkb250IHdhbnQgdGhpcyBoYW5naW5nIGFyb3VuZCBpbiBtZW1vcnkhXG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG5cbiAgICB0aGlzLnRleHR1cmUuZGVzdHJveShkZXN0cm95QmFzZVRleHR1cmUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBkZXN0cm95QmFzZVRleHR1cmUpO1xufTtcblxuUElYSS5UZXh0LmhlaWdodENhY2hlID0ge307XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKiBBIFRleHQgT2JqZWN0IHdpbGwgY3JlYXRlIGEgbGluZShzKSBvZiB0ZXh0IHVzaW5nIGJpdG1hcCBmb250LiBUbyBzcGxpdCBhIGxpbmUgeW91IGNhbiB1c2UgJ1xcbicsICdcXHInIG9yICdcXHJcXG4nXG4gKiBZb3UgY2FuIGdlbmVyYXRlIHRoZSBmbnQgZmlsZXMgdXNpbmdcbiAqIGh0dHA6Ly93d3cuYW5nZWxjb2RlLmNvbS9wcm9kdWN0cy9ibWZvbnQvIGZvciB3aW5kb3dzIG9yXG4gKiBodHRwOi8vd3d3LmJtZ2x5cGguY29tLyBmb3IgbWFjLlxuICpcbiAqIEBjbGFzcyBCaXRtYXBUZXh0XG4gKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0Q29udGFpbmVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB0ZXh0IHtTdHJpbmd9IFRoZSBjb3B5IHRoYXQgeW91IHdvdWxkIGxpa2UgdGhlIHRleHQgdG8gZGlzcGxheVxuICogQHBhcmFtIHN0eWxlIHtPYmplY3R9IFRoZSBzdHlsZSBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0gc3R5bGUuZm9udCB7U3RyaW5nfSBUaGUgc2l6ZSAob3B0aW9uYWwpIGFuZCBiaXRtYXAgZm9udCBpZCAocmVxdWlyZWQpIGVxICdBcmlhbCcgb3IgJzIwcHggQXJpYWwnIChtdXN0IGhhdmUgbG9hZGVkIHByZXZpb3VzbHkpXG4gKiBAcGFyYW0gW3N0eWxlLmFsaWduPSdsZWZ0J10ge1N0cmluZ30gQWxpZ25tZW50IGZvciBtdWx0aWxpbmUgdGV4dCAoJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnKSwgZG9lcyBub3QgYWZmZWN0IHNpbmdsZSBsaW5lIHRleHRcbiAqL1xuUElYSS5CaXRtYXBUZXh0ID0gZnVuY3Rpb24odGV4dCwgc3R5bGUpXG57XG4gICAgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl9wb29sID0gW107XG5cbiAgICB0aGlzLnNldFRleHQodGV4dCk7XG4gICAgdGhpcy5zZXRTdHlsZShzdHlsZSk7XG4gICAgdGhpcy51cGRhdGVUZXh0KCk7XG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuQml0bWFwVGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUpO1xuUElYSS5CaXRtYXBUZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuQml0bWFwVGV4dDtcblxuLyoqXG4gKiBTZXQgdGhlIGNvcHkgZm9yIHRoZSB0ZXh0IG9iamVjdFxuICpcbiAqIEBtZXRob2Qgc2V0VGV4dFxuICogQHBhcmFtIHRleHQge1N0cmluZ30gVGhlIGNvcHkgdGhhdCB5b3Ugd291bGQgbGlrZSB0aGUgdGV4dCB0byBkaXNwbGF5XG4gKi9cblBJWEkuQml0bWFwVGV4dC5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uKHRleHQpXG57XG4gICAgdGhpcy50ZXh0ID0gdGV4dCB8fCAnICc7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc3R5bGUgb2YgdGhlIHRleHRcbiAqIHN0eWxlLmZvbnQge1N0cmluZ30gVGhlIHNpemUgKG9wdGlvbmFsKSBhbmQgYml0bWFwIGZvbnQgaWQgKHJlcXVpcmVkKSBlcSAnQXJpYWwnIG9yICcyMHB4IEFyaWFsJyAobXVzdCBoYXZlIGxvYWRlZCBwcmV2aW91c2x5KVxuICogW3N0eWxlLmFsaWduPSdsZWZ0J10ge1N0cmluZ30gQWxpZ25tZW50IGZvciBtdWx0aWxpbmUgdGV4dCAoJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnKSwgZG9lcyBub3QgYWZmZWN0IHNpbmdsZSBsaW5lIHRleHRcbiAqXG4gKiBAbWV0aG9kIHNldFN0eWxlXG4gKiBAcGFyYW0gc3R5bGUge09iamVjdH0gVGhlIHN0eWxlIHBhcmFtZXRlcnMsIGNvbnRhaW5lZCBhcyBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdFxuICovXG5QSVhJLkJpdG1hcFRleHQucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24oc3R5bGUpXG57XG4gICAgc3R5bGUgPSBzdHlsZSB8fCB7fTtcbiAgICBzdHlsZS5hbGlnbiA9IHN0eWxlLmFsaWduIHx8ICdsZWZ0JztcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG5cbiAgICB2YXIgZm9udCA9IHN0eWxlLmZvbnQuc3BsaXQoJyAnKTtcbiAgICB0aGlzLmZvbnROYW1lID0gZm9udFtmb250Lmxlbmd0aCAtIDFdO1xuICAgIHRoaXMuZm9udFNpemUgPSBmb250Lmxlbmd0aCA+PSAyID8gcGFyc2VJbnQoZm9udFtmb250Lmxlbmd0aCAtIDJdLCAxMCkgOiBQSVhJLkJpdG1hcFRleHQuZm9udHNbdGhpcy5mb250TmFtZV0uc2l6ZTtcblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIHRoaXMudGludCA9IHN0eWxlLnRpbnQ7XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgdGV4dCBhbmQgdXBkYXRlcyBpdCB3aGVuIG5lZWRlZFxuICpcbiAqIEBtZXRob2QgdXBkYXRlVGV4dFxuICogQHByaXZhdGVcbiAqL1xuUElYSS5CaXRtYXBUZXh0LnByb3RvdHlwZS51cGRhdGVUZXh0ID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBkYXRhID0gUElYSS5CaXRtYXBUZXh0LmZvbnRzW3RoaXMuZm9udE5hbWVdO1xuICAgIHZhciBwb3MgPSBuZXcgUElYSS5Qb2ludCgpO1xuICAgIHZhciBwcmV2Q2hhckNvZGUgPSBudWxsO1xuICAgIHZhciBjaGFycyA9IFtdO1xuICAgIHZhciBtYXhMaW5lV2lkdGggPSAwO1xuICAgIHZhciBsaW5lV2lkdGhzID0gW107XG4gICAgdmFyIGxpbmUgPSAwO1xuICAgIHZhciBzY2FsZSA9IHRoaXMuZm9udFNpemUgLyBkYXRhLnNpemU7XG4gICAgXG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy50ZXh0Lmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGNoYXJDb2RlID0gdGhpcy50ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmKC8oPzpcXHJcXG58XFxyfFxcbikvLnRlc3QodGhpcy50ZXh0LmNoYXJBdChpKSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxpbmVXaWR0aHMucHVzaChwb3MueCk7XG4gICAgICAgICAgICBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIHBvcy54KTtcbiAgICAgICAgICAgIGxpbmUrKztcblxuICAgICAgICAgICAgcG9zLnggPSAwO1xuICAgICAgICAgICAgcG9zLnkgKz0gZGF0YS5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgcHJldkNoYXJDb2RlID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoYXJEYXRhID0gZGF0YS5jaGFyc1tjaGFyQ29kZV07XG4gICAgICAgIGlmKCFjaGFyRGF0YSkgY29udGludWU7XG5cbiAgICAgICAgaWYocHJldkNoYXJDb2RlICYmIGNoYXJEYXRhW3ByZXZDaGFyQ29kZV0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBvcy54ICs9IGNoYXJEYXRhLmtlcm5pbmdbcHJldkNoYXJDb2RlXTtcbiAgICAgICAgfVxuICAgICAgICBjaGFycy5wdXNoKHt0ZXh0dXJlOmNoYXJEYXRhLnRleHR1cmUsIGxpbmU6IGxpbmUsIGNoYXJDb2RlOiBjaGFyQ29kZSwgcG9zaXRpb246IG5ldyBQSVhJLlBvaW50KHBvcy54ICsgY2hhckRhdGEueE9mZnNldCwgcG9zLnkgKyBjaGFyRGF0YS55T2Zmc2V0KX0pO1xuICAgICAgICBwb3MueCArPSBjaGFyRGF0YS54QWR2YW5jZTtcblxuICAgICAgICBwcmV2Q2hhckNvZGUgPSBjaGFyQ29kZTtcbiAgICB9XG5cbiAgICBsaW5lV2lkdGhzLnB1c2gocG9zLngpO1xuICAgIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgcG9zLngpO1xuXG4gICAgdmFyIGxpbmVBbGlnbk9mZnNldHMgPSBbXTtcbiAgICBmb3IoaSA9IDA7IGkgPD0gbGluZTsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGFsaWduT2Zmc2V0ID0gMDtcbiAgICAgICAgaWYodGhpcy5zdHlsZS5hbGlnbiA9PT0gJ3JpZ2h0JylcbiAgICAgICAge1xuICAgICAgICAgICAgYWxpZ25PZmZzZXQgPSBtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodGhpcy5zdHlsZS5hbGlnbiA9PT0gJ2NlbnRlcicpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFsaWduT2Zmc2V0ID0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaV0pIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBsaW5lQWxpZ25PZmZzZXRzLnB1c2goYWxpZ25PZmZzZXQpO1xuICAgIH1cblxuICAgIHZhciBsZW5DaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHZhciBsZW5DaGFycyA9IGNoYXJzLmxlbmd0aDtcbiAgICB2YXIgdGludCA9IHRoaXMudGludCB8fCAweEZGRkZGRjtcbiAgICBmb3IoaSA9IDA7IGkgPCBsZW5DaGFyczsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGMgPSBpIDwgbGVuQ2hpbGRyZW4gPyB0aGlzLmNoaWxkcmVuW2ldIDogdGhpcy5fcG9vbC5wb3AoKTsgLy8gZ2V0IG9sZCBjaGlsZCBpZiBoYXZlLiBpZiBub3QgLSB0YWtlIGZyb20gcG9vbC5cblxuICAgICAgICBpZiAoYykgYy5zZXRUZXh0dXJlKGNoYXJzW2ldLnRleHR1cmUpOyAvLyBjaGVjayBpZiBnb3Qgb25lIGJlZm9yZS5cbiAgICAgICAgZWxzZSBjID0gbmV3IFBJWEkuU3ByaXRlKGNoYXJzW2ldLnRleHR1cmUpOyAvLyBpZiBubyBjcmVhdGUgbmV3IG9uZS5cblxuICAgICAgICBjLnBvc2l0aW9uLnggPSAoY2hhcnNbaV0ucG9zaXRpb24ueCArIGxpbmVBbGlnbk9mZnNldHNbY2hhcnNbaV0ubGluZV0pICogc2NhbGU7XG4gICAgICAgIGMucG9zaXRpb24ueSA9IGNoYXJzW2ldLnBvc2l0aW9uLnkgKiBzY2FsZTtcbiAgICAgICAgYy5zY2FsZS54ID0gYy5zY2FsZS55ID0gc2NhbGU7XG4gICAgICAgIGMudGludCA9IHRpbnQ7XG4gICAgICAgIGlmICghYy5wYXJlbnQpIHRoaXMuYWRkQ2hpbGQoYyk7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHVubmVjZXNzYXJ5IGNoaWxkcmVuLlxuICAgIC8vIGFuZCBwdXQgdGhlaXIgaW50byB0aGUgcG9vbC5cbiAgICB3aGlsZSh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IGxlbkNoYXJzKVxuICAgIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5nZXRDaGlsZEF0KHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMSk7XG4gICAgICAgIHRoaXMuX3Bvb2wucHVzaChjaGlsZCk7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogW3JlYWQtb25seV0gVGhlIHdpZHRoIG9mIHRoZSBvdmVyYWxsIHRleHQsIGRpZmZlcmVudCBmcm9tIGZvbnRTaXplLFxuICAgICAqIHdoaWNoIGlzIGRlZmluZWQgaW4gdGhlIHN0eWxlIG9iamVjdFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRleHRXaWR0aFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMudGV4dFdpZHRoID0gbWF4TGluZVdpZHRoICogc2NhbGU7XG5cbiAgICAvKipcbiAgICAgKiBbcmVhZC1vbmx5XSBUaGUgaGVpZ2h0IG9mIHRoZSBvdmVyYWxsIHRleHQsIGRpZmZlcmVudCBmcm9tIGZvbnRTaXplLFxuICAgICAqIHdoaWNoIGlzIGRlZmluZWQgaW4gdGhlIHN0eWxlIG9iamVjdFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRleHRIZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLnRleHRIZWlnaHQgPSAocG9zLnkgKyBkYXRhLmxpbmVIZWlnaHQpICogc2NhbGU7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHRyYW5zZm9ybSBvZiB0aGlzIG9iamVjdFxuICpcbiAqIEBtZXRob2QgdXBkYXRlVHJhbnNmb3JtXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkJpdG1hcFRleHQucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uKClcbntcbiAgICBpZih0aGlzLmRpcnR5KVxuICAgIHtcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KCk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybS5jYWxsKHRoaXMpO1xufTtcblxuUElYSS5CaXRtYXBUZXh0LmZvbnRzID0ge307XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cbiBcbi8qKlxuICogSG9sZHMgYWxsIGluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gYW4gSW50ZXJhY3Rpb24gZXZlbnRcbiAqXG4gKiBAY2xhc3MgSW50ZXJhY3Rpb25EYXRhXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuUElYSS5JbnRlcmFjdGlvbkRhdGEgPSBmdW5jdGlvbigpXG57XG4gICAgLyoqXG4gICAgICogVGhpcyBwb2ludCBzdG9yZXMgdGhlIGdsb2JhbCBjb29yZHMgb2Ygd2hlcmUgdGhlIHRvdWNoL21vdXNlIGV2ZW50IGhhcHBlbmVkXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZ2xvYmFsXG4gICAgICogQHR5cGUgUG9pbnRcbiAgICAgKi9cbiAgICB0aGlzLmdsb2JhbCA9IG5ldyBQSVhJLlBvaW50KCk7XG5cbiAgIFxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgU3ByaXRlIHRoYXQgd2FzIGludGVyYWN0ZWQgd2l0aFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRhcmdldFxuICAgICAqIEB0eXBlIFNwcml0ZVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gcGFzc2VkIHRvIGFuIGV2ZW50IGhhbmRsZXIsIHRoaXMgd2lsbCBiZSB0aGUgb3JpZ2luYWwgRE9NIEV2ZW50IHRoYXQgd2FzIGNhcHR1cmVkXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3JpZ2luYWxFdmVudFxuICAgICAqIEB0eXBlIEV2ZW50XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gbnVsbDtcbn07XG5cbi8qKlxuICogVGhpcyB3aWxsIHJldHVybiB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHNwZWNpZmllZCBkaXNwbGF5T2JqZWN0IGZvciB0aGlzIEludGVyYWN0aW9uRGF0YVxuICpcbiAqIEBtZXRob2QgZ2V0TG9jYWxQb3NpdGlvblxuICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge0Rpc3BsYXlPYmplY3R9IFRoZSBEaXNwbGF5T2JqZWN0IHRoYXQgeW91IHdvdWxkIGxpa2UgdGhlIGxvY2FsIGNvb3JkcyBvZmZcbiAqIEByZXR1cm4ge1BvaW50fSBBIHBvaW50IGNvbnRhaW5pbmcgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBJbnRlcmFjdGlvbkRhdGEgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIERpc3BsYXlPYmplY3RcbiAqL1xuUElYSS5JbnRlcmFjdGlvbkRhdGEucHJvdG90eXBlLmdldExvY2FsUG9zaXRpb24gPSBmdW5jdGlvbihkaXNwbGF5T2JqZWN0KVxue1xuICAgIHZhciB3b3JsZFRyYW5zZm9ybSA9IGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm07XG4gICAgdmFyIGdsb2JhbCA9IHRoaXMuZ2xvYmFsO1xuXG4gICAgLy8gZG8gYSBjaGVla3kgdHJhbnNmb3JtIHRvIGdldCB0aGUgbW91c2UgY29vcmRzO1xuICAgIHZhciBhMDAgPSB3b3JsZFRyYW5zZm9ybS5hLCBhMDEgPSB3b3JsZFRyYW5zZm9ybS5iLCBhMDIgPSB3b3JsZFRyYW5zZm9ybS50eCxcbiAgICAgICAgYTEwID0gd29ybGRUcmFuc2Zvcm0uYywgYTExID0gd29ybGRUcmFuc2Zvcm0uZCwgYTEyID0gd29ybGRUcmFuc2Zvcm0udHksXG4gICAgICAgIGlkID0gMSAvIChhMDAgKiBhMTEgKyBhMDEgKiAtYTEwKTtcbiAgICAvLyBzZXQgdGhlIG1vdXNlIGNvb3Jkcy4uLlxuICAgIHJldHVybiBuZXcgUElYSS5Qb2ludChhMTEgKiBpZCAqIGdsb2JhbC54ICsgLWEwMSAqIGlkICogZ2xvYmFsLnkgKyAoYTEyICogYTAxIC0gYTAyICogYTExKSAqIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEwMCAqIGlkICogZ2xvYmFsLnkgKyAtYTEwICogaWQgKiBnbG9iYWwueCArICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGlkKTtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLkludGVyYWN0aW9uRGF0YS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkludGVyYWN0aW9uRGF0YTtcbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuIC8qKlxuICogVGhlIGludGVyYWN0aW9uIG1hbmFnZXIgZGVhbHMgd2l0aCBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzLiBBbnkgRGlzcGxheU9iamVjdCBjYW4gYmUgaW50ZXJhY3RpdmVcbiAqIGlmIGl0cyBpbnRlcmFjdGl2ZSBwYXJhbWV0ZXIgaXMgc2V0IHRvIHRydWVcbiAqIFRoaXMgbWFuYWdlciBhbHNvIHN1cHBvcnRzIG11bHRpdG91Y2guXG4gKlxuICogQGNsYXNzIEludGVyYWN0aW9uTWFuYWdlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gc3RhZ2Uge1N0YWdlfSBUaGUgc3RhZ2UgdG8gaGFuZGxlIGludGVyYWN0aW9uc1xuICovXG5QSVhJLkludGVyYWN0aW9uTWFuYWdlciA9IGZ1bmN0aW9uKHN0YWdlKVxue1xuICAgIC8qKlxuICAgICAqIGEgcmVmZXJlbmNlIHRvIHRoZSBzdGFnZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHN0YWdlXG4gICAgICogQHR5cGUgU3RhZ2VcbiAgICAgKi9cbiAgICB0aGlzLnN0YWdlID0gc3RhZ2U7XG5cbiAgICAvKipcbiAgICAgKiB0aGUgbW91c2UgZGF0YVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG1vdXNlXG4gICAgICogQHR5cGUgSW50ZXJhY3Rpb25EYXRhXG4gICAgICovXG4gICAgdGhpcy5tb3VzZSA9IG5ldyBQSVhJLkludGVyYWN0aW9uRGF0YSgpO1xuXG4gICAgLyoqXG4gICAgICogYW4gb2JqZWN0IHRoYXQgc3RvcmVzIGN1cnJlbnQgdG91Y2hlcyAoSW50ZXJhY3Rpb25EYXRhKSBieSBpZCByZWZlcmVuY2VcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0b3VjaHNcbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICB0aGlzLnRvdWNocyA9IHt9O1xuXG4gICAgLy8gaGVscGVyc1xuICAgIHRoaXMudGVtcFBvaW50ID0gbmV3IFBJWEkuUG9pbnQoKTtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwcm9wZXJ0eSBtb3VzZW92ZXJFbmFibGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdGhpcy5tb3VzZW92ZXJFbmFibGVkID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIHRpbnkgbGl0dGxlIGludGVyYWN0aXZlRGF0YSBwb29sICFcbiAgICAgKiBcbiAgICAgKiBAcHJvcGVydHkgcG9vbFxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgdGhpcy5wb29sID0gW107XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBjb250YWluaW5nIGFsbCB0aGUgaXRlcmF0aXZlIGl0ZW1zIGZyb20gdGhlIG91ciBpbnRlcmFjdGl2ZSB0cmVlXG4gICAgICogQHByb3BlcnR5IGludGVyYWN0aXZlSXRlbXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKi9cbiAgICB0aGlzLmludGVyYWN0aXZlSXRlbXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIE91ciBjYW52YXNcbiAgICAgKiBAcHJvcGVydHkgaW50ZXJhY3Rpb25ET01FbGVtZW50XG4gICAgICogQHR5cGUgSFRNTENhbnZhc0VsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50ID0gbnVsbDtcblxuICAgIC8vdGhpcyB3aWxsIG1ha2UgaXQgc28gdGhhdCB5b3UgZG9udCBoYXZlIHRvIGNhbGwgYmluZCBhbGwgdGhlIHRpbWVcbiAgICB0aGlzLm9uTW91c2VNb3ZlID0gdGhpcy5vbk1vdXNlTW92ZS5iaW5kKCB0aGlzICk7XG4gICAgdGhpcy5vbk1vdXNlRG93biA9IHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uTW91c2VPdXQgPSB0aGlzLm9uTW91c2VPdXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uTW91c2VVcCA9IHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLm9uVG91Y2hTdGFydCA9IHRoaXMub25Ub3VjaFN0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblRvdWNoRW5kID0gdGhpcy5vblRvdWNoRW5kLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblRvdWNoTW92ZSA9IHRoaXMub25Ub3VjaE1vdmUuYmluZCh0aGlzKTtcblxuICAgIHRoaXMubGFzdCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3NzIHN0eWxlIG9mIHRoZSBjdXJzb3IgdGhhdCBpcyBiZWluZyB1c2VkXG4gICAgICogQHByb3BlcnR5IGN1cnJlbnRDdXJzb3JTdHlsZVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqXG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50Q3Vyc29yU3R5bGUgPSAnaW5oZXJpdCc7XG5cbiAgICAvKipcbiAgICAgKiBJcyBzZXQgdG8gdHJ1ZSB3aGVuIHRoZSBtb3VzZSBpcyBtb3ZlZCBvdXQgb2YgdGhlIGNhbnZhc1xuICAgICAqIEBwcm9wZXJ0eSBtb3VzZU91dFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKlxuICAgICAqL1xuICAgIHRoaXMubW91c2VPdXQgPSBmYWxzZTtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkludGVyYWN0aW9uTWFuYWdlcjtcblxuLyoqXG4gKiBDb2xsZWN0cyBhbiBpbnRlcmFjdGl2ZSBzcHJpdGUgcmVjdXJzaXZlbHkgdG8gaGF2ZSB0aGVpciBpbnRlcmFjdGlvbnMgbWFuYWdlZFxuICpcbiAqIEBtZXRob2QgY29sbGVjdEludGVyYWN0aXZlU3ByaXRlXG4gKiBAcGFyYW0gZGlzcGxheU9iamVjdCB7RGlzcGxheU9iamVjdH0gdGhlIGRpc3BsYXlPYmplY3QgdG8gY29sbGVjdFxuICogQHBhcmFtIGlQYXJlbnQge0Rpc3BsYXlPYmplY3R9IHRoZSBkaXNwbGF5IG9iamVjdCdzIHBhcmVudFxuICogQHByaXZhdGVcbiAqL1xuUElYSS5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNvbGxlY3RJbnRlcmFjdGl2ZVNwcml0ZSA9IGZ1bmN0aW9uKGRpc3BsYXlPYmplY3QsIGlQYXJlbnQpXG57XG4gICAgdmFyIGNoaWxkcmVuID0gZGlzcGxheU9iamVjdC5jaGlsZHJlbjtcbiAgICB2YXIgbGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgLy8gbWFrZSBhbiBpbnRlcmFjdGlvbiB0cmVlLi4uIHtpdGVtLl9faW50ZXJhY3RpdmVQYXJlbnR9XG4gICAgZm9yICh2YXIgaSA9IGxlbmd0aC0xOyBpID49IDA7IGktLSlcbiAgICB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICAgIC8vIHB1c2ggYWxsIGludGVyYWN0aXZlIGJpdHNcbiAgICAgICAgaWYoY2hpbGQuX2ludGVyYWN0aXZlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpUGFyZW50LmludGVyYWN0aXZlQ2hpbGRyZW4gPSB0cnVlO1xuICAgICAgICAgICAgLy9jaGlsZC5fX2lQYXJlbnQgPSBpUGFyZW50O1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGl2ZUl0ZW1zLnB1c2goY2hpbGQpO1xuXG4gICAgICAgICAgICBpZihjaGlsZC5jaGlsZHJlbi5sZW5ndGggPiAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGVjdEludGVyYWN0aXZlU3ByaXRlKGNoaWxkLCBjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBjaGlsZC5fX2lQYXJlbnQgPSBudWxsO1xuXG4gICAgICAgICAgICBpZihjaGlsZC5jaGlsZHJlbi5sZW5ndGggPiAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGVjdEludGVyYWN0aXZlU3ByaXRlKGNoaWxkLCBpUGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXRzIHRoZSB0YXJnZXQgZm9yIGV2ZW50IGRlbGVnYXRpb25cbiAqXG4gKiBAbWV0aG9kIHNldFRhcmdldFxuICogQHBhcmFtIHRhcmdldCB7V2ViR0xSZW5kZXJlcnxDYW52YXNSZW5kZXJlcn0gdGhlIHJlbmRlcmVyIHRvIGJpbmQgZXZlbnRzIHRvXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0VGFyZ2V0ID0gZnVuY3Rpb24odGFyZ2V0KVxue1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgLy9jaGVjayBpZiB0aGUgZG9tIGVsZW1lbnQgaGFzIGJlZW4gc2V0LiBJZiBpdCBoYXMgZG9uJ3QgZG8gYW55dGhpbmdcbiAgICBpZiggdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQgPT09IG51bGwgKSB7XG5cbiAgICAgICAgdGhpcy5zZXRUYXJnZXREb21FbGVtZW50KCB0YXJnZXQudmlldyApO1xuICAgIH1cblxuICAgIFxufTtcblxuXG4vKipcbiAqIFNldHMgdGhlIERPTSBlbGVtZW50IHdoaWNoIHdpbGwgcmVjZWl2ZSBtb3VzZS90b3VjaCBldmVudHMuIFRoaXMgaXMgdXNlZnVsIGZvciB3aGVuIHlvdSBoYXZlIG90aGVyIERPTVxuICogZWxlbWVudHMgb24gdG9wIG9mIHRoZSByZW5kZXJlcnMgQ2FudmFzIGVsZW1lbnQuIFdpdGggdGhpcyB5b3UnbGwgYmUgYWJsZSB0byBkZWxlZ2F0ZSBhbm90aGVyIERPTSBlbGVtZW50XG4gKiB0byByZWNlaXZlIHRob3NlIGV2ZW50c1xuICpcbiAqIEBtZXRob2Qgc2V0VGFyZ2V0RG9tRWxlbWVudFxuICogQHBhcmFtIGRvbUVsZW1lbnQge0RPTUVsZW1lbnR9IHRoZSBET00gZWxlbWVudCB3aGljaCB3aWxsIHJlY2VpdmUgbW91c2UgYW5kIHRvdWNoIGV2ZW50c1xuICogQHByaXZhdGVcbiAqL1xuUElYSS5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNldFRhcmdldERvbUVsZW1lbnQgPSBmdW5jdGlvbihkb21FbGVtZW50KVxue1xuXG4gICAgdGhpcy5yZW1vdmVFdmVudHMoKTtcblxuXG4gICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZClcbiAgICB7XG4gICAgICAgIC8vIHRpbWUgdG8gcmVtb3ZlIHNvbWUgb2YgdGhhdCB6b29tIGluIGphLi5cbiAgICAgICAgZG9tRWxlbWVudC5zdHlsZVsnLW1zLWNvbnRlbnQtem9vbWluZyddID0gJ25vbmUnO1xuICAgICAgICBkb21FbGVtZW50LnN0eWxlWyctbXMtdG91Y2gtYWN0aW9uJ10gPSAnbm9uZSc7XG5cbiAgICAgICAgLy8gRE8gc29tZSB3aW5kb3cgc3BlY2lmaWMgdG91Y2ghXG4gICAgfVxuXG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQgPSBkb21FbGVtZW50O1xuXG4gICAgZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAgdGhpcy5vbk1vdXNlTW92ZSwgdHJ1ZSk7XG4gICAgZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAgdGhpcy5vbk1vdXNlRG93biwgdHJ1ZSk7XG4gICAgZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsICAgdGhpcy5vbk1vdXNlT3V0LCB0cnVlKTtcblxuICAgIC8vIGFpbnQgbm8gbXVsdGkgdG91Y2gganVzdCB5ZXQhXG4gICAgZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQsIHRydWUpO1xuICAgIGRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmQsIHRydWUpO1xuICAgIGRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblRvdWNoTW92ZSwgdHJ1ZSk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsICB0aGlzLm9uTW91c2VVcCwgdHJ1ZSk7XG59O1xuXG5cblBJWEkuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVFdmVudHMgPSBmdW5jdGlvbigpXG57XG4gICAgaWYoIXRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50KXJldHVybjtcblxuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlWyctbXMtY29udGVudC16b29taW5nJ10gPSAnJztcbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZVsnLW1zLXRvdWNoLWFjdGlvbiddID0gJyc7XG5cbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAgdGhpcy5vbk1vdXNlTW92ZSwgdHJ1ZSk7XG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgIHRoaXMub25Nb3VzZURvd24sIHRydWUpO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgICB0aGlzLm9uTW91c2VPdXQsIHRydWUpO1xuXG4gICAgLy8gYWludCBubyBtdWx0aSB0b3VjaCBqdXN0IHlldCFcbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQsIHRydWUpO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kLCB0cnVlKTtcbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlLCB0cnVlKTtcblxuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50ID0gbnVsbDtcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgIHRoaXMub25Nb3VzZVVwLCB0cnVlKTtcbn07XG5cbi8qKlxuICogdXBkYXRlcyB0aGUgc3RhdGUgb2YgaW50ZXJhY3RpdmUgb2JqZWN0c1xuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKVxue1xuICAgIGlmKCF0aGlzLnRhcmdldClyZXR1cm47XG5cbiAgICAvLyBmcmVxdWVuY3kgb2YgMzBmcHM/P1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgIHZhciBkaWZmID0gbm93IC0gdGhpcy5sYXN0O1xuICAgIGRpZmYgPSAoZGlmZiAqIFBJWEkuSU5URVJBQ1RJT05fRlJFUVVFTkNZICkgLyAxMDAwO1xuICAgIGlmKGRpZmYgPCAxKXJldHVybjtcbiAgICB0aGlzLmxhc3QgPSBub3c7XG5cbiAgICB2YXIgaSA9IDA7XG5cbiAgICAvLyBvay4uIHNvIG1vdXNlIGV2ZW50cz8/XG4gICAgLy8geWVzIGZvciBub3cgOilcbiAgICAvLyBPUFRJTUlTRSAtIGhvdyBvZnRlbiB0byBjaGVjaz8/XG4gICAgaWYodGhpcy5kaXJ0eSlcbiAgICB7XG4gICAgICAgIHRoaXMucmVidWlsZEludGVyYWN0aXZlR3JhcGgoKTtcbiAgICB9XG5cbiAgICAvLyBsb29wIHRocm91Z2ggaW50ZXJhY3RpdmUgb2JqZWN0cyFcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5pbnRlcmFjdGl2ZUl0ZW1zLmxlbmd0aDtcbiAgICB2YXIgY3Vyc29yID0gJ2luaGVyaXQnO1xuICAgIHZhciBvdmVyID0gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuaW50ZXJhY3RpdmVJdGVtc1tpXTtcblxuICAgICAgICAvLyBPUFRJTUlTQVRJT04gLSBvbmx5IGNhbGN1bGF0ZSBldmVyeSB0aW1lIGlmIHRoZSBtb3VzZW1vdmUgZnVuY3Rpb24gZXhpc3RzLi5cbiAgICAgICAgLy8gT0sgc28uLiBkb2VzIHRoZSBvYmplY3QgaGF2ZSBhbnkgb3RoZXIgaW50ZXJhY3RpdmUgZnVuY3Rpb25zP1xuICAgICAgICAvLyBoaXQtdGVzdCB0aGUgY2xpcCFcbiAgICAgICAvLyBpZihpdGVtLm1vdXNlb3ZlciB8fCBpdGVtLm1vdXNlb3V0IHx8IGl0ZW0uYnV0dG9uTW9kZSlcbiAgICAgICAvLyB7XG4gICAgICAgIC8vIG9rIHNvIHRoZXJlIGFyZSBzb21lIGZ1bmN0aW9ucyBzbyBsZXRzIGhpdCB0ZXN0IGl0Li5cbiAgICAgICAgaXRlbS5fX2hpdCA9IHRoaXMuaGl0VGVzdChpdGVtLCB0aGlzLm1vdXNlKTtcbiAgICAgICAgdGhpcy5tb3VzZS50YXJnZXQgPSBpdGVtO1xuICAgICAgICAvLyBvayBzbyBkZWFsIHdpdGggaW50ZXJhY3Rpb25zLi5cbiAgICAgICAgLy8gbG9va3MgbGlrZSB0aGVyZSB3YXMgYSBoaXQhXG4gICAgICAgIGlmKGl0ZW0uX19oaXQgJiYgIW92ZXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmKGl0ZW0uYnV0dG9uTW9kZSkgY3Vyc29yID0gaXRlbS5kZWZhdWx0Q3Vyc29yO1xuXG4gICAgICAgICAgICBpZighaXRlbS5pbnRlcmFjdGl2ZUNoaWxkcmVuKW92ZXIgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZighaXRlbS5fX2lzT3ZlcilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZihpdGVtLm1vdXNlb3ZlcilpdGVtLm1vdXNlb3Zlcih0aGlzLm1vdXNlKTtcbiAgICAgICAgICAgICAgICBpdGVtLl9faXNPdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmKGl0ZW0uX19pc092ZXIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gcm9sbCBvdXQhXG4gICAgICAgICAgICAgICAgaWYoaXRlbS5tb3VzZW91dClpdGVtLm1vdXNlb3V0KHRoaXMubW91c2UpO1xuICAgICAgICAgICAgICAgIGl0ZW0uX19pc092ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKCB0aGlzLmN1cnJlbnRDdXJzb3JTdHlsZSAhPT0gY3Vyc29yIClcbiAgICB7XG4gICAgICAgIHRoaXMuY3VycmVudEN1cnNvclN0eWxlID0gY3Vyc29yO1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG4gICAgfVxufTtcblxuUElYSS5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlYnVpbGRJbnRlcmFjdGl2ZUdyYXBoID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcblxuICAgIHZhciBsZW4gPSB0aGlzLmludGVyYWN0aXZlSXRlbXMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLmludGVyYWN0aXZlSXRlbXNbaV0uaW50ZXJhY3RpdmVDaGlsZHJlbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuaW50ZXJhY3RpdmVJdGVtcyA9IFtdO1xuXG4gICAgaWYodGhpcy5zdGFnZS5pbnRlcmFjdGl2ZSl0aGlzLmludGVyYWN0aXZlSXRlbXMucHVzaCh0aGlzLnN0YWdlKTtcbiAgICAvLyBnbyB0aHJvdWdoIGFuZCBjb2xsZWN0IGFsbCB0aGUgb2JqZWN0cyB0aGF0IGFyZSBpbnRlcmFjdGl2ZS4uXG4gICAgdGhpcy5jb2xsZWN0SW50ZXJhY3RpdmVTcHJpdGUodGhpcy5zdGFnZSwgdGhpcy5zdGFnZSk7XG59O1xuXG4vKipcbiAqIElzIGNhbGxlZCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBhY3Jvc3MgdGhlIHJlbmRlcmVyIGVsZW1lbnRcbiAqXG4gKiBAbWV0aG9kIG9uTW91c2VNb3ZlXG4gKiBAcGFyYW0gZXZlbnQge0V2ZW50fSBUaGUgRE9NIGV2ZW50IG9mIHRoZSBtb3VzZSBtb3ZpbmdcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uKGV2ZW50KVxue1xuICAgIGlmKHRoaXMuZGlydHkpXG4gICAge1xuICAgICAgICB0aGlzLnJlYnVpbGRJbnRlcmFjdGl2ZUdyYXBoKCk7XG4gICAgfVxuXG4gICAgdGhpcy5tb3VzZS5vcmlnaW5hbEV2ZW50ID0gZXZlbnQgfHwgd2luZG93LmV2ZW50OyAvL0lFIHVzZXMgd2luZG93LmV2ZW50XG4gICAgLy8gVE9ETyBvcHRpbWl6ZSBieSBub3QgY2hlY2sgRVZFUlkgVElNRSEgbWF5YmUgaGFsZiBhcyBvZnRlbj8gLy9cbiAgICB2YXIgcmVjdCA9IHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgdGhpcy5tb3VzZS5nbG9iYWwueCA9IChldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0KSAqICh0aGlzLnRhcmdldC53aWR0aCAvIHJlY3Qud2lkdGgpO1xuICAgIHRoaXMubW91c2UuZ2xvYmFsLnkgPSAoZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wKSAqICggdGhpcy50YXJnZXQuaGVpZ2h0IC8gcmVjdC5oZWlnaHQpO1xuXG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuaW50ZXJhY3RpdmVJdGVtcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmludGVyYWN0aXZlSXRlbXNbaV07XG5cbiAgICAgICAgaWYoaXRlbS5tb3VzZW1vdmUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vY2FsbCB0aGUgZnVuY3Rpb24hXG4gICAgICAgICAgICBpdGVtLm1vdXNlbW92ZSh0aGlzLm1vdXNlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogSXMgY2FsbGVkIHdoZW4gdGhlIG1vdXNlIGJ1dHRvbiBpcyBwcmVzc2VkIGRvd24gb24gdGhlIHJlbmRlcmVyIGVsZW1lbnRcbiAqXG4gKiBAbWV0aG9kIG9uTW91c2VEb3duXG4gKiBAcGFyYW0gZXZlbnQge0V2ZW50fSBUaGUgRE9NIGV2ZW50IG9mIGEgbW91c2UgYnV0dG9uIGJlaW5nIHByZXNzZWQgZG93blxuICogQHByaXZhdGVcbiAqL1xuUElYSS5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uTW91c2VEb3duID0gZnVuY3Rpb24oZXZlbnQpXG57XG4gICAgaWYodGhpcy5kaXJ0eSlcbiAgICB7XG4gICAgICAgIHRoaXMucmVidWlsZEludGVyYWN0aXZlR3JhcGgoKTtcbiAgICB9XG5cbiAgICB0aGlzLm1vdXNlLm9yaWdpbmFsRXZlbnQgPSBldmVudCB8fCB3aW5kb3cuZXZlbnQ7IC8vSUUgdXNlcyB3aW5kb3cuZXZlbnRcblxuICAgIGlmKFBJWEkuQVVUT19QUkVWRU5UX0RFRkFVTFQpdGhpcy5tb3VzZS5vcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAvLyBsb29wIHRocm91Z2ggaW50ZXJhY3Rpb24gdHJlZS4uLlxuICAgIC8vIGhpdCB0ZXN0IGVhY2ggaXRlbSEgLT5cbiAgICAvLyBnZXQgaW50ZXJhY3RpdmUgaXRlbXMgdW5kZXIgcG9pbnQ/P1xuICAgIC8vc3RhZ2UuX19pXG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuaW50ZXJhY3RpdmVJdGVtcy5sZW5ndGg7XG5cbiAgICAvLyB3aGlsZVxuICAgIC8vIGhpdCB0ZXN0XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5pbnRlcmFjdGl2ZUl0ZW1zW2ldO1xuXG4gICAgICAgIGlmKGl0ZW0ubW91c2Vkb3duIHx8IGl0ZW0uY2xpY2spXG4gICAgICAgIHtcbiAgICAgICAgICAgIGl0ZW0uX19tb3VzZUlzRG93biA9IHRydWU7XG4gICAgICAgICAgICBpdGVtLl9faGl0ID0gdGhpcy5oaXRUZXN0KGl0ZW0sIHRoaXMubW91c2UpO1xuXG4gICAgICAgICAgICBpZihpdGVtLl9faGl0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vY2FsbCB0aGUgZnVuY3Rpb24hXG4gICAgICAgICAgICAgICAgaWYoaXRlbS5tb3VzZWRvd24paXRlbS5tb3VzZWRvd24odGhpcy5tb3VzZSk7XG4gICAgICAgICAgICAgICAgaXRlbS5fX2lzRG93biA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBqdXN0IHRoZSBvbmUhXG4gICAgICAgICAgICAgICAgaWYoIWl0ZW0uaW50ZXJhY3RpdmVDaGlsZHJlbilicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogSXMgY2FsbGVkIHdoZW4gdGhlIG1vdXNlIGJ1dHRvbiBpcyBtb3ZlZCBvdXQgb2YgdGhlIHJlbmRlcmVyIGVsZW1lbnRcbiAqXG4gKiBAbWV0aG9kIG9uTW91c2VPdXRcbiAqIEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBET00gZXZlbnQgb2YgYSBtb3VzZSBidXR0b24gYmVpbmcgbW92ZWQgb3V0XG4gKiBAcHJpdmF0ZSBcbiAqL1xuUElYSS5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uTW91c2VPdXQgPSBmdW5jdGlvbigpXG57XG4gICAgaWYodGhpcy5kaXJ0eSlcbiAgICB7XG4gICAgICAgIHRoaXMucmVidWlsZEludGVyYWN0aXZlR3JhcGgoKTtcbiAgICB9XG5cbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5pbnRlcmFjdGl2ZUl0ZW1zLmxlbmd0aDtcblxuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlLmN1cnNvciA9ICdpbmhlcml0JztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuaW50ZXJhY3RpdmVJdGVtc1tpXTtcbiAgICAgICAgaWYoaXRlbS5fX2lzT3ZlcilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5tb3VzZS50YXJnZXQgPSBpdGVtO1xuICAgICAgICAgICAgaWYoaXRlbS5tb3VzZW91dClpdGVtLm1vdXNlb3V0KHRoaXMubW91c2UpO1xuICAgICAgICAgICAgaXRlbS5fX2lzT3ZlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5tb3VzZU91dCA9IHRydWU7XG5cbiAgICAvLyBtb3ZlIHRoZSBtb3VzZSB0byBhbiBpbXBvc3NpYmxlIHBvc2l0aW9uXG4gICAgdGhpcy5tb3VzZS5nbG9iYWwueCA9IC0xMDAwMDtcbiAgICB0aGlzLm1vdXNlLmdsb2JhbC55ID0gLTEwMDAwO1xufTtcblxuLyoqXG4gKiBJcyBjYWxsZWQgd2hlbiB0aGUgbW91c2UgYnV0dG9uIGlzIHJlbGVhc2VkIG9uIHRoZSByZW5kZXJlciBlbGVtZW50XG4gKlxuICogQG1ldGhvZCBvbk1vdXNlVXBcbiAqIEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBET00gZXZlbnQgb2YgYSBtb3VzZSBidXR0b24gYmVpbmcgcmVsZWFzZWRcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vbk1vdXNlVXAgPSBmdW5jdGlvbihldmVudClcbntcbiAgICBpZih0aGlzLmRpcnR5KVxuICAgIHtcbiAgICAgICAgdGhpcy5yZWJ1aWxkSW50ZXJhY3RpdmVHcmFwaCgpO1xuICAgIH1cblxuICAgIHRoaXMubW91c2Uub3JpZ2luYWxFdmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDsgLy9JRSB1c2VzIHdpbmRvdy5ldmVudFxuXG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuaW50ZXJhY3RpdmVJdGVtcy5sZW5ndGg7XG4gICAgdmFyIHVwID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmludGVyYWN0aXZlSXRlbXNbaV07XG5cbiAgICAgICAgaXRlbS5fX2hpdCA9IHRoaXMuaGl0VGVzdChpdGVtLCB0aGlzLm1vdXNlKTtcblxuICAgICAgICBpZihpdGVtLl9faGl0ICYmICF1cClcbiAgICAgICAge1xuICAgICAgICAgICAgLy9jYWxsIHRoZSBmdW5jdGlvbiFcbiAgICAgICAgICAgIGlmKGl0ZW0ubW91c2V1cClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpdGVtLm1vdXNldXAodGhpcy5tb3VzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihpdGVtLl9faXNEb3duKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmKGl0ZW0uY2xpY2spaXRlbS5jbGljayh0aGlzLm1vdXNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIWl0ZW0uaW50ZXJhY3RpdmVDaGlsZHJlbil1cCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBpZihpdGVtLl9faXNEb3duKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmKGl0ZW0ubW91c2V1cG91dHNpZGUpaXRlbS5tb3VzZXVwb3V0c2lkZSh0aGlzLm1vdXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW0uX19pc0Rvd24gPSBmYWxzZTtcbiAgICAgICAgLy99XG4gICAgfVxufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgY3VycmVudCBtb3VzZSBjb29yZGluYXRlcyBoaXQgYSBzcHJpdGVcbiAqXG4gKiBAbWV0aG9kIGhpdFRlc3RcbiAqIEBwYXJhbSBpdGVtIHtEaXNwbGF5T2JqZWN0fSBUaGUgZGlzcGxheU9iamVjdCB0byB0ZXN0IGZvciBhIGhpdFxuICogQHBhcmFtIGludGVyYWN0aW9uRGF0YSB7SW50ZXJhY3Rpb25EYXRhfSBUaGUgaW50ZXJhY3Rpb25EYXRhIG9iamVjdCB0byB1cGRhdGUgaW4gdGhlIGNhc2UgdGhlcmUgaXMgYSBoaXRcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5oaXRUZXN0ID0gZnVuY3Rpb24oaXRlbSwgaW50ZXJhY3Rpb25EYXRhKVxue1xuICAgIHZhciBnbG9iYWwgPSBpbnRlcmFjdGlvbkRhdGEuZ2xvYmFsO1xuXG4gICAgaWYoICFpdGVtLndvcmxkVmlzaWJsZSApcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gdGVtcCBmaXggZm9yIGlmIHRoZSBlbGVtZW50IGlzIGluIGEgbm9uIHZpc2libGVcbiAgIFxuICAgIHZhciBpc1Nwcml0ZSA9IChpdGVtIGluc3RhbmNlb2YgUElYSS5TcHJpdGUpLFxuICAgICAgICB3b3JsZFRyYW5zZm9ybSA9IGl0ZW0ud29ybGRUcmFuc2Zvcm0sXG4gICAgICAgIGEwMCA9IHdvcmxkVHJhbnNmb3JtLmEsIGEwMSA9IHdvcmxkVHJhbnNmb3JtLmIsIGEwMiA9IHdvcmxkVHJhbnNmb3JtLnR4LFxuICAgICAgICBhMTAgPSB3b3JsZFRyYW5zZm9ybS5jLCBhMTEgPSB3b3JsZFRyYW5zZm9ybS5kLCBhMTIgPSB3b3JsZFRyYW5zZm9ybS50eSxcbiAgICAgICAgaWQgPSAxIC8gKGEwMCAqIGExMSArIGEwMSAqIC1hMTApLFxuICAgICAgICB4ID0gYTExICogaWQgKiBnbG9iYWwueCArIC1hMDEgKiBpZCAqIGdsb2JhbC55ICsgKGExMiAqIGEwMSAtIGEwMiAqIGExMSkgKiBpZCxcbiAgICAgICAgeSA9IGEwMCAqIGlkICogZ2xvYmFsLnkgKyAtYTEwICogaWQgKiBnbG9iYWwueCArICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGlkO1xuXG4gICAgaW50ZXJhY3Rpb25EYXRhLnRhcmdldCA9IGl0ZW07XG5cbiAgICAvL2Egc3ByaXRlIG9yIGRpc3BsYXkgb2JqZWN0IHdpdGggYSBoaXQgYXJlYSBkZWZpbmVkXG4gICAgaWYoaXRlbS5oaXRBcmVhICYmIGl0ZW0uaGl0QXJlYS5jb250YWlucykge1xuICAgICAgICBpZihpdGVtLmhpdEFyZWEuY29udGFpbnMoeCwgeSkpIHtcbiAgICAgICAgICAgIC8vaWYoaXNTcHJpdGUpXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkRhdGEudGFyZ2V0ID0gaXRlbTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGEgc3ByaXRlIHdpdGggbm8gaGl0YXJlYSBkZWZpbmVkXG4gICAgZWxzZSBpZihpc1Nwcml0ZSlcbiAgICB7XG4gICAgICAgIHZhciB3aWR0aCA9IGl0ZW0udGV4dHVyZS5mcmFtZS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IGl0ZW0udGV4dHVyZS5mcmFtZS5oZWlnaHQsXG4gICAgICAgICAgICB4MSA9IC13aWR0aCAqIGl0ZW0uYW5jaG9yLngsXG4gICAgICAgICAgICB5MTtcblxuICAgICAgICBpZih4ID4geDEgJiYgeCA8IHgxICsgd2lkdGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHkxID0gLWhlaWdodCAqIGl0ZW0uYW5jaG9yLnk7XG5cbiAgICAgICAgICAgIGlmKHkgPiB5MSAmJiB5IDwgeTEgKyBoZWlnaHQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gc2V0IHRoZSB0YXJnZXQgcHJvcGVydHkgaWYgYSBoaXQgaXMgdHJ1ZSFcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbkRhdGEudGFyZ2V0ID0gaXRlbTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsZW5ndGggPSBpdGVtLmNoaWxkcmVuLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgdGVtcEl0ZW0gPSBpdGVtLmNoaWxkcmVuW2ldO1xuICAgICAgICB2YXIgaGl0ID0gdGhpcy5oaXRUZXN0KHRlbXBJdGVtLCBpbnRlcmFjdGlvbkRhdGEpO1xuICAgICAgICBpZihoaXQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGhtbS4uIFRPRE8gU0VUIENPUlJFQ1QgVEFSR0VUP1xuICAgICAgICAgICAgaW50ZXJhY3Rpb25EYXRhLnRhcmdldCA9IGl0ZW07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogSXMgY2FsbGVkIHdoZW4gYSB0b3VjaCBpcyBtb3ZlZCBhY3Jvc3MgdGhlIHJlbmRlcmVyIGVsZW1lbnRcbiAqXG4gKiBAbWV0aG9kIG9uVG91Y2hNb3ZlXG4gKiBAcGFyYW0gZXZlbnQge0V2ZW50fSBUaGUgRE9NIGV2ZW50IG9mIGEgdG91Y2ggbW92aW5nIGFjcm9zcyB0aGUgcmVuZGVyZXIgdmlld1xuICogQHByaXZhdGVcbiAqL1xuUElYSS5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uVG91Y2hNb3ZlID0gZnVuY3Rpb24oZXZlbnQpXG57XG4gICAgaWYodGhpcy5kaXJ0eSlcbiAgICB7XG4gICAgICAgIHRoaXMucmVidWlsZEludGVyYWN0aXZlR3JhcGgoKTtcbiAgICB9XG5cbiAgICB2YXIgcmVjdCA9IHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBjaGFuZ2VkVG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzO1xuICAgIHZhciB0b3VjaERhdGE7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIHRvdWNoRXZlbnQgPSBjaGFuZ2VkVG91Y2hlc1tpXTtcbiAgICAgICAgdG91Y2hEYXRhID0gdGhpcy50b3VjaHNbdG91Y2hFdmVudC5pZGVudGlmaWVyXTtcbiAgICAgICAgdG91Y2hEYXRhLm9yaWdpbmFsRXZlbnQgPSAgZXZlbnQgfHwgd2luZG93LmV2ZW50O1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdG91Y2ggcG9zaXRpb25cbiAgICAgICAgdG91Y2hEYXRhLmdsb2JhbC54ID0gKHRvdWNoRXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCkgKiAodGhpcy50YXJnZXQud2lkdGggLyByZWN0LndpZHRoKTtcbiAgICAgICAgdG91Y2hEYXRhLmdsb2JhbC55ID0gKHRvdWNoRXZlbnQuY2xpZW50WSAtIHJlY3QudG9wKSAgKiAodGhpcy50YXJnZXQuaGVpZ2h0IC8gcmVjdC5oZWlnaHQpO1xuICAgICAgICBpZihuYXZpZ2F0b3IuaXNDb2Nvb25KUykge1xuICAgICAgICAgICAgdG91Y2hEYXRhLmdsb2JhbC54ID0gdG91Y2hFdmVudC5jbGllbnRYO1xuICAgICAgICAgICAgdG91Y2hEYXRhLmdsb2JhbC55ID0gdG91Y2hFdmVudC5jbGllbnRZO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmludGVyYWN0aXZlSXRlbXMubGVuZ3RoOyBqKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5pbnRlcmFjdGl2ZUl0ZW1zW2pdO1xuICAgICAgICAgICAgaWYoaXRlbS50b3VjaG1vdmUgJiYgaXRlbS5fX3RvdWNoRGF0YSAmJiBpdGVtLl9fdG91Y2hEYXRhW3RvdWNoRXZlbnQuaWRlbnRpZmllcl0pIGl0ZW0udG91Y2htb3ZlKHRvdWNoRGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIElzIGNhbGxlZCB3aGVuIGEgdG91Y2ggaXMgc3RhcnRlZCBvbiB0aGUgcmVuZGVyZXIgZWxlbWVudFxuICpcbiAqIEBtZXRob2Qgb25Ub3VjaFN0YXJ0XG4gKiBAcGFyYW0gZXZlbnQge0V2ZW50fSBUaGUgRE9NIGV2ZW50IG9mIGEgdG91Y2ggc3RhcnRpbmcgb24gdGhlIHJlbmRlcmVyIHZpZXdcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vblRvdWNoU3RhcnQgPSBmdW5jdGlvbihldmVudClcbntcbiAgICBpZih0aGlzLmRpcnR5KVxuICAgIHtcbiAgICAgICAgdGhpcy5yZWJ1aWxkSW50ZXJhY3RpdmVHcmFwaCgpO1xuICAgIH1cblxuICAgIHZhciByZWN0ID0gdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICBpZihQSVhJLkFVVE9fUFJFVkVOVF9ERUZBVUxUKWV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgXG4gICAgdmFyIGNoYW5nZWRUb3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG4gICAgZm9yICh2YXIgaT0wOyBpIDwgY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgdG91Y2hFdmVudCA9IGNoYW5nZWRUb3VjaGVzW2ldO1xuXG4gICAgICAgIHZhciB0b3VjaERhdGEgPSB0aGlzLnBvb2wucG9wKCk7XG4gICAgICAgIGlmKCF0b3VjaERhdGEpdG91Y2hEYXRhID0gbmV3IFBJWEkuSW50ZXJhY3Rpb25EYXRhKCk7XG5cbiAgICAgICAgdG91Y2hEYXRhLm9yaWdpbmFsRXZlbnQgPSAgZXZlbnQgfHwgd2luZG93LmV2ZW50O1xuXG4gICAgICAgIHRoaXMudG91Y2hzW3RvdWNoRXZlbnQuaWRlbnRpZmllcl0gPSB0b3VjaERhdGE7XG4gICAgICAgIHRvdWNoRGF0YS5nbG9iYWwueCA9ICh0b3VjaEV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQpICogKHRoaXMudGFyZ2V0LndpZHRoIC8gcmVjdC53aWR0aCk7XG4gICAgICAgIHRvdWNoRGF0YS5nbG9iYWwueSA9ICh0b3VjaEV2ZW50LmNsaWVudFkgLSByZWN0LnRvcCkgICogKHRoaXMudGFyZ2V0LmhlaWdodCAvIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgaWYobmF2aWdhdG9yLmlzQ29jb29uSlMpIHtcbiAgICAgICAgICAgIHRvdWNoRGF0YS5nbG9iYWwueCA9IHRvdWNoRXZlbnQuY2xpZW50WDtcbiAgICAgICAgICAgIHRvdWNoRGF0YS5nbG9iYWwueSA9IHRvdWNoRXZlbnQuY2xpZW50WTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmludGVyYWN0aXZlSXRlbXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5pbnRlcmFjdGl2ZUl0ZW1zW2pdO1xuXG4gICAgICAgICAgICBpZihpdGVtLnRvdWNoc3RhcnQgfHwgaXRlbS50YXApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaXRlbS5fX2hpdCA9IHRoaXMuaGl0VGVzdChpdGVtLCB0b3VjaERhdGEpO1xuXG4gICAgICAgICAgICAgICAgaWYoaXRlbS5fX2hpdClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vY2FsbCB0aGUgZnVuY3Rpb24hXG4gICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0udG91Y2hzdGFydClpdGVtLnRvdWNoc3RhcnQodG91Y2hEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5fX2lzRG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uX190b3VjaERhdGEgPSBpdGVtLl9fdG91Y2hEYXRhIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBpdGVtLl9fdG91Y2hEYXRhW3RvdWNoRXZlbnQuaWRlbnRpZmllcl0gPSB0b3VjaERhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIWl0ZW0uaW50ZXJhY3RpdmVDaGlsZHJlbilicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIElzIGNhbGxlZCB3aGVuIGEgdG91Y2ggaXMgZW5kZWQgb24gdGhlIHJlbmRlcmVyIGVsZW1lbnRcbiAqXG4gKiBAbWV0aG9kIG9uVG91Y2hFbmRcbiAqIEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBET00gZXZlbnQgb2YgYSB0b3VjaCBlbmRpbmcgb24gdGhlIHJlbmRlcmVyIHZpZXdcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vblRvdWNoRW5kID0gZnVuY3Rpb24oZXZlbnQpXG57XG4gICAgaWYodGhpcy5kaXJ0eSlcbiAgICB7XG4gICAgICAgIHRoaXMucmVidWlsZEludGVyYWN0aXZlR3JhcGgoKTtcbiAgICB9XG4gICAgXG4gICAgLy90aGlzLm1vdXNlLm9yaWdpbmFsRXZlbnQgPSBldmVudCB8fCB3aW5kb3cuZXZlbnQ7IC8vSUUgdXNlcyB3aW5kb3cuZXZlbnRcbiAgICB2YXIgcmVjdCA9IHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBjaGFuZ2VkVG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzO1xuXG4gICAgZm9yICh2YXIgaT0wOyBpIDwgY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgdG91Y2hFdmVudCA9IGNoYW5nZWRUb3VjaGVzW2ldO1xuICAgICAgICB2YXIgdG91Y2hEYXRhID0gdGhpcy50b3VjaHNbdG91Y2hFdmVudC5pZGVudGlmaWVyXTtcbiAgICAgICAgdmFyIHVwID0gZmFsc2U7XG4gICAgICAgIHRvdWNoRGF0YS5nbG9iYWwueCA9ICh0b3VjaEV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQpICogKHRoaXMudGFyZ2V0LndpZHRoIC8gcmVjdC53aWR0aCk7XG4gICAgICAgIHRvdWNoRGF0YS5nbG9iYWwueSA9ICh0b3VjaEV2ZW50LmNsaWVudFkgLSByZWN0LnRvcCkgICogKHRoaXMudGFyZ2V0LmhlaWdodCAvIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgaWYobmF2aWdhdG9yLmlzQ29jb29uSlMpIHtcbiAgICAgICAgICAgIHRvdWNoRGF0YS5nbG9iYWwueCA9IHRvdWNoRXZlbnQuY2xpZW50WDtcbiAgICAgICAgICAgIHRvdWNoRGF0YS5nbG9iYWwueSA9IHRvdWNoRXZlbnQuY2xpZW50WTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmludGVyYWN0aXZlSXRlbXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaisrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuaW50ZXJhY3RpdmVJdGVtc1tqXTtcblxuICAgICAgICAgICAgaWYoaXRlbS5fX3RvdWNoRGF0YSAmJiBpdGVtLl9fdG91Y2hEYXRhW3RvdWNoRXZlbnQuaWRlbnRpZmllcl0pIHtcblxuICAgICAgICAgICAgICAgIGl0ZW0uX19oaXQgPSB0aGlzLmhpdFRlc3QoaXRlbSwgaXRlbS5fX3RvdWNoRGF0YVt0b3VjaEV2ZW50LmlkZW50aWZpZXJdKTtcblxuICAgICAgICAgICAgICAgIC8vIHNvIHRoaXMgb25lIFdBUyBkb3duLi4uXG4gICAgICAgICAgICAgICAgdG91Y2hEYXRhLm9yaWdpbmFsRXZlbnQgPSBldmVudCB8fCB3aW5kb3cuZXZlbnQ7XG4gICAgICAgICAgICAgICAgLy8gaGl0VGVzdD8/XG5cbiAgICAgICAgICAgICAgICBpZihpdGVtLnRvdWNoZW5kIHx8IGl0ZW0udGFwKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS5fX2hpdCAmJiAhdXApXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0udG91Y2hlbmQpaXRlbS50b3VjaGVuZCh0b3VjaERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS5fX2lzRG93bilcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpdGVtLnRhcClpdGVtLnRhcCh0b3VjaERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighaXRlbS5pbnRlcmFjdGl2ZUNoaWxkcmVuKXVwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0uX19pc0Rvd24pXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS50b3VjaGVuZG91dHNpZGUpaXRlbS50b3VjaGVuZG91dHNpZGUodG91Y2hEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uX19pc0Rvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpdGVtLl9fdG91Y2hEYXRhW3RvdWNoRXZlbnQuaWRlbnRpZmllcl0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgdG91Y2guLlxuICAgICAgICB0aGlzLnBvb2wucHVzaCh0b3VjaERhdGEpO1xuICAgICAgICB0aGlzLnRvdWNoc1t0b3VjaEV2ZW50LmlkZW50aWZpZXJdID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogQSBTdGFnZSByZXByZXNlbnRzIHRoZSByb290IG9mIHRoZSBkaXNwbGF5IHRyZWUuIEV2ZXJ5dGhpbmcgY29ubmVjdGVkIHRvIHRoZSBzdGFnZSBpcyByZW5kZXJlZFxuICpcbiAqIEBjbGFzcyBTdGFnZVxuICogQGV4dGVuZHMgRGlzcGxheU9iamVjdENvbnRhaW5lclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gYmFja2dyb3VuZENvbG9yIHtOdW1iZXJ9IHRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSBzdGFnZSwgeW91IGhhdmUgdG8gcGFzcyB0aGlzIGluIGlzIGluIGhleCBmb3JtYXRcbiAqICAgICAgbGlrZTogMHhGRkZGRkYgZm9yIHdoaXRlXG4gKiBcbiAqIENyZWF0aW5nIGEgc3RhZ2UgaXMgYSBtYW5kYXRvcnkgcHJvY2VzcyB3aGVuIHlvdSB1c2UgUGl4aSwgd2hpY2ggaXMgYXMgc2ltcGxlIGFzIHRoaXMgOiBcbiAqIHZhciBzdGFnZSA9IG5ldyBQSVhJLlN0YWdlKDB4RkZGRkZGKTtcbiAqIHdoZXJlIHRoZSBwYXJhbWV0ZXIgZ2l2ZW4gaXMgdGhlIGJhY2tncm91bmQgY29sb3VyIG9mIHRoZSBzdGFnZSwgaW4gaGV4XG4gKiB5b3Ugd2lsbCB1c2UgdGhpcyBzdGFnZSBpbnN0YW5jZSB0byBhZGQgeW91ciBzcHJpdGVzIHRvIGl0IGFuZCB0aGVyZWZvcmUgdG8gdGhlIHJlbmRlcmVyXG4gKiBIZXJlIGlzIGhvdyB0byBhZGQgYSBzcHJpdGUgdG8gdGhlIHN0YWdlIDogXG4gKiBzdGFnZS5hZGRDaGlsZChzcHJpdGUpO1xuICovXG5QSVhJLlN0YWdlID0gZnVuY3Rpb24oYmFja2dyb3VuZENvbG9yKVxue1xuICAgIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKCB0aGlzICk7XG5cbiAgICAvKipcbiAgICAgKiBbcmVhZC1vbmx5XSBDdXJyZW50IHRyYW5zZm9ybSBvZiB0aGUgb2JqZWN0IGJhc2VkIG9uIHdvcmxkIChwYXJlbnQpIGZhY3RvcnNcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB3b3JsZFRyYW5zZm9ybVxuICAgICAqIEB0eXBlIE1hdDNcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBuZXcgUElYSS5NYXRyaXgoKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBzdGFnZSBpcyBpbnRlcmFjdGl2ZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGludGVyYWN0aXZlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJhY3RpdmUgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVyYWN0aW9uIG1hbmFnZSBmb3IgdGhpcyBzdGFnZSwgbWFuYWdlcyBhbGwgaW50ZXJhY3RpdmUgYWN0aXZpdHkgb24gdGhlIHN0YWdlXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgaW50ZXJhY3Rpb25NYW5hZ2VyXG4gICAgICogQHR5cGUgSW50ZXJhY3Rpb25NYW5hZ2VyXG4gICAgICovXG4gICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIgPSBuZXcgUElYSS5JbnRlcmFjdGlvbk1hbmFnZXIodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBzdGFnZSBpcyBkaXJ0eSBhbmQgbmVlZHMgdG8gaGF2ZSBpbnRlcmFjdGlvbnMgdXBkYXRlZFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGRpcnR5XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICAvL3RoZSBzdGFnZSBpcyBpdHMgb3duIHN0YWdlXG4gICAgdGhpcy5zdGFnZSA9IHRoaXM7XG5cbiAgICAvL29wdGltaXplIGhpdCBkZXRlY3Rpb24gYSBiaXRcbiAgICB0aGlzLnN0YWdlLmhpdEFyZWEgPSBuZXcgUElYSS5SZWN0YW5nbGUoMCwwLDEwMDAwMCwgMTAwMDAwKTtcblxuICAgIHRoaXMuc2V0QmFja2dyb3VuZENvbG9yKGJhY2tncm91bmRDb2xvcik7XG59O1xuXG4vLyBjb25zdHJ1Y3RvclxuUElYSS5TdGFnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlICk7XG5QSVhJLlN0YWdlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuU3RhZ2U7XG5cbi8qKlxuICogU2V0cyBhbm90aGVyIERPTSBlbGVtZW50IHdoaWNoIGNhbiByZWNlaXZlIG1vdXNlL3RvdWNoIGludGVyYWN0aW9ucyBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IENhbnZhcyBlbGVtZW50LlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIHdoZW4geW91IGhhdmUgb3RoZXIgRE9NIGVsZW1lbnRzIG9uIHRvcCBvZiB0aGUgQ2FudmFzIGVsZW1lbnQuXG4gKlxuICogQG1ldGhvZCBzZXRJbnRlcmFjdGlvbkRlbGVnYXRlXG4gKiBAcGFyYW0gZG9tRWxlbWVudCB7RE9NRWxlbWVudH0gVGhpcyBuZXcgZG9tRWxlbWVudCB3aGljaCB3aWxsIHJlY2VpdmUgbW91c2UvdG91Y2ggZXZlbnRzXG4gKi9cblBJWEkuU3RhZ2UucHJvdG90eXBlLnNldEludGVyYWN0aW9uRGVsZWdhdGUgPSBmdW5jdGlvbihkb21FbGVtZW50KVxue1xuICAgIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyLnNldFRhcmdldERvbUVsZW1lbnQoIGRvbUVsZW1lbnQgKTtcbn07XG5cbi8qXG4gKiBVcGRhdGVzIHRoZSBvYmplY3QgdHJhbnNmb3JtIGZvciByZW5kZXJpbmdcbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVRyYW5zZm9ybVxuICogQHByaXZhdGVcbiAqL1xuUElYSS5TdGFnZS5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMud29ybGRBbHBoYSA9IDE7XG5cbiAgICBmb3IodmFyIGk9MCxqPXRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpPGo7IGkrKylcbiAgICB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0udXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgfVxuXG4gICAgaWYodGhpcy5kaXJ0eSlcbiAgICB7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgLy8gdXBkYXRlIGludGVyYWN0aXZlIVxuICAgICAgICB0aGlzLmludGVyYWN0aW9uTWFuYWdlci5kaXJ0eSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYodGhpcy5pbnRlcmFjdGl2ZSl0aGlzLmludGVyYWN0aW9uTWFuYWdlci51cGRhdGUoKTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgYmFja2dyb3VuZCBjb2xvciBmb3IgdGhlIHN0YWdlXG4gKlxuICogQG1ldGhvZCBzZXRCYWNrZ3JvdW5kQ29sb3JcbiAqIEBwYXJhbSBiYWNrZ3JvdW5kQ29sb3Ige051bWJlcn0gdGhlIGNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kLCBlYXNpZXN0IHdheSB0byBwYXNzIHRoaXMgaW4gaXMgaW4gaGV4IGZvcm1hdFxuICogICAgICBsaWtlOiAweEZGRkZGRiBmb3Igd2hpdGVcbiAqL1xuUElYSS5TdGFnZS5wcm90b3R5cGUuc2V0QmFja2dyb3VuZENvbG9yID0gZnVuY3Rpb24oYmFja2dyb3VuZENvbG9yKVxue1xuICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gYmFja2dyb3VuZENvbG9yIHx8IDB4MDAwMDAwO1xuICAgIHRoaXMuYmFja2dyb3VuZENvbG9yU3BsaXQgPSBQSVhJLmhleDJyZ2IodGhpcy5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgIHZhciBoZXggPSB0aGlzLmJhY2tncm91bmRDb2xvci50b1N0cmluZygxNik7XG4gICAgaGV4ID0gJzAwMDAwMCcuc3Vic3RyKDAsIDYgLSBoZXgubGVuZ3RoKSArIGhleDtcbiAgICB0aGlzLmJhY2tncm91bmRDb2xvclN0cmluZyA9ICcjJyArIGhleDtcbn07XG5cbi8qKlxuICogVGhpcyB3aWxsIHJldHVybiB0aGUgcG9pbnQgY29udGFpbmluZyBnbG9iYWwgY29vcmRzIG9mIHRoZSBtb3VzZS5cbiAqXG4gKiBAbWV0aG9kIGdldE1vdXNlUG9zaXRpb25cbiAqIEByZXR1cm4ge1BvaW50fSBUaGUgcG9pbnQgY29udGFpbmluZyB0aGUgY29vcmRzIG9mIHRoZSBnbG9iYWwgSW50ZXJhY3Rpb25EYXRhIHBvc2l0aW9uLlxuICovXG5QSVhJLlN0YWdlLnByb3RvdHlwZS5nZXRNb3VzZVBvc2l0aW9uID0gZnVuY3Rpb24oKVxue1xuICAgIHJldHVybiB0aGlzLmludGVyYWN0aW9uTWFuYWdlci5tb3VzZS5nbG9iYWw7XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG4gXG4vLyBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xuLy8gaHR0cDovL215Lm9wZXJhLmNvbS9lbW9sbGVyL2Jsb2cvMjAxMS8xMi8yMC9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWVyLWFuaW1hdGluZ1xuXG4vLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcG9seWZpbGwgYnkgRXJpayBNw7ZsbGVyLiBmaXhlcyBmcm9tIFBhdWwgSXJpc2ggYW5kIFRpbm8gWmlqZGVsXG5cbi8vIE1JVCBsaWNlbnNlXG5cbi8qKlxuICogQSBwb2x5ZmlsbCBmb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gKiBZb3UgY2FuIGFjdHVhbGx5IHVzZSBib3RoIHJlcXVlc3RBbmltYXRpb25GcmFtZSBhbmQgcmVxdWVzdEFuaW1GcmFtZSwgXG4gKiB5b3Ugd2lsbCBzdGlsbCBiZW5lZml0IGZyb20gdGhlIHBvbHlmaWxsXG4gKlxuICogQG1ldGhvZCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAqL1xuLyoqXG4gKiBBIHBvbHlmaWxsIGZvciBjYW5jZWxBbmltYXRpb25GcmFtZVxuICpcbiAqIEBtZXRob2QgY2FuY2VsQW5pbWF0aW9uRnJhbWVcbiAqL1xudmFyIGxhc3RUaW1lID0gMDtcbnZhciB2ZW5kb3JzID0gWydtcycsICdtb3onLCAnd2Via2l0JywgJ28nXTtcbmZvcih2YXIgeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKyt4KSB7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ10gfHxcbiAgICAgICAgd2luZG93W3ZlbmRvcnNbeF0gKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG59XG5cbmlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICB2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSk7XG4gICAgICAgIHZhciBpZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpOyB9LFxuICAgICAgICAgIHRpbWVUb0NhbGwpO1xuICAgICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH07XG59XG5cbmlmICghd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICB9O1xufVxuXG53aW5kb3cucmVxdWVzdEFuaW1GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cbi8qKlxuICogQ29udmVydHMgYSBoZXggY29sb3IgbnVtYmVyIHRvIGFuIFtSLCBHLCBCXSBhcnJheVxuICpcbiAqIEBtZXRob2QgaGV4MnJnYlxuICogQHBhcmFtIGhleCB7TnVtYmVyfVxuICovXG5QSVhJLmhleDJyZ2IgPSBmdW5jdGlvbihoZXgpIHtcbiAgICByZXR1cm4gWyhoZXggPj4gMTYgJiAweEZGKSAvIDI1NSwgKCBoZXggPj4gOCAmIDB4RkYpIC8gMjU1LCAoaGV4ICYgMHhGRikvIDI1NV07XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgY29sb3IgYXMgYW4gW1IsIEcsIEJdIGFycmF5IHRvIGEgaGV4IG51bWJlclxuICpcbiAqIEBtZXRob2QgcmdiMmhleFxuICogQHBhcmFtIHJnYiB7QXJyYXl9XG4gKi9cblBJWEkucmdiMmhleCA9IGZ1bmN0aW9uKHJnYikge1xuICAgIHJldHVybiAoKHJnYlswXSoyNTUgPDwgMTYpICsgKHJnYlsxXSoyNTUgPDwgOCkgKyByZ2JbMl0qMjU1KTtcbn07XG5cbi8qKlxuICogQSBwb2x5ZmlsbCBmb3IgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbiAqXG4gKiBAbWV0aG9kIGJpbmRcbiAqL1xuaWYgKHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRoaXNBcmcpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLCBib3VuZEFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYm91bmRBcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgICAgIHRhcmdldC5hcHBseSh0aGlzIGluc3RhbmNlb2YgYm91bmQgPyB0aGlzIDogdGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IChmdW5jdGlvbiBGKHByb3RvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3RvKSBGLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGKSkgcmV0dXJuIG5ldyBGKCk7XG4gICAgICAgICAgICB9KSh0YXJnZXQucHJvdG90eXBlKTtcblxuICAgICAgICAgICAgcmV0dXJuIGJvdW5kO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG59XG5cbi8qKlxuICogQSB3cmFwcGVyIGZvciBhamF4IHJlcXVlc3RzIHRvIGJlIGhhbmRsZWQgY3Jvc3MgYnJvd3NlclxuICpcbiAqIEBjbGFzcyBBamF4UmVxdWVzdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cblBJWEkuQWpheFJlcXVlc3QgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGFjdGl2ZXhtb2RlcyA9IFsnTXN4bWwyLlhNTEhUVFAuNi4wJywgJ01zeG1sMi5YTUxIVFRQLjMuMCcsICdNaWNyb3NvZnQuWE1MSFRUUCddOyAvL2FjdGl2ZVggdmVyc2lvbnMgdG8gY2hlY2sgZm9yIGluIElFXG5cbiAgICBpZiAod2luZG93LkFjdGl2ZVhPYmplY3QpXG4gICAgeyAvL1Rlc3QgZm9yIHN1cHBvcnQgZm9yIEFjdGl2ZVhPYmplY3QgaW4gSUUgZmlyc3QgKGFzIFhNTEh0dHBSZXF1ZXN0IGluIElFNyBpcyBicm9rZW4pXG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxhY3RpdmV4bW9kZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5BY3RpdmVYT2JqZWN0KGFjdGl2ZXhtb2Rlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgLy9zdXBwcmVzcyBlcnJvclxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCkgLy8gaWYgTW96aWxsYSwgU2FmYXJpIGV0Y1xuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG4vKlxuUElYSS5wYWNrQ29sb3JSR0JBID0gZnVuY3Rpb24ociwgZywgYiwgYSkvL3IsIGcsIGIsIGEpXG57XG4gIC8vICBjb25zb2xlLmxvZyhyLCBiLCBjLCBkKVxuICByZXR1cm4gKE1hdGguZmxvb3IoKHIpKjYzKSA8PCAxOCkgfCAoTWF0aC5mbG9vcigoZykqNjMpIDw8IDEyKSB8IChNYXRoLmZsb29yKChiKSo2MykgPDwgNik7Ly8gfCAoTWF0aC5mbG9vcigoYSkqNjMpKVxuICAvLyAgaSA9IGkgfCAoTWF0aC5mbG9vcigoYSkqNjMpKTtcbiAgIC8vIHJldHVybiBpO1xuICAgLy8gdmFyIHIgPSAoaSAvIDI2MjE0NC4wICkgLyA2NDtcbiAgIC8vIHZhciBnID0gKGkgLyA0MDk2LjApJTY0IC8gNjQ7XG4gIC8vICB2YXIgYiA9IChpIC8gNjQuMCklNjQgLyA2NDtcbiAgLy8gIHZhciBhID0gKGkpJTY0IC8gNjQ7XG4gICAgIFxuICAvLyAgY29uc29sZS5sb2cociwgZywgYiwgYSk7XG4gIC8vICByZXR1cm4gaTtcblxufTtcbiovXG4vKlxuUElYSS5wYWNrQ29sb3JSR0IgPSBmdW5jdGlvbihyLCBnLCBiKS8vciwgZywgYiwgYSlcbntcbiAgICByZXR1cm4gKE1hdGguZmxvb3IoKHIpKjI1NSkgPDwgMTYpIHwgKE1hdGguZmxvb3IoKGcpKjI1NSkgPDwgOCkgfCAoTWF0aC5mbG9vcigoYikqMjU1KSk7XG59O1xuXG5QSVhJLnVucGFja0NvbG9yUkdCID0gZnVuY3Rpb24ociwgZywgYikvL3IsIGcsIGIsIGEpXG57XG4gICAgcmV0dXJuIChNYXRoLmZsb29yKChyKSoyNTUpIDw8IDE2KSB8IChNYXRoLmZsb29yKChnKSoyNTUpIDw8IDgpIHwgKE1hdGguZmxvb3IoKGIpKjI1NSkpO1xufTtcbiovXG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIENhbnZhcyBCbGVuZE1vZGVzIGFyZSBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgYnJvd3NlclxuICpcbiAqIEBtZXRob2QgY2FuVXNlTmV3Q2FudmFzQmxlbmRNb2Rlc1xuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciB0aGV5IGFyZSBzdXBwb3J0ZWRcbiAqL1xuUElYSS5jYW5Vc2VOZXdDYW52YXNCbGVuZE1vZGVzID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSAxO1xuICAgIGNhbnZhcy5oZWlnaHQgPSAxO1xuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAnIzAwMCc7XG4gICAgY29udGV4dC5maWxsUmVjdCgwLDAsMSwxKTtcbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdtdWx0aXBseSc7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAnI2ZmZic7XG4gICAgY29udGV4dC5maWxsUmVjdCgwLDAsMSwxKTtcbiAgICByZXR1cm4gY29udGV4dC5nZXRJbWFnZURhdGEoMCwwLDEsMSkuZGF0YVswXSA9PT0gMDtcbn07XG5cbi8qKlxuICogR2l2ZW4gYSBudW1iZXIsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgY2xvc2VzdCBudW1iZXIgdGhhdCBpcyBhIHBvd2VyIG9mIHR3b1xuICogdGhpcyBmdW5jdGlvbiBpcyB0YWtlbiBmcm9tIFN0YXJsaW5nIEZyYW1ld29yayBhcyBpdHMgcHJldHR5IG5lYXQgOylcbiAqXG4gKiBAbWV0aG9kIGdldE5leHRQb3dlck9mVHdvXG4gKiBAcGFyYW0gbnVtYmVyIHtOdW1iZXJ9XG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBjbG9zZXN0IG51bWJlciB0aGF0IGlzIGEgcG93ZXIgb2YgdHdvXG4gKi9cblBJWEkuZ2V0TmV4dFBvd2VyT2ZUd28gPSBmdW5jdGlvbihudW1iZXIpXG57XG4gICAgaWYgKG51bWJlciA+IDAgJiYgKG51bWJlciAmIChudW1iZXIgLSAxKSkgPT09IDApIC8vIHNlZTogaHR0cDovL2dvby5nbC9EOWtQalxuICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHZhciByZXN1bHQgPSAxO1xuICAgICAgICB3aGlsZSAocmVzdWx0IDwgbnVtYmVyKSByZXN1bHQgPDw9IDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuIFxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL2V2ZW50dGFyZ2V0LmpzL1xuICogVEhhbmtTIG1yIERPb2IhXG4gKi9cblxuLyoqXG4gKiBBZGRzIGV2ZW50IGVtaXR0ZXIgZnVuY3Rpb25hbGl0eSB0byBhIGNsYXNzXG4gKlxuICogQGNsYXNzIEV2ZW50VGFyZ2V0XG4gKiBAZXhhbXBsZVxuICogICAgICBmdW5jdGlvbiBNeUVtaXR0ZXIoKSB7XG4gKiAgICAgICAgICBQSVhJLkV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7IC8vbWl4ZXMgaW4gZXZlbnQgdGFyZ2V0IHN0dWZmXG4gKiAgICAgIH1cbiAqXG4gKiAgICAgIHZhciBlbSA9IG5ldyBNeUVtaXR0ZXIoKTtcbiAqICAgICAgZW0uZW1pdCh7IHR5cGU6ICdldmVudE5hbWUnLCBkYXRhOiAnc29tZSBkYXRhJyB9KTtcbiAqL1xuUElYSS5FdmVudFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxuICAgICAqIEhvbGRzIGFsbCB0aGUgbGlzdGVuZXJzXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbGlzdGVuZXJzXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgdmFyIGxpc3RlbmVycyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIGZvciBhIHNwZWNpZmljIGV2ZW50XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXJcbiAgICAgKiBAcGFyYW0gdHlwZSB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvci5cbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIge2Z1bmN0aW9ufSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gdGhlIGV2ZW50IG9jY3Vyc1xuICAgICAqL1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IHRoaXMub24gPSBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuXG5cbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXSA9IFtdO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcblxuICAgICAgICAgICAgbGlzdGVuZXJzWyB0eXBlIF0udW5zaGlmdCggbGlzdGVuZXIgKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHRoZSBldmVudCwgaWUgcHJldGVuZHMgdGhhdCB0aGUgZXZlbnQgaGFzIGhhcHBlbmVkXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRpc3BhdGNoRXZlbnRcbiAgICAgKiBAcGFyYW0gZXZlbnQge0V2ZW50fSB0aGUgZXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50ID0gdGhpcy5lbWl0ID0gZnVuY3Rpb24gKCBldmVudCApIHtcblxuICAgICAgICBpZiAoICFsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXSB8fCAhbGlzdGVuZXJzWyBldmVudC50eXBlIF0ubGVuZ3RoICkge1xuXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgZm9yKHZhciBpID0gbGlzdGVuZXJzWyBldmVudC50eXBlIF0ubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4vLyAgICAgICAgZm9yKHZhciBpID0gMCwgbD1saXN0ZW5lcnNbIGV2ZW50LnR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblxuXG4gICAgICAgICAgICBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXVsgaSBdKCBldmVudCApO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgdGhhdCB3YXMgYXNzaWduZWQgdG8gdGhlIHNwZWNpZmllZCBldmVudCB0eXBlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUV2ZW50TGlzdGVuZXJcbiAgICAgKiBAcGFyYW0gdHlwZSB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgd2hpY2ggd2lsbCBoYXZlIGl0cyBsaXN0ZW5lciByZW1vdmVkXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIHtmdW5jdGlvbn0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2FzIGJlIGZpcmVkIHdoZW4gdGhlIGV2ZW50IG9jY3VyZWRcbiAgICAgKi9cbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSB0aGlzLm9mZiA9IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG5cbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBpbmRleCA9IGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICk7XG5cbiAgICAgICAgaWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXS5zcGxpY2UoIGluZGV4LCAxICk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRoZSBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFjdGl2ZSBmb3IgdGhlIHNwZWNpZmllZCBldmVudCB0eXBlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzXG4gICAgICogQHBhcmFtIHR5cGUge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHdoaWNoIHdpbGwgaGF2ZSBhbGwgaXRzIGxpc3RlbmVycyByZW1vdmVkXG4gICAgICovXG5cdHRoaXMucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHR2YXIgYSA9IGxpc3RlbmVyc1t0eXBlXTtcblx0XHRpZiAoYSlcblx0XHRcdGEubGVuZ3RoID0gMDtcblx0fTtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKiBUaGlzIGhlbHBlciBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHdoaWNoIHJlbmRlcmVyIHlvdSBzaG91bGQgYmUgdXNpbmcuXG4gKiBXZWJHTCBpcyB0aGUgcHJlZmVycmVkIHJlbmRlcmVyIGFzIGl0IGlzIGEgbG90IGZhc3Rlci4gSWYgd2ViR0wgaXMgbm90IHN1cHBvcnRlZCBieVxuICogdGhlIGJyb3dzZXIgdGhlbiB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgY2FudmFzIHJlbmRlcmVyXG4gKiBAY2xhc3MgYXV0b0RldGVjdFJlbmRlcmVyXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gd2lkdGg9ODAwIHtOdW1iZXJ9IHRoZSB3aWR0aCBvZiB0aGUgcmVuZGVyZXJzIHZpZXdcbiAqIEBwYXJhbSBoZWlnaHQ9NjAwIHtOdW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIHJlbmRlcmVycyB2aWV3XG4gKiBAcGFyYW0gW3ZpZXddIHtDYW52YXN9IHRoZSBjYW52YXMgdG8gdXNlIGFzIGEgdmlldywgb3B0aW9uYWwgXG4gKiBAcGFyYW0gW3RyYW5zcGFyZW50PWZhbHNlXSB7Qm9vbGVhbn0gdGhlIHRyYW5zcGFyZW5jeSBvZiB0aGUgcmVuZGVyIHZpZXcsIGRlZmF1bHQgZmFsc2VcbiAqIEBwYXJhbSBbYW50aWFsaWFzPWZhbHNlXSB7Qm9vbGVhbn0gc2V0cyBhbnRpYWxpYXMgKG9ubHkgYXBwbGljYWJsZSBpbiB3ZWJHTCBjaHJvbWUgYXQgdGhlIG1vbWVudClcbiAqXG4gKi9cblBJWEkuYXV0b0RldGVjdFJlbmRlcmVyID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgdmlldywgdHJhbnNwYXJlbnQsIGFudGlhbGlhcylcbntcbiAgICBpZighd2lkdGgpd2lkdGggPSA4MDA7XG4gICAgaWYoIWhlaWdodCloZWlnaHQgPSA2MDA7XG5cbiAgICAvLyBCT1JST1dFRCBmcm9tIE1yIERvb2IgKG1yZG9vYi5jb20pXG4gICAgdmFyIHdlYmdsID0gKCBmdW5jdGlvbiAoKSB7IHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhISB3aW5kb3cuV2ViR0xSZW5kZXJpbmdDb250ZXh0ICYmICggY2FudmFzLmdldENvbnRleHQoICd3ZWJnbCcgKSB8fCBjYW52YXMuZ2V0Q29udGV4dCggJ2V4cGVyaW1lbnRhbC13ZWJnbCcgKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKCBlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSApKCk7XG5cbiAgICBpZiggd2ViZ2wgKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQSVhJLldlYkdMUmVuZGVyZXIod2lkdGgsIGhlaWdodCwgdmlldywgdHJhbnNwYXJlbnQsIGFudGlhbGlhcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICBuZXcgUElYSS5DYW52YXNSZW5kZXJlcih3aWR0aCwgaGVpZ2h0LCB2aWV3LCB0cmFuc3BhcmVudCk7XG59O1xuXG4vKipcbiAqIFRoaXMgaGVscGVyIGZ1bmN0aW9uIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3Qgd2hpY2ggcmVuZGVyZXIgeW91IHNob3VsZCBiZSB1c2luZy5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdmVyeSBzaW1pbGFyIHRvIHRoZSBhdXRvRGV0ZWN0UmVuZGVyZXIgZnVuY3Rpb24gZXhjZXB0IHRoYXQgaXMgd2lsbCByZXR1cm4gYSBjYW52YXMgcmVuZGVyZXIgZm9yIGFuZHJvaWQuXG4gKiBFdmVuIHRob3VnaHQgYm90aCBhbmRyb2lkIGNocm9tZSBzdXBvcnRzIHdlYkdMIHRoZSBjYW52YXMgaW1wbGVtZW50YXRpb24gcGVyZm9ybSBiZXR0ZXIgYXQgdGhlIHRpbWUgb2Ygd3JpdGluZy4gXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgbGlrZWx5IGNoYW5nZSBhbmQgdXBkYXRlIGFzIHdlYkdMIHBlcmZvcm1hbmNlIGltcG9yb3ZlcyBvbiB0aGVhc2UgZGV2aWNlcy5cbiAqIEBjbGFzcyBnZXRSZWNvbW1lbmRlZFJlbmRlcmVyXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gd2lkdGg9ODAwIHtOdW1iZXJ9IHRoZSB3aWR0aCBvZiB0aGUgcmVuZGVyZXJzIHZpZXdcbiAqIEBwYXJhbSBoZWlnaHQ9NjAwIHtOdW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIHJlbmRlcmVycyB2aWV3XG4gKiBAcGFyYW0gW3ZpZXddIHtDYW52YXN9IHRoZSBjYW52YXMgdG8gdXNlIGFzIGEgdmlldywgb3B0aW9uYWwgXG4gKiBAcGFyYW0gW3RyYW5zcGFyZW50PWZhbHNlXSB7Qm9vbGVhbn0gdGhlIHRyYW5zcGFyZW5jeSBvZiB0aGUgcmVuZGVyIHZpZXcsIGRlZmF1bHQgZmFsc2VcbiAqIEBwYXJhbSBbYW50aWFsaWFzPWZhbHNlXSB7Qm9vbGVhbn0gc2V0cyBhbnRpYWxpYXMgKG9ubHkgYXBwbGljYWJsZSBpbiB3ZWJHTCBjaHJvbWUgYXQgdGhlIG1vbWVudClcbiAqXG4gKi9cblBJWEkuYXV0b0RldGVjdFJlY29tbWVuZGVkUmVuZGVyZXIgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCB2aWV3LCB0cmFuc3BhcmVudCwgYW50aWFsaWFzKVxue1xuICAgIGlmKCF3aWR0aCl3aWR0aCA9IDgwMDtcbiAgICBpZighaGVpZ2h0KWhlaWdodCA9IDYwMDtcblxuICAgIC8vIEJPUlJPV0VEIGZyb20gTXIgRG9vYiAobXJkb29iLmNvbSlcbiAgICB2YXIgd2ViZ2wgPSAoIGZ1bmN0aW9uICgpIHsgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhIHdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQgJiYgKCBjYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJyApIHx8IGNhbnZhcy5nZXRDb250ZXh0KCAnZXhwZXJpbWVudGFsLXdlYmdsJyApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goIGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICkoKTtcblxuICAgIHZhciBpc0FuZHJvaWQgPSAvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbiAgICBpZiggd2ViZ2wgJiYgIWlzQW5kcm9pZClcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgUElYSS5XZWJHTFJlbmRlcmVyKHdpZHRoLCBoZWlnaHQsIHZpZXcsIHRyYW5zcGFyZW50LCBhbnRpYWxpYXMpO1xuICAgIH1cblxuICAgIHJldHVybiAgbmV3IFBJWEkuQ2FudmFzUmVuZGVyZXIod2lkdGgsIGhlaWdodCwgdmlldywgdHJhbnNwYXJlbnQpO1xufTtcblxuLypcbiAgICBQb2x5SyBsaWJyYXJ5XG4gICAgdXJsOiBodHRwOi8vcG9seWsuaXZhbmsubmV0XG4gICAgUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2VuY2UuXG5cbiAgICBDb3B5cmlnaHQgKGMpIDIwMTIgSXZhbiBLdWNraXJcblxuICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAgICBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAgICByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiAgICBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICAgIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4gICAgY29uZGl0aW9uczpcblxuICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gICAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICAgIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAgICBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAgICBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAgICBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gICAgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4gICAgVGhpcyBpcyBhbiBhbWF6aW5nIGxpYiFcblxuICAgIHNsaWdodGx5IG1vZGlmaWVkIGJ5IE1hdCBHcm92ZXMgKG1hdGdyb3Zlcy5jb20pO1xuKi9cblxuLyoqXG4gKiBCYXNlZCBvbiB0aGUgUG9seWsgbGlicmFyeSBodHRwOi8vcG9seWsuaXZhbmsubmV0IHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbmNlLlxuICogVGhpcyBpcyBhbiBhbWF6aW5nIGxpYiFcbiAqIHNsaWdodGx5IG1vZGlmaWVkIGJ5IE1hdCBHcm92ZXMgKG1hdGdyb3Zlcy5jb20pO1xuICogQGNsYXNzIFBvbHlLXG4gKlxuICovXG5QSVhJLlBvbHlLID0ge307XG5cbi8qKlxuICogVHJpYW5ndWxhdGVzIHNoYXBlcyBmb3Igd2ViR0wgZ3JhcGhpYyBmaWxsc1xuICpcbiAqIEBtZXRob2QgVHJpYW5ndWxhdGVcbiAqIFxuICovXG5QSVhJLlBvbHlLLlRyaWFuZ3VsYXRlID0gZnVuY3Rpb24ocClcbntcbiAgICB2YXIgc2lnbiA9IHRydWU7XG5cbiAgICB2YXIgbiA9IHAubGVuZ3RoID4+IDE7XG4gICAgaWYobiA8IDMpIHJldHVybiBbXTtcblxuICAgIHZhciB0Z3MgPSBbXTtcbiAgICB2YXIgYXZsID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG47IGkrKykgYXZsLnB1c2goaSk7XG5cbiAgICBpID0gMDtcbiAgICB2YXIgYWwgPSBuO1xuICAgIHdoaWxlKGFsID4gMylcbiAgICB7XG4gICAgICAgIHZhciBpMCA9IGF2bFsoaSswKSVhbF07XG4gICAgICAgIHZhciBpMSA9IGF2bFsoaSsxKSVhbF07XG4gICAgICAgIHZhciBpMiA9IGF2bFsoaSsyKSVhbF07XG5cbiAgICAgICAgdmFyIGF4ID0gcFsyKmkwXSwgIGF5ID0gcFsyKmkwKzFdO1xuICAgICAgICB2YXIgYnggPSBwWzIqaTFdLCAgYnkgPSBwWzIqaTErMV07XG4gICAgICAgIHZhciBjeCA9IHBbMippMl0sICBjeSA9IHBbMippMisxXTtcblxuICAgICAgICB2YXIgZWFyRm91bmQgPSBmYWxzZTtcbiAgICAgICAgaWYoUElYSS5Qb2x5Sy5fY29udmV4KGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHNpZ24pKVxuICAgICAgICB7XG4gICAgICAgICAgICBlYXJGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgYWw7IGorKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgdmkgPSBhdmxbal07XG4gICAgICAgICAgICAgICAgaWYodmkgPT09IGkwIHx8IHZpID09PSBpMSB8fCB2aSA9PT0gaTIpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgaWYoUElYSS5Qb2x5Sy5fUG9pbnRJblRyaWFuZ2xlKHBbMip2aV0sIHBbMip2aSsxXSwgYXgsIGF5LCBieCwgYnksIGN4LCBjeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWFyRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoZWFyRm91bmQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRncy5wdXNoKGkwLCBpMSwgaTIpO1xuICAgICAgICAgICAgYXZsLnNwbGljZSgoaSsxKSVhbCwgMSk7XG4gICAgICAgICAgICBhbC0tO1xuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihpKysgPiAzKmFsKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBuZWVkIHRvIGZsaXAgZmxpcCByZXZlcnNlIGl0IVxuICAgICAgICAgICAgLy8gcmVzZXQhXG4gICAgICAgICAgICBpZihzaWduKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRncyA9IFtdO1xuICAgICAgICAgICAgICAgIGF2bCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IG47IGkrKykgYXZsLnB1c2goaSk7XG5cbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBhbCA9IG47XG5cbiAgICAgICAgICAgICAgICBzaWduID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKFwiUElYSSBXYXJuaW5nOiBzaGFwZSB0b28gY29tcGxleCB0byBmaWxsXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRncy5wdXNoKGF2bFswXSwgYXZsWzFdLCBhdmxbMl0pO1xuICAgIHJldHVybiB0Z3M7XG59O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgcG9pbnQgaXMgd2l0aGluIGEgdHJpYW5nbGVcbiAqXG4gKiBAbWV0aG9kIF9Qb2ludEluVHJpYW5nbGVcbiAqIEBwYXJhbSBweCB7TnVtYmVyfSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAqIEBwYXJhbSBweSB7TnVtYmVyfSB5IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAqIEBwYXJhbSBheCB7TnVtYmVyfSB4IGNvb3JkaW5hdGUgb2YgdGhlIGEgcG9pbnQgb2YgdGhlIHRyaWFuZ2xlXG4gKiBAcGFyYW0gYXkge051bWJlcn0geSBjb29yZGluYXRlIG9mIHRoZSBhIHBvaW50IG9mIHRoZSB0cmlhbmdsZVxuICogQHBhcmFtIGJ4IHtOdW1iZXJ9IHggY29vcmRpbmF0ZSBvZiB0aGUgYiBwb2ludCBvZiB0aGUgdHJpYW5nbGVcbiAqIEBwYXJhbSBieSB7TnVtYmVyfSB5IGNvb3JkaW5hdGUgb2YgdGhlIGIgcG9pbnQgb2YgdGhlIHRyaWFuZ2xlXG4gKiBAcGFyYW0gY3gge051bWJlcn0geCBjb29yZGluYXRlIG9mIHRoZSBjIHBvaW50IG9mIHRoZSB0cmlhbmdsZVxuICogQHBhcmFtIGN5IHtOdW1iZXJ9IHkgY29vcmRpbmF0ZSBvZiB0aGUgYyBwb2ludCBvZiB0aGUgdHJpYW5nbGVcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuUG9seUsuX1BvaW50SW5UcmlhbmdsZSA9IGZ1bmN0aW9uKHB4LCBweSwgYXgsIGF5LCBieCwgYnksIGN4LCBjeSlcbntcbiAgICB2YXIgdjB4ID0gY3gtYXg7XG4gICAgdmFyIHYweSA9IGN5LWF5O1xuICAgIHZhciB2MXggPSBieC1heDtcbiAgICB2YXIgdjF5ID0gYnktYXk7XG4gICAgdmFyIHYyeCA9IHB4LWF4O1xuICAgIHZhciB2MnkgPSBweS1heTtcblxuICAgIHZhciBkb3QwMCA9IHYweCp2MHgrdjB5KnYweTtcbiAgICB2YXIgZG90MDEgPSB2MHgqdjF4K3YweSp2MXk7XG4gICAgdmFyIGRvdDAyID0gdjB4KnYyeCt2MHkqdjJ5O1xuICAgIHZhciBkb3QxMSA9IHYxeCp2MXgrdjF5KnYxeTtcbiAgICB2YXIgZG90MTIgPSB2MXgqdjJ4K3YxeSp2Mnk7XG5cbiAgICB2YXIgaW52RGVub20gPSAxIC8gKGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxKTtcbiAgICB2YXIgdSA9IChkb3QxMSAqIGRvdDAyIC0gZG90MDEgKiBkb3QxMikgKiBpbnZEZW5vbTtcbiAgICB2YXIgdiA9IChkb3QwMCAqIGRvdDEyIC0gZG90MDEgKiBkb3QwMikgKiBpbnZEZW5vbTtcblxuICAgIC8vIENoZWNrIGlmIHBvaW50IGlzIGluIHRyaWFuZ2xlXG4gICAgcmV0dXJuICh1ID49IDApICYmICh2ID49IDApICYmICh1ICsgdiA8IDEpO1xufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIHNoYXBlIGlzIGNvbnZleFxuICpcbiAqIEBtZXRob2QgX2NvbnZleFxuICogXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlBvbHlLLl9jb252ZXggPSBmdW5jdGlvbihheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBzaWduKVxue1xuICAgIHJldHVybiAoKGF5LWJ5KSooY3gtYngpICsgKGJ4LWF4KSooY3ktYnkpID49IDApID09PSBzaWduO1xufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vLyBUT0RPIEFsdmluIGFuZCBNYXRcbi8vIFNob3VsZCB3ZSBldmVudHVhbGx5IGNyZWF0ZSBhIFV0aWxzIGNsYXNzID8gXG4vLyBPciBqdXN0IG1vdmUgdGhpcyBmaWxlIHRvIHRoZSBwaXhpLmpzIGZpbGUgP1xuUElYSS5pbml0RGVmYXVsdFNoYWRlcnMgPSBmdW5jdGlvbigpXG57XG4gICBcbiAgLy8gIFBJWEkuc3RyaXBTaGFkZXIgPSBuZXcgUElYSS5TdHJpcFNoYWRlcigpO1xuLy8gICAgUElYSS5zdHJpcFNoYWRlci5pbml0KCk7XG5cbn07XG5cblBJWEkuQ29tcGlsZVZlcnRleFNoYWRlciA9IGZ1bmN0aW9uKGdsLCBzaGFkZXJTcmMpXG57XG4gICAgcmV0dXJuIFBJWEkuX0NvbXBpbGVTaGFkZXIoZ2wsIHNoYWRlclNyYywgZ2wuVkVSVEVYX1NIQURFUik7XG59O1xuXG5QSVhJLkNvbXBpbGVGcmFnbWVudFNoYWRlciA9IGZ1bmN0aW9uKGdsLCBzaGFkZXJTcmMpXG57XG4gICAgcmV0dXJuIFBJWEkuX0NvbXBpbGVTaGFkZXIoZ2wsIHNoYWRlclNyYywgZ2wuRlJBR01FTlRfU0hBREVSKTtcbn07XG5cblBJWEkuX0NvbXBpbGVTaGFkZXIgPSBmdW5jdGlvbihnbCwgc2hhZGVyU3JjLCBzaGFkZXJUeXBlKVxue1xuICAgIHZhciBzcmMgPSBzaGFkZXJTcmMuam9pbihcIlxcblwiKTtcbiAgICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHNoYWRlclR5cGUpO1xuICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNyYyk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFkZXI7XG59O1xuXG5QSVhJLmNvbXBpbGVQcm9ncmFtID0gZnVuY3Rpb24oZ2wsIHZlcnRleFNyYywgZnJhZ21lbnRTcmMpXG57XG4gICAgdmFyIGZyYWdtZW50U2hhZGVyID0gUElYSS5Db21waWxlRnJhZ21lbnRTaGFkZXIoZ2wsIGZyYWdtZW50U3JjKTtcbiAgICB2YXIgdmVydGV4U2hhZGVyID0gUElYSS5Db21waWxlVmVydGV4U2hhZGVyKGdsLCB2ZXJ0ZXhTcmMpO1xuXG4gICAgdmFyIHNoYWRlclByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cbiAgICBnbC5hdHRhY2hTaGFkZXIoc2hhZGVyUHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIoc2hhZGVyUHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICAgIGdsLmxpbmtQcm9ncmFtKHNoYWRlclByb2dyYW0pO1xuXG4gICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHNoYWRlclByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coXCJDb3VsZCBub3QgaW5pdGlhbGlzZSBzaGFkZXJzXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFkZXJQcm9ncmFtO1xufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqIEBhdXRob3IgUmljaGFyZCBEYXZleSBodHRwOi8vd3d3LnBob3RvbnN0b3JtLmNvbSBAcGhvdG9uc3Rvcm1cbiAqL1xuXG4vKipcbiogQGNsYXNzIFBpeGlTaGFkZXJcbiogQGNvbnN0cnVjdG9yXG4qL1xuUElYSS5QaXhpU2hhZGVyID0gZnVuY3Rpb24oZ2wpXG57XG4gICAgdGhpcy5fVUlEID0gUElYSS5fVUlEKys7XG4gICAgXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGdsXG4gICAgICogQHR5cGUgV2ViR0xDb250ZXh0XG4gICAgICovXG4gICAgdGhpcy5nbCA9IGdsO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2FueX0gcHJvZ3JhbSAtIFRoZSBXZWJHTCBwcm9ncmFtLlxuICAgICovXG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHthcnJheX0gZnJhZ21lbnRTcmMgLSBUaGUgZnJhZ21lbnQgc2hhZGVyLlxuICAgICovXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcbiAgICAgICAgJ3ByZWNpc2lvbiBsb3dwIGZsb2F0OycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3IgOycsXG4gICAgICAgICd9J1xuICAgIF07XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0ZXh0dXJlQ291bnQgLSBBIGxvY2FsIHRleHR1cmUgY291bnRlciBmb3IgbXVsdGktdGV4dHVyZSBzaGFkZXJzLlxuICAgICovXG4gICAgdGhpcy50ZXh0dXJlQ291bnQgPSAwO1xuXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gW107XG5cbiAgICB0aGlzLmluaXQoKTtcbn07XG5cbi8qKlxuKiBJbml0aWFsaXNlcyB0aGUgc2hhZGVyXG4qIEBtZXRob2QgaW5pdFxuKlxuKi9cblBJWEkuUGl4aVNoYWRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdmFyIHByb2dyYW0gPSBQSVhJLmNvbXBpbGVQcm9ncmFtKGdsLCB0aGlzLnZlcnRleFNyYyB8fCBQSVhJLlBpeGlTaGFkZXIuZGVmYXVsdFZlcnRleFNyYywgdGhpcy5mcmFnbWVudFNyYyk7XG4gICAgXG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcblxuICAgIC8vIGdldCBhbmQgc3RvcmUgdGhlIHVuaWZvcm1zIGZvciB0aGUgc2hhZGVyXG4gICAgdGhpcy51U2FtcGxlciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVNhbXBsZXInKTtcbiAgICB0aGlzLnByb2plY3Rpb25WZWN0b3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Byb2plY3Rpb25WZWN0b3InKTtcbiAgICB0aGlzLm9mZnNldFZlY3RvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnb2Zmc2V0VmVjdG9yJyk7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdkaW1lbnNpb25zJyk7XG5cbiAgICAvLyBnZXQgYW5kIHN0b3JlIHRoZSBhdHRyaWJ1dGVzXG4gICAgdGhpcy5hVmVydGV4UG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVZlcnRleFBvc2l0aW9uJyk7XG4gICAgdGhpcy5hVGV4dHVyZUNvb3JkID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FUZXh0dXJlQ29vcmQnKTtcbiAgICB0aGlzLmNvbG9yQXR0cmlidXRlID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FDb2xvcicpO1xuXG5cbiAgICAvLyBCZWdpbiB3b3JzdCBoYWNrIGV2YSAvL1xuXG4gICAgLy8gV0hZPz8/IE9OTFkgb24gbXkgY2hyb21lIHBpeGVsIHRoZSBsaW5lIGFib3ZlIHJldHVybnMgLTEgd2hlbiB1c2luZyBmaWx0ZXJzP1xuICAgIC8vIG1heWJlIGl0cyBzb21ldGhpbmcgdG8gZG8gd2l0aCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZ2wgY29udGV4dC5cbiAgICAvLyBJbSBjb252aW5jZWQgdGhpcyBpcyBhIGJ1ZyBpbiB0aGUgY2hyb21lIGJyb3dzZXIgYXMgdGhlcmUgaXMgTk8gcmVhc29uIHdoeSB0aGlzIHNob3VsZCBiZSByZXR1cm5pbmcgLTEgZXNwZWNpYWxseSBhcyBpdCBvbmx5IG1hbmlmZXN0cyBvbiBteSBjaHJvbWUgcGl4ZWxcbiAgICAvLyBJZiB0aGVyZXMgYW55IHdlYkdMIHBlb3BsZSB0aGF0IGtub3cgd2h5IGNvdWxkIGhhcHBlbiBwbGVhc2UgaGVscCA6KVxuICAgIGlmKHRoaXMuY29sb3JBdHRyaWJ1dGUgPT09IC0xKVxuICAgIHtcbiAgICAgICAgdGhpcy5jb2xvckF0dHJpYnV0ZSA9IDI7XG4gICAgfVxuXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gW3RoaXMuYVZlcnRleFBvc2l0aW9uLCB0aGlzLmFUZXh0dXJlQ29vcmQsIHRoaXMuY29sb3JBdHRyaWJ1dGVdO1xuXG4gICAgLy8gRW5kIHdvcnN0IGhhY2sgZXZhIC8vXG5cbiAgICAvLyBhZGQgdGhvc2UgY3VzdG9tIHNoYWRlcnMhXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMudW5pZm9ybXMpXG4gICAge1xuICAgICAgICAvLyBnZXQgdGhlIHVuaWZvcm0gbG9jYXRpb25zLi5cbiAgICAgICAgdGhpcy51bmlmb3Jtc1trZXldLnVuaWZvcm1Mb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBrZXkpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdFVuaWZvcm1zKCk7XG5cbiAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xufTtcblxuLyoqXG4qIEluaXRpYWxpc2VzIHRoZSBzaGFkZXIgdW5pZm9ybSB2YWx1ZXMuXG4qIFVuaWZvcm1zIGFyZSBzcGVjaWZpZWQgaW4gdGhlIEdMU0xfRVMgU3BlY2lmaWNhdGlvbjogaHR0cDovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS93ZWJnbC9zcGVjcy9sYXRlc3QvMS4wL1xuKiBodHRwOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L2dsZXMvc3BlY3MvMi4wL0dMU0xfRVNfU3BlY2lmaWNhdGlvbl8xLjAuMTcucGRmXG4qXG4qIEBtZXRob2QgaW5pdFVuaWZvcm1zXG4qL1xuUElYSS5QaXhpU2hhZGVyLnByb3RvdHlwZS5pbml0VW5pZm9ybXMgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy50ZXh0dXJlQ291bnQgPSAxO1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgdmFyIHVuaWZvcm07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy51bmlmb3JtcylcbiAgICB7XG4gICAgICAgIHVuaWZvcm0gPSB0aGlzLnVuaWZvcm1zW2tleV07XG5cbiAgICAgICAgdmFyIHR5cGUgPSB1bmlmb3JtLnR5cGU7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdzYW1wbGVyMkQnKVxuICAgICAgICB7XG4gICAgICAgICAgICB1bmlmb3JtLl9pbml0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICh1bmlmb3JtLnZhbHVlICE9PSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFNhbXBsZXIyRCh1bmlmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnbWF0MicgfHwgdHlwZSA9PT0gJ21hdDMnIHx8IHR5cGUgPT09ICdtYXQ0JylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gIFRoZXNlIHJlcXVpcmUgc3BlY2lhbCBoYW5kbGluZ1xuICAgICAgICAgICAgdW5pZm9ybS5nbE1hdHJpeCA9IHRydWU7XG4gICAgICAgICAgICB1bmlmb3JtLmdsVmFsdWVMZW5ndGggPSAxO1xuXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ21hdDInKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHVuaWZvcm0uZ2xGdW5jID0gZ2wudW5pZm9ybU1hdHJpeDJmdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdtYXQzJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1bmlmb3JtLmdsRnVuYyA9IGdsLnVuaWZvcm1NYXRyaXgzZnY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnbWF0NCcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS5nbEZ1bmMgPSBnbC51bmlmb3JtTWF0cml4NGZ2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gIEdMIGZ1bmN0aW9uIHJlZmVyZW5jZVxuICAgICAgICAgICAgdW5pZm9ybS5nbEZ1bmMgPSBnbFsndW5pZm9ybScgKyB0eXBlXTtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICcyZicgfHwgdHlwZSA9PT0gJzJpJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1bmlmb3JtLmdsVmFsdWVMZW5ndGggPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJzNmJyB8fCB0eXBlID09PSAnM2knKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHVuaWZvcm0uZ2xWYWx1ZUxlbmd0aCA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnNGYnIHx8IHR5cGUgPT09ICc0aScpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS5nbFZhbHVlTGVuZ3RoID0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1bmlmb3JtLmdsVmFsdWVMZW5ndGggPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG4vKipcbiogSW5pdGlhbGlzZXMgYSBTYW1wbGVyMkQgdW5pZm9ybSAod2hpY2ggbWF5IG9ubHkgYmUgYXZhaWxhYmxlIGxhdGVyIG9uIGFmdGVyIGluaXRVbmlmb3JtcyBvbmNlIHRoZSB0ZXh0dXJlIGhhcyBsb2FkZWQpXG4qXG4qIEBtZXRob2QgaW5pdFNhbXBsZXIyRFxuKi9cblBJWEkuUGl4aVNoYWRlci5wcm90b3R5cGUuaW5pdFNhbXBsZXIyRCA9IGZ1bmN0aW9uKHVuaWZvcm0pXG57XG4gICAgaWYgKCF1bmlmb3JtLnZhbHVlIHx8ICF1bmlmb3JtLnZhbHVlLmJhc2VUZXh0dXJlIHx8ICF1bmlmb3JtLnZhbHVlLmJhc2VUZXh0dXJlLmhhc0xvYWRlZClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbFsnVEVYVFVSRScgKyB0aGlzLnRleHR1cmVDb3VudF0pO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHVuaWZvcm0udmFsdWUuYmFzZVRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKTtcblxuICAgIC8vICBFeHRlbmRlZCB0ZXh0dXJlIGRhdGFcbiAgICBpZiAodW5pZm9ybS50ZXh0dXJlRGF0YSlcbiAgICB7XG4gICAgICAgIHZhciBkYXRhID0gdW5pZm9ybS50ZXh0dXJlRGF0YTtcblxuICAgICAgICAvLyBHTFRleHR1cmUgPSBtYWcgbGluZWFyLCBtaW4gbGluZWFyX21pcG1hcF9saW5lYXIsIHdyYXAgcmVwZWF0ICsgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG4gICAgICAgIC8vIEdMVGV4dHVyZUxpbmVhciA9IG1hZy9taW4gbGluZWFyLCB3cmFwIGNsYW1wXG4gICAgICAgIC8vIEdMVGV4dHVyZU5lYXJlc3RSZXBlYXQgPSBtYWcvbWluIE5FQVJFU1QsIHdyYXAgcmVwZWF0XG4gICAgICAgIC8vIEdMVGV4dHVyZU5lYXJlc3QgPSBtYWcvbWluIG5lYXJlc3QsIHdyYXAgY2xhbXBcbiAgICAgICAgLy8gQXVkaW9UZXh0dXJlID0gd2hhdGV2ZXIgKyBsdW1pbmFuY2UgKyB3aWR0aCA1MTIsIGhlaWdodCAyLCBib3JkZXIgMFxuICAgICAgICAvLyBLZXlUZXh0dXJlID0gd2hhdGV2ZXIgKyBsdW1pbmFuY2UgKyB3aWR0aCAyNTYsIGhlaWdodCAyLCBib3JkZXIgMFxuXG4gICAgICAgIC8vICBtYWdGaWx0ZXIgY2FuIGJlOiBnbC5MSU5FQVIsIGdsLkxJTkVBUl9NSVBNQVBfTElORUFSIG9yIGdsLk5FQVJFU1RcbiAgICAgICAgLy8gIHdyYXBTL1QgY2FuIGJlOiBnbC5DTEFNUF9UT19FREdFIG9yIGdsLlJFUEVBVFxuXG4gICAgICAgIHZhciBtYWdGaWx0ZXIgPSAoZGF0YS5tYWdGaWx0ZXIpID8gZGF0YS5tYWdGaWx0ZXIgOiBnbC5MSU5FQVI7XG4gICAgICAgIHZhciBtaW5GaWx0ZXIgPSAoZGF0YS5taW5GaWx0ZXIpID8gZGF0YS5taW5GaWx0ZXIgOiBnbC5MSU5FQVI7XG4gICAgICAgIHZhciB3cmFwUyA9IChkYXRhLndyYXBTKSA/IGRhdGEud3JhcFMgOiBnbC5DTEFNUF9UT19FREdFO1xuICAgICAgICB2YXIgd3JhcFQgPSAoZGF0YS53cmFwVCkgPyBkYXRhLndyYXBUIDogZ2wuQ0xBTVBfVE9fRURHRTtcbiAgICAgICAgdmFyIGZvcm1hdCA9IChkYXRhLmx1bWluYW5jZSkgPyBnbC5MVU1JTkFOQ0UgOiBnbC5SR0JBO1xuXG4gICAgICAgIGlmIChkYXRhLnJlcGVhdClcbiAgICAgICAge1xuICAgICAgICAgICAgd3JhcFMgPSBnbC5SRVBFQVQ7XG4gICAgICAgICAgICB3cmFwVCA9IGdsLlJFUEVBVDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsICEhZGF0YS5mbGlwWSk7XG5cbiAgICAgICAgaWYgKGRhdGEud2lkdGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IChkYXRhLndpZHRoKSA/IGRhdGEud2lkdGggOiA1MTI7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gKGRhdGEuaGVpZ2h0KSA/IGRhdGEuaGVpZ2h0IDogMjtcbiAgICAgICAgICAgIHZhciBib3JkZXIgPSAoZGF0YS5ib3JkZXIpID8gZGF0YS5ib3JkZXIgOiAwO1xuXG4gICAgICAgICAgICAvLyB2b2lkIHRleEltYWdlMkQoR0xlbnVtIHRhcmdldCwgR0xpbnQgbGV2ZWwsIEdMZW51bSBpbnRlcm5hbGZvcm1hdCwgR0xzaXplaSB3aWR0aCwgR0xzaXplaSBoZWlnaHQsIEdMaW50IGJvcmRlciwgR0xlbnVtIGZvcm1hdCwgR0xlbnVtIHR5cGUsIEFycmF5QnVmZmVyVmlldz8gcGl4ZWxzKTtcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBib3JkZXIsIGZvcm1hdCwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgdm9pZCB0ZXhJbWFnZTJEKEdMZW51bSB0YXJnZXQsIEdMaW50IGxldmVsLCBHTGVudW0gaW50ZXJuYWxmb3JtYXQsIEdMZW51bSBmb3JtYXQsIEdMZW51bSB0eXBlLCBJbWFnZURhdGE/IHBpeGVscyk7XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGZvcm1hdCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdW5pZm9ybS52YWx1ZS5iYXNlVGV4dHVyZS5zb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIG1hZ0ZpbHRlcik7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBtaW5GaWx0ZXIpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCB3cmFwUyk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIHdyYXBUKTtcbiAgICB9XG5cbiAgICBnbC51bmlmb3JtMWkodW5pZm9ybS51bmlmb3JtTG9jYXRpb24sIHRoaXMudGV4dHVyZUNvdW50KTtcblxuICAgIHVuaWZvcm0uX2luaXQgPSB0cnVlO1xuXG4gICAgdGhpcy50ZXh0dXJlQ291bnQrKztcblxufTtcblxuLyoqXG4qIFVwZGF0ZXMgdGhlIHNoYWRlciB1bmlmb3JtIHZhbHVlcy5cbipcbiogQG1ldGhvZCBzeW5jVW5pZm9ybXNcbiovXG5QSVhJLlBpeGlTaGFkZXIucHJvdG90eXBlLnN5bmNVbmlmb3JtcyA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLnRleHR1cmVDb3VudCA9IDE7XG4gICAgdmFyIHVuaWZvcm07XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIC8vICBUaGlzIHdvdWxkIHByb2JhYmx5IGJlIGZhc3RlciBpbiBhbiBhcnJheSBhbmQgaXQgd291bGQgZ3VhcmFudGVlIGtleSBvcmRlclxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnVuaWZvcm1zKVxuICAgIHtcbiAgICAgICAgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXNba2V5XTtcblxuICAgICAgICBpZiAodW5pZm9ybS5nbFZhbHVlTGVuZ3RoID09PSAxKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodW5pZm9ybS5nbE1hdHJpeCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1bmlmb3JtLmdsRnVuYy5jYWxsKGdsLCB1bmlmb3JtLnVuaWZvcm1Mb2NhdGlvbiwgdW5pZm9ybS50cmFuc3Bvc2UsIHVuaWZvcm0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHVuaWZvcm0uZ2xGdW5jLmNhbGwoZ2wsIHVuaWZvcm0udW5pZm9ybUxvY2F0aW9uLCB1bmlmb3JtLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1bmlmb3JtLmdsVmFsdWVMZW5ndGggPT09IDIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHVuaWZvcm0uZ2xGdW5jLmNhbGwoZ2wsIHVuaWZvcm0udW5pZm9ybUxvY2F0aW9uLCB1bmlmb3JtLnZhbHVlLngsIHVuaWZvcm0udmFsdWUueSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodW5pZm9ybS5nbFZhbHVlTGVuZ3RoID09PSAzKVxuICAgICAgICB7XG4gICAgICAgICAgICB1bmlmb3JtLmdsRnVuYy5jYWxsKGdsLCB1bmlmb3JtLnVuaWZvcm1Mb2NhdGlvbiwgdW5pZm9ybS52YWx1ZS54LCB1bmlmb3JtLnZhbHVlLnksIHVuaWZvcm0udmFsdWUueik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodW5pZm9ybS5nbFZhbHVlTGVuZ3RoID09PSA0KVxuICAgICAgICB7XG4gICAgICAgICAgICB1bmlmb3JtLmdsRnVuYy5jYWxsKGdsLCB1bmlmb3JtLnVuaWZvcm1Mb2NhdGlvbiwgdW5pZm9ybS52YWx1ZS54LCB1bmlmb3JtLnZhbHVlLnksIHVuaWZvcm0udmFsdWUueiwgdW5pZm9ybS52YWx1ZS53KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1bmlmb3JtLnR5cGUgPT09ICdzYW1wbGVyMkQnKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodW5pZm9ybS5faW5pdClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsWydURVhUVVJFJyArIHRoaXMudGV4dHVyZUNvdW50XSk7XG4gICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdW5pZm9ybS52YWx1ZS5iYXNlVGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0gfHwgUElYSS5jcmVhdGVXZWJHTFRleHR1cmUoIHVuaWZvcm0udmFsdWUuYmFzZVRleHR1cmUsIGdsKSk7XG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFpKHVuaWZvcm0udW5pZm9ybUxvY2F0aW9uLCB0aGlzLnRleHR1cmVDb3VudCk7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRTYW1wbGVyMkQodW5pZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbi8qKlxuKiBEZXN0cm95cyB0aGUgc2hhZGVyXG4qIEBtZXRob2QgZGVzdHJveVxuKi9cblBJWEkuUGl4aVNoYWRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmdsLmRlbGV0ZVByb2dyYW0oIHRoaXMucHJvZ3JhbSApO1xuICAgIHRoaXMudW5pZm9ybXMgPSBudWxsO1xuICAgIHRoaXMuZ2wgPSBudWxsO1xuXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gbnVsbDtcbn07XG5cbi8qKlxuKiBUaGUgRGVmYXVsdCBWZXJ0ZXggc2hhZGVyIHNvdXJjZVxuKiBAcHJvcGVydHkgZGVmYXVsdFZlcnRleFNyY1xuKiBAdHlwZSBTdHJpbmdcbiovXG5QSVhJLlBpeGlTaGFkZXIuZGVmYXVsdFZlcnRleFNyYyA9IFtcbiAgICAnYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uOycsXG4gICAgJ2F0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7JyxcbiAgICAnYXR0cmlidXRlIHZlYzIgYUNvbG9yOycsXG5cbiAgICAndW5pZm9ybSB2ZWMyIHByb2plY3Rpb25WZWN0b3I7JyxcbiAgICAndW5pZm9ybSB2ZWMyIG9mZnNldFZlY3RvcjsnLFxuXG4gICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcblxuICAgICdjb25zdCB2ZWMyIGNlbnRlciA9IHZlYzIoLTEuMCwgMS4wKTsnLFxuXG4gICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAnICAgZ2xfUG9zaXRpb24gPSB2ZWM0KCAoKGFWZXJ0ZXhQb3NpdGlvbiArIG9mZnNldFZlY3RvcikgLyBwcm9qZWN0aW9uVmVjdG9yKSArIGNlbnRlciAsIDAuMCwgMS4wKTsnLFxuICAgICcgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDsnLFxuICAgICcgICB2ZWMzIGNvbG9yID0gbW9kKHZlYzMoYUNvbG9yLnkvNjU1MzYuMCwgYUNvbG9yLnkvMjU2LjAsIGFDb2xvci55KSwgMjU2LjApIC8gMjU2LjA7JyxcbiAgICAnICAgdkNvbG9yID0gdmVjNChjb2xvciAqIGFDb2xvci54LCBhQ29sb3IueCk7JyxcbiAgICAnfSdcbl07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKiBAYXV0aG9yIFJpY2hhcmQgRGF2ZXkgaHR0cDovL3d3dy5waG90b25zdG9ybS5jb20gQHBob3RvbnN0b3JtXG4gKi9cblxuLyoqXG4qIEBjbGFzcyBQaXhpRmFzdFNoYWRlclxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIGdsIHtXZWJHTENvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuKi9cblBJWEkuUGl4aUZhc3RTaGFkZXIgPSBmdW5jdGlvbihnbClcbntcbiAgICB0aGlzLl9VSUQgPSBQSVhJLl9VSUQrKztcbiAgICBcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZ2xcbiAgICAgKiBAdHlwZSBXZWJHTENvbnRleHRcbiAgICAgKi9cbiAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2FueX0gcHJvZ3JhbSAtIFRoZSBXZWJHTCBwcm9ncmFtLlxuICAgICAqL1xuICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSBmcmFnbWVudFNyYyAtIFRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAgICovXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcbiAgICAgICAgJ3ByZWNpc2lvbiBsb3dwIGZsb2F0OycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICAgICAndmFyeWluZyBmbG9hdCB2Q29sb3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG4gICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdkNvbG9yIDsnLFxuICAgICAgICAnfSdcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2FycmF5fSB2ZXJ0ZXhTcmMgLSBUaGUgdmVydGV4IHNoYWRlclxuICAgICovXG4gICAgdGhpcy52ZXJ0ZXhTcmMgPSBbXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247JyxcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbkNvb3JkOycsXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhU2NhbGU7JyxcbiAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhUm90YXRpb247JyxcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhQ29sb3I7JyxcblxuICAgICAgICAndW5pZm9ybSB2ZWMyIHByb2plY3Rpb25WZWN0b3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiBvZmZzZXRWZWN0b3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gbWF0MyB1TWF0cml4OycsXG5cbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgICAgICd2YXJ5aW5nIGZsb2F0IHZDb2xvcjsnLFxuXG4gICAgICAgICdjb25zdCB2ZWMyIGNlbnRlciA9IHZlYzIoLTEuMCwgMS4wKTsnLFxuXG4gICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICcgICB2ZWMyIHY7JyxcbiAgICAgICAgJyAgIHZlYzIgc3YgPSBhVmVydGV4UG9zaXRpb24gKiBhU2NhbGU7JyxcbiAgICAgICAgJyAgIHYueCA9IChzdi54KSAqIGNvcyhhUm90YXRpb24pIC0gKHN2LnkpICogc2luKGFSb3RhdGlvbik7JyxcbiAgICAgICAgJyAgIHYueSA9IChzdi54KSAqIHNpbihhUm90YXRpb24pICsgKHN2LnkpICogY29zKGFSb3RhdGlvbik7JyxcbiAgICAgICAgJyAgIHYgPSAoIHVNYXRyaXggKiB2ZWMzKHYgKyBhUG9zaXRpb25Db29yZCAsIDEuMCkgKS54eSA7JyxcbiAgICAgICAgJyAgIGdsX1Bvc2l0aW9uID0gdmVjNCggKCB2IC8gcHJvamVjdGlvblZlY3RvcikgKyBjZW50ZXIgLCAwLjAsIDEuMCk7JyxcbiAgICAgICAgJyAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkOycsXG4gICAgICAvLyAgJyAgIHZlYzMgY29sb3IgPSBtb2QodmVjMyhhQ29sb3IueS82NTUzNi4wLCBhQ29sb3IueS8yNTYuMCwgYUNvbG9yLnkpLCAyNTYuMCkgLyAyNTYuMDsnLFxuICAgICAgICAnICAgdkNvbG9yID0gYUNvbG9yOycsXG4gICAgICAgICd9J1xuICAgIF07XG5cblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRleHR1cmVDb3VudCAtIEEgbG9jYWwgdGV4dHVyZSBjb3VudGVyIGZvciBtdWx0aS10ZXh0dXJlIHNoYWRlcnMuXG4gICAgKi9cbiAgICB0aGlzLnRleHR1cmVDb3VudCA9IDA7XG5cbiAgICBcbiAgICB0aGlzLmluaXQoKTtcbn07XG5cbi8qKlxuKiBJbml0aWFsaXNlcyB0aGUgc2hhZGVyXG4qIEBtZXRob2QgaW5pdFxuKlxuKi9cblBJWEkuUGl4aUZhc3RTaGFkZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpXG57XG5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdmFyIHByb2dyYW0gPSBQSVhJLmNvbXBpbGVQcm9ncmFtKGdsLCB0aGlzLnZlcnRleFNyYywgdGhpcy5mcmFnbWVudFNyYyk7XG4gICAgXG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcblxuICAgIC8vIGdldCBhbmQgc3RvcmUgdGhlIHVuaWZvcm1zIGZvciB0aGUgc2hhZGVyXG4gICAgdGhpcy51U2FtcGxlciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVNhbXBsZXInKTtcblxuICAgIHRoaXMucHJvamVjdGlvblZlY3RvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAncHJvamVjdGlvblZlY3RvcicpO1xuICAgIHRoaXMub2Zmc2V0VmVjdG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdvZmZzZXRWZWN0b3InKTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ2RpbWVuc2lvbnMnKTtcbiAgICB0aGlzLnVNYXRyaXggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VNYXRyaXgnKTtcblxuICAgIC8vIGdldCBhbmQgc3RvcmUgdGhlIGF0dHJpYnV0ZXNcbiAgICB0aGlzLmFWZXJ0ZXhQb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhVmVydGV4UG9zaXRpb24nKTtcbiAgICB0aGlzLmFQb3NpdGlvbkNvb3JkID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FQb3NpdGlvbkNvb3JkJyk7XG5cbiAgICB0aGlzLmFTY2FsZSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhU2NhbGUnKTtcbiAgICB0aGlzLmFSb3RhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhUm90YXRpb24nKTtcblxuICAgIHRoaXMuYVRleHR1cmVDb29yZCA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhVGV4dHVyZUNvb3JkJyk7XG4gICAgdGhpcy5jb2xvckF0dHJpYnV0ZSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhQ29sb3InKTtcbiAgIFxuXG4gICBcbiAgICAvLyBCZWdpbiB3b3JzdCBoYWNrIGV2YSAvL1xuXG4gICAgLy8gV0hZPz8/IE9OTFkgb24gbXkgY2hyb21lIHBpeGVsIHRoZSBsaW5lIGFib3ZlIHJldHVybnMgLTEgd2hlbiB1c2luZyBmaWx0ZXJzP1xuICAgIC8vIG1heWJlIGl0cyBzb210aGluZyB0byBkbyB3aXRoIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBnbCBjb250ZXh0LlxuICAgIC8vIEltIGNvbnZpbmNlZCB0aGlzIGlzIGEgYnVnIGluIHRoZSBjaHJvbWUgYnJvd3NlciBhcyB0aGVyZSBpcyBOTyByZWFzb24gd2h5IHRoaXMgc2hvdWxkIGJlIHJldHVybmluZyAtMSBlc3BlY2lhbGx5IGFzIGl0IG9ubHkgbWFuaWZlc3RzIG9uIG15IGNocm9tZSBwaXhlbFxuICAgIC8vIElmIHRoZXJlcyBhbnkgd2ViR0wgcGVvcGxlIHRoYXQga25vdyB3aHkgY291bGQgaGFwcGVuIHBsZWFzZSBoZWxwIDopXG4gICAgaWYodGhpcy5jb2xvckF0dHJpYnV0ZSA9PT0gLTEpXG4gICAge1xuICAgICAgICB0aGlzLmNvbG9yQXR0cmlidXRlID0gMjtcbiAgICB9XG5cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbdGhpcy5hVmVydGV4UG9zaXRpb24sIHRoaXMuYVBvc2l0aW9uQ29vcmQsICB0aGlzLmFTY2FsZSwgdGhpcy5hUm90YXRpb24sIHRoaXMuYVRleHR1cmVDb29yZCwgdGhpcy5jb2xvckF0dHJpYnV0ZV07XG4gICAgXG4gICAgLy8gRW5kIHdvcnN0IGhhY2sgZXZhIC8vXG5cblxuICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG59O1xuXG4vKipcbiogRGVzdHJveXMgdGhlIHNoYWRlclxuKiBAbWV0aG9kIGRlc3Ryb3lcbipcbiovXG5QSVhJLlBpeGlGYXN0U2hhZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbSggdGhpcy5wcm9ncmFtICk7XG4gICAgdGhpcy51bmlmb3JtcyA9IG51bGw7XG4gICAgdGhpcy5nbCA9IG51bGw7XG5cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBudWxsO1xufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG5cblBJWEkuU3RyaXBTaGFkZXIgPSBmdW5jdGlvbihnbClcbntcbiAgICB0aGlzLl9VSUQgPSBQSVhJLl9VSUQrKztcbiAgICBcbiAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7YW55fSBwcm9ncmFtIC0gVGhlIFdlYkdMIHByb2dyYW0uXG4gICAgKi9cbiAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gZnJhZ21lbnRTcmMgLSBUaGUgZnJhZ21lbnQgc2hhZGVyLlxuICAgICAqL1xuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBbXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgLy8gICAndmFyeWluZyBmbG9hdCB2Q29sb3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgYWxwaGE7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLngsIHZUZXh0dXJlQ29vcmQueSkpOycsXG4gICAgICAvLyAgJyAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAwLjAsIDAuMCwgMS4wKTsnLC8vZ2xfRnJhZ0NvbG9yICogYWxwaGE7JyxcbiAgICAgICAgJ30nXG4gICAgXTtcblxuICAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IGZyYWdtZW50U3JjIC0gVGhlIGZyYWdtZW50IHNoYWRlci5cbiAgICAqL1xuICAgIHRoaXMudmVydGV4U3JjICA9IFtcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjsnLFxuICAgICAgICAnYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDsnLFxuICAgICAgICAndW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4OycsXG4gICAgICAgICd1bmlmb3JtIHZlYzIgcHJvamVjdGlvblZlY3RvcjsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMyIG9mZnNldFZlY3RvcjsnLFxuICAgICAgLy8gICd1bmlmb3JtIGZsb2F0IGFscGhhOycsXG4gICAgICAgLy8gJ3VuaWZvcm0gdmVjMyB0aW50OycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICAgLy8gICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIHZlYzMgdiA9IHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24gLCAxLjApOycsXG4gICAgICAgICcgICB2IC09IG9mZnNldFZlY3Rvci54eXg7JyxcbiAgICAgICAgJyAgIGdsX1Bvc2l0aW9uID0gdmVjNCggdi54IC8gcHJvamVjdGlvblZlY3Rvci54IC0xLjAsIHYueSAvIC1wcm9qZWN0aW9uVmVjdG9yLnkgKyAxLjAgLCAwLjAsIDEuMCk7JyxcbiAgICAgICAgJyAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkOycsXG4gICAgICAgLy8gJyAgIHZDb2xvciA9IGFDb2xvciAqIHZlYzQodGludCAqIGFscGhhLCBhbHBoYSk7JyxcbiAgICAgICAgJ30nXG4gICAgXTtcblxuICAgIHRoaXMuaW5pdCgpO1xufTtcblxuLyoqXG4qIEluaXRpYWxpc2VzIHRoZSBzaGFkZXJcbiogQG1ldGhvZCBpbml0XG4qXG4qL1xuUElYSS5TdHJpcFNoYWRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdmFyIHByb2dyYW0gPSBQSVhJLmNvbXBpbGVQcm9ncmFtKGdsLCB0aGlzLnZlcnRleFNyYywgdGhpcy5mcmFnbWVudFNyYyk7XG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcblxuICAgIC8vIGdldCBhbmQgc3RvcmUgdGhlIHVuaWZvcm1zIGZvciB0aGUgc2hhZGVyXG4gICAgdGhpcy51U2FtcGxlciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVNhbXBsZXInKTtcbiAgICB0aGlzLnByb2plY3Rpb25WZWN0b3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Byb2plY3Rpb25WZWN0b3InKTtcbiAgICB0aGlzLm9mZnNldFZlY3RvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnb2Zmc2V0VmVjdG9yJyk7XG4gICAgdGhpcy5jb2xvckF0dHJpYnV0ZSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhQ29sb3InKTtcbiAgICAvL3RoaXMuZGltZW5zaW9ucyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sICdkaW1lbnNpb25zJyk7XG5cbiAgICAvLyBnZXQgYW5kIHN0b3JlIHRoZSBhdHRyaWJ1dGVzXG4gICAgdGhpcy5hVmVydGV4UG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVZlcnRleFBvc2l0aW9uJyk7XG4gICAgdGhpcy5hVGV4dHVyZUNvb3JkID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FUZXh0dXJlQ29vcmQnKTtcblxuICAgIHRoaXMuYXR0cmlidXRlcyA9IFt0aGlzLmFWZXJ0ZXhQb3NpdGlvbiwgdGhpcy5hVGV4dHVyZUNvb3JkXTtcblxuICAgIHRoaXMudHJhbnNsYXRpb25NYXRyaXggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3RyYW5zbGF0aW9uTWF0cml4Jyk7XG4gICAgdGhpcy5hbHBoYSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnYWxwaGEnKTtcblxuICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuKiBAY2xhc3MgUHJpbWl0aXZlU2hhZGVyXG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0gZ2wge1dlYkdMQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4qL1xuUElYSS5QcmltaXRpdmVTaGFkZXIgPSBmdW5jdGlvbihnbClcbntcbiAgICB0aGlzLl9VSUQgPSBQSVhJLl9VSUQrKztcbiBcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZ2xcbiAgICAgKiBAdHlwZSBXZWJHTENvbnRleHRcbiAgICAgKi9cbiAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7YW55fSBwcm9ncmFtIC0gVGhlIFdlYkdMIHByb2dyYW0uXG4gICAgKi9cbiAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGZyYWdtZW50U3JjXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICB0aGlzLmZyYWdtZW50U3JjID0gW1xuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gdkNvbG9yOycsXG4gICAgICAgICd9J1xuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgdmVydGV4U3JjXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICB0aGlzLnZlcnRleFNyYyAgPSBbXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247JyxcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWM0IGFDb2xvcjsnLFxuICAgICAgICAndW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4OycsXG4gICAgICAgICd1bmlmb3JtIHZlYzIgcHJvamVjdGlvblZlY3RvcjsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMyIG9mZnNldFZlY3RvcjsnLFxuICAgICAgICAndW5pZm9ybSBmbG9hdCBhbHBoYTsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMzIHRpbnQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgdmVjMyB2ID0gdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiAsIDEuMCk7JyxcbiAgICAgICAgJyAgIHYgLT0gb2Zmc2V0VmVjdG9yLnh5eDsnLFxuICAgICAgICAnICAgZ2xfUG9zaXRpb24gPSB2ZWM0KCB2LnggLyBwcm9qZWN0aW9uVmVjdG9yLnggLTEuMCwgdi55IC8gLXByb2plY3Rpb25WZWN0b3IueSArIDEuMCAsIDAuMCwgMS4wKTsnLFxuICAgICAgICAnICAgdkNvbG9yID0gYUNvbG9yICogdmVjNCh0aW50ICogYWxwaGEsIGFscGhhKTsnLFxuICAgICAgICAnfSdcbiAgICBdO1xuXG4gICAgdGhpcy5pbml0KCk7XG59O1xuXG4vKipcbiogSW5pdGlhbGlzZXMgdGhlIHNoYWRlclxuKiBAbWV0aG9kIGluaXRcbipcbiovXG5QSVhJLlByaW1pdGl2ZVNoYWRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKClcbntcblxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICB2YXIgcHJvZ3JhbSA9IFBJWEkuY29tcGlsZVByb2dyYW0oZ2wsIHRoaXMudmVydGV4U3JjLCB0aGlzLmZyYWdtZW50U3JjKTtcbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgLy8gZ2V0IGFuZCBzdG9yZSB0aGUgdW5pZm9ybXMgZm9yIHRoZSBzaGFkZXJcbiAgICB0aGlzLnByb2plY3Rpb25WZWN0b3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Byb2plY3Rpb25WZWN0b3InKTtcbiAgICB0aGlzLm9mZnNldFZlY3RvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnb2Zmc2V0VmVjdG9yJyk7XG4gICAgdGhpcy50aW50Q29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3RpbnQnKTtcblxuXG4gICAgLy8gZ2V0IGFuZCBzdG9yZSB0aGUgYXR0cmlidXRlc1xuICAgIHRoaXMuYVZlcnRleFBvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FWZXJ0ZXhQb3NpdGlvbicpO1xuICAgIHRoaXMuY29sb3JBdHRyaWJ1dGUgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYUNvbG9yJyk7XG5cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbdGhpcy5hVmVydGV4UG9zaXRpb24sIHRoaXMuY29sb3JBdHRyaWJ1dGVdO1xuXG4gICAgdGhpcy50cmFuc2xhdGlvbk1hdHJpeCA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndHJhbnNsYXRpb25NYXRyaXgnKTtcbiAgICB0aGlzLmFscGhhID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdhbHBoYScpO1xuXG4gICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbn07XG5cbi8qKlxuKiBEZXN0cm95cyB0aGUgc2hhZGVyXG4qIEBtZXRob2QgZGVzdHJveVxuKlxuKi9cblBJWEkuUHJpbWl0aXZlU2hhZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbSggdGhpcy5wcm9ncmFtICk7XG4gICAgdGhpcy51bmlmb3JtcyA9IG51bGw7XG4gICAgdGhpcy5nbCA9IG51bGw7XG5cbiAgICB0aGlzLmF0dHJpYnV0ZSA9IG51bGw7XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuKiBAY2xhc3MgQ29tcGxleFByaW1pdGl2ZVNoYWRlclxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIGdsIHtXZWJHTENvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuKi9cblBJWEkuQ29tcGxleFByaW1pdGl2ZVNoYWRlciA9IGZ1bmN0aW9uKGdsKVxue1xuICAgIHRoaXMuX1VJRCA9IFBJWEkuX1VJRCsrO1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBnbFxuICAgICAqIEB0eXBlIFdlYkdMQ29udGV4dFxuICAgICAqL1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHthbnl9IHByb2dyYW0gLSBUaGUgV2ViR0wgcHJvZ3JhbS5cbiAgICAqL1xuICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZnJhZ21lbnRTcmNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBbXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuICAgICAgICBcblxuXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHZDb2xvcjsnLFxuICAgICAgICAnfSdcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHZlcnRleFNyY1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgdGhpcy52ZXJ0ZXhTcmMgID0gW1xuICAgICAgICAnYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uOycsXG4gICAgICAgIC8vJ2F0dHJpYnV0ZSB2ZWM0IGFDb2xvcjsnLFxuICAgICAgICAndW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4OycsXG4gICAgICAgICd1bmlmb3JtIHZlYzIgcHJvamVjdGlvblZlY3RvcjsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMyIG9mZnNldFZlY3RvcjsnLFxuICAgICAgICBcbiAgICAgICAgJ3VuaWZvcm0gdmVjMyB0aW50OycsXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IGFscGhhOycsXG4gICAgICAgICd1bmlmb3JtIHZlYzMgY29sb3I7JyxcblxuICAgICAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxuXG4gICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICcgICB2ZWMzIHYgPSB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uICwgMS4wKTsnLFxuICAgICAgICAnICAgdiAtPSBvZmZzZXRWZWN0b3IueHl4OycsXG4gICAgICAgICcgICBnbF9Qb3NpdGlvbiA9IHZlYzQoIHYueCAvIHByb2plY3Rpb25WZWN0b3IueCAtMS4wLCB2LnkgLyAtcHJvamVjdGlvblZlY3Rvci55ICsgMS4wICwgMC4wLCAxLjApOycsXG4gICAgICAgICcgICB2Q29sb3IgPSB2ZWM0KGNvbG9yICogYWxwaGEgKiB0aW50LCBhbHBoYSk7JywvL1wiICogdmVjNCh0aW50ICogYWxwaGEsIGFscGhhKTsnLFxuICAgICAgICAnfSdcbiAgICBdO1xuXG4gICAgdGhpcy5pbml0KCk7XG59O1xuXG4vKipcbiogSW5pdGlhbGlzZXMgdGhlIHNoYWRlclxuKiBAbWV0aG9kIGluaXRcbipcbiovXG5QSVhJLkNvbXBsZXhQcmltaXRpdmVTaGFkZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpXG57XG5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdmFyIHByb2dyYW0gPSBQSVhJLmNvbXBpbGVQcm9ncmFtKGdsLCB0aGlzLnZlcnRleFNyYywgdGhpcy5mcmFnbWVudFNyYyk7XG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcblxuICAgIC8vIGdldCBhbmQgc3RvcmUgdGhlIHVuaWZvcm1zIGZvciB0aGUgc2hhZGVyXG4gICAgdGhpcy5wcm9qZWN0aW9uVmVjdG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdwcm9qZWN0aW9uVmVjdG9yJyk7XG4gICAgdGhpcy5vZmZzZXRWZWN0b3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ29mZnNldFZlY3RvcicpO1xuICAgIHRoaXMudGludENvbG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd0aW50Jyk7XG4gICAgdGhpcy5jb2xvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnY29sb3InKTtcblxuXG4gICAgLy8gZ2V0IGFuZCBzdG9yZSB0aGUgYXR0cmlidXRlc1xuICAgIHRoaXMuYVZlcnRleFBvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FWZXJ0ZXhQb3NpdGlvbicpO1xuICAgLy8gdGhpcy5jb2xvckF0dHJpYnV0ZSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhQ29sb3InKTtcblxuICAgIHRoaXMuYXR0cmlidXRlcyA9IFt0aGlzLmFWZXJ0ZXhQb3NpdGlvbiwgdGhpcy5jb2xvckF0dHJpYnV0ZV07XG5cbiAgICB0aGlzLnRyYW5zbGF0aW9uTWF0cml4ID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd0cmFuc2xhdGlvbk1hdHJpeCcpO1xuICAgIHRoaXMuYWxwaGEgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ2FscGhhJyk7XG5cbiAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xufTtcblxuLyoqXG4qIERlc3Ryb3lzIHRoZSBzaGFkZXJcbiogQG1ldGhvZCBkZXN0cm95XG4qXG4qL1xuUElYSS5Db21wbGV4UHJpbWl0aXZlU2hhZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbSggdGhpcy5wcm9ncmFtICk7XG4gICAgdGhpcy51bmlmb3JtcyA9IG51bGw7XG4gICAgdGhpcy5nbCA9IG51bGw7XG5cbiAgICB0aGlzLmF0dHJpYnV0ZSA9IG51bGw7XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogQSBzZXQgb2YgZnVuY3Rpb25zIHVzZWQgYnkgdGhlIHdlYkdMIHJlbmRlcmVyIHRvIGRyYXcgdGhlIHByaW1pdGl2ZSBncmFwaGljcyBkYXRhXG4gKlxuICogQGNsYXNzIFdlYkdMR3JhcGhpY3NcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKi9cblBJWEkuV2ViR0xHcmFwaGljcyA9IGZ1bmN0aW9uKClcbntcblxufTtcblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBncmFwaGljcyBvYmplY3RcbiAqXG4gKiBAc3RhdGljXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCByZW5kZXJHcmFwaGljc1xuICogQHBhcmFtIGdyYXBoaWNzIHtHcmFwaGljc31cbiAqIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtPYmplY3R9XG4gKi9cblBJWEkuV2ViR0xHcmFwaGljcy5yZW5kZXJHcmFwaGljcyA9IGZ1bmN0aW9uKGdyYXBoaWNzLCByZW5kZXJTZXNzaW9uKS8vcHJvamVjdGlvbiwgb2Zmc2V0KVxue1xuICAgIHZhciBnbCA9IHJlbmRlclNlc3Npb24uZ2w7XG4gICAgdmFyIHByb2plY3Rpb24gPSByZW5kZXJTZXNzaW9uLnByb2plY3Rpb24sXG4gICAgICAgIG9mZnNldCA9IHJlbmRlclNlc3Npb24ub2Zmc2V0LFxuICAgICAgICBzaGFkZXIgPSByZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIucHJpbWl0aXZlU2hhZGVyLFxuICAgICAgICB3ZWJHTERhdGE7XG5cbiAgICBpZihncmFwaGljcy5kaXJ0eSlcbiAgICB7XG4gICAgICAgIFBJWEkuV2ViR0xHcmFwaGljcy51cGRhdGVHcmFwaGljcyhncmFwaGljcywgZ2wpO1xuICAgIH1cblxuICAgIHZhciB3ZWJHTCA9IGdyYXBoaWNzLl93ZWJHTFtnbC5pZF07XG5cbiAgICAvLyBUaGlzICBjb3VsZCBiZSBzcGVlZGVkIHVwIGZvciBzdXJlIVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3ZWJHTC5kYXRhLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgaWYod2ViR0wuZGF0YVtpXS5tb2RlID09PSAxKVxuICAgICAgICB7XG4gICAgICAgICAgICB3ZWJHTERhdGEgPSB3ZWJHTC5kYXRhW2ldO1xuXG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLnN0ZW5jaWxNYW5hZ2VyLnB1c2hTdGVuY2lsKGdyYXBoaWNzLCB3ZWJHTERhdGEsIHJlbmRlclNlc3Npb24pO1xuXG4gICAgICAgICAgICAvLyByZW5kZXIgcXVhZC4uXG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVfRkFOLCA0LCBnbC5VTlNJR05FRF9TSE9SVCwgKCB3ZWJHTERhdGEuaW5kaWNlcy5sZW5ndGggLSA0ICkgKiAyICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24uc3RlbmNpbE1hbmFnZXIucG9wU3RlbmNpbChncmFwaGljcywgd2ViR0xEYXRhLCByZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5sYXN0ID0gd2ViR0xEYXRhLm1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB3ZWJHTERhdGEgPSB3ZWJHTC5kYXRhW2ldO1xuICAgICAgICAgICBcblxuICAgICAgICAgICAgcmVuZGVyU2Vzc2lvbi5zaGFkZXJNYW5hZ2VyLnNldFNoYWRlciggc2hhZGVyICk7Ly9hY3RpdmF0ZVByaW1pdGl2ZVNoYWRlcigpO1xuICAgICAgICAgICAgc2hhZGVyID0gcmVuZGVyU2Vzc2lvbi5zaGFkZXJNYW5hZ2VyLnByaW1pdGl2ZVNoYWRlcjtcbiAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoc2hhZGVyLnRyYW5zbGF0aW9uTWF0cml4LCBmYWxzZSwgZ3JhcGhpY3Mud29ybGRUcmFuc2Zvcm0udG9BcnJheSh0cnVlKSk7XG5cbiAgICAgICAgICAgIGdsLnVuaWZvcm0yZihzaGFkZXIucHJvamVjdGlvblZlY3RvciwgcHJvamVjdGlvbi54LCAtcHJvamVjdGlvbi55KTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0yZihzaGFkZXIub2Zmc2V0VmVjdG9yLCAtb2Zmc2V0LngsIC1vZmZzZXQueSk7XG5cbiAgICAgICAgICAgIGdsLnVuaWZvcm0zZnYoc2hhZGVyLnRpbnRDb2xvciwgUElYSS5oZXgycmdiKGdyYXBoaWNzLnRpbnQpKTtcblxuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci5hbHBoYSwgZ3JhcGhpY3Mud29ybGRBbHBoYSk7XG4gICAgICAgICAgICBcblxuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHdlYkdMRGF0YS5idWZmZXIpO1xuXG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hVmVydGV4UG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgNCAqIDYsIDApO1xuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuY29sb3JBdHRyaWJ1dGUsIDQsIGdsLkZMT0FULCBmYWxzZSw0ICogNiwgMiAqIDQpO1xuXG4gICAgICAgICAgICAvLyBzZXQgdGhlIGluZGV4IGJ1ZmZlciFcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHdlYkdMRGF0YS5pbmRleEJ1ZmZlcik7XG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVfU1RSSVAsICB3ZWJHTERhdGEuaW5kaWNlcy5sZW5ndGgsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGdyYXBoaWNzIG9iamVjdFxuICpcbiAqIEBzdGF0aWNcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIHVwZGF0ZUdyYXBoaWNzXG4gKiBAcGFyYW0gZ3JhcGhpY3NEYXRhIHtHcmFwaGljc30gVGhlIGdyYXBoaWNzIG9iamVjdCB0byB1cGRhdGVcbiAqIEBwYXJhbSBnbCB7V2ViR0xDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiAqL1xuUElYSS5XZWJHTEdyYXBoaWNzLnVwZGF0ZUdyYXBoaWNzID0gZnVuY3Rpb24oZ3JhcGhpY3MsIGdsKVxue1xuICAgIC8vIGdldCB0aGUgY29udGV4dHMgZ3JhcGhpY3Mgb2JqZWN0XG4gICAgdmFyIHdlYkdMID0gZ3JhcGhpY3MuX3dlYkdMW2dsLmlkXTtcbiAgICAvLyBpZiB0aGUgZ3JhcGhpY3Mgb2JqZWN0IGRvZXMgbm90IGV4aXN0IGluIHRoZSB3ZWJHTCBjb250ZXh0IHRpbWUgdG8gY3JlYXRlIGl0IVxuICAgIGlmKCF3ZWJHTCl3ZWJHTCA9IGdyYXBoaWNzLl93ZWJHTFtnbC5pZF0gPSB7bGFzdEluZGV4OjAsIGRhdGE6W10sIGdsOmdsfTtcblxuICAgIC8vIGZsYWcgdGhlIGdyYXBoaWNzIGFzIG5vdCBkaXJ0eSBhcyB3ZSBhcmUgYWJvdXQgdG8gdXBkYXRlIGl0Li4uXG4gICAgZ3JhcGhpY3MuZGlydHkgPSBmYWxzZTtcblxuICAgIHZhciBpO1xuXG4gICAgLy8gaWYgdGhlIHVzZXIgY2xlYXJlZCB0aGUgZ3JhcGhpY3Mgb2JqZWN0IHdlIHdpbGwgbmVlZCB0byBjbGVhciBldmVyeSBvYmplY3RcbiAgICBpZihncmFwaGljcy5jbGVhckRpcnR5KVxuICAgIHtcbiAgICAgICAgZ3JhcGhpY3MuY2xlYXJEaXJ0eSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGxvcCB0aHJvdWdoIGFuZCByZXR1cm4gYWxsIHRoZSB3ZWJHTERhdGFzIHRvIHRoZSBvYmplY3QgcG9vbCBzbyB0aGFuIGNhbiBiZSByZXVzZWQgbGF0ZXIgb25cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHdlYkdMLmRhdGEubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBncmFwaGljc0RhdGEgPSB3ZWJHTC5kYXRhW2ldO1xuICAgICAgICAgICAgZ3JhcGhpY3NEYXRhLnJlc2V0KCk7XG4gICAgICAgICAgICBQSVhJLldlYkdMR3JhcGhpY3MuZ3JhcGhpY3NEYXRhUG9vbC5wdXNoKCBncmFwaGljc0RhdGEgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBhcnJheSBhbmQgcmVzZXQgdGhlIGluZGV4Li4gXG4gICAgICAgIHdlYkdMLmRhdGEgPSBbXTtcbiAgICAgICAgd2ViR0wubGFzdEluZGV4ID0gMDtcbiAgICB9XG5cbiAgICBcbiAgICB2YXIgd2ViR0xEYXRhO1xuICAgIFxuICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgZ3JhcGhpY3MgZGF0YXMgYW5kIGNvbnN0cnVjdCBlYWNoIG9uZS4uXG4gICAgLy8gaWYgdGhlIG9iamVjdCBpcyBhIGNvbXBsZXggZmlsbCB0aGVuIHRoZSBuZXcgc3RlbmNpbCBidWZmZXIgdGVjaG5pcXVlIHdpbGwgYmUgdXNlZFxuICAgIC8vIG90aGVyIHdpc2UgZ3JhcGhpY3Mgb2JqZWN0cyB3aWxsIGJlIHB1c2hlZCBpbnRvIGEgYmF0Y2guLlxuICAgIGZvciAoaSA9IHdlYkdMLmxhc3RJbmRleDsgaSA8IGdyYXBoaWNzLmdyYXBoaWNzRGF0YS5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBkYXRhID0gZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhW2ldO1xuXG4gICAgICAgIGlmKGRhdGEudHlwZSA9PT0gUElYSS5HcmFwaGljcy5QT0xZKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBNQUtFIFNVUkUgV0UgSEFWRSBUSEUgQ09SUkVDVCBUWVBFLi5cbiAgICAgICAgICAgIGlmKGRhdGEuZmlsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZihkYXRhLnBvaW50cy5sZW5ndGggPiA2KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoZGF0YS5wb2ludHMubGVuZ3RoID4gNSAqIDIpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlYkdMRGF0YSA9IFBJWEkuV2ViR0xHcmFwaGljcy5zd2l0Y2hNb2RlKHdlYkdMLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFBJWEkuV2ViR0xHcmFwaGljcy5idWlsZENvbXBsZXhQb2x5KGRhdGEsIHdlYkdMRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWJHTERhdGEgPSBQSVhJLldlYkdMR3JhcGhpY3Muc3dpdGNoTW9kZSh3ZWJHTCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBQSVhJLldlYkdMR3JhcGhpY3MuYnVpbGRQb2x5KGRhdGEsIHdlYkdMRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGRhdGEubGluZVdpZHRoID4gMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB3ZWJHTERhdGEgPSBQSVhJLldlYkdMR3JhcGhpY3Muc3dpdGNoTW9kZSh3ZWJHTCwgMCk7XG4gICAgICAgICAgICAgICAgUElYSS5XZWJHTEdyYXBoaWNzLmJ1aWxkTGluZShkYXRhLCB3ZWJHTERhdGEpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB3ZWJHTERhdGEgPSBQSVhJLldlYkdMR3JhcGhpY3Muc3dpdGNoTW9kZSh3ZWJHTCwgMCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGRhdGEudHlwZSA9PT0gUElYSS5HcmFwaGljcy5SRUNUKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFBJWEkuV2ViR0xHcmFwaGljcy5idWlsZFJlY3RhbmdsZShkYXRhLCB3ZWJHTERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihkYXRhLnR5cGUgPT09IFBJWEkuR3JhcGhpY3MuQ0lSQyB8fCBkYXRhLnR5cGUgPT09IFBJWEkuR3JhcGhpY3MuRUxJUClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBQSVhJLldlYkdMR3JhcGhpY3MuYnVpbGRDaXJjbGUoZGF0YSwgd2ViR0xEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoZGF0YS50eXBlID09PSBQSVhJLkdyYXBoaWNzLlJSRUMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgUElYSS5XZWJHTEdyYXBoaWNzLmJ1aWxkUm91bmRlZFJlY3RhbmdsZShkYXRhLCB3ZWJHTERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICB3ZWJHTC5sYXN0SW5kZXgrKztcbiAgICB9XG5cbiAgICAvLyB1cGxvYWQgYWxsIHRoZSBkaXJ0eSBkYXRhLi4uXG4gICAgZm9yIChpID0gMDsgaSA8IHdlYkdMLmRhdGEubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB3ZWJHTERhdGEgPSB3ZWJHTC5kYXRhW2ldO1xuICAgICAgICBpZih3ZWJHTERhdGEuZGlydHkpd2ViR0xEYXRhLnVwbG9hZCgpO1xuICAgIH1cbn07XG5cblxuUElYSS5XZWJHTEdyYXBoaWNzLnN3aXRjaE1vZGUgPSBmdW5jdGlvbih3ZWJHTCwgdHlwZSlcbntcbiAgICB2YXIgd2ViR0xEYXRhO1xuXG4gICAgaWYoIXdlYkdMLmRhdGEubGVuZ3RoKVxuICAgIHtcbiAgICAgICAgd2ViR0xEYXRhID0gUElYSS5XZWJHTEdyYXBoaWNzLmdyYXBoaWNzRGF0YVBvb2wucG9wKCkgfHwgbmV3IFBJWEkuV2ViR0xHcmFwaGljc0RhdGEod2ViR0wuZ2wpO1xuICAgICAgICB3ZWJHTERhdGEubW9kZSA9IHR5cGU7XG4gICAgICAgIHdlYkdMLmRhdGEucHVzaCh3ZWJHTERhdGEpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB3ZWJHTERhdGEgPSB3ZWJHTC5kYXRhW3dlYkdMLmRhdGEubGVuZ3RoLTFdO1xuXG4gICAgICAgIGlmKHdlYkdMRGF0YS5tb2RlICE9PSB0eXBlIHx8IHR5cGUgPT09IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHdlYkdMRGF0YSA9IFBJWEkuV2ViR0xHcmFwaGljcy5ncmFwaGljc0RhdGFQb29sLnBvcCgpIHx8IG5ldyBQSVhJLldlYkdMR3JhcGhpY3NEYXRhKHdlYkdMLmdsKTtcbiAgICAgICAgICAgIHdlYkdMRGF0YS5tb2RlID0gdHlwZTtcbiAgICAgICAgICAgIHdlYkdMLmRhdGEucHVzaCh3ZWJHTERhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd2ViR0xEYXRhLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHJldHVybiB3ZWJHTERhdGE7XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIHJlY3RhbmdsZSB0byBkcmF3XG4gKlxuICogQHN0YXRpY1xuICogQHByaXZhdGVcbiAqIEBtZXRob2QgYnVpbGRSZWN0YW5nbGVcbiAqIEBwYXJhbSBncmFwaGljc0RhdGEge0dyYXBoaWNzfSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xuICogQHBhcmFtIHdlYkdMRGF0YSB7T2JqZWN0fVxuICovXG5QSVhJLldlYkdMR3JhcGhpY3MuYnVpbGRSZWN0YW5nbGUgPSBmdW5jdGlvbihncmFwaGljc0RhdGEsIHdlYkdMRGF0YSlcbntcbiAgICAvLyAtLS0gLy9cbiAgICAvLyBuZWVkIHRvIGNvbnZlcnQgcG9pbnRzIHRvIGEgbmljZSByZWd1bGFyIGRhdGFcbiAgICAvL1xuICAgIHZhciByZWN0RGF0YSA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG4gICAgdmFyIHggPSByZWN0RGF0YVswXTtcbiAgICB2YXIgeSA9IHJlY3REYXRhWzFdO1xuICAgIHZhciB3aWR0aCA9IHJlY3REYXRhWzJdO1xuICAgIHZhciBoZWlnaHQgPSByZWN0RGF0YVszXTtcblxuXG4gICAgaWYoZ3JhcGhpY3NEYXRhLmZpbGwpXG4gICAge1xuICAgICAgICB2YXIgY29sb3IgPSBQSVhJLmhleDJyZ2IoZ3JhcGhpY3NEYXRhLmZpbGxDb2xvcik7XG4gICAgICAgIHZhciBhbHBoYSA9IGdyYXBoaWNzRGF0YS5maWxsQWxwaGE7XG5cbiAgICAgICAgdmFyIHIgPSBjb2xvclswXSAqIGFscGhhO1xuICAgICAgICB2YXIgZyA9IGNvbG9yWzFdICogYWxwaGE7XG4gICAgICAgIHZhciBiID0gY29sb3JbMl0gKiBhbHBoYTtcblxuICAgICAgICB2YXIgdmVydHMgPSB3ZWJHTERhdGEucG9pbnRzO1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHdlYkdMRGF0YS5pbmRpY2VzO1xuXG4gICAgICAgIHZhciB2ZXJ0UG9zID0gdmVydHMubGVuZ3RoLzY7XG5cbiAgICAgICAgLy8gc3RhcnRcbiAgICAgICAgdmVydHMucHVzaCh4LCB5KTtcbiAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgdmVydHMucHVzaCh4ICsgd2lkdGgsIHkpO1xuICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICB2ZXJ0cy5wdXNoKHggLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgdmVydHMucHVzaCh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAvLyBpbnNlcnQgMiBkZWFkIHRyaWFuZ2xlcy4uXG4gICAgICAgIGluZGljZXMucHVzaCh2ZXJ0UG9zLCB2ZXJ0UG9zLCB2ZXJ0UG9zKzEsIHZlcnRQb3MrMiwgdmVydFBvcyszLCB2ZXJ0UG9zKzMpO1xuICAgIH1cblxuICAgIGlmKGdyYXBoaWNzRGF0YS5saW5lV2lkdGgpXG4gICAge1xuICAgICAgICB2YXIgdGVtcFBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG5cbiAgICAgICAgZ3JhcGhpY3NEYXRhLnBvaW50cyA9IFt4LCB5LFxuICAgICAgICAgICAgICAgICAgeCArIHdpZHRoLCB5LFxuICAgICAgICAgICAgICAgICAgeCArIHdpZHRoLCB5ICsgaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgeCwgeSArIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgIHgsIHldO1xuXG5cbiAgICAgICAgUElYSS5XZWJHTEdyYXBoaWNzLmJ1aWxkTGluZShncmFwaGljc0RhdGEsIHdlYkdMRGF0YSk7XG5cbiAgICAgICAgZ3JhcGhpY3NEYXRhLnBvaW50cyA9IHRlbXBQb2ludHM7XG4gICAgfVxufTtcblxuLyoqXG4gKiBCdWlsZHMgYSByb3VuZGVkIHJlY3RhbmdsZSB0byBkcmF3XG4gKlxuICogQHN0YXRpY1xuICogQHByaXZhdGVcbiAqIEBtZXRob2QgYnVpbGRSb3VuZGVkUmVjdGFuZ2xlXG4gKiBAcGFyYW0gZ3JhcGhpY3NEYXRhIHtHcmFwaGljc30gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcbiAqIEBwYXJhbSB3ZWJHTERhdGEge09iamVjdH1cbiAqL1xuUElYSS5XZWJHTEdyYXBoaWNzLmJ1aWxkUm91bmRlZFJlY3RhbmdsZSA9IGZ1bmN0aW9uKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKVxue1xuXG4gICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG4gICAgdmFyIHggPSBwb2ludHNbMF07XG4gICAgdmFyIHkgPSBwb2ludHNbMV07XG4gICAgdmFyIHdpZHRoID0gcG9pbnRzWzJdO1xuICAgIHZhciBoZWlnaHQgPSBwb2ludHNbM107XG4gICAgdmFyIHJhZGl1cyA9IHBvaW50c1s0XTtcblxuXG4gICAgdmFyIHJlY1BvaW50cyA9IFtdO1xuICAgIHJlY1BvaW50cy5wdXNoKHgsIHkgKyByYWRpdXMpO1xuICAgIHJlY1BvaW50cyA9IHJlY1BvaW50cy5jb25jYXQoUElYSS5XZWJHTEdyYXBoaWNzLnF1YWRyYXRpY0JlemllckN1cnZlKHgsIHkgKyBoZWlnaHQgLSByYWRpdXMsIHgsIHkgKyBoZWlnaHQsIHggKyByYWRpdXMsIHkgKyBoZWlnaHQpKTtcbiAgICByZWNQb2ludHMgPSByZWNQb2ludHMuY29uY2F0KFBJWEkuV2ViR0xHcmFwaGljcy5xdWFkcmF0aWNCZXppZXJDdXJ2ZSh4ICsgd2lkdGggLSByYWRpdXMsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzKSk7XG4gICAgcmVjUG9pbnRzID0gcmVjUG9pbnRzLmNvbmNhdChQSVhJLldlYkdMR3JhcGhpY3MucXVhZHJhdGljQmV6aWVyQ3VydmUoeCArIHdpZHRoLCB5ICsgcmFkaXVzLCB4ICsgd2lkdGgsIHksIHggKyB3aWR0aCAtIHJhZGl1cywgeSkpO1xuICAgIHJlY1BvaW50cyA9IHJlY1BvaW50cy5jb25jYXQoUElYSS5XZWJHTEdyYXBoaWNzLnF1YWRyYXRpY0JlemllckN1cnZlKHggKyByYWRpdXMsIHksIHgsIHksIHgsIHkgKyByYWRpdXMpKTtcblxuXG4gICAgaWYgKGdyYXBoaWNzRGF0YS5maWxsKSB7XG4gICAgICAgIHZhciBjb2xvciA9IFBJWEkuaGV4MnJnYihncmFwaGljc0RhdGEuZmlsbENvbG9yKTtcbiAgICAgICAgdmFyIGFscGhhID0gZ3JhcGhpY3NEYXRhLmZpbGxBbHBoYTtcblxuICAgICAgICB2YXIgciA9IGNvbG9yWzBdICogYWxwaGE7XG4gICAgICAgIHZhciBnID0gY29sb3JbMV0gKiBhbHBoYTtcbiAgICAgICAgdmFyIGIgPSBjb2xvclsyXSAqIGFscGhhO1xuXG4gICAgICAgIHZhciB2ZXJ0cyA9IHdlYkdMRGF0YS5wb2ludHM7XG4gICAgICAgIHZhciBpbmRpY2VzID0gd2ViR0xEYXRhLmluZGljZXM7XG5cbiAgICAgICAgdmFyIHZlY1BvcyA9IHZlcnRzLmxlbmd0aC82O1xuXG4gICAgICAgIHZhciB0cmlhbmdsZXMgPSBQSVhJLlBvbHlLLlRyaWFuZ3VsYXRlKHJlY1BvaW50cyk7XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSs9MylcbiAgICAgICAge1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpXSArIHZlY1Bvcyk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2ldICsgdmVjUG9zKTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSsxXSArIHZlY1Bvcyk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2krMl0gKyB2ZWNQb3MpO1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpKzJdICsgdmVjUG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZWNQb2ludHMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gocmVjUG9pbnRzW2ldLCByZWNQb2ludHNbKytpXSwgciwgZywgYiwgYWxwaGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGdyYXBoaWNzRGF0YS5saW5lV2lkdGgpIHtcbiAgICAgICAgdmFyIHRlbXBQb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuXG4gICAgICAgIGdyYXBoaWNzRGF0YS5wb2ludHMgPSByZWNQb2ludHM7XG5cbiAgICAgICAgUElYSS5XZWJHTEdyYXBoaWNzLmJ1aWxkTGluZShncmFwaGljc0RhdGEsIHdlYkdMRGF0YSk7XG5cbiAgICAgICAgZ3JhcGhpY3NEYXRhLnBvaW50cyA9IHRlbXBQb2ludHM7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDYWxjdWwgdGhlIHBvaW50cyBmb3IgYSBxdWFkcmF0aWMgYmV6aWVyIGN1cnZlLiAoaGVscGVyIGZ1bmN0aW9uLi4pXG4gKiBCYXNlZCBvbiA6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc4NTA5Ny9ob3ctZG8taS1pbXBsZW1lbnQtYS1iZXppZXItY3VydmUtaW4tY1xuICpcbiAqIEBwYXJhbSAge251bWJlcn0gICBmcm9tWCBPcmlnaW4gcG9pbnQgeFxuICogQHBhcmFtICB7bnVtYmVyfSAgIGZyb21ZIE9yaWdpbiBwb2ludCB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICAgY3BYICAgQ29udHJvbCBwb2ludCB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICAgY3BZICAgQ29udHJvbCBwb2ludCB5XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICAgdG9YICAgRGVzdGluYXRpb24gcG9pbnQgeFxuICogQHBhcmFtICB7bnVtYmVyfSAgIHRvWSAgIERlc3RpbmF0aW9uIHBvaW50IHlcbiAqIEByZXR1cm4ge251bWJlcltdfVxuICovXG5QSVhJLldlYkdMR3JhcGhpY3MucXVhZHJhdGljQmV6aWVyQ3VydmUgPSBmdW5jdGlvbihmcm9tWCwgZnJvbVksIGNwWCwgY3BZLCB0b1gsIHRvWSkge1xuICAgIHZhciB4YSxcbiAgICAgICAgeWEsXG4gICAgICAgIHhiLFxuICAgICAgICB5YixcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgbiA9IDIwLFxuICAgICAgICBwb2ludHMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGdldFB0KG4xICwgbjIsIHBlcmMpIHtcbiAgICAgICAgdmFyIGRpZmYgPSBuMiAtIG4xO1xuXG4gICAgICAgIHJldHVybiBuMSArICggZGlmZiAqIHBlcmMgKTtcbiAgICB9XG5cbiAgICB2YXIgaiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbjsgaSsrIClcbiAgICB7XG4gICAgICAgIGogPSBpIC8gbjtcblxuICAgICAgICAvLyBUaGUgR3JlZW4gTGluZVxuICAgICAgICB4YSA9IGdldFB0KCBmcm9tWCAsIGNwWCAsIGogKTtcbiAgICAgICAgeWEgPSBnZXRQdCggZnJvbVkgLCBjcFkgLCBqICk7XG4gICAgICAgIHhiID0gZ2V0UHQoIGNwWCAsIHRvWCAsIGogKTtcbiAgICAgICAgeWIgPSBnZXRQdCggY3BZICwgdG9ZICwgaiApO1xuXG4gICAgICAgIC8vIFRoZSBCbGFjayBEb3RcbiAgICAgICAgeCA9IGdldFB0KCB4YSAsIHhiICwgaiApO1xuICAgICAgICB5ID0gZ2V0UHQoIHlhICwgeWIgLCBqICk7XG5cbiAgICAgICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludHM7XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIGNpcmNsZSB0byBkcmF3XG4gKlxuICogQHN0YXRpY1xuICogQHByaXZhdGVcbiAqIEBtZXRob2QgYnVpbGRDaXJjbGVcbiAqIEBwYXJhbSBncmFwaGljc0RhdGEge0dyYXBoaWNzfSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IHRvIGRyYXdcbiAqIEBwYXJhbSB3ZWJHTERhdGEge09iamVjdH1cbiAqL1xuUElYSS5XZWJHTEdyYXBoaWNzLmJ1aWxkQ2lyY2xlID0gZnVuY3Rpb24oZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpXG57XG4gICAgXG4gICAgLy8gbmVlZCB0byBjb252ZXJ0IHBvaW50cyB0byBhIG5pY2UgcmVndWxhciBkYXRhXG4gICAgdmFyIHJlY3REYXRhID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcbiAgICB2YXIgeCA9IHJlY3REYXRhWzBdO1xuICAgIHZhciB5ID0gcmVjdERhdGFbMV07XG4gICAgdmFyIHdpZHRoID0gcmVjdERhdGFbMl07XG4gICAgdmFyIGhlaWdodCA9IHJlY3REYXRhWzNdO1xuXG4gICAgdmFyIHRvdGFsU2VncyA9IDQwO1xuICAgIHZhciBzZWcgPSAoTWF0aC5QSSAqIDIpIC8gdG90YWxTZWdzIDtcblxuICAgIHZhciBpID0gMDtcblxuICAgIGlmKGdyYXBoaWNzRGF0YS5maWxsKVxuICAgIHtcbiAgICAgICAgdmFyIGNvbG9yID0gUElYSS5oZXgycmdiKGdyYXBoaWNzRGF0YS5maWxsQ29sb3IpO1xuICAgICAgICB2YXIgYWxwaGEgPSBncmFwaGljc0RhdGEuZmlsbEFscGhhO1xuXG4gICAgICAgIHZhciByID0gY29sb3JbMF0gKiBhbHBoYTtcbiAgICAgICAgdmFyIGcgPSBjb2xvclsxXSAqIGFscGhhO1xuICAgICAgICB2YXIgYiA9IGNvbG9yWzJdICogYWxwaGE7XG5cbiAgICAgICAgdmFyIHZlcnRzID0gd2ViR0xEYXRhLnBvaW50cztcbiAgICAgICAgdmFyIGluZGljZXMgPSB3ZWJHTERhdGEuaW5kaWNlcztcblxuICAgICAgICB2YXIgdmVjUG9zID0gdmVydHMubGVuZ3RoLzY7XG5cbiAgICAgICAgaW5kaWNlcy5wdXNoKHZlY1Bvcyk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvdGFsU2VncyArIDEgOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZlcnRzLnB1c2goeCx5LCByLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgICAgIHZlcnRzLnB1c2goeCArIE1hdGguc2luKHNlZyAqIGkpICogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgIHkgKyBNYXRoLmNvcyhzZWcgKiBpKSAqIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgciwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godmVjUG9zKyssIHZlY1BvcysrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGljZXMucHVzaCh2ZWNQb3MtMSk7XG4gICAgfVxuXG4gICAgaWYoZ3JhcGhpY3NEYXRhLmxpbmVXaWR0aClcbiAgICB7XG4gICAgICAgIHZhciB0ZW1wUG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcblxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvdGFsU2VncyArIDE7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgZ3JhcGhpY3NEYXRhLnBvaW50cy5wdXNoKHggKyBNYXRoLnNpbihzZWcgKiBpKSAqIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKyBNYXRoLmNvcyhzZWcgKiBpKSAqIGhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBQSVhJLldlYkdMR3JhcGhpY3MuYnVpbGRMaW5lKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKTtcblxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gdGVtcFBvaW50cztcbiAgICB9XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIGxpbmUgdG8gZHJhd1xuICpcbiAqIEBzdGF0aWNcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIGJ1aWxkTGluZVxuICogQHBhcmFtIGdyYXBoaWNzRGF0YSB7R3JhcGhpY3N9IFRoZSBncmFwaGljcyBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gd2ViR0xEYXRhIHtPYmplY3R9XG4gKi9cblBJWEkuV2ViR0xHcmFwaGljcy5idWlsZExpbmUgPSBmdW5jdGlvbihncmFwaGljc0RhdGEsIHdlYkdMRGF0YSlcbntcbiAgICAvLyBUT0RPIE9QVElNSVNFIVxuICAgIHZhciBpID0gMDtcblxuICAgIHZhciBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuICAgIGlmKHBvaW50cy5sZW5ndGggPT09IDApcmV0dXJuO1xuXG4gICAgLy8gaWYgdGhlIGxpbmUgd2lkdGggaXMgYW4gb2RkIG51bWJlciBhZGQgMC41IHRvIGFsaWduIHRvIGEgd2hvbGUgcGl4ZWxcbiAgICBpZihncmFwaGljc0RhdGEubGluZVdpZHRoJTIpXG4gICAge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwb2ludHNbaV0gKz0gMC41O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZ2V0IGZpcnN0IGFuZCBsYXN0IHBvaW50Li4gZmlndXJlIG91dCB0aGUgbWlkZGxlIVxuICAgIHZhciBmaXJzdFBvaW50ID0gbmV3IFBJWEkuUG9pbnQoIHBvaW50c1swXSwgcG9pbnRzWzFdICk7XG4gICAgdmFyIGxhc3RQb2ludCA9IG5ldyBQSVhJLlBvaW50KCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdLCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdICk7XG5cbiAgICAvLyBpZiB0aGUgZmlyc3QgcG9pbnQgaXMgdGhlIGxhc3QgcG9pbnQgLSBnb25uYSBoYXZlIGlzc3VlcyA6KVxuICAgIGlmKGZpcnN0UG9pbnQueCA9PT0gbGFzdFBvaW50LnggJiYgZmlyc3RQb2ludC55ID09PSBsYXN0UG9pbnQueSlcbiAgICB7XG4gICAgICAgIC8vIG5lZWQgdG8gY2xvbmUgYXMgd2UgYXJlIGdvaW5nIHRvIHNsaWdodGx5IG1vZGlmeSB0aGUgc2hhcGUuLlxuICAgICAgICBwb2ludHMgPSBwb2ludHMuc2xpY2UoKTtcblxuICAgICAgICBwb2ludHMucG9wKCk7XG4gICAgICAgIHBvaW50cy5wb3AoKTtcblxuICAgICAgICBsYXN0UG9pbnQgPSBuZXcgUElYSS5Qb2ludCggcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSApO1xuXG4gICAgICAgIHZhciBtaWRQb2ludFggPSBsYXN0UG9pbnQueCArIChmaXJzdFBvaW50LnggLSBsYXN0UG9pbnQueCkgKjAuNTtcbiAgICAgICAgdmFyIG1pZFBvaW50WSA9IGxhc3RQb2ludC55ICsgKGZpcnN0UG9pbnQueSAtIGxhc3RQb2ludC55KSAqMC41O1xuXG4gICAgICAgIHBvaW50cy51bnNoaWZ0KG1pZFBvaW50WCwgbWlkUG9pbnRZKTtcbiAgICAgICAgcG9pbnRzLnB1c2gobWlkUG9pbnRYLCBtaWRQb2ludFkpO1xuICAgIH1cblxuICAgIHZhciB2ZXJ0cyA9IHdlYkdMRGF0YS5wb2ludHM7XG4gICAgdmFyIGluZGljZXMgPSB3ZWJHTERhdGEuaW5kaWNlcztcbiAgICB2YXIgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCAvIDI7XG4gICAgdmFyIGluZGV4Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIHZhciBpbmRleFN0YXJ0ID0gdmVydHMubGVuZ3RoLzY7XG5cbiAgICAvLyBEUkFXIHRoZSBMaW5lXG4gICAgdmFyIHdpZHRoID0gZ3JhcGhpY3NEYXRhLmxpbmVXaWR0aCAvIDI7XG5cbiAgICAvLyBzb3J0IGNvbG9yXG4gICAgdmFyIGNvbG9yID0gUElYSS5oZXgycmdiKGdyYXBoaWNzRGF0YS5saW5lQ29sb3IpO1xuICAgIHZhciBhbHBoYSA9IGdyYXBoaWNzRGF0YS5saW5lQWxwaGE7XG4gICAgdmFyIHIgPSBjb2xvclswXSAqIGFscGhhO1xuICAgIHZhciBnID0gY29sb3JbMV0gKiBhbHBoYTtcbiAgICB2YXIgYiA9IGNvbG9yWzJdICogYWxwaGE7XG5cbiAgICB2YXIgcHgsIHB5LCBwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5O1xuICAgIHZhciBwZXJweCwgcGVycHksIHBlcnAyeCwgcGVycDJ5LCBwZXJwM3gsIHBlcnAzeTtcbiAgICB2YXIgYTEsIGIxLCBjMSwgYTIsIGIyLCBjMjtcbiAgICB2YXIgZGVub20sIHBkaXN0LCBkaXN0O1xuXG4gICAgcDF4ID0gcG9pbnRzWzBdO1xuICAgIHAxeSA9IHBvaW50c1sxXTtcblxuICAgIHAyeCA9IHBvaW50c1syXTtcbiAgICBwMnkgPSBwb2ludHNbM107XG5cbiAgICBwZXJweCA9IC0ocDF5IC0gcDJ5KTtcbiAgICBwZXJweSA9ICBwMXggLSBwMng7XG5cbiAgICBkaXN0ID0gTWF0aC5zcXJ0KHBlcnB4KnBlcnB4ICsgcGVycHkqcGVycHkpO1xuXG4gICAgcGVycHggLz0gZGlzdDtcbiAgICBwZXJweSAvPSBkaXN0O1xuICAgIHBlcnB4ICo9IHdpZHRoO1xuICAgIHBlcnB5ICo9IHdpZHRoO1xuXG4gICAgLy8gc3RhcnRcbiAgICB2ZXJ0cy5wdXNoKHAxeCAtIHBlcnB4ICwgcDF5IC0gcGVycHksXG4gICAgICAgICAgICAgICAgciwgZywgYiwgYWxwaGEpO1xuXG4gICAgdmVydHMucHVzaChwMXggKyBwZXJweCAsIHAxeSArIHBlcnB5LFxuICAgICAgICAgICAgICAgIHIsIGcsIGIsIGFscGhhKTtcblxuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGgtMTsgaSsrKVxuICAgIHtcbiAgICAgICAgcDF4ID0gcG9pbnRzWyhpLTEpKjJdO1xuICAgICAgICBwMXkgPSBwb2ludHNbKGktMSkqMiArIDFdO1xuXG4gICAgICAgIHAyeCA9IHBvaW50c1soaSkqMl07XG4gICAgICAgIHAyeSA9IHBvaW50c1soaSkqMiArIDFdO1xuXG4gICAgICAgIHAzeCA9IHBvaW50c1soaSsxKSoyXTtcbiAgICAgICAgcDN5ID0gcG9pbnRzWyhpKzEpKjIgKyAxXTtcblxuICAgICAgICBwZXJweCA9IC0ocDF5IC0gcDJ5KTtcbiAgICAgICAgcGVycHkgPSBwMXggLSBwMng7XG5cbiAgICAgICAgZGlzdCA9IE1hdGguc3FydChwZXJweCpwZXJweCArIHBlcnB5KnBlcnB5KTtcbiAgICAgICAgcGVycHggLz0gZGlzdDtcbiAgICAgICAgcGVycHkgLz0gZGlzdDtcbiAgICAgICAgcGVycHggKj0gd2lkdGg7XG4gICAgICAgIHBlcnB5ICo9IHdpZHRoO1xuXG4gICAgICAgIHBlcnAyeCA9IC0ocDJ5IC0gcDN5KTtcbiAgICAgICAgcGVycDJ5ID0gcDJ4IC0gcDN4O1xuXG4gICAgICAgIGRpc3QgPSBNYXRoLnNxcnQocGVycDJ4KnBlcnAyeCArIHBlcnAyeSpwZXJwMnkpO1xuICAgICAgICBwZXJwMnggLz0gZGlzdDtcbiAgICAgICAgcGVycDJ5IC89IGRpc3Q7XG4gICAgICAgIHBlcnAyeCAqPSB3aWR0aDtcbiAgICAgICAgcGVycDJ5ICo9IHdpZHRoO1xuXG4gICAgICAgIGExID0gKC1wZXJweSArIHAxeSkgLSAoLXBlcnB5ICsgcDJ5KTtcbiAgICAgICAgYjEgPSAoLXBlcnB4ICsgcDJ4KSAtICgtcGVycHggKyBwMXgpO1xuICAgICAgICBjMSA9ICgtcGVycHggKyBwMXgpICogKC1wZXJweSArIHAyeSkgLSAoLXBlcnB4ICsgcDJ4KSAqICgtcGVycHkgKyBwMXkpO1xuICAgICAgICBhMiA9ICgtcGVycDJ5ICsgcDN5KSAtICgtcGVycDJ5ICsgcDJ5KTtcbiAgICAgICAgYjIgPSAoLXBlcnAyeCArIHAyeCkgLSAoLXBlcnAyeCArIHAzeCk7XG4gICAgICAgIGMyID0gKC1wZXJwMnggKyBwM3gpICogKC1wZXJwMnkgKyBwMnkpIC0gKC1wZXJwMnggKyBwMngpICogKC1wZXJwMnkgKyBwM3kpO1xuXG4gICAgICAgIGRlbm9tID0gYTEqYjIgLSBhMipiMTtcblxuICAgICAgICBpZihNYXRoLmFicyhkZW5vbSkgPCAwLjEgKVxuICAgICAgICB7XG5cbiAgICAgICAgICAgIGRlbm9tKz0xMC4xO1xuICAgICAgICAgICAgdmVydHMucHVzaChwMnggLSBwZXJweCAsIHAyeSAtIHBlcnB5LFxuICAgICAgICAgICAgICAgIHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAgICAgdmVydHMucHVzaChwMnggKyBwZXJweCAsIHAyeSArIHBlcnB5LFxuICAgICAgICAgICAgICAgIHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBweCA9IChiMSpjMiAtIGIyKmMxKS9kZW5vbTtcbiAgICAgICAgcHkgPSAoYTIqYzEgLSBhMSpjMikvZGVub207XG5cblxuICAgICAgICBwZGlzdCA9IChweCAtcDJ4KSAqIChweCAtcDJ4KSArIChweSAtcDJ5KSArIChweSAtcDJ5KTtcblxuXG4gICAgICAgIGlmKHBkaXN0ID4gMTQwICogMTQwKVxuICAgICAgICB7XG4gICAgICAgICAgICBwZXJwM3ggPSBwZXJweCAtIHBlcnAyeDtcbiAgICAgICAgICAgIHBlcnAzeSA9IHBlcnB5IC0gcGVycDJ5O1xuXG4gICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KHBlcnAzeCpwZXJwM3ggKyBwZXJwM3kqcGVycDN5KTtcbiAgICAgICAgICAgIHBlcnAzeCAvPSBkaXN0O1xuICAgICAgICAgICAgcGVycDN5IC89IGRpc3Q7XG4gICAgICAgICAgICBwZXJwM3ggKj0gd2lkdGg7XG4gICAgICAgICAgICBwZXJwM3kgKj0gd2lkdGg7XG5cbiAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4IC0gcGVycDN4LCBwMnkgLXBlcnAzeSk7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAgICAgdmVydHMucHVzaChwMnggKyBwZXJwM3gsIHAyeSArcGVycDN5KTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIHBlcnAzeCwgcDJ5IC1wZXJwM3kpO1xuICAgICAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgICAgIGluZGV4Q291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcblxuICAgICAgICAgICAgdmVydHMucHVzaChweCAsIHB5KTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIChweC1wMngpLCBwMnkgLSAocHkgLSBwMnkpKTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcDF4ID0gcG9pbnRzWyhsZW5ndGgtMikqMl07XG4gICAgcDF5ID0gcG9pbnRzWyhsZW5ndGgtMikqMiArIDFdO1xuXG4gICAgcDJ4ID0gcG9pbnRzWyhsZW5ndGgtMSkqMl07XG4gICAgcDJ5ID0gcG9pbnRzWyhsZW5ndGgtMSkqMiArIDFdO1xuXG4gICAgcGVycHggPSAtKHAxeSAtIHAyeSk7XG4gICAgcGVycHkgPSBwMXggLSBwMng7XG5cbiAgICBkaXN0ID0gTWF0aC5zcXJ0KHBlcnB4KnBlcnB4ICsgcGVycHkqcGVycHkpO1xuICAgIHBlcnB4IC89IGRpc3Q7XG4gICAgcGVycHkgLz0gZGlzdDtcbiAgICBwZXJweCAqPSB3aWR0aDtcbiAgICBwZXJweSAqPSB3aWR0aDtcblxuICAgIHZlcnRzLnB1c2gocDJ4IC0gcGVycHggLCBwMnkgLSBwZXJweSk7XG4gICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICB2ZXJ0cy5wdXNoKHAyeCArIHBlcnB4ICwgcDJ5ICsgcGVycHkpO1xuICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgaW5kaWNlcy5wdXNoKGluZGV4U3RhcnQpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGluZGV4Q291bnQ7IGkrKylcbiAgICB7XG4gICAgICAgIGluZGljZXMucHVzaChpbmRleFN0YXJ0KyspO1xuICAgIH1cblxuICAgIGluZGljZXMucHVzaChpbmRleFN0YXJ0LTEpO1xufTtcblxuLyoqXG4gKiBCdWlsZHMgYSBjb21wbGV4IHBvbHlnb24gdG8gZHJhd1xuICpcbiAqIEBzdGF0aWNcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIGJ1aWxkUG9seVxuICogQHBhcmFtIGdyYXBoaWNzRGF0YSB7R3JhcGhpY3N9IFRoZSBncmFwaGljcyBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gd2ViR0xEYXRhIHtPYmplY3R9XG4gKi9cblBJWEkuV2ViR0xHcmFwaGljcy5idWlsZENvbXBsZXhQb2x5ID0gZnVuY3Rpb24oZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpXG57XG5cbiAgICAvL1RPRE8gLSBubyBuZWVkIHRvIGNvcHkgdGhpcyBhcyBpdCBnZXRzIHR1cm5lZCBpbnRvIGEgRkxvYXQzMkFycmF5IGFueXdheXMuLlxuICAgIHZhciBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzLnNsaWNlKCk7XG4gICAgaWYocG9pbnRzLmxlbmd0aCA8IDYpcmV0dXJuO1xuXG4gICAgLy8gZ2V0IGZpcnN0IGFuZCBsYXN0IHBvaW50Li4gZmlndXJlIG91dCB0aGUgbWlkZGxlIVxuICAgIHZhciBpbmRpY2VzID0gd2ViR0xEYXRhLmluZGljZXM7XG4gICAgd2ViR0xEYXRhLnBvaW50cyA9IHBvaW50cztcbiAgICB3ZWJHTERhdGEuYWxwaGEgPSBncmFwaGljc0RhdGEuZmlsbEFscGhhO1xuICAgIHdlYkdMRGF0YS5jb2xvciA9IFBJWEkuaGV4MnJnYihncmFwaGljc0RhdGEuZmlsbENvbG9yKTtcblxuICAgIC8qXG4gICAgICAgIGNhbGNsYXRlIHRoZSBib3VuZHMuLlxuICAgICovXG4gICAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcblxuICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG4gICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICB2YXIgeCx5O1xuXG4gICAgLy8gZ2V0IHNpemUuLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSs9MilcbiAgICB7XG4gICAgICAgIHggPSBwb2ludHNbaV07XG4gICAgICAgIHkgPSBwb2ludHNbaSsxXTtcblxuICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICAgICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG5cbiAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICAgIH1cblxuICAgIC8vIGFkZCBhIHF1YWQgdG8gdGhlIGVuZCBjb3MgdGhlcmUgaXMgbm8gcG9pbnQgbWFraW5nIGFub3RoZXIgYnVmZmVyIVxuICAgIHBvaW50cy5wdXNoKG1pblgsIG1pblksXG4gICAgICAgICAgICAgICAgbWF4WCwgbWluWSxcbiAgICAgICAgICAgICAgICBtYXhYLCBtYXhZLFxuICAgICAgICAgICAgICAgIG1pblgsIG1heFkpO1xuXG4gICAgLy8gcHVzaCBhIHF1YWQgb250byB0aGUgZW5kLi4gXG4gICAgXG4gICAgLy9UT0RPIC0gdGhpcyBhaW50IG5lZWRlZCFcbiAgICB2YXIgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCAvIDI7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKCBpICk7XG4gICAgfVxuXG59O1xuXG5QSVhJLldlYkdMR3JhcGhpY3MuYnVpbGRQb2x5ID0gZnVuY3Rpb24oZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpXG57XG4gICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG4gICAgaWYocG9pbnRzLmxlbmd0aCA8IDYpcmV0dXJuO1xuXG4gICAgLy8gZ2V0IGZpcnN0IGFuZCBsYXN0IHBvaW50Li4gZmlndXJlIG91dCB0aGUgbWlkZGxlIVxuICAgIHZhciB2ZXJ0cyA9IHdlYkdMRGF0YS5wb2ludHM7XG4gICAgdmFyIGluZGljZXMgPSB3ZWJHTERhdGEuaW5kaWNlcztcblxuICAgIHZhciBsZW5ndGggPSBwb2ludHMubGVuZ3RoIC8gMjtcblxuICAgIC8vIHNvcnQgY29sb3JcbiAgICB2YXIgY29sb3IgPSBQSVhJLmhleDJyZ2IoZ3JhcGhpY3NEYXRhLmZpbGxDb2xvcik7XG4gICAgdmFyIGFscGhhID0gZ3JhcGhpY3NEYXRhLmZpbGxBbHBoYTtcbiAgICB2YXIgciA9IGNvbG9yWzBdICogYWxwaGE7XG4gICAgdmFyIGcgPSBjb2xvclsxXSAqIGFscGhhO1xuICAgIHZhciBiID0gY29sb3JbMl0gKiBhbHBoYTtcblxuICAgIHZhciB0cmlhbmdsZXMgPSBQSVhJLlBvbHlLLlRyaWFuZ3VsYXRlKHBvaW50cyk7XG4gICAgdmFyIHZlcnRQb3MgPSB2ZXJ0cy5sZW5ndGggLyA2O1xuXG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkrPTMpXG4gICAge1xuICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2ldICsgdmVydFBvcyk7XG4gICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaV0gKyB2ZXJ0UG9zKTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpKzFdICsgdmVydFBvcyk7XG4gICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSsyXSArdmVydFBvcyk7XG4gICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSsyXSArIHZlcnRQb3MpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZlcnRzLnB1c2gocG9pbnRzW2kgKiAyXSwgcG9pbnRzW2kgKiAyICsgMV0sXG4gICAgICAgICAgICAgICAgICAgciwgZywgYiwgYWxwaGEpO1xuICAgIH1cblxufTtcblxuUElYSS5XZWJHTEdyYXBoaWNzLmdyYXBoaWNzRGF0YVBvb2wgPSBbXTtcblxuUElYSS5XZWJHTEdyYXBoaWNzRGF0YSA9IGZ1bmN0aW9uKGdsKVxue1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIC8vVE9ETyBkb2VzIHRoaXMgbmVlZCB0byBiZSBzcGxpdCBiZWZvcmUgdXBsb2Rpbmc/P1xuICAgIHRoaXMuY29sb3IgPSBbMCwwLDBdOyAvLyBjb2xvciBzcGxpdCFcbiAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgIHRoaXMuaW5kaWNlcyA9IFtdO1xuICAgIHRoaXMubGFzdEluZGV4ID0gMDtcbiAgICB0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLm1vZGUgPSAxO1xuICAgIHRoaXMuYWxwaGEgPSAxO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xufTtcblxuUElYSS5XZWJHTEdyYXBoaWNzRGF0YS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICB0aGlzLmluZGljZXMgPSBbXTtcbiAgICB0aGlzLmxhc3RJbmRleCA9IDA7XG59O1xuXG5QSVhJLldlYkdMR3JhcGhpY3NEYXRhLnByb3RvdHlwZS51cGxvYWQgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuLy8gICAgdGhpcy5sYXN0SW5kZXggPSBncmFwaGljcy5ncmFwaGljc0RhdGEubGVuZ3RoO1xuICAgIHRoaXMuZ2xQb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMucG9pbnRzKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHRoaXMuZ2xQb2ludHMsIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIHRoaXMuZ2xJbmRpY2llcyA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmluZGljZXMpO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRleEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5nbEluZGljaWVzLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cblBJWEkuZ2xDb250ZXh0cyA9IFtdOyAvLyB0aGlzIGlzIHdoZXJlIHdlIHN0b3JlIHRoZSB3ZWJHTCBjb250ZXh0cyBmb3IgZWFzeSBhY2Nlc3MuXG5cbi8qKlxuICogdGhlIFdlYkdMUmVuZGVyZXIgZHJhd3MgdGhlIHN0YWdlIGFuZCBhbGwgaXRzIGNvbnRlbnQgb250byBhIHdlYkdMIGVuYWJsZWQgY2FudmFzLiBUaGlzIHJlbmRlcmVyXG4gKiBzaG91bGQgYmUgdXNlZCBmb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IHdlYkdMLiBUaGlzIFJlbmRlciB3b3JrcyBieSBhdXRvbWF0aWNhbGx5IG1hbmFnaW5nIHdlYkdMQmF0Y2gncy5cbiAqIFNvIG5vIG5lZWQgZm9yIFNwcml0ZSBCYXRjaCdzIG9yIFNwcml0ZSBDbG91ZCdzXG4gKiBEb250IGZvcmdldCB0byBhZGQgdGhlIHZpZXcgdG8geW91ciBET00gb3IgeW91IHdpbGwgbm90IHNlZSBhbnl0aGluZyA6KVxuICpcbiAqIEBjbGFzcyBXZWJHTFJlbmRlcmVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB3aWR0aD0wIHtOdW1iZXJ9IHRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIHZpZXdcbiAqIEBwYXJhbSBoZWlnaHQ9MCB7TnVtYmVyfSB0aGUgaGVpZ2h0IG9mIHRoZSBjYW52YXMgdmlld1xuICogQHBhcmFtIHZpZXcge0hUTUxDYW52YXNFbGVtZW50fSB0aGUgY2FudmFzIHRvIHVzZSBhcyBhIHZpZXcsIG9wdGlvbmFsXG4gKiBAcGFyYW0gdHJhbnNwYXJlbnQ9ZmFsc2Uge0Jvb2xlYW59IElmIHRoZSByZW5kZXIgdmlldyBpcyB0cmFuc3BhcmVudCwgZGVmYXVsdCBmYWxzZVxuICogQHBhcmFtIGFudGlhbGlhcz1mYWxzZSB7Qm9vbGVhbn0gc2V0cyBhbnRpYWxpYXMgKG9ubHkgYXBwbGljYWJsZSBpbiBjaHJvbWUgYXQgdGhlIG1vbWVudClcbiAqIEBwYXJhbSBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI9ZmFsc2Uge0Jvb2xlYW59IGVuYWJsZXMgZHJhd2luZyBidWZmZXIgcHJlc2VydmF0aW9uLCBlbmFibGUgdGhpcyBpZiB5b3UgbmVlZCB0byBjYWxsIHRvRGF0YVVybCBvbiB0aGUgd2ViZ2wgY29udGV4dFxuICpcbiAqL1xuUElYSS5XZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgdmlldywgdHJhbnNwYXJlbnQsIGFudGlhbGlhcywgcHJlc2VydmVEcmF3aW5nQnVmZmVyKVxue1xuICAgIGlmKCFQSVhJLmRlZmF1bHRSZW5kZXJlcilcbiAgICB7XG4gICAgICAgIFBJWEkuc2F5SGVsbG8oJ3dlYkdMJyk7XG4gICAgICAgIFBJWEkuZGVmYXVsdFJlbmRlcmVyID0gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSBQSVhJLldFQkdMX1JFTkRFUkVSO1xuXG4gICAgLy8gZG8gYSBjYXRjaC4uIG9ubHkgMSB3ZWJHTCByZW5kZXJlci4uXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVuZGVyIHZpZXcgaXMgdHJhbnNwYXJlbnRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0cmFuc3BhcmVudFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zcGFyZW50ID0gISF0cmFuc3BhcmVudDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBvZiB0aGUgcHJlc2VydmVEcmF3aW5nQnVmZmVyIGZsYWcgYWZmZWN0cyB3aGV0aGVyIG9yIG5vdCB0aGUgY29udGVudHMgb2YgdGhlIHN0ZW5jaWwgYnVmZmVyIGlzIHJldGFpbmVkIGFmdGVyIHJlbmRlcmluZy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwcmVzZXJ2ZURyYXdpbmdCdWZmZXJcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIGNhbnZhcyB2aWV3XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgd2lkdGhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCA4MDBcbiAgICAgKi9cbiAgICB0aGlzLndpZHRoID0gd2lkdGggfHwgODAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgY2FudmFzIHZpZXdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBoZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCA2MDBcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCA2MDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FudmFzIGVsZW1lbnQgdGhhdCBldmVyeXRoaW5nIGlzIGRyYXduIHRvXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdmlld1xuICAgICAqIEB0eXBlIEhUTUxDYW52YXNFbGVtZW50XG4gICAgICovXG4gICAgdGhpcy52aWV3ID0gdmlldyB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xuICAgIHRoaXMudmlldy53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgdGhpcy52aWV3LmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgLy8gZGVhbCB3aXRoIGxvc2luZyBjb250ZXh0Li5cbiAgICB0aGlzLmNvbnRleHRMb3N0ID0gdGhpcy5oYW5kbGVDb250ZXh0TG9zdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuY29udGV4dFJlc3RvcmVkTG9zdCA9IHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkLmJpbmQodGhpcyk7XG4gICAgXG4gICAgdGhpcy52aWV3LmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCB0aGlzLmNvbnRleHRMb3N0LCBmYWxzZSk7XG4gICAgdGhpcy52aWV3LmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgdGhpcy5jb250ZXh0UmVzdG9yZWRMb3N0LCBmYWxzZSk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgIGFscGhhOiB0aGlzLnRyYW5zcGFyZW50LFxuICAgICAgICBhbnRpYWxpYXM6ISFhbnRpYWxpYXMsIC8vIFNQRUVEIFVQPz9cbiAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiEhdHJhbnNwYXJlbnQsXG4gICAgICAgIHN0ZW5jaWw6dHJ1ZSxcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBwcmVzZXJ2ZURyYXdpbmdCdWZmZXJcbiAgICB9O1xuXG4gICAgdmFyIGdsID0gbnVsbDtcblxuICAgIFsnZXhwZXJpbWVudGFsLXdlYmdsJywgJ3dlYmdsJ10uZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBnbCA9IGdsIHx8IHRoaXMudmlldy5nZXRDb250ZXh0KG5hbWUsICB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9IGNhdGNoKGUpIHt9XG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAoIWdsKSB7XG4gICAgICAgIC8vIGZhaWwsIG5vdCBhYmxlIHRvIGdldCBhIGNvbnRleHRcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB3ZWJHTC4gVHJ5IHVzaW5nIHRoZSBjYW52YXMgcmVuZGVyZXInICsgdGhpcyk7XG4gICAgfVxuXG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMuZ2xDb250ZXh0SWQgPSBnbC5pZCA9IFBJWEkuV2ViR0xSZW5kZXJlci5nbENvbnRleHRJZCArKztcblxuICAgIFBJWEkuZ2xDb250ZXh0c1t0aGlzLmdsQ29udGV4dElkXSA9IGdsO1xuXG4gICAgaWYoIVBJWEkuYmxlbmRNb2Rlc1dlYkdMKVxuICAgIHtcbiAgICAgICAgUElYSS5ibGVuZE1vZGVzV2ViR0wgPSBbXTtcblxuICAgICAgICBQSVhJLmJsZW5kTW9kZXNXZWJHTFtQSVhJLmJsZW5kTW9kZXMuTk9STUFMXSAgICAgICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgUElYSS5ibGVuZE1vZGVzV2ViR0xbUElYSS5ibGVuZE1vZGVzLkFERF0gICAgICAgICAgID0gW2dsLlNSQ19BTFBIQSwgZ2wuRFNUX0FMUEhBXTtcbiAgICAgICAgUElYSS5ibGVuZE1vZGVzV2ViR0xbUElYSS5ibGVuZE1vZGVzLk1VTFRJUExZXSAgICAgID0gW2dsLkRTVF9DT0xPUiwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIFBJWEkuYmxlbmRNb2Rlc1dlYkdMW1BJWEkuYmxlbmRNb2Rlcy5TQ1JFRU5dICAgICAgICA9IFtnbC5TUkNfQUxQSEEsIGdsLk9ORV07XG4gICAgICAgIFBJWEkuYmxlbmRNb2Rlc1dlYkdMW1BJWEkuYmxlbmRNb2Rlcy5PVkVSTEFZXSAgICAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBQSVhJLmJsZW5kTW9kZXNXZWJHTFtQSVhJLmJsZW5kTW9kZXMuREFSS0VOXSAgICAgICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgUElYSS5ibGVuZE1vZGVzV2ViR0xbUElYSS5ibGVuZE1vZGVzLkxJR0hURU5dICAgICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIFBJWEkuYmxlbmRNb2Rlc1dlYkdMW1BJWEkuYmxlbmRNb2Rlcy5DT0xPUl9ET0RHRV0gICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBQSVhJLmJsZW5kTW9kZXNXZWJHTFtQSVhJLmJsZW5kTW9kZXMuQ09MT1JfQlVSTl0gICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgUElYSS5ibGVuZE1vZGVzV2ViR0xbUElYSS5ibGVuZE1vZGVzLkhBUkRfTElHSFRdICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIFBJWEkuYmxlbmRNb2Rlc1dlYkdMW1BJWEkuYmxlbmRNb2Rlcy5TT0ZUX0xJR0hUXSAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBQSVhJLmJsZW5kTW9kZXNXZWJHTFtQSVhJLmJsZW5kTW9kZXMuRElGRkVSRU5DRV0gICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgUElYSS5ibGVuZE1vZGVzV2ViR0xbUElYSS5ibGVuZE1vZGVzLkVYQ0xVU0lPTl0gICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIFBJWEkuYmxlbmRNb2Rlc1dlYkdMW1BJWEkuYmxlbmRNb2Rlcy5IVUVdICAgICAgICAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBQSVhJLmJsZW5kTW9kZXNXZWJHTFtQSVhJLmJsZW5kTW9kZXMuU0FUVVJBVElPTl0gICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgUElYSS5ibGVuZE1vZGVzV2ViR0xbUElYSS5ibGVuZE1vZGVzLkNPTE9SXSAgICAgICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIFBJWEkuYmxlbmRNb2Rlc1dlYkdMW1BJWEkuYmxlbmRNb2Rlcy5MVU1JTk9TSVRZXSAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgIH1cblxuXG5cblxuICAgIHRoaXMucHJvamVjdGlvbiA9IG5ldyBQSVhJLlBvaW50KCk7XG4gICAgdGhpcy5wcm9qZWN0aW9uLnggPSAgdGhpcy53aWR0aC8yO1xuICAgIHRoaXMucHJvamVjdGlvbi55ID0gIC10aGlzLmhlaWdodC8yO1xuXG4gICAgdGhpcy5vZmZzZXQgPSBuZXcgUElYSS5Qb2ludCgwLCAwKTtcblxuICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB0aGlzLmNvbnRleHRMb3N0ID0gZmFsc2U7XG5cbiAgICAvLyB0aW1lIHRvIGNyZWF0ZSB0aGUgcmVuZGVyIG1hbmFnZXJzISBlYWNoIG9uZSBmb2N1c2VzIG9uIG1hbmFnaW5lIGEgc3RhdGUgaW4gd2ViR0xcbiAgICB0aGlzLnNoYWRlck1hbmFnZXIgPSBuZXcgUElYSS5XZWJHTFNoYWRlck1hbmFnZXIoZ2wpOyAgICAgICAgICAgICAgICAgICAvLyBkZWFscyB3aXRoIG1hbmFnaW5nIHRoZSBzaGFkZXIgcHJvZ3JhbXMgYW5kIHRoZWlyIGF0dHJpYnNcbiAgICB0aGlzLnNwcml0ZUJhdGNoID0gbmV3IFBJWEkuV2ViR0xTcHJpdGVCYXRjaChnbCk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBtYW5hZ2VzIHRoZSByZW5kZXJpbmcgb2Ygc3ByaXRlc1xuICAgIC8vdGhpcy5wcmltaXRpdmVCYXRjaCA9IG5ldyBQSVhJLldlYkdMUHJpbWl0aXZlQmF0Y2goZ2wpOyAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZSBiYXRjaCByZW5kZXJlclxuICAgIHRoaXMubWFza01hbmFnZXIgPSBuZXcgUElYSS5XZWJHTE1hc2tNYW5hZ2VyKGdsKTsgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hbmFnZXMgdGhlIG1hc2tzIHVzaW5nIHRoZSBzdGVuY2lsIGJ1ZmZlclxuICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IG5ldyBQSVhJLldlYkdMRmlsdGVyTWFuYWdlcihnbCwgdGhpcy50cmFuc3BhcmVudCk7IC8vIG1hbmFnZXMgdGhlIGZpbHRlcnNcbiAgICB0aGlzLnN0ZW5jaWxNYW5hZ2VyID0gbmV3IFBJWEkuV2ViR0xTdGVuY2lsTWFuYWdlcihnbCk7XG4gICAgdGhpcy5ibGVuZE1vZGVNYW5hZ2VyID0gbmV3IFBJWEkuV2ViR0xCbGVuZE1vZGVNYW5hZ2VyKGdsKTtcblxuICAgIHRoaXMucmVuZGVyU2Vzc2lvbiA9IHt9O1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5nbCA9IHRoaXMuZ2w7XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLmRyYXdDb3VudCA9IDA7XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIgPSB0aGlzLnNoYWRlck1hbmFnZXI7XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLm1hc2tNYW5hZ2VyID0gdGhpcy5tYXNrTWFuYWdlcjtcbiAgICB0aGlzLnJlbmRlclNlc3Npb24uZmlsdGVyTWFuYWdlciA9IHRoaXMuZmlsdGVyTWFuYWdlcjtcbiAgICB0aGlzLnJlbmRlclNlc3Npb24uYmxlbmRNb2RlTWFuYWdlciA9IHRoaXMuYmxlbmRNb2RlTWFuYWdlcjtcbiAgIC8vIHRoaXMucmVuZGVyU2Vzc2lvbi5wcmltaXRpdmVCYXRjaCA9IHRoaXMucHJpbWl0aXZlQmF0Y2g7XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoID0gdGhpcy5zcHJpdGVCYXRjaDtcbiAgICB0aGlzLnJlbmRlclNlc3Npb24uc3RlbmNpbE1hbmFnZXIgPSB0aGlzLnN0ZW5jaWxNYW5hZ2VyO1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5yZW5kZXJlciA9IHRoaXM7XG5cbiAgICBnbC51c2VQcm9ncmFtKHRoaXMuc2hhZGVyTWFuYWdlci5kZWZhdWx0U2hhZGVyLnByb2dyYW0pO1xuXG4gICAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICBnbC5kaXNhYmxlKGdsLkNVTExfRkFDRSk7XG5cbiAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0aGlzLnRyYW5zcGFyZW50KTtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLldlYkdMUmVuZGVyZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5XZWJHTFJlbmRlcmVyO1xuXG4vKipcbiAqIFJlbmRlcnMgdGhlIHN0YWdlIHRvIGl0cyB3ZWJHTCB2aWV3XG4gKlxuICogQG1ldGhvZCByZW5kZXJcbiAqIEBwYXJhbSBzdGFnZSB7U3RhZ2V9IHRoZSBTdGFnZSBlbGVtZW50IHRvIGJlIHJlbmRlcmVkXG4gKi9cblBJWEkuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oc3RhZ2UpXG57XG4gICAgaWYodGhpcy5jb250ZXh0TG9zdClyZXR1cm47XG5cblxuICAgIC8vIGlmIHJlbmRlcmluZyBhIG5ldyBzdGFnZSBjbGVhciB0aGUgYmF0Y2hlcy4uXG4gICAgaWYodGhpcy5fX3N0YWdlICE9PSBzdGFnZSlcbiAgICB7XG4gICAgICAgIGlmKHN0YWdlLmludGVyYWN0aXZlKXN0YWdlLmludGVyYWN0aW9uTWFuYWdlci5yZW1vdmVFdmVudHMoKTtcblxuICAgICAgICAvLyBUT0RPIG1ha2UgdGhpcyB3b3JrXG4gICAgICAgIC8vIGRvbnQgdGhpbmsgdGhpcyBpcyBuZWVkZWQgYW55IG1vcmU/XG4gICAgICAgIHRoaXMuX19zdGFnZSA9IHN0YWdlO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBhbnkgdGV4dHVyZXMgdGhpcyBpbmNsdWRlcyB1dnMgYW5kIHVwbG9hZGluZyB0aGVtIHRvIHRoZSBncHVcbiAgICBQSVhJLldlYkdMUmVuZGVyZXIudXBkYXRlVGV4dHVyZXMoKTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgc2NlbmUgZ3JhcGhcbiAgICBzdGFnZS51cGRhdGVUcmFuc2Zvcm0oKTtcblxuXG4gICAgLy8gaW50ZXJhY3Rpb25cbiAgICBpZihzdGFnZS5faW50ZXJhY3RpdmUpXG4gICAge1xuICAgICAgICAvL25lZWQgdG8gYWRkIHNvbWUgZXZlbnRzIVxuICAgICAgICBpZighc3RhZ2UuX2ludGVyYWN0aXZlRXZlbnRzQWRkZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0YWdlLl9pbnRlcmFjdGl2ZUV2ZW50c0FkZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0YWdlLmludGVyYWN0aW9uTWFuYWdlci5zZXRUYXJnZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIC8vIC0tIERvZXMgdGhpcyBuZWVkIHRvIGJlIHNldCBldmVyeSBmcmFtZT8gLS0gLy9cbiAgICAvL2dsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0aGlzLnRyYW5zcGFyZW50KTtcbiAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cbiAgICAvLyBtYWtlIHN1cmUgd2UgYXJlIGJvdW5kIHRvIHRoZSBtYWluIGZyYW1lIGJ1ZmZlclxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cbiAgICBpZih0aGlzLnRyYW5zcGFyZW50KVxuICAgIHtcbiAgICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgZ2wuY2xlYXJDb2xvcihzdGFnZS5iYWNrZ3JvdW5kQ29sb3JTcGxpdFswXSxzdGFnZS5iYWNrZ3JvdW5kQ29sb3JTcGxpdFsxXSxzdGFnZS5iYWNrZ3JvdW5kQ29sb3JTcGxpdFsyXSwgMSk7XG4gICAgfVxuXG5cbiAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcblxuICAgIHRoaXMucmVuZGVyRGlzcGxheU9iamVjdCggc3RhZ2UsIHRoaXMucHJvamVjdGlvbiApO1xuXG4gICAgLy8gaW50ZXJhY3Rpb25cbiAgICBpZihzdGFnZS5pbnRlcmFjdGl2ZSlcbiAgICB7XG4gICAgICAgIC8vbmVlZCB0byBhZGQgc29tZSBldmVudHMhXG4gICAgICAgIGlmKCFzdGFnZS5faW50ZXJhY3RpdmVFdmVudHNBZGRlZClcbiAgICAgICAge1xuICAgICAgICAgICAgc3RhZ2UuX2ludGVyYWN0aXZlRXZlbnRzQWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgc3RhZ2UuaW50ZXJhY3Rpb25NYW5hZ2VyLnNldFRhcmdldCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBpZihzdGFnZS5faW50ZXJhY3RpdmVFdmVudHNBZGRlZClcbiAgICAgICAge1xuICAgICAgICAgICAgc3RhZ2UuX2ludGVyYWN0aXZlRXZlbnRzQWRkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHN0YWdlLmludGVyYWN0aW9uTWFuYWdlci5zZXRUYXJnZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgIC8vY2FuIHNpbXVsYXRlIGNvbnRleHQgbG9zcyBpbiBDaHJvbWUgbGlrZSBzbzpcbiAgICAgdGhpcy52aWV3Lm9ubW91c2Vkb3duID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgY29uc29sZS5kaXIodGhpcy5nbC5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zKCkpO1xuICAgICAgICB2YXIgZXh0ID0gKFxuICAgICAgICAgICAgZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfc2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXCIpXG4gICAgICAgLy8gZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcIikgfHxcbiAgICAgICAvLyBnbC5nZXRFeHRlbnNpb24oXCJNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcIikgfHxcbiAgICAgICAvLyBnbC5nZXRFeHRlbnNpb24oXCJXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcIilcbiAgICAgKTtcbiAgICAgY29uc29sZS5kaXIoZXh0KTtcbiAgICAgdmFyIGxvc2VDdHggPSB0aGlzLmdsLmdldEV4dGVuc2lvbihcIldFQkdMX2xvc2VfY29udGV4dFwiKTtcbiAgICAgIGNvbnNvbGUubG9nKFwia2lsbGluZyBjb250ZXh0XCIpO1xuICAgICAgbG9zZUN0eC5sb3NlQ29udGV4dCgpO1xuICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwicmVzdG9yaW5nIGNvbnRleHQuLi5cIik7XG4gICAgICAgICAgbG9zZUN0eC5yZXN0b3JlQ29udGV4dCgpO1xuICAgICAgfS5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAqL1xufTtcblxuLyoqXG4gKiBSZW5kZXJzIGEgZGlzcGxheSBPYmplY3RcbiAqXG4gKiBAbWV0aG9kIHJlbmRlckRJc3BsYXlPYmplY3RcbiAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IHtEaXNwbGF5T2JqZWN0fSBUaGUgRGlzcGxheU9iamVjdCB0byByZW5kZXJcbiAqIEBwYXJhbSBwcm9qZWN0aW9uIHtQb2ludH0gVGhlIHByb2plY3Rpb25cbiAqIEBwYXJhbSBidWZmZXIge0FycmF5fSBhIHN0YW5kYXJkIFdlYkdMIGJ1ZmZlciBcbiAqL1xuUElYSS5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJEaXNwbGF5T2JqZWN0ID0gZnVuY3Rpb24oZGlzcGxheU9iamVjdCwgcHJvamVjdGlvbiwgYnVmZmVyKVxue1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5ibGVuZE1vZGVNYW5hZ2VyLnNldEJsZW5kTW9kZShQSVhJLmJsZW5kTW9kZXMuTk9STUFMKTtcbiAgICAvLyByZXNldCB0aGUgcmVuZGVyIHNlc3Npb24gZGF0YS4uXG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLmRyYXdDb3VudCA9IDA7XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLmN1cnJlbnRCbGVuZE1vZGUgPSA5OTk5O1xuXG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLnByb2plY3Rpb24gPSBwcm9qZWN0aW9uO1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5vZmZzZXQgPSB0aGlzLm9mZnNldDtcblxuICAgIC8vIHN0YXJ0IHRoZSBzcHJpdGUgYmF0Y2hcbiAgICB0aGlzLnNwcml0ZUJhdGNoLmJlZ2luKHRoaXMucmVuZGVyU2Vzc2lvbik7XG5cbi8vICAgIHRoaXMucHJpbWl0aXZlQmF0Y2guYmVnaW4odGhpcy5yZW5kZXJTZXNzaW9uKTtcblxuICAgIC8vIHN0YXJ0IHRoZSBmaWx0ZXIgbWFuYWdlclxuICAgIHRoaXMuZmlsdGVyTWFuYWdlci5iZWdpbih0aGlzLnJlbmRlclNlc3Npb24sIGJ1ZmZlcik7XG5cbiAgICAvLyByZW5kZXIgdGhlIHNjZW5lIVxuICAgIGRpc3BsYXlPYmplY3QuX3JlbmRlcldlYkdMKHRoaXMucmVuZGVyU2Vzc2lvbik7XG5cbiAgICAvLyBmaW5pc2ggdGhlIHNwcml0ZSBiYXRjaFxuICAgIHRoaXMuc3ByaXRlQmF0Y2guZW5kKCk7XG5cbi8vICAgIHRoaXMucHJpbWl0aXZlQmF0Y2guZW5kKCk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHRleHR1cmVzIGxvYWRlZCBpbnRvIHRoaXMgd2ViZ2wgcmVuZGVyZXJcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHVwZGF0ZVRleHR1cmVzXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLldlYkdMUmVuZGVyZXIudXBkYXRlVGV4dHVyZXMgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgLy9UT0RPIGJyZWFrIHRoaXMgb3V0IGludG8gYSB0ZXh0dXJlIG1hbmFnZXIuLi5cbiAgLy8gIGZvciAoaSA9IDA7IGkgPCBQSVhJLnRleHR1cmVzVG9VcGRhdGUubGVuZ3RoOyBpKyspXG4gIC8vICAgICAgUElYSS4udXBkYXRlV2ViR0xUZXh0dXJlKFBJWEkudGV4dHVyZXNUb1VwZGF0ZVtpXSwgdGhpcy5nbCk7XG5cblxuICAgIGZvciAoaT0wOyBpIDwgUElYSS5UZXh0dXJlLmZyYW1lVXBkYXRlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgUElYSS5XZWJHTFJlbmRlcmVyLnVwZGF0ZVRleHR1cmVGcmFtZShQSVhJLlRleHR1cmUuZnJhbWVVcGRhdGVzW2ldKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBQSVhJLnRleHR1cmVzVG9EZXN0cm95Lmxlbmd0aDsgaSsrKVxuICAgICAgICBQSVhJLldlYkdMUmVuZGVyZXIuZGVzdHJveVRleHR1cmUoUElYSS50ZXh0dXJlc1RvRGVzdHJveVtpXSk7XG5cbiAgICBQSVhJLnRleHR1cmVzVG9VcGRhdGUubGVuZ3RoID0gMDtcbiAgICBQSVhJLnRleHR1cmVzVG9EZXN0cm95Lmxlbmd0aCA9IDA7XG4gICAgUElYSS5UZXh0dXJlLmZyYW1lVXBkYXRlcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBEZXN0cm95cyBhIGxvYWRlZCB3ZWJnbCB0ZXh0dXJlXG4gKlxuICogQG1ldGhvZCBkZXN0cm95VGV4dHVyZVxuICogQHBhcmFtIHRleHR1cmUge1RleHR1cmV9IFRoZSB0ZXh0dXJlIHRvIHVwZGF0ZVxuICogQHByaXZhdGVcbiAqL1xuUElYSS5XZWJHTFJlbmRlcmVyLmRlc3Ryb3lUZXh0dXJlID0gZnVuY3Rpb24odGV4dHVyZSlcbntcbiAgICAvL1RPRE8gYnJlYWsgdGhpcyBvdXQgaW50byBhIHRleHR1cmUgbWFuYWdlci4uLlxuXG4gICAgZm9yICh2YXIgaSA9IHRleHR1cmUuX2dsVGV4dHVyZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAge1xuICAgICAgICB2YXIgZ2xUZXh0dXJlID0gdGV4dHVyZS5fZ2xUZXh0dXJlc1tpXTtcbiAgICAgICAgdmFyIGdsID0gUElYSS5nbENvbnRleHRzW2ldO1xuXG4gICAgICAgIGlmKGdsICYmIGdsVGV4dHVyZSlcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuZGVsZXRlVGV4dHVyZShnbFRleHR1cmUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGV4dHVyZS5fZ2xUZXh0dXJlcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKlxuICogQG1ldGhvZCB1cGRhdGVUZXh0dXJlRnJhbWVcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfSBUaGUgdGV4dHVyZSB0byB1cGRhdGUgdGhlIGZyYW1lIGZyb21cbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuV2ViR0xSZW5kZXJlci51cGRhdGVUZXh0dXJlRnJhbWUgPSBmdW5jdGlvbih0ZXh0dXJlKVxue1xuICAgIC8vdGV4dHVyZS51cGRhdGVGcmFtZSA9IGZhbHNlO1xuXG4gICAgLy8gbm93IHNldCB0aGUgdXZzLiBGaWd1cmVkIHRoYXQgdGhlIHV2IGRhdGEgc2l0cyB3aXRoIGEgdGV4dHVyZSByYXRoZXIgdGhhbiBhIHNwcml0ZS5cbiAgICAvLyBzbyB1diBkYXRhIGlzIHN0b3JlZCBvbiB0aGUgdGV4dHVyZSBpdHNlbGZcbiAgICB0ZXh0dXJlLl91cGRhdGVXZWJHTHV2cygpO1xufTtcblxuLyoqXG4gKiByZXNpemVzIHRoZSB3ZWJHTCB2aWV3IHRvIHRoZSBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodFxuICpcbiAqIEBtZXRob2QgcmVzaXplXG4gKiBAcGFyYW0gd2lkdGgge051bWJlcn0gdGhlIG5ldyB3aWR0aCBvZiB0aGUgd2ViR0wgdmlld1xuICogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSB0aGUgbmV3IGhlaWdodCBvZiB0aGUgd2ViR0wgdmlld1xuICovXG5QSVhJLldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpXG57XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgdGhpcy52aWV3LndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy52aWV3LmhlaWdodCA9IGhlaWdodDtcblxuICAgIHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgdGhpcy5wcm9qZWN0aW9uLnggPSAgdGhpcy53aWR0aC8yO1xuICAgIHRoaXMucHJvamVjdGlvbi55ID0gIC10aGlzLmhlaWdodC8yO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgV2ViR0wgdGV4dHVyZVxuICpcbiAqIEBtZXRob2QgY3JlYXRlV2ViR0xUZXh0dXJlXG4gKiBAcGFyYW0gdGV4dHVyZSB7VGV4dHVyZX0gdGhlIHRleHR1cmUgdG8gcmVuZGVyXG4gKiBAcGFyYW0gZ2wge3dlYmdsQ29udGV4dH0gdGhlIFdlYkdMIGNvbnRleHRcbiAqIEBzdGF0aWNcbiAqL1xuUElYSS5jcmVhdGVXZWJHTFRleHR1cmUgPSBmdW5jdGlvbih0ZXh0dXJlLCBnbClcbntcblxuXG4gICAgaWYodGV4dHVyZS5oYXNMb2FkZWQpXG4gICAge1xuICAgICAgICB0ZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSk7XG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGV4dHVyZS5wcmVtdWx0aXBsaWVkQWxwaGEpO1xuXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGV4dHVyZS5zb3VyY2UpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGV4dHVyZS5zY2FsZU1vZGUgPT09IFBJWEkuc2NhbGVNb2Rlcy5MSU5FQVIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRleHR1cmUuc2NhbGVNb2RlID09PSBQSVhJLnNjYWxlTW9kZXMuTElORUFSID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVCk7XG5cbiAgICAgICAgLy8gcmVndWxlci4uLlxuXG4gICAgICAgIGlmKCF0ZXh0dXJlLl9wb3dlck9mMilcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLlJFUEVBVCk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5SRVBFQVQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cbiAgICAgICAgdGV4dHVyZS5fZGlydHlbZ2wuaWRdID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuICB0ZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyBhIFdlYkdMIHRleHR1cmVcbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVdlYkdMVGV4dHVyZVxuICogQHBhcmFtIHRleHR1cmUge1RleHR1cmV9IHRoZSB0ZXh0dXJlIHRvIHVwZGF0ZVxuICogQHBhcmFtIGdsIHt3ZWJnbENvbnRleHR9IHRoZSBXZWJHTCBjb250ZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLnVwZGF0ZVdlYkdMVGV4dHVyZSA9IGZ1bmN0aW9uKHRleHR1cmUsIGdsKVxue1xuICAgIGlmKCB0ZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSApXG4gICAge1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSk7XG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGV4dHVyZS5wcmVtdWx0aXBsaWVkQWxwaGEpO1xuXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGV4dHVyZS5zb3VyY2UpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGV4dHVyZS5zY2FsZU1vZGUgPT09IFBJWEkuc2NhbGVNb2Rlcy5MSU5FQVIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRleHR1cmUuc2NhbGVNb2RlID09PSBQSVhJLnNjYWxlTW9kZXMuTElORUFSID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVCk7XG5cbiAgICAgICAgLy8gcmVndWxlci4uLlxuXG4gICAgICAgIGlmKCF0ZXh0dXJlLl9wb3dlck9mMilcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLlJFUEVBVCk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5SRVBFQVQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dHVyZS5fZGlydHlbZ2wuaWRdID0gZmFsc2U7XG4gICAgfVxuICAgIFxufTtcblxuLyoqXG4gKiBIYW5kbGVzIGEgbG9zdCB3ZWJnbCBjb250ZXh0XG4gKlxuICogQG1ldGhvZCBoYW5kbGVDb250ZXh0TG9zdFxuICogQHBhcmFtIGV2ZW50IHtFdmVudH1cbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuaGFuZGxlQ29udGV4dExvc3QgPSBmdW5jdGlvbihldmVudClcbntcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuY29udGV4dExvc3QgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIGEgcmVzdG9yZWQgd2ViZ2wgY29udGV4dFxuICpcbiAqIEBtZXRob2QgaGFuZGxlQ29udGV4dFJlc3RvcmVkXG4gKiBAcGFyYW0gZXZlbnQge0V2ZW50fVxuICogQHByaXZhdGVcbiAqL1xuUElYSS5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5oYW5kbGVDb250ZXh0UmVzdG9yZWQgPSBmdW5jdGlvbigpXG57XG5cbiAgICAvL3RyeSAnZXhwZXJpbWVudGFsLXdlYmdsJ1xuICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZ2wgPSB0aGlzLnZpZXcuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgIHRoaXMub3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvL3RyeSAnd2ViZ2wnXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmdsID0gdGhpcy52aWV3LmdldENvbnRleHQoJ3dlYmdsJywgIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAvLyBmYWlsLCBub3QgYWJsZSB0byBnZXQgYSBjb250ZXh0XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyBUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB3ZWJHTC4gVHJ5IHVzaW5nIHRoZSBjYW52YXMgcmVuZGVyZXInICsgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLmlkID0gUElYSS5XZWJHTFJlbmRlcmVyLmdsQ29udGV4dElkICsrO1xuXG5cblxuICAgIC8vIG5lZWQgdG8gc2V0IHRoZSBjb250ZXh0Li4uXG4gICAgdGhpcy5zaGFkZXJNYW5hZ2VyLnNldENvbnRleHQoZ2wpO1xuICAgIHRoaXMuc3ByaXRlQmF0Y2guc2V0Q29udGV4dChnbCk7XG4gICAgdGhpcy5wcmltaXRpdmVCYXRjaC5zZXRDb250ZXh0KGdsKTtcbiAgICB0aGlzLm1hc2tNYW5hZ2VyLnNldENvbnRleHQoZ2wpO1xuICAgIHRoaXMuZmlsdGVyTWFuYWdlci5zZXRDb250ZXh0KGdsKTtcblxuXG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLmdsID0gdGhpcy5nbDtcblxuICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xuXG4gICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICBnbC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdGhpcy50cmFuc3BhcmVudCk7XG5cbiAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgIGZvcih2YXIga2V5IGluIFBJWEkuVGV4dHVyZUNhY2hlKVxuICAgIHtcbiAgICAgICAgdmFyIHRleHR1cmUgPSBQSVhJLlRleHR1cmVDYWNoZVtrZXldLmJhc2VUZXh0dXJlO1xuICAgICAgICB0ZXh0dXJlLl9nbFRleHR1cmVzID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY29udGV4dCB3YXMgbG9zdCBcbiAgICAgKiBAcHJvcGVydHkgY29udGV4dExvc3RcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0TG9zdCA9IGZhbHNlO1xuXG59O1xuXG4vKipcbiAqIFJlbW92ZXMgZXZlcnl0aGluZyBmcm9tIHRoZSByZW5kZXJlciAoZXZlbnQgbGlzdGVuZXJzLCBzcHJpdGViYXRjaCwgZXRjLi4uKVxuICpcbiAqIEBtZXRob2QgZGVzdHJveVxuICovXG5QSVhJLldlYkdMUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXG57XG5cbiAgICAvLyBkZWFsIHdpdGggbG9zaW5nIGNvbnRleHQuLlxuICAgIFxuICAgIC8vIHJlbW92ZSBsaXN0ZW5lcnNcbiAgICB0aGlzLnZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIHRoaXMuY29udGV4dExvc3QpO1xuICAgIHRoaXMudmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIHRoaXMuY29udGV4dFJlc3RvcmVkTG9zdCk7XG5cbiAgICBQSVhJLmdsQ29udGV4dHNbdGhpcy5nbENvbnRleHRJZF0gPSBudWxsO1xuXG4gICAgdGhpcy5wcm9qZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLm9mZnNldCA9IG51bGw7XG5cbiAgICAvLyB0aW1lIHRvIGNyZWF0ZSB0aGUgcmVuZGVyIG1hbmFnZXJzISBlYWNoIG9uZSBmb2N1c2VzIG9uIG1hbmFnaW5lIGEgc3RhdGUgaW4gd2ViR0xcbiAgICB0aGlzLnNoYWRlck1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuc3ByaXRlQmF0Y2guZGVzdHJveSgpO1xuICAgIHRoaXMucHJpbWl0aXZlQmF0Y2guZGVzdHJveSgpO1xuICAgIHRoaXMubWFza01hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuZmlsdGVyTWFuYWdlci5kZXN0cm95KCk7XG5cbiAgICB0aGlzLnNoYWRlck1hbmFnZXIgPSBudWxsO1xuICAgIHRoaXMuc3ByaXRlQmF0Y2ggPSBudWxsO1xuICAgIHRoaXMubWFza01hbmFnZXIgPSBudWxsO1xuICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IG51bGw7XG4gICAgXG4gICAgdGhpcy5nbCA9IG51bGw7XG4gICAgLy9cbiAgICB0aGlzLnJlbmRlclNlc3Npb24gPSBudWxsO1xufTtcblxuXG5QSVhJLldlYkdMUmVuZGVyZXIuZ2xDb250ZXh0SWQgPSAwO1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuKiBAY2xhc3MgV2ViR0xNYXNrTWFuYWdlclxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIGdsIHtXZWJHTENvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuKiBAcHJpdmF0ZVxuKi9cblBJWEkuV2ViR0xCbGVuZE1vZGVNYW5hZ2VyID0gZnVuY3Rpb24oZ2wpXG57XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMuY3VycmVudEJsZW5kTW9kZSA9IDk5OTk5O1xufTtcblxuLyoqXG4qIFNldHMtdXAgdGhlIGdpdmVuIGJsZW5kTW9kZSBmcm9tIFdlYkdMJ3MgcG9pbnQgb2Ygdmlld1xuKiBAbWV0aG9kIHNldEJsZW5kTW9kZSBcbipcbiogQHBhcmFtIGJsZW5kTW9kZSB7TnVtYmVyfSB0aGUgYmxlbmRNb2RlLCBzaG91bGQgYmUgYSBQaXhpIGNvbnN0LCBzdWNoIGFzIFBJWEkuQmxlbmRNb2Rlcy5BRERcbiovXG5QSVhJLldlYkdMQmxlbmRNb2RlTWFuYWdlci5wcm90b3R5cGUuc2V0QmxlbmRNb2RlID0gZnVuY3Rpb24oYmxlbmRNb2RlKVxue1xuICAgIGlmKHRoaXMuY3VycmVudEJsZW5kTW9kZSA9PT0gYmxlbmRNb2RlKXJldHVybiBmYWxzZTtcbiAvLyAgIGNvbnNvbGUubG9nKFwiU1dBUCFcIilcbiAgICB0aGlzLmN1cnJlbnRCbGVuZE1vZGUgPSBibGVuZE1vZGU7XG4gICAgXG4gICAgdmFyIGJsZW5kTW9kZVdlYkdMID0gUElYSS5ibGVuZE1vZGVzV2ViR0xbdGhpcy5jdXJyZW50QmxlbmRNb2RlXTtcbiAgICB0aGlzLmdsLmJsZW5kRnVuYyhibGVuZE1vZGVXZWJHTFswXSwgYmxlbmRNb2RlV2ViR0xbMV0pO1xuICAgIFxuICAgIHJldHVybiB0cnVlO1xufTtcblxuUElYSS5XZWJHTEJsZW5kTW9kZU1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5nbCA9IG51bGw7XG59O1xuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiogQGNsYXNzIFdlYkdMTWFza01hbmFnZXJcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSBnbCB7V2ViR0xDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiogQHByaXZhdGVcbiovXG5QSVhJLldlYkdMTWFza01hbmFnZXIgPSBmdW5jdGlvbihnbClcbntcbiAgICB0aGlzLm1hc2tTdGFjayA9IFtdO1xuICAgIHRoaXMubWFza1Bvc2l0aW9uID0gMDtcblxuICAgIHRoaXMuc2V0Q29udGV4dChnbCk7XG5cbiAgICB0aGlzLnJldmVyc2UgPSBmYWxzZTtcbiAgICB0aGlzLmNvdW50ID0gMDtcbn07XG5cbi8qKlxuKiBTZXRzIHRoZSBkcmF3aW5nIGNvbnRleHQgdG8gdGhlIG9uZSBnaXZlbiBpbiBwYXJhbWV0ZXJcbiogQG1ldGhvZCBzZXRDb250ZXh0IFxuKiBAcGFyYW0gZ2wge1dlYkdMQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4qL1xuUElYSS5XZWJHTE1hc2tNYW5hZ2VyLnByb3RvdHlwZS5zZXRDb250ZXh0ID0gZnVuY3Rpb24oZ2wpXG57XG4gICAgdGhpcy5nbCA9IGdsO1xufTtcblxuLyoqXG4qIEFwcGxpZXMgdGhlIE1hc2sgYW5kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgZmlsdGVyIHN0YWNrXG4qIEBtZXRob2QgcHVzaE1hc2tcbiogQHBhcmFtIG1hc2tEYXRhIHtBcnJheX1cbiogQHBhcmFtIHJlbmRlclNlc3Npb24ge1JlbmRlclNlc3Npb259XG4qL1xuUElYSS5XZWJHTE1hc2tNYW5hZ2VyLnByb3RvdHlwZS5wdXNoTWFzayA9IGZ1bmN0aW9uKG1hc2tEYXRhLCByZW5kZXJTZXNzaW9uKVxue1xuICAgIHZhciBnbCA9IHJlbmRlclNlc3Npb24uZ2w7XG5cbiAgICBpZihtYXNrRGF0YS5kaXJ0eSlcbiAgICB7XG4gICAgICAgIFBJWEkuV2ViR0xHcmFwaGljcy51cGRhdGVHcmFwaGljcyhtYXNrRGF0YSwgZ2wpO1xuICAgIH1cblxuICAgIGlmKCFtYXNrRGF0YS5fd2ViR0xbZ2wuaWRdLmRhdGEubGVuZ3RoKXJldHVybjtcblxuICAgIHJlbmRlclNlc3Npb24uc3RlbmNpbE1hbmFnZXIucHVzaFN0ZW5jaWwobWFza0RhdGEsIG1hc2tEYXRhLl93ZWJHTFtnbC5pZF0uZGF0YVswXSwgcmVuZGVyU2Vzc2lvbik7XG59O1xuXG4vKipcbiogUmVtb3ZlcyB0aGUgbGFzdCBmaWx0ZXIgZnJvbSB0aGUgZmlsdGVyIHN0YWNrIGFuZCBkb2Vzbid0IHJldHVybiBpdFxuKiBAbWV0aG9kIHBvcE1hc2tcbipcbiogQHBhcmFtIHJlbmRlclNlc3Npb24ge1JlbmRlclNlc3Npb259IGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgdXNlZnVsIHBhcmFtZXRlcnNcbiovXG5QSVhJLldlYkdMTWFza01hbmFnZXIucHJvdG90eXBlLnBvcE1hc2sgPSBmdW5jdGlvbihtYXNrRGF0YSwgcmVuZGVyU2Vzc2lvbilcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIHJlbmRlclNlc3Npb24uc3RlbmNpbE1hbmFnZXIucG9wU3RlbmNpbChtYXNrRGF0YSwgbWFza0RhdGEuX3dlYkdMW2dsLmlkXS5kYXRhWzBdLCByZW5kZXJTZXNzaW9uKTtcbn07XG5cblxuLyoqXG4qIERlc3Ryb3lzIHRoZSBtYXNrIHN0YWNrXG4qIEBtZXRob2QgZGVzdHJveVxuKi9cblBJWEkuV2ViR0xNYXNrTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLm1hc2tTdGFjayA9IG51bGw7XG4gICAgdGhpcy5nbCA9IG51bGw7XG59O1xuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuIFxuLy9CQTAyODVcbi8vSW50ZXJjb250aW5lbnRhbCBIb3RlbCwgODg4IEhvd2FyZCBTdHJlZXRcbi8vU2FuIEZyYW5jaXNjb1xuXG4vKipcbiogQGNsYXNzIFdlYkdMU3RlbmNpbE1hbmFnZXJcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSBnbCB7V2ViR0xDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiogQHByaXZhdGVcbiovXG5QSVhJLldlYkdMU3RlbmNpbE1hbmFnZXIgPSBmdW5jdGlvbihnbClcbntcbiAgIFxuICAgIHRoaXMuc3RlbmNpbFN0YWNrID0gW107XG4gICAgdGhpcy5zZXRDb250ZXh0KGdsKTtcbiAgICB0aGlzLnJldmVyc2UgPSB0cnVlO1xuICAgIHRoaXMuY291bnQgPSAwO1xuXG59O1xuXG4vKipcbiogU2V0cyB0aGUgZHJhd2luZyBjb250ZXh0IHRvIHRoZSBvbmUgZ2l2ZW4gaW4gcGFyYW1ldGVyXG4qIEBtZXRob2Qgc2V0Q29udGV4dCBcbiogQHBhcmFtIGdsIHtXZWJHTENvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuKi9cblBJWEkuV2ViR0xTdGVuY2lsTWFuYWdlci5wcm90b3R5cGUuc2V0Q29udGV4dCA9IGZ1bmN0aW9uKGdsKVxue1xuICAgIHRoaXMuZ2wgPSBnbDtcbn07XG5cbi8qKlxuKiBBcHBsaWVzIHRoZSBNYXNrIGFuZCBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IGZpbHRlciBzdGFja1xuKiBAbWV0aG9kIHB1c2hNYXNrXG4qIEBwYXJhbSBtYXNrRGF0YSB7QXJyYXl9XG4qIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtSZW5kZXJTZXNzaW9ufVxuKi9cblBJWEkuV2ViR0xTdGVuY2lsTWFuYWdlci5wcm90b3R5cGUucHVzaFN0ZW5jaWwgPSBmdW5jdGlvbihncmFwaGljcywgd2ViR0xEYXRhLCByZW5kZXJTZXNzaW9uKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgdGhpcy5iaW5kR3JhcGhpY3MoZ3JhcGhpY3MsIHdlYkdMRGF0YSwgcmVuZGVyU2Vzc2lvbik7XG5cbiAgICBpZih0aGlzLnN0ZW5jaWxTdGFjay5sZW5ndGggPT09IDApXG4gICAge1xuICAgICAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICAgICAgZ2wuY2xlYXIoZ2wuU1RFTkNJTF9CVUZGRVJfQklUKTtcbiAgICAgICAgdGhpcy5yZXZlcnNlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5zdGVuY2lsU3RhY2sucHVzaCh3ZWJHTERhdGEpO1xuXG4gICAgdmFyIGxldmVsID0gdGhpcy5jb3VudDtcblxuICAgIGdsLmNvbG9yTWFzayhmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG5cbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5BTFdBWVMsMCwweEZGKTtcbiAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLklOVkVSVCk7XG5cbiAgICAvLyBkcmF3IHRoZSB0cmlhbmdsZSBzdHJpcCFcblxuICAgIGlmKHdlYkdMRGF0YS5tb2RlID09PSAxKVxuICAgIHtcblxuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVfRkFOLCAgd2ViR0xEYXRhLmluZGljZXMubGVuZ3RoIC0gNCwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcbiAgICAgICBcbiAgICAgICAgaWYodGhpcy5yZXZlcnNlKVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHhGRiAtIGxldmVsLCAweEZGKTtcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuREVDUik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCxsZXZlbCwgMHhGRik7XG4gICAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLklOQ1IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZHJhdyBhIHF1YWQgdG8gaW5jcmVtZW50Li5cbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFX0ZBTiwgNCwgZ2wuVU5TSUdORURfU0hPUlQsICggd2ViR0xEYXRhLmluZGljZXMubGVuZ3RoIC0gNCApICogMiApO1xuICAgICAgICAgICAgICAgXG4gICAgICAgIGlmKHRoaXMucmV2ZXJzZSlcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsMHhGRi0obGV2ZWwrMSksIDB4RkYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsbGV2ZWwrMSwgMHhGRik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJldmVyc2UgPSAhdGhpcy5yZXZlcnNlO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBpZighdGhpcy5yZXZlcnNlKVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHhGRiAtIGxldmVsLCAweEZGKTtcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuREVDUik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCxsZXZlbCwgMHhGRik7XG4gICAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLklOQ1IpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFX1NUUklQLCAgd2ViR0xEYXRhLmluZGljZXMubGVuZ3RoLCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG4gICAgICAgIGlmKCF0aGlzLnJldmVyc2UpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLDB4RkYtKGxldmVsKzEpLCAweEZGKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLGxldmVsKzEsIDB4RkYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuS0VFUCk7XG5cbiAgICB0aGlzLmNvdW50Kys7XG59O1xuXG4vL1RPRE8gdGhpcyBkb2VzIG5vdCBiZWxvbmcgaGVyZSFcblBJWEkuV2ViR0xTdGVuY2lsTWFuYWdlci5wcm90b3R5cGUuYmluZEdyYXBoaWNzID0gZnVuY3Rpb24oZ3JhcGhpY3MsIHdlYkdMRGF0YSwgcmVuZGVyU2Vzc2lvbilcbntcbiAgICAvL2lmKHRoaXMuX2N1cnJlbnRHcmFwaGljcyA9PT0gZ3JhcGhpY3MpcmV0dXJuO1xuICAgIHRoaXMuX2N1cnJlbnRHcmFwaGljcyA9IGdyYXBoaWNzO1xuXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgICAvLyBiaW5kIHRoZSBncmFwaGljcyBvYmplY3QuLlxuICAgIHZhciBwcm9qZWN0aW9uID0gcmVuZGVyU2Vzc2lvbi5wcm9qZWN0aW9uLFxuICAgICAgICBvZmZzZXQgPSByZW5kZXJTZXNzaW9uLm9mZnNldCxcbiAgICAgICAgc2hhZGVyOy8vID0gcmVuZGVyU2Vzc2lvbi5zaGFkZXJNYW5hZ2VyLnByaW1pdGl2ZVNoYWRlcjtcblxuICAgIGlmKHdlYkdMRGF0YS5tb2RlID09PSAxKVxuICAgIHtcbiAgICAgICAgc2hhZGVyID0gcmVuZGVyU2Vzc2lvbi5zaGFkZXJNYW5hZ2VyLmNvbXBsZXhQcmltYXRpdmVTaGFkZXI7XG5cbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5zaGFkZXJNYW5hZ2VyLnNldFNoYWRlciggc2hhZGVyICk7XG5cbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihzaGFkZXIudHJhbnNsYXRpb25NYXRyaXgsIGZhbHNlLCBncmFwaGljcy53b3JsZFRyYW5zZm9ybS50b0FycmF5KHRydWUpKTtcblxuICAgICAgICBnbC51bmlmb3JtMmYoc2hhZGVyLnByb2plY3Rpb25WZWN0b3IsIHByb2plY3Rpb24ueCwgLXByb2plY3Rpb24ueSk7XG4gICAgICAgIGdsLnVuaWZvcm0yZihzaGFkZXIub2Zmc2V0VmVjdG9yLCAtb2Zmc2V0LngsIC1vZmZzZXQueSk7XG5cbiAgICAgICAgZ2wudW5pZm9ybTNmdihzaGFkZXIudGludENvbG9yLCBQSVhJLmhleDJyZ2IoZ3JhcGhpY3MudGludCkpO1xuICAgICAgICBnbC51bmlmb3JtM2Z2KHNoYWRlci5jb2xvciwgd2ViR0xEYXRhLmNvbG9yKTtcblxuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLmFscGhhLCBncmFwaGljcy53b3JsZEFscGhhICogd2ViR0xEYXRhLmFscGhhKTtcblxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgd2ViR0xEYXRhLmJ1ZmZlcik7XG5cbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYVZlcnRleFBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDQgKiAyLCAwKTtcblxuXG4gICAgICAgIC8vIG5vdyBkbyB0aGUgcmVzdC4uXG4gICAgICAgIC8vIHNldCB0aGUgaW5kZXggYnVmZmVyIVxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB3ZWJHTERhdGEuaW5kZXhCdWZmZXIpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICAvL3JlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlci5hY3RpdmF0ZVByaW1pdGl2ZVNoYWRlcigpO1xuICAgICAgICBzaGFkZXIgPSByZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIucHJpbWl0aXZlU2hhZGVyO1xuICAgICAgICByZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIuc2V0U2hhZGVyKCBzaGFkZXIgKTtcblxuICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHNoYWRlci50cmFuc2xhdGlvbk1hdHJpeCwgZmFsc2UsIGdyYXBoaWNzLndvcmxkVHJhbnNmb3JtLnRvQXJyYXkodHJ1ZSkpO1xuXG4gICAgICAgIGdsLnVuaWZvcm0yZihzaGFkZXIucHJvamVjdGlvblZlY3RvciwgcHJvamVjdGlvbi54LCAtcHJvamVjdGlvbi55KTtcbiAgICAgICAgZ2wudW5pZm9ybTJmKHNoYWRlci5vZmZzZXRWZWN0b3IsIC1vZmZzZXQueCwgLW9mZnNldC55KTtcblxuICAgICAgICBnbC51bmlmb3JtM2Z2KHNoYWRlci50aW50Q29sb3IsIFBJWEkuaGV4MnJnYihncmFwaGljcy50aW50KSk7XG5cbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci5hbHBoYSwgZ3JhcGhpY3Mud29ybGRBbHBoYSk7XG4gICAgICAgIFxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgd2ViR0xEYXRhLmJ1ZmZlcik7XG5cbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYVZlcnRleFBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDQgKiA2LCAwKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuY29sb3JBdHRyaWJ1dGUsIDQsIGdsLkZMT0FULCBmYWxzZSw0ICogNiwgMiAqIDQpO1xuXG4gICAgICAgIC8vIHNldCB0aGUgaW5kZXggYnVmZmVyIVxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB3ZWJHTERhdGEuaW5kZXhCdWZmZXIpO1xuICAgIH1cbn07XG5cblBJWEkuV2ViR0xTdGVuY2lsTWFuYWdlci5wcm90b3R5cGUucG9wU3RlbmNpbCA9IGZ1bmN0aW9uKGdyYXBoaWNzLCB3ZWJHTERhdGEsIHJlbmRlclNlc3Npb24pXG57XG5cdHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgdGhpcy5zdGVuY2lsU3RhY2sucG9wKCk7XG4gICBcbiAgICB0aGlzLmNvdW50LS07XG5cbiAgICBpZih0aGlzLnN0ZW5jaWxTdGFjay5sZW5ndGggPT09IDApXG4gICAge1xuICAgICAgICAvLyB0aGUgc3RhY2sgaXMgZW1wdHkhXG4gICAgICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcblxuICAgIH1cbiAgICBlbHNlXG4gICAge1xuXG4gICAgICAgIHZhciBsZXZlbCA9IHRoaXMuY291bnQ7XG5cbiAgICAgICAgdGhpcy5iaW5kR3JhcGhpY3MoZ3JhcGhpY3MsIHdlYkdMRGF0YSwgcmVuZGVyU2Vzc2lvbik7XG5cbiAgICAgICAgZ2wuY29sb3JNYXNrKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcbiAgICBcbiAgICAgICAgaWYod2ViR0xEYXRhLm1vZGUgPT09IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucmV2ZXJzZSA9ICF0aGlzLnJldmVyc2U7XG5cbiAgICAgICAgICAgIGlmKHRoaXMucmV2ZXJzZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHhGRiAtIChsZXZlbCsxKSwgMHhGRik7XG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsZ2wuS0VFUCxnbC5JTkNSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCxsZXZlbCsxLCAweEZGKTtcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLkRFQ1IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkcmF3IGEgcXVhZCB0byBpbmNyZW1lbnQuLlxuICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFX0ZBTiwgNCwgZ2wuVU5TSUdORURfU0hPUlQsICggd2ViR0xEYXRhLmluZGljZXMubGVuZ3RoIC0gNCApICogMiApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5BTFdBWVMsMCwweEZGKTtcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuSU5WRVJUKTtcblxuICAgICAgICAgICAgLy8gZHJhdyB0aGUgdHJpYW5nbGUgc3RyaXAhXG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVfRkFOLCAgd2ViR0xEYXRhLmluZGljZXMubGVuZ3RoIC0gNCwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcbiAgICAgICAgICAgXG4gICAgICAgICAgICBpZighdGhpcy5yZXZlcnNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLDB4RkYtKGxldmVsKSwgMHhGRik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsbGV2ZWwsIDB4RkYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgLy8gIGNvbnNvbGUubG9nKFwiPDw+PlwiKVxuICAgICAgICAgICAgaWYoIXRoaXMucmV2ZXJzZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHhGRiAtIChsZXZlbCsxKSwgMHhGRik7XG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsZ2wuS0VFUCxnbC5JTkNSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCxsZXZlbCsxLCAweEZGKTtcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLkRFQ1IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVfU1RSSVAsICB3ZWJHTERhdGEuaW5kaWNlcy5sZW5ndGgsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cbiAgICAgICAgICAgIGlmKCF0aGlzLnJldmVyc2UpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsMHhGRi0obGV2ZWwpLCAweEZGKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCxsZXZlbCwgMHhGRik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnbC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuS0VFUCk7XG5cblxuICAgIH1cblxuICAgIC8vcmVuZGVyU2Vzc2lvbi5zaGFkZXJNYW5hZ2VyLmRlYWN0aXZhdGVQcmltaXRpdmVTaGFkZXIoKTtcbn07XG5cbi8qKlxuKiBEZXN0cm95cyB0aGUgbWFzayBzdGFja1xuKiBAbWV0aG9kIGRlc3Ryb3lcbiovXG5QSVhJLldlYkdMU3RlbmNpbE1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5tYXNrU3RhY2sgPSBudWxsO1xuICAgIHRoaXMuZ2wgPSBudWxsO1xufTtcbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4qIEBjbGFzcyBXZWJHTFNoYWRlck1hbmFnZXJcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSBnbCB7V2ViR0xDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiogQHByaXZhdGVcbiovXG5QSVhJLldlYkdMU2hhZGVyTWFuYWdlciA9IGZ1bmN0aW9uKGdsKVxue1xuXG4gICAgdGhpcy5tYXhBdHRpYnMgPSAxMDtcbiAgICB0aGlzLmF0dHJpYlN0YXRlID0gW107XG4gICAgdGhpcy50ZW1wQXR0cmliU3RhdGUgPSBbXTtcbiAgICB0aGlzLnNoYWRlck1hcCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1heEF0dGliczsgaSsrKSB7XG4gICAgICAgIHRoaXMuYXR0cmliU3RhdGVbaV0gPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnNldENvbnRleHQoZ2wpO1xuICAgIC8vIHRoZSBmaW5hbCBvbmUgaXMgdXNlZCBmb3IgdGhlIHJlbmRlcmluZyBzdHJpcHNcbn07XG5cblxuLyoqXG4qIEluaXRpYWxpc2VzIHRoZSBjb250ZXh0IGFuZCB0aGUgcHJvcGVydGllc1xuKiBAbWV0aG9kIHNldENvbnRleHQgXG4qIEBwYXJhbSBnbCB7V2ViR0xDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiogQHBhcmFtIHRyYW5zcGFyZW50IHtCb29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgZHJhd2luZyBjb250ZXh0IHNob3VsZCBiZSB0cmFuc3BhcmVudFxuKi9cblBJWEkuV2ViR0xTaGFkZXJNYW5hZ2VyLnByb3RvdHlwZS5zZXRDb250ZXh0ID0gZnVuY3Rpb24oZ2wpXG57XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIFxuICAgIC8vIHRoZSBuZXh0IG9uZSBpcyB1c2VkIGZvciByZW5kZXJpbmcgcHJpbWF0aXZlc1xuICAgIHRoaXMucHJpbWl0aXZlU2hhZGVyID0gbmV3IFBJWEkuUHJpbWl0aXZlU2hhZGVyKGdsKTtcblxuICAgIC8vIHRoZSBuZXh0IG9uZSBpcyB1c2VkIGZvciByZW5kZXJpbmcgdHJpYW5nbGUgc3RyaXBzXG4gICAgdGhpcy5jb21wbGV4UHJpbWF0aXZlU2hhZGVyID0gbmV3IFBJWEkuQ29tcGxleFByaW1pdGl2ZVNoYWRlcihnbCk7XG5cbiAgICAvLyB0aGlzIHNoYWRlciBpcyB1c2VkIGZvciB0aGUgZGVmYXVsdCBzcHJpdGUgcmVuZGVyaW5nXG4gICAgdGhpcy5kZWZhdWx0U2hhZGVyID0gbmV3IFBJWEkuUGl4aVNoYWRlcihnbCk7XG5cbiAgICAvLyB0aGlzIHNoYWRlciBpcyB1c2VkIGZvciB0aGUgZmFzdCBzcHJpdGUgcmVuZGVyaW5nXG4gICAgdGhpcy5mYXN0U2hhZGVyID0gbmV3IFBJWEkuUGl4aUZhc3RTaGFkZXIoZ2wpO1xuXG4gICAgLy8gdGhlIG5leHQgb25lIGlzIHVzZWQgZm9yIHJlbmRlcmluZyB0cmlhbmdsZSBzdHJpcHNcbiAgICB0aGlzLnN0cmlwU2hhZGVyID0gbmV3IFBJWEkuU3RyaXBTaGFkZXIoZ2wpO1xuICAgIHRoaXMuc2V0U2hhZGVyKHRoaXMuZGVmYXVsdFNoYWRlcik7XG59O1xuXG5cbi8qKlxuKiBUYWtlcyB0aGUgYXR0cmlidXRlcyBnaXZlbiBpbiBwYXJhbWV0ZXJzIFxuKiBAbWV0aG9kIHNldEF0dHJpYnNcbiogQHBhcmFtIGF0dHJpYnMge0FycmF5fSBhdHRyaWJzIFxuKi9cblBJWEkuV2ViR0xTaGFkZXJNYW5hZ2VyLnByb3RvdHlwZS5zZXRBdHRyaWJzID0gZnVuY3Rpb24oYXR0cmlicylcbntcbiAgICAvLyByZXNldCB0ZW1wIHN0YXRlXG5cbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnRlbXBBdHRyaWJTdGF0ZS5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHRoaXMudGVtcEF0dHJpYlN0YXRlW2ldID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gc2V0IHRoZSBuZXcgYXR0cmlic1xuICAgIGZvciAoaSA9IDA7IGkgPCBhdHRyaWJzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGF0dHJpYklkID0gYXR0cmlic1tpXTtcbiAgICAgICAgdGhpcy50ZW1wQXR0cmliU3RhdGVbYXR0cmliSWRdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuYXR0cmliU3RhdGUubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpZih0aGlzLmF0dHJpYlN0YXRlW2ldICE9PSB0aGlzLnRlbXBBdHRyaWJTdGF0ZVtpXSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJTdGF0ZVtpXSA9IHRoaXMudGVtcEF0dHJpYlN0YXRlW2ldO1xuXG4gICAgICAgICAgICBpZih0aGlzLnRlbXBBdHRyaWJTdGF0ZVtpXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5QSVhJLldlYkdMU2hhZGVyTWFuYWdlci5wcm90b3R5cGUuc2V0U2hhZGVyID0gZnVuY3Rpb24oc2hhZGVyKVxue1xuICAgIGlmKHRoaXMuX2N1cnJlbnRJZCA9PT0gc2hhZGVyLl9VSUQpcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIHRoaXMuX2N1cnJlbnRJZCA9IHNoYWRlci5fVUlEO1xuXG4gICAgdGhpcy5jdXJyZW50U2hhZGVyID0gc2hhZGVyO1xuXG4gICAgdGhpcy5nbC51c2VQcm9ncmFtKHNoYWRlci5wcm9ncmFtKTtcbiAgICB0aGlzLnNldEF0dHJpYnMoc2hhZGVyLmF0dHJpYnV0ZXMpO1xuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiogRGVzdHJveXNcbiogQG1ldGhvZCBkZXN0cm95XG4qL1xuUElYSS5XZWJHTFNoYWRlck1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5hdHRyaWJTdGF0ZSA9IG51bGw7XG5cbiAgICB0aGlzLnRlbXBBdHRyaWJTdGF0ZSA9IG51bGw7XG5cbiAgICB0aGlzLnByaW1pdGl2ZVNoYWRlci5kZXN0cm95KCk7XG5cbiAgICB0aGlzLmRlZmF1bHRTaGFkZXIuZGVzdHJveSgpO1xuXG4gICAgdGhpcy5mYXN0U2hhZGVyLmRlc3Ryb3koKTtcblxuICAgIHRoaXMuc3RyaXBTaGFkZXIuZGVzdHJveSgpO1xuXG4gICAgdGhpcy5nbCA9IG51bGw7XG59O1xuXG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzXG4gKiBcbiAqIEJpZyB0aGFua3MgdG8gdGhlIHZlcnkgY2xldmVyIE1hdHQgRGVzTGF1cmllcnMgPG1hdHRkZXNsPiBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvXG4gKiBmb3IgY3JlYXRpbmcgdGhlIG9yaWdpbmFsIHBpeGkgdmVyc2lvbiFcbiAqXG4gKiBIZWF2aWx5IGluc3BpcmVkIGJ5IExpYkdEWCdzIFdlYkdMU3ByaXRlQmF0Y2g6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vbGliZ2R4L2xpYmdkeC9ibG9iL21hc3Rlci9nZHgvc3JjL2NvbS9iYWRsb2dpYy9nZHgvZ3JhcGhpY3MvZzJkL1dlYkdMU3ByaXRlQmF0Y2guamF2YVxuICovXG5cbiAvKipcbiAqXG4gKiBAY2xhc3MgV2ViR0xTcHJpdGVCYXRjaFxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGdsIHtXZWJHTENvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuICpcbiAqL1xuUElYSS5XZWJHTFNwcml0ZUJhdGNoID0gZnVuY3Rpb24oZ2wpXG57XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB2ZXJ0U2l6ZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMudmVydFNpemUgPSA2O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBpbWFnZXMgaW4gdGhlIFNwcml0ZUJhdGNoIGJlZm9yZSBpdCBmbHVzaGVzXG4gICAgICogQHByb3BlcnR5IHNpemVcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLnNpemUgPSAyMDAwOy8vTWF0aC5wb3coMiwgMTYpIC8gIHRoaXMudmVydFNpemU7XG5cbiAgICAvL3RoZSB0b3RhbCBudW1iZXIgb2YgZmxvYXRzIGluIG91ciBiYXRjaFxuICAgIHZhciBudW1WZXJ0cyA9IHRoaXMuc2l6ZSAqIDQgKiAgdGhpcy52ZXJ0U2l6ZTtcbiAgICAvL3RoZSB0b3RhbCBudW1iZXIgb2YgaW5kaWNlcyBpbiBvdXIgYmF0Y2hcbiAgICB2YXIgbnVtSW5kaWNlcyA9IHRoaXMuc2l6ZSAqIDY7XG5cbiAgICAvL3ZlcnRleCBkYXRhXG5cbiAgICAvKipcbiAgICAqIEhvbGRzIHRoZSB2ZXJ0aWNlc1xuICAgICpcbiAgICAqIEBwcm9wZXJ0eSB2ZXJ0aWNlc1xuICAgICogQHR5cGUgRmxvYXQzMkFycmF5XG4gICAgKi9cbiAgICB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShudW1WZXJ0cyk7XG5cbiAgICAvL2luZGV4IGRhdGFcbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgaW5kaWNlc1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IGluZGljZXNcbiAgICAgKiBAdHlwZSBVaW50MTZBcnJheVxuICAgICAqL1xuICAgIHRoaXMuaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShudW1JbmRpY2VzKTtcbiAgICBcbiAgICB0aGlzLmxhc3RJbmRleENvdW50ID0gMDtcblxuICAgIGZvciAodmFyIGk9MCwgaj0wOyBpIDwgbnVtSW5kaWNlczsgaSArPSA2LCBqICs9IDQpXG4gICAge1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDBdID0gaiArIDA7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgMV0gPSBqICsgMTtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyAyXSA9IGogKyAyO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDNdID0gaiArIDA7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgNF0gPSBqICsgMjtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyA1XSA9IGogKyAzO1xuICAgIH1cblxuXG4gICAgdGhpcy5kcmF3aW5nID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50QmF0Y2hTaXplID0gMDtcbiAgICB0aGlzLmN1cnJlbnRCYXNlVGV4dHVyZSA9IG51bGw7XG4gICAgXG4gICAgdGhpcy5zZXRDb250ZXh0KGdsKTtcblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgdGhpcy50ZXh0dXJlcyA9IFtdO1xuICAgIHRoaXMuYmxlbmRNb2RlcyA9IFtdO1xufTtcblxuLyoqXG4qIFxuKiBAbWV0aG9kIHNldENvbnRleHRcbipcbiogQHBhcmFtIGdsIHtXZWJHTENvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuKi9cblBJWEkuV2ViR0xTcHJpdGVCYXRjaC5wcm90b3R5cGUuc2V0Q29udGV4dCA9IGZ1bmN0aW9uKGdsKVxue1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIC8vIGNyZWF0ZSBhIGNvdXBsZSBvZiBidWZmZXJzXG4gICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICAvLyA2NTUzNSBpcyBtYXggaW5kZXgsIHNvIDY1NTM1IC8gNiA9IDEwOTIyLlxuXG5cbiAgICAvL3VwbG9hZCB0aGUgaW5kZXggZGF0YVxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kaWNlcywgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGV4QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0aWNlcywgZ2wuRFlOQU1JQ19EUkFXKTtcblxuICAgIHRoaXMuY3VycmVudEJsZW5kTW9kZSA9IDk5OTk5O1xufTtcblxuLyoqXG4qIFxuKiBAbWV0aG9kIGJlZ2luXG4qXG4qIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtSZW5kZXJTZXNzaW9ufSB0aGUgUmVuZGVyU2Vzc2lvblxuKi9cblBJWEkuV2ViR0xTcHJpdGVCYXRjaC5wcm90b3R5cGUuYmVnaW4gPSBmdW5jdGlvbihyZW5kZXJTZXNzaW9uKVxue1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbiA9IHJlbmRlclNlc3Npb247XG4gICAgdGhpcy5zaGFkZXIgPSB0aGlzLnJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlci5kZWZhdWx0U2hhZGVyO1xuXG4gICAgdGhpcy5zdGFydCgpO1xufTtcblxuLyoqXG4qIFxuKiBAbWV0aG9kIGVuZFxuKlxuKi9cblBJWEkuV2ViR0xTcHJpdGVCYXRjaC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuKiBcbiogQG1ldGhvZCByZW5kZXJcbiogXG4qIEBwYXJhbSBzcHJpdGUge1Nwcml0ZX0gdGhlIHNwcml0ZSB0byByZW5kZXIgd2hlbiB1c2luZyB0aGlzIHNwcml0ZWJhdGNoXG4qL1xuUElYSS5XZWJHTFNwcml0ZUJhdGNoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihzcHJpdGUpXG57XG4gICAgdmFyIHRleHR1cmUgPSBzcHJpdGUudGV4dHVyZTtcbiAgICBcbiAgIC8vVE9ETyBzZXQgYmxlbmQgbW9kZXMuLiBcbiAgICAvLyBjaGVjayB0ZXh0dXJlLi5cbiAgICBpZih0aGlzLmN1cnJlbnRCYXRjaFNpemUgPj0gdGhpcy5zaXplKVxuICAgIHtcbiAgICAgICAgLy9yZXR1cm47XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgdGhpcy5jdXJyZW50QmFzZVRleHR1cmUgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgIH1cblxuICAgIC8vIGdldCB0aGUgdXZzIGZvciB0aGUgdGV4dHVyZVxuICAgIHZhciB1dnMgPSB0ZXh0dXJlLl91dnM7XG4gICAgLy8gaWYgdGhlIHV2cyBoYXZlIG5vdCB1cGRhdGVkIHRoZW4gbm8gcG9pbnQgcmVuZGVyaW5nIGp1c3QgeWV0IVxuICAgIGlmKCF1dnMpcmV0dXJuO1xuXG4gICAgLy8gZ2V0IHRoZSBzcHJpdGVzIGN1cnJlbnQgYWxwaGFcbiAgICB2YXIgYWxwaGEgPSBzcHJpdGUud29ybGRBbHBoYTtcbiAgICB2YXIgdGludCA9IHNwcml0ZS50aW50O1xuXG4gICAgdmFyIHZlcnRpY2llcyA9IHRoaXMudmVydGljZXM7XG5cblxuICAgIC8vIFRPRE8gdHJpbT8/XG4gICAgdmFyIGFYID0gc3ByaXRlLmFuY2hvci54O1xuICAgIHZhciBhWSA9IHNwcml0ZS5hbmNob3IueTtcblxuICAgIHZhciB3MCwgdzEsIGgwLCBoMTtcbiAgICAgICAgXG4gICAgaWYgKHRleHR1cmUudHJpbSlcbiAgICB7XG4gICAgICAgIC8vIGlmIHRoZSBzcHJpdGUgaXMgdHJpbW1lZCB0aGVuIHdlIG5lZWQgdG8gYWRkIHRoZSBleHRyYSBzcGFjZSBiZWZvcmUgdHJhbnNmb3JtaW5nIHRoZSBzcHJpdGUgY29vcmRzLi5cbiAgICAgICAgdmFyIHRyaW0gPSB0ZXh0dXJlLnRyaW07XG5cbiAgICAgICAgdzEgPSB0cmltLnggLSBhWCAqIHRyaW0ud2lkdGg7XG4gICAgICAgIHcwID0gdzEgKyB0ZXh0dXJlLmNyb3Aud2lkdGg7XG5cbiAgICAgICAgaDEgPSB0cmltLnkgLSBhWSAqIHRyaW0uaGVpZ2h0O1xuICAgICAgICBoMCA9IGgxICsgdGV4dHVyZS5jcm9wLmhlaWdodDtcblxuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB3MCA9ICh0ZXh0dXJlLmZyYW1lLndpZHRoICkgKiAoMS1hWCk7XG4gICAgICAgIHcxID0gKHRleHR1cmUuZnJhbWUud2lkdGggKSAqIC1hWDtcblxuICAgICAgICBoMCA9IHRleHR1cmUuZnJhbWUuaGVpZ2h0ICogKDEtYVkpO1xuICAgICAgICBoMSA9IHRleHR1cmUuZnJhbWUuaGVpZ2h0ICogLWFZO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IHRoaXMuY3VycmVudEJhdGNoU2l6ZSAqIDQgKiB0aGlzLnZlcnRTaXplO1xuXG4gICAgdmFyIHdvcmxkVHJhbnNmb3JtID0gc3ByaXRlLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgdmFyIGEgPSB3b3JsZFRyYW5zZm9ybS5hOy8vWzBdO1xuICAgIHZhciBiID0gd29ybGRUcmFuc2Zvcm0uYzsvL1szXTtcbiAgICB2YXIgYyA9IHdvcmxkVHJhbnNmb3JtLmI7Ly9bMV07XG4gICAgdmFyIGQgPSB3b3JsZFRyYW5zZm9ybS5kOy8vWzRdO1xuICAgIHZhciB0eCA9IHdvcmxkVHJhbnNmb3JtLnR4Oy8vWzJdO1xuICAgIHZhciB0eSA9IHdvcmxkVHJhbnNmb3JtLnR5Oy8vL1s1XTtcblxuICAgIC8vIHh5XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gYSAqIHcxICsgYyAqIGgxICsgdHg7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gZCAqIGgxICsgYiAqIHcxICsgdHk7XG4gICAgLy8gdXZcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueDA7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdXZzLnkwO1xuICAgIC8vIGNvbG9yXG4gICAgdmVydGljaWVzW2luZGV4KytdID0gYWxwaGE7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdGludDtcblxuICAgIC8vIHh5XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gYSAqIHcwICsgYyAqIGgxICsgdHg7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gZCAqIGgxICsgYiAqIHcwICsgdHk7XG4gICAgLy8gdXZcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueDE7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdXZzLnkxO1xuICAgIC8vIGNvbG9yXG4gICAgdmVydGljaWVzW2luZGV4KytdID0gYWxwaGE7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdGludDtcblxuICAgIC8vIHh5XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gYSAqIHcwICsgYyAqIGgwICsgdHg7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gZCAqIGgwICsgYiAqIHcwICsgdHk7XG4gICAgLy8gdXZcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueDI7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdXZzLnkyO1xuICAgIC8vIGNvbG9yXG4gICAgdmVydGljaWVzW2luZGV4KytdID0gYWxwaGE7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdGludDtcblxuICAgIC8vIHh5XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gYSAqIHcxICsgYyAqIGgwICsgdHg7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gZCAqIGgwICsgYiAqIHcxICsgdHk7XG4gICAgLy8gdXZcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueDM7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdXZzLnkzO1xuICAgIC8vIGNvbG9yXG4gICAgdmVydGljaWVzW2luZGV4KytdID0gYWxwaGE7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdGludDtcbiAgICBcbiAgICAvLyBpbmNyZW1lbnQgdGhlIGJhdGNoc2l6ZVxuICAgIHRoaXMudGV4dHVyZXNbdGhpcy5jdXJyZW50QmF0Y2hTaXplXSA9IHNwcml0ZS50ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgIHRoaXMuYmxlbmRNb2Rlc1t0aGlzLmN1cnJlbnRCYXRjaFNpemVdID0gc3ByaXRlLmJsZW5kTW9kZTtcblxuICAgIHRoaXMuY3VycmVudEJhdGNoU2l6ZSsrO1xuXG59O1xuXG4vKipcbiogUmVuZGVycyBhIHRpbGluZ1Nwcml0ZSB1c2luZyB0aGUgc3ByaXRlQmF0Y2hcbiogQG1ldGhvZCByZW5kZXJUaWxpbmdTcHJpdGVcbiogXG4qIEBwYXJhbSBzcHJpdGUge1RpbGluZ1Nwcml0ZX0gdGhlIHRpbGluZ1Nwcml0ZSB0byByZW5kZXJcbiovXG5QSVhJLldlYkdMU3ByaXRlQmF0Y2gucHJvdG90eXBlLnJlbmRlclRpbGluZ1Nwcml0ZSA9IGZ1bmN0aW9uKHRpbGluZ1Nwcml0ZSlcbntcbiAgICB2YXIgdGV4dHVyZSA9IHRpbGluZ1Nwcml0ZS50aWxpbmdUZXh0dXJlO1xuXG4gICAgXG4gICAgLy8gY2hlY2sgdGV4dHVyZS4uXG4gICAgaWYodGhpcy5jdXJyZW50QmF0Y2hTaXplID49IHRoaXMuc2l6ZSlcbiAgICB7XG4gICAgICAgIC8vcmV0dXJuO1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIHRoaXMuY3VycmVudEJhc2VUZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICB9XG5cbiAgICAgLy8gc2V0IHRoZSB0ZXh0dXJlcyB1dnMgdGVtcG9yYXJpbHlcbiAgICAvLyBUT0RPIGNyZWF0ZSBhIHNlcGFyYXRlIHRleHR1cmUgc28gdGhhdCB3ZSBjYW4gdGlsZSBwYXJ0IG9mIGEgdGV4dHVyZVxuXG4gICAgaWYoIXRpbGluZ1Nwcml0ZS5fdXZzKXRpbGluZ1Nwcml0ZS5fdXZzID0gbmV3IFBJWEkuVGV4dHVyZVV2cygpO1xuXG4gICAgdmFyIHV2cyA9IHRpbGluZ1Nwcml0ZS5fdXZzO1xuXG4gICAgdGlsaW5nU3ByaXRlLnRpbGVQb3NpdGlvbi54ICU9IHRleHR1cmUuYmFzZVRleHR1cmUud2lkdGggKiB0aWxpbmdTcHJpdGUudGlsZVNjYWxlT2Zmc2V0Lng7XG4gICAgdGlsaW5nU3ByaXRlLnRpbGVQb3NpdGlvbi55ICU9IHRleHR1cmUuYmFzZVRleHR1cmUuaGVpZ2h0ICogdGlsaW5nU3ByaXRlLnRpbGVTY2FsZU9mZnNldC55O1xuXG4gICAgdmFyIG9mZnNldFggPSAgdGlsaW5nU3ByaXRlLnRpbGVQb3NpdGlvbi54Lyh0ZXh0dXJlLmJhc2VUZXh0dXJlLndpZHRoKnRpbGluZ1Nwcml0ZS50aWxlU2NhbGVPZmZzZXQueCk7XG4gICAgdmFyIG9mZnNldFkgPSAgdGlsaW5nU3ByaXRlLnRpbGVQb3NpdGlvbi55Lyh0ZXh0dXJlLmJhc2VUZXh0dXJlLmhlaWdodCp0aWxpbmdTcHJpdGUudGlsZVNjYWxlT2Zmc2V0LnkpO1xuXG4gICAgdmFyIHNjYWxlWCA9ICAodGlsaW5nU3ByaXRlLndpZHRoIC8gdGV4dHVyZS5iYXNlVGV4dHVyZS53aWR0aCkgIC8gKHRpbGluZ1Nwcml0ZS50aWxlU2NhbGUueCAqIHRpbGluZ1Nwcml0ZS50aWxlU2NhbGVPZmZzZXQueCk7XG4gICAgdmFyIHNjYWxlWSA9ICAodGlsaW5nU3ByaXRlLmhlaWdodCAvIHRleHR1cmUuYmFzZVRleHR1cmUuaGVpZ2h0KSAvICh0aWxpbmdTcHJpdGUudGlsZVNjYWxlLnkgKiB0aWxpbmdTcHJpdGUudGlsZVNjYWxlT2Zmc2V0LnkpO1xuXG4gICAgdXZzLngwID0gMCAtIG9mZnNldFg7XG4gICAgdXZzLnkwID0gMCAtIG9mZnNldFk7XG5cbiAgICB1dnMueDEgPSAoMSAqIHNjYWxlWCkgLSBvZmZzZXRYO1xuICAgIHV2cy55MSA9IDAgLSBvZmZzZXRZO1xuXG4gICAgdXZzLngyID0gKDEgKiBzY2FsZVgpIC0gb2Zmc2V0WDtcbiAgICB1dnMueTIgPSAoMSAqIHNjYWxlWSkgLSBvZmZzZXRZO1xuXG4gICAgdXZzLngzID0gMCAtIG9mZnNldFg7XG4gICAgdXZzLnkzID0gKDEgKnNjYWxlWSkgLSBvZmZzZXRZO1xuXG4gICAgLy8gZ2V0IHRoZSB0aWxpbmdTcHJpdGVzIGN1cnJlbnQgYWxwaGFcbiAgICB2YXIgYWxwaGEgPSB0aWxpbmdTcHJpdGUud29ybGRBbHBoYTtcbiAgICB2YXIgdGludCA9IHRpbGluZ1Nwcml0ZS50aW50O1xuXG4gICAgdmFyICB2ZXJ0aWNpZXMgPSB0aGlzLnZlcnRpY2VzO1xuXG4gICAgdmFyIHdpZHRoID0gdGlsaW5nU3ByaXRlLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSB0aWxpbmdTcHJpdGUuaGVpZ2h0O1xuXG4gICAgLy8gVE9ETyB0cmltPz9cbiAgICB2YXIgYVggPSB0aWxpbmdTcHJpdGUuYW5jaG9yLng7XG4gICAgdmFyIGFZID0gdGlsaW5nU3ByaXRlLmFuY2hvci55O1xuICAgIHZhciB3MCA9IHdpZHRoICogKDEtYVgpO1xuICAgIHZhciB3MSA9IHdpZHRoICogLWFYO1xuXG4gICAgdmFyIGgwID0gaGVpZ2h0ICogKDEtYVkpO1xuICAgIHZhciBoMSA9IGhlaWdodCAqIC1hWTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuY3VycmVudEJhdGNoU2l6ZSAqIDQgKiB0aGlzLnZlcnRTaXplO1xuXG4gICAgdmFyIHdvcmxkVHJhbnNmb3JtID0gdGlsaW5nU3ByaXRlLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgdmFyIGEgPSB3b3JsZFRyYW5zZm9ybS5hOy8vWzBdO1xuICAgIHZhciBiID0gd29ybGRUcmFuc2Zvcm0uYzsvL1szXTtcbiAgICB2YXIgYyA9IHdvcmxkVHJhbnNmb3JtLmI7Ly9bMV07XG4gICAgdmFyIGQgPSB3b3JsZFRyYW5zZm9ybS5kOy8vWzRdO1xuICAgIHZhciB0eCA9IHdvcmxkVHJhbnNmb3JtLnR4Oy8vWzJdO1xuICAgIHZhciB0eSA9IHdvcmxkVHJhbnNmb3JtLnR5Oy8vL1s1XTtcblxuICAgIC8vIHh5XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gYSAqIHcxICsgYyAqIGgxICsgdHg7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gZCAqIGgxICsgYiAqIHcxICsgdHk7XG4gICAgLy8gdXZcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueDA7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdXZzLnkwO1xuICAgIC8vIGNvbG9yXG4gICAgdmVydGljaWVzW2luZGV4KytdID0gYWxwaGE7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdGludDtcblxuICAgIC8vIHh5XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gKGEgKiB3MCArIGMgKiBoMSArIHR4KTtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBkICogaDEgKyBiICogdzAgKyB0eTtcbiAgICAvLyB1dlxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy54MTtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueTE7XG4gICAgLy8gY29sb3JcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhbHBoYTtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB0aW50O1xuICAgIFxuICAgIC8vIHh5XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gYSAqIHcwICsgYyAqIGgwICsgdHg7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gZCAqIGgwICsgYiAqIHcwICsgdHk7XG4gICAgLy8gdXZcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueDI7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdXZzLnkyO1xuICAgIC8vIGNvbG9yXG4gICAgdmVydGljaWVzW2luZGV4KytdID0gYWxwaGE7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdGludDtcblxuICAgIC8vIHh5XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gYSAqIHcxICsgYyAqIGgwICsgdHg7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gZCAqIGgwICsgYiAqIHcxICsgdHk7XG4gICAgLy8gdXZcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueDM7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdXZzLnkzO1xuICAgIC8vIGNvbG9yXG4gICAgdmVydGljaWVzW2luZGV4KytdID0gYWxwaGE7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdGludDtcblxuICAgIC8vIGluY3JlbWVudCB0aGUgYmF0Y2hzXG4gICAgdGhpcy50ZXh0dXJlc1t0aGlzLmN1cnJlbnRCYXRjaFNpemVdID0gdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICB0aGlzLmJsZW5kTW9kZXNbdGhpcy5jdXJyZW50QmF0Y2hTaXplXSA9IHRpbGluZ1Nwcml0ZS5ibGVuZE1vZGU7XG4gICAgdGhpcy5jdXJyZW50QmF0Y2hTaXplKys7XG59O1xuXG5cbi8qKlxuKiBSZW5kZXJzIHRoZSBjb250ZW50IGFuZCBlbXB0aWVzIHRoZSBjdXJyZW50IGJhdGNoXG4qXG4qIEBtZXRob2QgZmx1c2hcbiogXG4qL1xuUElYSS5XZWJHTFNwcml0ZUJhdGNoLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKClcbntcbiAgICAvLyBJZiB0aGUgYmF0Y2ggaXMgbGVuZ3RoIDAgdGhlbiByZXR1cm4gYXMgdGhlcmUgaXMgbm90aGluZyB0byBkcmF3XG4gICAgaWYgKHRoaXMuY3VycmVudEJhdGNoU2l6ZT09PTApcmV0dXJuO1xuXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5zaGFkZXJNYW5hZ2VyLnNldFNoYWRlcih0aGlzLnJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlci5kZWZhdWx0U2hhZGVyKTtcblxuICAgIGlmKHRoaXMuZGlydHkpXG4gICAge1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIC8vIGJpbmQgdGhlIG1haW4gdGV4dHVyZVxuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcblxuICAgICAgICAvLyBiaW5kIHRoZSBidWZmZXJzXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRleEJ1ZmZlcik7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXIpO1xuXG4gICAgICAgIC8vIHNldCB0aGUgcHJvamVjdGlvblxuICAgICAgICB2YXIgcHJvamVjdGlvbiA9IHRoaXMucmVuZGVyU2Vzc2lvbi5wcm9qZWN0aW9uO1xuICAgICAgICBnbC51bmlmb3JtMmYodGhpcy5zaGFkZXIucHJvamVjdGlvblZlY3RvciwgcHJvamVjdGlvbi54LCBwcm9qZWN0aW9uLnkpO1xuXG4gICAgICAgIC8vIHNldCB0aGUgcG9pbnRlcnNcbiAgICAgICAgdmFyIHN0cmlkZSA9ICB0aGlzLnZlcnRTaXplICogNDtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnNoYWRlci5hVmVydGV4UG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgc3RyaWRlLCAwKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnNoYWRlci5hVGV4dHVyZUNvb3JkLCAyLCBnbC5GTE9BVCwgZmFsc2UsIHN0cmlkZSwgMiAqIDQpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuc2hhZGVyLmNvbG9yQXR0cmlidXRlLCAyLCBnbC5GTE9BVCwgZmFsc2UsIHN0cmlkZSwgNCAqIDQpO1xuXG4gICAgfVxuXG4gICAgLy8gdXBsb2FkIHRoZSB2ZXJ0cyB0byB0aGUgYnVmZmVyICBcbiAgICBpZih0aGlzLmN1cnJlbnRCYXRjaFNpemUgPiAoIHRoaXMuc2l6ZSAqIDAuNSApIClcbiAgICB7XG4gICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB0aGlzLnZlcnRpY2VzKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZlcnRpY2VzLnN1YmFycmF5KDAsIHRoaXMuY3VycmVudEJhdGNoU2l6ZSAqIDQgKiB0aGlzLnZlcnRTaXplKTtcbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHZpZXcpO1xuICAgIH1cblxuICAgIHZhciBuZXh0VGV4dHVyZSwgbmV4dEJsZW5kTW9kZTtcbiAgICB2YXIgYmF0Y2hTaXplID0gMDtcbiAgICB2YXIgc3RhcnQgPSAwO1xuXG4gICAgdmFyIGN1cnJlbnRCYXNlVGV4dHVyZSA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRCbGVuZE1vZGUgPSB0aGlzLnJlbmRlclNlc3Npb24uYmxlbmRNb2RlTWFuYWdlci5jdXJyZW50QmxlbmRNb2RlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmN1cnJlbnRCYXRjaFNpemU7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgXG4gICAgICAgIG5leHRUZXh0dXJlID0gdGhpcy50ZXh0dXJlc1tpXTtcbiAgICAgICAgbmV4dEJsZW5kTW9kZSA9IHRoaXMuYmxlbmRNb2Rlc1tpXTtcblxuICAgICAgICBpZihjdXJyZW50QmFzZVRleHR1cmUgIT09IG5leHRUZXh0dXJlIHx8IGN1cnJlbnRCbGVuZE1vZGUgIT09IG5leHRCbGVuZE1vZGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQmF0Y2goY3VycmVudEJhc2VUZXh0dXJlLCBiYXRjaFNpemUsIHN0YXJ0KTtcblxuICAgICAgICAgICAgc3RhcnQgPSBpO1xuICAgICAgICAgICAgYmF0Y2hTaXplID0gMDtcbiAgICAgICAgICAgIGN1cnJlbnRCYXNlVGV4dHVyZSA9IG5leHRUZXh0dXJlO1xuICAgICAgICAgICAgY3VycmVudEJsZW5kTW9kZSA9IG5leHRCbGVuZE1vZGU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5ibGVuZE1vZGVNYW5hZ2VyLnNldEJsZW5kTW9kZSggY3VycmVudEJsZW5kTW9kZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgYmF0Y2hTaXplKys7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJCYXRjaChjdXJyZW50QmFzZVRleHR1cmUsIGJhdGNoU2l6ZSwgc3RhcnQpO1xuXG4gICAgLy8gdGhlbiByZXNldCB0aGUgYmF0Y2ghXG4gICAgdGhpcy5jdXJyZW50QmF0Y2hTaXplID0gMDtcbn07XG5cblBJWEkuV2ViR0xTcHJpdGVCYXRjaC5wcm90b3R5cGUucmVuZGVyQmF0Y2ggPSBmdW5jdGlvbih0ZXh0dXJlLCBzaXplLCBzdGFydEluZGV4KVxue1xuICAgIGlmKHNpemUgPT09IDApcmV0dXJuO1xuXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAvLyBiaW5kIHRoZSBjdXJyZW50IHRleHR1cmVcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSB8fCBQSVhJLmNyZWF0ZVdlYkdMVGV4dHVyZSh0ZXh0dXJlLCBnbCkpO1xuXG4gICAgLy8gY2hlY2sgaWYgYSB0ZXh0dXJlIGlzIGRpcnR5Li5cbiAgICBpZih0ZXh0dXJlLl9kaXJ0eVtnbC5pZF0pXG4gICAge1xuICAgICAgICBQSVhJLnVwZGF0ZVdlYkdMVGV4dHVyZSh0aGlzLmN1cnJlbnRCYXNlVGV4dHVyZSwgZ2wpO1xuICAgIH1cblxuICAgIC8vIG5vdyBkcmF3IHRob3NlIHN1Y2thcyFcbiAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBzaXplICogNiwgZ2wuVU5TSUdORURfU0hPUlQsIHN0YXJ0SW5kZXggKiA2ICogMik7XG4gICAgXG4gICAgLy8gaW5jcmVtZW50IHRoZSBkcmF3IGNvdW50XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLmRyYXdDb3VudCsrO1xufTtcblxuLyoqXG4qIFxuKiBAbWV0aG9kIHN0b3BcbipcbiovXG5QSVhJLldlYkdMU3ByaXRlQmF0Y2gucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5mbHVzaCgpO1xufTtcblxuLyoqXG4qIFxuKiBAbWV0aG9kIHN0YXJ0XG4qXG4qL1xuUElYSS5XZWJHTFNwcml0ZUJhdGNoLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbn07XG5cbi8qKlxuKiBEZXN0cm95cyB0aGUgU3ByaXRlQmF0Y2hcbiogQG1ldGhvZCBkZXN0cm95XG4qL1xuUElYSS5XZWJHTFNwcml0ZUJhdGNoLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxue1xuXG4gICAgdGhpcy52ZXJ0aWNlcyA9IG51bGw7XG4gICAgdGhpcy5pbmRpY2VzID0gbnVsbDtcbiAgICBcbiAgICB0aGlzLmdsLmRlbGV0ZUJ1ZmZlciggdGhpcy52ZXJ0ZXhCdWZmZXIgKTtcbiAgICB0aGlzLmdsLmRlbGV0ZUJ1ZmZlciggdGhpcy5pbmRleEJ1ZmZlciApO1xuICAgIFxuICAgIHRoaXMuY3VycmVudEJhc2VUZXh0dXJlID0gbnVsbDtcbiAgICBcbiAgICB0aGlzLmdsID0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXNcbiAqIFxuICogQmlnIHRoYW5rcyB0byB0aGUgdmVyeSBjbGV2ZXIgTWF0dCBEZXNMYXVyaWVycyA8bWF0dGRlc2w+IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbC9cbiAqIGZvciBjcmVhdGluZyB0aGUgb3JpZ2luYWwgcGl4aSB2ZXJzaW9uIVxuICpcbiAqIEhlYXZpbHkgaW5zcGlyZWQgYnkgTGliR0RYJ3MgV2ViR0xTcHJpdGVCYXRjaDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9saWJnZHgvbGliZ2R4L2Jsb2IvbWFzdGVyL2dkeC9zcmMvY29tL2JhZGxvZ2ljL2dkeC9ncmFwaGljcy9nMmQvV2ViR0xTcHJpdGVCYXRjaC5qYXZhXG4gKi9cblxuUElYSS5XZWJHTEZhc3RTcHJpdGVCYXRjaCA9IGZ1bmN0aW9uKGdsKVxue1xuICAgXG5cbiAgICB0aGlzLnZlcnRTaXplID0gMTA7XG4gICAgdGhpcy5tYXhTaXplID0gNjAwMDsvL01hdGgucG93KDIsIDE2KSAvICB0aGlzLnZlcnRTaXplO1xuICAgIHRoaXMuc2l6ZSA9IHRoaXMubWF4U2l6ZTtcblxuICAgIC8vdGhlIHRvdGFsIG51bWJlciBvZiBmbG9hdHMgaW4gb3VyIGJhdGNoXG4gICAgdmFyIG51bVZlcnRzID0gdGhpcy5zaXplICogNCAqICB0aGlzLnZlcnRTaXplO1xuICAgIC8vdGhlIHRvdGFsIG51bWJlciBvZiBpbmRpY2VzIGluIG91ciBiYXRjaFxuICAgIHZhciBudW1JbmRpY2VzID0gdGhpcy5tYXhTaXplICogNjtcblxuICAgICAvL3ZlcnRleCBkYXRhXG4gICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkobnVtVmVydHMpO1xuICAgIC8vaW5kZXggZGF0YVxuICAgIHRoaXMuaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShudW1JbmRpY2VzKTtcbiAgICBcbiAgICB0aGlzLnZlcnRleEJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGw7XG5cbiAgICB0aGlzLmxhc3RJbmRleENvdW50ID0gMDtcblxuICAgIGZvciAodmFyIGk9MCwgaj0wOyBpIDwgbnVtSW5kaWNlczsgaSArPSA2LCBqICs9IDQpXG4gICAge1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDBdID0gaiArIDA7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgMV0gPSBqICsgMTtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyAyXSA9IGogKyAyO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDNdID0gaiArIDA7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgNF0gPSBqICsgMjtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyA1XSA9IGogKyAzO1xuICAgIH1cblxuICAgIHRoaXMuZHJhd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudEJhdGNoU2l6ZSA9IDA7XG4gICAgdGhpcy5jdXJyZW50QmFzZVRleHR1cmUgPSBudWxsO1xuICAgXG4gICAgdGhpcy5jdXJyZW50QmxlbmRNb2RlID0gMDtcbiAgICB0aGlzLnJlbmRlclNlc3Npb24gPSBudWxsO1xuICAgIFxuXG4gICAgdGhpcy5zaGFkZXIgPSBudWxsO1xuXG4gICAgdGhpcy5tYXRyaXggPSBudWxsO1xuXG4gICAgdGhpcy5zZXRDb250ZXh0KGdsKTtcbn07XG5cblBJWEkuV2ViR0xGYXN0U3ByaXRlQmF0Y2gucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbihnbClcbntcbiAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAvLyBjcmVhdGUgYSBjb3VwbGUgb2YgYnVmZmVyc1xuICAgIHRoaXMudmVydGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgLy8gNjU1MzUgaXMgbWF4IGluZGV4LCBzbyA2NTUzNSAvIDYgPSAxMDkyMi5cblxuXG4gICAgLy91cGxvYWQgdGhlIGluZGV4IGRhdGFcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGljZXMsIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRleEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGljZXMsIGdsLkRZTkFNSUNfRFJBVyk7XG59O1xuXG5QSVhJLldlYkdMRmFzdFNwcml0ZUJhdGNoLnByb3RvdHlwZS5iZWdpbiA9IGZ1bmN0aW9uKHNwcml0ZUJhdGNoLCByZW5kZXJTZXNzaW9uKVxue1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbiA9IHJlbmRlclNlc3Npb247XG4gICAgdGhpcy5zaGFkZXIgPSB0aGlzLnJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlci5mYXN0U2hhZGVyO1xuXG4gICAgdGhpcy5tYXRyaXggPSBzcHJpdGVCYXRjaC53b3JsZFRyYW5zZm9ybS50b0FycmF5KHRydWUpO1xuXG4gICAgdGhpcy5zdGFydCgpO1xufTtcblxuUElYSS5XZWJHTEZhc3RTcHJpdGVCYXRjaC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuZmx1c2goKTtcbn07XG5cblxuUElYSS5XZWJHTEZhc3RTcHJpdGVCYXRjaC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oc3ByaXRlQmF0Y2gpXG57XG5cbiAgICB2YXIgY2hpbGRyZW4gPSBzcHJpdGVCYXRjaC5jaGlsZHJlbjtcbiAgICB2YXIgc3ByaXRlID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGUgdXZzIGhhdmUgbm90IHVwZGF0ZWQgdGhlbiBubyBwb2ludCByZW5kZXJpbmcganVzdCB5ZXQhXG4gICAgXG4gICAgLy8gY2hlY2sgdGV4dHVyZS5cbiAgICBpZighc3ByaXRlLnRleHR1cmUuX3V2cylyZXR1cm47XG4gICBcbiAgICB0aGlzLmN1cnJlbnRCYXNlVGV4dHVyZSA9IHNwcml0ZS50ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgIFxuICAgIC8vIGNoZWNrIGJsZW5kIG1vZGVcbiAgICBpZihzcHJpdGUuYmxlbmRNb2RlICE9PSB0aGlzLnJlbmRlclNlc3Npb24uYmxlbmRNb2RlTWFuYWdlci5jdXJyZW50QmxlbmRNb2RlKVxuICAgIHtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB0aGlzLnJlbmRlclNlc3Npb24uYmxlbmRNb2RlTWFuYWdlci5zZXRCbGVuZE1vZGUoc3ByaXRlLmJsZW5kTW9kZSk7XG4gICAgfVxuICAgIFxuICAgIGZvcih2YXIgaT0wLGo9IGNoaWxkcmVuLmxlbmd0aDsgaTxqOyBpKyspXG4gICAge1xuICAgICAgICB0aGlzLnJlbmRlclNwcml0ZShjaGlsZHJlbltpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5mbHVzaCgpO1xufTtcblxuUElYSS5XZWJHTEZhc3RTcHJpdGVCYXRjaC5wcm90b3R5cGUucmVuZGVyU3ByaXRlID0gZnVuY3Rpb24oc3ByaXRlKVxue1xuICAgIC8vc3ByaXRlID0gY2hpbGRyZW5baV07XG4gICAgaWYoIXNwcml0ZS52aXNpYmxlKXJldHVybjtcbiAgICBcbiAgICAvLyBUT0RPIHRyaW0/P1xuICAgIGlmKHNwcml0ZS50ZXh0dXJlLmJhc2VUZXh0dXJlICE9PSB0aGlzLmN1cnJlbnRCYXNlVGV4dHVyZSlcbiAgICB7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgdGhpcy5jdXJyZW50QmFzZVRleHR1cmUgPSBzcHJpdGUudGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICAgICAgXG4gICAgICAgIGlmKCFzcHJpdGUudGV4dHVyZS5fdXZzKXJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdXZzLCB2ZXJ0aWNpZXMgPSB0aGlzLnZlcnRpY2VzLCB3aWR0aCwgaGVpZ2h0LCB3MCwgdzEsIGgwLCBoMSwgaW5kZXg7XG5cbiAgICB1dnMgPSBzcHJpdGUudGV4dHVyZS5fdXZzO1xuXG5cbiAgICB3aWR0aCA9IHNwcml0ZS50ZXh0dXJlLmZyYW1lLndpZHRoO1xuICAgIGhlaWdodCA9IHNwcml0ZS50ZXh0dXJlLmZyYW1lLmhlaWdodDtcblxuICAgIGlmIChzcHJpdGUudGV4dHVyZS50cmltKVxuICAgIHtcbiAgICAgICAgLy8gaWYgdGhlIHNwcml0ZSBpcyB0cmltbWVkIHRoZW4gd2UgbmVlZCB0byBhZGQgdGhlIGV4dHJhIHNwYWNlIGJlZm9yZSB0cmFuc2Zvcm1pbmcgdGhlIHNwcml0ZSBjb29yZHMuLlxuICAgICAgICB2YXIgdHJpbSA9IHNwcml0ZS50ZXh0dXJlLnRyaW07XG5cbiAgICAgICAgdzEgPSB0cmltLnggLSBzcHJpdGUuYW5jaG9yLnggKiB0cmltLndpZHRoO1xuICAgICAgICB3MCA9IHcxICsgc3ByaXRlLnRleHR1cmUuY3JvcC53aWR0aDtcblxuICAgICAgICBoMSA9IHRyaW0ueSAtIHNwcml0ZS5hbmNob3IueSAqIHRyaW0uaGVpZ2h0O1xuICAgICAgICBoMCA9IGgxICsgc3ByaXRlLnRleHR1cmUuY3JvcC5oZWlnaHQ7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHcwID0gKHNwcml0ZS50ZXh0dXJlLmZyYW1lLndpZHRoICkgKiAoMS1zcHJpdGUuYW5jaG9yLngpO1xuICAgICAgICB3MSA9IChzcHJpdGUudGV4dHVyZS5mcmFtZS53aWR0aCApICogLXNwcml0ZS5hbmNob3IueDtcblxuICAgICAgICBoMCA9IHNwcml0ZS50ZXh0dXJlLmZyYW1lLmhlaWdodCAqICgxLXNwcml0ZS5hbmNob3IueSk7XG4gICAgICAgIGgxID0gc3ByaXRlLnRleHR1cmUuZnJhbWUuaGVpZ2h0ICogLXNwcml0ZS5hbmNob3IueTtcbiAgICB9XG5cbiAgICBpbmRleCA9IHRoaXMuY3VycmVudEJhdGNoU2l6ZSAqIDQgKiB0aGlzLnZlcnRTaXplO1xuXG4gICAgLy8geHlcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB3MTtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBoMTtcblxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5wb3NpdGlvbi54O1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5wb3NpdGlvbi55O1xuXG4gICAgLy9zY2FsZVxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5zY2FsZS54O1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5zY2FsZS55O1xuXG4gICAgLy9yb3RhdGlvblxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5yb3RhdGlvbjtcblxuICAgIC8vIHV2XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdXZzLngwO1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy55MTtcbiAgICAvLyBjb2xvclxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5hbHBoYTtcbiBcblxuICAgIC8vIHh5XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdzA7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gaDE7XG5cbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUucG9zaXRpb24ueDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUucG9zaXRpb24ueTtcblxuICAgIC8vc2NhbGVcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUuc2NhbGUueDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUuc2NhbGUueTtcblxuICAgICAvL3JvdGF0aW9uXG4gICAgdmVydGljaWVzW2luZGV4KytdID0gc3ByaXRlLnJvdGF0aW9uO1xuXG4gICAgLy8gdXZcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueDE7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdXZzLnkxO1xuICAgIC8vIGNvbG9yXG4gICAgdmVydGljaWVzW2luZGV4KytdID0gc3ByaXRlLmFscGhhO1xuICBcblxuICAgIC8vIHh5XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdzA7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gaDA7XG5cbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUucG9zaXRpb24ueDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUucG9zaXRpb24ueTtcblxuICAgIC8vc2NhbGVcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUuc2NhbGUueDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUuc2NhbGUueTtcblxuICAgICAvL3JvdGF0aW9uXG4gICAgdmVydGljaWVzW2luZGV4KytdID0gc3ByaXRlLnJvdGF0aW9uO1xuXG4gICAgLy8gdXZcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueDI7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdXZzLnkyO1xuICAgIC8vIGNvbG9yXG4gICAgdmVydGljaWVzW2luZGV4KytdID0gc3ByaXRlLmFscGhhO1xuIFxuXG5cblxuICAgIC8vIHh5XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdzE7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gaDA7XG5cbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUucG9zaXRpb24ueDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUucG9zaXRpb24ueTtcblxuICAgIC8vc2NhbGVcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUuc2NhbGUueDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUuc2NhbGUueTtcblxuICAgICAvL3JvdGF0aW9uXG4gICAgdmVydGljaWVzW2luZGV4KytdID0gc3ByaXRlLnJvdGF0aW9uO1xuXG4gICAgLy8gdXZcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueDM7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdXZzLnkzO1xuICAgIC8vIGNvbG9yXG4gICAgdmVydGljaWVzW2luZGV4KytdID0gc3ByaXRlLmFscGhhO1xuXG4gICAgLy8gaW5jcmVtZW50IHRoZSBiYXRjaHNcbiAgICB0aGlzLmN1cnJlbnRCYXRjaFNpemUrKztcblxuICAgIGlmKHRoaXMuY3VycmVudEJhdGNoU2l6ZSA+PSB0aGlzLnNpemUpXG4gICAge1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxufTtcblxuUElYSS5XZWJHTEZhc3RTcHJpdGVCYXRjaC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbigpXG57XG5cbiAgICAvLyBJZiB0aGUgYmF0Y2ggaXMgbGVuZ3RoIDAgdGhlbiByZXR1cm4gYXMgdGhlcmUgaXMgbm90aGluZyB0byBkcmF3XG4gICAgaWYgKHRoaXMuY3VycmVudEJhdGNoU2l6ZT09PTApcmV0dXJuO1xuXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBcbiAgICAvLyBiaW5kIHRoZSBjdXJyZW50IHRleHR1cmVcblxuICAgIGlmKCF0aGlzLmN1cnJlbnRCYXNlVGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0pUElYSS5jcmVhdGVXZWJHTFRleHR1cmUodGhpcy5jdXJyZW50QmFzZVRleHR1cmUsIGdsKTtcblxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuY3VycmVudEJhc2VUZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSk7XG5cbiAgICAvLyB1cGxvYWQgdGhlIHZlcnRzIHRvIHRoZSBidWZmZXJcblxuICAgXG4gICAgaWYodGhpcy5jdXJyZW50QmF0Y2hTaXplID4gKCB0aGlzLnNpemUgKiAwLjUgKSApXG4gICAge1xuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdGhpcy52ZXJ0aWNlcyk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52ZXJ0aWNlcy5zdWJhcnJheSgwLCB0aGlzLmN1cnJlbnRCYXRjaFNpemUgKiA0ICogdGhpcy52ZXJ0U2l6ZSk7XG5cbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHZpZXcpO1xuICAgIH1cbiAgICBcbiAgICBcbiAgICAvLyBub3cgZHJhdyB0aG9zZSBzdWNrYXMhXG4gICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgdGhpcy5jdXJyZW50QmF0Y2hTaXplICogNiwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xuICAgXG4gICAgLy8gdGhlbiByZXNldCB0aGUgYmF0Y2ghXG4gICAgdGhpcy5jdXJyZW50QmF0Y2hTaXplID0gMDtcblxuICAgIC8vIGluY3JlbWVudCB0aGUgZHJhdyBjb3VudFxuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5kcmF3Q291bnQrKztcbn07XG5cblxuUElYSS5XZWJHTEZhc3RTcHJpdGVCYXRjaC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmZsdXNoKCk7XG59O1xuXG5QSVhJLldlYkdMRmFzdFNwcml0ZUJhdGNoLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgLy8gYmluZCB0aGUgbWFpbiB0ZXh0dXJlXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG5cbiAgICAvLyBiaW5kIHRoZSBidWZmZXJzXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGV4QnVmZmVyKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4QnVmZmVyKTtcblxuICAgIC8vIHNldCB0aGUgcHJvamVjdGlvblxuICAgIHZhciBwcm9qZWN0aW9uID0gdGhpcy5yZW5kZXJTZXNzaW9uLnByb2plY3Rpb247XG4gICAgZ2wudW5pZm9ybTJmKHRoaXMuc2hhZGVyLnByb2plY3Rpb25WZWN0b3IsIHByb2plY3Rpb24ueCwgcHJvamVjdGlvbi55KTtcblxuICAgIC8vIHNldCB0aGUgbWF0cml4XG4gICAgZ2wudW5pZm9ybU1hdHJpeDNmdih0aGlzLnNoYWRlci51TWF0cml4LCBmYWxzZSwgdGhpcy5tYXRyaXgpO1xuXG4gICAgLy8gc2V0IHRoZSBwb2ludGVyc1xuICAgIHZhciBzdHJpZGUgPSAgdGhpcy52ZXJ0U2l6ZSAqIDQ7XG5cbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuc2hhZGVyLmFWZXJ0ZXhQb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBzdHJpZGUsIDApO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5zaGFkZXIuYVBvc2l0aW9uQ29vcmQsIDIsIGdsLkZMT0FULCBmYWxzZSwgc3RyaWRlLCAyICogNCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnNoYWRlci5hU2NhbGUsIDIsIGdsLkZMT0FULCBmYWxzZSwgc3RyaWRlLCA0ICogNCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnNoYWRlci5hUm90YXRpb24sIDEsIGdsLkZMT0FULCBmYWxzZSwgc3RyaWRlLCA2ICogNCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnNoYWRlci5hVGV4dHVyZUNvb3JkLCAyLCBnbC5GTE9BVCwgZmFsc2UsIHN0cmlkZSwgNyAqIDQpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5zaGFkZXIuY29sb3JBdHRyaWJ1dGUsIDEsIGdsLkZMT0FULCBmYWxzZSwgc3RyaWRlLCA5ICogNCk7XG5cbiAgICBcbn07XG5cblxuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuKiBAY2xhc3MgV2ViR0xGaWx0ZXJNYW5hZ2VyXG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0gZ2wge1dlYkdMQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4qIEBwYXJhbSB0cmFuc3BhcmVudCB7Qm9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGRyYXdpbmcgY29udGV4dCBzaG91bGQgYmUgdHJhbnNwYXJlbnRcbiogQHByaXZhdGVcbiovXG5QSVhJLldlYkdMRmlsdGVyTWFuYWdlciA9IGZ1bmN0aW9uKGdsLCB0cmFuc3BhcmVudClcbntcbiAgICB0aGlzLnRyYW5zcGFyZW50ID0gdHJhbnNwYXJlbnQ7XG5cbiAgICB0aGlzLmZpbHRlclN0YWNrID0gW107XG4gICAgXG4gICAgdGhpcy5vZmZzZXRYID0gMDtcbiAgICB0aGlzLm9mZnNldFkgPSAwO1xuXG4gICAgdGhpcy5zZXRDb250ZXh0KGdsKTtcbn07XG5cbi8vIEFQSVxuLyoqXG4qIEluaXRpYWxpc2VzIHRoZSBjb250ZXh0IGFuZCB0aGUgcHJvcGVydGllc1xuKiBAbWV0aG9kIHNldENvbnRleHQgXG4qIEBwYXJhbSBnbCB7V2ViR0xDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiovXG5QSVhJLldlYkdMRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuc2V0Q29udGV4dCA9IGZ1bmN0aW9uKGdsKVxue1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLnRleHR1cmVQb29sID0gW107XG5cbiAgICB0aGlzLmluaXRTaGFkZXJCdWZmZXJzKCk7XG59O1xuXG4vKipcbiogXG4qIEBtZXRob2QgYmVnaW5cbiogQHBhcmFtIHJlbmRlclNlc3Npb24ge1JlbmRlclNlc3Npb259IFxuKiBAcGFyYW0gYnVmZmVyIHtBcnJheUJ1ZmZlcn0gXG4qL1xuUElYSS5XZWJHTEZpbHRlck1hbmFnZXIucHJvdG90eXBlLmJlZ2luID0gZnVuY3Rpb24ocmVuZGVyU2Vzc2lvbiwgYnVmZmVyKVxue1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbiA9IHJlbmRlclNlc3Npb247XG4gICAgdGhpcy5kZWZhdWx0U2hhZGVyID0gcmVuZGVyU2Vzc2lvbi5zaGFkZXJNYW5hZ2VyLmRlZmF1bHRTaGFkZXI7XG5cbiAgICB2YXIgcHJvamVjdGlvbiA9IHRoaXMucmVuZGVyU2Vzc2lvbi5wcm9qZWN0aW9uO1xuICAgLy8gY29uc29sZS5sb2codGhpcy53aWR0aClcbiAgICB0aGlzLndpZHRoID0gcHJvamVjdGlvbi54ICogMjtcbiAgICB0aGlzLmhlaWdodCA9IC1wcm9qZWN0aW9uLnkgKiAyO1xuICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xufTtcblxuLyoqXG4qIEFwcGxpZXMgdGhlIGZpbHRlciBhbmQgYWRkcyBpdCB0byB0aGUgY3VycmVudCBmaWx0ZXIgc3RhY2tcbiogQG1ldGhvZCBwdXNoRmlsdGVyXG4qIEBwYXJhbSBmaWx0ZXJCbG9jayB7T2JqZWN0fSB0aGUgZmlsdGVyIHRoYXQgd2lsbCBiZSBwdXNoZWQgdG8gdGhlIGN1cnJlbnQgZmlsdGVyIHN0YWNrXG4qL1xuUElYSS5XZWJHTEZpbHRlck1hbmFnZXIucHJvdG90eXBlLnB1c2hGaWx0ZXIgPSBmdW5jdGlvbihmaWx0ZXJCbG9jaylcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdmFyIHByb2plY3Rpb24gPSB0aGlzLnJlbmRlclNlc3Npb24ucHJvamVjdGlvbjtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5yZW5kZXJTZXNzaW9uLm9mZnNldDtcblxuICAgIGZpbHRlckJsb2NrLl9maWx0ZXJBcmVhID0gZmlsdGVyQmxvY2sudGFyZ2V0LmZpbHRlckFyZWEgfHwgZmlsdGVyQmxvY2sudGFyZ2V0LmdldEJvdW5kcygpO1xuXG5cbiAgICAvLyBmaWx0ZXIgcHJvZ3JhbVxuICAgIC8vIE9QVElNSVNBVElPTiAtIHRoZSBmaXJzdCBmaWx0ZXIgaXMgZnJlZSBpZiBpdHMgYSBzaW1wbGUgY29sb3IgY2hhbmdlP1xuICAgIHRoaXMuZmlsdGVyU3RhY2sucHVzaChmaWx0ZXJCbG9jayk7XG5cbiAgICB2YXIgZmlsdGVyID0gZmlsdGVyQmxvY2suZmlsdGVyUGFzc2VzWzBdO1xuXG4gICAgdGhpcy5vZmZzZXRYICs9IGZpbHRlckJsb2NrLl9maWx0ZXJBcmVhLng7XG4gICAgdGhpcy5vZmZzZXRZICs9IGZpbHRlckJsb2NrLl9maWx0ZXJBcmVhLnk7XG5cbiAgICB2YXIgdGV4dHVyZSA9IHRoaXMudGV4dHVyZVBvb2wucG9wKCk7XG4gICAgaWYoIXRleHR1cmUpXG4gICAge1xuICAgICAgICB0ZXh0dXJlID0gbmV3IFBJWEkuRmlsdGVyVGV4dHVyZSh0aGlzLmdsLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRleHR1cmUucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCAgdGV4dHVyZS50ZXh0dXJlKTtcblxuICAgIHZhciBmaWx0ZXJBcmVhID0gZmlsdGVyQmxvY2suX2ZpbHRlckFyZWE7Ly8gZmlsdGVyQmxvY2sudGFyZ2V0LmdldEJvdW5kcygpOy8vL2ZpbHRlckJsb2NrLnRhcmdldC5maWx0ZXJBcmVhO1xuXG4gICAgdmFyIHBhZGRpbmcgPSBmaWx0ZXIucGFkZGluZztcbiAgICBmaWx0ZXJBcmVhLnggLT0gcGFkZGluZztcbiAgICBmaWx0ZXJBcmVhLnkgLT0gcGFkZGluZztcbiAgICBmaWx0ZXJBcmVhLndpZHRoICs9IHBhZGRpbmcgKiAyO1xuICAgIGZpbHRlckFyZWEuaGVpZ2h0ICs9IHBhZGRpbmcgKiAyO1xuXG4gICAgLy8gY2FwIGZpbHRlciB0byBzY3JlZW4gc2l6ZS4uXG4gICAgaWYoZmlsdGVyQXJlYS54IDwgMClmaWx0ZXJBcmVhLnggPSAwO1xuICAgIGlmKGZpbHRlckFyZWEud2lkdGggPiB0aGlzLndpZHRoKWZpbHRlckFyZWEud2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGlmKGZpbHRlckFyZWEueSA8IDApZmlsdGVyQXJlYS55ID0gMDtcbiAgICBpZihmaWx0ZXJBcmVhLmhlaWdodCA+IHRoaXMuaGVpZ2h0KWZpbHRlckFyZWEuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cbiAgICAvL2dsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgIGZpbHRlckFyZWEud2lkdGgsIGZpbHRlckFyZWEuaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRleHR1cmUuZnJhbWVCdWZmZXIpO1xuXG4gICAgLy8gc2V0IHZpZXcgcG9ydFxuICAgIGdsLnZpZXdwb3J0KDAsIDAsIGZpbHRlckFyZWEud2lkdGgsIGZpbHRlckFyZWEuaGVpZ2h0KTtcblxuICAgIHByb2plY3Rpb24ueCA9IGZpbHRlckFyZWEud2lkdGgvMjtcbiAgICBwcm9qZWN0aW9uLnkgPSAtZmlsdGVyQXJlYS5oZWlnaHQvMjtcblxuICAgIG9mZnNldC54ID0gLWZpbHRlckFyZWEueDtcbiAgICBvZmZzZXQueSA9IC1maWx0ZXJBcmVhLnk7XG5cbiAgICAvLyB1cGRhdGUgcHJvamVjdGlvblxuICAgIC8vIG5vdyByZXN0b3JlIHRoZSByZWd1bGFyIHNoYWRlci4uXG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIuc2V0U2hhZGVyKHRoaXMuZGVmYXVsdFNoYWRlcik7XG4gICAgZ2wudW5pZm9ybTJmKHRoaXMuZGVmYXVsdFNoYWRlci5wcm9qZWN0aW9uVmVjdG9yLCBmaWx0ZXJBcmVhLndpZHRoLzIsIC1maWx0ZXJBcmVhLmhlaWdodC8yKTtcbiAgICBnbC51bmlmb3JtMmYodGhpcy5kZWZhdWx0U2hhZGVyLm9mZnNldFZlY3RvciwgLWZpbHRlckFyZWEueCwgLWZpbHRlckFyZWEueSk7XG5cbiAgICBnbC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZ2wuY2xlYXJDb2xvcigwLDAsMCwgMCk7XG4gICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG5cbiAgICBmaWx0ZXJCbG9jay5fZ2xGaWx0ZXJUZXh0dXJlID0gdGV4dHVyZTtcblxufTtcblxuXG4vKipcbiogUmVtb3ZlcyB0aGUgbGFzdCBmaWx0ZXIgZnJvbSB0aGUgZmlsdGVyIHN0YWNrIGFuZCBkb2Vzbid0IHJldHVybiBpdFxuKiBAbWV0aG9kIHBvcEZpbHRlclxuKi9cblBJWEkuV2ViR0xGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5wb3BGaWx0ZXIgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICB2YXIgZmlsdGVyQmxvY2sgPSB0aGlzLmZpbHRlclN0YWNrLnBvcCgpO1xuICAgIHZhciBmaWx0ZXJBcmVhID0gZmlsdGVyQmxvY2suX2ZpbHRlckFyZWE7XG4gICAgdmFyIHRleHR1cmUgPSBmaWx0ZXJCbG9jay5fZ2xGaWx0ZXJUZXh0dXJlO1xuICAgIHZhciBwcm9qZWN0aW9uID0gdGhpcy5yZW5kZXJTZXNzaW9uLnByb2plY3Rpb247XG4gICAgdmFyIG9mZnNldCA9IHRoaXMucmVuZGVyU2Vzc2lvbi5vZmZzZXQ7XG5cbiAgICBpZihmaWx0ZXJCbG9jay5maWx0ZXJQYXNzZXMubGVuZ3RoID4gMSlcbiAgICB7XG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIGZpbHRlckFyZWEud2lkdGgsIGZpbHRlckFyZWEuaGVpZ2h0KTtcblxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0ZXhCdWZmZXIpO1xuXG4gICAgICAgIHRoaXMudmVydGV4QXJyYXlbMF0gPSAwO1xuICAgICAgICB0aGlzLnZlcnRleEFycmF5WzFdID0gZmlsdGVyQXJlYS5oZWlnaHQ7XG5cbiAgICAgICAgdGhpcy52ZXJ0ZXhBcnJheVsyXSA9IGZpbHRlckFyZWEud2lkdGg7XG4gICAgICAgIHRoaXMudmVydGV4QXJyYXlbM10gPSBmaWx0ZXJBcmVhLmhlaWdodDtcblxuICAgICAgICB0aGlzLnZlcnRleEFycmF5WzRdID0gMDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhBcnJheVs1XSA9IDA7XG5cbiAgICAgICAgdGhpcy52ZXJ0ZXhBcnJheVs2XSA9IGZpbHRlckFyZWEud2lkdGg7XG4gICAgICAgIHRoaXMudmVydGV4QXJyYXlbN10gPSAwO1xuXG4gICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB0aGlzLnZlcnRleEFycmF5KTtcblxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy51dkJ1ZmZlcik7XG4gICAgICAgIC8vIG5vdyBzZXQgdGhlIHV2cy4uXG4gICAgICAgIHRoaXMudXZBcnJheVsyXSA9IGZpbHRlckFyZWEud2lkdGgvdGhpcy53aWR0aDtcbiAgICAgICAgdGhpcy51dkFycmF5WzVdID0gZmlsdGVyQXJlYS5oZWlnaHQvdGhpcy5oZWlnaHQ7XG4gICAgICAgIHRoaXMudXZBcnJheVs2XSA9IGZpbHRlckFyZWEud2lkdGgvdGhpcy53aWR0aDtcbiAgICAgICAgdGhpcy51dkFycmF5WzddID0gZmlsdGVyQXJlYS5oZWlnaHQvdGhpcy5oZWlnaHQ7XG5cbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHRoaXMudXZBcnJheSk7XG5cbiAgICAgICAgdmFyIGlucHV0VGV4dHVyZSA9IHRleHR1cmU7XG4gICAgICAgIHZhciBvdXRwdXRUZXh0dXJlID0gdGhpcy50ZXh0dXJlUG9vbC5wb3AoKTtcbiAgICAgICAgaWYoIW91dHB1dFRleHR1cmUpb3V0cHV0VGV4dHVyZSA9IG5ldyBQSVhJLkZpbHRlclRleHR1cmUodGhpcy5nbCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICBvdXRwdXRUZXh0dXJlLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cbiAgICAgICAgLy8gbmVlZCB0byBjbGVhciB0aGlzIEZCTyBhcyBpdCBtYXkgaGF2ZSBzb21lIGxlZnQgb3ZlciBlbGVtZW50cyBmcm9tIGEgcHJldmlvdXMgZmlsdGVyLlxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG91dHB1dFRleHR1cmUuZnJhbWVCdWZmZXIgKTtcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG5cbiAgICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWx0ZXJCbG9jay5maWx0ZXJQYXNzZXMubGVuZ3RoLTE7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGZpbHRlclBhc3MgPSBmaWx0ZXJCbG9jay5maWx0ZXJQYXNzZXNbaV07XG5cbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgb3V0cHV0VGV4dHVyZS5mcmFtZUJ1ZmZlciApO1xuXG4gICAgICAgICAgICAvLyBzZXQgdGV4dHVyZVxuICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBpbnB1dFRleHR1cmUudGV4dHVyZSk7XG5cbiAgICAgICAgICAgIC8vIGRyYXcgdGV4dHVyZS4uXG4gICAgICAgICAgICAvL2ZpbHRlclBhc3MuYXBwbHlGaWx0ZXJQYXNzKGZpbHRlckFyZWEud2lkdGgsIGZpbHRlckFyZWEuaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlGaWx0ZXJQYXNzKGZpbHRlclBhc3MsIGZpbHRlckFyZWEsIGZpbHRlckFyZWEud2lkdGgsIGZpbHRlckFyZWEuaGVpZ2h0KTtcblxuICAgICAgICAgICAgLy8gc3dhcCB0aGUgdGV4dHVyZXMuLlxuICAgICAgICAgICAgdmFyIHRlbXAgPSBpbnB1dFRleHR1cmU7XG4gICAgICAgICAgICBpbnB1dFRleHR1cmUgPSBvdXRwdXRUZXh0dXJlO1xuICAgICAgICAgICAgb3V0cHV0VGV4dHVyZSA9IHRlbXA7XG4gICAgICAgIH1cblxuICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuXG4gICAgICAgIHRleHR1cmUgPSBpbnB1dFRleHR1cmU7XG4gICAgICAgIHRoaXMudGV4dHVyZVBvb2wucHVzaChvdXRwdXRUZXh0dXJlKTtcbiAgICB9XG5cbiAgICB2YXIgZmlsdGVyID0gZmlsdGVyQmxvY2suZmlsdGVyUGFzc2VzW2ZpbHRlckJsb2NrLmZpbHRlclBhc3Nlcy5sZW5ndGgtMV07XG5cbiAgICB0aGlzLm9mZnNldFggLT0gZmlsdGVyQXJlYS54O1xuICAgIHRoaXMub2Zmc2V0WSAtPSBmaWx0ZXJBcmVhLnk7XG5cblxuICAgIHZhciBzaXplWCA9IHRoaXMud2lkdGg7XG4gICAgdmFyIHNpemVZID0gdGhpcy5oZWlnaHQ7XG5cbiAgICB2YXIgb2Zmc2V0WCA9IDA7XG4gICAgdmFyIG9mZnNldFkgPSAwO1xuXG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuXG4gICAgLy8gdGltZSB0byByZW5kZXIgdGhlIGZpbHRlcnMgdGV4dHVyZSB0byB0aGUgcHJldmlvdXMgc2NlbmVcbiAgICBpZih0aGlzLmZpbHRlclN0YWNrLmxlbmd0aCA9PT0gMClcbiAgICB7XG4gICAgICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTsvL3RoaXMudHJhbnNwYXJlbnQpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB2YXIgY3VycmVudEZpbHRlciA9IHRoaXMuZmlsdGVyU3RhY2tbdGhpcy5maWx0ZXJTdGFjay5sZW5ndGgtMV07XG4gICAgICAgIGZpbHRlckFyZWEgPSBjdXJyZW50RmlsdGVyLl9maWx0ZXJBcmVhO1xuXG4gICAgICAgIHNpemVYID0gZmlsdGVyQXJlYS53aWR0aDtcbiAgICAgICAgc2l6ZVkgPSBmaWx0ZXJBcmVhLmhlaWdodDtcblxuICAgICAgICBvZmZzZXRYID0gZmlsdGVyQXJlYS54O1xuICAgICAgICBvZmZzZXRZID0gZmlsdGVyQXJlYS55O1xuXG4gICAgICAgIGJ1ZmZlciA9ICBjdXJyZW50RmlsdGVyLl9nbEZpbHRlclRleHR1cmUuZnJhbWVCdWZmZXI7XG4gICAgfVxuXG5cblxuICAgIC8vIFRPRE8gbmVlZCB0b3JlbW92ZSB0aGVhc2UgZ2xvYmFsIGVsZW1lbnRzLi5cbiAgICBwcm9qZWN0aW9uLnggPSBzaXplWC8yO1xuICAgIHByb2plY3Rpb24ueSA9IC1zaXplWS8yO1xuXG4gICAgb2Zmc2V0LnggPSBvZmZzZXRYO1xuICAgIG9mZnNldC55ID0gb2Zmc2V0WTtcblxuICAgIGZpbHRlckFyZWEgPSBmaWx0ZXJCbG9jay5fZmlsdGVyQXJlYTtcblxuICAgIHZhciB4ID0gZmlsdGVyQXJlYS54LW9mZnNldFg7XG4gICAgdmFyIHkgPSBmaWx0ZXJBcmVhLnktb2Zmc2V0WTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVycy4uXG4gICAgLy8gbWFrZSBzdXJlIHRvIGZsaXAgdGhlIHkhXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGV4QnVmZmVyKTtcblxuICAgIHRoaXMudmVydGV4QXJyYXlbMF0gPSB4O1xuICAgIHRoaXMudmVydGV4QXJyYXlbMV0gPSB5ICsgZmlsdGVyQXJlYS5oZWlnaHQ7XG5cbiAgICB0aGlzLnZlcnRleEFycmF5WzJdID0geCArIGZpbHRlckFyZWEud2lkdGg7XG4gICAgdGhpcy52ZXJ0ZXhBcnJheVszXSA9IHkgKyBmaWx0ZXJBcmVhLmhlaWdodDtcblxuICAgIHRoaXMudmVydGV4QXJyYXlbNF0gPSB4O1xuICAgIHRoaXMudmVydGV4QXJyYXlbNV0gPSB5O1xuXG4gICAgdGhpcy52ZXJ0ZXhBcnJheVs2XSA9IHggKyBmaWx0ZXJBcmVhLndpZHRoO1xuICAgIHRoaXMudmVydGV4QXJyYXlbN10gPSB5O1xuXG4gICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHRoaXMudmVydGV4QXJyYXkpO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudXZCdWZmZXIpO1xuXG4gICAgdGhpcy51dkFycmF5WzJdID0gZmlsdGVyQXJlYS53aWR0aC90aGlzLndpZHRoO1xuICAgIHRoaXMudXZBcnJheVs1XSA9IGZpbHRlckFyZWEuaGVpZ2h0L3RoaXMuaGVpZ2h0O1xuICAgIHRoaXMudXZBcnJheVs2XSA9IGZpbHRlckFyZWEud2lkdGgvdGhpcy53aWR0aDtcbiAgICB0aGlzLnV2QXJyYXlbN10gPSBmaWx0ZXJBcmVhLmhlaWdodC90aGlzLmhlaWdodDtcblxuICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB0aGlzLnV2QXJyYXkpO1xuXG4gICAvL2NvbnNvbGUubG9nKHRoaXMudmVydGV4QXJyYXkpXG4gICAvL2NvbnNvbGUubG9nKHRoaXMudXZBcnJheSlcbiAgICAvL2NvbnNvbGUubG9nKHNpemVYICsgXCIgOiBcIiArIHNpemVZKVxuXG4gICAgZ2wudmlld3BvcnQoMCwgMCwgc2l6ZVgsIHNpemVZKTtcblxuICAgIC8vIGJpbmQgdGhlIGJ1ZmZlclxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgYnVmZmVyICk7XG5cbiAgICAvLyBzZXQgdGhlIGJsZW5kIG1vZGUhIFxuICAgIC8vZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSlcblxuICAgIC8vIHNldCB0ZXh0dXJlXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZS50ZXh0dXJlKTtcblxuICAgIC8vIGFwcGx5IVxuICAgIHRoaXMuYXBwbHlGaWx0ZXJQYXNzKGZpbHRlciwgZmlsdGVyQXJlYSwgc2l6ZVgsIHNpemVZKTtcblxuICAgIC8vIG5vdyByZXN0b3JlIHRoZSByZWd1bGFyIHNoYWRlci4uXG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIuc2V0U2hhZGVyKHRoaXMuZGVmYXVsdFNoYWRlcik7XG4gICAgZ2wudW5pZm9ybTJmKHRoaXMuZGVmYXVsdFNoYWRlci5wcm9qZWN0aW9uVmVjdG9yLCBzaXplWC8yLCAtc2l6ZVkvMik7XG4gICAgZ2wudW5pZm9ybTJmKHRoaXMuZGVmYXVsdFNoYWRlci5vZmZzZXRWZWN0b3IsIC1vZmZzZXRYLCAtb2Zmc2V0WSk7XG5cbiAgICAvLyByZXR1cm4gdGhlIHRleHR1cmUgdG8gdGhlIHBvb2xcbiAgICB0aGlzLnRleHR1cmVQb29sLnB1c2godGV4dHVyZSk7XG4gICAgZmlsdGVyQmxvY2suX2dsRmlsdGVyVGV4dHVyZSA9IG51bGw7XG59O1xuXG5cbi8qKlxuKiBBcHBsaWVzIHRoZSBmaWx0ZXIgdG8gdGhlIHNwZWNpZmllZCBhcmVhXG4qIEBtZXRob2QgYXBwbHlGaWx0ZXJQYXNzXG4qIEBwYXJhbSBmaWx0ZXIge0Fic3RyYWN0RmlsdGVyfSB0aGUgZmlsdGVyIHRoYXQgbmVlZHMgdG8gYmUgYXBwbGllZFxuKiBAcGFyYW0gZmlsdGVyQXJlYSB7dGV4dHVyZX0gVE9ETyAtIG1pZ2h0IG5lZWQgYW4gdXBkYXRlXG4qIEBwYXJhbSB3aWR0aCB7TnVtYmVyfSB0aGUgaG9yaXpvbnRhbCByYW5nZSBvZiB0aGUgZmlsdGVyXG4qIEBwYXJhbSBoZWlnaHQge051bWJlcn0gdGhlIHZlcnRpY2FsIHJhbmdlIG9mIHRoZSBmaWx0ZXJcbiovXG5QSVhJLldlYkdMRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuYXBwbHlGaWx0ZXJQYXNzID0gZnVuY3Rpb24oZmlsdGVyLCBmaWx0ZXJBcmVhLCB3aWR0aCwgaGVpZ2h0KVxue1xuICAgIC8vIHVzZSBwcm9ncmFtXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICB2YXIgc2hhZGVyID0gZmlsdGVyLnNoYWRlcnNbZ2wuaWRdO1xuXG4gICAgaWYoIXNoYWRlcilcbiAgICB7XG4gICAgICAgIHNoYWRlciA9IG5ldyBQSVhJLlBpeGlTaGFkZXIoZ2wpO1xuXG4gICAgICAgIHNoYWRlci5mcmFnbWVudFNyYyA9IGZpbHRlci5mcmFnbWVudFNyYztcbiAgICAgICAgc2hhZGVyLnVuaWZvcm1zID0gZmlsdGVyLnVuaWZvcm1zO1xuICAgICAgICBzaGFkZXIuaW5pdCgpO1xuXG4gICAgICAgIGZpbHRlci5zaGFkZXJzW2dsLmlkXSA9IHNoYWRlcjtcbiAgICB9XG5cbiAgICAvLyBzZXQgdGhlIHNoYWRlclxuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5zaGFkZXJNYW5hZ2VyLnNldFNoYWRlcihzaGFkZXIpO1xuXG4vLyAgICBnbC51c2VQcm9ncmFtKHNoYWRlci5wcm9ncmFtKTtcblxuICAgIGdsLnVuaWZvcm0yZihzaGFkZXIucHJvamVjdGlvblZlY3Rvciwgd2lkdGgvMiwgLWhlaWdodC8yKTtcbiAgICBnbC51bmlmb3JtMmYoc2hhZGVyLm9mZnNldFZlY3RvciwgMCwwKTtcblxuICAgIGlmKGZpbHRlci51bmlmb3Jtcy5kaW1lbnNpb25zKVxuICAgIHtcbiAgICAgICAgZmlsdGVyLnVuaWZvcm1zLmRpbWVuc2lvbnMudmFsdWVbMF0gPSB0aGlzLndpZHRoOy8vd2lkdGg7XG4gICAgICAgIGZpbHRlci51bmlmb3Jtcy5kaW1lbnNpb25zLnZhbHVlWzFdID0gdGhpcy5oZWlnaHQ7Ly9oZWlnaHQ7XG4gICAgICAgIGZpbHRlci51bmlmb3Jtcy5kaW1lbnNpb25zLnZhbHVlWzJdID0gdGhpcy52ZXJ0ZXhBcnJheVswXTtcbiAgICAgICAgZmlsdGVyLnVuaWZvcm1zLmRpbWVuc2lvbnMudmFsdWVbM10gPSB0aGlzLnZlcnRleEFycmF5WzVdOy8vZmlsdGVyQXJlYS5oZWlnaHQ7XG4gICAgfVxuXG4gIC8vICBjb25zb2xlLmxvZyh0aGlzLnV2QXJyYXkgKVxuICAgIHNoYWRlci5zeW5jVW5pZm9ybXMoKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRleEJ1ZmZlcik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYVZlcnRleFBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudXZCdWZmZXIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFUZXh0dXJlQ29vcmQsIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5jb2xvckJ1ZmZlcik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuY29sb3JBdHRyaWJ1dGUsIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4QnVmZmVyKTtcblxuICAgIC8vIGRyYXcgdGhlIGZpbHRlci4uLlxuICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cbiAgICB0aGlzLnJlbmRlclNlc3Npb24uZHJhd0NvdW50Kys7XG59O1xuXG4vKipcbiogSW5pdGlhbGlzZXMgdGhlIHNoYWRlciBidWZmZXJzXG4qIEBtZXRob2QgaW5pdFNoYWRlckJ1ZmZlcnNcbiovXG5QSVhJLldlYkdMRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuaW5pdFNoYWRlckJ1ZmZlcnMgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIC8vIGNyZWF0ZSBzb21lIGJ1ZmZlcnNcbiAgICB0aGlzLnZlcnRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMudXZCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLmNvbG9yQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG5cbiAgICAvLyBiaW5kIGFuZCB1cGxvYWQgdGhlIHZlcnRleHMuLlxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHZlcnRleEZsb2F0RGF0YS4uXG4gICAgdGhpcy52ZXJ0ZXhBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoWzAuMCwgMC4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLjAsIDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMC4wLCAxLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEuMCwgMS4wXSk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0ZXhCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoXG4gICAgZ2wuQVJSQVlfQlVGRkVSLFxuICAgIHRoaXMudmVydGV4QXJyYXksXG4gICAgZ2wuU1RBVElDX0RSQVcpO1xuXG5cbiAgICAvLyBiaW5kIGFuZCB1cGxvYWQgdGhlIHV2IGJ1ZmZlclxuICAgIHRoaXMudXZBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoWzAuMCwgMC4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEuMCwgMC4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAuMCwgMS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEuMCwgMS4wXSk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy51dkJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShcbiAgICBnbC5BUlJBWV9CVUZGRVIsXG4gICAgdGhpcy51dkFycmF5LFxuICAgIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIHRoaXMuY29sb3JBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoWzEuMCwgMHhGRkZGRkYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMS4wLCAweEZGRkZGRixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLjAsIDB4RkZGRkZGLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEuMCwgMHhGRkZGRkZdKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmNvbG9yQnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKFxuICAgIGdsLkFSUkFZX0JVRkZFUixcbiAgICB0aGlzLmNvbG9yQXJyYXksXG4gICAgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgLy8gYmluZCBhbmQgdXBsb2FkIHRoZSBpbmRleFxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoXG4gICAgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsXG4gICAgbmV3IFVpbnQxNkFycmF5KFswLCAxLCAyLCAxLCAzLCAyXSksXG4gICAgZ2wuU1RBVElDX0RSQVcpO1xufTtcblxuLyoqXG4qIERlc3Ryb3lzIHRoZSBmaWx0ZXIgYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgZmlsdGVyIHN0YWNrXG4qIEBtZXRob2QgZGVzdHJveVxuKi9cblBJWEkuV2ViR0xGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICB0aGlzLmZpbHRlclN0YWNrID0gbnVsbDtcbiAgICBcbiAgICB0aGlzLm9mZnNldFggPSAwO1xuICAgIHRoaXMub2Zmc2V0WSA9IDA7XG5cbiAgICAvLyBkZXN0cm95IHRleHR1cmVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRleHR1cmVQb29sLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZVBvb2xbaV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLnRleHR1cmVQb29sID0gbnVsbDtcblxuICAgIC8vZGVzdHJveSBidWZmZXJzLi5cbiAgICBnbC5kZWxldGVCdWZmZXIodGhpcy52ZXJ0ZXhCdWZmZXIpO1xuICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLnV2QnVmZmVyKTtcbiAgICBnbC5kZWxldGVCdWZmZXIodGhpcy5jb2xvckJ1ZmZlcik7XG4gICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMuaW5kZXhCdWZmZXIpO1xufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiogQGNsYXNzIEZpbHRlclRleHR1cmVcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSBnbCB7V2ViR0xDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IHRoZSBob3Jpem9udGFsIHJhbmdlIG9mIHRoZSBmaWx0ZXJcbiogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSB0aGUgdmVydGljYWwgcmFuZ2Ugb2YgdGhlIGZpbHRlclxuKiBAcGFyYW0gc2NhbGVNb2RlIHtOdW1iZXJ9IFNob3VsZCBiZSBvbmUgb2YgdGhlIFBJWEkuc2NhbGVNb2RlIGNvbnN0c1xuKiBAcHJpdmF0ZVxuKi9cblBJWEkuRmlsdGVyVGV4dHVyZSA9IGZ1bmN0aW9uKGdsLCB3aWR0aCwgaGVpZ2h0LCBzY2FsZU1vZGUpXG57XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGdsXG4gICAgICogQHR5cGUgV2ViR0xDb250ZXh0XG4gICAgICovXG4gICAgdGhpcy5nbCA9IGdsO1xuXG4gICAgLy8gbmV4dCB0aW1lIHRvIGNyZWF0ZSBhIGZyYW1lIGJ1ZmZlciBhbmQgdGV4dHVyZVxuICAgIHRoaXMuZnJhbWVCdWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblxuICAgIHNjYWxlTW9kZSA9IHNjYWxlTW9kZSB8fCBQSVhJLnNjYWxlTW9kZXMuREVGQVVMVDtcblxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsICB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBzY2FsZU1vZGUgPT09IFBJWEkuc2NhbGVNb2Rlcy5MSU5FQVIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgc2NhbGVNb2RlID09PSBQSVhJLnNjYWxlTW9kZXMuTElORUFSID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyICk7XG5cbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXIgKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSwgMCk7XG5cbiAgICAvLyByZXF1aXJlZCBmb3IgbWFza2luZyBhIG1hc2s/P1xuICAgIHRoaXMucmVuZGVyQnVmZmVyID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG4gICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIHRoaXMucmVuZGVyQnVmZmVyKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIHRoaXMucmVuZGVyQnVmZmVyKTtcbiAgXG4gICAgdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG59O1xuXG5cbi8qKlxuKiBDbGVhcnMgdGhlIGZpbHRlciB0ZXh0dXJlXG4qIEBtZXRob2QgY2xlYXJcbiovXG5QSVhJLkZpbHRlclRleHR1cmUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgXG4gICAgZ2wuY2xlYXJDb2xvcigwLDAsMCwgMCk7XG4gICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG59O1xuXG4vKipcbiAqIFJlc2l6ZXMgdGhlIHRleHR1cmUgdG8gdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0XG4gKlxuICogQG1ldGhvZCByZXNpemVcbiAqIEBwYXJhbSB3aWR0aCB7TnVtYmVyfSB0aGUgbmV3IHdpZHRoIG9mIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gaGVpZ2h0IHtOdW1iZXJ9IHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlXG4gKi9cblBJWEkuRmlsdGVyVGV4dHVyZS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodClcbntcbiAgICBpZih0aGlzLndpZHRoID09PSB3aWR0aCAmJiB0aGlzLmhlaWdodCA9PT0gaGVpZ2h0KSByZXR1cm47XG5cbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCAgd2lkdGgsIGhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG5cbiAgICAvLyB1cGRhdGUgdGhlIHN0ZW5jaWwgYnVmZmVyIHdpZHRoIGFuZCBoZWlnaHRcbiAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5yZW5kZXJCdWZmZXIpO1xuICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9TVEVOQ0lMLCB3aWR0aCwgaGVpZ2h0KTtcbn07XG5cbi8qKlxuKiBEZXN0cm95cyB0aGUgZmlsdGVyIHRleHR1cmVcbiogQG1ldGhvZCBkZXN0cm95XG4qL1xuUElYSS5GaWx0ZXJUZXh0dXJlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHRoaXMuZnJhbWVCdWZmZXIgKTtcbiAgICBnbC5kZWxldGVUZXh0dXJlKCB0aGlzLnRleHR1cmUgKTtcblxuICAgIHRoaXMuZnJhbWVCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3Zlc1xuICogXG4gKiBcbiAqL1xuLyoqXG4gKiBBIHNldCBvZiBmdW5jdGlvbnMgdXNlZCB0byBoYW5kbGUgbWFza2luZ1xuICpcbiAqIEBjbGFzcyBDYW52YXNNYXNrTWFuYWdlclxuICovXG5QSVhJLkNhbnZhc01hc2tNYW5hZ2VyID0gZnVuY3Rpb24oKVxue1xuICAgIFxufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IHN0YWNrIG9mIG1hc2tzXG4gKlxuICogQG1ldGhvZCBwdXNoTWFza1xuICogQHBhcmFtIG1hc2tEYXRhIHRoZSBtYXNrRGF0YSB0aGF0IHdpbGwgYmUgcHVzaGVkXG4gKiBAcGFyYW0gY29udGV4dCB7Q29udGV4dDJEfSB0aGUgMmQgZHJhd2luZyBtZXRob2Qgb2YgdGhlIGNhbnZhc1xuICovXG5QSVhJLkNhbnZhc01hc2tNYW5hZ2VyLnByb3RvdHlwZS5wdXNoTWFzayA9IGZ1bmN0aW9uKG1hc2tEYXRhLCBjb250ZXh0KVxue1xuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIFxuICAgIHZhciBjYWNoZUFscGhhID0gbWFza0RhdGEuYWxwaGE7XG4gICAgdmFyIHRyYW5zZm9ybSA9IG1hc2tEYXRhLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgY29udGV4dC5zZXRUcmFuc2Zvcm0odHJhbnNmb3JtLmEsIHRyYW5zZm9ybS5jLCB0cmFuc2Zvcm0uYiwgdHJhbnNmb3JtLmQsIHRyYW5zZm9ybS50eCwgdHJhbnNmb3JtLnR5KTtcblxuICAgIFBJWEkuQ2FudmFzR3JhcGhpY3MucmVuZGVyR3JhcGhpY3NNYXNrKG1hc2tEYXRhLCBjb250ZXh0KTtcblxuICAgIGNvbnRleHQuY2xpcCgpO1xuXG4gICAgbWFza0RhdGEud29ybGRBbHBoYSA9IGNhY2hlQWxwaGE7XG59O1xuXG4vKipcbiAqIFJlc3RvcmVzIHRoZSBjdXJyZW50IGRyYXdpbmcgY29udGV4dCB0byB0aGUgc3RhdGUgaXQgd2FzIGJlZm9yZSB0aGUgbWFzayB3YXMgYXBwbGllZFxuICpcbiAqIEBtZXRob2QgcG9wTWFza1xuICogQHBhcmFtIGNvbnRleHQge0NvbnRleHQyRH0gdGhlIDJkIGRyYXdpbmcgbWV0aG9kIG9mIHRoZSBjYW52YXNcbiAqL1xuUElYSS5DYW52YXNNYXNrTWFuYWdlci5wcm90b3R5cGUucG9wTWFzayA9IGZ1bmN0aW9uKGNvbnRleHQpXG57XG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3Zlc1xuICogXG4gKiBcbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBDYW52YXNUaW50ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHN0YXRpY1xuICovXG5QSVhJLkNhbnZhc1RpbnRlciA9IGZ1bmN0aW9uKClcbntcbiAgICAvLy8gdGhpcy50ZXh0dXJlQ2FjaFxufTtcblxuLy9QSVhJLkNhbnZhc1RpbnRlci5jYWNoVGludCA9IHRydWU7XG4gICAgXG5cbi8qKlxuICogQmFzaWNhbGx5IHRoaXMgbWV0aG9kIGp1c3QgbmVlZHMgYSBzcHJpdGUgYW5kIGEgY29sb3IgYW5kIHRpbnRzIHRoZSBzcHJpdGUgXG4gKiB3aXRoIHRoZSBnaXZlbiBjb2xvclxuICogXG4gKiBAbWV0aG9kIGdldFRpbnRlZFRleHR1cmUgXG4gKiBAcGFyYW0gc3ByaXRlIHtTcHJpdGV9IHRoZSBzcHJpdGUgdG8gdGludFxuICogQHBhcmFtIGNvbG9yIHtOdW1iZXJ9IHRoZSBjb2xvciB0byB1c2UgdG8gdGludCB0aGUgc3ByaXRlIHdpdGhcbiAqL1xuUElYSS5DYW52YXNUaW50ZXIuZ2V0VGludGVkVGV4dHVyZSA9IGZ1bmN0aW9uKHNwcml0ZSwgY29sb3IpXG57XG5cbiAgICB2YXIgdGV4dHVyZSA9IHNwcml0ZS50ZXh0dXJlO1xuXG4gICAgY29sb3IgPSBQSVhJLkNhbnZhc1RpbnRlci5yb3VuZENvbG9yKGNvbG9yKTtcblxuICAgIHZhciBzdHJpbmdDb2xvciA9IFwiI1wiICsgKFwiMDAwMDBcIiArICggY29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG4gICBcbiAgICB0ZXh0dXJlLnRpbnRDYWNoZSA9IHRleHR1cmUudGludENhY2hlIHx8IHt9O1xuXG4gICAgaWYodGV4dHVyZS50aW50Q2FjaGVbc3RyaW5nQ29sb3JdKSByZXR1cm4gdGV4dHVyZS50aW50Q2FjaGVbc3RyaW5nQ29sb3JdO1xuXG4gICAgIC8vIGNsb25lIHRleHR1cmUuLlxuICAgIHZhciBjYW52YXMgPSBQSVhJLkNhbnZhc1RpbnRlci5jYW52YXMgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBcbiAgICAvL1BJWEkuQ2FudmFzVGludGVyLnRpbnRXaXRoUGVyUGl4ZWwodGV4dHVyZSwgc3RyaW5nQ29sb3IsIGNhbnZhcyk7XG5cbiAgICBcbiAgICBQSVhJLkNhbnZhc1RpbnRlci50aW50TWV0aG9kKHRleHR1cmUsIGNvbG9yLCBjYW52YXMpO1xuXG4gICAgaWYoUElYSS5DYW52YXNUaW50ZXIuY29udmVydFRpbnRUb0ltYWdlKVxuICAgIHtcbiAgICAgICAgLy8gaXMgdGhpcyBiZXR0ZXI/XG4gICAgICAgIHZhciB0aW50SW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgdGludEltYWdlLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoKTtcblxuICAgICAgICB0ZXh0dXJlLnRpbnRDYWNoZVtzdHJpbmdDb2xvcl0gPSB0aW50SW1hZ2U7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICBcbiAgICAgICAgdGV4dHVyZS50aW50Q2FjaGVbc3RyaW5nQ29sb3JdID0gY2FudmFzO1xuICAgICAgICAvLyBpZiB3ZSBhcmUgbm90IGNvbnZlcnRpbmcgdGhlIHRleHR1cmUgdG8gYW4gaW1hZ2UgdGhlbiB3ZSBuZWVkIHRvIGxvc2UgdGhlIHJlZmVyZW5jZSB0byB0aGUgY2FudmFzXG4gICAgICAgIFBJWEkuQ2FudmFzVGludGVyLmNhbnZhcyA9IG51bGw7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gY2FudmFzO1xufTtcblxuLyoqXG4gKiBUaW50IGEgdGV4dHVyZSB1c2luZyB0aGUgXCJtdWx0aXBseVwiIG9wZXJhdGlvblxuICogQG1ldGhvZCB0aW50V2l0aE11bHRpcGx5XG4gKiBAcGFyYW0gdGV4dHVyZSB7dGV4dHVyZX0gdGhlIHRleHR1cmUgdG8gdGludFxuICogQHBhcmFtIGNvbG9yIHtOdW1iZXJ9IHRoZSBjb2xvciB0byB1c2UgdG8gdGludCB0aGUgc3ByaXRlIHdpdGhcbiAqIEBwYXJhbSBjYW52YXMge0hUTUxDYW52YXNFbGVtZW50fSB0aGUgY3VycmVudCBjYW52YXNcbiAqL1xuUElYSS5DYW52YXNUaW50ZXIudGludFdpdGhNdWx0aXBseSA9IGZ1bmN0aW9uKHRleHR1cmUsIGNvbG9yLCBjYW52YXMpXG57XG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggXCIyZFwiICk7XG5cbiAgICB2YXIgZnJhbWUgPSB0ZXh0dXJlLmZyYW1lO1xuXG4gICAgY2FudmFzLndpZHRoID0gZnJhbWUud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGZyYW1lLmhlaWdodDtcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCIjXCIgKyAoXCIwMDAwMFwiICsgKCBjb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICBcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGZyYW1lLndpZHRoLCBmcmFtZS5oZWlnaHQpO1xuICAgIFxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJtdWx0aXBseVwiO1xuXG4gICAgY29udGV4dC5kcmF3SW1hZ2UodGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLmhlaWdodCk7XG5cbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24tYXRvcFwiO1xuICAgIFxuICAgIGNvbnRleHQuZHJhd0ltYWdlKHRleHR1cmUuYmFzZVRleHR1cmUuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5oZWlnaHQpO1xufTtcblxuLyoqXG4gKiBUaW50IGEgdGV4dHVyZSB1c2luZyB0aGUgXCJvdmVybGF5XCIgb3BlcmF0aW9uXG4gKiBAbWV0aG9kIHRpbnRXaXRoT3ZlcmxheVxuICogQHBhcmFtIHRleHR1cmUge3RleHR1cmV9IHRoZSB0ZXh0dXJlIHRvIHRpbnRcbiAqIEBwYXJhbSBjb2xvciB7TnVtYmVyfSB0aGUgY29sb3IgdG8gdXNlIHRvIHRpbnQgdGhlIHNwcml0ZSB3aXRoXG4gKiBAcGFyYW0gY2FudmFzIHtIVE1MQ2FudmFzRWxlbWVudH0gdGhlIGN1cnJlbnQgY2FudmFzXG4gKi9cblBJWEkuQ2FudmFzVGludGVyLnRpbnRXaXRoT3ZlcmxheSA9IGZ1bmN0aW9uKHRleHR1cmUsIGNvbG9yLCBjYW52YXMpXG57XG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggXCIyZFwiICk7XG5cbiAgICB2YXIgZnJhbWUgPSB0ZXh0dXJlLmZyYW1lO1xuXG4gICAgY2FudmFzLndpZHRoID0gZnJhbWUud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGZyYW1lLmhlaWdodDtcblxuICAgIFxuICAgIFxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJjb3B5XCI7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBcIiNcIiArIChcIjAwMDAwXCIgKyAoIGNvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgZnJhbWUud2lkdGgsIGZyYW1lLmhlaWdodCk7XG5cbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24tYXRvcFwiO1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKHRleHR1cmUuYmFzZVRleHR1cmUuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5oZWlnaHQpO1xuXG4gICAgXG4gICAgLy9jb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiY29weVwiO1xuXG59O1xuXG4vKipcbiAqIFRpbnQgYSB0ZXh0dXJlIHBpeGVsIHBlciBwaXhlbFxuICogQG1ldGhvZCB0aW50UGVyUGl4ZWxcbiAqIEBwYXJhbSB0ZXh0dXJlIHt0ZXh0dXJlfSB0aGUgdGV4dHVyZSB0byB0aW50XG4gKiBAcGFyYW0gY29sb3Ige051bWJlcn0gdGhlIGNvbG9yIHRvIHVzZSB0byB0aW50IHRoZSBzcHJpdGUgd2l0aFxuICogQHBhcmFtIGNhbnZhcyB7SFRNTENhbnZhc0VsZW1lbnR9IHRoZSBjdXJyZW50IGNhbnZhc1xuICovXG5QSVhJLkNhbnZhc1RpbnRlci50aW50V2l0aFBlclBpeGVsID0gZnVuY3Rpb24odGV4dHVyZSwgY29sb3IsIGNhbnZhcylcbntcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCBcIjJkXCIgKTtcblxuICAgIHZhciBmcmFtZSA9IHRleHR1cmUuZnJhbWU7XG5cbiAgICBjYW52YXMud2lkdGggPSBmcmFtZS53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gZnJhbWUuaGVpZ2h0O1xuICBcbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiY29weVwiO1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKHRleHR1cmUuYmFzZVRleHR1cmUuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5oZWlnaHQpO1xuXG4gICAgdmFyIHJnYlZhbHVlcyA9IFBJWEkuaGV4MnJnYihjb2xvcik7XG4gICAgdmFyIHIgPSByZ2JWYWx1ZXNbMF0sIGcgPSByZ2JWYWx1ZXNbMV0sIGIgPSByZ2JWYWx1ZXNbMl07XG5cbiAgICB2YXIgcGl4ZWxEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgZnJhbWUud2lkdGgsIGZyYW1lLmhlaWdodCk7XG5cbiAgICB2YXIgcGl4ZWxzID0gcGl4ZWxEYXRhLmRhdGE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBpeGVscy5sZW5ndGg7IGkgKz0gNClcbiAgICB7XG4gICAgICAgIHBpeGVsc1tpKzBdICo9IHI7XG4gICAgICAgIHBpeGVsc1tpKzFdICo9IGc7XG4gICAgICAgIHBpeGVsc1tpKzJdICo9IGI7XG4gICAgfVxuXG4gICAgY29udGV4dC5wdXRJbWFnZURhdGEocGl4ZWxEYXRhLCAwLCAwKTtcbn07XG5cbi8qKlxuICogUm91bmRzIHRoZSBzcGVjaWZpZWQgY29sb3IgYWNjb3JkaW5nIHRvIHRoZSBQSVhJLkNhbnZhc1RpbnRlci5jYWNoZVN0ZXBzUGVyQ29sb3JDaGFubmVsXG4gKiBAbWV0aG9kIHJvdW5kQ29sb3JcbiAqIEBwYXJhbSBjb2xvciB7bnVtYmVyfSB0aGUgY29sb3IgdG8gcm91bmQsIHNob3VsZCBiZSBhIGhleCBjb2xvclxuICovXG5QSVhJLkNhbnZhc1RpbnRlci5yb3VuZENvbG9yID0gZnVuY3Rpb24oY29sb3IpXG57XG4gICAgdmFyIHN0ZXAgPSBQSVhJLkNhbnZhc1RpbnRlci5jYWNoZVN0ZXBzUGVyQ29sb3JDaGFubmVsO1xuXG4gICAgdmFyIHJnYlZhbHVlcyA9IFBJWEkuaGV4MnJnYihjb2xvcik7XG5cbiAgICByZ2JWYWx1ZXNbMF0gPSBNYXRoLm1pbigyNTUsIChyZ2JWYWx1ZXNbMF0gLyBzdGVwKSAqIHN0ZXApO1xuICAgIHJnYlZhbHVlc1sxXSA9IE1hdGgubWluKDI1NSwgKHJnYlZhbHVlc1sxXSAvIHN0ZXApICogc3RlcCk7XG4gICAgcmdiVmFsdWVzWzJdID0gTWF0aC5taW4oMjU1LCAocmdiVmFsdWVzWzJdIC8gc3RlcCkgKiBzdGVwKTtcblxuICAgIHJldHVybiBQSVhJLnJnYjJoZXgocmdiVmFsdWVzKTtcbn07XG5cbi8qKlxuICogXG4gKiBOdW1iZXIgb2Ygc3RlcHMgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGEgY2FwIHdoZW4gcm91bmRpbmcgY29sb3JzXG4gKlxuICogQHByb3BlcnR5IGNhY2hlU3RlcHNQZXJDb2xvckNoYW5uZWxcbiAqIEB0eXBlIE51bWJlclxuICovXG5QSVhJLkNhbnZhc1RpbnRlci5jYWNoZVN0ZXBzUGVyQ29sb3JDaGFubmVsID0gODtcbi8qKlxuICogXG4gKiBOdW1iZXIgb2Ygc3RlcHMgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGEgY2FwIHdoZW4gcm91bmRpbmcgY29sb3JzXG4gKlxuICogQHByb3BlcnR5IGNvbnZlcnRUaW50VG9JbWFnZVxuICogQHR5cGUgQm9vbGVhblxuICovXG5QSVhJLkNhbnZhc1RpbnRlci5jb252ZXJ0VGludFRvSW1hZ2UgPSBmYWxzZTtcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgQ2FudmFzIEJsZW5kTW9kZXMgYXJlIHN1cHBvcnRlZCwgY29uc2VxdWVudGx5IHRoZSBhYmlsaXR5IHRvIHRpbnQgdXNpbmcgdGhlIG11bHRpcGx5IG1ldGhvZFxuICpcbiAqIEBwcm9wZXJ0eSBjYW5Vc2VNdWx0aXBseVxuICogQHR5cGUgQm9vbGVhblxuICovXG5QSVhJLkNhbnZhc1RpbnRlci5jYW5Vc2VNdWx0aXBseSA9IFBJWEkuY2FuVXNlTmV3Q2FudmFzQmxlbmRNb2RlcygpO1xuXG5QSVhJLkNhbnZhc1RpbnRlci50aW50TWV0aG9kID0gUElYSS5DYW52YXNUaW50ZXIuY2FuVXNlTXVsdGlwbHkgPyBQSVhJLkNhbnZhc1RpbnRlci50aW50V2l0aE11bHRpcGx5IDogIFBJWEkuQ2FudmFzVGludGVyLnRpbnRXaXRoUGVyUGl4ZWw7XG5cblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqIHRoZSBDYW52YXNSZW5kZXJlciBkcmF3cyB0aGUgc3RhZ2UgYW5kIGFsbCBpdHMgY29udGVudCBvbnRvIGEgMmQgY2FudmFzLiBUaGlzIHJlbmRlcmVyIHNob3VsZCBiZSB1c2VkIGZvciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IHdlYkdMLlxuICogRG9udCBmb3JnZXQgdG8gYWRkIHRoZSB2aWV3IHRvIHlvdXIgRE9NIG9yIHlvdSB3aWxsIG5vdCBzZWUgYW55dGhpbmcgOilcbiAqXG4gKiBAY2xhc3MgQ2FudmFzUmVuZGVyZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHdpZHRoPTgwMCB7TnVtYmVyfSB0aGUgd2lkdGggb2YgdGhlIGNhbnZhcyB2aWV3XG4gKiBAcGFyYW0gaGVpZ2h0PTYwMCB7TnVtYmVyfSB0aGUgaGVpZ2h0IG9mIHRoZSBjYW52YXMgdmlld1xuICogQHBhcmFtIFt2aWV3XSB7SFRNTENhbnZhc0VsZW1lbnR9IHRoZSBjYW52YXMgdG8gdXNlIGFzIGEgdmlldywgb3B0aW9uYWxcbiAqIEBwYXJhbSBbdHJhbnNwYXJlbnQ9ZmFsc2VdIHtCb29sZWFufSB0aGUgdHJhbnNwYXJlbmN5IG9mIHRoZSByZW5kZXIgdmlldywgZGVmYXVsdCBmYWxzZVxuICovXG5QSVhJLkNhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgdmlldywgdHJhbnNwYXJlbnQpXG57XG4gICAgaWYoIVBJWEkuZGVmYXVsdFJlbmRlcmVyKVxuICAgIHtcbiAgICAgICAgUElYSS5zYXlIZWxsbyhcIkNhbnZhc1wiKTtcbiAgICAgICAgUElYSS5kZWZhdWx0UmVuZGVyZXIgPSB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMudHlwZSA9IFBJWEkuQ0FOVkFTX1JFTkRFUkVSO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBzZXRzIGlmIHRoZSBDYW52YXNSZW5kZXJlciB3aWxsIGNsZWFyIHRoZSBjYW52YXMgb3Igbm90IGJlZm9yZSB0aGUgbmV3IHJlbmRlciBwYXNzLlxuICAgICAqIElmIHRoZSBTdGFnZSBpcyBOT1QgdHJhbnNwYXJlbnQgUGl4aSB3aWxsIHVzZSBhIGNhbnZhcyBzaXplZCBmaWxsUmVjdCBvcGVyYXRpb24gZXZlcnkgZnJhbWUgdG8gc2V0IHRoZSBjYW52YXMgYmFja2dyb3VuZCBjb2xvci5cbiAgICAgKiBJZiB0aGUgU3RhZ2UgaXMgdHJhbnNwYXJlbnQgUGl4aSB3aWxsIHVzZSBjbGVhclJlY3QgdG8gY2xlYXIgdGhlIGNhbnZhcyBldmVyeSBmcmFtZS5cbiAgICAgKiBEaXNhYmxlIHRoaXMgYnkgc2V0dGluZyB0aGlzIHRvIGZhbHNlLiBGb3IgZXhhbXBsZSBpZiB5b3VyIGdhbWUgaGFzIGEgY2FudmFzIGZpbGxpbmcgYmFja2dyb3VuZCBpbWFnZSB5b3Ugb2Z0ZW4gZG9uJ3QgbmVlZCB0aGlzIHNldC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjbGVhckJlZm9yZVJlbmRlclxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVuZGVyIHZpZXcgaXMgdHJhbnNwYXJlbnRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0cmFuc3BhcmVudFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zcGFyZW50ID0gISF0cmFuc3BhcmVudDtcblxuICAgIGlmKCFQSVhJLmJsZW5kTW9kZXNDYW52YXMpXG4gICAge1xuICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXMgPSBbXTtcblxuICAgICAgICBpZihQSVhJLmNhblVzZU5ld0NhbnZhc0JsZW5kTW9kZXMoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5OT1JNQUxdICAgPSBcInNvdXJjZS1vdmVyXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLkFERF0gICAgICA9IFwibGlnaHRlclwiOyAvL0lTIFRISVMgT0s/Pz9cbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuTVVMVElQTFldID0gXCJtdWx0aXBseVwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5TQ1JFRU5dICAgPSBcInNjcmVlblwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5PVkVSTEFZXSAgPSBcIm92ZXJsYXlcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuREFSS0VOXSAgID0gXCJkYXJrZW5cIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuTElHSFRFTl0gID0gXCJsaWdodGVuXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLkNPTE9SX0RPREdFXSA9IFwiY29sb3ItZG9kZ2VcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuQ09MT1JfQlVSTl0gPSBcImNvbG9yLWJ1cm5cIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuSEFSRF9MSUdIVF0gPSBcImhhcmQtbGlnaHRcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuU09GVF9MSUdIVF0gPSBcInNvZnQtbGlnaHRcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuRElGRkVSRU5DRV0gPSBcImRpZmZlcmVuY2VcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuRVhDTFVTSU9OXSA9IFwiZXhjbHVzaW9uXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLkhVRV0gICAgICAgPSBcImh1ZVwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5TQVRVUkFUSU9OXSA9IFwic2F0dXJhdGlvblwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5DT0xPUl0gICAgICA9IFwiY29sb3JcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuTFVNSU5PU0lUWV0gPSBcImx1bWlub3NpdHlcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBjb29sIG5ldyBibGVuZCBtb2RlcyBpbiBjYW52YXMgXCJjb3VnaFwiIGllIFwiY291Z2hcIlxuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5OT1JNQUxdICAgPSBcInNvdXJjZS1vdmVyXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLkFERF0gICAgICA9IFwibGlnaHRlclwiOyAvL0lTIFRISVMgT0s/Pz9cbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuTVVMVElQTFldID0gXCJzb3VyY2Utb3ZlclwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5TQ1JFRU5dICAgPSBcInNvdXJjZS1vdmVyXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLk9WRVJMQVldICA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuREFSS0VOXSAgID0gXCJzb3VyY2Utb3ZlclwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5MSUdIVEVOXSAgPSBcInNvdXJjZS1vdmVyXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLkNPTE9SX0RPREdFXSA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuQ09MT1JfQlVSTl0gPSBcInNvdXJjZS1vdmVyXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLkhBUkRfTElHSFRdID0gXCJzb3VyY2Utb3ZlclwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5TT0ZUX0xJR0hUXSA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuRElGRkVSRU5DRV0gPSBcInNvdXJjZS1vdmVyXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLkVYQ0xVU0lPTl0gPSBcInNvdXJjZS1vdmVyXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLkhVRV0gICAgICAgPSBcInNvdXJjZS1vdmVyXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLlNBVFVSQVRJT05dID0gXCJzb3VyY2Utb3ZlclwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5DT0xPUl0gICAgICA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuTFVNSU5PU0lUWV0gPSBcInNvdXJjZS1vdmVyXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIGNhbnZhcyB2aWV3XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgd2lkdGhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCA4MDBcbiAgICAgKi9cbiAgICB0aGlzLndpZHRoID0gd2lkdGggfHwgODAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgY2FudmFzIHZpZXdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBoZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCA2MDBcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCA2MDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FudmFzIGVsZW1lbnQgdGhhdCBldmVyeXRoaW5nIGlzIGRyYXduIHRvXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdmlld1xuICAgICAqIEB0eXBlIEhUTUxDYW52YXNFbGVtZW50XG4gICAgICovXG4gICAgdGhpcy52aWV3ID0gdmlldyB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImNhbnZhc1wiICk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FudmFzIDJkIGNvbnRleHQgdGhhdCBldmVyeXRoaW5nIGlzIGRyYXduIHdpdGhcbiAgICAgKiBAcHJvcGVydHkgY29udGV4dFxuICAgICAqIEB0eXBlIEhUTUxDYW52YXNFbGVtZW50IDJkIENvbnRleHRcbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLnZpZXcuZ2V0Q29udGV4dCggXCIyZFwiLCB7IGFscGhhOiB0aGlzLnRyYW5zcGFyZW50IH0gKTtcblxuICAgIHRoaXMucmVmcmVzaCA9IHRydWU7XG4gICAgLy8gaGFjayB0byBlbmFibGUgc29tZSBoYXJkd2FyZSBhY2NlbGVyYXRpb24hXG4gICAgLy90aGlzLnZpZXcuc3R5bGVbXCJ0cmFuc2Zvcm1cIl0gPSBcInRyYW5zbGF0ZXooMClcIjtcblxuICAgIHRoaXMudmlldy53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgdGhpcy52aWV3LmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIHRoaXMuY291bnQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogSW5zdGFuY2Ugb2YgYSBQSVhJLkNhbnZhc01hc2tNYW5hZ2VyLCBoYW5kbGVzIG1hc2tpbmcgd2hlbiB1c2luZyB0aGUgY2FudmFzIHJlbmRlcmVyXG4gICAgICogQHByb3BlcnR5IENhbnZhc01hc2tNYW5hZ2VyXG4gICAgICogQHR5cGUgQ2FudmFzTWFza01hbmFnZXJcbiAgICAgKi9cbiAgICB0aGlzLm1hc2tNYW5hZ2VyID0gbmV3IFBJWEkuQ2FudmFzTWFza01hbmFnZXIoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZW5kZXIgc2Vzc2lvbiBpcyBqdXN0IGEgYnVuY2ggb2YgcGFyYW1ldGVyIHVzZWQgZm9yIHJlbmRlcmluZ1xuICAgICAqIEBwcm9wZXJ0eSByZW5kZXJTZXNzaW9uXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uID0ge1xuICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICAgIG1hc2tNYW5hZ2VyOiB0aGlzLm1hc2tNYW5hZ2VyLFxuICAgICAgICBzY2FsZU1vZGU6IG51bGwsXG4gICAgICAgIHNtb290aFByb3BlcnR5OiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlIFBpeGkgd2lsbCBNYXRoLmZsb29yKCkgeC95IHZhbHVlcyB3aGVuIHJlbmRlcmluZywgc3RvcHBpbmcgcGl4ZWwgaW50ZXJwb2xhdGlvbi5cbiAgICAgICAgICogSGFuZHkgZm9yIGNyaXNwIHBpeGVsIGFydCBhbmQgc3BlZWQgb24gbGVnYWN5IGRldmljZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICByb3VuZFBpeGVsczogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYoXCJpbWFnZVNtb290aGluZ0VuYWJsZWRcIiBpbiB0aGlzLmNvbnRleHQpXG4gICAgICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5zbW9vdGhQcm9wZXJ0eSA9IFwiaW1hZ2VTbW9vdGhpbmdFbmFibGVkXCI7XG4gICAgZWxzZSBpZihcIndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZFwiIGluIHRoaXMuY29udGV4dClcbiAgICAgICAgdGhpcy5yZW5kZXJTZXNzaW9uLnNtb290aFByb3BlcnR5ID0gXCJ3ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWRcIjtcbiAgICBlbHNlIGlmKFwibW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkXCIgaW4gdGhpcy5jb250ZXh0KVxuICAgICAgICB0aGlzLnJlbmRlclNlc3Npb24uc21vb3RoUHJvcGVydHkgPSBcIm1vekltYWdlU21vb3RoaW5nRW5hYmxlZFwiO1xuICAgIGVsc2UgaWYoXCJvSW1hZ2VTbW9vdGhpbmdFbmFibGVkXCIgaW4gdGhpcy5jb250ZXh0KVxuICAgICAgICB0aGlzLnJlbmRlclNlc3Npb24uc21vb3RoUHJvcGVydHkgPSBcIm9JbWFnZVNtb290aGluZ0VuYWJsZWRcIjtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuQ2FudmFzUmVuZGVyZXI7XG5cbi8qKlxuICogUmVuZGVycyB0aGUgc3RhZ2UgdG8gaXRzIGNhbnZhcyB2aWV3XG4gKlxuICogQG1ldGhvZCByZW5kZXJcbiAqIEBwYXJhbSBzdGFnZSB7U3RhZ2V9IHRoZSBTdGFnZSBlbGVtZW50IHRvIGJlIHJlbmRlcmVkXG4gKi9cblBJWEkuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHN0YWdlKVxue1xuICAgIC8vIHVwZGF0ZSB0ZXh0dXJlcyBpZiBuZWVkIGJlXG4gICAgUElYSS50ZXh0dXJlc1RvVXBkYXRlLmxlbmd0aCA9IDA7XG4gICAgUElYSS50ZXh0dXJlc1RvRGVzdHJveS5sZW5ndGggPSAwO1xuXG4gICAgc3RhZ2UudXBkYXRlVHJhbnNmb3JtKCk7XG5cbiAgICB0aGlzLmNvbnRleHQuc2V0VHJhbnNmb3JtKDEsMCwwLDEsMCwwKTtcbiAgICB0aGlzLmNvbnRleHQuZ2xvYmFsQWxwaGEgPSAxO1xuXG4gICAgaWYgKG5hdmlnYXRvci5pc0NvY29vbkpTICYmIHRoaXMudmlldy5zY3JlZW5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNsZWFyKCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnRyYW5zcGFyZW50ICYmIHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIpXG4gICAge1xuICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gc3RhZ2UuYmFja2dyb3VuZENvbG9yU3RyaW5nO1xuICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLnRyYW5zcGFyZW50ICYmIHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIpXG4gICAge1xuICAgICAgICB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlckRpc3BsYXlPYmplY3Qoc3RhZ2UpO1xuXG4gICAgLy8gcnVuIGludGVyYWN0aW9uIVxuICAgIGlmKHN0YWdlLmludGVyYWN0aXZlKVxuICAgIHtcbiAgICAgICAgLy9uZWVkIHRvIGFkZCBzb21lIGV2ZW50cyFcbiAgICAgICAgaWYoIXN0YWdlLl9pbnRlcmFjdGl2ZUV2ZW50c0FkZGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBzdGFnZS5faW50ZXJhY3RpdmVFdmVudHNBZGRlZCA9IHRydWU7XG4gICAgICAgICAgICBzdGFnZS5pbnRlcmFjdGlvbk1hbmFnZXIuc2V0VGFyZ2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGZyYW1lIHVwZGF0ZXMuLlxuICAgIGlmKFBJWEkuVGV4dHVyZS5mcmFtZVVwZGF0ZXMubGVuZ3RoID4gMClcbiAgICB7XG4gICAgICAgIFBJWEkuVGV4dHVyZS5mcmFtZVVwZGF0ZXMubGVuZ3RoID0gMDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlc2l6ZXMgdGhlIGNhbnZhcyB2aWV3IHRvIHRoZSBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodFxuICpcbiAqIEBtZXRob2QgcmVzaXplXG4gKiBAcGFyYW0gd2lkdGgge051bWJlcn0gdGhlIG5ldyB3aWR0aCBvZiB0aGUgY2FudmFzIHZpZXdcbiAqIEBwYXJhbSBoZWlnaHQge051bWJlcn0gdGhlIG5ldyBoZWlnaHQgb2YgdGhlIGNhbnZhcyB2aWV3XG4gKi9cblBJWEkuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpXG57XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgdGhpcy52aWV3LndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy52aWV3LmhlaWdodCA9IGhlaWdodDtcbn07XG5cbi8qKlxuICogUmVuZGVycyBhIGRpc3BsYXkgb2JqZWN0XG4gKlxuICogQG1ldGhvZCByZW5kZXJEaXNwbGF5T2JqZWN0XG4gKiBAcGFyYW0gZGlzcGxheU9iamVjdCB7RGlzcGxheU9iamVjdH0gVGhlIGRpc3BsYXlPYmplY3QgdG8gcmVuZGVyXG4gKiBAcGFyYW0gY29udGV4dCB7Q29udGV4dDJEfSB0aGUgY29udGV4dCAyZCBtZXRob2Qgb2YgdGhlIGNhbnZhc1xuICogQHByaXZhdGVcbiAqL1xuUElYSS5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRGlzcGxheU9iamVjdCA9IGZ1bmN0aW9uKGRpc3BsYXlPYmplY3QsIGNvbnRleHQpXG57XG4gICAgLy8gbm8gbG9uZ2VyIHJlY3Vyc2l2ZSFcbiAgICAvL3ZhciB0cmFuc2Zvcm07XG4gICAgLy92YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5jb250ZXh0ID0gY29udGV4dCB8fCB0aGlzLmNvbnRleHQ7XG4gICAgZGlzcGxheU9iamVjdC5fcmVuZGVyQ2FudmFzKHRoaXMucmVuZGVyU2Vzc2lvbik7XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgYSBmbGF0IHN0cmlwXG4gKlxuICogQG1ldGhvZCByZW5kZXJTdHJpcEZsYXRcbiAqIEBwYXJhbSBzdHJpcCB7U3RyaXB9IFRoZSBTdHJpcCB0byByZW5kZXJcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclN0cmlwRmxhdCA9IGZ1bmN0aW9uKHN0cmlwKVxue1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgIHZhciB2ZXJ0aWNpZXMgPSBzdHJpcC52ZXJ0aWNpZXM7XG5cbiAgICB2YXIgbGVuZ3RoID0gdmVydGljaWVzLmxlbmd0aC8yO1xuICAgIHRoaXMuY291bnQrKztcblxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgZm9yICh2YXIgaT0xOyBpIDwgbGVuZ3RoLTI7IGkrKylcbiAgICB7XG4gICAgICAgIC8vIGRyYXcgc29tZSB0cmlhbmdsZXMhXG4gICAgICAgIHZhciBpbmRleCA9IGkqMjtcblxuICAgICAgICB2YXIgeDAgPSB2ZXJ0aWNpZXNbaW5kZXhdLCAgIHgxID0gdmVydGljaWVzW2luZGV4KzJdLCB4MiA9IHZlcnRpY2llc1tpbmRleCs0XTtcbiAgICAgICAgdmFyIHkwID0gdmVydGljaWVzW2luZGV4KzFdLCB5MSA9IHZlcnRpY2llc1tpbmRleCszXSwgeTIgPSB2ZXJ0aWNpZXNbaW5kZXgrNV07XG5cbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeDAsIHkwKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeDEsIHkxKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeDIsIHkyKTtcbiAgICB9XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwiI0ZGMDAwMFwiO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgYSBzdHJpcFxuICpcbiAqIEBtZXRob2QgcmVuZGVyU3RyaXBcbiAqIEBwYXJhbSBzdHJpcCB7U3RyaXB9IFRoZSBTdHJpcCB0byByZW5kZXJcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclN0cmlwID0gZnVuY3Rpb24oc3RyaXApXG57XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAvLyBkcmF3IHRyaWFuZ2xlcyEhXG4gICAgdmFyIHZlcnRpY2llcyA9IHN0cmlwLnZlcnRpY2llcztcbiAgICB2YXIgdXZzID0gc3RyaXAudXZzO1xuXG4gICAgdmFyIGxlbmd0aCA9IHZlcnRpY2llcy5sZW5ndGgvMjtcbiAgICB0aGlzLmNvdW50Kys7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aC0yOyBpKyspXG4gICAge1xuICAgICAgICAvLyBkcmF3IHNvbWUgdHJpYW5nbGVzIVxuICAgICAgICB2YXIgaW5kZXggPSBpKjI7XG5cbiAgICAgICAgdmFyIHgwID0gdmVydGljaWVzW2luZGV4XSwgICB4MSA9IHZlcnRpY2llc1tpbmRleCsyXSwgeDIgPSB2ZXJ0aWNpZXNbaW5kZXgrNF07XG4gICAgICAgIHZhciB5MCA9IHZlcnRpY2llc1tpbmRleCsxXSwgeTEgPSB2ZXJ0aWNpZXNbaW5kZXgrM10sIHkyID0gdmVydGljaWVzW2luZGV4KzVdO1xuXG4gICAgICAgIHZhciB1MCA9IHV2c1tpbmRleF0gKiBzdHJpcC50ZXh0dXJlLndpZHRoLCAgIHUxID0gdXZzW2luZGV4KzJdICogc3RyaXAudGV4dHVyZS53aWR0aCwgdTIgPSB1dnNbaW5kZXgrNF0qIHN0cmlwLnRleHR1cmUud2lkdGg7XG4gICAgICAgIHZhciB2MCA9IHV2c1tpbmRleCsxXSogc3RyaXAudGV4dHVyZS5oZWlnaHQsIHYxID0gdXZzW2luZGV4KzNdICogc3RyaXAudGV4dHVyZS5oZWlnaHQsIHYyID0gdXZzW2luZGV4KzVdKiBzdHJpcC50ZXh0dXJlLmhlaWdodDtcblxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeDAsIHkwKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeDEsIHkxKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeDIsIHkyKTtcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgICAgICBjb250ZXh0LmNsaXAoKTtcblxuICAgICAgICAvLyBDb21wdXRlIG1hdHJpeCB0cmFuc2Zvcm1cbiAgICAgICAgdmFyIGRlbHRhID0gdTAqdjEgKyB2MCp1MiArIHUxKnYyIC0gdjEqdTIgLSB2MCp1MSAtIHUwKnYyO1xuICAgICAgICB2YXIgZGVsdGFBID0geDAqdjEgKyB2MCp4MiArIHgxKnYyIC0gdjEqeDIgLSB2MCp4MSAtIHgwKnYyO1xuICAgICAgICB2YXIgZGVsdGFCID0gdTAqeDEgKyB4MCp1MiArIHUxKngyIC0geDEqdTIgLSB4MCp1MSAtIHUwKngyO1xuICAgICAgICB2YXIgZGVsdGFDID0gdTAqdjEqeDIgKyB2MCp4MSp1MiArIHgwKnUxKnYyIC0geDAqdjEqdTIgLSB2MCp1MSp4MiAtIHUwKngxKnYyO1xuICAgICAgICB2YXIgZGVsdGFEID0geTAqdjEgKyB2MCp5MiArIHkxKnYyIC0gdjEqeTIgLSB2MCp5MSAtIHkwKnYyO1xuICAgICAgICB2YXIgZGVsdGFFID0gdTAqeTEgKyB5MCp1MiArIHUxKnkyIC0geTEqdTIgLSB5MCp1MSAtIHUwKnkyO1xuICAgICAgICB2YXIgZGVsdGFGID0gdTAqdjEqeTIgKyB2MCp5MSp1MiArIHkwKnUxKnYyIC0geTAqdjEqdTIgLSB2MCp1MSp5MiAtIHUwKnkxKnYyO1xuXG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtKGRlbHRhQSAvIGRlbHRhLCBkZWx0YUQgLyBkZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YUIgLyBkZWx0YSwgZGVsdGFFIC8gZGVsdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFDIC8gZGVsdGEsIGRlbHRhRiAvIGRlbHRhKTtcblxuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShzdHJpcC50ZXh0dXJlLmJhc2VUZXh0dXJlLnNvdXJjZSwgMCwgMCk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIENhbnZhcyBlbGVtZW50IG9mIHRoZSBnaXZlbiBzaXplXG4gKlxuICogQG1ldGhvZCBDYW52YXNCdWZmZXJcbiAqIEBwYXJhbSB3aWR0aCB7TnVtYmVyfSB0aGUgd2lkdGggZm9yIHRoZSBuZXdseSBjcmVhdGVkIGNhbnZhc1xuICogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSB0aGUgaGVpZ2h0IGZvciB0aGUgbmV3bHkgY3JlYXRlZCBjYW52YXNcbiAqIEBzdGF0aWNcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuQ2FudmFzQnVmZmVyID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodClcbntcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiY2FudmFzXCIgKTtcbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCBcIjJkXCIgKTtcblxuICAgIHRoaXMuY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIGNhbnZhcyB0aGF0IHdhcyBjcmVhdGVkIGJ5IHRoZSBDYW52YXNCdWZmZXIgY2xhc3NcbiAqXG4gKiBAbWV0aG9kIGNsZWFyXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkNhbnZhc0J1ZmZlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbn07XG5cbi8qKlxuICogUmVzaXplcyB0aGUgY2FudmFzIHRoYXQgd2FzIGNyZWF0ZWQgYnkgdGhlIENhbnZhc0J1ZmZlciBjbGFzcyB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHRcbiAqXG4gKiBAbWV0aG9kIHJlc2l6ZVxuICogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IHRoZSBuZXcgd2lkdGggb2YgdGhlIGNhbnZhc1xuICogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSB0aGUgbmV3IGhlaWdodCBvZiB0aGUgY2FudmFzXG4gKiBAcHJpdmF0ZVxuICovXG5cblBJWEkuQ2FudmFzQnVmZmVyLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KVxue1xuICAgIHRoaXMud2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xufTtcblxuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cblxuLyoqXG4gKiBBIHNldCBvZiBmdW5jdGlvbnMgdXNlZCBieSB0aGUgY2FudmFzIHJlbmRlcmVyIHRvIGRyYXcgdGhlIHByaW1pdGl2ZSBncmFwaGljcyBkYXRhXG4gKlxuICogQGNsYXNzIENhbnZhc0dyYXBoaWNzXG4gKi9cblBJWEkuQ2FudmFzR3JhcGhpY3MgPSBmdW5jdGlvbigpXG57XG5cbn07XG5cblxuLypcbiAqIFJlbmRlcnMgdGhlIGdyYXBoaWNzIG9iamVjdFxuICpcbiAqIEBzdGF0aWNcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIHJlbmRlckdyYXBoaWNzXG4gKiBAcGFyYW0gZ3JhcGhpY3Mge0dyYXBoaWNzfSB0aGUgYWN0dWFsIGdyYXBoaWNzIG9iamVjdCB0byByZW5kZXJcbiAqIEBwYXJhbSBjb250ZXh0IHtDb250ZXh0MkR9IHRoZSAyZCBkcmF3aW5nIG1ldGhvZCBvZiB0aGUgY2FudmFzXG4gKi9cblBJWEkuQ2FudmFzR3JhcGhpY3MucmVuZGVyR3JhcGhpY3MgPSBmdW5jdGlvbihncmFwaGljcywgY29udGV4dClcbntcbiAgICB2YXIgd29ybGRBbHBoYSA9IGdyYXBoaWNzLndvcmxkQWxwaGE7XG4gICAgdmFyIGNvbG9yID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYXBoaWNzLmdyYXBoaWNzRGF0YS5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBkYXRhID0gZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhW2ldO1xuICAgICAgICB2YXIgcG9pbnRzID0gZGF0YS5wb2ludHM7XG5cbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yID0gJyMnICsgKCcwMDAwMCcgKyAoIGRhdGEubGluZUNvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuXG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gZGF0YS5saW5lV2lkdGg7XG5cbiAgICAgICAgaWYoZGF0YS50eXBlID09PSBQSVhJLkdyYXBoaWNzLlBPTFkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaj0xOyBqIDwgcG9pbnRzLmxlbmd0aC8yOyBqKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocG9pbnRzW2ogKiAyXSwgcG9pbnRzW2ogKiAyICsgMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgZmlyc3QgYW5kIGxhc3QgcG9pbnQgYXJlIHRoZSBzYW1lIGNsb3NlIHRoZSBwYXRoIC0gbXVjaCBuZWF0ZXIgOilcbiAgICAgICAgICAgIGlmKHBvaW50c1swXSA9PT0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMl0gJiYgcG9pbnRzWzFdID09PSBwb2ludHNbcG9pbnRzLmxlbmd0aC0xXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihkYXRhLmZpbGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEuZmlsbEFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yID0gJyMnICsgKCcwMDAwMCcgKyAoIGRhdGEuZmlsbENvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZGF0YS5saW5lV2lkdGgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEubGluZUFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoZGF0YS50eXBlID09PSBQSVhJLkdyYXBoaWNzLlJFQ1QpXG4gICAgICAgIHtcblxuICAgICAgICAgICAgaWYoZGF0YS5maWxsQ29sb3IgfHwgZGF0YS5maWxsQ29sb3IgPT09IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEuZmlsbEFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yID0gJyMnICsgKCcwMDAwMCcgKyAoIGRhdGEuZmlsbENvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZGF0YS5saW5lV2lkdGgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEubGluZUFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoZGF0YS50eXBlID09PSBQSVhJLkdyYXBoaWNzLkNJUkMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFRPRE8gLSBuZWVkIHRvIGJlIFVuZGVmaW5lZCFcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LmFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLDAsMipNYXRoLlBJKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgICAgIGlmKGRhdGEuZmlsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5maWxsQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3IgPSAnIycgKyAoJzAwMDAwJyArICggZGF0YS5maWxsQ29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkYXRhLmxpbmVXaWR0aClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5saW5lQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihkYXRhLnR5cGUgPT09IFBJWEkuR3JhcGhpY3MuRUxJUClcbiAgICAgICAge1xuXG4gICAgICAgICAgICAvLyBlbGxpcHNlIGNvZGUgdGFrZW4gZnJvbTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMTcyNzk4L2hvdy10by1kcmF3LWFuLW92YWwtaW4taHRtbDUtY2FudmFzXG5cbiAgICAgICAgICAgIHZhciBlbGxpcHNlRGF0YSA9ICBkYXRhLnBvaW50cztcblxuICAgICAgICAgICAgdmFyIHcgPSBlbGxpcHNlRGF0YVsyXSAqIDI7XG4gICAgICAgICAgICB2YXIgaCA9IGVsbGlwc2VEYXRhWzNdICogMjtcblxuICAgICAgICAgICAgdmFyIHggPSBlbGxpcHNlRGF0YVswXSAtIHcvMjtcbiAgICAgICAgICAgIHZhciB5ID0gZWxsaXBzZURhdGFbMV0gLSBoLzI7XG5cbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgIHZhciBrYXBwYSA9IDAuNTUyMjg0OCxcbiAgICAgICAgICAgICAgICBveCA9ICh3IC8gMikgKiBrYXBwYSwgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgaG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgIG95ID0gKGggLyAyKSAqIGthcHBhLCAvLyBjb250cm9sIHBvaW50IG9mZnNldCB2ZXJ0aWNhbFxuICAgICAgICAgICAgICAgIHhlID0geCArIHcsICAgICAgICAgICAvLyB4LWVuZFxuICAgICAgICAgICAgICAgIHllID0geSArIGgsICAgICAgICAgICAvLyB5LWVuZFxuICAgICAgICAgICAgICAgIHhtID0geCArIHcgLyAyLCAgICAgICAvLyB4LW1pZGRsZVxuICAgICAgICAgICAgICAgIHltID0geSArIGggLyAyOyAgICAgICAvLyB5LW1pZGRsZVxuXG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh4LCB5bSk7XG4gICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeCwgeW0gLSBveSwgeG0gLSBveCwgeSwgeG0sIHkpO1xuICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHhtICsgb3gsIHksIHhlLCB5bSAtIG95LCB4ZSwgeW0pO1xuICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHhlLCB5bSArIG95LCB4bSArIG94LCB5ZSwgeG0sIHllKTtcbiAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4bSAtIG94LCB5ZSwgeCwgeW0gKyBveSwgeCwgeW0pO1xuXG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgICAgICBpZihkYXRhLmZpbGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEuZmlsbEFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yID0gJyMnICsgKCcwMDAwMCcgKyAoIGRhdGEuZmlsbENvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZGF0YS5saW5lV2lkdGgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEubGluZUFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gUElYSS5HcmFwaGljcy5SUkVDKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcnggPSBwb2ludHNbMF07XG4gICAgICAgICAgICB2YXIgcnkgPSBwb2ludHNbMV07XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBwb2ludHNbMl07XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcG9pbnRzWzNdO1xuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IHBvaW50c1s0XTtcblxuICAgICAgICAgICAgdmFyIG1heFJhZGl1cyA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpIC8gMiB8IDA7XG4gICAgICAgICAgICByYWRpdXMgPSByYWRpdXMgPiBtYXhSYWRpdXMgPyBtYXhSYWRpdXMgOiByYWRpdXM7XG5cbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhyeCwgcnkgKyByYWRpdXMpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocngsIHJ5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhyeCwgcnkgKyBoZWlnaHQsIHJ4ICsgcmFkaXVzLCByeSArIGhlaWdodCk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhyeCArIHdpZHRoIC0gcmFkaXVzLCByeSArIGhlaWdodCk7XG4gICAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocnggKyB3aWR0aCwgcnkgKyBoZWlnaHQsIHJ4ICsgd2lkdGgsIHJ5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHJ4ICsgd2lkdGgsIHJ5ICsgcmFkaXVzKTtcbiAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhyeCArIHdpZHRoLCByeSwgcnggKyB3aWR0aCAtIHJhZGl1cywgcnkpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocnggKyByYWRpdXMsIHJ5KTtcbiAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhyeCwgcnksIHJ4LCByeSArIHJhZGl1cyk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgICAgICBpZihkYXRhLmZpbGxDb2xvciB8fCBkYXRhLmZpbGxDb2xvciA9PT0gMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5maWxsQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3IgPSAnIycgKyAoJzAwMDAwJyArICggZGF0YS5maWxsQ29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsKCk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGRhdGEubGluZVdpZHRoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBkYXRhLmxpbmVBbHBoYSAqIHdvcmxkQWxwaGE7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qXG4gKiBSZW5kZXJzIGEgZ3JhcGhpY3MgbWFza1xuICpcbiAqIEBzdGF0aWNcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIHJlbmRlckdyYXBoaWNzTWFza1xuICogQHBhcmFtIGdyYXBoaWNzIHtHcmFwaGljc30gdGhlIGdyYXBoaWNzIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhIG1hc2tcbiAqIEBwYXJhbSBjb250ZXh0IHtDb250ZXh0MkR9IHRoZSBjb250ZXh0IDJkIG1ldGhvZCBvZiB0aGUgY2FudmFzXG4gKi9cblBJWEkuQ2FudmFzR3JhcGhpY3MucmVuZGVyR3JhcGhpY3NNYXNrID0gZnVuY3Rpb24oZ3JhcGhpY3MsIGNvbnRleHQpXG57XG4gICAgdmFyIGxlbiA9IGdyYXBoaWNzLmdyYXBoaWNzRGF0YS5sZW5ndGg7XG5cbiAgICBpZihsZW4gPT09IDApIHJldHVybjtcblxuICAgIGlmKGxlbiA+IDEpXG4gICAge1xuICAgICAgICBsZW4gPSAxO1xuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coJ1BpeGkuanMgd2FybmluZzogbWFza3MgaW4gY2FudmFzIGNhbiBvbmx5IG1hc2sgdXNpbmcgdGhlIGZpcnN0IHBhdGggaW4gdGhlIGdyYXBoaWNzIG9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGRhdGEgPSBncmFwaGljcy5ncmFwaGljc0RhdGFbaV07XG4gICAgICAgIHZhciBwb2ludHMgPSBkYXRhLnBvaW50cztcblxuICAgICAgICBpZihkYXRhLnR5cGUgPT09IFBJWEkuR3JhcGhpY3MuUE9MWSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaj0xOyBqIDwgcG9pbnRzLmxlbmd0aC8yOyBqKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocG9pbnRzW2ogKiAyXSwgcG9pbnRzW2ogKiAyICsgMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgZmlyc3QgYW5kIGxhc3QgcG9pbnQgYXJlIHRoZSBzYW1lIGNsb3NlIHRoZSBwYXRoIC0gbXVjaCBuZWF0ZXIgOilcbiAgICAgICAgICAgIGlmKHBvaW50c1swXSA9PT0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMl0gJiYgcG9pbnRzWzFdID09PSBwb2ludHNbcG9pbnRzLmxlbmd0aC0xXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihkYXRhLnR5cGUgPT09IFBJWEkuR3JhcGhpY3MuUkVDVClcbiAgICAgICAge1xuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQucmVjdChwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGRhdGEudHlwZSA9PT0gUElYSS5HcmFwaGljcy5DSVJDKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBUT0RPIC0gbmVlZCB0byBiZSBVbmRlZmluZWQhXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5hcmMocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwwLDIqTWF0aC5QSSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoZGF0YS50eXBlID09PSBQSVhJLkdyYXBoaWNzLkVMSVApXG4gICAgICAgIHtcblxuICAgICAgICAgICAgLy8gZWxsaXBzZSBjb2RlIHRha2VuIGZyb206IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjE3Mjc5OC9ob3ctdG8tZHJhdy1hbi1vdmFsLWluLWh0bWw1LWNhbnZhc1xuICAgICAgICAgICAgdmFyIGVsbGlwc2VEYXRhID0gIGRhdGEucG9pbnRzO1xuXG4gICAgICAgICAgICB2YXIgdyA9IGVsbGlwc2VEYXRhWzJdICogMjtcbiAgICAgICAgICAgIHZhciBoID0gZWxsaXBzZURhdGFbM10gKiAyO1xuXG4gICAgICAgICAgICB2YXIgeCA9IGVsbGlwc2VEYXRhWzBdIC0gdy8yO1xuICAgICAgICAgICAgdmFyIHkgPSBlbGxpcHNlRGF0YVsxXSAtIGgvMjtcblxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgdmFyIGthcHBhID0gMC41NTIyODQ4LFxuICAgICAgICAgICAgICAgIG94ID0gKHcgLyAyKSAqIGthcHBhLCAvLyBjb250cm9sIHBvaW50IG9mZnNldCBob3Jpem9udGFsXG4gICAgICAgICAgICAgICAgb3kgPSAoaCAvIDIpICoga2FwcGEsIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IHZlcnRpY2FsXG4gICAgICAgICAgICAgICAgeGUgPSB4ICsgdywgICAgICAgICAgIC8vIHgtZW5kXG4gICAgICAgICAgICAgICAgeWUgPSB5ICsgaCwgICAgICAgICAgIC8vIHktZW5kXG4gICAgICAgICAgICAgICAgeG0gPSB4ICsgdyAvIDIsICAgICAgIC8vIHgtbWlkZGxlXG4gICAgICAgICAgICAgICAgeW0gPSB5ICsgaCAvIDI7ICAgICAgIC8vIHktbWlkZGxlXG5cbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHgsIHltKTtcbiAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4LCB5bSAtIG95LCB4bSAtIG94LCB5LCB4bSwgeSk7XG4gICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeG0gKyBveCwgeSwgeGUsIHltIC0gb3ksIHhlLCB5bSk7XG4gICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeGUsIHltICsgb3ksIHhtICsgb3gsIHllLCB4bSwgeWUpO1xuICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHhtIC0gb3gsIHllLCB4LCB5bSArIG95LCB4LCB5bSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gUElYSS5HcmFwaGljcy5SUkVDKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcnggPSBwb2ludHNbMF07XG4gICAgICAgICAgICB2YXIgcnkgPSBwb2ludHNbMV07XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBwb2ludHNbMl07XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcG9pbnRzWzNdO1xuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IHBvaW50c1s0XTtcblxuICAgICAgICAgICAgdmFyIG1heFJhZGl1cyA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpIC8gMiB8IDA7XG4gICAgICAgICAgICByYWRpdXMgPSByYWRpdXMgPiBtYXhSYWRpdXMgPyBtYXhSYWRpdXMgOiByYWRpdXM7XG5cbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhyeCwgcnkgKyByYWRpdXMpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocngsIHJ5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhyeCwgcnkgKyBoZWlnaHQsIHJ4ICsgcmFkaXVzLCByeSArIGhlaWdodCk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhyeCArIHdpZHRoIC0gcmFkaXVzLCByeSArIGhlaWdodCk7XG4gICAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocnggKyB3aWR0aCwgcnkgKyBoZWlnaHQsIHJ4ICsgd2lkdGgsIHJ5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHJ4ICsgd2lkdGgsIHJ5ICsgcmFkaXVzKTtcbiAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhyeCArIHdpZHRoLCByeSwgcnggKyB3aWR0aCAtIHJhZGl1cywgcnkpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocnggKyByYWRpdXMsIHJ5KTtcbiAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhyeCwgcnksIHJ4LCByeSArIHJhZGl1cyk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG5cbi8qKlxuICogVGhlIEdyYXBoaWNzIGNsYXNzIGNvbnRhaW5zIGEgc2V0IG9mIG1ldGhvZHMgdGhhdCB5b3UgY2FuIHVzZSB0byBjcmVhdGUgcHJpbWl0aXZlIHNoYXBlcyBhbmQgbGluZXMuXG4gKiBJdCBpcyBpbXBvcnRhbnQgdG8ga25vdyB0aGF0IHdpdGggdGhlIHdlYkdMIHJlbmRlcmVyIG9ubHkgc2ltcGxlIHBvbHlnb25zIGNhbiBiZSBmaWxsZWQgYXQgdGhpcyBzdGFnZVxuICogQ29tcGxleCBwb2x5Z29ucyB3aWxsIG5vdCBiZSBmaWxsZWQuIEhlcmVzIGFuIGV4YW1wbGUgb2YgYSBjb21wbGV4IHBvbHlnb246IGh0dHA6Ly93d3cuZ29vZGJveWRpZ2l0YWwuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDEzLzA2L2NvbXBsZXhQb2x5Z29uLnBuZ1xuICpcbiAqIEBjbGFzcyBHcmFwaGljc1xuICogQGV4dGVuZHMgRGlzcGxheU9iamVjdENvbnRhaW5lclxuICogQGNvbnN0cnVjdG9yXG4gKi9cblBJWEkuR3JhcGhpY3MgPSBmdW5jdGlvbigpXG57XG4gICAgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMucmVuZGVyYWJsZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYWxwaGEgb2YgdGhlIGZpbGwgb2YgdGhpcyBncmFwaGljcyBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBmaWxsQWxwaGFcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLmZpbGxBbHBoYSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgYW55IGxpbmVzIGRyYXduXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbGluZVdpZHRoXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5saW5lV2lkdGggPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbG9yIG9mIGFueSBsaW5lcyBkcmF3blxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGxpbmVDb2xvclxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIHRoaXMubGluZUNvbG9yID0gXCJibGFja1wiO1xuXG4gICAgLyoqXG4gICAgICogR3JhcGhpY3MgZGF0YVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGdyYXBoaWNzRGF0YVxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmdyYXBoaWNzRGF0YSA9IFtdO1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGludCBhcHBsaWVkIHRvIHRoZSBncmFwaGljIHNoYXBlLiBUaGlzIGlzIGEgaGV4IHZhbHVlXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdGludFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDB4RkZGRkZGXG4gICAgICovXG4gICAgdGhpcy50aW50ID0gMHhGRkZGRkY7Ly8gKiBNYXRoLnJhbmRvbSgpO1xuICAgIFxuICAgIC8qKlxuICAgICAqIFRoZSBibGVuZCBtb2RlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGdyYXBoaWMgc2hhcGVcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBibGVuZE1vZGVcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCBQSVhJLmJsZW5kTW9kZXMuTk9STUFMO1xuICAgICAqL1xuICAgIHRoaXMuYmxlbmRNb2RlID0gUElYSS5ibGVuZE1vZGVzLk5PUk1BTDtcbiAgICBcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHBhdGhcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjdXJyZW50UGF0aFxuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50UGF0aCA9IHtwb2ludHM6W119O1xuXG4gICAgLyoqXG4gICAgICogQXJyYXkgY29udGFpbmluZyBzb21lIFdlYkdMLXJlbGF0ZWQgcHJvcGVydGllcyB1c2VkIGJ5IHRoZSBXZWJHTCByZW5kZXJlclxuICAgICAqXG4gICAgICogQHByb3BlcnR5IF93ZWJHTFxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl93ZWJHTCA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIHNoYXBlIGlzIGJlaW5nIHVzZWQgYXMgYSBtYXNrXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgaXNNYXNrXG4gICAgICogQHR5cGUgaXNNYXNrXG4gICAgICovXG4gICAgdGhpcy5pc01hc2sgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBib3VuZHMgb2YgdGhlIGdyYXBoaWMgc2hhcGUgYXMgcmVjdGFuZ2xlIG9iamVjdFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJvdW5kc1xuICAgICAqIEB0eXBlIFJlY3RhbmdsZVxuICAgICAqL1xuICAgIHRoaXMuYm91bmRzID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIHRoZSBib3VuZHMnIHBhZGRpbmcgdXNlZCBmb3IgYm91bmRzIGNhbGN1bGF0aW9uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYm91bmRzUGFkZGluZ1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuYm91bmRzUGFkZGluZyA9IDEwO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBkZXRlY3QgaWYgdGhlIGdyYXBoaWNzIG9iamVjdCBoYXMgY2hhbmdlZCBpZiB0aGlzIGlzIHNldCB0byB0cnVlIHRoZW4gdGhlIGdyYXBoaWNzIG9iamVjdCB3aWxsIGJlIHJlY2FsY3VsYXRlZFxuICAgICAqIFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuR3JhcGhpY3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZSApO1xuUElYSS5HcmFwaGljcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkdyYXBoaWNzO1xuXG4vKipcbiAqIElmIGNhY2hlQXNCaXRtYXAgaXMgdHJ1ZSB0aGUgZ3JhcGhpY3Mgb2JqZWN0IHdpbGwgdGhlbiBiZSByZW5kZXJlZCBhcyBpZiBpdCB3YXMgYSBzcHJpdGUuXG4gKiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3VyIGdyYXBoaWNzIGVsZW1lbnQgZG9lcyBub3QgY2hhbmdlIG9mdGVuIGFzIGl0IHdpbGwgc3BlZWQgdXAgdGhlIHJlbmRlcmluZyBvZiB0aGUgb2JqZWN0XG4gKiBJdCBpcyBhbHNvIHVzZnVsIGFzIHRoZSBncmFwaGljcyBvYmplY3Qgd2lsbCBhbHdheXMgYmUgYW50aWFsaWFzZWQgYmVjYXVzZSBpdCB3aWxsIGJlIHJlbmRlcmVkIHVzaW5nIGNhbnZhc1xuICogTm90IHJlY29tbWVuZGVkIGlmIHlvdSBhcmUgY29uc3Rhbmx5IHJlZHJhd2luZyB0aGUgZ3JhcGhpY3MgZWxlbWVudC5cbiAqXG4gKiBAcHJvcGVydHkgY2FjaGVBc0JpdG1hcFxuICogQGRlZmF1bHQgZmFsc2VcbiAqIEB0eXBlIEJvb2xlYW5cbiAqIEBwcml2YXRlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLkdyYXBoaWNzLnByb3RvdHlwZSwgXCJjYWNoZUFzQml0bWFwXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIHRoaXMuX2NhY2hlQXNCaXRtYXA7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlQXNCaXRtYXAgPSB2YWx1ZTtcblxuICAgICAgICBpZih0aGlzLl9jYWNoZUFzQml0bWFwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9nZW5lcmF0ZUNhY2hlZFNwcml0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95Q2FjaGVkU3ByaXRlKCk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfVxufSk7XG5cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGxpbmUgc3R5bGUgdXNlZCBmb3Igc3Vic2VxdWVudCBjYWxscyB0byBHcmFwaGljcyBtZXRob2RzIHN1Y2ggYXMgdGhlIGxpbmVUbygpIG1ldGhvZCBvciB0aGUgZHJhd0NpcmNsZSgpIG1ldGhvZC5cbiAqXG4gKiBAbWV0aG9kIGxpbmVTdHlsZVxuICogQHBhcmFtIGxpbmVXaWR0aCB7TnVtYmVyfSB3aWR0aCBvZiB0aGUgbGluZSB0byBkcmF3LCB3aWxsIHVwZGF0ZSB0aGUgb2JqZWN0J3Mgc3RvcmVkIHN0eWxlXG4gKiBAcGFyYW0gY29sb3Ige051bWJlcn0gY29sb3Igb2YgdGhlIGxpbmUgdG8gZHJhdywgd2lsbCB1cGRhdGUgdGhlIG9iamVjdCdzIHN0b3JlZCBzdHlsZVxuICogQHBhcmFtIGFscGhhIHtOdW1iZXJ9IGFscGhhIG9mIHRoZSBsaW5lIHRvIGRyYXcsIHdpbGwgdXBkYXRlIHRoZSBvYmplY3QncyBzdG9yZWQgc3R5bGVcbiAqL1xuUElYSS5HcmFwaGljcy5wcm90b3R5cGUubGluZVN0eWxlID0gZnVuY3Rpb24obGluZVdpZHRoLCBjb2xvciwgYWxwaGEpXG57XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRQYXRoLnBvaW50cy5sZW5ndGgpIHRoaXMuZ3JhcGhpY3NEYXRhLnBvcCgpO1xuXG4gICAgdGhpcy5saW5lV2lkdGggPSBsaW5lV2lkdGggfHwgMDtcbiAgICB0aGlzLmxpbmVDb2xvciA9IGNvbG9yIHx8IDA7XG4gICAgdGhpcy5saW5lQWxwaGEgPSAoYXJndW1lbnRzLmxlbmd0aCA8IDMpID8gMSA6IGFscGhhO1xuXG4gICAgdGhpcy5jdXJyZW50UGF0aCA9IHtsaW5lV2lkdGg6dGhpcy5saW5lV2lkdGgsIGxpbmVDb2xvcjp0aGlzLmxpbmVDb2xvciwgbGluZUFscGhhOnRoaXMubGluZUFscGhhLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOnRoaXMuZmlsbENvbG9yLCBmaWxsQWxwaGE6dGhpcy5maWxsQWxwaGEsIGZpbGw6dGhpcy5maWxsaW5nLCBwb2ludHM6W10sIHR5cGU6UElYSS5HcmFwaGljcy5QT0xZfTtcblxuICAgIHRoaXMuZ3JhcGhpY3NEYXRhLnB1c2godGhpcy5jdXJyZW50UGF0aCk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTW92ZXMgdGhlIGN1cnJlbnQgZHJhd2luZyBwb3NpdGlvbiB0byAoeCwgeSkuXG4gKlxuICogQG1ldGhvZCBtb3ZlVG9cbiAqIEBwYXJhbSB4IHtOdW1iZXJ9IHRoZSBYIGNvb3JkaW5hdGUgdG8gbW92ZSB0b1xuICogQHBhcmFtIHkge051bWJlcn0gdGhlIFkgY29vcmRpbmF0ZSB0byBtb3ZlIHRvXG4gKi9cblBJWEkuR3JhcGhpY3MucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uKHgsIHkpXG57XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRQYXRoLnBvaW50cy5sZW5ndGgpIHRoaXMuZ3JhcGhpY3NEYXRhLnBvcCgpO1xuXG4gICAgdGhpcy5jdXJyZW50UGF0aCA9IHRoaXMuY3VycmVudFBhdGggPSB7bGluZVdpZHRoOnRoaXMubGluZVdpZHRoLCBsaW5lQ29sb3I6dGhpcy5saW5lQ29sb3IsIGxpbmVBbHBoYTp0aGlzLmxpbmVBbHBoYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjp0aGlzLmZpbGxDb2xvciwgZmlsbEFscGhhOnRoaXMuZmlsbEFscGhhLCBmaWxsOnRoaXMuZmlsbGluZywgcG9pbnRzOltdLCB0eXBlOlBJWEkuR3JhcGhpY3MuUE9MWX07XG5cbiAgICB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cy5wdXNoKHgsIHkpO1xuXG4gICAgdGhpcy5ncmFwaGljc0RhdGEucHVzaCh0aGlzLmN1cnJlbnRQYXRoKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEcmF3cyBhIGxpbmUgdXNpbmcgdGhlIGN1cnJlbnQgbGluZSBzdHlsZSBmcm9tIHRoZSBjdXJyZW50IGRyYXdpbmcgcG9zaXRpb24gdG8gKHgsIHkpO1xuICogdGhlIGN1cnJlbnQgZHJhd2luZyBwb3NpdGlvbiBpcyB0aGVuIHNldCB0byAoeCwgeSkuXG4gKlxuICogQG1ldGhvZCBsaW5lVG9cbiAqIEBwYXJhbSB4IHtOdW1iZXJ9IHRoZSBYIGNvb3JkaW5hdGUgdG8gZHJhdyB0b1xuICogQHBhcmFtIHkge051bWJlcn0gdGhlIFkgY29vcmRpbmF0ZSB0byBkcmF3IHRvXG4gKi9cblBJWEkuR3JhcGhpY3MucHJvdG90eXBlLmxpbmVUbyA9IGZ1bmN0aW9uKHgsIHkpXG57XG4gICAgdGhpcy5jdXJyZW50UGF0aC5wb2ludHMucHVzaCh4LCB5KTtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHBvaW50cyBmb3IgYSBxdWFkcmF0aWMgYmV6aWVyIGN1cnZlLlxuICogQmFzZWQgb24gOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83ODUwOTcvaG93LWRvLWktaW1wbGVtZW50LWEtYmV6aWVyLWN1cnZlLWluLWNcbiAqXG4gKiBAbWV0aG9kIHF1YWRyYXRpY0N1cnZlVG9cbiAqIEBwYXJhbSAge251bWJlcn0gICBjcFggICBDb250cm9sIHBvaW50IHhcbiAqIEBwYXJhbSAge251bWJlcn0gICBjcFkgICBDb250cm9sIHBvaW50IHlcbiAqIEBwYXJhbSAge251bWJlcn0gICB0b1ggICBEZXN0aW5hdGlvbiBwb2ludCB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICAgdG9ZICAgRGVzdGluYXRpb24gcG9pbnQgeVxuICogQHJldHVybiB7UElYSS5HcmFwaGljc31cbiAqL1xuUElYSS5HcmFwaGljcy5wcm90b3R5cGUucXVhZHJhdGljQ3VydmVUbyA9IGZ1bmN0aW9uKGNwWCwgY3BZLCB0b1gsIHRvWSlcbntcbiAgICBpZiggdGhpcy5jdXJyZW50UGF0aC5wb2ludHMubGVuZ3RoID09PSAwKXRoaXMubW92ZVRvKDAsMCk7XG5cbiAgICB2YXIgeGEsXG4gICAgeWEsXG4gICAgbiA9IDIwLFxuICAgIHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzO1xuICAgIGlmKHBvaW50cy5sZW5ndGggPT09IDApdGhpcy5tb3ZlVG8oMCwgMCk7XG4gICAgXG5cbiAgICB2YXIgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aC0yXTtcbiAgICB2YXIgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aC0xXTtcblxuICAgIHZhciBqID0gMDtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBuOyBpKysgKVxuICAgIHtcbiAgICAgICAgaiA9IGkgLyBuO1xuXG4gICAgICAgIHhhID0gZnJvbVggKyAoIChjcFggLSBmcm9tWCkgKiBqICk7XG4gICAgICAgIHlhID0gZnJvbVkgKyAoIChjcFkgLSBmcm9tWSkgKiBqICk7XG5cbiAgICAgICAgcG9pbnRzLnB1c2goIHhhICsgKCAoKGNwWCArICggKHRvWCAtIGNwWCkgKiBqICkpIC0geGEpICogaiApLFxuICAgICAgICAgICAgICAgICAgICAgeWEgKyAoICgoY3BZICsgKCAodG9ZIC0gY3BZKSAqIGogKSkgLSB5YSkgKiBqICkgKTtcbiAgICB9XG5cblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgcG9pbnRzIGZvciBhIGJlemllciBjdXJ2ZS5cbiAqXG4gKiBAbWV0aG9kIGJlemllckN1cnZlVG9cbiAqIEBwYXJhbSAge251bWJlcn0gICBjcFggICAgQ29udHJvbCBwb2ludCB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICAgY3BZICAgIENvbnRyb2wgcG9pbnQgeVxuICogQHBhcmFtICB7bnVtYmVyfSAgIGNwWDIgICBTZWNvbmQgQ29udHJvbCBwb2ludCB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICAgY3BZMiAgIFNlY29uZCBDb250cm9sIHBvaW50IHlcbiAqIEBwYXJhbSAge251bWJlcn0gICB0b1ggICAgRGVzdGluYXRpb24gcG9pbnQgeFxuICogQHBhcmFtICB7bnVtYmVyfSAgIHRvWSAgICBEZXN0aW5hdGlvbiBwb2ludCB5XG4gKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfVxuICovXG5QSVhJLkdyYXBoaWNzLnByb3RvdHlwZS5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24oY3BYLCBjcFksIGNwWDIsIGNwWTIsIHRvWCwgdG9ZKVxue1xuICAgIGlmKCB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cy5sZW5ndGggPT09IDApdGhpcy5tb3ZlVG8oMCwwKTtcblxuICAgIHZhciBuID0gMjAsXG4gICAgZHQsXG4gICAgZHQyLFxuICAgIGR0MyxcbiAgICB0MixcbiAgICB0MyxcbiAgICBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cztcblxuICAgIHZhciBmcm9tWCA9IHBvaW50c1twb2ludHMubGVuZ3RoLTJdO1xuICAgIHZhciBmcm9tWSA9IHBvaW50c1twb2ludHMubGVuZ3RoLTFdO1xuICAgIFxuICAgIHZhciBqID0gMDtcblxuICAgIGZvciAodmFyIGk9MTsgaTxuOyBpKyspXG4gICAge1xuICAgICAgICBqID0gaSAvIG47XG5cbiAgICAgICAgZHQgPSAoMSAtIGopO1xuICAgICAgICBkdDIgPSBkdCAqIGR0O1xuICAgICAgICBkdDMgPSBkdDIgKiBkdDtcblxuICAgICAgICB0MiA9IGogKiBqO1xuICAgICAgICB0MyA9IHQyICogajtcbiAgICAgICAgXG4gICAgICAgIHBvaW50cy5wdXNoKCBkdDMgKiBmcm9tWCArIDMgKiBkdDIgKiBqICogY3BYICsgMyAqIGR0ICogdDIgKiBjcFgyICsgdDMgKiB0b1gsXG4gICAgICAgICAgICAgICAgICAgICBkdDMgKiBmcm9tWSArIDMgKiBkdDIgKiBqICogY3BZICsgMyAqIGR0ICogdDIgKiBjcFkyICsgdDMgKiB0b1kpO1xuICAgICAgICBcbiAgICB9XG4gICAgXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qXG4gKiB0aGUgYXJjVG8oKSBtZXRob2QgY3JlYXRlcyBhbiBhcmMvY3VydmUgYmV0d2VlbiB0d28gdGFuZ2VudHMgb24gdGhlIGNhbnZhcy5cbiAqIFxuICogXCJib3Jyb3dlZFwiIGZyb20gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9meGNhbnZhcy8gLSB0aGFua3MgZ29vZ2xlIVxuICpcbiAqIEBtZXRob2QgYXJjVG9cbiAqIEBwYXJhbSAge251bWJlcn0gICB4MSAgICAgICAgVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcmNcbiAqIEBwYXJhbSAge251bWJlcn0gICB5MSAgICAgICAgVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcmNcbiAqIEBwYXJhbSAge251bWJlcn0gICB4MiAgICAgICAgVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBhcmNcbiAqIEBwYXJhbSAge251bWJlcn0gICB5MiAgICAgICAgVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBhcmNcbiAqIEBwYXJhbSAge251bWJlcn0gICByYWRpdXMgICAgVGhlIHJhZGl1cyBvZiB0aGUgYXJjXG4gKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfVxuICovXG5QSVhJLkdyYXBoaWNzLnByb3RvdHlwZS5hcmNUbyA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpXG57XG4gICAgLy8gY2hlY2sgdGhhdCBwYXRoIGNvbnRhaW5zIHN1YnBhdGhzXG4gICAgaWYoIHRoaXMuY3VycmVudFBhdGgucG9pbnRzLmxlbmd0aCA9PT0gMCl0aGlzLm1vdmVUbyh4MSwgeTEpO1xuICAgIFxuICAgIHZhciBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cztcbiAgICB2YXIgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aC0yXTtcbiAgICB2YXIgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aC0xXTtcblxuLy8gICAgcG9pbnRzLnB1c2goIHgxLCAgeTEpO1xuXG4gICAgdmFyIGExID0gZnJvbVkgLSB5MTtcbiAgICB2YXIgYjEgPSBmcm9tWCAtIHgxO1xuICAgIHZhciBhMiA9IHkyICAgLSB5MTtcbiAgICB2YXIgYjIgPSB4MiAgIC0geDE7XG4gICAgdmFyIG1tID0gTWF0aC5hYnMoYTEgKiBiMiAtIGIxICogYTIpO1xuXG4gICAgaWYgKG1tIDwgMS4wZS04IHx8IHJhZGl1cyA9PT0gMClcbiAgICB7XG4gICAgICAgIHBvaW50cy5wdXNoKHgxLCB5MSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHZhciBkZCA9IGExICogYTEgKyBiMSAqIGIxO1xuICAgICAgICB2YXIgY2MgPSBhMiAqIGEyICsgYjIgKiBiMjtcbiAgICAgICAgdmFyIHR0ID0gYTEgKiBhMiArIGIxICogYjI7XG4gICAgICAgIHZhciBrMSA9IHJhZGl1cyAqIE1hdGguc3FydChkZCkgLyBtbTtcbiAgICAgICAgdmFyIGsyID0gcmFkaXVzICogTWF0aC5zcXJ0KGNjKSAvIG1tO1xuICAgICAgICB2YXIgajEgPSBrMSAqIHR0IC8gZGQ7XG4gICAgICAgIHZhciBqMiA9IGsyICogdHQgLyBjYztcbiAgICAgICAgdmFyIGN4ID0gazEgKiBiMiArIGsyICogYjE7XG4gICAgICAgIHZhciBjeSA9IGsxICogYTIgKyBrMiAqIGExO1xuICAgICAgICB2YXIgcHggPSBiMSAqIChrMiArIGoxKTtcbiAgICAgICAgdmFyIHB5ID0gYTEgKiAoazIgKyBqMSk7XG4gICAgICAgIHZhciBxeCA9IGIyICogKGsxICsgajIpO1xuICAgICAgICB2YXIgcXkgPSBhMiAqIChrMSArIGoyKTtcbiAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBNYXRoLmF0YW4yKHB5IC0gY3ksIHB4IC0gY3gpO1xuICAgICAgICB2YXIgZW5kQW5nbGUgICA9IE1hdGguYXRhbjIocXkgLSBjeSwgcXggLSBjeCk7XG4gICAgICAgIC8vIG5vdCByZXF1aXJlZD9cbiAgICAgLy8gICBwb2ludHMucHVzaChweCArIHgxICwgcHkgKyB5MSk7XG4gICAgICAgIHRoaXMuYXJjKGN4ICsgeDEsIGN5ICsgeTEsIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGIxICogYTIgPiBiMiAqIGExKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUaGUgYXJjKCkgbWV0aG9kIGNyZWF0ZXMgYW4gYXJjL2N1cnZlICh1c2VkIHRvIGNyZWF0ZSBjaXJjbGVzLCBvciBwYXJ0cyBvZiBjaXJjbGVzKS5cbiAqXG4gKiBAbWV0aG9kIGFyY1xuICogQHBhcmFtICB7bnVtYmVyfSAgIGN4ICAgICAgICAgICAgICAgIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICAgY3kgICAgICAgICAgICAgICAgVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcbiAqIEBwYXJhbSAge251bWJlcn0gICByYWRpdXMgICAgICAgICAgICBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAqIEBwYXJhbSAge251bWJlcn0gICBzdGFydEFuZ2xlICAgICAgICBUaGUgc3RhcnRpbmcgYW5nbGUsIGluIHJhZGlhbnMgKDAgaXMgYXQgdGhlIDMgbydjbG9jayBwb3NpdGlvbiBvZiB0aGUgYXJjJ3MgY2lyY2xlKVxuICogQHBhcmFtICB7bnVtYmVyfSAgIGVuZEFuZ2xlICAgICAgICAgIFRoZSBlbmRpbmcgYW5nbGUsIGluIHJhZGlhbnNcbiAqIEBwYXJhbSAge251bWJlcn0gICBhbnRpY2xvY2t3aXNlICAgICBPcHRpb25hbC4gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGRyYXdpbmcgc2hvdWxkIGJlIGNvdW50ZXJjbG9ja3dpc2Ugb3IgY2xvY2t3aXNlLiBGYWxzZSBpcyBkZWZhdWx0LCBhbmQgaW5kaWNhdGVzIGNsb2Nrd2lzZSwgd2hpbGUgdHJ1ZSBpbmRpY2F0ZXMgY291bnRlci1jbG9ja3dpc2UuXG4gKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfVxuICovXG5QSVhJLkdyYXBoaWNzLnByb3RvdHlwZS5hcmMgPSBmdW5jdGlvbihjeCwgY3ksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpXG57XG4gICAgdmFyIHN0YXJ0WCA9IGN4ICsgTWF0aC5jb3Moc3RhcnRBbmdsZSkgKiByYWRpdXM7XG4gICAgdmFyIHN0YXJ0WSA9IGN5ICsgTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByYWRpdXM7XG4gICAgXG4gICAgdmFyIHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzO1xuXG4gICAgaWYocG9pbnRzLmxlbmd0aCAhPT0gMCAmJiBwb2ludHNbcG9pbnRzLmxlbmd0aC0yXSAhPT0gc3RhcnRYIHx8IHBvaW50c1twb2ludHMubGVuZ3RoLTFdICE9PSBzdGFydFkpXG4gICAge1xuICAgICAgICB0aGlzLm1vdmVUbyhzdGFydFgsIHN0YXJ0WSk7XG4gICAgICAgIHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzO1xuICAgIH1cblxuICAgIGlmIChzdGFydEFuZ2xlID09PSBlbmRBbmdsZSlyZXR1cm4gdGhpcztcblxuICAgIGlmKCAhYW50aWNsb2Nrd2lzZSAmJiBlbmRBbmdsZSA8PSBzdGFydEFuZ2xlIClcbiAgICB7XG4gICAgICAgIGVuZEFuZ2xlICs9IE1hdGguUEkgKiAyO1xuICAgIH1cbiAgICBlbHNlIGlmKCBhbnRpY2xvY2t3aXNlICYmIHN0YXJ0QW5nbGUgPD0gZW5kQW5nbGUgKVxuICAgIHtcbiAgICAgICAgc3RhcnRBbmdsZSArPSBNYXRoLlBJICogMjtcbiAgICB9XG5cbiAgICB2YXIgc3dlZXAgPSBhbnRpY2xvY2t3aXNlID8gKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSkgKi0xIDogKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gICAgdmFyIHNlZ3MgPSAgKCBNYXRoLmFicyhzd2VlcCkvIChNYXRoLlBJICogMikgKSAqIDQwO1xuXG4gICAgaWYoIHN3ZWVwID09PSAwICkgcmV0dXJuIHRoaXM7XG5cbiAgICB2YXIgdGhldGEgPSBzd2VlcC8oc2VncyoyKTtcbiAgICB2YXIgdGhldGEyID0gdGhldGEqMjtcblxuICAgIHZhciBjVGhldGEgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgdmFyIHNUaGV0YSA9IE1hdGguc2luKHRoZXRhKTtcbiAgICBcbiAgICB2YXIgc2VnTWludXMgPSBzZWdzIC0gMTtcblxuICAgIHZhciByZW1haW5kZXIgPSAoIHNlZ01pbnVzICUgMSApIC8gc2VnTWludXM7XG5cbiAgICBmb3IodmFyIGk9MDsgaTw9c2VnTWludXM7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciByZWFsID0gIGkgKyByZW1haW5kZXIgKiBpO1xuXG4gICAgXG4gICAgICAgIHZhciBhbmdsZSA9ICgodGhldGEpICsgc3RhcnRBbmdsZSArICh0aGV0YTIgKiByZWFsKSk7XG5cbiAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIHZhciBzID0gLU1hdGguc2luKGFuZ2xlKTtcblxuICAgICAgICBwb2ludHMucHVzaCgoIChjVGhldGEgKiAgYykgKyAoc1RoZXRhICogcykgKSAqIHJhZGl1cyArIGN4LFxuICAgICAgICAgICAgICAgICAgICAoIChjVGhldGEgKiAtcykgKyAoc1RoZXRhICogYykgKSAqIHJhZGl1cyArIGN5KTtcbiAgICB9XG5cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEcmF3cyBhIGxpbmUgdXNpbmcgdGhlIGN1cnJlbnQgbGluZSBzdHlsZSBmcm9tIHRoZSBjdXJyZW50IGRyYXdpbmcgcG9zaXRpb24gdG8gKHgsIHkpO1xuICogdGhlIGN1cnJlbnQgZHJhd2luZyBwb3NpdGlvbiBpcyB0aGVuIHNldCB0byAoeCwgeSkuXG4gKlxuICogQG1ldGhvZCBsaW5lVG9cbiAqIEBwYXJhbSB4IHtOdW1iZXJ9IHRoZSBYIGNvb3JkaW5hdGUgdG8gZHJhdyB0b1xuICogQHBhcmFtIHkge051bWJlcn0gdGhlIFkgY29vcmRpbmF0ZSB0byBkcmF3IHRvXG4gKi9cblBJWEkuR3JhcGhpY3MucHJvdG90eXBlLmRyYXdQYXRoID0gZnVuY3Rpb24ocGF0aClcbntcbiAgICBpZiAoIXRoaXMuY3VycmVudFBhdGgucG9pbnRzLmxlbmd0aCkgdGhpcy5ncmFwaGljc0RhdGEucG9wKCk7XG5cbiAgICB0aGlzLmN1cnJlbnRQYXRoID0gdGhpcy5jdXJyZW50UGF0aCA9IHtsaW5lV2lkdGg6dGhpcy5saW5lV2lkdGgsIGxpbmVDb2xvcjp0aGlzLmxpbmVDb2xvciwgbGluZUFscGhhOnRoaXMubGluZUFscGhhLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOnRoaXMuZmlsbENvbG9yLCBmaWxsQWxwaGE6dGhpcy5maWxsQWxwaGEsIGZpbGw6dGhpcy5maWxsaW5nLCBwb2ludHM6W10sIHR5cGU6UElYSS5HcmFwaGljcy5QT0xZfTtcblxuICAgIHRoaXMuZ3JhcGhpY3NEYXRhLnB1c2godGhpcy5jdXJyZW50UGF0aCk7XG5cbiAgICB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cyA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzLmNvbmNhdChwYXRoKTtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBzaW1wbGUgb25lLWNvbG9yIGZpbGwgdGhhdCBzdWJzZXF1ZW50IGNhbGxzIHRvIG90aGVyIEdyYXBoaWNzIG1ldGhvZHNcbiAqIChzdWNoIGFzIGxpbmVUbygpIG9yIGRyYXdDaXJjbGUoKSkgdXNlIHdoZW4gZHJhd2luZy5cbiAqXG4gKiBAbWV0aG9kIGJlZ2luRmlsbFxuICogQHBhcmFtIGNvbG9yIHtOdW1iZXJ9IHRoZSBjb2xvciBvZiB0aGUgZmlsbFxuICogQHBhcmFtIGFscGhhIHtOdW1iZXJ9IHRoZSBhbHBoYSBvZiB0aGUgZmlsbFxuICovXG5QSVhJLkdyYXBoaWNzLnByb3RvdHlwZS5iZWdpbkZpbGwgPSBmdW5jdGlvbihjb2xvciwgYWxwaGEpXG57XG5cbiAgICB0aGlzLmZpbGxpbmcgPSB0cnVlO1xuICAgIHRoaXMuZmlsbENvbG9yID0gY29sb3IgfHwgMDtcbiAgICB0aGlzLmZpbGxBbHBoYSA9IChhcmd1bWVudHMubGVuZ3RoIDwgMikgPyAxIDogYWxwaGE7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQXBwbGllcyBhIGZpbGwgdG8gdGhlIGxpbmVzIGFuZCBzaGFwZXMgdGhhdCB3ZXJlIGFkZGVkIHNpbmNlIHRoZSBsYXN0IGNhbGwgdG8gdGhlIGJlZ2luRmlsbCgpIG1ldGhvZC5cbiAqXG4gKiBAbWV0aG9kIGVuZEZpbGxcbiAqL1xuUElYSS5HcmFwaGljcy5wcm90b3R5cGUuZW5kRmlsbCA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmZpbGxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmZpbGxDb2xvciA9IG51bGw7XG4gICAgdGhpcy5maWxsQWxwaGEgPSAxO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZHJhd1JlY3RcbiAqXG4gKiBAcGFyYW0geCB7TnVtYmVyfSBUaGUgWCBjb29yZCBvZiB0aGUgdG9wLWxlZnQgb2YgdGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIHkge051bWJlcn0gVGhlIFkgY29vcmQgb2YgdGhlIHRvcC1sZWZ0IG9mIHRoZSByZWN0YW5nbGVcbiAqIEBwYXJhbSB3aWR0aCB7TnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAqL1xuUElYSS5HcmFwaGljcy5wcm90b3R5cGUuZHJhd1JlY3QgPSBmdW5jdGlvbiggeCwgeSwgd2lkdGgsIGhlaWdodCApXG57XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRQYXRoLnBvaW50cy5sZW5ndGgpIHRoaXMuZ3JhcGhpY3NEYXRhLnBvcCgpO1xuXG4gICAgdGhpcy5jdXJyZW50UGF0aCA9IHtsaW5lV2lkdGg6dGhpcy5saW5lV2lkdGgsIGxpbmVDb2xvcjp0aGlzLmxpbmVDb2xvciwgbGluZUFscGhhOnRoaXMubGluZUFscGhhLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOnRoaXMuZmlsbENvbG9yLCBmaWxsQWxwaGE6dGhpcy5maWxsQWxwaGEsIGZpbGw6dGhpcy5maWxsaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOlt4LCB5LCB3aWR0aCwgaGVpZ2h0XSwgdHlwZTpQSVhJLkdyYXBoaWNzLlJFQ1R9O1xuXG4gICAgdGhpcy5ncmFwaGljc0RhdGEucHVzaCh0aGlzLmN1cnJlbnRQYXRoKTtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGRyYXdSb3VuZGVkUmVjdFxuICpcbiAqIEBwYXJhbSB4IHtOdW1iZXJ9IFRoZSBYIGNvb3JkIG9mIHRoZSB0b3AtbGVmdCBvZiB0aGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0geSB7TnVtYmVyfSBUaGUgWSBjb29yZCBvZiB0aGUgdG9wLWxlZnQgb2YgdGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gaGVpZ2h0IHtOdW1iZXJ9IFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIHJhZGl1cyB7TnVtYmVyfSBSYWRpdXMgb2YgdGhlIHJlY3RhbmdsZSBjb3JuZXJzXG4gKi9cblBJWEkuR3JhcGhpY3MucHJvdG90eXBlLmRyYXdSb3VuZGVkUmVjdCA9IGZ1bmN0aW9uKCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMgKVxue1xuICAgIGlmICghdGhpcy5jdXJyZW50UGF0aC5wb2ludHMubGVuZ3RoKSB0aGlzLmdyYXBoaWNzRGF0YS5wb3AoKTtcblxuICAgIHRoaXMuY3VycmVudFBhdGggPSB7bGluZVdpZHRoOnRoaXMubGluZVdpZHRoLCBsaW5lQ29sb3I6dGhpcy5saW5lQ29sb3IsIGxpbmVBbHBoYTp0aGlzLmxpbmVBbHBoYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjp0aGlzLmZpbGxDb2xvciwgZmlsbEFscGhhOnRoaXMuZmlsbEFscGhhLCBmaWxsOnRoaXMuZmlsbGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czpbeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzXSwgdHlwZTpQSVhJLkdyYXBoaWNzLlJSRUN9O1xuXG4gICAgdGhpcy5ncmFwaGljc0RhdGEucHVzaCh0aGlzLmN1cnJlbnRQYXRoKTtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEcmF3cyBhIGNpcmNsZS5cbiAqXG4gKiBAbWV0aG9kIGRyYXdDaXJjbGVcbiAqIEBwYXJhbSB4IHtOdW1iZXJ9IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXG4gKiBAcGFyYW0geSB7TnVtYmVyfSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxuICogQHBhcmFtIHJhZGl1cyB7TnVtYmVyfSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAqL1xuUElYSS5HcmFwaGljcy5wcm90b3R5cGUuZHJhd0NpcmNsZSA9IGZ1bmN0aW9uKHgsIHksIHJhZGl1cylcbntcblxuICAgIGlmICghdGhpcy5jdXJyZW50UGF0aC5wb2ludHMubGVuZ3RoKSB0aGlzLmdyYXBoaWNzRGF0YS5wb3AoKTtcblxuICAgIHRoaXMuY3VycmVudFBhdGggPSB7bGluZVdpZHRoOnRoaXMubGluZVdpZHRoLCBsaW5lQ29sb3I6dGhpcy5saW5lQ29sb3IsIGxpbmVBbHBoYTp0aGlzLmxpbmVBbHBoYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjp0aGlzLmZpbGxDb2xvciwgZmlsbEFscGhhOnRoaXMuZmlsbEFscGhhLCBmaWxsOnRoaXMuZmlsbGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czpbeCwgeSwgcmFkaXVzLCByYWRpdXNdLCB0eXBlOlBJWEkuR3JhcGhpY3MuQ0lSQ307XG5cbiAgICB0aGlzLmdyYXBoaWNzRGF0YS5wdXNoKHRoaXMuY3VycmVudFBhdGgpO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERyYXdzIGFuIGVsbGlwc2UuXG4gKlxuICogQG1ldGhvZCBkcmF3RWxsaXBzZVxuICogQHBhcmFtIHgge051bWJlcn0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlXG4gKiBAcGFyYW0geSB7TnVtYmVyfSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2VcbiAqIEBwYXJhbSB3aWR0aCB7TnVtYmVyfSBUaGUgaGFsZiB3aWR0aCBvZiB0aGUgZWxsaXBzZVxuICogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSBUaGUgaGFsZiBoZWlnaHQgb2YgdGhlIGVsbGlwc2VcbiAqL1xuUElYSS5HcmFwaGljcy5wcm90b3R5cGUuZHJhd0VsbGlwc2UgPSBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KVxue1xuXG4gICAgaWYgKCF0aGlzLmN1cnJlbnRQYXRoLnBvaW50cy5sZW5ndGgpIHRoaXMuZ3JhcGhpY3NEYXRhLnBvcCgpO1xuXG4gICAgdGhpcy5jdXJyZW50UGF0aCA9IHtsaW5lV2lkdGg6dGhpcy5saW5lV2lkdGgsIGxpbmVDb2xvcjp0aGlzLmxpbmVDb2xvciwgbGluZUFscGhhOnRoaXMubGluZUFscGhhLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOnRoaXMuZmlsbENvbG9yLCBmaWxsQWxwaGE6dGhpcy5maWxsQWxwaGEsIGZpbGw6dGhpcy5maWxsaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOlt4LCB5LCB3aWR0aCwgaGVpZ2h0XSwgdHlwZTpQSVhJLkdyYXBoaWNzLkVMSVB9O1xuXG4gICAgdGhpcy5ncmFwaGljc0RhdGEucHVzaCh0aGlzLmN1cnJlbnRQYXRoKTtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIGdyYXBoaWNzIHRoYXQgd2VyZSBkcmF3biB0byB0aGlzIEdyYXBoaWNzIG9iamVjdCwgYW5kIHJlc2V0cyBmaWxsIGFuZCBsaW5lIHN0eWxlIHNldHRpbmdzLlxuICpcbiAqIEBtZXRob2QgY2xlYXJcbiAqL1xuUElYSS5HcmFwaGljcy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5saW5lV2lkdGggPSAwO1xuICAgIHRoaXMuZmlsbGluZyA9IGZhbHNlO1xuXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5jbGVhckRpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLmdyYXBoaWNzRGF0YSA9IFtdO1xuXG4gICAgdGhpcy5ib3VuZHMgPSBudWxsOyAvL25ldyBQSVhJLlJlY3RhbmdsZSgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFVzZWZ1bCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB0ZXh0dXJlIG9mIHRoZSBncmFwaGljcyBvYmplY3QgdGhhdCBjYW4gdGhlbiBiZSB1c2VkIHRvIGNyZWF0ZSBzcHJpdGVzXG4gKiBUaGlzIGNhbiBiZSBxdWl0ZSB1c2VmdWwgaWYgeW91ciBnZW9tZXRyeSBpcyBjb21wbGljYXRlZCBhbmQgbmVlZHMgdG8gYmUgcmV1c2VkIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIEBtZXRob2QgZ2VuZXJhdGVUZXh0dXJlXG4gKiBAcmV0dXJuIHtUZXh0dXJlfSBhIHRleHR1cmUgb2YgdGhlIGdyYXBoaWNzIG9iamVjdFxuICovXG5QSVhJLkdyYXBoaWNzLnByb3RvdHlwZS5nZW5lcmF0ZVRleHR1cmUgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XG5cbiAgICB2YXIgY2FudmFzQnVmZmVyID0gbmV3IFBJWEkuQ2FudmFzQnVmZmVyKGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCk7XG4gICAgdmFyIHRleHR1cmUgPSBQSVhJLlRleHR1cmUuZnJvbUNhbnZhcyhjYW52YXNCdWZmZXIuY2FudmFzKTtcblxuICAgIGNhbnZhc0J1ZmZlci5jb250ZXh0LnRyYW5zbGF0ZSgtYm91bmRzLngsLWJvdW5kcy55KTtcbiAgICBcbiAgICBQSVhJLkNhbnZhc0dyYXBoaWNzLnJlbmRlckdyYXBoaWNzKHRoaXMsIGNhbnZhc0J1ZmZlci5jb250ZXh0KTtcblxuICAgIHJldHVybiB0ZXh0dXJlO1xufTtcblxuLyoqXG4qIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbipcbiogQG1ldGhvZCBfcmVuZGVyV2ViR0xcbiogQHBhcmFtIHJlbmRlclNlc3Npb24ge1JlbmRlclNlc3Npb259IFxuKiBAcHJpdmF0ZVxuKi9cblBJWEkuR3JhcGhpY3MucHJvdG90eXBlLl9yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uKHJlbmRlclNlc3Npb24pXG57XG4gICAgLy8gaWYgdGhlIHNwcml0ZSBpcyBub3QgdmlzaWJsZSBvciB0aGUgYWxwaGEgaXMgMCB0aGVuIG5vIG5lZWQgdG8gcmVuZGVyIHRoaXMgZWxlbWVudFxuICAgIGlmKHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgfHwgdGhpcy5hbHBoYSA9PT0gMCB8fCB0aGlzLmlzTWFzayA9PT0gdHJ1ZSlyZXR1cm47XG4gICAgXG5cbiAgICBpZih0aGlzLl9jYWNoZUFzQml0bWFwKVxuICAgIHtcbiAgICAgICBcbiAgICAgICAgaWYodGhpcy5kaXJ0eSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdGVDYWNoZWRTcHJpdGUoKTtcbiAgICAgICAgICAgIC8vIHdlIHdpbGwgYWxzbyBuZWVkIHRvIHVwZGF0ZSB0aGUgdGV4dHVyZSBvbiB0aGUgZ3B1IHRvbyFcbiAgICAgICAgICAgIFBJWEkudXBkYXRlV2ViR0xUZXh0dXJlKHRoaXMuX2NhY2hlZFNwcml0ZS50ZXh0dXJlLmJhc2VUZXh0dXJlLCByZW5kZXJTZXNzaW9uLmdsKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9ICBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5hbHBoYSA9IHRoaXMuYWxwaGE7XG4gICAgICAgIFBJWEkuU3ByaXRlLnByb3RvdHlwZS5fcmVuZGVyV2ViR0wuY2FsbCh0aGlzLl9jYWNoZWRTcHJpdGUsIHJlbmRlclNlc3Npb24pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaC5zdG9wKCk7XG4gICAgICAgIHJlbmRlclNlc3Npb24uYmxlbmRNb2RlTWFuYWdlci5zZXRCbGVuZE1vZGUodGhpcy5ibGVuZE1vZGUpO1xuXG4gICAgICAgIGlmKHRoaXMuX21hc2spcmVuZGVyU2Vzc2lvbi5tYXNrTWFuYWdlci5wdXNoTWFzayh0aGlzLl9tYXNrLCByZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgaWYodGhpcy5fZmlsdGVycylyZW5kZXJTZXNzaW9uLmZpbHRlck1hbmFnZXIucHVzaEZpbHRlcih0aGlzLl9maWx0ZXJCbG9jayk7XG4gICAgICBcbiAgICAgICAgLy8gY2hlY2sgYmxlbmQgbW9kZVxuICAgICAgICBpZih0aGlzLmJsZW5kTW9kZSAhPT0gcmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaC5jdXJyZW50QmxlbmRNb2RlKVxuICAgICAgICB7XG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLmN1cnJlbnRCbGVuZE1vZGUgPSB0aGlzLmJsZW5kTW9kZTtcbiAgICAgICAgICAgIHZhciBibGVuZE1vZGVXZWJHTCA9IFBJWEkuYmxlbmRNb2Rlc1dlYkdMW3JlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2guY3VycmVudEJsZW5kTW9kZV07XG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLmdsLmJsZW5kRnVuYyhibGVuZE1vZGVXZWJHTFswXSwgYmxlbmRNb2RlV2ViR0xbMV0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgLy8gIGZvciAodmFyIGkgPSB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAvLyAgICB0aGlzLmdyYXBoaWNzRGF0YVtpXVxuICAgICAgICAgICAgXG4vLyAgICAgICAgfTtcblxuICAgICAgICBQSVhJLldlYkdMR3JhcGhpY3MucmVuZGVyR3JhcGhpY3ModGhpcywgcmVuZGVyU2Vzc2lvbik7XG4gICAgICAgIFxuICAgICAgICAvLyBvbmx5IHJlbmRlciBpZiBpdCBoYXMgY2hpbGRyZW4hXG4gICAgICAgIGlmKHRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLnN0YXJ0KCk7XG5cbiAgICAgICAgICAgICAvLyBzaW1wbGUgcmVuZGVyIGNoaWxkcmVuIVxuICAgICAgICAgICAgZm9yKHZhciBpPTAsIGo9dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGk8ajsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uX3JlbmRlcldlYkdMKHJlbmRlclNlc3Npb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLnN0b3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuX2ZpbHRlcnMpcmVuZGVyU2Vzc2lvbi5maWx0ZXJNYW5hZ2VyLnBvcEZpbHRlcigpO1xuICAgICAgICBpZih0aGlzLl9tYXNrKXJlbmRlclNlc3Npb24ubWFza01hbmFnZXIucG9wTWFzayh0aGlzLm1hc2ssIHJlbmRlclNlc3Npb24pO1xuICAgICAgICAgIFxuICAgICAgICByZW5kZXJTZXNzaW9uLmRyYXdDb3VudCsrO1xuXG4gICAgICAgIHJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2guc3RhcnQoKTtcbiAgICB9XG59O1xuXG4vKipcbiogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbipcbiogQG1ldGhvZCBfcmVuZGVyQ2FudmFzXG4qIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtSZW5kZXJTZXNzaW9ufSBcbiogQHByaXZhdGVcbiovXG5QSVhJLkdyYXBoaWNzLnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzID0gZnVuY3Rpb24ocmVuZGVyU2Vzc2lvbilcbntcbiAgICAvLyBpZiB0aGUgc3ByaXRlIGlzIG5vdCB2aXNpYmxlIG9yIHRoZSBhbHBoYSBpcyAwIHRoZW4gbm8gbmVlZCB0byByZW5kZXIgdGhpcyBlbGVtZW50XG4gICAgaWYodGhpcy52aXNpYmxlID09PSBmYWxzZSB8fCB0aGlzLmFscGhhID09PSAwIHx8IHRoaXMuaXNNYXNrID09PSB0cnVlKXJldHVybjtcbiAgICBcbiAgICB2YXIgY29udGV4dCA9IHJlbmRlclNlc3Npb24uY29udGV4dDtcbiAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcbiAgICBcbiAgICBpZih0aGlzLmJsZW5kTW9kZSAhPT0gcmVuZGVyU2Vzc2lvbi5jdXJyZW50QmxlbmRNb2RlKVxuICAgIHtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5jdXJyZW50QmxlbmRNb2RlID0gdGhpcy5ibGVuZE1vZGU7XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gUElYSS5ibGVuZE1vZGVzQ2FudmFzW3JlbmRlclNlc3Npb24uY3VycmVudEJsZW5kTW9kZV07XG4gICAgfVxuXG4gICAgaWYodGhpcy5fbWFzaylcbiAgICB7XG4gICAgICAgIHJlbmRlclNlc3Npb24ubWFza01hbmFnZXIucHVzaE1hc2sodGhpcy5fbWFzaywgcmVuZGVyU2Vzc2lvbi5jb250ZXh0KTtcbiAgICB9XG5cbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybSh0cmFuc2Zvcm0uYSwgdHJhbnNmb3JtLmMsIHRyYW5zZm9ybS5iLCB0cmFuc2Zvcm0uZCwgdHJhbnNmb3JtLnR4LCB0cmFuc2Zvcm0udHkpO1xuICAgIFBJWEkuQ2FudmFzR3JhcGhpY3MucmVuZGVyR3JhcGhpY3ModGhpcywgY29udGV4dCk7XG5cbiAgICAgLy8gc2ltcGxlIHJlbmRlciBjaGlsZHJlbiFcbiAgICBmb3IodmFyIGk9MCwgaj10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxqOyBpKyspXG4gICAge1xuICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLl9yZW5kZXJDYW52YXMocmVuZGVyU2Vzc2lvbik7XG4gICAgfVxuXG4gICAgaWYodGhpcy5fbWFzaylcbiAgICB7XG4gICAgICAgIHJlbmRlclNlc3Npb24ubWFza01hbmFnZXIucG9wTWFzayhyZW5kZXJTZXNzaW9uLmNvbnRleHQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBib3VuZHMgb2YgdGhlIGdyYXBoaWMgc2hhcGUgYXMgYSByZWN0YW5nbGUgb2JqZWN0XG4gKlxuICogQG1ldGhvZCBnZXRCb3VuZHNcbiAqIEByZXR1cm4ge1JlY3RhbmdsZX0gdGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGFyZWFcbiAqL1xuUElYSS5HcmFwaGljcy5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24oIG1hdHJpeCApXG57XG4gICAgaWYoIXRoaXMuYm91bmRzKXRoaXMudXBkYXRlQm91bmRzKCk7XG5cbiAgICB2YXIgdzAgPSB0aGlzLmJvdW5kcy54O1xuICAgIHZhciB3MSA9IHRoaXMuYm91bmRzLndpZHRoICsgdGhpcy5ib3VuZHMueDtcblxuICAgIHZhciBoMCA9IHRoaXMuYm91bmRzLnk7XG4gICAgdmFyIGgxID0gdGhpcy5ib3VuZHMuaGVpZ2h0ICsgdGhpcy5ib3VuZHMueTtcblxuICAgIHZhciB3b3JsZFRyYW5zZm9ybSA9IG1hdHJpeCB8fCB0aGlzLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgdmFyIGEgPSB3b3JsZFRyYW5zZm9ybS5hO1xuICAgIHZhciBiID0gd29ybGRUcmFuc2Zvcm0uYztcbiAgICB2YXIgYyA9IHdvcmxkVHJhbnNmb3JtLmI7XG4gICAgdmFyIGQgPSB3b3JsZFRyYW5zZm9ybS5kO1xuICAgIHZhciB0eCA9IHdvcmxkVHJhbnNmb3JtLnR4O1xuICAgIHZhciB0eSA9IHdvcmxkVHJhbnNmb3JtLnR5O1xuXG4gICAgdmFyIHgxID0gYSAqIHcxICsgYyAqIGgxICsgdHg7XG4gICAgdmFyIHkxID0gZCAqIGgxICsgYiAqIHcxICsgdHk7XG5cbiAgICB2YXIgeDIgPSBhICogdzAgKyBjICogaDEgKyB0eDtcbiAgICB2YXIgeTIgPSBkICogaDEgKyBiICogdzAgKyB0eTtcblxuICAgIHZhciB4MyA9IGEgKiB3MCArIGMgKiBoMCArIHR4O1xuICAgIHZhciB5MyA9IGQgKiBoMCArIGIgKiB3MCArIHR5O1xuXG4gICAgdmFyIHg0ID0gIGEgKiB3MSArIGMgKiBoMCArIHR4O1xuICAgIHZhciB5NCA9ICBkICogaDAgKyBiICogdzEgKyB0eTtcblxuICAgIHZhciBtYXhYID0geDE7XG4gICAgdmFyIG1heFkgPSB5MTtcblxuICAgIHZhciBtaW5YID0geDE7XG4gICAgdmFyIG1pblkgPSB5MTtcblxuICAgIG1pblggPSB4MiA8IG1pblggPyB4MiA6IG1pblg7XG4gICAgbWluWCA9IHgzIDwgbWluWCA/IHgzIDogbWluWDtcbiAgICBtaW5YID0geDQgPCBtaW5YID8geDQgOiBtaW5YO1xuXG4gICAgbWluWSA9IHkyIDwgbWluWSA/IHkyIDogbWluWTtcbiAgICBtaW5ZID0geTMgPCBtaW5ZID8geTMgOiBtaW5ZO1xuICAgIG1pblkgPSB5NCA8IG1pblkgPyB5NCA6IG1pblk7XG5cbiAgICBtYXhYID0geDIgPiBtYXhYID8geDIgOiBtYXhYO1xuICAgIG1heFggPSB4MyA+IG1heFggPyB4MyA6IG1heFg7XG4gICAgbWF4WCA9IHg0ID4gbWF4WCA/IHg0IDogbWF4WDtcblxuICAgIG1heFkgPSB5MiA+IG1heFkgPyB5MiA6IG1heFk7XG4gICAgbWF4WSA9IHkzID4gbWF4WSA/IHkzIDogbWF4WTtcbiAgICBtYXhZID0geTQgPiBtYXhZID8geTQgOiBtYXhZO1xuXG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuX2JvdW5kcztcblxuICAgIGJvdW5kcy54ID0gbWluWDtcbiAgICBib3VuZHMud2lkdGggPSBtYXhYIC0gbWluWDtcblxuICAgIGJvdW5kcy55ID0gbWluWTtcbiAgICBib3VuZHMuaGVpZ2h0ID0gbWF4WSAtIG1pblk7XG5cbiAgICByZXR1cm4gYm91bmRzO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGJvdW5kcyBvZiB0aGUgb2JqZWN0XG4gKlxuICogQG1ldGhvZCB1cGRhdGVCb3VuZHNcbiAqL1xuUElYSS5HcmFwaGljcy5wcm90b3R5cGUudXBkYXRlQm91bmRzID0gZnVuY3Rpb24oKVxue1xuICAgIFxuICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgdmFyIG1heFggPSAtSW5maW5pdHk7XG5cbiAgICB2YXIgbWluWSA9IEluZmluaXR5O1xuICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xuXG4gICAgdmFyIHBvaW50cywgeCwgeSwgdywgaDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdyYXBoaWNzRGF0YVtpXTtcbiAgICAgICAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBkYXRhLmxpbmVXaWR0aDtcblxuICAgICAgICBwb2ludHMgPSBkYXRhLnBvaW50cztcblxuICAgICAgICBpZih0eXBlID09PSBQSVhJLkdyYXBoaWNzLlJFQ1QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHggPSBwb2ludHNbMF0gLSBsaW5lV2lkdGgvMjtcbiAgICAgICAgICAgIHkgPSBwb2ludHNbMV0gLSBsaW5lV2lkdGgvMjtcbiAgICAgICAgICAgIHcgPSBwb2ludHNbMl0gKyBsaW5lV2lkdGg7XG4gICAgICAgICAgICBoID0gcG9pbnRzWzNdICsgbGluZVdpZHRoO1xuXG4gICAgICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICAgICAgICAgIG1heFggPSB4ICsgdyA+IG1heFggPyB4ICsgdyA6IG1heFg7XG5cbiAgICAgICAgICAgIG1pblkgPSB5IDwgbWluWSA/IHggOiBtaW5ZO1xuICAgICAgICAgICAgbWF4WSA9IHkgKyBoID4gbWF4WSA/IHkgKyBoIDogbWF4WTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHR5cGUgPT09IFBJWEkuR3JhcGhpY3MuQ0lSQyB8fCB0eXBlID09PSBQSVhJLkdyYXBoaWNzLkVMSVApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHggPSBwb2ludHNbMF07XG4gICAgICAgICAgICB5ID0gcG9pbnRzWzFdO1xuICAgICAgICAgICAgdyA9IHBvaW50c1syXSArIGxpbmVXaWR0aC8yO1xuICAgICAgICAgICAgaCA9IHBvaW50c1szXSArIGxpbmVXaWR0aC8yO1xuXG4gICAgICAgICAgICBtaW5YID0geCAtIHcgPCBtaW5YID8geCAtIHcgOiBtaW5YO1xuICAgICAgICAgICAgbWF4WCA9IHggKyB3ID4gbWF4WCA/IHggKyB3IDogbWF4WDtcblxuICAgICAgICAgICAgbWluWSA9IHkgLSBoIDwgbWluWSA/IHkgLSBoIDogbWluWTtcbiAgICAgICAgICAgIG1heFkgPSB5ICsgaCA+IG1heFkgPyB5ICsgaCA6IG1heFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBQT0xZXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvaW50cy5sZW5ndGg7IGorPTIpXG4gICAgICAgICAgICB7XG5cbiAgICAgICAgICAgICAgICB4ID0gcG9pbnRzW2pdO1xuICAgICAgICAgICAgICAgIHkgPSBwb2ludHNbaisxXTtcbiAgICAgICAgICAgICAgICBtaW5YID0geC1saW5lV2lkdGggPCBtaW5YID8geC1saW5lV2lkdGggOiBtaW5YO1xuICAgICAgICAgICAgICAgIG1heFggPSB4K2xpbmVXaWR0aCA+IG1heFggPyB4K2xpbmVXaWR0aCA6IG1heFg7XG5cbiAgICAgICAgICAgICAgICBtaW5ZID0geS1saW5lV2lkdGggPCBtaW5ZID8geS1saW5lV2lkdGggOiBtaW5ZO1xuICAgICAgICAgICAgICAgIG1heFkgPSB5K2xpbmVXaWR0aCA+IG1heFkgPyB5K2xpbmVXaWR0aCA6IG1heFk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcGFkZGluZyA9IHRoaXMuYm91bmRzUGFkZGluZztcbiAgICB0aGlzLmJvdW5kcyA9IG5ldyBQSVhJLlJlY3RhbmdsZShtaW5YIC0gcGFkZGluZywgbWluWSAtIHBhZGRpbmcsIChtYXhYIC0gbWluWCkgKyBwYWRkaW5nICogMiwgKG1heFkgLSBtaW5ZKSArIHBhZGRpbmcgKiAyKTtcbn07XG5cblxuLyoqXG4gKiBHZW5lcmF0ZXMgdGhlIGNhY2hlZCBzcHJpdGUgd2hlbiB0aGUgc3ByaXRlIGhhcyBjYWNoZUFzQml0bWFwID0gdHJ1ZVxuICpcbiAqIEBtZXRob2QgX2dlbmVyYXRlQ2FjaGVkU3ByaXRlXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkdyYXBoaWNzLnByb3RvdHlwZS5fZ2VuZXJhdGVDYWNoZWRTcHJpdGUgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKTtcblxuICAgIGlmKCF0aGlzLl9jYWNoZWRTcHJpdGUpXG4gICAge1xuICAgICAgICB2YXIgY2FudmFzQnVmZmVyID0gbmV3IFBJWEkuQ2FudmFzQnVmZmVyKGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCk7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gUElYSS5UZXh0dXJlLmZyb21DYW52YXMoY2FudmFzQnVmZmVyLmNhbnZhcyk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9jYWNoZWRTcHJpdGUgPSBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XG4gICAgICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5idWZmZXIgPSBjYW52YXNCdWZmZXI7XG5cbiAgICAgICAgdGhpcy5fY2FjaGVkU3ByaXRlLndvcmxkVHJhbnNmb3JtID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkU3ByaXRlLmJ1ZmZlci5yZXNpemUoYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvLyBsZXZlcmFnZSB0aGUgYW5jaG9yIHRvIGFjY291bnQgZm9yIHRoZSBvZmZzZXQgb2YgdGhlIGVsZW1lbnRcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUuYW5jaG9yLnggPSAtKCBib3VuZHMueCAvIGJvdW5kcy53aWR0aCApO1xuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5hbmNob3IueSA9IC0oIGJvdW5kcy55IC8gYm91bmRzLmhlaWdodCApO1xuXG4gICAvLyB0aGlzLl9jYWNoZWRTcHJpdGUuYnVmZmVyLmNvbnRleHQuc2F2ZSgpO1xuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5idWZmZXIuY29udGV4dC50cmFuc2xhdGUoLWJvdW5kcy54LC1ib3VuZHMueSk7XG4gICAgXG4gICAgUElYSS5DYW52YXNHcmFwaGljcy5yZW5kZXJHcmFwaGljcyh0aGlzLCB0aGlzLl9jYWNoZWRTcHJpdGUuYnVmZmVyLmNvbnRleHQpO1xuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5hbHBoYSA9IHRoaXMuYWxwaGE7XG5cbiAgIC8vIHRoaXMuX2NhY2hlZFNwcml0ZS5idWZmZXIuY29udGV4dC5yZXN0b3JlKCk7XG59O1xuXG5QSVhJLkdyYXBoaWNzLnByb3RvdHlwZS5kZXN0cm95Q2FjaGVkU3ByaXRlID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS50ZXh0dXJlLmRlc3Ryb3kodHJ1ZSk7XG5cbiAgICAvLyBsZXQgdGhlIGdjIGNvbGxlY3QgdGhlIHVudXNlZCBzcHJpdGVcbiAgICAvLyBUT0RPIGNvdWxkIGJlIG9iamVjdCBwb29sZWQhXG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlID0gbnVsbDtcbn07XG5cblxuLy8gU09NRSBUWVBFUzpcblBJWEkuR3JhcGhpY3MuUE9MWSA9IDA7XG5QSVhJLkdyYXBoaWNzLlJFQ1QgPSAxO1xuUElYSS5HcmFwaGljcy5DSVJDID0gMjtcblBJWEkuR3JhcGhpY3MuRUxJUCA9IDM7XG5QSVhJLkdyYXBoaWNzLlJSRUMgPSA0O1xuXG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tL1xuICovXG5cbiAvKipcbiAqIFxuICogQGNsYXNzIFN0cmlwXG4gKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0Q29udGFpbmVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfSBUaGUgdGV4dHVyZSB0byB1c2VcbiAqIEBwYXJhbSB3aWR0aCB7TnVtYmVyfSB0aGUgd2lkdGggXG4gKiBAcGFyYW0gaGVpZ2h0IHtOdW1iZXJ9IHRoZSBoZWlnaHRcbiAqIFxuICovXG5QSVhJLlN0cmlwID0gZnVuY3Rpb24odGV4dHVyZSlcbntcbiAgICBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIuY2FsbCggdGhpcyApO1xuICAgIFxuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG5cbiAgICAvLyBzZXQgdXAgdGhlIG1haW4gYml0cy4uXG4gICAgdGhpcy51dnMgPSBuZXcgUElYSS5GbG9hdDMyQXJyYXkoWzAsIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLCAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMSwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsMV0pO1xuXG4gICAgdGhpcy52ZXJ0aWNpZXMgPSBuZXcgUElYSS5GbG9hdDMyQXJyYXkoWzAsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgMTAwLDAsXG4gICAgICAgICAgICAgICAgICAgICAgMTAwLDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAwLCAxMDBdKTtcblxuICAgIHRoaXMuY29sb3JzID0gbmV3IFBJWEkuRmxvYXQzMkFycmF5KFsxLCAxLCAxLCAxXSk7XG5cbiAgICB0aGlzLmluZGljZXMgPSBuZXcgUElYSS5VaW50MTZBcnJheShbMCwgMSwgMiwgM10pO1xuICAgIFxuXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG59O1xuXG4vLyBjb25zdHJ1Y3RvclxuUElYSS5TdHJpcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUpO1xuUElYSS5TdHJpcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLlN0cmlwO1xuXG5QSVhJLlN0cmlwLnByb3RvdHlwZS5fcmVuZGVyV2ViR0wgPSBmdW5jdGlvbihyZW5kZXJTZXNzaW9uKVxue1xuICAgIC8vIGlmIHRoZSBzcHJpdGUgaXMgbm90IHZpc2libGUgb3IgdGhlIGFscGhhIGlzIDAgdGhlbiBubyBuZWVkIHRvIHJlbmRlciB0aGlzIGVsZW1lbnRcbiAgICBpZighdGhpcy52aXNpYmxlIHx8IHRoaXMuYWxwaGEgPD0gMClyZXR1cm47XG4gICAgLy8gcmVuZGVyIHRyaWFuZ2xlIHN0cmlwLi5cblxuICAgIHJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2guc3RvcCgpO1xuXG4gICAgLy8gaW5pdCEgaW5pdCFcbiAgICBpZighdGhpcy5fdmVydGV4QnVmZmVyKXRoaXMuX2luaXRXZWJHTChyZW5kZXJTZXNzaW9uKTtcbiAgICBcbiAgICByZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIuc2V0U2hhZGVyKHJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlci5zdHJpcFNoYWRlcik7XG5cbiAgICB0aGlzLl9yZW5kZXJTdHJpcChyZW5kZXJTZXNzaW9uKTtcblxuICAgIC8vL3JlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlci5hY3RpdmF0ZURlZmF1bHRTaGFkZXIoKTtcblxuICAgIHJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2guc3RhcnQoKTtcblxuICAgIC8vVE9ETyBjaGVjayBjdWxsaW5nICBcbn07XG5cblBJWEkuU3RyaXAucHJvdG90eXBlLl9pbml0V2ViR0wgPSBmdW5jdGlvbihyZW5kZXJTZXNzaW9uKVxue1xuICAgIC8vIGJ1aWxkIHRoZSBzdHJpcCFcbiAgICB2YXIgZ2wgPSByZW5kZXJTZXNzaW9uLmdsO1xuICAgIFxuICAgIHRoaXMuX3ZlcnRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMuX2luZGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy5fdXZCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLl9jb2xvckJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIFxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLl92ZXJ0ZXhCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRpY2llcywgZ2wuRFlOQU1JQ19EUkFXKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLl91dkJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsICB0aGlzLnV2cywgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuX2NvbG9yQnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5jb2xvcnMsIGdsLlNUQVRJQ19EUkFXKTtcbiBcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLl9pbmRleEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRpY2VzLCBnbC5TVEFUSUNfRFJBVyk7XG59O1xuXG5QSVhJLlN0cmlwLnByb3RvdHlwZS5fcmVuZGVyU3RyaXAgPSBmdW5jdGlvbihyZW5kZXJTZXNzaW9uKVxue1xuICAgIHZhciBnbCA9IHJlbmRlclNlc3Npb24uZ2w7XG4gICAgdmFyIHByb2plY3Rpb24gPSByZW5kZXJTZXNzaW9uLnByb2plY3Rpb24sXG4gICAgICAgIG9mZnNldCA9IHJlbmRlclNlc3Npb24ub2Zmc2V0LFxuICAgICAgICBzaGFkZXIgPSByZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIuc3RyaXBTaGFkZXI7XG5cblxuICAgIC8vIGdsLnVuaWZvcm1NYXRyaXg0ZnYoc2hhZGVyUHJvZ3JhbS5tdk1hdHJpeFVuaWZvcm0sIGZhbHNlLCBtYXQ0UmVhbCk7XG5cbiAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcblxuICAgIC8vIHNldCB1bmlmb3Jtc1xuICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoc2hhZGVyLnRyYW5zbGF0aW9uTWF0cml4LCBmYWxzZSwgdGhpcy53b3JsZFRyYW5zZm9ybS50b0FycmF5KHRydWUpKTtcbiAgICBnbC51bmlmb3JtMmYoc2hhZGVyLnByb2plY3Rpb25WZWN0b3IsIHByb2plY3Rpb24ueCwgLXByb2plY3Rpb24ueSk7XG4gICAgZ2wudW5pZm9ybTJmKHNoYWRlci5vZmZzZXRWZWN0b3IsIC1vZmZzZXQueCwgLW9mZnNldC55KTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLmFscGhhLCAxKTtcblxuICAgIGlmKCF0aGlzLmRpcnR5KVxuICAgIHtcbiAgICAgICAgXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLl92ZXJ0ZXhCdWZmZXIpO1xuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdGhpcy52ZXJ0aWNpZXMpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hVmVydGV4UG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgICAgIFxuICAgICAgICAvLyB1cGRhdGUgdGhlIHV2c1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5fdXZCdWZmZXIpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hVGV4dHVyZUNvb3JkLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgICAgICAgICAgXG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgICAgICAgLy8gYmluZCB0aGUgY3VycmVudCB0ZXh0dXJlXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZS5iYXNlVGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0gfHwgUElYSS5jcmVhdGVXZWJHTFRleHR1cmUodGhpcy50ZXh0dXJlLmJhc2VUZXh0dXJlLCBnbCkpO1xuICAgIFxuICAgICAgICAvLyBkb250IG5lZWQgdG8gdXBsb2FkIVxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLl9pbmRleEJ1ZmZlcik7XG4gICAgXG4gICAgXG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG5cbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5fdmVydGV4QnVmZmVyKTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGljaWVzLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFWZXJ0ZXhQb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdXZzXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLl91dkJ1ZmZlcik7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnV2cywgZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hVGV4dHVyZUNvb3JkLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgICAgICAgICAgXG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUuYmFzZVRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdIHx8IFBJWEkuY3JlYXRlV2ViR0xUZXh0dXJlKHRoaXMudGV4dHVyZS5iYXNlVGV4dHVyZSwgZ2wpKTtcbiAgICBcbiAgICAgICAgLy8gZG9udCBuZWVkIHRvIHVwbG9hZCFcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5faW5kZXhCdWZmZXIpO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGljZXMsIGdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgXG4gICAgfVxuICAgIC8vY29uc29sZS5sb2coZ2wuVFJJQU5HTEVfU1RSSVApXG4gICAgLy9cbiAgICAvL1xuICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRV9TVFJJUCwgdGhpcy5pbmRpY2VzLmxlbmd0aCwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xuICAgIFxuICBcbn07XG5cblBJWEkuU3RyaXAucHJvdG90eXBlLl9yZW5kZXJDYW52YXMgPSBmdW5jdGlvbihyZW5kZXJTZXNzaW9uKVxue1xuICAgIHZhciBjb250ZXh0ID0gcmVuZGVyU2Vzc2lvbi5jb250ZXh0O1xuICAgIFxuICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgaWYgKHJlbmRlclNlc3Npb24ucm91bmRQaXhlbHMpXG4gICAge1xuICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSh0cmFuc2Zvcm0uYSwgdHJhbnNmb3JtLmMsIHRyYW5zZm9ybS5iLCB0cmFuc2Zvcm0uZCwgdHJhbnNmb3JtLnR4IHwgMCwgdHJhbnNmb3JtLnR5IHwgMCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKHRyYW5zZm9ybS5hLCB0cmFuc2Zvcm0uYywgdHJhbnNmb3JtLmIsIHRyYW5zZm9ybS5kLCB0cmFuc2Zvcm0udHgsIHRyYW5zZm9ybS50eSk7XG4gICAgfVxuICAgICAgICBcbiAgICB2YXIgc3RyaXAgPSB0aGlzO1xuICAgIC8vIGRyYXcgdHJpYW5nbGVzISFcbiAgICB2YXIgdmVydGljaWVzID0gc3RyaXAudmVydGljaWVzO1xuICAgIHZhciB1dnMgPSBzdHJpcC51dnM7XG5cbiAgICB2YXIgbGVuZ3RoID0gdmVydGljaWVzLmxlbmd0aC8yO1xuICAgIHRoaXMuY291bnQrKztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoLTI7IGkrKylcbiAgICB7XG4gICAgICAgIC8vIGRyYXcgc29tZSB0cmlhbmdsZXMhXG4gICAgICAgIHZhciBpbmRleCA9IGkqMjtcblxuICAgICAgICB2YXIgeDAgPSB2ZXJ0aWNpZXNbaW5kZXhdLCAgIHgxID0gdmVydGljaWVzW2luZGV4KzJdLCB4MiA9IHZlcnRpY2llc1tpbmRleCs0XTtcbiAgICAgICAgdmFyIHkwID0gdmVydGljaWVzW2luZGV4KzFdLCB5MSA9IHZlcnRpY2llc1tpbmRleCszXSwgeTIgPSB2ZXJ0aWNpZXNbaW5kZXgrNV07XG5cbiAgICAgICAgaWYodHJ1ZSlcbiAgICAgICAge1xuXG4gICAgICAgICAgICAvL2V4cGFuZCgpO1xuICAgICAgICAgICAgdmFyIGNlbnRlclggPSAoeDAgKyB4MSArIHgyKS8zO1xuICAgICAgICAgICAgdmFyIGNlbnRlclkgPSAoeTAgKyB5MSArIHkyKS8zO1xuXG4gICAgICAgICAgICB2YXIgbm9ybVggPSB4MCAtIGNlbnRlclg7XG4gICAgICAgICAgICB2YXIgbm9ybVkgPSB5MCAtIGNlbnRlclk7XG5cbiAgICAgICAgICAgIHZhciBkaXN0ID0gTWF0aC5zcXJ0KCBub3JtWCAqIG5vcm1YICsgbm9ybVkgKiBub3JtWSApO1xuICAgICAgICAgICAgeDAgPSBjZW50ZXJYICsgKG5vcm1YIC8gZGlzdCkgKiAoZGlzdCArIDMpO1xuICAgICAgICAgICAgeTAgPSBjZW50ZXJZICsgKG5vcm1ZIC8gZGlzdCkgKiAoZGlzdCArIDMpO1xuXG4gICAgICAgICAgICAvLyBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbm9ybVggPSB4MSAtIGNlbnRlclg7XG4gICAgICAgICAgICBub3JtWSA9IHkxIC0gY2VudGVyWTtcblxuICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydCggbm9ybVggKiBub3JtWCArIG5vcm1ZICogbm9ybVkgKTtcbiAgICAgICAgICAgIHgxID0gY2VudGVyWCArIChub3JtWCAvIGRpc3QpICogKGRpc3QgKyAzKTtcbiAgICAgICAgICAgIHkxID0gY2VudGVyWSArIChub3JtWSAvIGRpc3QpICogKGRpc3QgKyAzKTtcblxuICAgICAgICAgICAgbm9ybVggPSB4MiAtIGNlbnRlclg7XG4gICAgICAgICAgICBub3JtWSA9IHkyIC0gY2VudGVyWTtcblxuICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydCggbm9ybVggKiBub3JtWCArIG5vcm1ZICogbm9ybVkgKTtcbiAgICAgICAgICAgIHgyID0gY2VudGVyWCArIChub3JtWCAvIGRpc3QpICogKGRpc3QgKyAzKTtcbiAgICAgICAgICAgIHkyID0gY2VudGVyWSArIChub3JtWSAvIGRpc3QpICogKGRpc3QgKyAzKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHUwID0gdXZzW2luZGV4XSAqIHN0cmlwLnRleHR1cmUud2lkdGgsICAgdTEgPSB1dnNbaW5kZXgrMl0gKiBzdHJpcC50ZXh0dXJlLndpZHRoLCB1MiA9IHV2c1tpbmRleCs0XSogc3RyaXAudGV4dHVyZS53aWR0aDtcbiAgICAgICAgdmFyIHYwID0gdXZzW2luZGV4KzFdKiBzdHJpcC50ZXh0dXJlLmhlaWdodCwgdjEgPSB1dnNbaW5kZXgrM10gKiBzdHJpcC50ZXh0dXJlLmhlaWdodCwgdjIgPSB1dnNbaW5kZXgrNV0qIHN0cmlwLnRleHR1cmUuaGVpZ2h0O1xuXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG5cbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeDAsIHkwKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeDEsIHkxKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeDIsIHkyKTtcblxuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgIGNvbnRleHQuY2xpcCgpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgbWF0cml4IHRyYW5zZm9ybVxuICAgICAgICB2YXIgZGVsdGEgPSB1MCp2MSArIHYwKnUyICsgdTEqdjIgLSB2MSp1MiAtIHYwKnUxIC0gdTAqdjI7XG4gICAgICAgIHZhciBkZWx0YUEgPSB4MCp2MSArIHYwKngyICsgeDEqdjIgLSB2MSp4MiAtIHYwKngxIC0geDAqdjI7XG4gICAgICAgIHZhciBkZWx0YUIgPSB1MCp4MSArIHgwKnUyICsgdTEqeDIgLSB4MSp1MiAtIHgwKnUxIC0gdTAqeDI7XG4gICAgICAgIHZhciBkZWx0YUMgPSB1MCp2MSp4MiArIHYwKngxKnUyICsgeDAqdTEqdjIgLSB4MCp2MSp1MiAtIHYwKnUxKngyIC0gdTAqeDEqdjI7XG4gICAgICAgIHZhciBkZWx0YUQgPSB5MCp2MSArIHYwKnkyICsgeTEqdjIgLSB2MSp5MiAtIHYwKnkxIC0geTAqdjI7XG4gICAgICAgIHZhciBkZWx0YUUgPSB1MCp5MSArIHkwKnUyICsgdTEqeTIgLSB5MSp1MiAtIHkwKnUxIC0gdTAqeTI7XG4gICAgICAgIHZhciBkZWx0YUYgPSB1MCp2MSp5MiArIHYwKnkxKnUyICsgeTAqdTEqdjIgLSB5MCp2MSp1MiAtIHYwKnUxKnkyIC0gdTAqeTEqdjI7XG5cbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm0oZGVsdGFBIC8gZGVsdGEsIGRlbHRhRCAvIGRlbHRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhQiAvIGRlbHRhLCBkZWx0YUUgLyBkZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YUMgLyBkZWx0YSwgZGVsdGFGIC8gZGVsdGEpO1xuXG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHN0cmlwLnRleHR1cmUuYmFzZVRleHR1cmUuc291cmNlLCAwLCAwKTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfVxufTtcblxuLypcbiAqIFNldHMgdGhlIHRleHR1cmUgdGhhdCB0aGUgU3RyaXAgd2lsbCB1c2UgXG4gKlxuICogQG1ldGhvZCBzZXRUZXh0dXJlXG4gKiBAcGFyYW0gdGV4dHVyZSB7VGV4dHVyZX0gdGhlIHRleHR1cmUgdGhhdCB3aWxsIGJlIHVzZWRcbiAqIEBwcml2YXRlXG4gKi9cblxuLypcblBJWEkuU3RyaXAucHJvdG90eXBlLnNldFRleHR1cmUgPSBmdW5jdGlvbih0ZXh0dXJlKVxue1xuICAgIC8vVE9ETyBTRVQgVEhFIFRFWFRVUkVTXG4gICAgLy9UT0RPIFZJU0lCSUxJVFlcblxuICAgIC8vIHN0b3AgY3VycmVudCB0ZXh0dXJlXG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICB0aGlzLndpZHRoICAgPSB0ZXh0dXJlLmZyYW1lLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ICA9IHRleHR1cmUuZnJhbWUuaGVpZ2h0O1xuICAgIHRoaXMudXBkYXRlRnJhbWUgPSB0cnVlO1xufTtcbiovXG5cbi8qKlxuICogV2hlbiB0aGUgdGV4dHVyZSBpcyB1cGRhdGVkLCB0aGlzIGV2ZW50IHdpbGwgZmlyZSB0byB1cGRhdGUgdGhlIHNjYWxlIGFuZCBmcmFtZVxuICpcbiAqIEBtZXRob2Qgb25UZXh0dXJlVXBkYXRlXG4gKiBAcGFyYW0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cblxuUElYSS5TdHJpcC5wcm90b3R5cGUub25UZXh0dXJlVXBkYXRlID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMudXBkYXRlRnJhbWUgPSB0cnVlO1xufTtcbi8qIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogXG4gKiBAY2xhc3MgUm9wZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gdGV4dHVyZSB7VGV4dHVyZX0gVGhlIHRleHR1cmUgdG8gdXNlXG4gKiBAcGFyYW0gcG9pbnRzIHtBcnJheX1cbiAqIFxuICovXG5QSVhJLlJvcGUgPSBmdW5jdGlvbih0ZXh0dXJlLCBwb2ludHMpXG57XG4gICAgUElYSS5TdHJpcC5jYWxsKCB0aGlzLCB0ZXh0dXJlICk7XG4gICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XG5cbiAgICB0aGlzLnZlcnRpY2llcyA9IG5ldyBQSVhJLkZsb2F0MzJBcnJheShwb2ludHMubGVuZ3RoICogNCk7XG4gICAgdGhpcy51dnMgPSBuZXcgUElYSS5GbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDQpO1xuICAgIHRoaXMuY29sb3JzID0gbmV3IFBJWEkuRmxvYXQzMkFycmF5KHBvaW50cy5sZW5ndGggKiAyKTtcbiAgICB0aGlzLmluZGljZXMgPSBuZXcgUElYSS5VaW50MTZBcnJheShwb2ludHMubGVuZ3RoICogMik7XG4gICBcblxuICAgIHRoaXMucmVmcmVzaCgpO1xufTtcblxuXG4vLyBjb25zdHJ1Y3RvclxuUElYSS5Sb3BlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBJWEkuU3RyaXAucHJvdG90eXBlICk7XG5QSVhJLlJvcGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5Sb3BlO1xuXG4vKlxuICogUmVmcmVzaGVzIFxuICpcbiAqIEBtZXRob2QgcmVmcmVzaFxuICovXG5QSVhJLlJvcGUucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIGlmKHBvaW50cy5sZW5ndGggPCAxKSByZXR1cm47XG5cbiAgICB2YXIgdXZzID0gdGhpcy51dnM7XG5cbiAgICB2YXIgbGFzdFBvaW50ID0gcG9pbnRzWzBdO1xuICAgIHZhciBpbmRpY2VzID0gdGhpcy5pbmRpY2VzO1xuICAgIHZhciBjb2xvcnMgPSB0aGlzLmNvbG9ycztcblxuICAgIHRoaXMuY291bnQtPTAuMjtcblxuICAgIHV2c1swXSA9IDA7XG4gICAgdXZzWzFdID0gMDtcbiAgICB1dnNbMl0gPSAwO1xuICAgIHV2c1szXSA9IDE7XG5cbiAgICBjb2xvcnNbMF0gPSAxO1xuICAgIGNvbG9yc1sxXSA9IDE7XG5cbiAgICBpbmRpY2VzWzBdID0gMDtcbiAgICBpbmRpY2VzWzFdID0gMTtcblxuICAgIHZhciB0b3RhbCA9IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIHBvaW50LCBpbmRleCwgYW1vdW50O1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0b3RhbDsgaSsrKVxuICAgIHtcbiAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgIGluZGV4ID0gaSAqIDQ7XG4gICAgICAgIC8vIHRpbWUgdG8gZG8gc29tZSBzbWFydCBkcmF3aW5nIVxuICAgICAgICBhbW91bnQgPSBpIC8gKHRvdGFsLTEpO1xuXG4gICAgICAgIGlmKGklMilcbiAgICAgICAge1xuICAgICAgICAgICAgdXZzW2luZGV4XSA9IGFtb3VudDtcbiAgICAgICAgICAgIHV2c1tpbmRleCsxXSA9IDA7XG5cbiAgICAgICAgICAgIHV2c1tpbmRleCsyXSA9IGFtb3VudDtcbiAgICAgICAgICAgIHV2c1tpbmRleCszXSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB1dnNbaW5kZXhdID0gYW1vdW50O1xuICAgICAgICAgICAgdXZzW2luZGV4KzFdID0gMDtcblxuICAgICAgICAgICAgdXZzW2luZGV4KzJdID0gYW1vdW50O1xuICAgICAgICAgICAgdXZzW2luZGV4KzNdID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gaSAqIDI7XG4gICAgICAgIGNvbG9yc1tpbmRleF0gPSAxO1xuICAgICAgICBjb2xvcnNbaW5kZXgrMV0gPSAxO1xuXG4gICAgICAgIGluZGV4ID0gaSAqIDI7XG4gICAgICAgIGluZGljZXNbaW5kZXhdID0gaW5kZXg7XG4gICAgICAgIGluZGljZXNbaW5kZXggKyAxXSA9IGluZGV4ICsgMTtcblxuICAgICAgICBsYXN0UG9pbnQgPSBwb2ludDtcbiAgICB9XG59O1xuXG4vKlxuICogVXBkYXRlcyB0aGUgb2JqZWN0IHRyYW5zZm9ybSBmb3IgcmVuZGVyaW5nXG4gKlxuICogQG1ldGhvZCB1cGRhdGVUcmFuc2Zvcm1cbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuUm9wZS5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24oKVxue1xuXG4gICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIGlmKHBvaW50cy5sZW5ndGggPCAxKXJldHVybjtcblxuICAgIHZhciBsYXN0UG9pbnQgPSBwb2ludHNbMF07XG4gICAgdmFyIG5leHRQb2ludDtcbiAgICB2YXIgcGVycCA9IHt4OjAsIHk6MH07XG5cbiAgICB0aGlzLmNvdW50LT0wLjI7XG5cbiAgICB2YXIgdmVydGljaWVzID0gdGhpcy52ZXJ0aWNpZXM7XG4gICAgdmFyIHRvdGFsID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgcG9pbnQsIGluZGV4LCByYXRpbywgcGVycExlbmd0aCwgbnVtO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKVxuICAgIHtcbiAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgIGluZGV4ID0gaSAqIDQ7XG5cbiAgICAgICAgaWYoaSA8IHBvaW50cy5sZW5ndGgtMSlcbiAgICAgICAge1xuICAgICAgICAgICAgbmV4dFBvaW50ID0gcG9pbnRzW2krMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBuZXh0UG9pbnQgPSBwb2ludDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBlcnAueSA9IC0obmV4dFBvaW50LnggLSBsYXN0UG9pbnQueCk7XG4gICAgICAgIHBlcnAueCA9IG5leHRQb2ludC55IC0gbGFzdFBvaW50Lnk7XG5cbiAgICAgICAgcmF0aW8gPSAoMSAtIChpIC8gKHRvdGFsLTEpKSkgKiAxMDtcblxuICAgICAgICBpZihyYXRpbyA+IDEpIHJhdGlvID0gMTtcblxuICAgICAgICBwZXJwTGVuZ3RoID0gTWF0aC5zcXJ0KHBlcnAueCAqIHBlcnAueCArIHBlcnAueSAqIHBlcnAueSk7XG4gICAgICAgIG51bSA9IHRoaXMudGV4dHVyZS5oZWlnaHQgLyAyOyAvLygyMCArIE1hdGguYWJzKE1hdGguc2luKChpICsgdGhpcy5jb3VudCkgKiAwLjMpICogNTApICkqIHJhdGlvO1xuICAgICAgICBwZXJwLnggLz0gcGVycExlbmd0aDtcbiAgICAgICAgcGVycC55IC89IHBlcnBMZW5ndGg7XG5cbiAgICAgICAgcGVycC54ICo9IG51bTtcbiAgICAgICAgcGVycC55ICo9IG51bTtcblxuICAgICAgICB2ZXJ0aWNpZXNbaW5kZXhdID0gcG9pbnQueCArIHBlcnAueDtcbiAgICAgICAgdmVydGljaWVzW2luZGV4KzFdID0gcG9pbnQueSArIHBlcnAueTtcbiAgICAgICAgdmVydGljaWVzW2luZGV4KzJdID0gcG9pbnQueCAtIHBlcnAueDtcbiAgICAgICAgdmVydGljaWVzW2luZGV4KzNdID0gcG9pbnQueSAtIHBlcnAueTtcblxuICAgICAgICBsYXN0UG9pbnQgPSBwb2ludDtcbiAgICB9XG5cbiAgICBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybS5jYWxsKCB0aGlzICk7XG59O1xuLypcbiAqIFNldHMgdGhlIHRleHR1cmUgdGhhdCB0aGUgUm9wZSB3aWxsIHVzZSBcbiAqXG4gKiBAbWV0aG9kIHNldFRleHR1cmVcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfSB0aGUgdGV4dHVyZSB0aGF0IHdpbGwgYmUgdXNlZFxuICovXG5QSVhJLlJvcGUucHJvdG90eXBlLnNldFRleHR1cmUgPSBmdW5jdGlvbih0ZXh0dXJlKVxue1xuICAgIC8vIHN0b3AgY3VycmVudCB0ZXh0dXJlXG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICAvL3RoaXMudXBkYXRlRnJhbWUgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vXG4gKi9cblxuLyoqXG4gKiBBIHRpbGluZyBzcHJpdGUgaXMgYSBmYXN0IHdheSBvZiByZW5kZXJpbmcgYSB0aWxpbmcgaW1hZ2VcbiAqXG4gKiBAY2xhc3MgVGlsaW5nU3ByaXRlXG4gKiBAZXh0ZW5kcyBTcHJpdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHRleHR1cmUge1RleHR1cmV9IHRoZSB0ZXh0dXJlIG9mIHRoZSB0aWxpbmcgc3ByaXRlXG4gKiBAcGFyYW0gd2lkdGgge051bWJlcn0gIHRoZSB3aWR0aCBvZiB0aGUgdGlsaW5nIHNwcml0ZVxuICogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSB0aGUgaGVpZ2h0IG9mIHRoZSB0aWxpbmcgc3ByaXRlXG4gKi9cblBJWEkuVGlsaW5nU3ByaXRlID0gZnVuY3Rpb24odGV4dHVyZSwgd2lkdGgsIGhlaWdodClcbntcbiAgICBQSVhJLlNwcml0ZS5jYWxsKCB0aGlzLCB0ZXh0dXJlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aXRoIG9mIHRoZSB0aWxpbmcgc3ByaXRlXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgd2lkdGhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLl93aWR0aCA9IHdpZHRoIHx8IDEwMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBoZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQgfHwgMTAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjYWxpbmcgb2YgdGhlIGltYWdlIHRoYXQgaXMgYmVpbmcgdGlsZWRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0aWxlU2NhbGVcbiAgICAgKiBAdHlwZSBQb2ludFxuICAgICAqL1xuICAgIHRoaXMudGlsZVNjYWxlID0gbmV3IFBJWEkuUG9pbnQoMSwxKTtcblxuICAgIC8qKlxuICAgICAqIEEgcG9pbnQgdGhhdCByZXByZXNlbnRzIHRoZSBzY2FsZSBvZiB0aGUgdGV4dHVyZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0aWxlU2NhbGVPZmZzZXRcbiAgICAgKiBAdHlwZSBQb2ludFxuICAgICAqL1xuICAgIHRoaXMudGlsZVNjYWxlT2Zmc2V0ID0gbmV3IFBJWEkuUG9pbnQoMSwxKTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBUaGUgb2Zmc2V0IHBvc2l0aW9uIG9mIHRoZSBpbWFnZSB0aGF0IGlzIGJlaW5nIHRpbGVkXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdGlsZVBvc2l0aW9uXG4gICAgICogQHR5cGUgUG9pbnRcbiAgICAgKi9cbiAgICB0aGlzLnRpbGVQb3NpdGlvbiA9IG5ldyBQSVhJLlBvaW50KDAsMCk7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgc3ByaXRlIGlzIHJlbmRlcmFibGUgb3Igbm90XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyYWJsZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJhYmxlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aW50IGFwcGxpZWQgdG8gdGhlIHNwcml0ZS4gVGhpcyBpcyBhIGhleCB2YWx1ZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRpbnRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAweEZGRkZGRlxuICAgICAqL1xuICAgIHRoaXMudGludCA9IDB4RkZGRkZGO1xuICAgIFxuICAgIC8qKlxuICAgICAqIFRoZSBibGVuZCBtb2RlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHNwcml0ZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJsZW5kTW9kZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IFBJWEkuYmxlbmRNb2Rlcy5OT1JNQUw7XG4gICAgICovXG4gICAgdGhpcy5ibGVuZE1vZGUgPSBQSVhJLmJsZW5kTW9kZXMuTk9STUFMO1xuXG4gICAgXG5cbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLlRpbGluZ1Nwcml0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBJWEkuU3ByaXRlLnByb3RvdHlwZSk7XG5QSVhJLlRpbGluZ1Nwcml0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLlRpbGluZ1Nwcml0ZTtcblxuXG4vKipcbiAqIFRoZSB3aWR0aCBvZiB0aGUgc3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxuICpcbiAqIEBwcm9wZXJ0eSB3aWR0aFxuICogQHR5cGUgTnVtYmVyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLlRpbGluZ1Nwcml0ZS5wcm90b3R5cGUsICd3aWR0aCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFRoZSBoZWlnaHQgb2YgdGhlIFRpbGluZ1Nwcml0ZSwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcbiAqXG4gKiBAcHJvcGVydHkgaGVpZ2h0XG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuVGlsaW5nU3ByaXRlLnByb3RvdHlwZSwgJ2hlaWdodCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIHRoaXMuX2hlaWdodDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gICAgfVxufSk7XG5cblBJWEkuVGlsaW5nU3ByaXRlLnByb3RvdHlwZS5zZXRUZXh0dXJlID0gZnVuY3Rpb24odGV4dHVyZSlcbntcbiAgICBpZiAodGhpcy50ZXh0dXJlID09PSB0ZXh0dXJlKSByZXR1cm47XG5cbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuXG4gICAgdGhpcy5yZWZyZXNoVGV4dHVyZSA9IHRydWU7XG5cbiAgICB0aGlzLmNhY2hlZFRpbnQgPSAweEZGRkZGRjtcbn07XG5cbi8qKlxuKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyXG4qXG4qIEBtZXRob2QgX3JlbmRlcldlYkdMXG4qIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtSZW5kZXJTZXNzaW9ufSBcbiogQHByaXZhdGVcbiovXG5QSVhJLlRpbGluZ1Nwcml0ZS5wcm90b3R5cGUuX3JlbmRlcldlYkdMID0gZnVuY3Rpb24ocmVuZGVyU2Vzc2lvbilcbntcbiAgICBpZiAodGhpcy52aXNpYmxlID09PSBmYWxzZSB8fCB0aGlzLmFscGhhID09PSAwKSByZXR1cm47XG4gICAgdmFyIGksajtcblxuICAgIGlmICh0aGlzLl9tYXNrKVxuICAgIHtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaC5zdG9wKCk7XG4gICAgICAgIHJlbmRlclNlc3Npb24ubWFza01hbmFnZXIucHVzaE1hc2sodGhpcy5tYXNrLCByZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaC5zdGFydCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9maWx0ZXJzKVxuICAgIHtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaC5mbHVzaCgpO1xuICAgICAgICByZW5kZXJTZXNzaW9uLmZpbHRlck1hbmFnZXIucHVzaEZpbHRlcih0aGlzLl9maWx0ZXJCbG9jayk7XG4gICAgfVxuXG4gICBcblxuICAgIGlmICghdGhpcy50aWxpbmdUZXh0dXJlIHx8IHRoaXMucmVmcmVzaFRleHR1cmUpXG4gICAge1xuICAgICAgICB0aGlzLmdlbmVyYXRlVGlsaW5nVGV4dHVyZSh0cnVlKTtcblxuICAgICAgICBpZiAodGhpcy50aWxpbmdUZXh0dXJlICYmIHRoaXMudGlsaW5nVGV4dHVyZS5uZWVkc1VwZGF0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy9UT0RPIC0gdHdlYWtpbmdcbiAgICAgICAgICAgIFBJWEkudXBkYXRlV2ViR0xUZXh0dXJlKHRoaXMudGlsaW5nVGV4dHVyZS5iYXNlVGV4dHVyZSwgcmVuZGVyU2Vzc2lvbi5nbCk7XG4gICAgICAgICAgICB0aGlzLnRpbGluZ1RleHR1cmUubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgLy8gdGhpcy50aWxpbmdUZXh0dXJlLl91dnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2gucmVuZGVyVGlsaW5nU3ByaXRlKHRoaXMpO1xuICAgIH1cbiAgICAvLyBzaW1wbGUgcmVuZGVyIGNoaWxkcmVuIVxuICAgIGZvciAoaT0wLGo9dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGk8ajsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5fcmVuZGVyV2ViR0wocmVuZGVyU2Vzc2lvbik7XG4gICAgfVxuXG4gICAgcmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaC5zdG9wKCk7XG5cbiAgICBpZiAodGhpcy5fZmlsdGVycykgcmVuZGVyU2Vzc2lvbi5maWx0ZXJNYW5hZ2VyLnBvcEZpbHRlcigpO1xuICAgIGlmICh0aGlzLl9tYXNrKSByZW5kZXJTZXNzaW9uLm1hc2tNYW5hZ2VyLnBvcE1hc2socmVuZGVyU2Vzc2lvbik7XG4gICAgXG4gICAgcmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaC5zdGFydCgpO1xufTtcblxuLyoqXG4qIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgQ2FudmFzIHJlbmRlcmVyXG4qXG4qIEBtZXRob2QgX3JlbmRlckNhbnZhc1xuKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7UmVuZGVyU2Vzc2lvbn0gXG4qIEBwcml2YXRlXG4qL1xuUElYSS5UaWxpbmdTcHJpdGUucHJvdG90eXBlLl9yZW5kZXJDYW52YXMgPSBmdW5jdGlvbihyZW5kZXJTZXNzaW9uKVxue1xuICAgIGlmICh0aGlzLnZpc2libGUgPT09IGZhbHNlIHx8IHRoaXMuYWxwaGEgPT09IDApcmV0dXJuO1xuICAgIFxuICAgIHZhciBjb250ZXh0ID0gcmVuZGVyU2Vzc2lvbi5jb250ZXh0O1xuXG4gICAgaWYgKHRoaXMuX21hc2spXG4gICAge1xuICAgICAgICByZW5kZXJTZXNzaW9uLm1hc2tNYW5hZ2VyLnB1c2hNYXNrKHRoaXMuX21hc2ssIGNvbnRleHQpO1xuICAgIH1cblxuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XG4gICAgXG4gICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMud29ybGRUcmFuc2Zvcm07XG5cbiAgICB2YXIgaSxqO1xuXG4gICAgY29udGV4dC5zZXRUcmFuc2Zvcm0odHJhbnNmb3JtLmEsIHRyYW5zZm9ybS5jLCB0cmFuc2Zvcm0uYiwgdHJhbnNmb3JtLmQsIHRyYW5zZm9ybS50eCAsIHRyYW5zZm9ybS50eSk7XG5cbiAgICBpZiAoIXRoaXMuX190aWxlUGF0dGVybiB8fCAgdGhpcy5yZWZyZXNoVGV4dHVyZSlcbiAgICB7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVUaWxpbmdUZXh0dXJlKGZhbHNlKTtcbiAgICBcbiAgICAgICAgaWYgKHRoaXMudGlsaW5nVGV4dHVyZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fX3RpbGVQYXR0ZXJuID0gY29udGV4dC5jcmVhdGVQYXR0ZXJuKHRoaXMudGlsaW5nVGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsICdyZXBlYXQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGJsZW5kIG1vZGVcbiAgICBpZiAodGhpcy5ibGVuZE1vZGUgIT09IHJlbmRlclNlc3Npb24uY3VycmVudEJsZW5kTW9kZSlcbiAgICB7XG4gICAgICAgIHJlbmRlclNlc3Npb24uY3VycmVudEJsZW5kTW9kZSA9IHRoaXMuYmxlbmRNb2RlO1xuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tyZW5kZXJTZXNzaW9uLmN1cnJlbnRCbGVuZE1vZGVdO1xuICAgIH1cblxuICAgIHZhciB0aWxlUG9zaXRpb24gPSB0aGlzLnRpbGVQb3NpdGlvbjtcbiAgICB2YXIgdGlsZVNjYWxlID0gdGhpcy50aWxlU2NhbGU7XG5cbiAgICB0aWxlUG9zaXRpb24ueCAlPSB0aGlzLnRpbGluZ1RleHR1cmUuYmFzZVRleHR1cmUud2lkdGg7XG4gICAgdGlsZVBvc2l0aW9uLnkgJT0gdGhpcy50aWxpbmdUZXh0dXJlLmJhc2VUZXh0dXJlLmhlaWdodDtcblxuICAgIC8vIG9mZnNldFxuICAgIGNvbnRleHQuc2NhbGUodGlsZVNjYWxlLngsdGlsZVNjYWxlLnkpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKHRpbGVQb3NpdGlvbi54LCB0aWxlUG9zaXRpb24ueSk7XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuX190aWxlUGF0dGVybjtcblxuICAgIC8vIG1ha2Ugc3VyZSB0byBhY2NvdW50IGZvciB0aGUgYW5jaG9yIHBvaW50Li5cbiAgICBjb250ZXh0LmZpbGxSZWN0KC10aWxlUG9zaXRpb24ueCArICh0aGlzLmFuY2hvci54ICogLXRoaXMuX3dpZHRoKSxcbiAgICAgICAgICAgICAgICAgICAgLXRpbGVQb3NpdGlvbi55ICsgKHRoaXMuYW5jaG9yLnkgKiAtdGhpcy5faGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2lkdGggLyB0aWxlU2NhbGUueCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGVpZ2h0IC8gdGlsZVNjYWxlLnkpO1xuXG4gICAgY29udGV4dC5zY2FsZSgxIC8gdGlsZVNjYWxlLngsIDEgLyB0aWxlU2NhbGUueSk7XG4gICAgY29udGV4dC50cmFuc2xhdGUoLXRpbGVQb3NpdGlvbi54LCAtdGlsZVBvc2l0aW9uLnkpO1xuXG4gICAgaWYgKHRoaXMuX21hc2spXG4gICAge1xuICAgICAgICByZW5kZXJTZXNzaW9uLm1hc2tNYW5hZ2VyLnBvcE1hc2socmVuZGVyU2Vzc2lvbi5jb250ZXh0KTtcbiAgICB9XG5cbiAgICBmb3IgKGk9MCxqPXRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpPGo7IGkrKylcbiAgICB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0uX3JlbmRlckNhbnZhcyhyZW5kZXJTZXNzaW9uKTtcbiAgICB9XG59O1xuXG5cbi8qKlxuKiBSZXR1cm5zIHRoZSBmcmFtaW5nIHJlY3RhbmdsZSBvZiB0aGUgc3ByaXRlIGFzIGEgUElYSS5SZWN0YW5nbGUgb2JqZWN0XG4qXG4qIEBtZXRob2QgZ2V0Qm91bmRzXG4qIEByZXR1cm4ge1JlY3RhbmdsZX0gdGhlIGZyYW1pbmcgcmVjdGFuZ2xlXG4qL1xuUElYSS5UaWxpbmdTcHJpdGUucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuXG4gICAgdmFyIHcwID0gd2lkdGggKiAoMS10aGlzLmFuY2hvci54KTtcbiAgICB2YXIgdzEgPSB3aWR0aCAqIC10aGlzLmFuY2hvci54O1xuXG4gICAgdmFyIGgwID0gaGVpZ2h0ICogKDEtdGhpcy5hbmNob3IueSk7XG4gICAgdmFyIGgxID0gaGVpZ2h0ICogLXRoaXMuYW5jaG9yLnk7XG5cbiAgICB2YXIgd29ybGRUcmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgdmFyIGEgPSB3b3JsZFRyYW5zZm9ybS5hO1xuICAgIHZhciBiID0gd29ybGRUcmFuc2Zvcm0uYztcbiAgICB2YXIgYyA9IHdvcmxkVHJhbnNmb3JtLmI7XG4gICAgdmFyIGQgPSB3b3JsZFRyYW5zZm9ybS5kO1xuICAgIHZhciB0eCA9IHdvcmxkVHJhbnNmb3JtLnR4O1xuICAgIHZhciB0eSA9IHdvcmxkVHJhbnNmb3JtLnR5O1xuICAgIFxuICAgIHZhciB4MSA9IGEgKiB3MSArIGMgKiBoMSArIHR4O1xuICAgIHZhciB5MSA9IGQgKiBoMSArIGIgKiB3MSArIHR5O1xuXG4gICAgdmFyIHgyID0gYSAqIHcwICsgYyAqIGgxICsgdHg7XG4gICAgdmFyIHkyID0gZCAqIGgxICsgYiAqIHcwICsgdHk7XG5cbiAgICB2YXIgeDMgPSBhICogdzAgKyBjICogaDAgKyB0eDtcbiAgICB2YXIgeTMgPSBkICogaDAgKyBiICogdzAgKyB0eTtcblxuICAgIHZhciB4NCA9ICBhICogdzEgKyBjICogaDAgKyB0eDtcbiAgICB2YXIgeTQgPSAgZCAqIGgwICsgYiAqIHcxICsgdHk7XG5cbiAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcblxuICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgdmFyIG1pblkgPSBJbmZpbml0eTtcblxuICAgIG1pblggPSB4MSA8IG1pblggPyB4MSA6IG1pblg7XG4gICAgbWluWCA9IHgyIDwgbWluWCA/IHgyIDogbWluWDtcbiAgICBtaW5YID0geDMgPCBtaW5YID8geDMgOiBtaW5YO1xuICAgIG1pblggPSB4NCA8IG1pblggPyB4NCA6IG1pblg7XG5cbiAgICBtaW5ZID0geTEgPCBtaW5ZID8geTEgOiBtaW5ZO1xuICAgIG1pblkgPSB5MiA8IG1pblkgPyB5MiA6IG1pblk7XG4gICAgbWluWSA9IHkzIDwgbWluWSA/IHkzIDogbWluWTtcbiAgICBtaW5ZID0geTQgPCBtaW5ZID8geTQgOiBtaW5ZO1xuXG4gICAgbWF4WCA9IHgxID4gbWF4WCA/IHgxIDogbWF4WDtcbiAgICBtYXhYID0geDIgPiBtYXhYID8geDIgOiBtYXhYO1xuICAgIG1heFggPSB4MyA+IG1heFggPyB4MyA6IG1heFg7XG4gICAgbWF4WCA9IHg0ID4gbWF4WCA/IHg0IDogbWF4WDtcblxuICAgIG1heFkgPSB5MSA+IG1heFkgPyB5MSA6IG1heFk7XG4gICAgbWF4WSA9IHkyID4gbWF4WSA/IHkyIDogbWF4WTtcbiAgICBtYXhZID0geTMgPiBtYXhZID8geTMgOiBtYXhZO1xuICAgIG1heFkgPSB5NCA+IG1heFkgPyB5NCA6IG1heFk7XG5cbiAgICB2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzO1xuXG4gICAgYm91bmRzLnggPSBtaW5YO1xuICAgIGJvdW5kcy53aWR0aCA9IG1heFggLSBtaW5YO1xuXG4gICAgYm91bmRzLnkgPSBtaW5ZO1xuICAgIGJvdW5kcy5oZWlnaHQgPSBtYXhZIC0gbWluWTtcblxuICAgIC8vIHN0b3JlIGEgcmVmZXJlbmNlIHNvIHRoYXQgaWYgdGhpcyBmdW5jdGlvbiBnZXRzIGNhbGxlZCBhZ2FpbiBpbiB0aGUgcmVuZGVyIGN5Y2xlIHdlIGRvIG5vdCBoYXZlIHRvIHJlY2FsY3VsYXRlXG4gICAgdGhpcy5fY3VycmVudEJvdW5kcyA9IGJvdW5kcztcblxuICAgIHJldHVybiBib3VuZHM7XG59O1xuXG5cblxuLyoqXG4gKiBXaGVuIHRoZSB0ZXh0dXJlIGlzIHVwZGF0ZWQsIHRoaXMgZXZlbnQgd2lsbCBmaXJlIHRvIHVwZGF0ZSB0aGUgc2NhbGUgYW5kIGZyYW1lXG4gKlxuICogQG1ldGhvZCBvblRleHR1cmVVcGRhdGVcbiAqIEBwYXJhbSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuUElYSS5UaWxpbmdTcHJpdGUucHJvdG90eXBlLm9uVGV4dHVyZVVwZGF0ZSA9IGZ1bmN0aW9uKClcbntcbiAgIC8vIG92ZXJyaWRpbmcgdGhlIHNwcml0ZSB2ZXJzaW9uIG9mIHRoaXMhXG59O1xuXG5cbi8qKlxuKiBcbiogQG1ldGhvZCBnZW5lcmF0ZVRpbGluZ1RleHR1cmVcbiogXG4qIEBwYXJhbSBmb3JjZVBvd2VyT2ZUd28ge0Jvb2xlYW59IFdoZXRoZXIgd2Ugd2FudCB0byBmb3JjZSB0aGUgdGV4dHVyZSB0byBiZSBhIHBvd2VyIG9mIHR3b1xuKi9cblBJWEkuVGlsaW5nU3ByaXRlLnByb3RvdHlwZS5nZW5lcmF0ZVRpbGluZ1RleHR1cmUgPSBmdW5jdGlvbihmb3JjZVBvd2VyT2ZUd28pXG57XG4gICAgaWYgKCF0aGlzLnRleHR1cmUuYmFzZVRleHR1cmUuaGFzTG9hZGVkKSByZXR1cm47XG5cbiAgICB2YXIgdGV4dHVyZSA9IHRoaXMudGV4dHVyZTtcbiAgICB2YXIgZnJhbWUgPSB0ZXh0dXJlLmZyYW1lO1xuICAgIHZhciB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0O1xuXG4gICAgLy8gIENoZWNrIHRoYXQgdGhlIGZyYW1lIGlzIHRoZSBzYW1lIHNpemUgYXMgdGhlIGJhc2UgdGV4dHVyZS5cbiAgICB2YXIgaXNGcmFtZSA9IGZyYW1lLndpZHRoICE9PSB0ZXh0dXJlLmJhc2VUZXh0dXJlLndpZHRoIHx8IGZyYW1lLmhlaWdodCAhPT0gdGV4dHVyZS5iYXNlVGV4dHVyZS5oZWlnaHQ7XG5cbiAgICB2YXIgbmV3VGV4dHVyZVJlcXVpcmVkID0gZmFsc2U7XG5cbiAgICBpZiAoIWZvcmNlUG93ZXJPZlR3bylcbiAgICB7XG4gICAgICAgIGlmIChpc0ZyYW1lKVxuICAgICAgICB7XG4gICAgICAgICAgICB0YXJnZXRXaWR0aCA9IGZyYW1lLndpZHRoO1xuICAgICAgICAgICAgdGFyZ2V0SGVpZ2h0ID0gZnJhbWUuaGVpZ2h0O1xuICAgICAgICAgICBcbiAgICAgICAgICAgIG5ld1RleHR1cmVSZXF1aXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGFyZ2V0V2lkdGggPSBQSVhJLmdldE5leHRQb3dlck9mVHdvKGZyYW1lLndpZHRoKTtcbiAgICAgICAgdGFyZ2V0SGVpZ2h0ID0gUElYSS5nZXROZXh0UG93ZXJPZlR3byhmcmFtZS5oZWlnaHQpO1xuXG4gICAgICAgIGlmIChmcmFtZS53aWR0aCAhPT0gdGFyZ2V0V2lkdGggfHwgZnJhbWUuaGVpZ2h0ICE9PSB0YXJnZXRIZWlnaHQpIG5ld1RleHR1cmVSZXF1aXJlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG5ld1RleHR1cmVSZXF1aXJlZClcbiAgICB7XG4gICAgICAgIHZhciBjYW52YXNCdWZmZXI7XG5cbiAgICAgICAgaWYgKHRoaXMudGlsaW5nVGV4dHVyZSAmJiB0aGlzLnRpbGluZ1RleHR1cmUuaXNUaWxpbmcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNhbnZhc0J1ZmZlciA9IHRoaXMudGlsaW5nVGV4dHVyZS5jYW52YXNCdWZmZXI7XG4gICAgICAgICAgICBjYW52YXNCdWZmZXIucmVzaXplKHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy50aWxpbmdUZXh0dXJlLmJhc2VUZXh0dXJlLndpZHRoID0gdGFyZ2V0V2lkdGg7XG4gICAgICAgICAgICB0aGlzLnRpbGluZ1RleHR1cmUuYmFzZVRleHR1cmUuaGVpZ2h0ID0gdGFyZ2V0SGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy50aWxpbmdUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNhbnZhc0J1ZmZlciA9IG5ldyBQSVhJLkNhbnZhc0J1ZmZlcih0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0KTtcblxuICAgICAgICAgICAgdGhpcy50aWxpbmdUZXh0dXJlID0gUElYSS5UZXh0dXJlLmZyb21DYW52YXMoY2FudmFzQnVmZmVyLmNhbnZhcyk7XG4gICAgICAgICAgICB0aGlzLnRpbGluZ1RleHR1cmUuY2FudmFzQnVmZmVyID0gY2FudmFzQnVmZmVyO1xuICAgICAgICAgICAgdGhpcy50aWxpbmdUZXh0dXJlLmlzVGlsaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbnZhc0J1ZmZlci5jb250ZXh0LmRyYXdJbWFnZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmNyb3AueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmNyb3AueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmNyb3Aud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5jcm9wLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SGVpZ2h0KTtcblxuICAgICAgICB0aGlzLnRpbGVTY2FsZU9mZnNldC54ID0gZnJhbWUud2lkdGggLyB0YXJnZXRXaWR0aDtcbiAgICAgICAgdGhpcy50aWxlU2NhbGVPZmZzZXQueSA9IGZyYW1lLmhlaWdodCAvIHRhcmdldEhlaWdodDtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgLy8gIFRPRE8gLSBzd2l0Y2hpbmc/XG4gICAgICAgIGlmICh0aGlzLnRpbGluZ1RleHR1cmUgJiYgdGhpcy50aWxpbmdUZXh0dXJlLmlzVGlsaW5nKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBkZXN0cm95IHRoZSB0aWxpbmcgdGV4dHVyZSFcbiAgICAgICAgICAgIC8vIFRPRE8gY291bGQgc3RvcmUgdGhpcyBzb21ld2hlcmU/XG4gICAgICAgICAgICB0aGlzLnRpbGluZ1RleHR1cmUuZGVzdHJveSh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGlsZVNjYWxlT2Zmc2V0LnggPSAxO1xuICAgICAgICB0aGlzLnRpbGVTY2FsZU9mZnNldC55ID0gMTtcbiAgICAgICAgdGhpcy50aWxpbmdUZXh0dXJlID0gdGV4dHVyZTtcbiAgICB9XG5cbiAgICB0aGlzLnJlZnJlc2hUZXh0dXJlID0gZmFsc2U7XG4gICAgdGhpcy50aWxpbmdUZXh0dXJlLmJhc2VUZXh0dXJlLl9wb3dlck9mMiA9IHRydWU7XG59O1xuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqIGJhc2VkIG9uIHBpeGkgaW1wYWN0IHNwaW5lIGltcGxlbWVudGF0aW9uIG1hZGUgYnkgRWVtZWxpIEtlbG9rb3JwaSAoQGVrZWxva29ycGkpIGh0dHBzOi8vZ2l0aHViLmNvbS9la2Vsb2tvcnBpXG4gKlxuICogQXdlc29tZSBKUyBydW4gdGltZSBwcm92aWRlZCBieSBFc290ZXJpY1NvZnR3YXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vRXNvdGVyaWNTb2Z0d2FyZS9zcGluZS1ydW50aW1lc1xuICpcbiAqL1xuXG4vKlxuICogQXdlc29tZSBKUyBydW4gdGltZSBwcm92aWRlZCBieSBFc290ZXJpY1NvZnR3YXJlXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL0Vzb3RlcmljU29mdHdhcmUvc3BpbmUtcnVudGltZXNcbiAqXG4gKi9cblxuXG5cbnZhciBzcGluZSA9IHt9O1xuXG5zcGluZS5Cb25lRGF0YSA9IGZ1bmN0aW9uIChuYW1lLCBwYXJlbnQpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xufTtcbnNwaW5lLkJvbmVEYXRhLnByb3RvdHlwZSA9IHtcbiAgICBsZW5ndGg6IDAsXG4gICAgeDogMCwgeTogMCxcbiAgICByb3RhdGlvbjogMCxcbiAgICBzY2FsZVg6IDEsIHNjYWxlWTogMVxufTtcblxuc3BpbmUuU2xvdERhdGEgPSBmdW5jdGlvbiAobmFtZSwgYm9uZURhdGEpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuYm9uZURhdGEgPSBib25lRGF0YTtcbn07XG5zcGluZS5TbG90RGF0YS5wcm90b3R5cGUgPSB7XG4gICAgcjogMSwgZzogMSwgYjogMSwgYTogMSxcbiAgICBhdHRhY2htZW50TmFtZTogbnVsbFxufTtcblxuc3BpbmUuQm9uZSA9IGZ1bmN0aW9uIChib25lRGF0YSwgcGFyZW50KSB7XG4gICAgdGhpcy5kYXRhID0gYm9uZURhdGE7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5zZXRUb1NldHVwUG9zZSgpO1xufTtcbnNwaW5lLkJvbmUueURvd24gPSBmYWxzZTtcbnNwaW5lLkJvbmUucHJvdG90eXBlID0ge1xuICAgIHg6IDAsIHk6IDAsXG4gICAgcm90YXRpb246IDAsXG4gICAgc2NhbGVYOiAxLCBzY2FsZVk6IDEsXG4gICAgbTAwOiAwLCBtMDE6IDAsIHdvcmxkWDogMCwgLy8gYSBiIHhcbiAgICBtMTA6IDAsIG0xMTogMCwgd29ybGRZOiAwLCAvLyBjIGQgeVxuICAgIHdvcmxkUm90YXRpb246IDAsXG4gICAgd29ybGRTY2FsZVg6IDEsIHdvcmxkU2NhbGVZOiAxLFxuICAgIHVwZGF0ZVdvcmxkVHJhbnNmb3JtOiBmdW5jdGlvbiAoZmxpcFgsIGZsaXBZKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLndvcmxkWCA9IHRoaXMueCAqIHBhcmVudC5tMDAgKyB0aGlzLnkgKiBwYXJlbnQubTAxICsgcGFyZW50LndvcmxkWDtcbiAgICAgICAgICAgIHRoaXMud29ybGRZID0gdGhpcy54ICogcGFyZW50Lm0xMCArIHRoaXMueSAqIHBhcmVudC5tMTEgKyBwYXJlbnQud29ybGRZO1xuICAgICAgICAgICAgdGhpcy53b3JsZFNjYWxlWCA9IHBhcmVudC53b3JsZFNjYWxlWCAqIHRoaXMuc2NhbGVYO1xuICAgICAgICAgICAgdGhpcy53b3JsZFNjYWxlWSA9IHBhcmVudC53b3JsZFNjYWxlWSAqIHRoaXMuc2NhbGVZO1xuICAgICAgICAgICAgdGhpcy53b3JsZFJvdGF0aW9uID0gcGFyZW50LndvcmxkUm90YXRpb24gKyB0aGlzLnJvdGF0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53b3JsZFggPSB0aGlzLng7XG4gICAgICAgICAgICB0aGlzLndvcmxkWSA9IHRoaXMueTtcbiAgICAgICAgICAgIHRoaXMud29ybGRTY2FsZVggPSB0aGlzLnNjYWxlWDtcbiAgICAgICAgICAgIHRoaXMud29ybGRTY2FsZVkgPSB0aGlzLnNjYWxlWTtcbiAgICAgICAgICAgIHRoaXMud29ybGRSb3RhdGlvbiA9IHRoaXMucm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhZGlhbnMgPSB0aGlzLndvcmxkUm90YXRpb24gKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MocmFkaWFucyk7XG4gICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbihyYWRpYW5zKTtcbiAgICAgICAgdGhpcy5tMDAgPSBjb3MgKiB0aGlzLndvcmxkU2NhbGVYO1xuICAgICAgICB0aGlzLm0xMCA9IHNpbiAqIHRoaXMud29ybGRTY2FsZVg7XG4gICAgICAgIHRoaXMubTAxID0gLXNpbiAqIHRoaXMud29ybGRTY2FsZVk7XG4gICAgICAgIHRoaXMubTExID0gY29zICogdGhpcy53b3JsZFNjYWxlWTtcbiAgICAgICAgaWYgKGZsaXBYKSB7XG4gICAgICAgICAgICB0aGlzLm0wMCA9IC10aGlzLm0wMDtcbiAgICAgICAgICAgIHRoaXMubTAxID0gLXRoaXMubTAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbGlwWSkge1xuICAgICAgICAgICAgdGhpcy5tMTAgPSAtdGhpcy5tMTA7XG4gICAgICAgICAgICB0aGlzLm0xMSA9IC10aGlzLm0xMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BpbmUuQm9uZS55RG93bikge1xuICAgICAgICAgICAgdGhpcy5tMTAgPSAtdGhpcy5tMTA7XG4gICAgICAgICAgICB0aGlzLm0xMSA9IC10aGlzLm0xMTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2V0VG9TZXR1cFBvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIHRoaXMueCA9IGRhdGEueDtcbiAgICAgICAgdGhpcy55ID0gZGF0YS55O1xuICAgICAgICB0aGlzLnJvdGF0aW9uID0gZGF0YS5yb3RhdGlvbjtcbiAgICAgICAgdGhpcy5zY2FsZVggPSBkYXRhLnNjYWxlWDtcbiAgICAgICAgdGhpcy5zY2FsZVkgPSBkYXRhLnNjYWxlWTtcbiAgICB9XG59O1xuXG5zcGluZS5TbG90ID0gZnVuY3Rpb24gKHNsb3REYXRhLCBza2VsZXRvbiwgYm9uZSkge1xuICAgIHRoaXMuZGF0YSA9IHNsb3REYXRhO1xuICAgIHRoaXMuc2tlbGV0b24gPSBza2VsZXRvbjtcbiAgICB0aGlzLmJvbmUgPSBib25lO1xuICAgIHRoaXMuc2V0VG9TZXR1cFBvc2UoKTtcbn07XG5zcGluZS5TbG90LnByb3RvdHlwZSA9IHtcbiAgICByOiAxLCBnOiAxLCBiOiAxLCBhOiAxLFxuICAgIF9hdHRhY2htZW50VGltZTogMCxcbiAgICBhdHRhY2htZW50OiBudWxsLFxuICAgIHNldEF0dGFjaG1lbnQ6IGZ1bmN0aW9uIChhdHRhY2htZW50KSB7XG4gICAgICAgIHRoaXMuYXR0YWNobWVudCA9IGF0dGFjaG1lbnQ7XG4gICAgICAgIHRoaXMuX2F0dGFjaG1lbnRUaW1lID0gdGhpcy5za2VsZXRvbi50aW1lO1xuICAgIH0sXG4gICAgc2V0QXR0YWNobWVudFRpbWU6IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIHRoaXMuX2F0dGFjaG1lbnRUaW1lID0gdGhpcy5za2VsZXRvbi50aW1lIC0gdGltZTtcbiAgICB9LFxuICAgIGdldEF0dGFjaG1lbnRUaW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNrZWxldG9uLnRpbWUgLSB0aGlzLl9hdHRhY2htZW50VGltZTtcbiAgICB9LFxuICAgIHNldFRvU2V0dXBQb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICB0aGlzLnIgPSBkYXRhLnI7XG4gICAgICAgIHRoaXMuZyA9IGRhdGEuZztcbiAgICAgICAgdGhpcy5iID0gZGF0YS5iO1xuICAgICAgICB0aGlzLmEgPSBkYXRhLmE7XG5cbiAgICAgICAgdmFyIHNsb3REYXRhcyA9IHRoaXMuc2tlbGV0b24uZGF0YS5zbG90cztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBzbG90RGF0YXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc2xvdERhdGFzW2ldID09IGRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dGFjaG1lbnQoIWRhdGEuYXR0YWNobWVudE5hbWUgPyBudWxsIDogdGhpcy5za2VsZXRvbi5nZXRBdHRhY2htZW50QnlTbG90SW5kZXgoaSwgZGF0YS5hdHRhY2htZW50TmFtZSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuc3BpbmUuU2tpbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmF0dGFjaG1lbnRzID0ge307XG59O1xuc3BpbmUuU2tpbi5wcm90b3R5cGUgPSB7XG4gICAgYWRkQXR0YWNobWVudDogZnVuY3Rpb24gKHNsb3RJbmRleCwgbmFtZSwgYXR0YWNobWVudCkge1xuICAgICAgICB0aGlzLmF0dGFjaG1lbnRzW3Nsb3RJbmRleCArIFwiOlwiICsgbmFtZV0gPSBhdHRhY2htZW50O1xuICAgIH0sXG4gICAgZ2V0QXR0YWNobWVudDogZnVuY3Rpb24gKHNsb3RJbmRleCwgbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRhY2htZW50c1tzbG90SW5kZXggKyBcIjpcIiArIG5hbWVdO1xuICAgIH0sXG4gICAgX2F0dGFjaEFsbDogZnVuY3Rpb24gKHNrZWxldG9uLCBvbGRTa2luKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvbGRTa2luLmF0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgICB2YXIgY29sb24gPSBrZXkuaW5kZXhPZihcIjpcIik7XG4gICAgICAgICAgICB2YXIgc2xvdEluZGV4ID0gcGFyc2VJbnQoa2V5LnN1YnN0cmluZygwLCBjb2xvbiksIDEwKTtcbiAgICAgICAgICAgIHZhciBuYW1lID0ga2V5LnN1YnN0cmluZyhjb2xvbiArIDEpO1xuICAgICAgICAgICAgdmFyIHNsb3QgPSBza2VsZXRvbi5zbG90c1tzbG90SW5kZXhdO1xuICAgICAgICAgICAgaWYgKHNsb3QuYXR0YWNobWVudCAmJiBzbG90LmF0dGFjaG1lbnQubmFtZSA9PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSB0aGlzLmdldEF0dGFjaG1lbnQoc2xvdEluZGV4LCBuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudCkgc2xvdC5zZXRBdHRhY2htZW50KGF0dGFjaG1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuc3BpbmUuQW5pbWF0aW9uID0gZnVuY3Rpb24gKG5hbWUsIHRpbWVsaW5lcywgZHVyYXRpb24pIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudGltZWxpbmVzID0gdGltZWxpbmVzO1xuICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbn07XG5zcGluZS5BbmltYXRpb24ucHJvdG90eXBlID0ge1xuICAgIGFwcGx5OiBmdW5jdGlvbiAoc2tlbGV0b24sIHRpbWUsIGxvb3ApIHtcbiAgICAgICAgaWYgKGxvb3AgJiYgdGhpcy5kdXJhdGlvbikgdGltZSAlPSB0aGlzLmR1cmF0aW9uO1xuICAgICAgICB2YXIgdGltZWxpbmVzID0gdGhpcy50aW1lbGluZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGltZWxpbmVzLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAgICAgIHRpbWVsaW5lc1tpXS5hcHBseShza2VsZXRvbiwgdGltZSwgMSk7XG4gICAgfSxcbiAgICBtaXg6IGZ1bmN0aW9uIChza2VsZXRvbiwgdGltZSwgbG9vcCwgYWxwaGEpIHtcbiAgICAgICAgaWYgKGxvb3AgJiYgdGhpcy5kdXJhdGlvbikgdGltZSAlPSB0aGlzLmR1cmF0aW9uO1xuICAgICAgICB2YXIgdGltZWxpbmVzID0gdGhpcy50aW1lbGluZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGltZWxpbmVzLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAgICAgIHRpbWVsaW5lc1tpXS5hcHBseShza2VsZXRvbiwgdGltZSwgYWxwaGEpO1xuICAgIH1cbn07XG5cbnNwaW5lLmJpbmFyeVNlYXJjaCA9IGZ1bmN0aW9uICh2YWx1ZXMsIHRhcmdldCwgc3RlcCkge1xuICAgIHZhciBsb3cgPSAwO1xuICAgIHZhciBoaWdoID0gTWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoIC8gc3RlcCkgLSAyO1xuICAgIGlmICghaGlnaCkgcmV0dXJuIHN0ZXA7XG4gICAgdmFyIGN1cnJlbnQgPSBoaWdoID4+PiAxO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmICh2YWx1ZXNbKGN1cnJlbnQgKyAxKSAqIHN0ZXBdIDw9IHRhcmdldClcbiAgICAgICAgICAgIGxvdyA9IGN1cnJlbnQgKyAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBoaWdoID0gY3VycmVudDtcbiAgICAgICAgaWYgKGxvdyA9PSBoaWdoKSByZXR1cm4gKGxvdyArIDEpICogc3RlcDtcbiAgICAgICAgY3VycmVudCA9IChsb3cgKyBoaWdoKSA+Pj4gMTtcbiAgICB9XG59O1xuc3BpbmUubGluZWFyU2VhcmNoID0gZnVuY3Rpb24gKHZhbHVlcywgdGFyZ2V0LCBzdGVwKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxhc3QgPSB2YWx1ZXMubGVuZ3RoIC0gc3RlcDsgaSA8PSBsYXN0OyBpICs9IHN0ZXApXG4gICAgICAgIGlmICh2YWx1ZXNbaV0gPiB0YXJnZXQpIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbn07XG5cbnNwaW5lLkN1cnZlcyA9IGZ1bmN0aW9uIChmcmFtZUNvdW50KSB7XG4gICAgdGhpcy5jdXJ2ZXMgPSBbXTsgLy8gZGZ4LCBkZnksIGRkZngsIGRkZnksIGRkZGZ4LCBkZGRmeSwgLi4uXG4gICAgdGhpcy5jdXJ2ZXMubGVuZ3RoID0gKGZyYW1lQ291bnQgLSAxKSAqIDY7XG59O1xuc3BpbmUuQ3VydmVzLnByb3RvdHlwZSA9IHtcbiAgICBzZXRMaW5lYXI6IGZ1bmN0aW9uIChmcmFtZUluZGV4KSB7XG4gICAgICAgIHRoaXMuY3VydmVzW2ZyYW1lSW5kZXggKiA2XSA9IDAvKkxJTkVBUiovO1xuICAgIH0sXG4gICAgc2V0U3RlcHBlZDogZnVuY3Rpb24gKGZyYW1lSW5kZXgpIHtcbiAgICAgICAgdGhpcy5jdXJ2ZXNbZnJhbWVJbmRleCAqIDZdID0gLTEvKlNURVBQRUQqLztcbiAgICB9LFxuICAgIC8qKiBTZXRzIHRoZSBjb250cm9sIGhhbmRsZSBwb3NpdGlvbnMgZm9yIGFuIGludGVycG9sYXRpb24gYmV6aWVyIGN1cnZlIHVzZWQgdG8gdHJhbnNpdGlvbiBmcm9tIHRoaXMga2V5ZnJhbWUgdG8gdGhlIG5leHQuXG4gICAgICogY3gxIGFuZCBjeDIgYXJlIGZyb20gMCB0byAxLCByZXByZXNlbnRpbmcgdGhlIHBlcmNlbnQgb2YgdGltZSBiZXR3ZWVuIHRoZSB0d28ga2V5ZnJhbWVzLiBjeTEgYW5kIGN5MiBhcmUgdGhlIHBlcmNlbnQgb2ZcbiAgICAgKiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBrZXlmcmFtZSdzIHZhbHVlcy4gKi9cbiAgICBzZXRDdXJ2ZTogZnVuY3Rpb24gKGZyYW1lSW5kZXgsIGN4MSwgY3kxLCBjeDIsIGN5Mikge1xuICAgICAgICB2YXIgc3ViZGl2X3N0ZXAgPSAxIC8gMTAvKkJFWklFUl9TRUdNRU5UUyovO1xuICAgICAgICB2YXIgc3ViZGl2X3N0ZXAyID0gc3ViZGl2X3N0ZXAgKiBzdWJkaXZfc3RlcDtcbiAgICAgICAgdmFyIHN1YmRpdl9zdGVwMyA9IHN1YmRpdl9zdGVwMiAqIHN1YmRpdl9zdGVwO1xuICAgICAgICB2YXIgcHJlMSA9IDMgKiBzdWJkaXZfc3RlcDtcbiAgICAgICAgdmFyIHByZTIgPSAzICogc3ViZGl2X3N0ZXAyO1xuICAgICAgICB2YXIgcHJlNCA9IDYgKiBzdWJkaXZfc3RlcDI7XG4gICAgICAgIHZhciBwcmU1ID0gNiAqIHN1YmRpdl9zdGVwMztcbiAgICAgICAgdmFyIHRtcDF4ID0gLWN4MSAqIDIgKyBjeDI7XG4gICAgICAgIHZhciB0bXAxeSA9IC1jeTEgKiAyICsgY3kyO1xuICAgICAgICB2YXIgdG1wMnggPSAoY3gxIC0gY3gyKSAqIDMgKyAxO1xuICAgICAgICB2YXIgdG1wMnkgPSAoY3kxIC0gY3kyKSAqIDMgKyAxO1xuICAgICAgICB2YXIgaSA9IGZyYW1lSW5kZXggKiA2O1xuICAgICAgICB2YXIgY3VydmVzID0gdGhpcy5jdXJ2ZXM7XG4gICAgICAgIGN1cnZlc1tpXSA9IGN4MSAqIHByZTEgKyB0bXAxeCAqIHByZTIgKyB0bXAyeCAqIHN1YmRpdl9zdGVwMztcbiAgICAgICAgY3VydmVzW2kgKyAxXSA9IGN5MSAqIHByZTEgKyB0bXAxeSAqIHByZTIgKyB0bXAyeSAqIHN1YmRpdl9zdGVwMztcbiAgICAgICAgY3VydmVzW2kgKyAyXSA9IHRtcDF4ICogcHJlNCArIHRtcDJ4ICogcHJlNTtcbiAgICAgICAgY3VydmVzW2kgKyAzXSA9IHRtcDF5ICogcHJlNCArIHRtcDJ5ICogcHJlNTtcbiAgICAgICAgY3VydmVzW2kgKyA0XSA9IHRtcDJ4ICogcHJlNTtcbiAgICAgICAgY3VydmVzW2kgKyA1XSA9IHRtcDJ5ICogcHJlNTtcbiAgICB9LFxuICAgIGdldEN1cnZlUGVyY2VudDogZnVuY3Rpb24gKGZyYW1lSW5kZXgsIHBlcmNlbnQpIHtcbiAgICAgICAgcGVyY2VudCA9IHBlcmNlbnQgPCAwID8gMCA6IChwZXJjZW50ID4gMSA/IDEgOiBwZXJjZW50KTtcbiAgICAgICAgdmFyIGN1cnZlSW5kZXggPSBmcmFtZUluZGV4ICogNjtcbiAgICAgICAgdmFyIGN1cnZlcyA9IHRoaXMuY3VydmVzO1xuICAgICAgICB2YXIgZGZ4ID0gY3VydmVzW2N1cnZlSW5kZXhdO1xuICAgICAgICBpZiAoIWRmeC8qTElORUFSKi8pIHJldHVybiBwZXJjZW50O1xuICAgICAgICBpZiAoZGZ4ID09IC0xLypTVEVQUEVEKi8pIHJldHVybiAwO1xuICAgICAgICB2YXIgZGZ5ID0gY3VydmVzW2N1cnZlSW5kZXggKyAxXTtcbiAgICAgICAgdmFyIGRkZnggPSBjdXJ2ZXNbY3VydmVJbmRleCArIDJdO1xuICAgICAgICB2YXIgZGRmeSA9IGN1cnZlc1tjdXJ2ZUluZGV4ICsgM107XG4gICAgICAgIHZhciBkZGRmeCA9IGN1cnZlc1tjdXJ2ZUluZGV4ICsgNF07XG4gICAgICAgIHZhciBkZGRmeSA9IGN1cnZlc1tjdXJ2ZUluZGV4ICsgNV07XG4gICAgICAgIHZhciB4ID0gZGZ4LCB5ID0gZGZ5O1xuICAgICAgICB2YXIgaSA9IDEwLypCRVpJRVJfU0VHTUVOVFMqLyAtIDI7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAoeCA+PSBwZXJjZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RYID0geCAtIGRmeDtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFkgPSB5IC0gZGZ5O1xuICAgICAgICAgICAgICAgIHJldHVybiBsYXN0WSArICh5IC0gbGFzdFkpICogKHBlcmNlbnQgLSBsYXN0WCkgLyAoeCAtIGxhc3RYKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaSkgYnJlYWs7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgICBkZnggKz0gZGRmeDtcbiAgICAgICAgICAgIGRmeSArPSBkZGZ5O1xuICAgICAgICAgICAgZGRmeCArPSBkZGRmeDtcbiAgICAgICAgICAgIGRkZnkgKz0gZGRkZnk7XG4gICAgICAgICAgICB4ICs9IGRmeDtcbiAgICAgICAgICAgIHkgKz0gZGZ5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5ICsgKDEgLSB5KSAqIChwZXJjZW50IC0geCkgLyAoMSAtIHgpOyAvLyBMYXN0IHBvaW50IGlzIDEsMS5cbiAgICB9XG59O1xuXG5zcGluZS5Sb3RhdGVUaW1lbGluZSA9IGZ1bmN0aW9uIChmcmFtZUNvdW50KSB7XG4gICAgdGhpcy5jdXJ2ZXMgPSBuZXcgc3BpbmUuQ3VydmVzKGZyYW1lQ291bnQpO1xuICAgIHRoaXMuZnJhbWVzID0gW107IC8vIHRpbWUsIGFuZ2xlLCAuLi5cbiAgICB0aGlzLmZyYW1lcy5sZW5ndGggPSBmcmFtZUNvdW50ICogMjtcbn07XG5zcGluZS5Sb3RhdGVUaW1lbGluZS5wcm90b3R5cGUgPSB7XG4gICAgYm9uZUluZGV4OiAwLFxuICAgIGdldEZyYW1lQ291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhbWVzLmxlbmd0aCAvIDI7XG4gICAgfSxcbiAgICBzZXRGcmFtZTogZnVuY3Rpb24gKGZyYW1lSW5kZXgsIHRpbWUsIGFuZ2xlKSB7XG4gICAgICAgIGZyYW1lSW5kZXggKj0gMjtcbiAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleF0gPSB0aW1lO1xuICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgMV0gPSBhbmdsZTtcbiAgICB9LFxuICAgIGFwcGx5OiBmdW5jdGlvbiAoc2tlbGV0b24sIHRpbWUsIGFscGhhKSB7XG4gICAgICAgIHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcyxcbiAgICAgICAgICAgIGFtb3VudDtcblxuICAgICAgICBpZiAodGltZSA8IGZyYW1lc1swXSkgcmV0dXJuOyAvLyBUaW1lIGlzIGJlZm9yZSBmaXJzdCBmcmFtZS5cblxuICAgICAgICB2YXIgYm9uZSA9IHNrZWxldG9uLmJvbmVzW3RoaXMuYm9uZUluZGV4XTtcblxuICAgICAgICBpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDJdKSB7IC8vIFRpbWUgaXMgYWZ0ZXIgbGFzdCBmcmFtZS5cbiAgICAgICAgICAgIGFtb3VudCA9IGJvbmUuZGF0YS5yb3RhdGlvbiArIGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gMV0gLSBib25lLnJvdGF0aW9uO1xuICAgICAgICAgICAgd2hpbGUgKGFtb3VudCA+IDE4MClcbiAgICAgICAgICAgICAgICBhbW91bnQgLT0gMzYwO1xuICAgICAgICAgICAgd2hpbGUgKGFtb3VudCA8IC0xODApXG4gICAgICAgICAgICAgICAgYW1vdW50ICs9IDM2MDtcbiAgICAgICAgICAgIGJvbmUucm90YXRpb24gKz0gYW1vdW50ICogYWxwaGE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnRlcnBvbGF0ZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBmcmFtZS5cbiAgICAgICAgdmFyIGZyYW1lSW5kZXggPSBzcGluZS5iaW5hcnlTZWFyY2goZnJhbWVzLCB0aW1lLCAyKTtcbiAgICAgICAgdmFyIGxhc3RGcmFtZVZhbHVlID0gZnJhbWVzW2ZyYW1lSW5kZXggLSAxXTtcbiAgICAgICAgdmFyIGZyYW1lVGltZSA9IGZyYW1lc1tmcmFtZUluZGV4XTtcbiAgICAgICAgdmFyIHBlcmNlbnQgPSAxIC0gKHRpbWUgLSBmcmFtZVRpbWUpIC8gKGZyYW1lc1tmcmFtZUluZGV4IC0gMi8qTEFTVF9GUkFNRV9USU1FKi9dIC0gZnJhbWVUaW1lKTtcbiAgICAgICAgcGVyY2VudCA9IHRoaXMuY3VydmVzLmdldEN1cnZlUGVyY2VudChmcmFtZUluZGV4IC8gMiAtIDEsIHBlcmNlbnQpO1xuXG4gICAgICAgIGFtb3VudCA9IGZyYW1lc1tmcmFtZUluZGV4ICsgMS8qRlJBTUVfVkFMVUUqL10gLSBsYXN0RnJhbWVWYWx1ZTtcbiAgICAgICAgd2hpbGUgKGFtb3VudCA+IDE4MClcbiAgICAgICAgICAgIGFtb3VudCAtPSAzNjA7XG4gICAgICAgIHdoaWxlIChhbW91bnQgPCAtMTgwKVxuICAgICAgICAgICAgYW1vdW50ICs9IDM2MDtcbiAgICAgICAgYW1vdW50ID0gYm9uZS5kYXRhLnJvdGF0aW9uICsgKGxhc3RGcmFtZVZhbHVlICsgYW1vdW50ICogcGVyY2VudCkgLSBib25lLnJvdGF0aW9uO1xuICAgICAgICB3aGlsZSAoYW1vdW50ID4gMTgwKVxuICAgICAgICAgICAgYW1vdW50IC09IDM2MDtcbiAgICAgICAgd2hpbGUgKGFtb3VudCA8IC0xODApXG4gICAgICAgICAgICBhbW91bnQgKz0gMzYwO1xuICAgICAgICBib25lLnJvdGF0aW9uICs9IGFtb3VudCAqIGFscGhhO1xuICAgIH1cbn07XG5cbnNwaW5lLlRyYW5zbGF0ZVRpbWVsaW5lID0gZnVuY3Rpb24gKGZyYW1lQ291bnQpIHtcbiAgICB0aGlzLmN1cnZlcyA9IG5ldyBzcGluZS5DdXJ2ZXMoZnJhbWVDb3VudCk7XG4gICAgdGhpcy5mcmFtZXMgPSBbXTsgLy8gdGltZSwgeCwgeSwgLi4uXG4gICAgdGhpcy5mcmFtZXMubGVuZ3RoID0gZnJhbWVDb3VudCAqIDM7XG59O1xuc3BpbmUuVHJhbnNsYXRlVGltZWxpbmUucHJvdG90eXBlID0ge1xuICAgIGJvbmVJbmRleDogMCxcbiAgICBnZXRGcmFtZUNvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYW1lcy5sZW5ndGggLyAzO1xuICAgIH0sXG4gICAgc2V0RnJhbWU6IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCB4LCB5KSB7XG4gICAgICAgIGZyYW1lSW5kZXggKj0gMztcbiAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleF0gPSB0aW1lO1xuICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgMV0gPSB4O1xuICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgMl0gPSB5O1xuICAgIH0sXG4gICAgYXBwbHk6IGZ1bmN0aW9uIChza2VsZXRvbiwgdGltZSwgYWxwaGEpIHtcbiAgICAgICAgdmFyIGZyYW1lcyA9IHRoaXMuZnJhbWVzO1xuICAgICAgICBpZiAodGltZSA8IGZyYW1lc1swXSkgcmV0dXJuOyAvLyBUaW1lIGlzIGJlZm9yZSBmaXJzdCBmcmFtZS5cblxuICAgICAgICB2YXIgYm9uZSA9IHNrZWxldG9uLmJvbmVzW3RoaXMuYm9uZUluZGV4XTtcblxuICAgICAgICBpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDNdKSB7IC8vIFRpbWUgaXMgYWZ0ZXIgbGFzdCBmcmFtZS5cbiAgICAgICAgICAgIGJvbmUueCArPSAoYm9uZS5kYXRhLnggKyBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDJdIC0gYm9uZS54KSAqIGFscGhhO1xuICAgICAgICAgICAgYm9uZS55ICs9IChib25lLmRhdGEueSArIGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gMV0gLSBib25lLnkpICogYWxwaGE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnRlcnBvbGF0ZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBmcmFtZS5cbiAgICAgICAgdmFyIGZyYW1lSW5kZXggPSBzcGluZS5iaW5hcnlTZWFyY2goZnJhbWVzLCB0aW1lLCAzKTtcbiAgICAgICAgdmFyIGxhc3RGcmFtZVggPSBmcmFtZXNbZnJhbWVJbmRleCAtIDJdO1xuICAgICAgICB2YXIgbGFzdEZyYW1lWSA9IGZyYW1lc1tmcmFtZUluZGV4IC0gMV07XG4gICAgICAgIHZhciBmcmFtZVRpbWUgPSBmcmFtZXNbZnJhbWVJbmRleF07XG4gICAgICAgIHZhciBwZXJjZW50ID0gMSAtICh0aW1lIC0gZnJhbWVUaW1lKSAvIChmcmFtZXNbZnJhbWVJbmRleCArIC0zLypMQVNUX0ZSQU1FX1RJTUUqL10gLSBmcmFtZVRpbWUpO1xuICAgICAgICBwZXJjZW50ID0gdGhpcy5jdXJ2ZXMuZ2V0Q3VydmVQZXJjZW50KGZyYW1lSW5kZXggLyAzIC0gMSwgcGVyY2VudCk7XG5cbiAgICAgICAgYm9uZS54ICs9IChib25lLmRhdGEueCArIGxhc3RGcmFtZVggKyAoZnJhbWVzW2ZyYW1lSW5kZXggKyAxLypGUkFNRV9YKi9dIC0gbGFzdEZyYW1lWCkgKiBwZXJjZW50IC0gYm9uZS54KSAqIGFscGhhO1xuICAgICAgICBib25lLnkgKz0gKGJvbmUuZGF0YS55ICsgbGFzdEZyYW1lWSArIChmcmFtZXNbZnJhbWVJbmRleCArIDIvKkZSQU1FX1kqL10gLSBsYXN0RnJhbWVZKSAqIHBlcmNlbnQgLSBib25lLnkpICogYWxwaGE7XG4gICAgfVxufTtcblxuc3BpbmUuU2NhbGVUaW1lbGluZSA9IGZ1bmN0aW9uIChmcmFtZUNvdW50KSB7XG4gICAgdGhpcy5jdXJ2ZXMgPSBuZXcgc3BpbmUuQ3VydmVzKGZyYW1lQ291bnQpO1xuICAgIHRoaXMuZnJhbWVzID0gW107IC8vIHRpbWUsIHgsIHksIC4uLlxuICAgIHRoaXMuZnJhbWVzLmxlbmd0aCA9IGZyYW1lQ291bnQgKiAzO1xufTtcbnNwaW5lLlNjYWxlVGltZWxpbmUucHJvdG90eXBlID0ge1xuICAgIGJvbmVJbmRleDogMCxcbiAgICBnZXRGcmFtZUNvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYW1lcy5sZW5ndGggLyAzO1xuICAgIH0sXG4gICAgc2V0RnJhbWU6IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCB4LCB5KSB7XG4gICAgICAgIGZyYW1lSW5kZXggKj0gMztcbiAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleF0gPSB0aW1lO1xuICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgMV0gPSB4O1xuICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgMl0gPSB5O1xuICAgIH0sXG4gICAgYXBwbHk6IGZ1bmN0aW9uIChza2VsZXRvbiwgdGltZSwgYWxwaGEpIHtcbiAgICAgICAgdmFyIGZyYW1lcyA9IHRoaXMuZnJhbWVzO1xuICAgICAgICBpZiAodGltZSA8IGZyYW1lc1swXSkgcmV0dXJuOyAvLyBUaW1lIGlzIGJlZm9yZSBmaXJzdCBmcmFtZS5cblxuICAgICAgICB2YXIgYm9uZSA9IHNrZWxldG9uLmJvbmVzW3RoaXMuYm9uZUluZGV4XTtcblxuICAgICAgICBpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDNdKSB7IC8vIFRpbWUgaXMgYWZ0ZXIgbGFzdCBmcmFtZS5cbiAgICAgICAgICAgIGJvbmUuc2NhbGVYICs9IChib25lLmRhdGEuc2NhbGVYIC0gMSArIGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gMl0gLSBib25lLnNjYWxlWCkgKiBhbHBoYTtcbiAgICAgICAgICAgIGJvbmUuc2NhbGVZICs9IChib25lLmRhdGEuc2NhbGVZIC0gMSArIGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gMV0gLSBib25lLnNjYWxlWSkgKiBhbHBoYTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEludGVycG9sYXRlIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IGZyYW1lLlxuICAgICAgICB2YXIgZnJhbWVJbmRleCA9IHNwaW5lLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUsIDMpO1xuICAgICAgICB2YXIgbGFzdEZyYW1lWCA9IGZyYW1lc1tmcmFtZUluZGV4IC0gMl07XG4gICAgICAgIHZhciBsYXN0RnJhbWVZID0gZnJhbWVzW2ZyYW1lSW5kZXggLSAxXTtcbiAgICAgICAgdmFyIGZyYW1lVGltZSA9IGZyYW1lc1tmcmFtZUluZGV4XTtcbiAgICAgICAgdmFyIHBlcmNlbnQgPSAxIC0gKHRpbWUgLSBmcmFtZVRpbWUpIC8gKGZyYW1lc1tmcmFtZUluZGV4ICsgLTMvKkxBU1RfRlJBTUVfVElNRSovXSAtIGZyYW1lVGltZSk7XG4gICAgICAgIHBlcmNlbnQgPSB0aGlzLmN1cnZlcy5nZXRDdXJ2ZVBlcmNlbnQoZnJhbWVJbmRleCAvIDMgLSAxLCBwZXJjZW50KTtcblxuICAgICAgICBib25lLnNjYWxlWCArPSAoYm9uZS5kYXRhLnNjYWxlWCAtIDEgKyBsYXN0RnJhbWVYICsgKGZyYW1lc1tmcmFtZUluZGV4ICsgMS8qRlJBTUVfWCovXSAtIGxhc3RGcmFtZVgpICogcGVyY2VudCAtIGJvbmUuc2NhbGVYKSAqIGFscGhhO1xuICAgICAgICBib25lLnNjYWxlWSArPSAoYm9uZS5kYXRhLnNjYWxlWSAtIDEgKyBsYXN0RnJhbWVZICsgKGZyYW1lc1tmcmFtZUluZGV4ICsgMi8qRlJBTUVfWSovXSAtIGxhc3RGcmFtZVkpICogcGVyY2VudCAtIGJvbmUuc2NhbGVZKSAqIGFscGhhO1xuICAgIH1cbn07XG5cbnNwaW5lLkNvbG9yVGltZWxpbmUgPSBmdW5jdGlvbiAoZnJhbWVDb3VudCkge1xuICAgIHRoaXMuY3VydmVzID0gbmV3IHNwaW5lLkN1cnZlcyhmcmFtZUNvdW50KTtcbiAgICB0aGlzLmZyYW1lcyA9IFtdOyAvLyB0aW1lLCByLCBnLCBiLCBhLCAuLi5cbiAgICB0aGlzLmZyYW1lcy5sZW5ndGggPSBmcmFtZUNvdW50ICogNTtcbn07XG5zcGluZS5Db2xvclRpbWVsaW5lLnByb3RvdHlwZSA9IHtcbiAgICBzbG90SW5kZXg6IDAsXG4gICAgZ2V0RnJhbWVDb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFtZXMubGVuZ3RoIC8gNTtcbiAgICB9LFxuICAgIHNldEZyYW1lOiBmdW5jdGlvbiAoZnJhbWVJbmRleCwgdGltZSwgciwgZywgYiwgYSkge1xuICAgICAgICBmcmFtZUluZGV4ICo9IDU7XG4gICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcbiAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIDFdID0gcjtcbiAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIDJdID0gZztcbiAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIDNdID0gYjtcbiAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIDRdID0gYTtcbiAgICB9LFxuICAgIGFwcGx5OiBmdW5jdGlvbiAoc2tlbGV0b24sIHRpbWUsIGFscGhhKSB7XG4gICAgICAgIHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcbiAgICAgICAgaWYgKHRpbWUgPCBmcmFtZXNbMF0pIHJldHVybjsgLy8gVGltZSBpcyBiZWZvcmUgZmlyc3QgZnJhbWUuXG5cbiAgICAgICAgdmFyIHNsb3QgPSBza2VsZXRvbi5zbG90c1t0aGlzLnNsb3RJbmRleF07XG5cbiAgICAgICAgaWYgKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSA1XSkgeyAvLyBUaW1lIGlzIGFmdGVyIGxhc3QgZnJhbWUuXG4gICAgICAgICAgICB2YXIgaSA9IGZyYW1lcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgc2xvdC5yID0gZnJhbWVzW2kgLSAzXTtcbiAgICAgICAgICAgIHNsb3QuZyA9IGZyYW1lc1tpIC0gMl07XG4gICAgICAgICAgICBzbG90LmIgPSBmcmFtZXNbaSAtIDFdO1xuICAgICAgICAgICAgc2xvdC5hID0gZnJhbWVzW2ldO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW50ZXJwb2xhdGUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgZnJhbWUuXG4gICAgICAgIHZhciBmcmFtZUluZGV4ID0gc3BpbmUuYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSwgNSk7XG4gICAgICAgIHZhciBsYXN0RnJhbWVSID0gZnJhbWVzW2ZyYW1lSW5kZXggLSA0XTtcbiAgICAgICAgdmFyIGxhc3RGcmFtZUcgPSBmcmFtZXNbZnJhbWVJbmRleCAtIDNdO1xuICAgICAgICB2YXIgbGFzdEZyYW1lQiA9IGZyYW1lc1tmcmFtZUluZGV4IC0gMl07XG4gICAgICAgIHZhciBsYXN0RnJhbWVBID0gZnJhbWVzW2ZyYW1lSW5kZXggLSAxXTtcbiAgICAgICAgdmFyIGZyYW1lVGltZSA9IGZyYW1lc1tmcmFtZUluZGV4XTtcbiAgICAgICAgdmFyIHBlcmNlbnQgPSAxIC0gKHRpbWUgLSBmcmFtZVRpbWUpIC8gKGZyYW1lc1tmcmFtZUluZGV4IC0gNS8qTEFTVF9GUkFNRV9USU1FKi9dIC0gZnJhbWVUaW1lKTtcbiAgICAgICAgcGVyY2VudCA9IHRoaXMuY3VydmVzLmdldEN1cnZlUGVyY2VudChmcmFtZUluZGV4IC8gNSAtIDEsIHBlcmNlbnQpO1xuXG4gICAgICAgIHZhciByID0gbGFzdEZyYW1lUiArIChmcmFtZXNbZnJhbWVJbmRleCArIDEvKkZSQU1FX1IqL10gLSBsYXN0RnJhbWVSKSAqIHBlcmNlbnQ7XG4gICAgICAgIHZhciBnID0gbGFzdEZyYW1lRyArIChmcmFtZXNbZnJhbWVJbmRleCArIDIvKkZSQU1FX0cqL10gLSBsYXN0RnJhbWVHKSAqIHBlcmNlbnQ7XG4gICAgICAgIHZhciBiID0gbGFzdEZyYW1lQiArIChmcmFtZXNbZnJhbWVJbmRleCArIDMvKkZSQU1FX0IqL10gLSBsYXN0RnJhbWVCKSAqIHBlcmNlbnQ7XG4gICAgICAgIHZhciBhID0gbGFzdEZyYW1lQSArIChmcmFtZXNbZnJhbWVJbmRleCArIDQvKkZSQU1FX0EqL10gLSBsYXN0RnJhbWVBKSAqIHBlcmNlbnQ7XG4gICAgICAgIGlmIChhbHBoYSA8IDEpIHtcbiAgICAgICAgICAgIHNsb3QuciArPSAociAtIHNsb3QucikgKiBhbHBoYTtcbiAgICAgICAgICAgIHNsb3QuZyArPSAoZyAtIHNsb3QuZykgKiBhbHBoYTtcbiAgICAgICAgICAgIHNsb3QuYiArPSAoYiAtIHNsb3QuYikgKiBhbHBoYTtcbiAgICAgICAgICAgIHNsb3QuYSArPSAoYSAtIHNsb3QuYSkgKiBhbHBoYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNsb3QuciA9IHI7XG4gICAgICAgICAgICBzbG90LmcgPSBnO1xuICAgICAgICAgICAgc2xvdC5iID0gYjtcbiAgICAgICAgICAgIHNsb3QuYSA9IGE7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5zcGluZS5BdHRhY2htZW50VGltZWxpbmUgPSBmdW5jdGlvbiAoZnJhbWVDb3VudCkge1xuICAgIHRoaXMuY3VydmVzID0gbmV3IHNwaW5lLkN1cnZlcyhmcmFtZUNvdW50KTtcbiAgICB0aGlzLmZyYW1lcyA9IFtdOyAvLyB0aW1lLCAuLi5cbiAgICB0aGlzLmZyYW1lcy5sZW5ndGggPSBmcmFtZUNvdW50O1xuICAgIHRoaXMuYXR0YWNobWVudE5hbWVzID0gW107IC8vIHRpbWUsIC4uLlxuICAgIHRoaXMuYXR0YWNobWVudE5hbWVzLmxlbmd0aCA9IGZyYW1lQ291bnQ7XG59O1xuc3BpbmUuQXR0YWNobWVudFRpbWVsaW5lLnByb3RvdHlwZSA9IHtcbiAgICBzbG90SW5kZXg6IDAsXG4gICAgZ2V0RnJhbWVDb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJhbWVzLmxlbmd0aDtcbiAgICB9LFxuICAgIHNldEZyYW1lOiBmdW5jdGlvbiAoZnJhbWVJbmRleCwgdGltZSwgYXR0YWNobWVudE5hbWUpIHtcbiAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleF0gPSB0aW1lO1xuICAgICAgICB0aGlzLmF0dGFjaG1lbnROYW1lc1tmcmFtZUluZGV4XSA9IGF0dGFjaG1lbnROYW1lO1xuICAgIH0sXG4gICAgYXBwbHk6IGZ1bmN0aW9uIChza2VsZXRvbiwgdGltZSwgYWxwaGEpIHtcbiAgICAgICAgdmFyIGZyYW1lcyA9IHRoaXMuZnJhbWVzO1xuICAgICAgICBpZiAodGltZSA8IGZyYW1lc1swXSkgcmV0dXJuOyAvLyBUaW1lIGlzIGJlZm9yZSBmaXJzdCBmcmFtZS5cblxuICAgICAgICB2YXIgZnJhbWVJbmRleDtcbiAgICAgICAgaWYgKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSAxXSkgLy8gVGltZSBpcyBhZnRlciBsYXN0IGZyYW1lLlxuICAgICAgICAgICAgZnJhbWVJbmRleCA9IGZyYW1lcy5sZW5ndGggLSAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmcmFtZUluZGV4ID0gc3BpbmUuYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSwgMSkgLSAxO1xuXG4gICAgICAgIHZhciBhdHRhY2htZW50TmFtZSA9IHRoaXMuYXR0YWNobWVudE5hbWVzW2ZyYW1lSW5kZXhdO1xuICAgICAgICBza2VsZXRvbi5zbG90c1t0aGlzLnNsb3RJbmRleF0uc2V0QXR0YWNobWVudCghYXR0YWNobWVudE5hbWUgPyBudWxsIDogc2tlbGV0b24uZ2V0QXR0YWNobWVudEJ5U2xvdEluZGV4KHRoaXMuc2xvdEluZGV4LCBhdHRhY2htZW50TmFtZSkpO1xuICAgIH1cbn07XG5cbnNwaW5lLlNrZWxldG9uRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmJvbmVzID0gW107XG4gICAgdGhpcy5zbG90cyA9IFtdO1xuICAgIHRoaXMuc2tpbnMgPSBbXTtcbiAgICB0aGlzLmFuaW1hdGlvbnMgPSBbXTtcbn07XG5zcGluZS5Ta2VsZXRvbkRhdGEucHJvdG90eXBlID0ge1xuICAgIGRlZmF1bHRTa2luOiBudWxsLFxuICAgIC8qKiBAcmV0dXJuIE1heSBiZSBudWxsLiAqL1xuICAgIGZpbmRCb25lOiBmdW5jdGlvbiAoYm9uZU5hbWUpIHtcbiAgICAgICAgdmFyIGJvbmVzID0gdGhpcy5ib25lcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAgICAgICAgICBpZiAoYm9uZXNbaV0ubmFtZSA9PSBib25lTmFtZSkgcmV0dXJuIGJvbmVzW2ldO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIC8qKiBAcmV0dXJuIC0xIGlmIHRoZSBib25lIHdhcyBub3QgZm91bmQuICovXG4gICAgZmluZEJvbmVJbmRleDogZnVuY3Rpb24gKGJvbmVOYW1lKSB7XG4gICAgICAgIHZhciBib25lcyA9IHRoaXMuYm9uZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAgaWYgKGJvbmVzW2ldLm5hbWUgPT0gYm9uZU5hbWUpIHJldHVybiBpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSxcbiAgICAvKiogQHJldHVybiBNYXkgYmUgbnVsbC4gKi9cbiAgICBmaW5kU2xvdDogZnVuY3Rpb24gKHNsb3ROYW1lKSB7XG4gICAgICAgIHZhciBzbG90cyA9IHRoaXMuc2xvdHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc2xvdHNbaV0ubmFtZSA9PSBzbG90TmFtZSkgcmV0dXJuIHNsb3RbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICAvKiogQHJldHVybiAtMSBpZiB0aGUgYm9uZSB3YXMgbm90IGZvdW5kLiAqL1xuICAgIGZpbmRTbG90SW5kZXg6IGZ1bmN0aW9uIChzbG90TmFtZSkge1xuICAgICAgICB2YXIgc2xvdHMgPSB0aGlzLnNsb3RzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAgICAgIGlmIChzbG90c1tpXS5uYW1lID09IHNsb3ROYW1lKSByZXR1cm4gaTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0sXG4gICAgLyoqIEByZXR1cm4gTWF5IGJlIG51bGwuICovXG4gICAgZmluZFNraW46IGZ1bmN0aW9uIChza2luTmFtZSkge1xuICAgICAgICB2YXIgc2tpbnMgPSB0aGlzLnNraW5zO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNraW5zLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAgICAgIGlmIChza2luc1tpXS5uYW1lID09IHNraW5OYW1lKSByZXR1cm4gc2tpbnNbaV07XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgLyoqIEByZXR1cm4gTWF5IGJlIG51bGwuICovXG4gICAgZmluZEFuaW1hdGlvbjogZnVuY3Rpb24gKGFuaW1hdGlvbk5hbWUpIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSB0aGlzLmFuaW1hdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYW5pbWF0aW9ucy5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uc1tpXS5uYW1lID09IGFuaW1hdGlvbk5hbWUpIHJldHVybiBhbmltYXRpb25zW2ldO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5zcGluZS5Ta2VsZXRvbiA9IGZ1bmN0aW9uIChza2VsZXRvbkRhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBza2VsZXRvbkRhdGE7XG5cbiAgICB0aGlzLmJvbmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBza2VsZXRvbkRhdGEuYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBib25lRGF0YSA9IHNrZWxldG9uRGF0YS5ib25lc1tpXTtcbiAgICAgICAgdmFyIHBhcmVudCA9ICFib25lRGF0YS5wYXJlbnQgPyBudWxsIDogdGhpcy5ib25lc1tza2VsZXRvbkRhdGEuYm9uZXMuaW5kZXhPZihib25lRGF0YS5wYXJlbnQpXTtcbiAgICAgICAgdGhpcy5ib25lcy5wdXNoKG5ldyBzcGluZS5Cb25lKGJvbmVEYXRhLCBwYXJlbnQpKTtcbiAgICB9XG5cbiAgICB0aGlzLnNsb3RzID0gW107XG4gICAgdGhpcy5kcmF3T3JkZXIgPSBbXTtcbiAgICBmb3IgKGkgPSAwLCBuID0gc2tlbGV0b25EYXRhLnNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICB2YXIgc2xvdERhdGEgPSBza2VsZXRvbkRhdGEuc2xvdHNbaV07XG4gICAgICAgIHZhciBib25lID0gdGhpcy5ib25lc1tza2VsZXRvbkRhdGEuYm9uZXMuaW5kZXhPZihzbG90RGF0YS5ib25lRGF0YSldO1xuICAgICAgICB2YXIgc2xvdCA9IG5ldyBzcGluZS5TbG90KHNsb3REYXRhLCB0aGlzLCBib25lKTtcbiAgICAgICAgdGhpcy5zbG90cy5wdXNoKHNsb3QpO1xuICAgICAgICB0aGlzLmRyYXdPcmRlci5wdXNoKHNsb3QpO1xuICAgIH1cbn07XG5zcGluZS5Ta2VsZXRvbi5wcm90b3R5cGUgPSB7XG4gICAgeDogMCwgeTogMCxcbiAgICBza2luOiBudWxsLFxuICAgIHI6IDEsIGc6IDEsIGI6IDEsIGE6IDEsXG4gICAgdGltZTogMCxcbiAgICBmbGlwWDogZmFsc2UsIGZsaXBZOiBmYWxzZSxcbiAgICAvKiogVXBkYXRlcyB0aGUgd29ybGQgdHJhbnNmb3JtIGZvciBlYWNoIGJvbmUuICovXG4gICAgdXBkYXRlV29ybGRUcmFuc2Zvcm06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZsaXBYID0gdGhpcy5mbGlwWDtcbiAgICAgICAgdmFyIGZsaXBZID0gdGhpcy5mbGlwWTtcbiAgICAgICAgdmFyIGJvbmVzID0gdGhpcy5ib25lcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAgICAgICAgICBib25lc1tpXS51cGRhdGVXb3JsZFRyYW5zZm9ybShmbGlwWCwgZmxpcFkpO1xuICAgIH0sXG4gICAgLyoqIFNldHMgdGhlIGJvbmVzIGFuZCBzbG90cyB0byB0aGVpciBzZXR1cCBwb3NlIHZhbHVlcy4gKi9cbiAgICBzZXRUb1NldHVwUG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldEJvbmVzVG9TZXR1cFBvc2UoKTtcbiAgICAgICAgdGhpcy5zZXRTbG90c1RvU2V0dXBQb3NlKCk7XG4gICAgfSxcbiAgICBzZXRCb25lc1RvU2V0dXBQb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBib25lcyA9IHRoaXMuYm9uZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAgYm9uZXNbaV0uc2V0VG9TZXR1cFBvc2UoKTtcbiAgICB9LFxuICAgIHNldFNsb3RzVG9TZXR1cFBvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNsb3RzID0gdGhpcy5zbG90cztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBzbG90cy5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAgICAgICAgICBzbG90c1tpXS5zZXRUb1NldHVwUG9zZShpKTtcbiAgICB9LFxuICAgIC8qKiBAcmV0dXJuIE1heSByZXR1cm4gbnVsbC4gKi9cbiAgICBnZXRSb290Qm9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib25lcy5sZW5ndGggPyB0aGlzLmJvbmVzWzBdIDogbnVsbDtcbiAgICB9LFxuICAgIC8qKiBAcmV0dXJuIE1heSBiZSBudWxsLiAqL1xuICAgIGZpbmRCb25lOiBmdW5jdGlvbiAoYm9uZU5hbWUpIHtcbiAgICAgICAgdmFyIGJvbmVzID0gdGhpcy5ib25lcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAgICAgICAgICBpZiAoYm9uZXNbaV0uZGF0YS5uYW1lID09IGJvbmVOYW1lKSByZXR1cm4gYm9uZXNbaV07XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgLyoqIEByZXR1cm4gLTEgaWYgdGhlIGJvbmUgd2FzIG5vdCBmb3VuZC4gKi9cbiAgICBmaW5kQm9uZUluZGV4OiBmdW5jdGlvbiAoYm9uZU5hbWUpIHtcbiAgICAgICAgdmFyIGJvbmVzID0gdGhpcy5ib25lcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAgICAgICAgICBpZiAoYm9uZXNbaV0uZGF0YS5uYW1lID09IGJvbmVOYW1lKSByZXR1cm4gaTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0sXG4gICAgLyoqIEByZXR1cm4gTWF5IGJlIG51bGwuICovXG4gICAgZmluZFNsb3Q6IGZ1bmN0aW9uIChzbG90TmFtZSkge1xuICAgICAgICB2YXIgc2xvdHMgPSB0aGlzLnNsb3RzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAgICAgIGlmIChzbG90c1tpXS5kYXRhLm5hbWUgPT0gc2xvdE5hbWUpIHJldHVybiBzbG90c1tpXTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICAvKiogQHJldHVybiAtMSBpZiB0aGUgYm9uZSB3YXMgbm90IGZvdW5kLiAqL1xuICAgIGZpbmRTbG90SW5kZXg6IGZ1bmN0aW9uIChzbG90TmFtZSkge1xuICAgICAgICB2YXIgc2xvdHMgPSB0aGlzLnNsb3RzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAgICAgIGlmIChzbG90c1tpXS5kYXRhLm5hbWUgPT0gc2xvdE5hbWUpIHJldHVybiBpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSxcbiAgICBzZXRTa2luQnlOYW1lOiBmdW5jdGlvbiAoc2tpbk5hbWUpIHtcbiAgICAgICAgdmFyIHNraW4gPSB0aGlzLmRhdGEuZmluZFNraW4oc2tpbk5hbWUpO1xuICAgICAgICBpZiAoIXNraW4pIHRocm93IFwiU2tpbiBub3QgZm91bmQ6IFwiICsgc2tpbk5hbWU7XG4gICAgICAgIHRoaXMuc2V0U2tpbihza2luKTtcbiAgICB9LFxuICAgIC8qKiBTZXRzIHRoZSBza2luIHVzZWQgdG8gbG9vayB1cCBhdHRhY2htZW50cyBub3QgZm91bmQgaW4gdGhlIHtAbGluayBTa2VsZXRvbkRhdGEjZ2V0RGVmYXVsdFNraW4oKSBkZWZhdWx0IHNraW59LiBBdHRhY2htZW50c1xuICAgICAqIGZyb20gdGhlIG5ldyBza2luIGFyZSBhdHRhY2hlZCBpZiB0aGUgY29ycmVzcG9uZGluZyBhdHRhY2htZW50IGZyb20gdGhlIG9sZCBza2luIHdhcyBhdHRhY2hlZC5cbiAgICAgKiBAcGFyYW0gbmV3U2tpbiBNYXkgYmUgbnVsbC4gKi9cbiAgICBzZXRTa2luOiBmdW5jdGlvbiAobmV3U2tpbikge1xuICAgICAgICBpZiAodGhpcy5za2luICYmIG5ld1NraW4pIG5ld1NraW4uX2F0dGFjaEFsbCh0aGlzLCB0aGlzLnNraW4pO1xuICAgICAgICB0aGlzLnNraW4gPSBuZXdTa2luO1xuICAgIH0sXG4gICAgLyoqIEByZXR1cm4gTWF5IGJlIG51bGwuICovXG4gICAgZ2V0QXR0YWNobWVudEJ5U2xvdE5hbWU6IGZ1bmN0aW9uIChzbG90TmFtZSwgYXR0YWNobWVudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0YWNobWVudEJ5U2xvdEluZGV4KHRoaXMuZGF0YS5maW5kU2xvdEluZGV4KHNsb3ROYW1lKSwgYXR0YWNobWVudE5hbWUpO1xuICAgIH0sXG4gICAgLyoqIEByZXR1cm4gTWF5IGJlIG51bGwuICovXG4gICAgZ2V0QXR0YWNobWVudEJ5U2xvdEluZGV4OiBmdW5jdGlvbiAoc2xvdEluZGV4LCBhdHRhY2htZW50TmFtZSkge1xuICAgICAgICBpZiAodGhpcy5za2luKSB7XG4gICAgICAgICAgICB2YXIgYXR0YWNobWVudCA9IHRoaXMuc2tpbi5nZXRBdHRhY2htZW50KHNsb3RJbmRleCwgYXR0YWNobWVudE5hbWUpO1xuICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnQpIHJldHVybiBhdHRhY2htZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRhdGEuZGVmYXVsdFNraW4pIHJldHVybiB0aGlzLmRhdGEuZGVmYXVsdFNraW4uZ2V0QXR0YWNobWVudChzbG90SW5kZXgsIGF0dGFjaG1lbnROYW1lKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICAvKiogQHBhcmFtIGF0dGFjaG1lbnROYW1lIE1heSBiZSBudWxsLiAqL1xuICAgIHNldEF0dGFjaG1lbnQ6IGZ1bmN0aW9uIChzbG90TmFtZSwgYXR0YWNobWVudE5hbWUpIHtcbiAgICAgICAgdmFyIHNsb3RzID0gdGhpcy5zbG90cztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBzbG90cy5zaXplOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2xvdCA9IHNsb3RzW2ldO1xuICAgICAgICAgICAgaWYgKHNsb3QuZGF0YS5uYW1lID09IHNsb3ROYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50ID0gdGhpcy5nZXRBdHRhY2htZW50KGksIGF0dGFjaG1lbnROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnQgPT0gbnVsbCkgdGhyb3cgXCJBdHRhY2htZW50IG5vdCBmb3VuZDogXCIgKyBhdHRhY2htZW50TmFtZSArIFwiLCBmb3Igc2xvdDogXCIgKyBzbG90TmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2xvdC5zZXRBdHRhY2htZW50KGF0dGFjaG1lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBcIlNsb3Qgbm90IGZvdW5kOiBcIiArIHNsb3ROYW1lO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgdGltZSArPSBkZWx0YTtcbiAgICB9XG59O1xuXG5zcGluZS5BdHRhY2htZW50VHlwZSA9IHtcbiAgICByZWdpb246IDBcbn07XG5cbnNwaW5lLlJlZ2lvbkF0dGFjaG1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5vZmZzZXQgPSBbXTtcbiAgICB0aGlzLm9mZnNldC5sZW5ndGggPSA4O1xuICAgIHRoaXMudXZzID0gW107XG4gICAgdGhpcy51dnMubGVuZ3RoID0gODtcbn07XG5zcGluZS5SZWdpb25BdHRhY2htZW50LnByb3RvdHlwZSA9IHtcbiAgICB4OiAwLCB5OiAwLFxuICAgIHJvdGF0aW9uOiAwLFxuICAgIHNjYWxlWDogMSwgc2NhbGVZOiAxLFxuICAgIHdpZHRoOiAwLCBoZWlnaHQ6IDAsXG4gICAgcmVuZGVyZXJPYmplY3Q6IG51bGwsXG4gICAgcmVnaW9uT2Zmc2V0WDogMCwgcmVnaW9uT2Zmc2V0WTogMCxcbiAgICByZWdpb25XaWR0aDogMCwgcmVnaW9uSGVpZ2h0OiAwLFxuICAgIHJlZ2lvbk9yaWdpbmFsV2lkdGg6IDAsIHJlZ2lvbk9yaWdpbmFsSGVpZ2h0OiAwLFxuICAgIHNldFVWczogZnVuY3Rpb24gKHUsIHYsIHUyLCB2Miwgcm90YXRlKSB7XG4gICAgICAgIHZhciB1dnMgPSB0aGlzLnV2cztcbiAgICAgICAgaWYgKHJvdGF0ZSkge1xuICAgICAgICAgICAgdXZzWzIvKlgyKi9dID0gdTtcbiAgICAgICAgICAgIHV2c1szLypZMiovXSA9IHYyO1xuICAgICAgICAgICAgdXZzWzQvKlgzKi9dID0gdTtcbiAgICAgICAgICAgIHV2c1s1LypZMyovXSA9IHY7XG4gICAgICAgICAgICB1dnNbNi8qWDQqL10gPSB1MjtcbiAgICAgICAgICAgIHV2c1s3LypZNCovXSA9IHY7XG4gICAgICAgICAgICB1dnNbMC8qWDEqL10gPSB1MjtcbiAgICAgICAgICAgIHV2c1sxLypZMSovXSA9IHYyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXZzWzAvKlgxKi9dID0gdTtcbiAgICAgICAgICAgIHV2c1sxLypZMSovXSA9IHYyO1xuICAgICAgICAgICAgdXZzWzIvKlgyKi9dID0gdTtcbiAgICAgICAgICAgIHV2c1szLypZMiovXSA9IHY7XG4gICAgICAgICAgICB1dnNbNC8qWDMqL10gPSB1MjtcbiAgICAgICAgICAgIHV2c1s1LypZMyovXSA9IHY7XG4gICAgICAgICAgICB1dnNbNi8qWDQqL10gPSB1MjtcbiAgICAgICAgICAgIHV2c1s3LypZNCovXSA9IHYyO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB1cGRhdGVPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlZ2lvblNjYWxlWCA9IHRoaXMud2lkdGggLyB0aGlzLnJlZ2lvbk9yaWdpbmFsV2lkdGggKiB0aGlzLnNjYWxlWDtcbiAgICAgICAgdmFyIHJlZ2lvblNjYWxlWSA9IHRoaXMuaGVpZ2h0IC8gdGhpcy5yZWdpb25PcmlnaW5hbEhlaWdodCAqIHRoaXMuc2NhbGVZO1xuICAgICAgICB2YXIgbG9jYWxYID0gLXRoaXMud2lkdGggLyAyICogdGhpcy5zY2FsZVggKyB0aGlzLnJlZ2lvbk9mZnNldFggKiByZWdpb25TY2FsZVg7XG4gICAgICAgIHZhciBsb2NhbFkgPSAtdGhpcy5oZWlnaHQgLyAyICogdGhpcy5zY2FsZVkgKyB0aGlzLnJlZ2lvbk9mZnNldFkgKiByZWdpb25TY2FsZVk7XG4gICAgICAgIHZhciBsb2NhbFgyID0gbG9jYWxYICsgdGhpcy5yZWdpb25XaWR0aCAqIHJlZ2lvblNjYWxlWDtcbiAgICAgICAgdmFyIGxvY2FsWTIgPSBsb2NhbFkgKyB0aGlzLnJlZ2lvbkhlaWdodCAqIHJlZ2lvblNjYWxlWTtcbiAgICAgICAgdmFyIHJhZGlhbnMgPSB0aGlzLnJvdGF0aW9uICogTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHJhZGlhbnMpO1xuICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4ocmFkaWFucyk7XG4gICAgICAgIHZhciBsb2NhbFhDb3MgPSBsb2NhbFggKiBjb3MgKyB0aGlzLng7XG4gICAgICAgIHZhciBsb2NhbFhTaW4gPSBsb2NhbFggKiBzaW47XG4gICAgICAgIHZhciBsb2NhbFlDb3MgPSBsb2NhbFkgKiBjb3MgKyB0aGlzLnk7XG4gICAgICAgIHZhciBsb2NhbFlTaW4gPSBsb2NhbFkgKiBzaW47XG4gICAgICAgIHZhciBsb2NhbFgyQ29zID0gbG9jYWxYMiAqIGNvcyArIHRoaXMueDtcbiAgICAgICAgdmFyIGxvY2FsWDJTaW4gPSBsb2NhbFgyICogc2luO1xuICAgICAgICB2YXIgbG9jYWxZMkNvcyA9IGxvY2FsWTIgKiBjb3MgKyB0aGlzLnk7XG4gICAgICAgIHZhciBsb2NhbFkyU2luID0gbG9jYWxZMiAqIHNpbjtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBvZmZzZXRbMC8qWDEqL10gPSBsb2NhbFhDb3MgLSBsb2NhbFlTaW47XG4gICAgICAgIG9mZnNldFsxLypZMSovXSA9IGxvY2FsWUNvcyArIGxvY2FsWFNpbjtcbiAgICAgICAgb2Zmc2V0WzIvKlgyKi9dID0gbG9jYWxYQ29zIC0gbG9jYWxZMlNpbjtcbiAgICAgICAgb2Zmc2V0WzMvKlkyKi9dID0gbG9jYWxZMkNvcyArIGxvY2FsWFNpbjtcbiAgICAgICAgb2Zmc2V0WzQvKlgzKi9dID0gbG9jYWxYMkNvcyAtIGxvY2FsWTJTaW47XG4gICAgICAgIG9mZnNldFs1LypZMyovXSA9IGxvY2FsWTJDb3MgKyBsb2NhbFgyU2luO1xuICAgICAgICBvZmZzZXRbNi8qWDQqL10gPSBsb2NhbFgyQ29zIC0gbG9jYWxZU2luO1xuICAgICAgICBvZmZzZXRbNy8qWTQqL10gPSBsb2NhbFlDb3MgKyBsb2NhbFgyU2luO1xuICAgIH0sXG4gICAgY29tcHV0ZVZlcnRpY2VzOiBmdW5jdGlvbiAoeCwgeSwgYm9uZSwgdmVydGljZXMpIHtcbiAgICAgICAgeCArPSBib25lLndvcmxkWDtcbiAgICAgICAgeSArPSBib25lLndvcmxkWTtcbiAgICAgICAgdmFyIG0wMCA9IGJvbmUubTAwO1xuICAgICAgICB2YXIgbTAxID0gYm9uZS5tMDE7XG4gICAgICAgIHZhciBtMTAgPSBib25lLm0xMDtcbiAgICAgICAgdmFyIG0xMSA9IGJvbmUubTExO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIHZlcnRpY2VzWzAvKlgxKi9dID0gb2Zmc2V0WzAvKlgxKi9dICogbTAwICsgb2Zmc2V0WzEvKlkxKi9dICogbTAxICsgeDtcbiAgICAgICAgdmVydGljZXNbMS8qWTEqL10gPSBvZmZzZXRbMC8qWDEqL10gKiBtMTAgKyBvZmZzZXRbMS8qWTEqL10gKiBtMTEgKyB5O1xuICAgICAgICB2ZXJ0aWNlc1syLypYMiovXSA9IG9mZnNldFsyLypYMiovXSAqIG0wMCArIG9mZnNldFszLypZMiovXSAqIG0wMSArIHg7XG4gICAgICAgIHZlcnRpY2VzWzMvKlkyKi9dID0gb2Zmc2V0WzIvKlgyKi9dICogbTEwICsgb2Zmc2V0WzMvKlkyKi9dICogbTExICsgeTtcbiAgICAgICAgdmVydGljZXNbNC8qWDMqL10gPSBvZmZzZXRbNC8qWDMqL10gKiBtMDAgKyBvZmZzZXRbNS8qWDMqL10gKiBtMDEgKyB4O1xuICAgICAgICB2ZXJ0aWNlc1s1LypYMyovXSA9IG9mZnNldFs0LypYMyovXSAqIG0xMCArIG9mZnNldFs1LypYMyovXSAqIG0xMSArIHk7XG4gICAgICAgIHZlcnRpY2VzWzYvKlg0Ki9dID0gb2Zmc2V0WzYvKlg0Ki9dICogbTAwICsgb2Zmc2V0WzcvKlk0Ki9dICogbTAxICsgeDtcbiAgICAgICAgdmVydGljZXNbNy8qWTQqL10gPSBvZmZzZXRbNi8qWDQqL10gKiBtMTAgKyBvZmZzZXRbNy8qWTQqL10gKiBtMTEgKyB5O1xuICAgIH1cbn1cblxuc3BpbmUuQW5pbWF0aW9uU3RhdGVEYXRhID0gZnVuY3Rpb24gKHNrZWxldG9uRGF0YSkge1xuICAgIHRoaXMuc2tlbGV0b25EYXRhID0gc2tlbGV0b25EYXRhO1xuICAgIHRoaXMuYW5pbWF0aW9uVG9NaXhUaW1lID0ge307XG59O1xuc3BpbmUuQW5pbWF0aW9uU3RhdGVEYXRhLnByb3RvdHlwZSA9IHtcbiAgICAgICAgZGVmYXVsdE1peDogMCxcbiAgICBzZXRNaXhCeU5hbWU6IGZ1bmN0aW9uIChmcm9tTmFtZSwgdG9OYW1lLCBkdXJhdGlvbikge1xuICAgICAgICB2YXIgZnJvbSA9IHRoaXMuc2tlbGV0b25EYXRhLmZpbmRBbmltYXRpb24oZnJvbU5hbWUpO1xuICAgICAgICBpZiAoIWZyb20pIHRocm93IFwiQW5pbWF0aW9uIG5vdCBmb3VuZDogXCIgKyBmcm9tTmFtZTtcbiAgICAgICAgdmFyIHRvID0gdGhpcy5za2VsZXRvbkRhdGEuZmluZEFuaW1hdGlvbih0b05hbWUpO1xuICAgICAgICBpZiAoIXRvKSB0aHJvdyBcIkFuaW1hdGlvbiBub3QgZm91bmQ6IFwiICsgdG9OYW1lO1xuICAgICAgICB0aGlzLnNldE1peChmcm9tLCB0bywgZHVyYXRpb24pO1xuICAgIH0sXG4gICAgc2V0TWl4OiBmdW5jdGlvbiAoZnJvbSwgdG8sIGR1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uVG9NaXhUaW1lW2Zyb20ubmFtZSArIFwiOlwiICsgdG8ubmFtZV0gPSBkdXJhdGlvbjtcbiAgICB9LFxuICAgIGdldE1peDogZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICAgIHZhciB0aW1lID0gdGhpcy5hbmltYXRpb25Ub01peFRpbWVbZnJvbS5uYW1lICsgXCI6XCIgKyB0by5uYW1lXTtcbiAgICAgICAgICAgIHJldHVybiB0aW1lID8gdGltZSA6IHRoaXMuZGVmYXVsdE1peDtcbiAgICB9XG59O1xuXG5zcGluZS5BbmltYXRpb25TdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZURhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBzdGF0ZURhdGE7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xufTtcbnNwaW5lLkFuaW1hdGlvblN0YXRlLnByb3RvdHlwZSA9IHtcbiAgICBhbmltYXRpb25TcGVlZDogMSxcbiAgICBjdXJyZW50OiBudWxsLFxuICAgIHByZXZpb3VzOiBudWxsLFxuICAgIGN1cnJlbnRUaW1lOiAwLFxuICAgIHByZXZpb3VzVGltZTogMCxcbiAgICBjdXJyZW50TG9vcDogZmFsc2UsXG4gICAgcHJldmlvdXNMb29wOiBmYWxzZSxcbiAgICBtaXhUaW1lOiAwLFxuICAgIG1peER1cmF0aW9uOiAwLFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUgKz0gKGRlbHRhICogdGhpcy5hbmltYXRpb25TcGVlZCk7IC8vdGltZVNjYWxlOiBNdWx0aXBseSBkZWx0YSBieSB0aGUgc3BlZWQgb2YgYW5pbWF0aW9uIHJlcXVpcmVkLlxuICAgICAgICB0aGlzLnByZXZpb3VzVGltZSArPSBkZWx0YTtcbiAgICAgICAgdGhpcy5taXhUaW1lICs9IGRlbHRhO1xuXG4gICAgICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMucXVldWVbMF07XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50VGltZSA+PSBlbnRyeS5kZWxheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEFuaW1hdGlvbihlbnRyeS5hbmltYXRpb24sIGVudHJ5Lmxvb3ApO1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgYXBwbHk6IGZ1bmN0aW9uIChza2VsZXRvbikge1xuICAgICAgICBpZiAoIXRoaXMuY3VycmVudCkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5wcmV2aW91cykge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91cy5hcHBseShza2VsZXRvbiwgdGhpcy5wcmV2aW91c1RpbWUsIHRoaXMucHJldmlvdXNMb29wKTtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IHRoaXMubWl4VGltZSAvIHRoaXMubWl4RHVyYXRpb247XG4gICAgICAgICAgICBpZiAoYWxwaGEgPj0gMSkge1xuICAgICAgICAgICAgICAgIGFscGhhID0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5taXgoc2tlbGV0b24sIHRoaXMuY3VycmVudFRpbWUsIHRoaXMuY3VycmVudExvb3AsIGFscGhhKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuYXBwbHkoc2tlbGV0b24sIHRoaXMuY3VycmVudFRpbWUsIHRoaXMuY3VycmVudExvb3ApO1xuICAgIH0sXG4gICAgY2xlYXJBbmltYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMucXVldWUubGVuZ3RoID0gMDtcbiAgICB9LFxuICAgIF9zZXRBbmltYXRpb246IGZ1bmN0aW9uIChhbmltYXRpb24sIGxvb3ApIHtcbiAgICAgICAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG4gICAgICAgIGlmIChhbmltYXRpb24gJiYgdGhpcy5jdXJyZW50KSB7XG4gICAgICAgICAgICB0aGlzLm1peER1cmF0aW9uID0gdGhpcy5kYXRhLmdldE1peCh0aGlzLmN1cnJlbnQsIGFuaW1hdGlvbik7XG4gICAgICAgICAgICBpZiAodGhpcy5taXhEdXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1peFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXMgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c1RpbWUgPSB0aGlzLmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNMb29wID0gdGhpcy5jdXJyZW50TG9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnQgPSBhbmltYXRpb247XG4gICAgICAgIHRoaXMuY3VycmVudExvb3AgPSBsb29wO1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgICB9LFxuICAgIC8qKiBAc2VlICNzZXRBbmltYXRpb24oQW5pbWF0aW9uLCBCb29sZWFuKSAqL1xuICAgIHNldEFuaW1hdGlvbkJ5TmFtZTogZnVuY3Rpb24gKGFuaW1hdGlvbk5hbWUsIGxvb3ApIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuZGF0YS5za2VsZXRvbkRhdGEuZmluZEFuaW1hdGlvbihhbmltYXRpb25OYW1lKTtcbiAgICAgICAgaWYgKCFhbmltYXRpb24pIHRocm93IFwiQW5pbWF0aW9uIG5vdCBmb3VuZDogXCIgKyBhbmltYXRpb25OYW1lO1xuICAgICAgICB0aGlzLnNldEFuaW1hdGlvbihhbmltYXRpb24sIGxvb3ApO1xuICAgIH0sXG4gICAgLyoqIFNldCB0aGUgY3VycmVudCBhbmltYXRpb24uIEFueSBxdWV1ZWQgYW5pbWF0aW9ucyBhcmUgY2xlYXJlZCBhbmQgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHRpbWUgaXMgc2V0IHRvIDAuXG4gICAgICogQHBhcmFtIGFuaW1hdGlvbiBNYXkgYmUgbnVsbC4gKi9cbiAgICBzZXRBbmltYXRpb246IGZ1bmN0aW9uIChhbmltYXRpb24sIGxvb3ApIHtcbiAgICAgICAgdGhpcy5xdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9zZXRBbmltYXRpb24oYW5pbWF0aW9uLCBsb29wKTtcbiAgICB9LFxuICAgIC8qKiBAc2VlICNhZGRBbmltYXRpb24oQW5pbWF0aW9uLCBCb29sZWFuLCBOdW1iZXIpICovXG4gICAgYWRkQW5pbWF0aW9uQnlOYW1lOiBmdW5jdGlvbiAoYW5pbWF0aW9uTmFtZSwgbG9vcCwgZGVsYXkpIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuZGF0YS5za2VsZXRvbkRhdGEuZmluZEFuaW1hdGlvbihhbmltYXRpb25OYW1lKTtcbiAgICAgICAgaWYgKCFhbmltYXRpb24pIHRocm93IFwiQW5pbWF0aW9uIG5vdCBmb3VuZDogXCIgKyBhbmltYXRpb25OYW1lO1xuICAgICAgICB0aGlzLmFkZEFuaW1hdGlvbihhbmltYXRpb24sIGxvb3AsIGRlbGF5KTtcbiAgICB9LFxuICAgIC8qKiBBZGRzIGFuIGFuaW1hdGlvbiB0byBiZSBwbGF5ZWQgZGVsYXkgc2Vjb25kcyBhZnRlciB0aGUgY3VycmVudCBvciBsYXN0IHF1ZXVlZCBhbmltYXRpb24uXG4gICAgICogQHBhcmFtIGRlbGF5IE1heSBiZSA8PSAwIHRvIHVzZSBkdXJhdGlvbiBvZiBwcmV2aW91cyBhbmltYXRpb24gbWludXMgYW55IG1peCBkdXJhdGlvbiBwbHVzIHRoZSBuZWdhdGl2ZSBkZWxheS4gKi9cbiAgICBhZGRBbmltYXRpb246IGZ1bmN0aW9uIChhbmltYXRpb24sIGxvb3AsIGRlbGF5KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHt9O1xuICAgICAgICBlbnRyeS5hbmltYXRpb24gPSBhbmltYXRpb247XG4gICAgICAgIGVudHJ5Lmxvb3AgPSBsb29wO1xuXG4gICAgICAgIGlmICghZGVsYXkgfHwgZGVsYXkgPD0gMCkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzQW5pbWF0aW9uID0gdGhpcy5xdWV1ZS5sZW5ndGggPyB0aGlzLnF1ZXVlW3RoaXMucXVldWUubGVuZ3RoIC0gMV0uYW5pbWF0aW9uIDogdGhpcy5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzQW5pbWF0aW9uICE9IG51bGwpXG4gICAgICAgICAgICAgICAgZGVsYXkgPSBwcmV2aW91c0FuaW1hdGlvbi5kdXJhdGlvbiAtIHRoaXMuZGF0YS5nZXRNaXgocHJldmlvdXNBbmltYXRpb24sIGFuaW1hdGlvbikgKyAoZGVsYXkgfHwgMCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVudHJ5LmRlbGF5ID0gZGVsYXk7XG5cbiAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKGVudHJ5KTtcbiAgICB9LFxuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgbm8gYW5pbWF0aW9uIGlzIHNldCBvciBpZiB0aGUgY3VycmVudCB0aW1lIGlzIGdyZWF0ZXIgdGhhbiB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uLCByZWdhcmRsZXNzIG9mIGxvb3BpbmcuICovXG4gICAgaXNDb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY3VycmVudCB8fCB0aGlzLmN1cnJlbnRUaW1lID49IHRoaXMuY3VycmVudC5kdXJhdGlvbjtcbiAgICB9XG59O1xuXG5zcGluZS5Ta2VsZXRvbkpzb24gPSBmdW5jdGlvbiAoYXR0YWNobWVudExvYWRlcikge1xuICAgIHRoaXMuYXR0YWNobWVudExvYWRlciA9IGF0dGFjaG1lbnRMb2FkZXI7XG59O1xuc3BpbmUuU2tlbGV0b25Kc29uLnByb3RvdHlwZSA9IHtcbiAgICBzY2FsZTogMSxcbiAgICByZWFkU2tlbGV0b25EYXRhOiBmdW5jdGlvbiAocm9vdCkge1xuICAgICAgICAvKmpzaGludCAtVzA2OSovXG4gICAgICAgIHZhciBza2VsZXRvbkRhdGEgPSBuZXcgc3BpbmUuU2tlbGV0b25EYXRhKCksXG4gICAgICAgICAgICBib25lRGF0YTtcblxuICAgICAgICAvLyBCb25lcy5cbiAgICAgICAgdmFyIGJvbmVzID0gcm9vdFtcImJvbmVzXCJdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvbmVNYXAgPSBib25lc1tpXTtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGJvbmVNYXBbXCJwYXJlbnRcIl0pIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBza2VsZXRvbkRhdGEuZmluZEJvbmUoYm9uZU1hcFtcInBhcmVudFwiXSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnQpIHRocm93IFwiUGFyZW50IGJvbmUgbm90IGZvdW5kOiBcIiArIGJvbmVNYXBbXCJwYXJlbnRcIl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib25lRGF0YSA9IG5ldyBzcGluZS5Cb25lRGF0YShib25lTWFwW1wibmFtZVwiXSwgcGFyZW50KTtcbiAgICAgICAgICAgIGJvbmVEYXRhLmxlbmd0aCA9IChib25lTWFwW1wibGVuZ3RoXCJdIHx8IDApICogdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGJvbmVEYXRhLnggPSAoYm9uZU1hcFtcInhcIl0gfHwgMCkgKiB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgYm9uZURhdGEueSA9IChib25lTWFwW1wieVwiXSB8fCAwKSAqIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBib25lRGF0YS5yb3RhdGlvbiA9IChib25lTWFwW1wicm90YXRpb25cIl0gfHwgMCk7XG4gICAgICAgICAgICBib25lRGF0YS5zY2FsZVggPSBib25lTWFwW1wic2NhbGVYXCJdIHx8IDE7XG4gICAgICAgICAgICBib25lRGF0YS5zY2FsZVkgPSBib25lTWFwW1wic2NhbGVZXCJdIHx8IDE7XG4gICAgICAgICAgICBza2VsZXRvbkRhdGEuYm9uZXMucHVzaChib25lRGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTbG90cy5cbiAgICAgICAgdmFyIHNsb3RzID0gcm9vdFtcInNsb3RzXCJdO1xuICAgICAgICBmb3IgKGkgPSAwLCBuID0gc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2xvdE1hcCA9IHNsb3RzW2ldO1xuICAgICAgICAgICAgYm9uZURhdGEgPSBza2VsZXRvbkRhdGEuZmluZEJvbmUoc2xvdE1hcFtcImJvbmVcIl0pO1xuICAgICAgICAgICAgaWYgKCFib25lRGF0YSkgdGhyb3cgXCJTbG90IGJvbmUgbm90IGZvdW5kOiBcIiArIHNsb3RNYXBbXCJib25lXCJdO1xuICAgICAgICAgICAgdmFyIHNsb3REYXRhID0gbmV3IHNwaW5lLlNsb3REYXRhKHNsb3RNYXBbXCJuYW1lXCJdLCBib25lRGF0YSk7XG5cbiAgICAgICAgICAgIHZhciBjb2xvciA9IHNsb3RNYXBbXCJjb2xvclwiXTtcbiAgICAgICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgICAgIHNsb3REYXRhLnIgPSBzcGluZS5Ta2VsZXRvbkpzb24udG9Db2xvcihjb2xvciwgMCk7XG4gICAgICAgICAgICAgICAgc2xvdERhdGEuZyA9IHNwaW5lLlNrZWxldG9uSnNvbi50b0NvbG9yKGNvbG9yLCAxKTtcbiAgICAgICAgICAgICAgICBzbG90RGF0YS5iID0gc3BpbmUuU2tlbGV0b25Kc29uLnRvQ29sb3IoY29sb3IsIDIpO1xuICAgICAgICAgICAgICAgIHNsb3REYXRhLmEgPSBzcGluZS5Ta2VsZXRvbkpzb24udG9Db2xvcihjb2xvciwgMyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNsb3REYXRhLmF0dGFjaG1lbnROYW1lID0gc2xvdE1hcFtcImF0dGFjaG1lbnRcIl07XG5cbiAgICAgICAgICAgIHNrZWxldG9uRGF0YS5zbG90cy5wdXNoKHNsb3REYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNraW5zLlxuICAgICAgICB2YXIgc2tpbnMgPSByb290W1wic2tpbnNcIl07XG4gICAgICAgIGZvciAodmFyIHNraW5OYW1lIGluIHNraW5zKSB7XG4gICAgICAgICAgICBpZiAoIXNraW5zLmhhc093blByb3BlcnR5KHNraW5OYW1lKSkgY29udGludWU7XG4gICAgICAgICAgICB2YXIgc2tpbk1hcCA9IHNraW5zW3NraW5OYW1lXTtcbiAgICAgICAgICAgIHZhciBza2luID0gbmV3IHNwaW5lLlNraW4oc2tpbk5hbWUpO1xuICAgICAgICAgICAgZm9yICh2YXIgc2xvdE5hbWUgaW4gc2tpbk1hcCkge1xuICAgICAgICAgICAgICAgIGlmICghc2tpbk1hcC5oYXNPd25Qcm9wZXJ0eShzbG90TmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHZhciBzbG90SW5kZXggPSBza2VsZXRvbkRhdGEuZmluZFNsb3RJbmRleChzbG90TmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIHNsb3RFbnRyeSA9IHNraW5NYXBbc2xvdE5hbWVdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGF0dGFjaG1lbnROYW1lIGluIHNsb3RFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNsb3RFbnRyeS5oYXNPd25Qcm9wZXJ0eShhdHRhY2htZW50TmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0YWNobWVudCA9IHRoaXMucmVhZEF0dGFjaG1lbnQoc2tpbiwgYXR0YWNobWVudE5hbWUsIHNsb3RFbnRyeVthdHRhY2htZW50TmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudCAhPSBudWxsKSBza2luLmFkZEF0dGFjaG1lbnQoc2xvdEluZGV4LCBhdHRhY2htZW50TmFtZSwgYXR0YWNobWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2tlbGV0b25EYXRhLnNraW5zLnB1c2goc2tpbik7XG4gICAgICAgICAgICBpZiAoc2tpbi5uYW1lID09IFwiZGVmYXVsdFwiKSBza2VsZXRvbkRhdGEuZGVmYXVsdFNraW4gPSBza2luO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQW5pbWF0aW9ucy5cbiAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSByb290W1wiYW5pbWF0aW9uc1wiXTtcbiAgICAgICAgZm9yICh2YXIgYW5pbWF0aW9uTmFtZSBpbiBhbmltYXRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIWFuaW1hdGlvbnMuaGFzT3duUHJvcGVydHkoYW5pbWF0aW9uTmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5yZWFkQW5pbWF0aW9uKGFuaW1hdGlvbk5hbWUsIGFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV0sIHNrZWxldG9uRGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2tlbGV0b25EYXRhO1xuICAgIH0sXG4gICAgcmVhZEF0dGFjaG1lbnQ6IGZ1bmN0aW9uIChza2luLCBuYW1lLCBtYXApIHtcbiAgICAgICAgLypqc2hpbnQgLVcwNjkqL1xuICAgICAgICBuYW1lID0gbWFwW1wibmFtZVwiXSB8fCBuYW1lO1xuXG4gICAgICAgIHZhciB0eXBlID0gc3BpbmUuQXR0YWNobWVudFR5cGVbbWFwW1widHlwZVwiXSB8fCBcInJlZ2lvblwiXTtcblxuICAgICAgICBpZiAodHlwZSA9PSBzcGluZS5BdHRhY2htZW50VHlwZS5yZWdpb24pIHtcbiAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gbmV3IHNwaW5lLlJlZ2lvbkF0dGFjaG1lbnQoKTtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQueCA9IChtYXBbXCJ4XCJdIHx8IDApICogdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQueSA9IChtYXBbXCJ5XCJdIHx8IDApICogdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQuc2NhbGVYID0gbWFwW1wic2NhbGVYXCJdIHx8IDE7XG4gICAgICAgICAgICBhdHRhY2htZW50LnNjYWxlWSA9IG1hcFtcInNjYWxlWVwiXSB8fCAxO1xuICAgICAgICAgICAgYXR0YWNobWVudC5yb3RhdGlvbiA9IG1hcFtcInJvdGF0aW9uXCJdIHx8IDA7XG4gICAgICAgICAgICBhdHRhY2htZW50LndpZHRoID0gKG1hcFtcIndpZHRoXCJdIHx8IDMyKSAqIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBhdHRhY2htZW50LmhlaWdodCA9IChtYXBbXCJoZWlnaHRcIl0gfHwgMzIpICogdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQudXBkYXRlT2Zmc2V0KCk7XG5cbiAgICAgICAgICAgIGF0dGFjaG1lbnQucmVuZGVyZXJPYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQucmVuZGVyZXJPYmplY3QubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICBhdHRhY2htZW50LnJlbmRlcmVyT2JqZWN0LnNjYWxlID0ge307XG4gICAgICAgICAgICBhdHRhY2htZW50LnJlbmRlcmVyT2JqZWN0LnNjYWxlLnggPSBhdHRhY2htZW50LnNjYWxlWDtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQucmVuZGVyZXJPYmplY3Quc2NhbGUueSA9IGF0dGFjaG1lbnQuc2NhbGVZO1xuICAgICAgICAgICAgYXR0YWNobWVudC5yZW5kZXJlck9iamVjdC5yb3RhdGlvbiA9IC1hdHRhY2htZW50LnJvdGF0aW9uICogTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgICAgIHJldHVybiBhdHRhY2htZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IFwiVW5rbm93biBhdHRhY2htZW50IHR5cGU6IFwiICsgdHlwZTtcbiAgICB9LFxuXG4gICAgcmVhZEFuaW1hdGlvbjogZnVuY3Rpb24gKG5hbWUsIG1hcCwgc2tlbGV0b25EYXRhKSB7XG4gICAgICAgIC8qanNoaW50IC1XMDY5Ki9cbiAgICAgICAgdmFyIHRpbWVsaW5lcyA9IFtdO1xuICAgICAgICB2YXIgZHVyYXRpb24gPSAwO1xuICAgICAgICB2YXIgZnJhbWVJbmRleCwgdGltZWxpbmUsIHRpbWVsaW5lTmFtZSwgdmFsdWVNYXAsIHZhbHVlcyxcbiAgICAgICAgICAgIGksIG47XG5cbiAgICAgICAgdmFyIGJvbmVzID0gbWFwW1wiYm9uZXNcIl07XG4gICAgICAgIGZvciAodmFyIGJvbmVOYW1lIGluIGJvbmVzKSB7XG4gICAgICAgICAgICBpZiAoIWJvbmVzLmhhc093blByb3BlcnR5KGJvbmVOYW1lKSkgY29udGludWU7XG4gICAgICAgICAgICB2YXIgYm9uZUluZGV4ID0gc2tlbGV0b25EYXRhLmZpbmRCb25lSW5kZXgoYm9uZU5hbWUpO1xuICAgICAgICAgICAgaWYgKGJvbmVJbmRleCA9PSAtMSkgdGhyb3cgXCJCb25lIG5vdCBmb3VuZDogXCIgKyBib25lTmFtZTtcbiAgICAgICAgICAgIHZhciBib25lTWFwID0gYm9uZXNbYm9uZU5hbWVdO1xuXG4gICAgICAgICAgICBmb3IgKHRpbWVsaW5lTmFtZSBpbiBib25lTWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFib25lTWFwLmhhc093blByb3BlcnR5KHRpbWVsaW5lTmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHZhbHVlcyA9IGJvbmVNYXBbdGltZWxpbmVOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodGltZWxpbmVOYW1lID09IFwicm90YXRlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUgPSBuZXcgc3BpbmUuUm90YXRlVGltZWxpbmUodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLmJvbmVJbmRleCA9IGJvbmVJbmRleDtcblxuICAgICAgICAgICAgICAgICAgICBmcmFtZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlTWFwID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgdmFsdWVNYXBbXCJ0aW1lXCJdLCB2YWx1ZU1hcFtcImFuZ2xlXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwaW5lLlNrZWxldG9uSnNvbi5yZWFkQ3VydmUodGltZWxpbmUsIGZyYW1lSW5kZXgsIHZhbHVlTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1t0aW1lbGluZS5nZXRGcmFtZUNvdW50KCkgKiAyIC0gMl0pO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aW1lbGluZU5hbWUgPT0gXCJ0cmFuc2xhdGVcIiB8fCB0aW1lbGluZU5hbWUgPT0gXCJzY2FsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZVNjYWxlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVsaW5lTmFtZSA9PSBcInNjYWxlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZSA9IG5ldyBzcGluZS5TY2FsZVRpbWVsaW5lKHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lID0gbmV3IHNwaW5lLlRyYW5zbGF0ZVRpbWVsaW5lKHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVTY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuYm9uZUluZGV4ID0gYm9uZUluZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBuID0gdmFsdWVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVNYXAgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9ICh2YWx1ZU1hcFtcInhcIl0gfHwgMCkgKiB0aW1lbGluZVNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSAodmFsdWVNYXBbXCJ5XCJdIHx8IDApICogdGltZWxpbmVTY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgsIHZhbHVlTWFwW1widGltZVwiXSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGluZS5Ta2VsZXRvbkpzb24ucmVhZEN1cnZlKHRpbWVsaW5lLCBmcmFtZUluZGV4LCB2YWx1ZU1hcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbdGltZWxpbmUuZ2V0RnJhbWVDb3VudCgpICogMyAtIDNdKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgdGltZWxpbmUgdHlwZSBmb3IgYSBib25lOiBcIiArIHRpbWVsaW5lTmFtZSArIFwiIChcIiArIGJvbmVOYW1lICsgXCIpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNsb3RzID0gbWFwW1wic2xvdHNcIl07XG4gICAgICAgIGZvciAodmFyIHNsb3ROYW1lIGluIHNsb3RzKSB7XG4gICAgICAgICAgICBpZiAoIXNsb3RzLmhhc093blByb3BlcnR5KHNsb3ROYW1lKSkgY29udGludWU7XG4gICAgICAgICAgICB2YXIgc2xvdE1hcCA9IHNsb3RzW3Nsb3ROYW1lXTtcbiAgICAgICAgICAgIHZhciBzbG90SW5kZXggPSBza2VsZXRvbkRhdGEuZmluZFNsb3RJbmRleChzbG90TmFtZSk7XG5cbiAgICAgICAgICAgIGZvciAodGltZWxpbmVOYW1lIGluIHNsb3RNYXApIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNsb3RNYXAuaGFzT3duUHJvcGVydHkodGltZWxpbmVOYW1lKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgdmFsdWVzID0gc2xvdE1hcFt0aW1lbGluZU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lbGluZU5hbWUgPT0gXCJjb2xvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lID0gbmV3IHNwaW5lLkNvbG9yVGltZWxpbmUodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNsb3RJbmRleCA9IHNsb3RJbmRleDtcblxuICAgICAgICAgICAgICAgICAgICBmcmFtZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlTWFwID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gdmFsdWVNYXBbXCJjb2xvclwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gc3BpbmUuU2tlbGV0b25Kc29uLnRvQ29sb3IoY29sb3IsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGcgPSBzcGluZS5Ta2VsZXRvbkpzb24udG9Db2xvcihjb2xvciwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHNwaW5lLlNrZWxldG9uSnNvbi50b0NvbG9yKGNvbG9yLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gc3BpbmUuU2tlbGV0b25Kc29uLnRvQ29sb3IoY29sb3IsIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgdmFsdWVNYXBbXCJ0aW1lXCJdLCByLCBnLCBiLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwaW5lLlNrZWxldG9uSnNvbi5yZWFkQ3VydmUodGltZWxpbmUsIGZyYW1lSW5kZXgsIHZhbHVlTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1t0aW1lbGluZS5nZXRGcmFtZUNvdW50KCkgKiA1IC0gNV0pO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aW1lbGluZU5hbWUgPT0gXCJhdHRhY2htZW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUgPSBuZXcgc3BpbmUuQXR0YWNobWVudFRpbWVsaW5lKHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zbG90SW5kZXggPSBzbG90SW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgICAgZnJhbWVJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIG4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZU1hcCA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgrKywgdmFsdWVNYXBbXCJ0aW1lXCJdLCB2YWx1ZU1hcFtcIm5hbWVcIl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1t0aW1lbGluZS5nZXRGcmFtZUNvdW50KCkgLSAxXSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHRpbWVsaW5lIHR5cGUgZm9yIGEgc2xvdDogXCIgKyB0aW1lbGluZU5hbWUgKyBcIiAoXCIgKyBzbG90TmFtZSArIFwiKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNrZWxldG9uRGF0YS5hbmltYXRpb25zLnB1c2gobmV3IHNwaW5lLkFuaW1hdGlvbihuYW1lLCB0aW1lbGluZXMsIGR1cmF0aW9uKSk7XG4gICAgfVxufTtcbnNwaW5lLlNrZWxldG9uSnNvbi5yZWFkQ3VydmUgPSBmdW5jdGlvbiAodGltZWxpbmUsIGZyYW1lSW5kZXgsIHZhbHVlTWFwKSB7XG4gICAgLypqc2hpbnQgLVcwNjkqL1xuICAgIHZhciBjdXJ2ZSA9IHZhbHVlTWFwW1wiY3VydmVcIl07XG4gICAgaWYgKCFjdXJ2ZSkgcmV0dXJuO1xuICAgIGlmIChjdXJ2ZSA9PSBcInN0ZXBwZWRcIilcbiAgICAgICAgdGltZWxpbmUuY3VydmVzLnNldFN0ZXBwZWQoZnJhbWVJbmRleCk7XG4gICAgZWxzZSBpZiAoY3VydmUgaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgdGltZWxpbmUuY3VydmVzLnNldEN1cnZlKGZyYW1lSW5kZXgsIGN1cnZlWzBdLCBjdXJ2ZVsxXSwgY3VydmVbMl0sIGN1cnZlWzNdKTtcbn07XG5zcGluZS5Ta2VsZXRvbkpzb24udG9Db2xvciA9IGZ1bmN0aW9uIChoZXhTdHJpbmcsIGNvbG9ySW5kZXgpIHtcbiAgICBpZiAoaGV4U3RyaW5nLmxlbmd0aCAhPSA4KSB0aHJvdyBcIkNvbG9yIGhleGlkZWNpbWFsIGxlbmd0aCBtdXN0IGJlIDgsIHJlY2lldmVkOiBcIiArIGhleFN0cmluZztcbiAgICByZXR1cm4gcGFyc2VJbnQoaGV4U3RyaW5nLnN1YnN0cihjb2xvckluZGV4ICogMiwgMiksIDE2KSAvIDI1NTtcbn07XG5cbnNwaW5lLkF0bGFzID0gZnVuY3Rpb24gKGF0bGFzVGV4dCwgdGV4dHVyZUxvYWRlcikge1xuICAgIHRoaXMudGV4dHVyZUxvYWRlciA9IHRleHR1cmVMb2FkZXI7XG4gICAgdGhpcy5wYWdlcyA9IFtdO1xuICAgIHRoaXMucmVnaW9ucyA9IFtdO1xuXG4gICAgdmFyIHJlYWRlciA9IG5ldyBzcGluZS5BdGxhc1JlYWRlcihhdGxhc1RleHQpO1xuICAgIHZhciB0dXBsZSA9IFtdO1xuICAgIHR1cGxlLmxlbmd0aCA9IDQ7XG4gICAgdmFyIHBhZ2UgPSBudWxsO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBsaW5lID0gcmVhZGVyLnJlYWRMaW5lKCk7XG4gICAgICAgIGlmIChsaW5lID09IG51bGwpIGJyZWFrO1xuICAgICAgICBsaW5lID0gcmVhZGVyLnRyaW0obGluZSk7XG4gICAgICAgIGlmICghbGluZS5sZW5ndGgpXG4gICAgICAgICAgICBwYWdlID0gbnVsbDtcbiAgICAgICAgZWxzZSBpZiAoIXBhZ2UpIHtcbiAgICAgICAgICAgIHBhZ2UgPSBuZXcgc3BpbmUuQXRsYXNQYWdlKCk7XG4gICAgICAgICAgICBwYWdlLm5hbWUgPSBsaW5lO1xuXG4gICAgICAgICAgICBwYWdlLmZvcm1hdCA9IHNwaW5lLkF0bGFzLkZvcm1hdFtyZWFkZXIucmVhZFZhbHVlKCldO1xuXG4gICAgICAgICAgICByZWFkZXIucmVhZFR1cGxlKHR1cGxlKTtcbiAgICAgICAgICAgIHBhZ2UubWluRmlsdGVyID0gc3BpbmUuQXRsYXMuVGV4dHVyZUZpbHRlclt0dXBsZVswXV07XG4gICAgICAgICAgICBwYWdlLm1hZ0ZpbHRlciA9IHNwaW5lLkF0bGFzLlRleHR1cmVGaWx0ZXJbdHVwbGVbMV1dO1xuXG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gcmVhZGVyLnJlYWRWYWx1ZSgpO1xuICAgICAgICAgICAgcGFnZS51V3JhcCA9IHNwaW5lLkF0bGFzLlRleHR1cmVXcmFwLmNsYW1wVG9FZGdlO1xuICAgICAgICAgICAgcGFnZS52V3JhcCA9IHNwaW5lLkF0bGFzLlRleHR1cmVXcmFwLmNsYW1wVG9FZGdlO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBcInhcIilcbiAgICAgICAgICAgICAgICBwYWdlLnVXcmFwID0gc3BpbmUuQXRsYXMuVGV4dHVyZVdyYXAucmVwZWF0O1xuICAgICAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09IFwieVwiKVxuICAgICAgICAgICAgICAgIHBhZ2UudldyYXAgPSBzcGluZS5BdGxhcy5UZXh0dXJlV3JhcC5yZXBlYXQ7XG4gICAgICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT0gXCJ4eVwiKVxuICAgICAgICAgICAgICAgIHBhZ2UudVdyYXAgPSBwYWdlLnZXcmFwID0gc3BpbmUuQXRsYXMuVGV4dHVyZVdyYXAucmVwZWF0O1xuXG4gICAgICAgICAgICB0ZXh0dXJlTG9hZGVyLmxvYWQocGFnZSwgbGluZSk7XG5cbiAgICAgICAgICAgIHRoaXMucGFnZXMucHVzaChwYWdlKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlZ2lvbiA9IG5ldyBzcGluZS5BdGxhc1JlZ2lvbigpO1xuICAgICAgICAgICAgcmVnaW9uLm5hbWUgPSBsaW5lO1xuICAgICAgICAgICAgcmVnaW9uLnBhZ2UgPSBwYWdlO1xuXG4gICAgICAgICAgICByZWdpb24ucm90YXRlID0gcmVhZGVyLnJlYWRWYWx1ZSgpID09IFwidHJ1ZVwiO1xuXG4gICAgICAgICAgICByZWFkZXIucmVhZFR1cGxlKHR1cGxlKTtcbiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VJbnQodHVwbGVbMF0sIDEwKTtcbiAgICAgICAgICAgIHZhciB5ID0gcGFyc2VJbnQodHVwbGVbMV0sIDEwKTtcblxuICAgICAgICAgICAgcmVhZGVyLnJlYWRUdXBsZSh0dXBsZSk7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBwYXJzZUludCh0dXBsZVswXSwgMTApO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHBhcnNlSW50KHR1cGxlWzFdLCAxMCk7XG5cbiAgICAgICAgICAgIHJlZ2lvbi51ID0geCAvIHBhZ2Uud2lkdGg7XG4gICAgICAgICAgICByZWdpb24udiA9IHkgLyBwYWdlLmhlaWdodDtcbiAgICAgICAgICAgIGlmIChyZWdpb24ucm90YXRlKSB7XG4gICAgICAgICAgICAgICAgcmVnaW9uLnUyID0gKHggKyBoZWlnaHQpIC8gcGFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICByZWdpb24udjIgPSAoeSArIHdpZHRoKSAvIHBhZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWdpb24udTIgPSAoeCArIHdpZHRoKSAvIHBhZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgcmVnaW9uLnYyID0gKHkgKyBoZWlnaHQpIC8gcGFnZS5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWdpb24ueCA9IHg7XG4gICAgICAgICAgICByZWdpb24ueSA9IHk7XG4gICAgICAgICAgICByZWdpb24ud2lkdGggPSBNYXRoLmFicyh3aWR0aCk7XG4gICAgICAgICAgICByZWdpb24uaGVpZ2h0ID0gTWF0aC5hYnMoaGVpZ2h0KTtcblxuICAgICAgICAgICAgaWYgKHJlYWRlci5yZWFkVHVwbGUodHVwbGUpID09IDQpIHsgLy8gc3BsaXQgaXMgb3B0aW9uYWxcbiAgICAgICAgICAgICAgICByZWdpb24uc3BsaXRzID0gW3BhcnNlSW50KHR1cGxlWzBdLCAxMCksIHBhcnNlSW50KHR1cGxlWzFdLCAxMCksIHBhcnNlSW50KHR1cGxlWzJdLCAxMCksIHBhcnNlSW50KHR1cGxlWzNdLCAxMCldO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlYWRlci5yZWFkVHVwbGUodHVwbGUpID09IDQpIHsgLy8gcGFkIGlzIG9wdGlvbmFsLCBidXQgb25seSBwcmVzZW50IHdpdGggc3BsaXRzXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lvbi5wYWRzID0gW3BhcnNlSW50KHR1cGxlWzBdLCAxMCksIHBhcnNlSW50KHR1cGxlWzFdLCAxMCksIHBhcnNlSW50KHR1cGxlWzJdLCAxMCksIHBhcnNlSW50KHR1cGxlWzNdLCAxMCldO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkVHVwbGUodHVwbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVnaW9uLm9yaWdpbmFsV2lkdGggPSBwYXJzZUludCh0dXBsZVswXSwgMTApO1xuICAgICAgICAgICAgcmVnaW9uLm9yaWdpbmFsSGVpZ2h0ID0gcGFyc2VJbnQodHVwbGVbMV0sIDEwKTtcblxuICAgICAgICAgICAgcmVhZGVyLnJlYWRUdXBsZSh0dXBsZSk7XG4gICAgICAgICAgICByZWdpb24ub2Zmc2V0WCA9IHBhcnNlSW50KHR1cGxlWzBdLCAxMCk7XG4gICAgICAgICAgICByZWdpb24ub2Zmc2V0WSA9IHBhcnNlSW50KHR1cGxlWzFdLCAxMCk7XG5cbiAgICAgICAgICAgIHJlZ2lvbi5pbmRleCA9IHBhcnNlSW50KHJlYWRlci5yZWFkVmFsdWUoKSwgMTApO1xuXG4gICAgICAgICAgICB0aGlzLnJlZ2lvbnMucHVzaChyZWdpb24pO1xuICAgICAgICB9XG4gICAgfVxufTtcbnNwaW5lLkF0bGFzLnByb3RvdHlwZSA9IHtcbiAgICBmaW5kUmVnaW9uOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgcmVnaW9ucyA9IHRoaXMucmVnaW9ucztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSByZWdpb25zLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAgICAgIGlmIChyZWdpb25zW2ldLm5hbWUgPT0gbmFtZSkgcmV0dXJuIHJlZ2lvbnNbaV07XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFnZXMgPSB0aGlzLnBhZ2VzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBhZ2VzLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZUxvYWRlci51bmxvYWQocGFnZXNbaV0ucmVuZGVyZXJPYmplY3QpO1xuICAgIH0sXG4gICAgdXBkYXRlVVZzOiBmdW5jdGlvbiAocGFnZSkge1xuICAgICAgICB2YXIgcmVnaW9ucyA9IHRoaXMucmVnaW9ucztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSByZWdpb25zLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIHJlZ2lvbiA9IHJlZ2lvbnNbaV07XG4gICAgICAgICAgICBpZiAocmVnaW9uLnBhZ2UgIT0gcGFnZSkgY29udGludWU7XG4gICAgICAgICAgICByZWdpb24udSA9IHJlZ2lvbi54IC8gcGFnZS53aWR0aDtcbiAgICAgICAgICAgIHJlZ2lvbi52ID0gcmVnaW9uLnkgLyBwYWdlLmhlaWdodDtcbiAgICAgICAgICAgIGlmIChyZWdpb24ucm90YXRlKSB7XG4gICAgICAgICAgICAgICAgcmVnaW9uLnUyID0gKHJlZ2lvbi54ICsgcmVnaW9uLmhlaWdodCkgLyBwYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgIHJlZ2lvbi52MiA9IChyZWdpb24ueSArIHJlZ2lvbi53aWR0aCkgLyBwYWdlLmhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVnaW9uLnUyID0gKHJlZ2lvbi54ICsgcmVnaW9uLndpZHRoKSAvIHBhZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgcmVnaW9uLnYyID0gKHJlZ2lvbi55ICsgcmVnaW9uLmhlaWdodCkgLyBwYWdlLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnNwaW5lLkF0bGFzLkZvcm1hdCA9IHtcbiAgICBhbHBoYTogMCxcbiAgICBpbnRlbnNpdHk6IDEsXG4gICAgbHVtaW5hbmNlQWxwaGE6IDIsXG4gICAgcmdiNTY1OiAzLFxuICAgIHJnYmE0NDQ0OiA0LFxuICAgIHJnYjg4ODogNSxcbiAgICByZ2JhODg4ODogNlxufTtcblxuc3BpbmUuQXRsYXMuVGV4dHVyZUZpbHRlciA9IHtcbiAgICBuZWFyZXN0OiAwLFxuICAgIGxpbmVhcjogMSxcbiAgICBtaXBNYXA6IDIsXG4gICAgbWlwTWFwTmVhcmVzdE5lYXJlc3Q6IDMsXG4gICAgbWlwTWFwTGluZWFyTmVhcmVzdDogNCxcbiAgICBtaXBNYXBOZWFyZXN0TGluZWFyOiA1LFxuICAgIG1pcE1hcExpbmVhckxpbmVhcjogNlxufTtcblxuc3BpbmUuQXRsYXMuVGV4dHVyZVdyYXAgPSB7XG4gICAgbWlycm9yZWRSZXBlYXQ6IDAsXG4gICAgY2xhbXBUb0VkZ2U6IDEsXG4gICAgcmVwZWF0OiAyXG59O1xuXG5zcGluZS5BdGxhc1BhZ2UgPSBmdW5jdGlvbiAoKSB7fTtcbnNwaW5lLkF0bGFzUGFnZS5wcm90b3R5cGUgPSB7XG4gICAgbmFtZTogbnVsbCxcbiAgICBmb3JtYXQ6IG51bGwsXG4gICAgbWluRmlsdGVyOiBudWxsLFxuICAgIG1hZ0ZpbHRlcjogbnVsbCxcbiAgICB1V3JhcDogbnVsbCxcbiAgICB2V3JhcDogbnVsbCxcbiAgICByZW5kZXJlck9iamVjdDogbnVsbCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbn07XG5cbnNwaW5lLkF0bGFzUmVnaW9uID0gZnVuY3Rpb24gKCkge307XG5zcGluZS5BdGxhc1JlZ2lvbi5wcm90b3R5cGUgPSB7XG4gICAgcGFnZTogbnVsbCxcbiAgICBuYW1lOiBudWxsLFxuICAgIHg6IDAsIHk6IDAsXG4gICAgd2lkdGg6IDAsIGhlaWdodDogMCxcbiAgICB1OiAwLCB2OiAwLCB1MjogMCwgdjI6IDAsXG4gICAgb2Zmc2V0WDogMCwgb2Zmc2V0WTogMCxcbiAgICBvcmlnaW5hbFdpZHRoOiAwLCBvcmlnaW5hbEhlaWdodDogMCxcbiAgICBpbmRleDogMCxcbiAgICByb3RhdGU6IGZhbHNlLFxuICAgIHNwbGl0czogbnVsbCxcbiAgICBwYWRzOiBudWxsXG59O1xuXG5zcGluZS5BdGxhc1JlYWRlciA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgdGhpcy5saW5lcyA9IHRleHQuc3BsaXQoL1xcclxcbnxcXHJ8XFxuLyk7XG59O1xuc3BpbmUuQXRsYXNSZWFkZXIucHJvdG90eXBlID0ge1xuICAgIGluZGV4OiAwLFxuICAgIHRyaW06IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgXCJcIik7XG4gICAgfSxcbiAgICByZWFkTGluZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLmxpbmVzLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVzW3RoaXMuaW5kZXgrK107XG4gICAgfSxcbiAgICByZWFkVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLnJlYWRMaW5lKCk7XG4gICAgICAgIHZhciBjb2xvbiA9IGxpbmUuaW5kZXhPZihcIjpcIik7XG4gICAgICAgIGlmIChjb2xvbiA9PSAtMSkgdGhyb3cgXCJJbnZhbGlkIGxpbmU6IFwiICsgbGluZTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpbShsaW5lLnN1YnN0cmluZyhjb2xvbiArIDEpKTtcbiAgICB9LFxuICAgIC8qKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdHVwbGUgdmFsdWVzIHJlYWQgKDIgb3IgNCkuICovXG4gICAgcmVhZFR1cGxlOiBmdW5jdGlvbiAodHVwbGUpIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLnJlYWRMaW5lKCk7XG4gICAgICAgIHZhciBjb2xvbiA9IGxpbmUuaW5kZXhPZihcIjpcIik7XG4gICAgICAgIGlmIChjb2xvbiA9PSAtMSkgdGhyb3cgXCJJbnZhbGlkIGxpbmU6IFwiICsgbGluZTtcbiAgICAgICAgdmFyIGkgPSAwLCBsYXN0TWF0Y2g9IGNvbG9uICsgMTtcbiAgICAgICAgZm9yICg7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb21tYSA9IGxpbmUuaW5kZXhPZihcIixcIiwgbGFzdE1hdGNoKTtcbiAgICAgICAgICAgIGlmIChjb21tYSA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmICghaSkgdGhyb3cgXCJJbnZhbGlkIGxpbmU6IFwiICsgbGluZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR1cGxlW2ldID0gdGhpcy50cmltKGxpbmUuc3Vic3RyKGxhc3RNYXRjaCwgY29tbWEgLSBsYXN0TWF0Y2gpKTtcbiAgICAgICAgICAgIGxhc3RNYXRjaCA9IGNvbW1hICsgMTtcbiAgICAgICAgfVxuICAgICAgICB0dXBsZVtpXSA9IHRoaXMudHJpbShsaW5lLnN1YnN0cmluZyhsYXN0TWF0Y2gpKTtcbiAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgIH1cbn1cblxuc3BpbmUuQXRsYXNBdHRhY2htZW50TG9hZGVyID0gZnVuY3Rpb24gKGF0bGFzKSB7XG4gICAgdGhpcy5hdGxhcyA9IGF0bGFzO1xufVxuc3BpbmUuQXRsYXNBdHRhY2htZW50TG9hZGVyLnByb3RvdHlwZSA9IHtcbiAgICBuZXdBdHRhY2htZW50OiBmdW5jdGlvbiAoc2tpbiwgdHlwZSwgbmFtZSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBzcGluZS5BdHRhY2htZW50VHlwZS5yZWdpb246XG4gICAgICAgICAgICB2YXIgcmVnaW9uID0gdGhpcy5hdGxhcy5maW5kUmVnaW9uKG5hbWUpO1xuICAgICAgICAgICAgaWYgKCFyZWdpb24pIHRocm93IFwiUmVnaW9uIG5vdCBmb3VuZCBpbiBhdGxhczogXCIgKyBuYW1lICsgXCIgKFwiICsgdHlwZSArIFwiKVwiO1xuICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSBuZXcgc3BpbmUuUmVnaW9uQXR0YWNobWVudChuYW1lKTtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQucmVuZGVyZXJPYmplY3QgPSByZWdpb247XG4gICAgICAgICAgICBhdHRhY2htZW50LnNldFVWcyhyZWdpb24udSwgcmVnaW9uLnYsIHJlZ2lvbi51MiwgcmVnaW9uLnYyLCByZWdpb24ucm90YXRlKTtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQucmVnaW9uT2Zmc2V0WCA9IHJlZ2lvbi5vZmZzZXRYO1xuICAgICAgICAgICAgYXR0YWNobWVudC5yZWdpb25PZmZzZXRZID0gcmVnaW9uLm9mZnNldFk7XG4gICAgICAgICAgICBhdHRhY2htZW50LnJlZ2lvbldpZHRoID0gcmVnaW9uLndpZHRoO1xuICAgICAgICAgICAgYXR0YWNobWVudC5yZWdpb25IZWlnaHQgPSByZWdpb24uaGVpZ2h0O1xuICAgICAgICAgICAgYXR0YWNobWVudC5yZWdpb25PcmlnaW5hbFdpZHRoID0gcmVnaW9uLm9yaWdpbmFsV2lkdGg7XG4gICAgICAgICAgICBhdHRhY2htZW50LnJlZ2lvbk9yaWdpbmFsSGVpZ2h0ID0gcmVnaW9uLm9yaWdpbmFsSGVpZ2h0O1xuICAgICAgICAgICAgcmV0dXJuIGF0dGFjaG1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgXCJVbmtub3duIGF0dGFjaG1lbnQgdHlwZTogXCIgKyB0eXBlO1xuICAgIH1cbn1cblxuc3BpbmUuQm9uZS55RG93biA9IHRydWU7XG5QSVhJLkFuaW1DYWNoZSA9IHt9O1xuXG4vKipcbiAqIEEgY2xhc3MgdGhhdCBlbmFibGVzIHRoZSB5b3UgdG8gaW1wb3J0IGFuZCBydW4geW91ciBzcGluZSBhbmltYXRpb25zIGluIHBpeGkuXG4gKiBTcGluZSBhbmltYXRpb24gZGF0YSBuZWVkcyB0byBiZSBsb2FkZWQgdXNpbmcgdGhlIFBJWEkuQXNzZXRMb2FkZXIgb3IgUElYSS5TcGluZUxvYWRlciBiZWZvcmUgaXQgY2FuIGJlIHVzZWQgYnkgdGhpcyBjbGFzc1xuICogU2VlIGV4YW1wbGUgMTIgKGh0dHA6Ly93d3cuZ29vZGJveWRpZ2l0YWwuY29tL3BpeGlqcy9leGFtcGxlcy8xMi8pIHRvIHNlZSBhIHdvcmtpbmcgZXhhbXBsZSBhbmQgY2hlY2sgb3V0IHRoZSBzb3VyY2VcbiAqXG4gKiBAY2xhc3MgU3BpbmVcbiAqIEBleHRlbmRzIERpc3BsYXlPYmplY3RDb250YWluZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHVybCB7U3RyaW5nfSBUaGUgdXJsIG9mIHRoZSBzcGluZSBhbmltIGZpbGUgdG8gYmUgdXNlZFxuICovXG5QSVhJLlNwaW5lID0gZnVuY3Rpb24gKHVybCkge1xuICAgIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5zcGluZURhdGEgPSBQSVhJLkFuaW1DYWNoZVt1cmxdO1xuXG4gICAgaWYgKCF0aGlzLnNwaW5lRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcGluZSBkYXRhIG11c3QgYmUgcHJlbG9hZGVkIHVzaW5nIFBJWEkuU3BpbmVMb2FkZXIgb3IgUElYSS5Bc3NldExvYWRlcjogXCIgKyB1cmwpO1xuICAgIH1cblxuICAgIHRoaXMuc2tlbGV0b24gPSBuZXcgc3BpbmUuU2tlbGV0b24odGhpcy5zcGluZURhdGEpO1xuICAgIHRoaXMuc2tlbGV0b24udXBkYXRlV29ybGRUcmFuc2Zvcm0oKTtcblxuICAgIHRoaXMuc3RhdGVEYXRhID0gbmV3IHNwaW5lLkFuaW1hdGlvblN0YXRlRGF0YSh0aGlzLnNwaW5lRGF0YSk7XG4gICAgdGhpcy5zdGF0ZSA9IG5ldyBzcGluZS5BbmltYXRpb25TdGF0ZSh0aGlzLnN0YXRlRGF0YSk7XG5cbiAgICB0aGlzLnNsb3RDb250YWluZXJzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMuc2tlbGV0b24uZHJhd09yZGVyLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICB2YXIgc2xvdCA9IHRoaXMuc2tlbGV0b24uZHJhd09yZGVyW2ldO1xuICAgICAgICB2YXIgYXR0YWNobWVudCA9IHNsb3QuYXR0YWNobWVudDtcbiAgICAgICAgdmFyIHNsb3RDb250YWluZXIgPSBuZXcgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyKCk7XG4gICAgICAgIHRoaXMuc2xvdENvbnRhaW5lcnMucHVzaChzbG90Q29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5hZGRDaGlsZChzbG90Q29udGFpbmVyKTtcbiAgICAgICAgaWYgKCEoYXR0YWNobWVudCBpbnN0YW5jZW9mIHNwaW5lLlJlZ2lvbkF0dGFjaG1lbnQpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3ByaXRlTmFtZSA9IGF0dGFjaG1lbnQucmVuZGVyZXJPYmplY3QubmFtZTtcbiAgICAgICAgdmFyIHNwcml0ZSA9IHRoaXMuY3JlYXRlU3ByaXRlKHNsb3QsIGF0dGFjaG1lbnQucmVuZGVyZXJPYmplY3QpO1xuICAgICAgICBzbG90LmN1cnJlbnRTcHJpdGUgPSBzcHJpdGU7XG4gICAgICAgIHNsb3QuY3VycmVudFNwcml0ZU5hbWUgPSBzcHJpdGVOYW1lO1xuICAgICAgICBzbG90Q29udGFpbmVyLmFkZENoaWxkKHNwcml0ZSk7XG4gICAgfVxufTtcblxuUElYSS5TcGluZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUpO1xuUElYSS5TcGluZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLlNwaW5lO1xuXG4vKlxuICogVXBkYXRlcyB0aGUgb2JqZWN0IHRyYW5zZm9ybSBmb3IgcmVuZGVyaW5nXG4gKlxuICogQG1ldGhvZCB1cGRhdGVUcmFuc2Zvcm1cbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuU3BpbmUucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxhc3RUaW1lID0gdGhpcy5sYXN0VGltZSB8fCBEYXRlLm5vdygpO1xuICAgIHZhciB0aW1lRGVsdGEgPSAoRGF0ZS5ub3coKSAtIHRoaXMubGFzdFRpbWUpICogMC4wMDE7XG4gICAgdGhpcy5sYXN0VGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5zdGF0ZS51cGRhdGUodGltZURlbHRhKTtcbiAgICB0aGlzLnN0YXRlLmFwcGx5KHRoaXMuc2tlbGV0b24pO1xuICAgIHRoaXMuc2tlbGV0b24udXBkYXRlV29ybGRUcmFuc2Zvcm0oKTtcblxuICAgIHZhciBkcmF3T3JkZXIgPSB0aGlzLnNrZWxldG9uLmRyYXdPcmRlcjtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGRyYXdPcmRlci5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIHNsb3QgPSBkcmF3T3JkZXJbaV07XG4gICAgICAgIHZhciBhdHRhY2htZW50ID0gc2xvdC5hdHRhY2htZW50O1xuICAgICAgICB2YXIgc2xvdENvbnRhaW5lciA9IHRoaXMuc2xvdENvbnRhaW5lcnNbaV07XG4gICAgICAgIGlmICghKGF0dGFjaG1lbnQgaW5zdGFuY2VvZiBzcGluZS5SZWdpb25BdHRhY2htZW50KSkge1xuICAgICAgICAgICAgc2xvdENvbnRhaW5lci52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdHRhY2htZW50LnJlbmRlcmVyT2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoIXNsb3QuY3VycmVudFNwcml0ZU5hbWUgfHwgc2xvdC5jdXJyZW50U3ByaXRlTmFtZSAhPSBhdHRhY2htZW50Lm5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ByaXRlTmFtZSA9IGF0dGFjaG1lbnQucmVuZGVyZXJPYmplY3QubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoc2xvdC5jdXJyZW50U3ByaXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2xvdC5jdXJyZW50U3ByaXRlLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2xvdC5zcHJpdGVzID0gc2xvdC5zcHJpdGVzIHx8IHt9O1xuICAgICAgICAgICAgICAgIGlmIChzbG90LnNwcml0ZXNbc3ByaXRlTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzbG90LnNwcml0ZXNbc3ByaXRlTmFtZV0udmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwcml0ZSA9IHRoaXMuY3JlYXRlU3ByaXRlKHNsb3QsIGF0dGFjaG1lbnQucmVuZGVyZXJPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICBzbG90Q29udGFpbmVyLmFkZENoaWxkKHNwcml0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNsb3QuY3VycmVudFNwcml0ZSA9IHNsb3Quc3ByaXRlc1tzcHJpdGVOYW1lXTtcbiAgICAgICAgICAgICAgICBzbG90LmN1cnJlbnRTcHJpdGVOYW1lID0gc3ByaXRlTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzbG90Q29udGFpbmVyLnZpc2libGUgPSB0cnVlO1xuXG4gICAgICAgIHZhciBib25lID0gc2xvdC5ib25lO1xuXG4gICAgICAgIHNsb3RDb250YWluZXIucG9zaXRpb24ueCA9IGJvbmUud29ybGRYICsgYXR0YWNobWVudC54ICogYm9uZS5tMDAgKyBhdHRhY2htZW50LnkgKiBib25lLm0wMTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5wb3NpdGlvbi55ID0gYm9uZS53b3JsZFkgKyBhdHRhY2htZW50LnggKiBib25lLm0xMCArIGF0dGFjaG1lbnQueSAqIGJvbmUubTExO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNjYWxlLnggPSBib25lLndvcmxkU2NhbGVYO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNjYWxlLnkgPSBib25lLndvcmxkU2NhbGVZO1xuXG4gICAgICAgIHNsb3RDb250YWluZXIucm90YXRpb24gPSAtKHNsb3QuYm9uZS53b3JsZFJvdGF0aW9uICogTWF0aC5QSSAvIDE4MCk7XG5cbiAgICAgICAgc2xvdENvbnRhaW5lci5hbHBoYSA9IHNsb3QuYTtcbiAgICAgICAgc2xvdC5jdXJyZW50U3ByaXRlLnRpbnQgPSBQSVhJLnJnYjJoZXgoW3Nsb3QucixzbG90Lmcsc2xvdC5iXSk7XG4gICAgfVxuXG4gICAgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0uY2FsbCh0aGlzKTtcbn07XG5cblxuUElYSS5TcGluZS5wcm90b3R5cGUuY3JlYXRlU3ByaXRlID0gZnVuY3Rpb24gKHNsb3QsIGRlc2NyaXB0b3IpIHtcbiAgICB2YXIgbmFtZSA9IFBJWEkuVGV4dHVyZUNhY2hlW2Rlc2NyaXB0b3IubmFtZV0gPyBkZXNjcmlwdG9yLm5hbWUgOiBkZXNjcmlwdG9yLm5hbWUgKyBcIi5wbmdcIjtcbiAgICB2YXIgc3ByaXRlID0gbmV3IFBJWEkuU3ByaXRlKFBJWEkuVGV4dHVyZS5mcm9tRnJhbWUobmFtZSkpO1xuICAgIHNwcml0ZS5zY2FsZSA9IGRlc2NyaXB0b3Iuc2NhbGU7XG4gICAgc3ByaXRlLnJvdGF0aW9uID0gZGVzY3JpcHRvci5yb3RhdGlvbjtcbiAgICBzcHJpdGUuYW5jaG9yLnggPSBzcHJpdGUuYW5jaG9yLnkgPSAwLjU7XG5cbiAgICBzbG90LnNwcml0ZXMgPSBzbG90LnNwcml0ZXMgfHwge307XG4gICAgc2xvdC5zcHJpdGVzW2Rlc2NyaXB0b3IubmFtZV0gPSBzcHJpdGU7XG4gICAgcmV0dXJuIHNwcml0ZTtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuUElYSS5CYXNlVGV4dHVyZUNhY2hlID0ge307XG5QSVhJLnRleHR1cmVzVG9VcGRhdGUgPSBbXTtcblBJWEkudGV4dHVyZXNUb0Rlc3Ryb3kgPSBbXTtcblxuUElYSS5CYXNlVGV4dHVyZUNhY2hlSWRHZW5lcmF0b3IgPSAwO1xuXG4vKipcbiAqIEEgdGV4dHVyZSBzdG9yZXMgdGhlIGluZm9ybWF0aW9uIHRoYXQgcmVwcmVzZW50cyBhbiBpbWFnZS4gQWxsIHRleHR1cmVzIGhhdmUgYSBiYXNlIHRleHR1cmVcbiAqXG4gKiBAY2xhc3MgQmFzZVRleHR1cmVcbiAqIEB1c2VzIEV2ZW50VGFyZ2V0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSBzb3VyY2Uge1N0cmluZ30gdGhlIHNvdXJjZSBvYmplY3QgKGltYWdlIG9yIGNhbnZhcylcbiAqIEBwYXJhbSBzY2FsZU1vZGUge051bWJlcn0gU2hvdWxkIGJlIG9uZSBvZiB0aGUgUElYSS5zY2FsZU1vZGUgY29uc3RzXG4gKi9cblBJWEkuQmFzZVRleHR1cmUgPSBmdW5jdGlvbihzb3VyY2UsIHNjYWxlTW9kZSlcbntcbiAgICBQSVhJLkV2ZW50VGFyZ2V0LmNhbGwoIHRoaXMgKTtcblxuICAgIC8qKlxuICAgICAqIFtyZWFkLW9ubHldIFRoZSB3aWR0aCBvZiB0aGUgYmFzZSB0ZXh0dXJlIHNldCB3aGVuIHRoZSBpbWFnZSBoYXMgbG9hZGVkXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgd2lkdGhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLndpZHRoID0gMTAwO1xuXG4gICAgLyoqXG4gICAgICogW3JlYWQtb25seV0gVGhlIGhlaWdodCBvZiB0aGUgYmFzZSB0ZXh0dXJlIHNldCB3aGVuIHRoZSBpbWFnZSBoYXMgbG9hZGVkXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgaGVpZ2h0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSAxMDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NhbGUgbW9kZSB0byBhcHBseSB3aGVuIHNjYWxpbmcgdGhpcyB0ZXh0dXJlXG4gICAgICogQHByb3BlcnR5IHNjYWxlTW9kZVxuICAgICAqIEB0eXBlIFBJWEkuc2NhbGVNb2Rlc1xuICAgICAqIEBkZWZhdWx0IFBJWEkuc2NhbGVNb2Rlcy5MSU5FQVJcbiAgICAgKi9cbiAgICB0aGlzLnNjYWxlTW9kZSA9IHNjYWxlTW9kZSB8fCBQSVhJLnNjYWxlTW9kZXMuREVGQVVMVDtcblxuICAgIC8qKlxuICAgICAqIFtyZWFkLW9ubHldIERlc2NyaWJlcyBpZiB0aGUgYmFzZSB0ZXh0dXJlIGhhcyBsb2FkZWQgb3Igbm90XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgaGFzTG9hZGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMuaGFzTG9hZGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc291cmNlIHRoYXQgaXMgbG9hZGVkIHRvIGNyZWF0ZSB0aGUgdGV4dHVyZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHNvdXJjZVxuICAgICAqIEB0eXBlIEltYWdlXG4gICAgICovXG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG5cbiAgICAvL1RPRE8gd2lsbCBiZSB1c2VkIGZvciBmdXRlciBwaXhpIDEuNS4uLlxuICAgIHRoaXMuaWQgPSBQSVhJLkJhc2VUZXh0dXJlQ2FjaGVJZEdlbmVyYXRvcisrO1xuXG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgaWYgUkdCIGNoYW5uZWxzIHNob3VsZCBiZSBwcmVtdWx0aXBsaWVkIGJ5IEFscGhhICAoV2ViR0wgb25seSlcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBUUlVFXG4gICAgKi9cbiAgICB0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9IHRydWU7XG5cbiAgICAvLyB1c2VkIGZvciB3ZWJHTFxuICAgIHRoaXMuX2dsVGV4dHVyZXMgPSBbXTtcbiAgICBcbiAgICAvLyB1c2VkIGZvciB3ZWJHTCB0ZXR1cmUgdXBkYXRlaW5nLi4uXG4gICAgdGhpcy5fZGlydHkgPSBbXTtcbiAgICBcbiAgICBpZighc291cmNlKXJldHVybjtcblxuICAgIGlmKCh0aGlzLnNvdXJjZS5jb21wbGV0ZSB8fCB0aGlzLnNvdXJjZS5nZXRDb250ZXh0KSAmJiB0aGlzLnNvdXJjZS53aWR0aCAmJiB0aGlzLnNvdXJjZS5oZWlnaHQpXG4gICAge1xuICAgICAgICB0aGlzLmhhc0xvYWRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLnNvdXJjZS53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnNvdXJjZS5oZWlnaHQ7XG5cbiAgICAgICAgUElYSS50ZXh0dXJlc1RvVXBkYXRlLnB1c2godGhpcyk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG5cbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICAgICAgdGhpcy5zb3VyY2Uub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHNjb3BlLmhhc0xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICBzY29wZS53aWR0aCA9IHNjb3BlLnNvdXJjZS53aWR0aDtcbiAgICAgICAgICAgIHNjb3BlLmhlaWdodCA9IHNjb3BlLnNvdXJjZS5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2NvcGUuX2dsVGV4dHVyZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2NvcGUuX2RpcnR5W2ldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWRkIGl0IHRvIHNvbWV3aGVyZS4uLlxuICAgICAgICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnbG9hZGVkJywgY29udGVudDogc2NvcGUgfSApO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNvdXJjZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzY29wZS5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdlcnJvcicsIGNvbnRlbnQ6IHNjb3BlIH0gKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLmltYWdlVXJsID0gbnVsbDtcbiAgICB0aGlzLl9wb3dlck9mMiA9IGZhbHNlO1xuXG4gICAgXG5cbn07XG5cblBJWEkuQmFzZVRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5CYXNlVGV4dHVyZTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGlzIGJhc2UgdGV4dHVyZVxuICpcbiAqIEBtZXRob2QgZGVzdHJveVxuICovXG5QSVhJLkJhc2VUZXh0dXJlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxue1xuICAgIGlmKHRoaXMuaW1hZ2VVcmwpXG4gICAge1xuICAgICAgICBkZWxldGUgUElYSS5CYXNlVGV4dHVyZUNhY2hlW3RoaXMuaW1hZ2VVcmxdO1xuICAgICAgICBkZWxldGUgUElYSS5UZXh0dXJlQ2FjaGVbdGhpcy5pbWFnZVVybF07XG4gICAgICAgIHRoaXMuaW1hZ2VVcmwgPSBudWxsO1xuICAgICAgICB0aGlzLnNvdXJjZS5zcmMgPSBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLnNvdXJjZSAmJiB0aGlzLnNvdXJjZS5fcGl4aUlkKVxuICAgIHtcbiAgICAgICAgZGVsZXRlIFBJWEkuQmFzZVRleHR1cmVDYWNoZVt0aGlzLnNvdXJjZS5fcGl4aUlkXTtcbiAgICB9XG4gICAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICAgIFBJWEkudGV4dHVyZXNUb0Rlc3Ryb3kucHVzaCh0aGlzKTtcbn07XG5cbi8qKlxuICogQ2hhbmdlcyB0aGUgc291cmNlIGltYWdlIG9mIHRoZSB0ZXh0dXJlXG4gKlxuICogQG1ldGhvZCB1cGRhdGVTb3VyY2VJbWFnZVxuICogQHBhcmFtIG5ld1NyYyB7U3RyaW5nfSB0aGUgcGF0aCBvZiB0aGUgaW1hZ2VcbiAqL1xuUElYSS5CYXNlVGV4dHVyZS5wcm90b3R5cGUudXBkYXRlU291cmNlSW1hZ2UgPSBmdW5jdGlvbihuZXdTcmMpXG57XG4gICAgdGhpcy5oYXNMb2FkZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNvdXJjZS5zcmMgPSBudWxsO1xuICAgIHRoaXMuc291cmNlLnNyYyA9IG5ld1NyYztcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGJhc2UgdGV4dHVyZSBiYXNlZCBvbiBhbiBpbWFnZSB1cmxcbiAqIElmIHRoZSBpbWFnZSBpcyBub3QgaW4gdGhlIGJhc2UgdGV4dHVyZSBjYWNoZSBpdCB3aWxsIGJlIGNyZWF0ZWQgYW5kIGxvYWRlZFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZnJvbUltYWdlXG4gKiBAcGFyYW0gaW1hZ2VVcmwge1N0cmluZ30gVGhlIGltYWdlIHVybCBvZiB0aGUgdGV4dHVyZVxuICogQHBhcmFtIGNyb3Nzb3JpZ2luIHtCb29sZWFufSBcbiAqIEBwYXJhbSBzY2FsZU1vZGUge051bWJlcn0gU2hvdWxkIGJlIG9uZSBvZiB0aGUgUElYSS5zY2FsZU1vZGUgY29uc3RzXG4gKiBAcmV0dXJuIEJhc2VUZXh0dXJlXG4gKi9cblBJWEkuQmFzZVRleHR1cmUuZnJvbUltYWdlID0gZnVuY3Rpb24oaW1hZ2VVcmwsIGNyb3Nzb3JpZ2luLCBzY2FsZU1vZGUpXG57XG4gICAgdmFyIGJhc2VUZXh0dXJlID0gUElYSS5CYXNlVGV4dHVyZUNhY2hlW2ltYWdlVXJsXTtcbiAgICBcbiAgICBpZihjcm9zc29yaWdpbiA9PT0gdW5kZWZpbmVkICYmIGltYWdlVXJsLmluZGV4T2YoJ2RhdGE6JykgPT09IC0xKSBjcm9zc29yaWdpbiA9IHRydWU7XG5cbiAgICBpZighYmFzZVRleHR1cmUpXG4gICAge1xuICAgICAgICAvLyBuZXcgSW1hZ2UoKSBicmVha3MgdGV4IGxvYWRpbmcgaW4gc29tZSB2ZXJzaW9ucyBvZiBDaHJvbWUuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjM4MDcxXG4gICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpOy8vZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgIGlmIChjcm9zc29yaWdpbilcbiAgICAgICAge1xuICAgICAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpbWFnZS5zcmMgPSBpbWFnZVVybDtcbiAgICAgICAgYmFzZVRleHR1cmUgPSBuZXcgUElYSS5CYXNlVGV4dHVyZShpbWFnZSwgc2NhbGVNb2RlKTtcbiAgICAgICAgYmFzZVRleHR1cmUuaW1hZ2VVcmwgPSBpbWFnZVVybDtcbiAgICAgICAgUElYSS5CYXNlVGV4dHVyZUNhY2hlW2ltYWdlVXJsXSA9IGJhc2VUZXh0dXJlO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlVGV4dHVyZTtcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGJhc2UgdGV4dHVyZSBiYXNlZCBvbiBhIGNhbnZhcyBlbGVtZW50XG4gKiBJZiB0aGUgaW1hZ2UgaXMgbm90IGluIHRoZSBiYXNlIHRleHR1cmUgY2FjaGUgaXQgd2lsbCBiZSBjcmVhdGVkIGFuZCBsb2FkZWRcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGZyb21DYW52YXNcbiAqIEBwYXJhbSBjYW52YXMge0NhbnZhc30gVGhlIGNhbnZhcyBlbGVtZW50IHNvdXJjZSBvZiB0aGUgdGV4dHVyZVxuICogQHBhcmFtIHNjYWxlTW9kZSB7TnVtYmVyfSBTaG91bGQgYmUgb25lIG9mIHRoZSBQSVhJLnNjYWxlTW9kZSBjb25zdHNcbiAqIEByZXR1cm4gQmFzZVRleHR1cmVcbiAqL1xuUElYSS5CYXNlVGV4dHVyZS5mcm9tQ2FudmFzID0gZnVuY3Rpb24oY2FudmFzLCBzY2FsZU1vZGUpXG57XG4gICAgaWYoIWNhbnZhcy5fcGl4aUlkKVxuICAgIHtcbiAgICAgICAgY2FudmFzLl9waXhpSWQgPSAnY2FudmFzXycgKyBQSVhJLlRleHR1cmVDYWNoZUlkR2VuZXJhdG9yKys7XG4gICAgfVxuXG4gICAgdmFyIGJhc2VUZXh0dXJlID0gUElYSS5CYXNlVGV4dHVyZUNhY2hlW2NhbnZhcy5fcGl4aUlkXTtcblxuICAgIGlmKCFiYXNlVGV4dHVyZSlcbiAgICB7XG4gICAgICAgIGJhc2VUZXh0dXJlID0gbmV3IFBJWEkuQmFzZVRleHR1cmUoY2FudmFzLCBzY2FsZU1vZGUpO1xuICAgICAgICBQSVhJLkJhc2VUZXh0dXJlQ2FjaGVbY2FudmFzLl9waXhpSWRdID0gYmFzZVRleHR1cmU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2VUZXh0dXJlO1xufTtcblxuXG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuUElYSS5UZXh0dXJlQ2FjaGUgPSB7fTtcblBJWEkuRnJhbWVDYWNoZSA9IHt9O1xuXG5QSVhJLlRleHR1cmVDYWNoZUlkR2VuZXJhdG9yID0gMDtcblxuLyoqXG4gKiBBIHRleHR1cmUgc3RvcmVzIHRoZSBpbmZvcm1hdGlvbiB0aGF0IHJlcHJlc2VudHMgYW4gaW1hZ2Ugb3IgcGFydCBvZiBhbiBpbWFnZS4gSXQgY2Fubm90IGJlIGFkZGVkXG4gKiB0byB0aGUgZGlzcGxheSBsaXN0IGRpcmVjdGx5LiBUbyBkbyB0aGlzIHVzZSBQSVhJLlNwcml0ZS4gSWYgbm8gZnJhbWUgaXMgcHJvdmlkZWQgdGhlbiB0aGUgd2hvbGUgaW1hZ2UgaXMgdXNlZFxuICpcbiAqIEBjbGFzcyBUZXh0dXJlXG4gKiBAdXNlcyBFdmVudFRhcmdldFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gYmFzZVRleHR1cmUge0Jhc2VUZXh0dXJlfSBUaGUgYmFzZSB0ZXh0dXJlIHNvdXJjZSB0byBjcmVhdGUgdGhlIHRleHR1cmUgZnJvbVxuICogQHBhcmFtIGZyYW1lIHtSZWN0YW5nbGV9IFRoZSByZWN0YW5nbGUgZnJhbWUgb2YgdGhlIHRleHR1cmUgdG8gc2hvd1xuICovXG5QSVhJLlRleHR1cmUgPSBmdW5jdGlvbihiYXNlVGV4dHVyZSwgZnJhbWUpXG57XG4gICAgUElYSS5FdmVudFRhcmdldC5jYWxsKCB0aGlzICk7XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoaXMgVGV4dHVyZSBoYXZlIGFueSBmcmFtZSBkYXRhIGFzc2lnbmVkIHRvIGl0P1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IG5vRnJhbWVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5ub0ZyYW1lID0gZmFsc2U7XG5cbiAgICBpZiAoIWZyYW1lKVxuICAgIHtcbiAgICAgICAgdGhpcy5ub0ZyYW1lID0gdHJ1ZTtcbiAgICAgICAgZnJhbWUgPSBuZXcgUElYSS5SZWN0YW5nbGUoMCwwLDEsMSk7XG4gICAgfVxuXG4gICAgaWYgKGJhc2VUZXh0dXJlIGluc3RhbmNlb2YgUElYSS5UZXh0dXJlKVxuICAgIHtcbiAgICAgICAgYmFzZVRleHR1cmUgPSBiYXNlVGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSB0ZXh0dXJlIHRoYXQgdGhpcyB0ZXh0dXJlIHVzZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYmFzZVRleHR1cmVcbiAgICAgKiBAdHlwZSBCYXNlVGV4dHVyZVxuICAgICAqL1xuICAgIHRoaXMuYmFzZVRleHR1cmUgPSBiYXNlVGV4dHVyZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFtZSBzcGVjaWZpZXMgdGhlIHJlZ2lvbiBvZiB0aGUgYmFzZSB0ZXh0dXJlIHRoYXQgdGhpcyB0ZXh0dXJlIHVzZXNcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBmcmFtZVxuICAgICAqIEB0eXBlIFJlY3RhbmdsZVxuICAgICAqL1xuICAgIHRoaXMuZnJhbWUgPSBmcmFtZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0cmltIHBvaW50XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdHJpbVxuICAgICAqIEB0eXBlIFJlY3RhbmdsZVxuICAgICAqL1xuICAgIHRoaXMudHJpbSA9IG51bGw7XG4gICAgXG4gICAgLyoqXG4gICAgICogVGhpcyB3aWxsIGxldCB0aGUgcmVuZGVyZXIga25vdyBpZiB0aGUgdGV4dHVyZSBpcyB2YWxpZC4gSWYgaXRzIG5vdCB0aGVuIGl0IGNhbm5vdCBiZSByZW5kZXJlZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB2YWxpZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udGV4dCBzY29wZSB1bmRlciB3aGljaCBldmVudHMgYXJlIHJ1bi5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBzY29wZVxuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIHRoaXMuc2NvcGUgPSB0aGlzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIFdlYkdMIFVWIGRhdGEgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSBfdXZzXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgdGhpcy5fdXZzID0gbnVsbDtcbiAgICBcbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIFRleHR1cmUgaW4gcGl4ZWxzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHdpZHRoXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBUZXh0dXJlIGluIHBpeGVscy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBoZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBhcmVhIG9mIHRoZSBCYXNlVGV4dHVyZSBpbWFnZSB0byBhY3R1YWxseSBjb3B5IHRvIHRoZSBDYW52YXMgLyBXZWJHTCB3aGVuIHJlbmRlcmluZyxcbiAgICAgKiBpcnJlc3BlY3RpdmUgb2YgdGhlIGFjdHVhbCBmcmFtZSBzaXplIG9yIHBsYWNlbWVudCAod2hpY2ggY2FuIGJlIGluZmx1ZW5jZWQgYnkgdHJpbW1lZCB0ZXh0dXJlIGF0bGFzZXMpXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY3JvcFxuICAgICAqIEB0eXBlIFJlY3RhbmdsZVxuICAgICAqL1xuICAgIHRoaXMuY3JvcCA9IG5ldyBQSVhJLlJlY3RhbmdsZSgwLCAwLCAxLCAxKTtcblxuICAgIGlmIChiYXNlVGV4dHVyZS5oYXNMb2FkZWQpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5ub0ZyYW1lKSBmcmFtZSA9IG5ldyBQSVhJLlJlY3RhbmdsZSgwLCAwLCBiYXNlVGV4dHVyZS53aWR0aCwgYmFzZVRleHR1cmUuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5zZXRGcmFtZShmcmFtZSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICAgIGJhc2VUZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZCcsIGZ1bmN0aW9uKCl7IHNjb3BlLm9uQmFzZVRleHR1cmVMb2FkZWQoKTsgfSk7XG4gICAgfVxufTtcblxuUElYSS5UZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuVGV4dHVyZTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGUgYmFzZSB0ZXh0dXJlIGlzIGxvYWRlZFxuICpcbiAqIEBtZXRob2Qgb25CYXNlVGV4dHVyZUxvYWRlZFxuICogQHBhcmFtIGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlRleHR1cmUucHJvdG90eXBlLm9uQmFzZVRleHR1cmVMb2FkZWQgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGJhc2VUZXh0dXJlID0gdGhpcy5iYXNlVGV4dHVyZTtcbiAgICBiYXNlVGV4dHVyZS5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkZWQnLCB0aGlzLm9uTG9hZGVkKTtcblxuICAgIGlmICh0aGlzLm5vRnJhbWUpIHRoaXMuZnJhbWUgPSBuZXcgUElYSS5SZWN0YW5nbGUoMCwgMCwgYmFzZVRleHR1cmUud2lkdGgsIGJhc2VUZXh0dXJlLmhlaWdodCk7XG4gICAgXG4gICAgdGhpcy5zZXRGcmFtZSh0aGlzLmZyYW1lKTtcblxuICAgIHRoaXMuc2NvcGUuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAndXBkYXRlJywgY29udGVudDogdGhpcyB9ICk7XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoaXMgdGV4dHVyZVxuICpcbiAqIEBtZXRob2QgZGVzdHJveVxuICogQHBhcmFtIGRlc3Ryb3lCYXNlIHtCb29sZWFufSBXaGV0aGVyIHRvIGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBhcyB3ZWxsXG4gKi9cblBJWEkuVGV4dHVyZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKGRlc3Ryb3lCYXNlKVxue1xuICAgIGlmIChkZXN0cm95QmFzZSkgdGhpcy5iYXNlVGV4dHVyZS5kZXN0cm95KCk7XG5cbiAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgcmVnaW9uIG9mIHRoZSBiYXNlVGV4dHVyZSB0aGF0IHRoaXMgdGV4dHVyZSB3aWxsIHVzZS5cbiAqXG4gKiBAbWV0aG9kIHNldEZyYW1lXG4gKiBAcGFyYW0gZnJhbWUge1JlY3RhbmdsZX0gVGhlIGZyYW1lIG9mIHRoZSB0ZXh0dXJlIHRvIHNldCBpdCB0b1xuICovXG5QSVhJLlRleHR1cmUucHJvdG90eXBlLnNldEZyYW1lID0gZnVuY3Rpb24oZnJhbWUpXG57XG4gICAgdGhpcy5ub0ZyYW1lID0gZmFsc2U7XG5cbiAgICB0aGlzLmZyYW1lID0gZnJhbWU7XG4gICAgdGhpcy53aWR0aCA9IGZyYW1lLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gZnJhbWUuaGVpZ2h0O1xuXG4gICAgdGhpcy5jcm9wLnggPSBmcmFtZS54O1xuICAgIHRoaXMuY3JvcC55ID0gZnJhbWUueTtcbiAgICB0aGlzLmNyb3Aud2lkdGggPSBmcmFtZS53aWR0aDtcbiAgICB0aGlzLmNyb3AuaGVpZ2h0ID0gZnJhbWUuaGVpZ2h0O1xuXG4gICAgaWYgKCF0aGlzLnRyaW0gJiYgKGZyYW1lLnggKyBmcmFtZS53aWR0aCA+IHRoaXMuYmFzZVRleHR1cmUud2lkdGggfHwgZnJhbWUueSArIGZyYW1lLmhlaWdodCA+IHRoaXMuYmFzZVRleHR1cmUuaGVpZ2h0KSlcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dHVyZSBFcnJvcjogZnJhbWUgZG9lcyBub3QgZml0IGluc2lkZSB0aGUgYmFzZSBUZXh0dXJlIGRpbWVuc2lvbnMgJyArIHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMudmFsaWQgPSBmcmFtZSAmJiBmcmFtZS53aWR0aCAmJiBmcmFtZS5oZWlnaHQgJiYgdGhpcy5iYXNlVGV4dHVyZS5zb3VyY2UgJiYgdGhpcy5iYXNlVGV4dHVyZS5oYXNMb2FkZWQ7XG5cbiAgICBpZiAodGhpcy50cmltKVxuICAgIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMudHJpbS53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnRyaW0uaGVpZ2h0O1xuICAgICAgICB0aGlzLmZyYW1lLndpZHRoID0gdGhpcy50cmltLndpZHRoO1xuICAgICAgICB0aGlzLmZyYW1lLmhlaWdodCA9IHRoaXMudHJpbS5oZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudmFsaWQpIFBJWEkuVGV4dHVyZS5mcmFtZVVwZGF0ZXMucHVzaCh0aGlzKTtcblxufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBXZWJHTCBVViBjYWNoZS5cbiAqXG4gKiBAbWV0aG9kIF91cGRhdGVXZWJHTHV2c1xuICogQHByaXZhdGVcbiAqL1xuUElYSS5UZXh0dXJlLnByb3RvdHlwZS5fdXBkYXRlV2ViR0x1dnMgPSBmdW5jdGlvbigpXG57XG4gICAgaWYoIXRoaXMuX3V2cyl0aGlzLl91dnMgPSBuZXcgUElYSS5UZXh0dXJlVXZzKCk7XG5cbiAgICB2YXIgZnJhbWUgPSB0aGlzLmNyb3A7XG4gICAgdmFyIHR3ID0gdGhpcy5iYXNlVGV4dHVyZS53aWR0aDtcbiAgICB2YXIgdGggPSB0aGlzLmJhc2VUZXh0dXJlLmhlaWdodDtcblxuICAgIHRoaXMuX3V2cy54MCA9IGZyYW1lLnggLyB0dztcbiAgICB0aGlzLl91dnMueTAgPSBmcmFtZS55IC8gdGg7XG5cbiAgICB0aGlzLl91dnMueDEgPSAoZnJhbWUueCArIGZyYW1lLndpZHRoKSAvIHR3O1xuICAgIHRoaXMuX3V2cy55MSA9IGZyYW1lLnkgLyB0aDtcblxuICAgIHRoaXMuX3V2cy54MiA9IChmcmFtZS54ICsgZnJhbWUud2lkdGgpIC8gdHc7XG4gICAgdGhpcy5fdXZzLnkyID0gKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpIC8gdGg7XG5cbiAgICB0aGlzLl91dnMueDMgPSBmcmFtZS54IC8gdHc7XG4gICAgdGhpcy5fdXZzLnkzID0gKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpIC8gdGg7XG5cbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRleHR1cmUgYmFzZWQgb24gYW4gaW1hZ2UgdXJsXG4gKiBJZiB0aGUgaW1hZ2UgaXMgbm90IGluIHRoZSB0ZXh0dXJlIGNhY2hlIGl0IHdpbGwgYmUgIGNyZWF0ZWQgYW5kIGxvYWRlZFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZnJvbUltYWdlXG4gKiBAcGFyYW0gaW1hZ2VVcmwge1N0cmluZ30gVGhlIGltYWdlIHVybCBvZiB0aGUgdGV4dHVyZVxuICogQHBhcmFtIGNyb3Nzb3JpZ2luIHtCb29sZWFufSBXaGV0aGVyIHJlcXVlc3RzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGNyb3Nzb3JpZ2luXG4gKiBAcGFyYW0gc2NhbGVNb2RlIHtOdW1iZXJ9IFNob3VsZCBiZSBvbmUgb2YgdGhlIFBJWEkuc2NhbGVNb2RlIGNvbnN0c1xuICogQHJldHVybiBUZXh0dXJlXG4gKi9cblBJWEkuVGV4dHVyZS5mcm9tSW1hZ2UgPSBmdW5jdGlvbihpbWFnZVVybCwgY3Jvc3NvcmlnaW4sIHNjYWxlTW9kZSlcbntcbiAgICB2YXIgdGV4dHVyZSA9IFBJWEkuVGV4dHVyZUNhY2hlW2ltYWdlVXJsXTtcblxuICAgIGlmKCF0ZXh0dXJlKVxuICAgIHtcbiAgICAgICAgdGV4dHVyZSA9IG5ldyBQSVhJLlRleHR1cmUoUElYSS5CYXNlVGV4dHVyZS5mcm9tSW1hZ2UoaW1hZ2VVcmwsIGNyb3Nzb3JpZ2luLCBzY2FsZU1vZGUpKTtcbiAgICAgICAgUElYSS5UZXh0dXJlQ2FjaGVbaW1hZ2VVcmxdID0gdGV4dHVyZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dHVyZTtcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRleHR1cmUgYmFzZWQgb24gYSBmcmFtZSBpZFxuICogSWYgdGhlIGZyYW1lIGlkIGlzIG5vdCBpbiB0aGUgdGV4dHVyZSBjYWNoZSBhbiBlcnJvciB3aWxsIGJlIHRocm93blxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZnJvbUZyYW1lXG4gKiBAcGFyYW0gZnJhbWVJZCB7U3RyaW5nfSBUaGUgZnJhbWUgaWQgb2YgdGhlIHRleHR1cmVcbiAqIEByZXR1cm4gVGV4dHVyZVxuICovXG5QSVhJLlRleHR1cmUuZnJvbUZyYW1lID0gZnVuY3Rpb24oZnJhbWVJZClcbntcbiAgICB2YXIgdGV4dHVyZSA9IFBJWEkuVGV4dHVyZUNhY2hlW2ZyYW1lSWRdO1xuICAgIGlmKCF0ZXh0dXJlKSB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBmcmFtZUlkIFwiJyArIGZyYW1lSWQgKyAnXCIgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHRleHR1cmUgY2FjaGUgJyk7XG4gICAgcmV0dXJuIHRleHR1cmU7XG59O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB0ZXh0dXJlIGJhc2VkIG9uIGEgY2FudmFzIGVsZW1lbnRcbiAqIElmIHRoZSBjYW52YXMgaXMgbm90IGluIHRoZSB0ZXh0dXJlIGNhY2hlIGl0IHdpbGwgYmUgIGNyZWF0ZWQgYW5kIGxvYWRlZFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZnJvbUNhbnZhc1xuICogQHBhcmFtIGNhbnZhcyB7Q2FudmFzfSBUaGUgY2FudmFzIGVsZW1lbnQgc291cmNlIG9mIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gc2NhbGVNb2RlIHtOdW1iZXJ9IFNob3VsZCBiZSBvbmUgb2YgdGhlIFBJWEkuc2NhbGVNb2RlIGNvbnN0c1xuICogQHJldHVybiBUZXh0dXJlXG4gKi9cblBJWEkuVGV4dHVyZS5mcm9tQ2FudmFzID0gZnVuY3Rpb24oY2FudmFzLCBzY2FsZU1vZGUpXG57XG4gICAgdmFyIGJhc2VUZXh0dXJlID0gUElYSS5CYXNlVGV4dHVyZS5mcm9tQ2FudmFzKGNhbnZhcywgc2NhbGVNb2RlKTtcblxuICAgIHJldHVybiBuZXcgUElYSS5UZXh0dXJlKCBiYXNlVGV4dHVyZSApO1xuXG59O1xuXG5cbi8qKlxuICogQWRkcyBhIHRleHR1cmUgdG8gdGhlIHRleHR1cmVDYWNoZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGFkZFRleHR1cmVUb0NhY2hlXG4gKiBAcGFyYW0gdGV4dHVyZSB7VGV4dHVyZX1cbiAqIEBwYXJhbSBpZCB7U3RyaW5nfSB0aGUgaWQgdGhhdCB0aGUgdGV4dHVyZSB3aWxsIGJlIHN0b3JlZCBhZ2FpbnN0LlxuICovXG5QSVhJLlRleHR1cmUuYWRkVGV4dHVyZVRvQ2FjaGUgPSBmdW5jdGlvbih0ZXh0dXJlLCBpZClcbntcbiAgICBQSVhJLlRleHR1cmVDYWNoZVtpZF0gPSB0ZXh0dXJlO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSB0ZXh0dXJlIGZyb20gdGhlIHRleHR1cmVDYWNoZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHJlbW92ZVRleHR1cmVGcm9tQ2FjaGVcbiAqIEBwYXJhbSBpZCB7U3RyaW5nfSB0aGUgaWQgb2YgdGhlIHRleHR1cmUgdG8gYmUgcmVtb3ZlZFxuICogQHJldHVybiB7VGV4dHVyZX0gdGhlIHRleHR1cmUgdGhhdCB3YXMgcmVtb3ZlZFxuICovXG5QSVhJLlRleHR1cmUucmVtb3ZlVGV4dHVyZUZyb21DYWNoZSA9IGZ1bmN0aW9uKGlkKVxue1xuICAgIHZhciB0ZXh0dXJlID0gUElYSS5UZXh0dXJlQ2FjaGVbaWRdO1xuICAgIGRlbGV0ZSBQSVhJLlRleHR1cmVDYWNoZVtpZF07XG4gICAgZGVsZXRlIFBJWEkuQmFzZVRleHR1cmVDYWNoZVtpZF07XG4gICAgcmV0dXJuIHRleHR1cmU7XG59O1xuXG4vLyB0aGlzIGlzIG1vcmUgZm9yIHdlYkdMLi4gaXQgY29udGFpbnMgdXBkYXRlZCBmcmFtZXMuLlxuUElYSS5UZXh0dXJlLmZyYW1lVXBkYXRlcyA9IFtdO1xuXG5QSVhJLlRleHR1cmVVdnMgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy54MCA9IDA7XG4gICAgdGhpcy55MCA9IDA7XG5cbiAgICB0aGlzLngxID0gMDtcbiAgICB0aGlzLnkxID0gMDtcblxuICAgIHRoaXMueDIgPSAwO1xuICAgIHRoaXMueTIgPSAwO1xuXG4gICAgdGhpcy54MyA9IDA7XG4gICAgdGhpcy55MyA9IDA7XG5cblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiBBIFJlbmRlclRleHR1cmUgaXMgYSBzcGVjaWFsIHRleHR1cmUgdGhhdCBhbGxvd3MgYW55IHBpeGkgZGlzcGxheU9iamVjdCB0byBiZSByZW5kZXJlZCB0byBpdC5cblxuIF9fSGludF9fOiBBbGwgRGlzcGxheU9iamVjdHMgKGV4bXBsLiBTcHJpdGVzKSB0aGF0IHJlbmRlciBvbiBSZW5kZXJUZXh0dXJlIHNob3VsZCBiZSBwcmVsb2FkZWQuXG4gT3RoZXJ3aXNlIGJsYWNrIHJlY3RhbmdsZXMgd2lsbCBiZSBkcmF3biBpbnN0ZWFkLlxuXG4gUmVuZGVyVGV4dHVyZSB0YWtlcyBzbmFwc2hvdCBvZiBEaXNwbGF5T2JqZWN0IHBhc3NlZCB0byByZW5kZXIgbWV0aG9kLiBJZiBEaXNwbGF5T2JqZWN0IGlzIHBhc3NlZCB0byByZW5kZXIgbWV0aG9kLCBwb3NpdGlvbiBhbmQgcm90YXRpb24gb2YgaXQgd2lsbCBiZSBpZ25vcmVkLiBGb3IgZXhhbXBsZTpcblxuICAgIHZhciByZW5kZXJUZXh0dXJlID0gbmV3IFBJWEkuUmVuZGVyVGV4dHVyZSg4MDAsIDYwMCk7XG4gICAgdmFyIHNwcml0ZSA9IFBJWEkuU3ByaXRlLmZyb21JbWFnZShcInNwaW5PYmpfMDEucG5nXCIpO1xuICAgIHNwcml0ZS5wb3NpdGlvbi54ID0gODAwLzI7XG4gICAgc3ByaXRlLnBvc2l0aW9uLnkgPSA2MDAvMjtcbiAgICBzcHJpdGUuYW5jaG9yLnggPSAwLjU7XG4gICAgc3ByaXRlLmFuY2hvci55ID0gMC41O1xuICAgIHJlbmRlclRleHR1cmUucmVuZGVyKHNwcml0ZSk7XG5cbiBTcHJpdGUgaW4gdGhpcyBjYXNlIHdpbGwgYmUgcmVuZGVyZWQgdG8gMCwwIHBvc2l0aW9uLiBUbyByZW5kZXIgdGhpcyBzcHJpdGUgYXQgY2VudGVyIERpc3BsYXlPYmplY3RDb250YWluZXIgc2hvdWxkIGJlIHVzZWQ6XG5cbiAgICB2YXIgZG9jID0gbmV3IFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcigpO1xuICAgIGRvYy5hZGRDaGlsZChzcHJpdGUpO1xuICAgIHJlbmRlclRleHR1cmUucmVuZGVyKGRvYyk7ICAvLyBSZW5kZXJzIHRvIGNlbnRlciBvZiByZW5kZXJUZXh0dXJlXG5cbiAqIEBjbGFzcyBSZW5kZXJUZXh0dXJlXG4gKiBAZXh0ZW5kcyBUZXh0dXJlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB3aWR0aCB7TnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIHJlbmRlciB0ZXh0dXJlXG4gKiBAcGFyYW0gaGVpZ2h0IHtOdW1iZXJ9IFRoZSBoZWlnaHQgb2YgdGhlIHJlbmRlciB0ZXh0dXJlXG4gKiBAcGFyYW0gc2NhbGVNb2RlIHtOdW1iZXJ9IFNob3VsZCBiZSBvbmUgb2YgdGhlIFBJWEkuc2NhbGVNb2RlIGNvbnN0c1xuICovXG5QSVhJLlJlbmRlclRleHR1cmUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCByZW5kZXJlciwgc2NhbGVNb2RlKVxue1xuICAgIFBJWEkuRXZlbnRUYXJnZXQuY2FsbCggdGhpcyApO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdpdGggb2YgdGhlIHJlbmRlciB0ZXh0dXJlXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgd2lkdGhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLndpZHRoID0gd2lkdGggfHwgMTAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHJlbmRlciB0ZXh0dXJlXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgaGVpZ2h0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgMTAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYW1pbmcgcmVjdGFuZ2xlIG9mIHRoZSByZW5kZXIgdGV4dHVyZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGZyYW1lXG4gICAgICogQHR5cGUgUmVjdGFuZ2xlXG4gICAgICovXG4gICAgdGhpcy5mcmFtZSA9IG5ldyBQSVhJLlJlY3RhbmdsZSgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBhcmVhIG9mIHRoZSBCYXNlVGV4dHVyZSBpbWFnZSB0byBhY3R1YWxseSBjb3B5IHRvIHRoZSBDYW52YXMgLyBXZWJHTCB3aGVuIHJlbmRlcmluZyxcbiAgICAgKiBpcnJlc3BlY3RpdmUgb2YgdGhlIGFjdHVhbCBmcmFtZSBzaXplIG9yIHBsYWNlbWVudCAod2hpY2ggY2FuIGJlIGluZmx1ZW5jZWQgYnkgdHJpbW1lZCB0ZXh0dXJlIGF0bGFzZXMpXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY3JvcFxuICAgICAqIEB0eXBlIFJlY3RhbmdsZVxuICAgICAqL1xuICAgIHRoaXMuY3JvcCA9IG5ldyBQSVhJLlJlY3RhbmdsZSgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgdGV4dHVyZSBvYmplY3QgdGhhdCB0aGlzIHRleHR1cmUgdXNlc1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJhc2VUZXh0dXJlXG4gICAgICogQHR5cGUgQmFzZVRleHR1cmVcbiAgICAgKi9cbiAgICB0aGlzLmJhc2VUZXh0dXJlID0gbmV3IFBJWEkuQmFzZVRleHR1cmUoKTtcbiAgICB0aGlzLmJhc2VUZXh0dXJlLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICB0aGlzLmJhc2VUZXh0dXJlLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIHRoaXMuYmFzZVRleHR1cmUuX2dsVGV4dHVyZXMgPSBbXTtcblxuICAgIHRoaXMuYmFzZVRleHR1cmUuc2NhbGVNb2RlID0gc2NhbGVNb2RlIHx8IFBJWEkuc2NhbGVNb2Rlcy5ERUZBVUxUO1xuXG4gICAgdGhpcy5iYXNlVGV4dHVyZS5oYXNMb2FkZWQgPSB0cnVlO1xuXG4gICAgLy8gZWFjaCByZW5kZXIgdGV4dHVyZSBjYW4gb25seSBiZWxvbmcgdG8gb25lIHJlbmRlcmVyIGF0IHRoZSBtb21lbnQgaWYgaXRzIHdlYkdMXG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyIHx8IFBJWEkuZGVmYXVsdFJlbmRlcmVyO1xuXG4gICAgaWYodGhpcy5yZW5kZXJlci50eXBlID09PSBQSVhJLldFQkdMX1JFTkRFUkVSKVxuICAgIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcblxuICAgICAgICB0aGlzLnRleHR1cmVCdWZmZXIgPSBuZXcgUElYSS5GaWx0ZXJUZXh0dXJlKGdsLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5iYXNlVGV4dHVyZS5zY2FsZU1vZGUpO1xuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSA9ICB0aGlzLnRleHR1cmVCdWZmZXIudGV4dHVyZTtcblxuICAgICAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyV2ViR0w7XG4gICAgICAgIHRoaXMucHJvamVjdGlvbiA9IG5ldyBQSVhJLlBvaW50KHRoaXMud2lkdGgvMiAsIC10aGlzLmhlaWdodC8yKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlckNhbnZhcztcbiAgICAgICAgdGhpcy50ZXh0dXJlQnVmZmVyID0gbmV3IFBJWEkuQ2FudmFzQnVmZmVyKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5zb3VyY2UgPSB0aGlzLnRleHR1cmVCdWZmZXIuY2FudmFzO1xuICAgIH1cblxuICAgIHRoaXMudmFsaWQgPSB0cnVlO1xuICAgIFBJWEkuVGV4dHVyZS5mcmFtZVVwZGF0ZXMucHVzaCh0aGlzKTtcblxuXG59O1xuXG5QSVhJLlJlbmRlclRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQSVhJLlRleHR1cmUucHJvdG90eXBlKTtcblBJWEkuUmVuZGVyVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLlJlbmRlclRleHR1cmU7XG5cbi8qKlxuICogUmVzaXplIHRoZSBSZW5kZXJUZXh0dXJlLlxuICpcbiAqIEBtZXRob2QgcmVzaXplXG4gKiBAcGFyYW0gd2lkdGgge051bWJlcn0gVGhlIHdpZHRoIHRvIHJlc2l6ZSB0by5cbiAqIEBwYXJhbSBoZWlnaHQge051bWJlcn0gVGhlIGhlaWdodCB0byByZXNpemUgdG8uXG4gKiBAcGFyYW0gdXBkYXRlQmFzZSB7Qm9vbGVhbn0gU2hvdWxkIHRoZSBiYXNlVGV4dHVyZS53aWR0aCBhbmQgaGVpZ2h0IHZhbHVlcyBiZSByZXNpemVkIGFzIHdlbGw/XG4gKi9cblBJWEkuUmVuZGVyVGV4dHVyZS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgdXBkYXRlQmFzZSlcbntcbiAgICBpZiAod2lkdGggPT09IHRoaXMud2lkdGggJiYgaGVpZ2h0ID09PSB0aGlzLmhlaWdodClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLndpZHRoID0gdGhpcy5mcmFtZS53aWR0aCA9IHRoaXMuY3JvcC53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gIHRoaXMuZnJhbWUuaGVpZ2h0ID0gdGhpcy5jcm9wLmhlaWdodCA9IGhlaWdodDtcblxuICAgIGlmICh1cGRhdGVCYXNlKVxuICAgIHtcbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgIHRoaXMuYmFzZVRleHR1cmUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVuZGVyZXIudHlwZSA9PT0gUElYSS5XRUJHTF9SRU5ERVJFUilcbiAgICB7XG4gICAgICAgIHRoaXMucHJvamVjdGlvbi54ID0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMucHJvamVjdGlvbi55ID0gLXRoaXMuaGVpZ2h0IC8gMjtcbiAgICB9XG4gICAgXG4gICAgdGhpcy50ZXh0dXJlQnVmZmVyLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgUmVuZGVyVGV4dHVyZS5cbiAqXG4gKiBAbWV0aG9kIGNsZWFyXG4gKi9cblBJWEkuUmVuZGVyVGV4dHVyZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpXG57XG4gICAgaWYgKHRoaXMucmVuZGVyZXIudHlwZSA9PT0gUElYSS5XRUJHTF9SRU5ERVJFUilcbiAgICB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMucmVuZGVyZXIuZ2wuRlJBTUVCVUZGRVIsIHRoaXMudGV4dHVyZUJ1ZmZlci5mcmFtZUJ1ZmZlcik7XG4gICAgfVxuICAgIFxuICAgIHRoaXMudGV4dHVyZUJ1ZmZlci5jbGVhcigpO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgZHJhdyB0aGUgZGlzcGxheSBvYmplY3QgdG8gdGhlIHRleHR1cmUuXG4gKlxuICogQG1ldGhvZCByZW5kZXJXZWJHTFxuICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge0Rpc3BsYXlPYmplY3R9IFRoZSBkaXNwbGF5IG9iamVjdCB0byByZW5kZXIgdGhpcyB0ZXh0dXJlIG9uXG4gKiBAcGFyYW0gY2xlYXIge0Jvb2xlYW59IElmIHRydWUgdGhlIHRleHR1cmUgd2lsbCBiZSBjbGVhcmVkIGJlZm9yZSB0aGUgZGlzcGxheU9iamVjdCBpcyBkcmF3blxuICogQHByaXZhdGVcbiAqL1xuUElYSS5SZW5kZXJUZXh0dXJlLnByb3RvdHlwZS5yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uKGRpc3BsYXlPYmplY3QsIHBvc2l0aW9uLCBjbGVhcilcbntcbiAgICAvL1RPT0QgcmVwbGFjZSBwb3NpdGlvbiB3aXRoIG1hdHJpeC4uXG4gICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcblxuICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcblxuICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy50ZXh0dXJlQnVmZmVyLmZyYW1lQnVmZmVyICk7XG5cbiAgICBpZihjbGVhcil0aGlzLnRleHR1cmVCdWZmZXIuY2xlYXIoKTtcblxuXG4gICAgLy8gVEhJUyBXSUxMIE1FU1MgV0lUSCBISVQgVEVTVElORyFcbiAgICB2YXIgY2hpbGRyZW4gPSBkaXNwbGF5T2JqZWN0LmNoaWxkcmVuO1xuXG4gICAgLy9UT0RPIC0/IGNyZWF0ZSBhIG5ldyBvbmU/Pz8gZG9udCB0aGluayBzbyFcbiAgICB2YXIgb3JpZ2luYWxXb3JsZFRyYW5zZm9ybSA9IGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm07XG4gICAgZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybSA9IFBJWEkuUmVuZGVyVGV4dHVyZS50ZW1wTWF0cml4O1xuICAgIC8vIG1vZGlmeSB0byBmbGlwLi4uXG4gICAgZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybS5kID0gLTE7XG4gICAgZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybS50eSA9IHRoaXMucHJvamVjdGlvbi55ICogLTI7XG5cbiAgICBpZihwb3NpdGlvbilcbiAgICB7XG4gICAgICAgIGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm0udHggPSBwb3NpdGlvbi54O1xuICAgICAgICBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtLnR5IC09IHBvc2l0aW9uLnk7XG4gICAgfVxuXG4gICAgZm9yKHZhciBpPTAsaj1jaGlsZHJlbi5sZW5ndGg7IGk8ajsgaSsrKVxuICAgIHtcbiAgICAgICAgY2hpbGRyZW5baV0udXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHRoZSB0ZXh0dXJlcyFcbiAgICBQSVhJLldlYkdMUmVuZGVyZXIudXBkYXRlVGV4dHVyZXMoKTtcblxuICAgIHRoaXMucmVuZGVyZXIuc3ByaXRlQmF0Y2guZGlydHkgPSB0cnVlO1xuICAgIFxuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyRGlzcGxheU9iamVjdChkaXNwbGF5T2JqZWN0LCB0aGlzLnByb2plY3Rpb24sIHRoaXMudGV4dHVyZUJ1ZmZlci5mcmFtZUJ1ZmZlcik7XG5cbiAgICBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtID0gb3JpZ2luYWxXb3JsZFRyYW5zZm9ybTtcblxuICAgIHRoaXMucmVuZGVyZXIuc3ByaXRlQmF0Y2guZGlydHkgPSB0cnVlO1xufTtcblxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBkcmF3IHRoZSBkaXNwbGF5IG9iamVjdCB0byB0aGUgdGV4dHVyZS5cbiAqXG4gKiBAbWV0aG9kIHJlbmRlckNhbnZhc1xuICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge0Rpc3BsYXlPYmplY3R9IFRoZSBkaXNwbGF5IG9iamVjdCB0byByZW5kZXIgdGhpcyB0ZXh0dXJlIG9uXG4gKiBAcGFyYW0gY2xlYXIge0Jvb2xlYW59IElmIHRydWUgdGhlIHRleHR1cmUgd2lsbCBiZSBjbGVhcmVkIGJlZm9yZSB0aGUgZGlzcGxheU9iamVjdCBpcyBkcmF3blxuICogQHByaXZhdGVcbiAqL1xuUElYSS5SZW5kZXJUZXh0dXJlLnByb3RvdHlwZS5yZW5kZXJDYW52YXMgPSBmdW5jdGlvbihkaXNwbGF5T2JqZWN0LCBwb3NpdGlvbiwgY2xlYXIpXG57XG4gICAgdmFyIGNoaWxkcmVuID0gZGlzcGxheU9iamVjdC5jaGlsZHJlbjtcblxuICAgIHZhciBvcmlnaW5hbFdvcmxkVHJhbnNmb3JtID0gZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybTtcblxuICAgIGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm0gPSBQSVhJLlJlbmRlclRleHR1cmUudGVtcE1hdHJpeDtcbiAgICBcbiAgICBpZihwb3NpdGlvbilcbiAgICB7XG4gICAgICAgIGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm0udHggPSBwb3NpdGlvbi54O1xuICAgICAgICBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtLnR5ID0gcG9zaXRpb24ueTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybS50eCA9IDA7XG4gICAgICAgIGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm0udHkgPSAwO1xuICAgIH1cblxuICAgIGZvcih2YXIgaSA9IDAsIGogPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspXG4gICAge1xuICAgICAgICBjaGlsZHJlbltpXS51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICB9XG5cbiAgICBpZihjbGVhcil0aGlzLnRleHR1cmVCdWZmZXIuY2xlYXIoKTtcblxuICAgIHZhciBjb250ZXh0ID0gdGhpcy50ZXh0dXJlQnVmZmVyLmNvbnRleHQ7XG5cbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlckRpc3BsYXlPYmplY3QoZGlzcGxheU9iamVjdCwgY29udGV4dCk7XG5cbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLDAsMCwxLDAsMCk7XG5cbiAgICBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtID0gb3JpZ2luYWxXb3JsZFRyYW5zZm9ybTtcbn07XG5cblBJWEkuUmVuZGVyVGV4dHVyZS50ZW1wTWF0cml4ID0gbmV3IFBJWEkuTWF0cml4KCk7XG5cblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqIEEgQ2xhc3MgdGhhdCBsb2FkcyBhIGJ1bmNoIG9mIGltYWdlcyAvIHNwcml0ZSBzaGVldCAvIGJpdG1hcCBmb250IGZpbGVzLiBPbmNlIHRoZVxuICogYXNzZXRzIGhhdmUgYmVlbiBsb2FkZWQgdGhleSBhcmUgYWRkZWQgdG8gdGhlIFBJWEkgVGV4dHVyZSBjYWNoZSBhbmQgY2FuIGJlIGFjY2Vzc2VkXG4gKiBlYXNpbHkgdGhyb3VnaCBQSVhJLlRleHR1cmUuZnJvbUltYWdlKCkgYW5kIFBJWEkuU3ByaXRlLmZyb21JbWFnZSgpXG4gKiBXaGVuIGFsbCBpdGVtcyBoYXZlIGJlZW4gbG9hZGVkIHRoaXMgY2xhc3Mgd2lsbCBkaXNwYXRjaCBhICdvbkxvYWRlZCcgZXZlbnRcbiAqIEFzIGVhY2ggaW5kaXZpZHVhbCBpdGVtIGlzIGxvYWRlZCB0aGlzIGNsYXNzIHdpbGwgZGlzcGF0Y2ggYSAnb25Qcm9ncmVzcycgZXZlbnRcbiAqXG4gKiBAY2xhc3MgQXNzZXRMb2FkZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHVzZXMgRXZlbnRUYXJnZXRcbiAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gYXNzZXRVUkxzIGFuIGFycmF5IG9mIGltYWdlL3Nwcml0ZSBzaGVldCB1cmxzIHRoYXQgeW91IHdvdWxkIGxpa2UgbG9hZGVkXG4gKiAgICAgIHN1cHBvcnRlZC4gU3VwcG9ydGVkIGltYWdlIGZvcm1hdHMgaW5jbHVkZSAnanBlZycsICdqcGcnLCAncG5nJywgJ2dpZicuIFN1cHBvcnRlZFxuICogICAgICBzcHJpdGUgc2hlZXQgZGF0YSBmb3JtYXRzIG9ubHkgaW5jbHVkZSAnSlNPTicgYXQgdGhpcyB0aW1lLiBTdXBwb3J0ZWQgYml0bWFwIGZvbnRcbiAqICAgICAgZGF0YSBmb3JtYXRzIGluY2x1ZGUgJ3htbCcgYW5kICdmbnQnLlxuICogQHBhcmFtIGNyb3Nzb3JpZ2luIHtCb29sZWFufSBXaGV0aGVyIHJlcXVlc3RzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGNyb3Nzb3JpZ2luXG4gKi9cblBJWEkuQXNzZXRMb2FkZXIgPSBmdW5jdGlvbihhc3NldFVSTHMsIGNyb3Nzb3JpZ2luKVxue1xuICAgIFBJWEkuRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcnJheSBvZiBhc3NldCBVUkxzIHRoYXQgYXJlIGdvaW5nIHRvIGJlIGxvYWRlZFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGFzc2V0VVJMc1xuICAgICAqIEB0eXBlIEFycmF5PFN0cmluZz5cbiAgICAgKi9cbiAgICB0aGlzLmFzc2V0VVJMcyA9IGFzc2V0VVJMcztcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHJlcXVlc3RzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGNyb3NzIG9yaWdpblxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNyb3Nzb3JpZ2luXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMuY3Jvc3NvcmlnaW4gPSBjcm9zc29yaWdpbjtcblxuICAgIC8qKlxuICAgICAqIE1hcHMgZmlsZSBleHRlbnNpb24gdG8gbG9hZGVyIHR5cGVzXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbG9hZGVyc0J5VHlwZVxuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIHRoaXMubG9hZGVyc0J5VHlwZSA9IHtcbiAgICAgICAgJ2pwZyc6ICBQSVhJLkltYWdlTG9hZGVyLFxuICAgICAgICAnanBlZyc6IFBJWEkuSW1hZ2VMb2FkZXIsXG4gICAgICAgICdwbmcnOiAgUElYSS5JbWFnZUxvYWRlcixcbiAgICAgICAgJ2dpZic6ICBQSVhJLkltYWdlTG9hZGVyLFxuICAgICAgICAnd2VicCc6IFBJWEkuSW1hZ2VMb2FkZXIsXG4gICAgICAgICdqc29uJzogUElYSS5Kc29uTG9hZGVyLFxuICAgICAgICAnYXRsYXMnOiBQSVhJLkF0bGFzTG9hZGVyLFxuICAgICAgICAnYW5pbSc6IFBJWEkuU3BpbmVMb2FkZXIsXG4gICAgICAgICd4bWwnOiAgUElYSS5CaXRtYXBGb250TG9hZGVyLFxuICAgICAgICAnZm50JzogIFBJWEkuQml0bWFwRm9udExvYWRlclxuICAgIH07XG59O1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gYW4gaXRlbSBoYXMgbG9hZGVkXG4gKiBAZXZlbnQgb25Qcm9ncmVzc1xuICovXG5cbi8qKlxuICogRmlyZWQgd2hlbiBhbGwgdGhlIGFzc2V0cyBoYXZlIGxvYWRlZFxuICogQGV2ZW50IG9uQ29tcGxldGVcbiAqL1xuXG4vLyBjb25zdHJ1Y3RvclxuUElYSS5Bc3NldExvYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkFzc2V0TG9hZGVyO1xuXG4vKipcbiAqIEdpdmVuIGEgZmlsZW5hbWUsIHJldHVybnMgaXRzIGV4dGVuc2lvbiwgd2lsXG4gKlxuICogQG1ldGhvZCBfZ2V0RGF0YVR5cGVcbiAqIEBwYXJhbSBzdHIge1N0cmluZ30gdGhlIG5hbWUgb2YgdGhlIGFzc2V0XG4gKi9cblBJWEkuQXNzZXRMb2FkZXIucHJvdG90eXBlLl9nZXREYXRhVHlwZSA9IGZ1bmN0aW9uKHN0cilcbntcbiAgICB2YXIgdGVzdCA9ICdkYXRhOic7XG4gICAgLy9zdGFydHMgd2l0aCAnZGF0YTonXG4gICAgdmFyIHN0YXJ0ID0gc3RyLnNsaWNlKDAsIHRlc3QubGVuZ3RoKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChzdGFydCA9PT0gdGVzdCkge1xuICAgICAgICB2YXIgZGF0YSA9IHN0ci5zbGljZSh0ZXN0Lmxlbmd0aCk7XG5cbiAgICAgICAgdmFyIHNlcElkeCA9IGRhdGEuaW5kZXhPZignLCcpO1xuICAgICAgICBpZiAoc2VwSWR4ID09PSAtMSkgLy9tYWxmb3JtZWQgZGF0YSBVUkkgc2NoZW1lXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICAvL2UuZy4gJ2ltYWdlL2dpZjtiYXNlNjQnID0+ICdpbWFnZS9naWYnXG4gICAgICAgIHZhciBpbmZvID0gZGF0YS5zbGljZSgwLCBzZXBJZHgpLnNwbGl0KCc7JylbMF07XG5cbiAgICAgICAgLy9XZSBtaWdodCBuZWVkIHRvIGhhbmRsZSBzb21lIHNwZWNpYWwgY2FzZXMgaGVyZS4uLlxuICAgICAgICAvL3N0YW5kYXJkaXplIHRleHQvcGxhaW4gdG8gJ3R4dCcgZmlsZSBleHRlbnNpb25cbiAgICAgICAgaWYgKCFpbmZvIHx8IGluZm8udG9Mb3dlckNhc2UoKSA9PT0gJ3RleHQvcGxhaW4nKVxuICAgICAgICAgICAgcmV0dXJuICd0eHQnO1xuXG4gICAgICAgIC8vVXNlciBzcGVjaWZpZWQgbWltZSB0eXBlLCB0cnkgc3BsaXR0aW5nIGl0IGJ5ICcvJ1xuICAgICAgICByZXR1cm4gaW5mby5zcGxpdCgnLycpLnBvcCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBsb2FkaW5nIHRoZSBhc3NldHMgc2VxdWVudGlhbGx5XG4gKlxuICogQG1ldGhvZCBsb2FkXG4gKi9cblBJWEkuQXNzZXRMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIG9uTG9hZChldnQpIHtcbiAgICAgICAgc2NvcGUub25Bc3NldExvYWRlZChldnQuY29udGVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2FkQ291bnQgPSB0aGlzLmFzc2V0VVJMcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpPTA7IGkgPCB0aGlzLmFzc2V0VVJMcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBmaWxlTmFtZSA9IHRoaXMuYXNzZXRVUkxzW2ldO1xuICAgICAgICAvL2ZpcnN0IHNlZSBpZiB3ZSBoYXZlIGEgZGF0YSBVUkkgc2NoZW1lLi5cbiAgICAgICAgdmFyIGZpbGVUeXBlID0gdGhpcy5fZ2V0RGF0YVR5cGUoZmlsZU5hbWUpO1xuXG4gICAgICAgIC8vaWYgbm90LCBhc3N1bWUgaXQncyBhIGZpbGUgVVJJXG4gICAgICAgIGlmICghZmlsZVR5cGUpXG4gICAgICAgICAgICBmaWxlVHlwZSA9IGZpbGVOYW1lLnNwbGl0KCc/Jykuc2hpZnQoKS5zcGxpdCgnLicpLnBvcCgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcy5sb2FkZXJzQnlUeXBlW2ZpbGVUeXBlXTtcbiAgICAgICAgaWYoIUNvbnN0cnVjdG9yKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZpbGVUeXBlICsgJyBpcyBhbiB1bnN1cHBvcnRlZCBmaWxlIHR5cGUnKTtcblxuICAgICAgICB2YXIgbG9hZGVyID0gbmV3IENvbnN0cnVjdG9yKGZpbGVOYW1lLCB0aGlzLmNyb3Nzb3JpZ2luKTtcblxuICAgICAgICBsb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkJywgb25Mb2FkKTtcbiAgICAgICAgbG9hZGVyLmxvYWQoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEludm9rZWQgYWZ0ZXIgZWFjaCBmaWxlIGlzIGxvYWRlZFxuICpcbiAqIEBtZXRob2Qgb25Bc3NldExvYWRlZFxuICogQHByaXZhdGVcbiAqL1xuUElYSS5Bc3NldExvYWRlci5wcm90b3R5cGUub25Bc3NldExvYWRlZCA9IGZ1bmN0aW9uKGxvYWRlcilcbntcbiAgICB0aGlzLmxvYWRDb3VudC0tO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6ICdvblByb2dyZXNzJywgY29udGVudDogdGhpcywgbG9hZGVyOiBsb2FkZXIgfSk7XG4gICAgaWYgKHRoaXMub25Qcm9ncmVzcykgdGhpcy5vblByb2dyZXNzKGxvYWRlcik7XG5cbiAgICBpZiAoIXRoaXMubG9hZENvdW50KVxuICAgIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiAnb25Db21wbGV0ZScsIGNvbnRlbnQ6IHRoaXN9KTtcbiAgICAgICAgaWYodGhpcy5vbkNvbXBsZXRlKSB0aGlzLm9uQ29tcGxldGUoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogVGhlIGpzb24gZmlsZSBsb2FkZXIgaXMgdXNlZCB0byBsb2FkIGluIEpTT04gZGF0YSBhbmQgcGFyc2UgaXRcbiAqIFdoZW4gbG9hZGVkIHRoaXMgY2xhc3Mgd2lsbCBkaXNwYXRjaCBhICdsb2FkZWQnIGV2ZW50XG4gKiBJZiBsb2FkaW5nIGZhaWxzIHRoaXMgY2xhc3Mgd2lsbCBkaXNwYXRjaCBhbiAnZXJyb3InIGV2ZW50XG4gKlxuICogQGNsYXNzIEpzb25Mb2FkZXJcbiAqIEB1c2VzIEV2ZW50VGFyZ2V0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB1cmwge1N0cmluZ30gVGhlIHVybCBvZiB0aGUgSlNPTiBmaWxlXG4gKiBAcGFyYW0gY3Jvc3NvcmlnaW4ge0Jvb2xlYW59IFdoZXRoZXIgcmVxdWVzdHMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgY3Jvc3NvcmlnaW5cbiAqL1xuUElYSS5Kc29uTG9hZGVyID0gZnVuY3Rpb24gKHVybCwgY3Jvc3NvcmlnaW4pIHtcbiAgICBQSVhJLkV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdXJsIG9mIHRoZSBiaXRtYXAgZm9udCBkYXRhXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdXJsXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgdGhpcy51cmwgPSB1cmw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSByZXF1ZXN0cyBzaG91bGQgYmUgdHJlYXRlZCBhcyBjcm9zcyBvcmlnaW5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjcm9zc29yaWdpblxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLmNyb3Nzb3JpZ2luID0gY3Jvc3NvcmlnaW47XG5cbiAgICAvKipcbiAgICAgKiBbcmVhZC1vbmx5XSBUaGUgYmFzZSB1cmwgb2YgdGhlIGJpdG1hcCBmb250IGRhdGFcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBiYXNlVXJsXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5iYXNlVXJsID0gdXJsLnJlcGxhY2UoL1teXFwvXSokLywgJycpO1xuXG4gICAgLyoqXG4gICAgICogW3JlYWQtb25seV0gV2hldGhlciB0aGUgZGF0YSBoYXMgbG9hZGVkIHlldFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGxvYWRlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuXG59O1xuXG4vLyBjb25zdHJ1Y3RvclxuUElYSS5Kc29uTG9hZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuSnNvbkxvYWRlcjtcblxuLyoqXG4gKiBMb2FkcyB0aGUgSlNPTiBkYXRhXG4gKlxuICogQG1ldGhvZCBsb2FkXG4gKi9cblBJWEkuSnNvbkxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICBpZih3aW5kb3cuWERvbWFpblJlcXVlc3QgJiYgc2NvcGUuY3Jvc3NvcmlnaW4pXG4gICAge1xuICAgICAgICB0aGlzLmFqYXhSZXF1ZXN0ID0gbmV3IHdpbmRvdy5YRG9tYWluUmVxdWVzdCgpO1xuXG4gICAgICAgIC8vIFhEb21haW5SZXF1ZXN0IGhhcyBhIGZldyBxdWVya3MuIE9jY2FzaW9uYWxseSBpdCB3aWxsIGFib3J0IHJlcXVlc3RzXG4gICAgICAgIC8vIEEgd2F5IHRvIGF2b2lkIHRoaXMgaXMgdG8gbWFrZSBzdXJlIEFMTCBjYWxsYmFja3MgYXJlIHNldCBldmVuIGlmIG5vdCB1c2VkXG4gICAgICAgIC8vIE1vcmUgaW5mbyBoZXJlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE1Nzg2OTY2L3hkb21haW5yZXF1ZXN0LWFib3J0cy1wb3N0LW9uLWllLTlcbiAgICAgICAgdGhpcy5hamF4UmVxdWVzdC50aW1lb3V0ID0gMzAwMDtcblxuICAgICAgICB0aGlzLmFqYXhSZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzY29wZS5vbkVycm9yKCk7XG4gICAgICAgIH07XG4gICAgICAgICAgIFxuICAgICAgICB0aGlzLmFqYXhSZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNjb3BlLm9uRXJyb3IoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmFqYXhSZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHt9O1xuXG4gICAgfVxuICAgIGVsc2UgaWYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdClcbiAgICB7XG4gICAgICAgIHRoaXMuYWpheFJlcXVlc3QgPSBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMuYWpheFJlcXVlc3QgPSBuZXcgd2luZG93LkFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgfVxuXG4gICAgXG5cbiAgICB0aGlzLmFqYXhSZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgc2NvcGUub25KU09OTG9hZGVkKCk7XG4gICAgfTtcblxuICAgIHRoaXMuYWpheFJlcXVlc3Qub3BlbignR0VUJyx0aGlzLnVybCx0cnVlKTtcblxuICAgIHRoaXMuYWpheFJlcXVlc3Quc2VuZCgpO1xufTtcblxuLyoqXG4gKiBJbnZva2Ugd2hlbiBKU09OIGZpbGUgaXMgbG9hZGVkXG4gKlxuICogQG1ldGhvZCBvbkpTT05Mb2FkZWRcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuSnNvbkxvYWRlci5wcm90b3R5cGUub25KU09OTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIFxuICAgIGlmKCF0aGlzLmFqYXhSZXF1ZXN0LnJlc3BvbnNlVGV4dCApXG4gICAge1xuICAgICAgICB0aGlzLm9uRXJyb3IoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgIFxuICAgIHRoaXMuanNvbiA9IEpTT04ucGFyc2UodGhpcy5hamF4UmVxdWVzdC5yZXNwb25zZVRleHQpO1xuXG4gICAgaWYodGhpcy5qc29uLmZyYW1lcylcbiAgICB7XG4gICAgICAgIC8vIHNwcml0ZSBzaGVldFxuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgICAgICB2YXIgdGV4dHVyZVVybCA9IHRoaXMuYmFzZVVybCArIHRoaXMuanNvbi5tZXRhLmltYWdlO1xuICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgUElYSS5JbWFnZUxvYWRlcih0ZXh0dXJlVXJsLCB0aGlzLmNyb3Nzb3JpZ2luKTtcbiAgICAgICAgdmFyIGZyYW1lRGF0YSA9IHRoaXMuanNvbi5mcmFtZXM7XG5cbiAgICAgICAgdGhpcy50ZXh0dXJlID0gaW1hZ2UudGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzY29wZS5vbkxvYWRlZCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBpIGluIGZyYW1lRGF0YSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBmcmFtZURhdGFbaV0uZnJhbWU7XG5cbiAgICAgICAgICAgIGlmIChyZWN0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFBJWEkuVGV4dHVyZUNhY2hlW2ldID0gbmV3IFBJWEkuVGV4dHVyZSh0aGlzLnRleHR1cmUsIHtcbiAgICAgICAgICAgICAgICAgICAgeDogcmVjdC54LFxuICAgICAgICAgICAgICAgICAgICB5OiByZWN0LnksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiByZWN0LncsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogcmVjdC5oXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBQSVhJLlRleHR1cmVDYWNoZVtpXS5jcm9wID0gbmV3IFBJWEkuUmVjdGFuZ2xlKHJlY3QueCwgcmVjdC55LCByZWN0LncsIHJlY3QuaCk7XG5cbiAgICAgICAgICAgICAgICAvLyAgQ2hlY2sgdG8gc2VlIGlmIHRoZSBzcHJpdGUgaXMgdHJpbW1lZFxuICAgICAgICAgICAgICAgIGlmIChmcmFtZURhdGFbaV0udHJpbW1lZClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3R1YWxTaXplID0gZnJhbWVEYXRhW2ldLnNvdXJjZVNpemU7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFsU2l6ZSA9IGZyYW1lRGF0YVtpXS5zcHJpdGVTb3VyY2VTaXplO1xuICAgICAgICAgICAgICAgICAgICBQSVhJLlRleHR1cmVDYWNoZVtpXS50cmltID0gbmV3IFBJWEkuUmVjdGFuZ2xlKHJlYWxTaXplLngsIHJlYWxTaXplLnksIGFjdHVhbFNpemUudywgYWN0dWFsU2l6ZS5oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpbWFnZS5sb2FkKCk7XG5cbiAgICB9XG4gICAgZWxzZSBpZih0aGlzLmpzb24uYm9uZXMpXG4gICAge1xuICAgICAgICAvLyBzcGluZSBhbmltYXRpb25cbiAgICAgICAgdmFyIHNwaW5lSnNvblBhcnNlciA9IG5ldyBzcGluZS5Ta2VsZXRvbkpzb24oKTtcbiAgICAgICAgdmFyIHNrZWxldG9uRGF0YSA9IHNwaW5lSnNvblBhcnNlci5yZWFkU2tlbGV0b25EYXRhKHRoaXMuanNvbik7XG4gICAgICAgIFBJWEkuQW5pbUNhY2hlW3RoaXMudXJsXSA9IHNrZWxldG9uRGF0YTtcbiAgICAgICAgdGhpcy5vbkxvYWRlZCgpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLm9uTG9hZGVkKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBJbnZva2Ugd2hlbiBqc29uIGZpbGUgbG9hZGVkXG4gKlxuICogQG1ldGhvZCBvbkxvYWRlZFxuICogQHByaXZhdGVcbiAqL1xuUElYSS5Kc29uTG9hZGVyLnByb3RvdHlwZS5vbkxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgdHlwZTogJ2xvYWRlZCcsXG4gICAgICAgIGNvbnRlbnQ6IHRoaXNcbiAgICB9KTtcbn07XG5cbi8qKlxuICogSW52b2tlIHdoZW4gZXJyb3Igb2NjdXJlZFxuICpcbiAqIEBtZXRob2Qgb25FcnJvclxuICogQHByaXZhdGVcbiAqL1xuUElYSS5Kc29uTG9hZGVyLnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgY29udGVudDogdGhpc1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hcnRpbiBLZWxtIGh0dHA6Ly9ta2VsbS5naXRodWIuY29tXG4gKi9cblxuLyoqXG4gKiBUaGUgYXRsYXMgZmlsZSBsb2FkZXIgaXMgdXNlZCB0byBsb2FkIGluIEF0bGFzIGRhdGEgYW5kIHBhcnNlIGl0XG4gKiBXaGVuIGxvYWRlZCB0aGlzIGNsYXNzIHdpbGwgZGlzcGF0Y2ggYSAnbG9hZGVkJyBldmVudFxuICogSWYgbG9hZGluZyBmYWlscyB0aGlzIGNsYXNzIHdpbGwgZGlzcGF0Y2ggYW4gJ2Vycm9yJyBldmVudFxuICogQGNsYXNzIEF0bGFzTG9hZGVyXG4gKiBAZXh0ZW5kcyBFdmVudFRhcmdldFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIHRoZSB1cmwgb2YgdGhlIEpTT04gZmlsZVxuICogQHBhcmFtIHtCb29sZWFufSBjcm9zc29yaWdpblxuICovXG5cblBJWEkuQXRsYXNMb2FkZXIgPSBmdW5jdGlvbiAodXJsLCBjcm9zc29yaWdpbikge1xuICAgIFBJWEkuRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLmJhc2VVcmwgPSB1cmwucmVwbGFjZSgvW15cXC9dKiQvLCAnJyk7XG4gICAgdGhpcy5jcm9zc29yaWdpbiA9IGNyb3Nzb3JpZ2luO1xuICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG5cbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLkF0bGFzTG9hZGVyLmNvbnN0cnVjdG9yID0gUElYSS5BdGxhc0xvYWRlcjtcblxuXG4gLyoqXG4gKiBTdGFydHMgbG9hZGluZyB0aGUgSlNPTiBmaWxlXG4gKlxuICogQG1ldGhvZCBsb2FkXG4gKi9cblBJWEkuQXRsYXNMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hamF4UmVxdWVzdCA9IG5ldyBQSVhJLkFqYXhSZXF1ZXN0KCk7XG4gICAgdGhpcy5hamF4UmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB0aGlzLm9uQXRsYXNMb2FkZWQuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuYWpheFJlcXVlc3Qub3BlbignR0VUJywgdGhpcy51cmwsIHRydWUpO1xuICAgIGlmICh0aGlzLmFqYXhSZXF1ZXN0Lm92ZXJyaWRlTWltZVR5cGUpIHRoaXMuYWpheFJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZSgnYXBwbGljYXRpb24vanNvbicpO1xuICAgIHRoaXMuYWpheFJlcXVlc3Quc2VuZChudWxsKTtcbn07XG5cbi8qKlxuICogSW52b2tlIHdoZW4gSlNPTiBmaWxlIGlzIGxvYWRlZFxuICogQG1ldGhvZCBvbkF0bGFzTG9hZGVkXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkF0bGFzTG9hZGVyLnByb3RvdHlwZS5vbkF0bGFzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmFqYXhSZXF1ZXN0LnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgaWYgKHRoaXMuYWpheFJlcXVlc3Quc3RhdHVzID09PSAyMDAgfHwgd2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZignaHR0cCcpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5hdGxhcyA9IHtcbiAgICAgICAgICAgICAgICBtZXRhIDoge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZSA6IFtdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmcmFtZXMgOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmFqYXhSZXF1ZXN0LnJlc3BvbnNlVGV4dC5zcGxpdCgvXFxyP1xcbi8pO1xuICAgICAgICAgICAgdmFyIGxpbmVDb3VudCA9IC0zO1xuXG4gICAgICAgICAgICB2YXIgY3VycmVudEltYWdlSWQgPSAwO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRGcmFtZSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgbmFtZUluTmV4dExpbmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgICAgIGogPSAwLFxuICAgICAgICAgICAgICAgIHNlbGZPbkxvYWRlZCA9IHRoaXMub25Mb2FkZWQuYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgLy8gcGFyc2VyIHdpdGhvdXQgcm90YXRpb24gc3VwcG9ydCB5ZXQhXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gcmVzdWx0W2ldLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0W2ldID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBuYW1lSW5OZXh0TGluZSA9IGkrMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdFtpXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lSW5OZXh0TGluZSA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdGxhcy5tZXRhLmltYWdlLnB1c2gocmVzdWx0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbWFnZUlkID0gdGhpcy5hdGxhcy5tZXRhLmltYWdlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0bGFzLmZyYW1lcy5wdXNoKHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVDb3VudCA9IC0zO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpbmVDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lQ291bnQgJSA3ID09PSAxKSB7IC8vIGZyYW1lIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEZyYW1lICE9IG51bGwpIHsgLy9qc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdGxhcy5mcmFtZXNbY3VycmVudEltYWdlSWRdW2N1cnJlbnRGcmFtZS5uYW1lXSA9IGN1cnJlbnRGcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZyYW1lID0geyBuYW1lOiByZXN1bHRbaV0sIGZyYW1lIDoge30gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSByZXN1bHRbaV0uc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZUNvdW50ICUgNyA9PT0gMykgeyAvLyBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RnJhbWUuZnJhbWUueCA9IE51bWJlcih0ZXh0WzFdLnJlcGxhY2UoJywnLCAnJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RnJhbWUuZnJhbWUueSA9IE51bWJlcih0ZXh0WzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpbmVDb3VudCAlIDcgPT09IDQpIHsgLy8gc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RnJhbWUuZnJhbWUudyA9IE51bWJlcih0ZXh0WzFdLnJlcGxhY2UoJywnLCAnJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RnJhbWUuZnJhbWUuaCA9IE51bWJlcih0ZXh0WzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpbmVDb3VudCAlIDcgPT09IDUpIHsgLy8gcmVhbCBzaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWFsU2l6ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3IDogTnVtYmVyKHRleHRbMV0ucmVwbGFjZSgnLCcsICcnKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoIDogTnVtYmVyKHRleHRbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWxTaXplLncgPiBjdXJyZW50RnJhbWUuZnJhbWUudyB8fCByZWFsU2l6ZS5oID4gY3VycmVudEZyYW1lLmZyYW1lLmgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGcmFtZS50cmltbWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGcmFtZS5yZWFsU2l6ZSA9IHJlYWxTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZyYW1lLnRyaW1tZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsaW5lQ291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50RnJhbWUgIT0gbnVsbCkgeyAvL2pzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgICAgIHRoaXMuYXRsYXMuZnJhbWVzW2N1cnJlbnRJbWFnZUlkXVtjdXJyZW50RnJhbWUubmFtZV0gPSBjdXJyZW50RnJhbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmF0bGFzLm1ldGEuaW1hZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXMuYXRsYXMubWV0YS5pbWFnZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBzcHJpdGUgc2hlZXRcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHR1cmVVcmwgPSB0aGlzLmJhc2VVcmwgKyB0aGlzLmF0bGFzLm1ldGEuaW1hZ2Vbal07XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZURhdGEgPSB0aGlzLmF0bGFzLmZyYW1lc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZXMucHVzaChuZXcgUElYSS5JbWFnZUxvYWRlcih0ZXh0dXJlVXJsLCB0aGlzLmNyb3Nzb3JpZ2luKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpIGluIGZyYW1lRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBmcmFtZURhdGFbaV0uZnJhbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBJWEkuVGV4dHVyZUNhY2hlW2ldID0gbmV3IFBJWEkuVGV4dHVyZSh0aGlzLmltYWdlc1tqXS50ZXh0dXJlLmJhc2VUZXh0dXJlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHJlY3QueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogcmVjdC55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogcmVjdC53LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHJlY3QuaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZURhdGFbaV0udHJpbW1lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQSVhJLlRleHR1cmVDYWNoZVtpXS5yZWFsU2l6ZSA9IGZyYW1lRGF0YVtpXS5yZWFsU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJpbSBpbiBwaXhpIG5vdCBzdXBwb3J0ZWQgeWV0LCB0b2RvIHVwZGF0ZSB0cmltIHByb3BlcnRpZXMgaWYgaXQgaXMgZG9uZSAuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUElYSS5UZXh0dXJlQ2FjaGVbaV0udHJpbS54ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUElYSS5UZXh0dXJlQ2FjaGVbaV0udHJpbS55ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRJbWFnZUlkID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdGhpcy5pbWFnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZXNbal0uYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkJywgc2VsZk9uTG9hZGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbWFnZXNbdGhpcy5jdXJyZW50SW1hZ2VJZF0ubG9hZCgpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub25Mb2FkZWQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEludm9rZSB3aGVuIGpzb24gZmlsZSBoYXMgbG9hZGVkXG4gKiBAbWV0aG9kIG9uTG9hZGVkXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkF0bGFzTG9hZGVyLnByb3RvdHlwZS5vbkxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pbWFnZXMubGVuZ3RoIC0gMSA+IHRoaXMuY3VycmVudEltYWdlSWQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50SW1hZ2VJZCsrO1xuICAgICAgICB0aGlzLmltYWdlc1t0aGlzLmN1cnJlbnRJbWFnZUlkXS5sb2FkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgdHlwZTogJ2xvYWRlZCcsXG4gICAgICAgICAgICBjb250ZW50OiB0aGlzXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogSW52b2tlIHdoZW4gZXJyb3Igb2NjdXJlZFxuICogQG1ldGhvZCBvbkVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkF0bGFzTG9hZGVyLnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgIGNvbnRlbnQ6IHRoaXNcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKiBUaGUgc3ByaXRlIHNoZWV0IGxvYWRlciBpcyB1c2VkIHRvIGxvYWQgaW4gSlNPTiBzcHJpdGUgc2hlZXQgZGF0YVxuICogVG8gZ2VuZXJhdGUgdGhlIGRhdGEgeW91IGNhbiB1c2UgaHR0cDovL3d3dy5jb2RlYW5kd2ViLmNvbS90ZXh0dXJlcGFja2VyIGFuZCBwdWJsaXNoIGluIHRoZSAnSlNPTicgZm9ybWF0XG4gKiBUaGVyZSBpcyBhIGZyZWUgdmVyc2lvbiBzbyB0aGF0cyBuaWNlLCBhbHRob3VnaCB0aGUgcGFpZCB2ZXJzaW9uIGlzIGdyZWF0IHZhbHVlIGZvciBtb25leS5cbiAqIEl0IGlzIGhpZ2hseSByZWNvbW1lbmRlZCB0byB1c2UgU3ByaXRlIHNoZWV0cyAoYWxzbyBrbm93IGFzIGEgJ3RleHR1cmUgYXRsYXMnKSBhcyBpdCBtZWFucyBzcHJpdGVzIGNhbiBiZSBiYXRjaGVkIGFuZCBkcmF3biB0b2dldGhlciBmb3IgaGlnaGx5IGluY3JlYXNlZCByZW5kZXJpbmcgc3BlZWQuXG4gKiBPbmNlIHRoZSBkYXRhIGhhcyBiZWVuIGxvYWRlZCB0aGUgZnJhbWVzIGFyZSBzdG9yZWQgaW4gdGhlIFBJWEkgdGV4dHVyZSBjYWNoZSBhbmQgY2FuIGJlIGFjY2Vzc2VkIHRob3VnaCBQSVhJLlRleHR1cmUuZnJvbUZyYW1lSWQoKSBhbmQgUElYSS5TcHJpdGUuZnJvbUZyYW1lSWQoKVxuICogVGhpcyBsb2FkZXIgd2lsbCBsb2FkIHRoZSBpbWFnZSBmaWxlIHRoYXQgdGhlIFNwcml0ZXNoZWV0IHBvaW50cyB0byBhcyB3ZWxsIGFzIHRoZSBkYXRhLlxuICogV2hlbiBsb2FkZWQgdGhpcyBjbGFzcyB3aWxsIGRpc3BhdGNoIGEgJ2xvYWRlZCcgZXZlbnRcbiAqXG4gKiBAY2xhc3MgU3ByaXRlU2hlZXRMb2FkZXJcbiAqIEB1c2VzIEV2ZW50VGFyZ2V0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB1cmwge1N0cmluZ30gVGhlIHVybCBvZiB0aGUgc3ByaXRlIHNoZWV0IEpTT04gZmlsZVxuICogQHBhcmFtIGNyb3Nzb3JpZ2luIHtCb29sZWFufSBXaGV0aGVyIHJlcXVlc3RzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGNyb3Nzb3JpZ2luXG4gKi9cblBJWEkuU3ByaXRlU2hlZXRMb2FkZXIgPSBmdW5jdGlvbiAodXJsLCBjcm9zc29yaWdpbikge1xuICAgIC8qXG4gICAgICogaSB1c2UgdGV4dHVyZSBwYWNrZXIgdG8gbG9hZCB0aGUgYXNzZXRzLi5cbiAgICAgKiBodHRwOi8vd3d3LmNvZGVhbmR3ZWIuY29tL3RleHR1cmVwYWNrZXJcbiAgICAgKiBtYWtlIHN1cmUgdG8gc2V0IHRoZSBmb3JtYXQgYXMgJ0pTT04nXG4gICAgICovXG4gICAgUElYSS5FdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHVybCBvZiB0aGUgYml0bWFwIGZvbnQgZGF0YVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHVybFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIHRoaXMudXJsID0gdXJsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVxdWVzdHMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgY3Jvc3Mgb3JpZ2luXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY3Jvc3NvcmlnaW5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5jcm9zc29yaWdpbiA9IGNyb3Nzb3JpZ2luO1xuXG4gICAgLyoqXG4gICAgICogW3JlYWQtb25seV0gVGhlIGJhc2UgdXJsIG9mIHRoZSBiaXRtYXAgZm9udCBkYXRhXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYmFzZVVybFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMuYmFzZVVybCA9IHVybC5yZXBsYWNlKC9bXlxcL10qJC8sICcnKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0dXJlIGJlaW5nIGxvYWRlZFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRleHR1cmVcbiAgICAgKiBAdHlwZSBUZXh0dXJlXG4gICAgICovXG4gICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFtZXMgb2YgdGhlIHNwcml0ZSBzaGVldFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGZyYW1lc1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIHRoaXMuZnJhbWVzID0ge307XG59O1xuXG4vLyBjb25zdHJ1Y3RvclxuUElYSS5TcHJpdGVTaGVldExvYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLlNwcml0ZVNoZWV0TG9hZGVyO1xuXG4vKipcbiAqIFRoaXMgd2lsbCBiZWdpbiBsb2FkaW5nIHRoZSBKU09OIGZpbGVcbiAqXG4gKiBAbWV0aG9kIGxvYWRcbiAqL1xuUElYSS5TcHJpdGVTaGVldExvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgIHZhciBqc29uTG9hZGVyID0gbmV3IFBJWEkuSnNvbkxvYWRlcih0aGlzLnVybCwgdGhpcy5jcm9zc29yaWdpbik7XG4gICAganNvbkxvYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc2NvcGUuanNvbiA9IGV2ZW50LmNvbnRlbnQuanNvbjtcbiAgICAgICAgc2NvcGUub25Mb2FkZWQoKTtcbiAgICB9KTtcbiAgICBqc29uTG9hZGVyLmxvYWQoKTtcbn07XG5cbi8qKlxuICogSW52b2tlIHdoZW4gYWxsIGZpbGVzIGFyZSBsb2FkZWQgKGpzb24gYW5kIHRleHR1cmUpXG4gKlxuICogQG1ldGhvZCBvbkxvYWRlZFxuICogQHByaXZhdGVcbiAqL1xuUElYSS5TcHJpdGVTaGVldExvYWRlci5wcm90b3R5cGUub25Mb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgdHlwZTogJ2xvYWRlZCcsXG4gICAgICAgIGNvbnRlbnQ6IHRoaXNcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKiBUaGUgaW1hZ2UgbG9hZGVyIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciBsb2FkaW5nIGltYWdlcyBmaWxlIGZvcm1hdHMgKCdqcGVnJywgJ2pwZycsICdwbmcnIGFuZCAnZ2lmJylcbiAqIE9uY2UgdGhlIGltYWdlIGhhcyBiZWVuIGxvYWRlZCBpdCBpcyBzdG9yZWQgaW4gdGhlIFBJWEkgdGV4dHVyZSBjYWNoZSBhbmQgY2FuIGJlIGFjY2Vzc2VkIHRob3VnaCBQSVhJLlRleHR1cmUuZnJvbUZyYW1lSWQoKSBhbmQgUElYSS5TcHJpdGUuZnJvbUZyYW1lSWQoKVxuICogV2hlbiBsb2FkZWQgdGhpcyBjbGFzcyB3aWxsIGRpc3BhdGNoIGEgJ2xvYWRlZCcgZXZlbnRcbiAqXG4gKiBAY2xhc3MgSW1hZ2VMb2FkZXJcbiAqIEB1c2VzIEV2ZW50VGFyZ2V0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB1cmwge1N0cmluZ30gVGhlIHVybCBvZiB0aGUgaW1hZ2VcbiAqIEBwYXJhbSBjcm9zc29yaWdpbiB7Qm9vbGVhbn0gV2hldGhlciByZXF1ZXN0cyBzaG91bGQgYmUgdHJlYXRlZCBhcyBjcm9zc29yaWdpblxuICovXG5QSVhJLkltYWdlTG9hZGVyID0gZnVuY3Rpb24odXJsLCBjcm9zc29yaWdpbilcbntcbiAgICBQSVhJLkV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dHVyZSBiZWluZyBsb2FkZWRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0ZXh0dXJlXG4gICAgICogQHR5cGUgVGV4dHVyZVxuICAgICAqL1xuICAgIHRoaXMudGV4dHVyZSA9IFBJWEkuVGV4dHVyZS5mcm9tSW1hZ2UodXJsLCBjcm9zc29yaWdpbik7XG5cbiAgICAvKipcbiAgICAgKiBpZiB0aGUgaW1hZ2UgaXMgbG9hZGVkIHdpdGggbG9hZEZyYW1lZFNwcml0ZVNoZWV0XG4gICAgICogZnJhbWVzIHdpbGwgY29udGFpbiB0aGUgc3ByaXRlIHNoZWV0IGZyYW1lc1xuICAgICAqXG4gICAgICovXG4gICAgdGhpcy5mcmFtZXMgPSBbXTtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLkltYWdlTG9hZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuSW1hZ2VMb2FkZXI7XG5cbi8qKlxuICogTG9hZHMgaW1hZ2Ugb3IgdGFrZXMgaXQgZnJvbSBjYWNoZVxuICpcbiAqIEBtZXRob2QgbG9hZFxuICovXG5QSVhJLkltYWdlTG9hZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24oKVxue1xuICAgIGlmKCF0aGlzLnRleHR1cmUuYmFzZVRleHR1cmUuaGFzTG9hZGVkKVxuICAgIHtcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICAgICAgdGhpcy50ZXh0dXJlLmJhc2VUZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZCcsIGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgc2NvcGUub25Mb2FkZWQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMub25Mb2FkZWQoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEludm9rZWQgd2hlbiBpbWFnZSBmaWxlIGlzIGxvYWRlZCBvciBpdCBpcyBhbHJlYWR5IGNhY2hlZCBhbmQgcmVhZHkgdG8gdXNlXG4gKlxuICogQG1ldGhvZCBvbkxvYWRlZFxuICogQHByaXZhdGVcbiAqL1xuUElYSS5JbWFnZUxvYWRlci5wcm90b3R5cGUub25Mb2FkZWQgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiAnbG9hZGVkJywgY29udGVudDogdGhpc30pO1xufTtcblxuLyoqXG4gKiBMb2FkcyBpbWFnZSBhbmQgc3BsaXQgaXQgdG8gdW5pZm9ybSBzaXplZCBmcmFtZXNcbiAqXG4gKlxuICogQG1ldGhvZCBsb2FkRnJhbWVkU3ByaXRlU2hlZXRcbiAqIEBwYXJhbSBmcmFtZVdpZHRoIHtOdW1iZXJ9IHdpZHRoIG9mIGVhY2ggZnJhbWVcbiAqIEBwYXJhbSBmcmFtZUhlaWdodCB7TnVtYmVyfSBoZWlnaHQgb2YgZWFjaCBmcmFtZVxuICogQHBhcmFtIHRleHR1cmVOYW1lIHtTdHJpbmd9IGlmIGdpdmVuLCB0aGUgZnJhbWVzIHdpbGwgYmUgY2FjaGVkIGluIDx0ZXh0dXJlTmFtZT4tPG9yZD4gZm9ybWF0XG4gKi9cblBJWEkuSW1hZ2VMb2FkZXIucHJvdG90eXBlLmxvYWRGcmFtZWRTcHJpdGVTaGVldCA9IGZ1bmN0aW9uKGZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0LCB0ZXh0dXJlTmFtZSlcbntcbiAgICB0aGlzLmZyYW1lcyA9IFtdO1xuICAgIHZhciBjb2xzID0gTWF0aC5mbG9vcih0aGlzLnRleHR1cmUud2lkdGggLyBmcmFtZVdpZHRoKTtcbiAgICB2YXIgcm93cyA9IE1hdGguZmxvb3IodGhpcy50ZXh0dXJlLmhlaWdodCAvIGZyYW1lSGVpZ2h0KTtcblxuICAgIHZhciBpPTA7XG4gICAgZm9yICh2YXIgeT0wOyB5PHJvd3M7IHkrKylcbiAgICB7XG4gICAgICAgIGZvciAodmFyIHg9MDsgeDxjb2xzOyB4KyssaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IG5ldyBQSVhJLlRleHR1cmUodGhpcy50ZXh0dXJlLCB7XG4gICAgICAgICAgICAgICAgeDogeCpmcmFtZVdpZHRoLFxuICAgICAgICAgICAgICAgIHk6IHkqZnJhbWVIZWlnaHQsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGZyYW1lV2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBmcmFtZUhlaWdodFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuZnJhbWVzLnB1c2godGV4dHVyZSk7XG4gICAgICAgICAgICBpZiAodGV4dHVyZU5hbWUpIFBJWEkuVGV4dHVyZUNhY2hlW3RleHR1cmVOYW1lICsgJy0nICsgaV0gPSB0ZXh0dXJlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoIXRoaXMudGV4dHVyZS5iYXNlVGV4dHVyZS5oYXNMb2FkZWQpXG4gICAge1xuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgICAgICB0aGlzLnRleHR1cmUuYmFzZVRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzY29wZS5vbkxvYWRlZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5vbkxvYWRlZCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKiBUaGUgeG1sIGxvYWRlciBpcyB1c2VkIHRvIGxvYWQgaW4gWE1MIGJpdG1hcCBmb250IGRhdGEgKCd4bWwnIG9yICdmbnQnKVxuICogVG8gZ2VuZXJhdGUgdGhlIGRhdGEgeW91IGNhbiB1c2UgaHR0cDovL3d3dy5hbmdlbGNvZGUuY29tL3Byb2R1Y3RzL2JtZm9udC9cbiAqIFRoaXMgbG9hZGVyIHdpbGwgYWxzbyBsb2FkIHRoZSBpbWFnZSBmaWxlIGFzIHRoZSBkYXRhLlxuICogV2hlbiBsb2FkZWQgdGhpcyBjbGFzcyB3aWxsIGRpc3BhdGNoIGEgJ2xvYWRlZCcgZXZlbnRcbiAqXG4gKiBAY2xhc3MgQml0bWFwRm9udExvYWRlclxuICogQHVzZXMgRXZlbnRUYXJnZXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHVybCB7U3RyaW5nfSBUaGUgdXJsIG9mIHRoZSBzcHJpdGUgc2hlZXQgSlNPTiBmaWxlXG4gKiBAcGFyYW0gY3Jvc3NvcmlnaW4ge0Jvb2xlYW59IFdoZXRoZXIgcmVxdWVzdHMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgY3Jvc3NvcmlnaW5cbiAqL1xuUElYSS5CaXRtYXBGb250TG9hZGVyID0gZnVuY3Rpb24odXJsLCBjcm9zc29yaWdpbilcbntcbiAgICAvKlxuICAgICAqIEkgdXNlIHRleHR1cmUgcGFja2VyIHRvIGxvYWQgdGhlIGFzc2V0cy4uXG4gICAgICogaHR0cDovL3d3dy5jb2RlYW5kd2ViLmNvbS90ZXh0dXJlcGFja2VyXG4gICAgICogbWFrZSBzdXJlIHRvIHNldCB0aGUgZm9ybWF0IGFzICdKU09OJ1xuICAgICAqL1xuICAgIFBJWEkuRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB1cmwgb2YgdGhlIGJpdG1hcCBmb250IGRhdGFcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB1cmxcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICB0aGlzLnVybCA9IHVybDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHJlcXVlc3RzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGNyb3NzIG9yaWdpblxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNyb3Nzb3JpZ2luXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMuY3Jvc3NvcmlnaW4gPSBjcm9zc29yaWdpbjtcblxuICAgIC8qKlxuICAgICAqIFtyZWFkLW9ubHldIFRoZSBiYXNlIHVybCBvZiB0aGUgYml0bWFwIGZvbnQgZGF0YVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJhc2VVcmxcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmJhc2VVcmwgPSB1cmwucmVwbGFjZSgvW15cXC9dKiQvLCAnJyk7XG5cbiAgICAvKipcbiAgICAgKiBbcmVhZC1vbmx5XSBUaGUgdGV4dHVyZSBvZiB0aGUgYml0bWFwIGZvbnRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBiYXNlVXJsXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLkJpdG1hcEZvbnRMb2FkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5CaXRtYXBGb250TG9hZGVyO1xuXG4vKipcbiAqIExvYWRzIHRoZSBYTUwgZm9udCBkYXRhXG4gKlxuICogQG1ldGhvZCBsb2FkXG4gKi9cblBJWEkuQml0bWFwRm9udExvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmFqYXhSZXF1ZXN0ID0gbmV3IFBJWEkuQWpheFJlcXVlc3QoKTtcbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgIHRoaXMuYWpheFJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgc2NvcGUub25YTUxMb2FkZWQoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5hamF4UmVxdWVzdC5vcGVuKCdHRVQnLCB0aGlzLnVybCwgdHJ1ZSk7XG4gICAgaWYgKHRoaXMuYWpheFJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZSkgdGhpcy5hamF4UmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlKCdhcHBsaWNhdGlvbi94bWwnKTtcbiAgICB0aGlzLmFqYXhSZXF1ZXN0LnNlbmQobnVsbCk7XG59O1xuXG4vKipcbiAqIEludm9rZWQgd2hlbiB0aGUgWE1MIGZpbGUgaXMgbG9hZGVkLCBwYXJzZXMgdGhlIGRhdGFcbiAqXG4gKiBAbWV0aG9kIG9uWE1MTG9hZGVkXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkJpdG1hcEZvbnRMb2FkZXIucHJvdG90eXBlLm9uWE1MTG9hZGVkID0gZnVuY3Rpb24oKVxue1xuICAgIGlmICh0aGlzLmFqYXhSZXF1ZXN0LnJlYWR5U3RhdGUgPT09IDQpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5hamF4UmVxdWVzdC5zdGF0dXMgPT09IDIwMCB8fCB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZignaHR0cCcpID09PSAtMSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlWE1MID0gdGhpcy5hamF4UmVxdWVzdC5yZXNwb25zZVhNTDtcbiAgICAgICAgICAgIGlmKCFyZXNwb25zZVhNTCB8fCAvTVNJRSA5L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBuYXZpZ2F0b3IuaXNDb2Nvb25KUykge1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZih3aW5kb3cuRE9NUGFyc2VyKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9tcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVhNTCA9IGRvbXBhcnNlci5wYXJzZUZyb21TdHJpbmcodGhpcy5hamF4UmVxdWVzdC5yZXNwb25zZVRleHQsICd0ZXh0L3htbCcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IHRoaXMuYWpheFJlcXVlc3QucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVhNTCA9IGRpdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0ZXh0dXJlVXJsID0gdGhpcy5iYXNlVXJsICsgcmVzcG9uc2VYTUwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3BhZ2UnKVswXS5nZXRBdHRyaWJ1dGUoJ2ZpbGUnKTtcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IG5ldyBQSVhJLkltYWdlTG9hZGVyKHRleHR1cmVVcmwsIHRoaXMuY3Jvc3NvcmlnaW4pO1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlID0gaW1hZ2UudGV4dHVyZS5iYXNlVGV4dHVyZTtcblxuICAgICAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgICAgIHZhciBpbmZvID0gcmVzcG9uc2VYTUwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2luZm8nKVswXTtcbiAgICAgICAgICAgIHZhciBjb21tb24gPSByZXNwb25zZVhNTC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY29tbW9uJylbMF07XG4gICAgICAgICAgICBkYXRhLmZvbnQgPSBpbmZvLmdldEF0dHJpYnV0ZSgnZmFjZScpO1xuICAgICAgICAgICAgZGF0YS5zaXplID0gcGFyc2VJbnQoaW5mby5nZXRBdHRyaWJ1dGUoJ3NpemUnKSwgMTApO1xuICAgICAgICAgICAgZGF0YS5saW5lSGVpZ2h0ID0gcGFyc2VJbnQoY29tbW9uLmdldEF0dHJpYnV0ZSgnbGluZUhlaWdodCcpLCAxMCk7XG4gICAgICAgICAgICBkYXRhLmNoYXJzID0ge307XG5cbiAgICAgICAgICAgIC8vcGFyc2UgbGV0dGVyc1xuICAgICAgICAgICAgdmFyIGxldHRlcnMgPSByZXNwb25zZVhNTC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2hhcicpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldHRlcnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gcGFyc2VJbnQobGV0dGVyc1tpXS5nZXRBdHRyaWJ1dGUoJ2lkJyksIDEwKTtcblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0dXJlUmVjdCA9IG5ldyBQSVhJLlJlY3RhbmdsZShcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQobGV0dGVyc1tpXS5nZXRBdHRyaWJ1dGUoJ3gnKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChsZXR0ZXJzW2ldLmdldEF0dHJpYnV0ZSgneScpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGxldHRlcnNbaV0uZ2V0QXR0cmlidXRlKCd3aWR0aCcpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGxldHRlcnNbaV0uZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSwgMTApXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGRhdGEuY2hhcnNbY2hhckNvZGVdID0ge1xuICAgICAgICAgICAgICAgICAgICB4T2Zmc2V0OiBwYXJzZUludChsZXR0ZXJzW2ldLmdldEF0dHJpYnV0ZSgneG9mZnNldCcpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIHlPZmZzZXQ6IHBhcnNlSW50KGxldHRlcnNbaV0uZ2V0QXR0cmlidXRlKCd5b2Zmc2V0JyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgeEFkdmFuY2U6IHBhcnNlSW50KGxldHRlcnNbaV0uZ2V0QXR0cmlidXRlKCd4YWR2YW5jZScpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIGtlcm5pbmc6IHt9LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlOiBQSVhJLlRleHR1cmVDYWNoZVtjaGFyQ29kZV0gPSBuZXcgUElYSS5UZXh0dXJlKHRoaXMudGV4dHVyZSwgdGV4dHVyZVJlY3QpXG5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3BhcnNlIGtlcm5pbmdzXG4gICAgICAgICAgICB2YXIga2VybmluZ3MgPSByZXNwb25zZVhNTC5nZXRFbGVtZW50c0J5VGFnTmFtZSgna2VybmluZycpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGtlcm5pbmdzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IHBhcnNlSW50KGtlcm5pbmdzW2ldLmdldEF0dHJpYnV0ZSgnZmlyc3QnKSwgMTApO1xuICAgICAgICAgICAgICAgIHZhciBzZWNvbmQgPSBwYXJzZUludChrZXJuaW5nc1tpXS5nZXRBdHRyaWJ1dGUoJ3NlY29uZCcpLCAxMCk7XG4gICAgICAgICAgICAgICAgdmFyIGFtb3VudCA9IHBhcnNlSW50KGtlcm5pbmdzW2ldLmdldEF0dHJpYnV0ZSgnYW1vdW50JyksIDEwKTtcblxuICAgICAgICAgICAgICAgIGRhdGEuY2hhcnNbc2Vjb25kXS5rZXJuaW5nW2ZpcnN0XSA9IGFtb3VudDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBQSVhJLkJpdG1hcFRleHQuZm9udHNbZGF0YS5mb250XSA9IGRhdGE7XG5cbiAgICAgICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICAgICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzY29wZS5vbkxvYWRlZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbWFnZS5sb2FkKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEludm9rZWQgd2hlbiBhbGwgZmlsZXMgYXJlIGxvYWRlZCAoeG1sL2ZudCBhbmQgdGV4dHVyZSlcbiAqXG4gKiBAbWV0aG9kIG9uTG9hZGVkXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkJpdG1hcEZvbnRMb2FkZXIucHJvdG90eXBlLm9uTG9hZGVkID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZTogJ2xvYWRlZCcsIGNvbnRlbnQ6IHRoaXN9KTtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKiBiYXNlZCBvbiBwaXhpIGltcGFjdCBzcGluZSBpbXBsZW1lbnRhdGlvbiBtYWRlIGJ5IEVlbWVsaSBLZWxva29ycGkgKEBla2Vsb2tvcnBpKSBodHRwczovL2dpdGh1Yi5jb20vZWtlbG9rb3JwaVxuICpcbiAqIEF3ZXNvbWUgSlMgcnVuIHRpbWUgcHJvdmlkZWQgYnkgRXNvdGVyaWNTb2Z0d2FyZVxuICogaHR0cHM6Ly9naXRodWIuY29tL0Vzb3RlcmljU29mdHdhcmUvc3BpbmUtcnVudGltZXNcbiAqXG4gKi9cblxuLyoqXG4gKiBUaGUgU3BpbmUgbG9hZGVyIGlzIHVzZWQgdG8gbG9hZCBpbiBKU09OIHNwaW5lIGRhdGFcbiAqIFRvIGdlbmVyYXRlIHRoZSBkYXRhIHlvdSBuZWVkIHRvIHVzZSBodHRwOi8vZXNvdGVyaWNzb2Z0d2FyZS5jb20vIGFuZCBleHBvcnQgaW4gdGhlIFwiSlNPTlwiIGZvcm1hdFxuICogRHVlIHRvIGEgY2xhc2ggb2YgbmFtZXMgIFlvdSB3aWxsIG5lZWQgdG8gY2hhbmdlIHRoZSBleHRlbnNpb24gb2YgdGhlIHNwaW5lIGZpbGUgZnJvbSAqLmpzb24gdG8gKi5hbmltIGZvciBpdCB0byBsb2FkXG4gKiBTZWUgZXhhbXBsZSAxMiAoaHR0cDovL3d3dy5nb29kYm95ZGlnaXRhbC5jb20vcGl4aWpzL2V4YW1wbGVzLzEyLykgdG8gc2VlIGEgd29ya2luZyBleGFtcGxlIGFuZCBjaGVjayBvdXQgdGhlIHNvdXJjZVxuICogWW91IHdpbGwgbmVlZCB0byBnZW5lcmF0ZSBhIHNwcml0ZSBzaGVldCB0byBhY2NvbXBhbnkgdGhlIHNwaW5lIGRhdGFcbiAqIFdoZW4gbG9hZGVkIHRoaXMgY2xhc3Mgd2lsbCBkaXNwYXRjaCBhIFwibG9hZGVkXCIgZXZlbnRcbiAqXG4gKiBAY2xhc3MgU3BpbmVcbiAqIEB1c2VzIEV2ZW50VGFyZ2V0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB1cmwge1N0cmluZ30gVGhlIHVybCBvZiB0aGUgSlNPTiBmaWxlXG4gKiBAcGFyYW0gY3Jvc3NvcmlnaW4ge0Jvb2xlYW59IFdoZXRoZXIgcmVxdWVzdHMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgY3Jvc3NvcmlnaW5cbiAqL1xuUElYSS5TcGluZUxvYWRlciA9IGZ1bmN0aW9uKHVybCwgY3Jvc3NvcmlnaW4pXG57XG4gICAgUElYSS5FdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHVybCBvZiB0aGUgYml0bWFwIGZvbnQgZGF0YVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHVybFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIHRoaXMudXJsID0gdXJsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVxdWVzdHMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgY3Jvc3Mgb3JpZ2luXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY3Jvc3NvcmlnaW5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5jcm9zc29yaWdpbiA9IGNyb3Nzb3JpZ2luO1xuXG4gICAgLyoqXG4gICAgICogW3JlYWQtb25seV0gV2hldGhlciB0aGUgZGF0YSBoYXMgbG9hZGVkIHlldFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGxvYWRlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xufTtcblxuUElYSS5TcGluZUxvYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLlNwaW5lTG9hZGVyO1xuXG4vKipcbiAqIExvYWRzIHRoZSBKU09OIGRhdGFcbiAqXG4gKiBAbWV0aG9kIGxvYWRcbiAqL1xuUElYSS5TcGluZUxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgdmFyIGpzb25Mb2FkZXIgPSBuZXcgUElYSS5Kc29uTG9hZGVyKHRoaXMudXJsLCB0aGlzLmNyb3Nzb3JpZ2luKTtcbiAgICBqc29uTG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHNjb3BlLmpzb24gPSBldmVudC5jb250ZW50Lmpzb247XG4gICAgICAgIHNjb3BlLm9uTG9hZGVkKCk7XG4gICAgfSk7XG4gICAganNvbkxvYWRlci5sb2FkKCk7XG59O1xuXG4vKipcbiAqIEludm9rZSB3aGVuIEpTT04gZmlsZSBpcyBsb2FkZWRcbiAqXG4gKiBAbWV0aG9kIG9uTG9hZGVkXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlNwaW5lTG9hZGVyLnByb3RvdHlwZS5vbkxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiBcImxvYWRlZFwiLCBjb250ZW50OiB0aGlzfSk7XG59O1xuXG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBjcmVhdGluZyBhIHBpeGkuanMgZmlsdGVyLiBDdXJyZW50bHkgb25seSB3ZWJHTCBzdXBwb3J0cyBmaWx0ZXJzLlxuICogSWYgeW91IHdhbnQgdG8gbWFrZSBhIGN1c3RvbSBmaWx0ZXIgdGhpcyBzaG91bGQgYmUgeW91ciBiYXNlIGNsYXNzLlxuICogQGNsYXNzIEFic3RyYWN0RmlsdGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSBmcmFnbWVudFNyY1xuICogQHBhcmFtIHVuaWZvcm1zXG4gKi9cblBJWEkuQWJzdHJhY3RGaWx0ZXIgPSBmdW5jdGlvbihmcmFnbWVudFNyYywgdW5pZm9ybXMpXG57XG4gICAgLyoqXG4gICAgKiBBbiBhcnJheSBvZiBwYXNzZXMgLSBzb21lIGZpbHRlcnMgY29udGFpbiBhIGZldyBzdGVwcyB0aGlzIGFycmF5IHNpbXBseSBzdG9yZXMgdGhlIHN0ZXBzIGluIGEgbGluaWVhciBmYXNoaW9uLlxuICAgICogRm9yIGV4YW1wbGUgdGhlIGJsdXIgZmlsdGVyIGhhcyB0d28gcGFzc2VzIGJsdXJYIGFuZCBibHVyWS5cbiAgICAqIEBwcm9wZXJ0eSBwYXNzZXNcbiAgICAqIEB0eXBlIEFycmF5IGFuIGFycmF5IG9mIGZpbHRlciBvYmplY3RzXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5wYXNzZXMgPSBbdGhpc107XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSBzaGFkZXJzXG4gICAgKiBAdHlwZSBBcnJheSBhbiBhcnJheSBvZiBzaGFkZXJzXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5zaGFkZXJzID0gW107XG4gICAgXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5wYWRkaW5nID0gMDtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHVuaWZvcm1zXG4gICAgKiBAdHlwZSBvYmplY3RcbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLnVuaWZvcm1zID0gdW5pZm9ybXMgfHwge307XG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkgZnJhZ21lbnRTcmNcbiAgICAqIEB0eXBlIEFycmF5XG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IGZyYWdtZW50U3JjIHx8IFtdO1xufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqXG4gKiBUaGUgQWxwaGFNYXNrRmlsdGVyIGNsYXNzIHVzZXMgdGhlIHBpeGVsIHZhbHVlcyBmcm9tIHRoZSBzcGVjaWZpZWQgdGV4dHVyZSAoY2FsbGVkIHRoZSBkaXNwbGFjZW1lbnQgbWFwKSB0byBwZXJmb3JtIGEgZGlzcGxhY2VtZW50IG9mIGFuIG9iamVjdC5cbiAqIFlvdSBjYW4gdXNlIHRoaXMgZmlsdGVyIHRvIGFwcGx5IGFsbCBtYW5vciBvZiBjcmF6eSB3YXJwaW5nIGVmZmVjdHNcbiAqIEN1cnJlbnRseSB0aGUgciBwcm9wZXJ0eSBvZiB0aGUgdGV4dHVyZSBpcyB1c2VkIHRvIG9mZnNldCB0aGUgeCBhbmQgdGhlIGcgcHJvcGVyeSBvZiB0aGUgdGV4dHVyZSBpcyB1c2VkIHRvIG9mZnNldCB0aGUgeS5cbiAqIEBjbGFzcyBBbHBoYU1hc2tGaWx0ZXJcbiAqIEBjb250cnVjdG9yXG4gKiBAcGFyYW0gdGV4dHVyZSB7VGV4dHVyZX0gVGhlIHRleHR1cmUgdXNlZCBmb3IgdGhlIGRpc3BsYWNlbXRlbnQgbWFwICogbXVzdCBiZSBwb3dlciBvZiAyIHRleHR1cmUgYXQgdGhlIG1vbWVudFxuICovXG5QSVhJLkFscGhhTWFza0ZpbHRlciA9IGZ1bmN0aW9uKHRleHR1cmUpXG57XG4gICAgUElYSS5BYnN0cmFjdEZpbHRlci5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnBhc3NlcyA9IFt0aGlzXTtcbiAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLl9wb3dlck9mMiA9IHRydWU7XG5cbiAgICAvLyBzZXQgdGhlIHVuaWZvcm1zXG4gICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgICAgbWFzazoge3R5cGU6ICdzYW1wbGVyMkQnLCB2YWx1ZTp0ZXh0dXJlfSxcbiAgICAgICAgbWFwRGltZW5zaW9uczogICB7dHlwZTogJzJmJywgdmFsdWU6e3g6MSwgeTo1MTEyfX0sXG4gICAgICAgIGRpbWVuc2lvbnM6ICAge3R5cGU6ICc0ZnYnLCB2YWx1ZTpbMCwwLDAsMF19XG4gICAgfTtcblxuICAgIGlmKHRleHR1cmUuYmFzZVRleHR1cmUuaGFzTG9hZGVkKVxuICAgIHtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5tYXNrLnZhbHVlLnggPSB0ZXh0dXJlLndpZHRoO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLm1hc2sudmFsdWUueSA9IHRleHR1cmUuaGVpZ2h0O1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLmJvdW5kTG9hZGVkRnVuY3Rpb24gPSB0aGlzLm9uVGV4dHVyZUxvYWRlZC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRleHR1cmUuYmFzZVRleHR1cmUub24oJ2xvYWRlZCcsIHRoaXMuYm91bmRMb2FkZWRGdW5jdGlvbik7XG4gICAgfVxuXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgbWFzazsnLFxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiBvZmZzZXQ7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjNCBkaW1lbnNpb25zOycsXG4gICAgICAgICd1bmlmb3JtIHZlYzIgbWFwRGltZW5zaW9uczsnLFxuXG4gICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICcgICB2ZWMyIG1hcENvcmRzID0gdlRleHR1cmVDb29yZC54eTsnLFxuICAgICAgICAnICAgbWFwQ29yZHMgKz0gKGRpbWVuc2lvbnMuencgKyBvZmZzZXQpLyBkaW1lbnNpb25zLnh5IDsnLFxuICAgICAgICAnICAgbWFwQ29yZHMueSAqPSAtMS4wOycsXG4gICAgICAgICcgICBtYXBDb3Jkcy55ICs9IDEuMDsnLFxuICAgICAgICAnICAgbWFwQ29yZHMgKj0gZGltZW5zaW9ucy54eSAvIG1hcERpbWVuc2lvbnM7JyxcblxuICAgICAgICAnICAgdmVjNCBvcmlnaW5hbCA9ICB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpOycsXG4gICAgICAgICcgICBmbG9hdCBtYXNrQWxwaGEgPSAgdGV4dHVyZTJEKG1hc2ssIG1hcENvcmRzKS5yOycsXG4gICAgICAgICcgICBvcmlnaW5hbCAqPSBtYXNrQWxwaGE7JyxcbiAgICAgICAgLy8nICAgb3JpZ2luYWwucmdiICo9IG1hc2tBbHBoYTsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gIG9yaWdpbmFsOycsXG4gICAgICAgIC8vJyAgIGdsX0ZyYWdDb2xvciA9IGdsX0ZyYWdDb2xvcjsnLFxuICAgICAgICAnfSdcbiAgICBdO1xufTtcblxuUElYSS5BbHBoYU1hc2tGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUElYSS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUgKTtcblBJWEkuQWxwaGFNYXNrRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuQWxwaGFNYXNrRmlsdGVyO1xuXG5QSVhJLkFscGhhTWFza0ZpbHRlci5wcm90b3R5cGUub25UZXh0dXJlTG9hZGVkID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMudW5pZm9ybXMubWFwRGltZW5zaW9ucy52YWx1ZS54ID0gdGhpcy51bmlmb3Jtcy5tYXNrLnZhbHVlLndpZHRoO1xuICAgIHRoaXMudW5pZm9ybXMubWFwRGltZW5zaW9ucy52YWx1ZS55ID0gdGhpcy51bmlmb3Jtcy5tYXNrLnZhbHVlLmhlaWdodDtcblxuICAgIHRoaXMudW5pZm9ybXMubWFzay52YWx1ZS5iYXNlVGV4dHVyZS5vZmYoJ2xvYWRlZCcsIHRoaXMuYm91bmRMb2FkZWRGdW5jdGlvbik7XG59O1xuXG4vKipcbiAqIFRoZSB0ZXh0dXJlIHVzZWQgZm9yIHRoZSBkaXNwbGFjZW10ZW50IG1hcCAqIG11c3QgYmUgcG93ZXIgb2YgMiB0ZXh0dXJlIGF0IHRoZSBtb21lbnRcbiAqXG4gKiBAcHJvcGVydHkgbWFwXG4gKiBAdHlwZSBUZXh0dXJlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLkFscGhhTWFza0ZpbHRlci5wcm90b3R5cGUsICdtYXAnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubWFzay52YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5tYXNrLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufSk7XG5cblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqXG4gKiBUaGUgQ29sb3JNYXRyaXhGaWx0ZXIgY2xhc3MgbGV0cyB5b3UgYXBwbHkgYSA0eDQgbWF0cml4IHRyYW5zZm9ybWF0aW9uIG9uIHRoZSBSR0JBXG4gKiBjb2xvciBhbmQgYWxwaGEgdmFsdWVzIG9mIGV2ZXJ5IHBpeGVsIG9uIHlvdXIgZGlzcGxheU9iamVjdCB0byBwcm9kdWNlIGEgcmVzdWx0XG4gKiB3aXRoIGEgbmV3IHNldCBvZiBSR0JBIGNvbG9yIGFuZCBhbHBoYSB2YWx1ZXMuIEl0cyBwcmV0dHkgcG93ZXJmdWwhXG4gKiBAY2xhc3MgQ29sb3JNYXRyaXhGaWx0ZXJcbiAqIEBjb250cnVjdG9yXG4gKi9cblBJWEkuQ29sb3JNYXRyaXhGaWx0ZXIgPSBmdW5jdGlvbigpXG57XG4gICAgUElYSS5BYnN0cmFjdEZpbHRlci5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnBhc3NlcyA9IFt0aGlzXTtcblxuICAgIC8vIHNldCB0aGUgdW5pZm9ybXNcbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgICBtYXRyaXg6IHt0eXBlOiAnbWF0NCcsIHZhbHVlOiBbMSwwLDAsMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsMSwwLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLDAsMSwwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwwLDAsMV19XG4gICAgfTtcblxuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBbXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgaW52ZXJ0OycsXG4gICAgICAgICd1bmlmb3JtIG1hdDQgbWF0cml4OycsXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLFxuXG4gICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogbWF0cml4OycsXG4gICAgICAvLyAgJyAgIGdsX0ZyYWdDb2xvciA9IGdsX0ZyYWdDb2xvcjsnLFxuICAgICAgICAnfSdcbiAgICBdO1xufTtcblxuUElYSS5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQSVhJLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSApO1xuUElYSS5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkNvbG9yTWF0cml4RmlsdGVyO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hdHJpeCBvZiB0aGUgY29sb3IgbWF0cml4IGZpbHRlclxuICpcbiAqIEBwcm9wZXJ0eSBtYXRyaXhcbiAqIEB0eXBlIEFycmF5IGFuZCBhcnJheSBvZiAyNiBudW1iZXJzXG4gKiBAZGVmYXVsdCBbMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCwwLDAsMV1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLCAnbWF0cml4Jywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm1hdHJpeC52YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5tYXRyaXgudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59KTtcbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKlxuICogVGhpcyB0dXJucyB5b3VyIGRpc3BsYXlPYmplY3RzIHRvIGJsYWNrIGFuZCB3aGl0ZS5cbiAqIEBjbGFzcyBHcmF5RmlsdGVyXG4gKiBAY29udHJ1Y3RvclxuICovXG5QSVhJLkdyYXlGaWx0ZXIgPSBmdW5jdGlvbigpXG57XG4gICAgUElYSS5BYnN0cmFjdEZpbHRlci5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnBhc3NlcyA9IFt0aGlzXTtcblxuICAgIC8vIHNldCB0aGUgdW5pZm9ybXNcbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgICBncmF5OiB7dHlwZTogJzFmJywgdmFsdWU6IDF9XG4gICAgfTtcblxuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBbXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IGdyYXk7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yLnJnYiA9IG1peChnbF9GcmFnQ29sb3IucmdiLCB2ZWMzKDAuMjEyNipnbF9GcmFnQ29sb3IuciArIDAuNzE1MipnbF9GcmFnQ29sb3IuZyArIDAuMDcyMipnbF9GcmFnQ29sb3IuYiksIGdyYXkpOycsXG4gICAgIC8vICAgJyAgIGdsX0ZyYWdDb2xvciA9IGdsX0ZyYWdDb2xvcjsnLFxuICAgICAgICAnfSdcbiAgICBdO1xufTtcblxuUElYSS5HcmF5RmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBJWEkuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlICk7XG5QSVhJLkdyYXlGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5HcmF5RmlsdGVyO1xuXG4vKipcblRoZSBzdHJlbmd0aCBvZiB0aGUgZ3JheS4gMSB3aWxsIG1ha2UgdGhlIG9iamVjdCBibGFjayBhbmQgd2hpdGUsIDAgd2lsbCBtYWtlIHRoZSBvYmplY3QgaXRzIG5vcm1hbCBjb2xvclxuQHByb3BlcnR5IGdyYXlcbiovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5HcmF5RmlsdGVyLnByb3RvdHlwZSwgJ2dyYXknLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ3JheS52YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5ncmF5LnZhbHVlID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKlxuICogVGhlIERpc3BsYWNlbWVudEZpbHRlciBjbGFzcyB1c2VzIHRoZSBwaXhlbCB2YWx1ZXMgZnJvbSB0aGUgc3BlY2lmaWVkIHRleHR1cmUgKGNhbGxlZCB0aGUgZGlzcGxhY2VtZW50IG1hcCkgdG8gcGVyZm9ybSBhIGRpc3BsYWNlbWVudCBvZiBhbiBvYmplY3QuXG4gKiBZb3UgY2FuIHVzZSB0aGlzIGZpbHRlciB0byBhcHBseSBhbGwgbWFub3Igb2YgY3Jhenkgd2FycGluZyBlZmZlY3RzXG4gKiBDdXJyZW50bHkgdGhlIHIgcHJvcGVydHkgb2YgdGhlIHRleHR1cmUgaXMgdXNlZCBvZmZzZXQgdGhlIHggYW5kIHRoZSBnIHByb3Blcnkgb2YgdGhlIHRleHR1cmUgaXMgdXNlZCB0byBvZmZzZXQgdGhlIHkuXG4gKiBAY2xhc3MgRGlzcGxhY2VtZW50RmlsdGVyXG4gKiBAY29udHJ1Y3RvclxuICogQHBhcmFtIHRleHR1cmUge1RleHR1cmV9IFRoZSB0ZXh0dXJlIHVzZWQgZm9yIHRoZSBkaXNwbGFjZW10ZW50IG1hcCAqIG11c3QgYmUgcG93ZXIgb2YgMiB0ZXh0dXJlIGF0IHRoZSBtb21lbnRcbiAqL1xuUElYSS5EaXNwbGFjZW1lbnRGaWx0ZXIgPSBmdW5jdGlvbih0ZXh0dXJlKVxue1xuICAgIFBJWEkuQWJzdHJhY3RGaWx0ZXIuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5wYXNzZXMgPSBbdGhpc107XG4gICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5fcG93ZXJPZjIgPSB0cnVlO1xuXG4gICAgLy8gc2V0IHRoZSB1bmlmb3Jtc1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICAgIGRpc3BsYWNlbWVudE1hcDoge3R5cGU6ICdzYW1wbGVyMkQnLCB2YWx1ZTp0ZXh0dXJlfSxcbiAgICAgICAgc2NhbGU6ICAgICAgICAgICB7dHlwZTogJzJmJywgdmFsdWU6e3g6MzAsIHk6MzB9fSxcbiAgICAgICAgb2Zmc2V0OiAgICAgICAgICB7dHlwZTogJzJmJywgdmFsdWU6e3g6MCwgeTowfX0sXG4gICAgICAgIG1hcERpbWVuc2lvbnM6ICAge3R5cGU6ICcyZicsIHZhbHVlOnt4OjEsIHk6NTExMn19LFxuICAgICAgICBkaW1lbnNpb25zOiAgIHt0eXBlOiAnNGZ2JywgdmFsdWU6WzAsMCwwLDBdfVxuICAgIH07XG5cbiAgICBpZih0ZXh0dXJlLmJhc2VUZXh0dXJlLmhhc0xvYWRlZClcbiAgICB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMubWFwRGltZW5zaW9ucy52YWx1ZS54ID0gdGV4dHVyZS53aWR0aDtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5tYXBEaW1lbnNpb25zLnZhbHVlLnkgPSB0ZXh0dXJlLmhlaWdodDtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5ib3VuZExvYWRlZEZ1bmN0aW9uID0gdGhpcy5vblRleHR1cmVMb2FkZWQuYmluZCh0aGlzKTtcblxuICAgICAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLm9uKCdsb2FkZWQnLCB0aGlzLmJvdW5kTG9hZGVkRnVuY3Rpb24pO1xuICAgIH1cblxuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBbXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIGRpc3BsYWNlbWVudE1hcDsnLFxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiBzY2FsZTsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMyIG9mZnNldDsnLFxuICAgICAgICAndW5pZm9ybSB2ZWM0IGRpbWVuc2lvbnM7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiBtYXBEaW1lbnNpb25zOycsLy8gPSB2ZWMyKDI1Ni4wLCAyNTYuMCk7JyxcbiAgICAgICAgLy8gJ2NvbnN0IHZlYzIgdGV4dHVyZURpbWVuc2lvbnMgPSB2ZWMyKDc1MC4wLCA3NTAuMCk7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgdmVjMiBtYXBDb3JkcyA9IHZUZXh0dXJlQ29vcmQueHk7JyxcbiAgICAgICAgLy8nICAgbWFwQ29yZHMgLT0gOycsXG4gICAgICAgICcgICBtYXBDb3JkcyArPSAoZGltZW5zaW9ucy56dyArIG9mZnNldCkvIGRpbWVuc2lvbnMueHkgOycsXG4gICAgICAgICcgICBtYXBDb3Jkcy55ICo9IC0xLjA7JyxcbiAgICAgICAgJyAgIG1hcENvcmRzLnkgKz0gMS4wOycsXG4gICAgICAgICcgICB2ZWMyIG1hdFNhbXBsZSA9IHRleHR1cmUyRChkaXNwbGFjZW1lbnRNYXAsIG1hcENvcmRzKS54eTsnLFxuICAgICAgICAnICAgbWF0U2FtcGxlIC09IDAuNTsnLFxuICAgICAgICAnICAgbWF0U2FtcGxlICo9IHNjYWxlOycsXG4gICAgICAgICcgICBtYXRTYW1wbGUgLz0gbWFwRGltZW5zaW9uczsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCArIG1hdFNhbXBsZS54LCB2VGV4dHVyZUNvb3JkLnkgKyBtYXRTYW1wbGUueSkpOycsXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IucmdiID0gbWl4KCBnbF9GcmFnQ29sb3IucmdiLCBnbF9GcmFnQ29sb3IucmdiLCAxLjApOycsXG4gICAgICAgICcgICB2ZWMyIGNvcmQgPSB2VGV4dHVyZUNvb3JkOycsXG5cbiAgICAgICAgLy8nICAgZ2xfRnJhZ0NvbG9yID0gIHRleHR1cmUyRChkaXNwbGFjZW1lbnRNYXAsIGNvcmQpOycsXG4gICAgIC8vICAgJyAgIGdsX0ZyYWdDb2xvciA9IGdsX0ZyYWdDb2xvcjsnLFxuICAgICAgICAnfSdcbiAgICBdO1xufTtcblxuUElYSS5EaXNwbGFjZW1lbnRGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUElYSS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUgKTtcblBJWEkuRGlzcGxhY2VtZW50RmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuRGlzcGxhY2VtZW50RmlsdGVyO1xuXG5QSVhJLkRpc3BsYWNlbWVudEZpbHRlci5wcm90b3R5cGUub25UZXh0dXJlTG9hZGVkID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMudW5pZm9ybXMubWFwRGltZW5zaW9ucy52YWx1ZS54ID0gdGhpcy51bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUud2lkdGg7XG4gICAgdGhpcy51bmlmb3Jtcy5tYXBEaW1lbnNpb25zLnZhbHVlLnkgPSB0aGlzLnVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZS5oZWlnaHQ7XG5cbiAgICB0aGlzLnVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZS5iYXNlVGV4dHVyZS5vZmYoJ2xvYWRlZCcsIHRoaXMuYm91bmRMb2FkZWRGdW5jdGlvbik7XG59O1xuXG4vKipcbiAqIFRoZSB0ZXh0dXJlIHVzZWQgZm9yIHRoZSBkaXNwbGFjZW10ZW50IG1hcCAqIG11c3QgYmUgcG93ZXIgb2YgMiB0ZXh0dXJlIGF0IHRoZSBtb21lbnRcbiAqXG4gKiBAcHJvcGVydHkgbWFwXG4gKiBAdHlwZSBUZXh0dXJlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLkRpc3BsYWNlbWVudEZpbHRlci5wcm90b3R5cGUsICdtYXAnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFRoZSBtdWx0aXBsaWVyIHVzZWQgdG8gc2NhbGUgdGhlIGRpc3BsYWNlbWVudCByZXN1bHQgZnJvbSB0aGUgbWFwIGNhbGN1bGF0aW9uLlxuICpcbiAqIEBwcm9wZXJ0eSBzY2FsZVxuICogQHR5cGUgUG9pbnRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuRGlzcGxhY2VtZW50RmlsdGVyLnByb3RvdHlwZSwgJ3NjYWxlJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogVGhlIG9mZnNldCB1c2VkIHRvIG1vdmUgdGhlIGRpc3BsYWNlbWVudCBtYXAuXG4gKlxuICogQHByb3BlcnR5IG9mZnNldFxuICogQHR5cGUgUG9pbnRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuRGlzcGxhY2VtZW50RmlsdGVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5vZmZzZXQudmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMub2Zmc2V0LnZhbHVlID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKlxuICogVGhpcyBmaWx0ZXIgYXBwbGllcyBhIHBpeGVsYXRlIGVmZmVjdCBtYWtpbmcgZGlzcGxheSBvYmplY3RzIGFwcGVhciAnYmxvY2t5J1xuICogQGNsYXNzIFBpeGVsYXRlRmlsdGVyXG4gKiBAY29udHJ1Y3RvclxuICovXG5QSVhJLlBpeGVsYXRlRmlsdGVyID0gZnVuY3Rpb24oKVxue1xuICAgIFBJWEkuQWJzdHJhY3RGaWx0ZXIuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5wYXNzZXMgPSBbdGhpc107XG5cbiAgICAvLyBzZXQgdGhlIHVuaWZvcm1zXG4gICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgICAgaW52ZXJ0OiB7dHlwZTogJzFmJywgdmFsdWU6IDB9LFxuICAgICAgICBkaW1lbnNpb25zOiB7dHlwZTogJzRmdicsIHZhbHVlOm5ldyBGbG9hdDMyQXJyYXkoWzEwMDAwLCAxMDAsIDEwLCAxMF0pfSxcbiAgICAgICAgcGl4ZWxTaXplOiB7dHlwZTogJzJmJywgdmFsdWU6e3g6MTAsIHk6MTB9fVxuICAgIH07XG5cbiAgICB0aGlzLmZyYWdtZW50U3JjID0gW1xuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG4gICAgICAgICd1bmlmb3JtIHZlYzIgdGVzdERpbTsnLFxuICAgICAgICAndW5pZm9ybSB2ZWM0IGRpbWVuc2lvbnM7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiBwaXhlbFNpemU7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIHZlYzIgY29vcmQgPSB2VGV4dHVyZUNvb3JkOycsXG5cbiAgICAgICAgJyAgIHZlYzIgc2l6ZSA9IGRpbWVuc2lvbnMueHkvcGl4ZWxTaXplOycsXG5cbiAgICAgICAgJyAgIHZlYzIgY29sb3IgPSBmbG9vciggKCB2VGV4dHVyZUNvb3JkICogc2l6ZSApICkgLyBzaXplICsgcGl4ZWxTaXplL2RpbWVuc2lvbnMueHkgKiAwLjU7JyxcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgY29sb3IpOycsXG4gICAgICAgICd9J1xuICAgIF07XG59O1xuXG5QSVhJLlBpeGVsYXRlRmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBJWEkuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlICk7XG5QSVhJLlBpeGVsYXRlRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuUGl4ZWxhdGVGaWx0ZXI7XG5cbi8qKlxuICpcbiAqIFRoaXMgYSBwb2ludCB0aGF0IGRlc2NyaWJlcyB0aGUgc2l6ZSBvZiB0aGUgYmxvY3MuIHggaXMgdGhlIHdpZHRoIG9mIHRoZSBibG9jayBhbmQgeSBpcyB0aGUgdGhlIGhlaWdodFxuICogQHByb3BlcnR5IHNpemVcbiAqIEB0eXBlIFBvaW50XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLlBpeGVsYXRlRmlsdGVyLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMucGl4ZWxTaXplLnZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5waXhlbFNpemUudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG5QSVhJLkJsdXJYRmlsdGVyID0gZnVuY3Rpb24oKVxue1xuICAgIFBJWEkuQWJzdHJhY3RGaWx0ZXIuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5wYXNzZXMgPSBbdGhpc107XG5cbiAgICAvLyBzZXQgdGhlIHVuaWZvcm1zXG4gICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgICAgYmx1cjoge3R5cGU6ICcxZicsIHZhbHVlOiAxLzUxMn1cbiAgICB9O1xuXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxuICAgICAgICAndW5pZm9ybSBmbG9hdCBibHVyOycsXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLFxuXG4gICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICcgICB2ZWM0IHN1bSA9IHZlYzQoMC4wKTsnLFxuXG4gICAgICAgICcgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCAtIDQuMCpibHVyLCB2VGV4dHVyZUNvb3JkLnkpKSAqIDAuMDU7JyxcbiAgICAgICAgJyAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54IC0gMy4wKmJsdXIsIHZUZXh0dXJlQ29vcmQueSkpICogMC4wOTsnLFxuICAgICAgICAnICAgc3VtICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLnggLSAyLjAqYmx1ciwgdlRleHR1cmVDb29yZC55KSkgKiAwLjEyOycsXG4gICAgICAgICcgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCAtIGJsdXIsIHZUZXh0dXJlQ29vcmQueSkpICogMC4xNTsnLFxuICAgICAgICAnICAgc3VtICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLngsIHZUZXh0dXJlQ29vcmQueSkpICogMC4xNjsnLFxuICAgICAgICAnICAgc3VtICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLnggKyBibHVyLCB2VGV4dHVyZUNvb3JkLnkpKSAqIDAuMTU7JyxcbiAgICAgICAgJyAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54ICsgMi4wKmJsdXIsIHZUZXh0dXJlQ29vcmQueSkpICogMC4xMjsnLFxuICAgICAgICAnICAgc3VtICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLnggKyAzLjAqYmx1ciwgdlRleHR1cmVDb29yZC55KSkgKiAwLjA5OycsXG4gICAgICAgICcgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCArIDQuMCpibHVyLCB2VGV4dHVyZUNvb3JkLnkpKSAqIDAuMDU7JyxcblxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gc3VtOycsXG4gICAgICAgICd9J1xuICAgIF07XG59O1xuXG5QSVhJLkJsdXJYRmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBJWEkuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlICk7XG5QSVhJLkJsdXJYRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuQmx1clhGaWx0ZXI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLkJsdXJYRmlsdGVyLnByb3RvdHlwZSwgJ2JsdXInLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuYmx1ci52YWx1ZSAvICgxLzcwMDApO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLmJsdXIudmFsdWUgPSAoMS83MDAwKSAqIHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cblBJWEkuQmx1cllGaWx0ZXIgPSBmdW5jdGlvbigpXG57XG4gICAgUElYSS5BYnN0cmFjdEZpbHRlci5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnBhc3NlcyA9IFt0aGlzXTtcblxuICAgIC8vIHNldCB0aGUgdW5pZm9ybXNcbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgICBibHVyOiB7dHlwZTogJzFmJywgdmFsdWU6IDEvNTEyfVxuICAgIH07XG5cbiAgICB0aGlzLmZyYWdtZW50U3JjID0gW1xuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IGJsdXI7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIHZlYzQgc3VtID0gdmVjNCgwLjApOycsXG5cbiAgICAgICAgJyAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54LCB2VGV4dHVyZUNvb3JkLnkgLSA0LjAqYmx1cikpICogMC4wNTsnLFxuICAgICAgICAnICAgc3VtICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLngsIHZUZXh0dXJlQ29vcmQueSAtIDMuMCpibHVyKSkgKiAwLjA5OycsXG4gICAgICAgICcgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCwgdlRleHR1cmVDb29yZC55IC0gMi4wKmJsdXIpKSAqIDAuMTI7JyxcbiAgICAgICAgJyAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54LCB2VGV4dHVyZUNvb3JkLnkgLSBibHVyKSkgKiAwLjE1OycsXG4gICAgICAgICcgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCwgdlRleHR1cmVDb29yZC55KSkgKiAwLjE2OycsXG4gICAgICAgICcgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCwgdlRleHR1cmVDb29yZC55ICsgYmx1cikpICogMC4xNTsnLFxuICAgICAgICAnICAgc3VtICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLngsIHZUZXh0dXJlQ29vcmQueSArIDIuMCpibHVyKSkgKiAwLjEyOycsXG4gICAgICAgICcgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCwgdlRleHR1cmVDb29yZC55ICsgMy4wKmJsdXIpKSAqIDAuMDk7JyxcbiAgICAgICAgJyAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54LCB2VGV4dHVyZUNvb3JkLnkgKyA0LjAqYmx1cikpICogMC4wNTsnLFxuXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSBzdW07JyxcbiAgICAgICAgJ30nXG4gICAgXTtcbn07XG5cblBJWEkuQmx1cllGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUElYSS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUgKTtcblBJWEkuQmx1cllGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5CbHVyWUZpbHRlcjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuQmx1cllGaWx0ZXIucHJvdG90eXBlLCAnYmx1cicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5ibHVyLnZhbHVlIC8gKDEvNzAwMCk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIC8vdGhpcy5wYWRkaW5nID0gdmFsdWU7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuYmx1ci52YWx1ZSA9ICgxLzcwMDApICogdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKlxuICogVGhlIEJsdXJGaWx0ZXIgYXBwbGllcyBhIEdhdXNzaWFuIGJsdXIgdG8gYW4gb2JqZWN0LlxuICogVGhlIHN0cmVuZ3RoIG9mIHRoZSBibHVyIGNhbiBiZSBzZXQgZm9yIHgtIGFuZCB5LWF4aXMgc2VwYXJhdGVseSAoYWx3YXlzIHJlbGF0aXZlIHRvIHRoZSBzdGFnZSkuXG4gKlxuICogQGNsYXNzIEJsdXJGaWx0ZXJcbiAqIEBjb250cnVjdG9yXG4gKi9cblBJWEkuQmx1ckZpbHRlciA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmJsdXJYRmlsdGVyID0gbmV3IFBJWEkuQmx1clhGaWx0ZXIoKTtcbiAgICB0aGlzLmJsdXJZRmlsdGVyID0gbmV3IFBJWEkuQmx1cllGaWx0ZXIoKTtcblxuICAgIHRoaXMucGFzc2VzID1bdGhpcy5ibHVyWEZpbHRlciwgdGhpcy5ibHVyWUZpbHRlcl07XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIGJvdGggdGhlIGJsdXJYIGFuZCBibHVyWSBwcm9wZXJ0aWVzIHNpbXVsdGFuZW91c2x5XG4gKlxuICogQHByb3BlcnR5IGJsdXJcbiAqIEB0eXBlIE51bWJlciB0aGUgc3RyZW5ndGggb2YgdGhlIGJsdXJcbiAqIEBkZWZhdWx0IDJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuQmx1ckZpbHRlci5wcm90b3R5cGUsICdibHVyJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsdXJYRmlsdGVyLmJsdXI7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYmx1clhGaWx0ZXIuYmx1ciA9IHRoaXMuYmx1cllGaWx0ZXIuYmx1ciA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIHRoZSBibHVyWCBwcm9wZXJ0eVxuICpcbiAqIEBwcm9wZXJ0eSBibHVyWFxuICogQHR5cGUgTnVtYmVyIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1clhcbiAqIEBkZWZhdWx0IDJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuQmx1ckZpbHRlci5wcm90b3R5cGUsICdibHVyWCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibHVyWEZpbHRlci5ibHVyO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLmJsdXJYRmlsdGVyLmJsdXIgPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1clggcHJvcGVydHlcbiAqXG4gKiBAcHJvcGVydHkgYmx1cllcbiAqIEB0eXBlIE51bWJlciB0aGUgc3RyZW5ndGggb2YgdGhlIGJsdXJZXG4gKiBAZGVmYXVsdCAyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLkJsdXJGaWx0ZXIucHJvdG90eXBlLCAnYmx1clknLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmx1cllGaWx0ZXIuYmx1cjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5ibHVyWUZpbHRlci5ibHVyID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKlxuICogVGhpcyBpbnZlcnRzIHlvdXIgZGlzcGxheU9iamVjdHMgY29sb3JzLlxuICogQGNsYXNzIEludmVydEZpbHRlclxuICogQGNvbnRydWN0b3JcbiAqL1xuUElYSS5JbnZlcnRGaWx0ZXIgPSBmdW5jdGlvbigpXG57XG4gICAgUElYSS5BYnN0cmFjdEZpbHRlci5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnBhc3NlcyA9IFt0aGlzXTtcblxuICAgIC8vIHNldCB0aGUgdW5pZm9ybXNcbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgICBpbnZlcnQ6IHt0eXBlOiAnMWYnLCB2YWx1ZTogMX1cbiAgICB9O1xuXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxuICAgICAgICAndW5pZm9ybSBmbG9hdCBpbnZlcnQ7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7JyxcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvci5yZ2IgPSBtaXgoICh2ZWMzKDEpLWdsX0ZyYWdDb2xvci5yZ2IpICogZ2xfRnJhZ0NvbG9yLmEsIGdsX0ZyYWdDb2xvci5yZ2IsIDEuMCAtIGludmVydCk7JyxcbiAgICAgICAgLy8nICAgZ2xfRnJhZ0NvbG9yLnJnYiA9IGdsX0ZyYWdDb2xvci5yZ2IgICogZ2xfRnJhZ0NvbG9yLmE7JyxcbiAgICAgIC8vICAnICAgZ2xfRnJhZ0NvbG9yID0gZ2xfRnJhZ0NvbG9yICogdkNvbG9yOycsXG4gICAgICAgICd9J1xuICAgIF07XG59O1xuXG5QSVhJLkludmVydEZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQSVhJLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSApO1xuUElYSS5JbnZlcnRGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5JbnZlcnRGaWx0ZXI7XG5cbi8qKlxuVGhlIHN0cmVuZ3RoIG9mIHRoZSBpbnZlcnQuIDEgd2lsbCBmdWxseSBpbnZlcnQgdGhlIGNvbG9ycywgMCB3aWxsIG1ha2UgdGhlIG9iamVjdCBpdHMgbm9ybWFsIGNvbG9yXG5AcHJvcGVydHkgaW52ZXJ0XG4qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuSW52ZXJ0RmlsdGVyLnByb3RvdHlwZSwgJ2ludmVydCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5pbnZlcnQudmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuaW52ZXJ0LnZhbHVlID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKlxuICogVGhpcyBhcHBsaWVzIGEgc2VwaWEgZWZmZWN0IHRvIHlvdXIgZGlzcGxheU9iamVjdHMuXG4gKiBAY2xhc3MgU2VwaWFGaWx0ZXJcbiAqIEBjb250cnVjdG9yXG4gKi9cblBJWEkuU2VwaWFGaWx0ZXIgPSBmdW5jdGlvbigpXG57XG4gICAgUElYSS5BYnN0cmFjdEZpbHRlci5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnBhc3NlcyA9IFt0aGlzXTtcblxuICAgIC8vIHNldCB0aGUgdW5pZm9ybXNcbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgICBzZXBpYToge3R5cGU6ICcxZicsIHZhbHVlOiAxfVxuICAgIH07XG5cbiAgICB0aGlzLmZyYWdtZW50U3JjID0gW1xuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHNlcGlhOycsXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLFxuXG4gICAgICAgICdjb25zdCBtYXQzIHNlcGlhTWF0cml4ID0gbWF0MygwLjM1ODgsIDAuNzA0NCwgMC4xMzY4LCAwLjI5OTAsIDAuNTg3MCwgMC4xMTQwLCAwLjIzOTIsIDAuNDY5NiwgMC4wOTEyKTsnLFxuXG4gICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpOycsXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IucmdiID0gbWl4KCBnbF9GcmFnQ29sb3IucmdiLCBnbF9GcmFnQ29sb3IucmdiICogc2VwaWFNYXRyaXgsIHNlcGlhKTsnLFxuICAgICAgIC8vICcgICBnbF9GcmFnQ29sb3IgPSBnbF9GcmFnQ29sb3IgKiB2Q29sb3I7JyxcbiAgICAgICAgJ30nXG4gICAgXTtcbn07XG5cblBJWEkuU2VwaWFGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUElYSS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUgKTtcblBJWEkuU2VwaWFGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5TZXBpYUZpbHRlcjtcblxuLyoqXG5UaGUgc3RyZW5ndGggb2YgdGhlIHNlcGlhLiAxIHdpbGwgYXBwbHkgdGhlIGZ1bGwgc2VwaWEgZWZmZWN0LCAwIHdpbGwgbWFrZSB0aGUgb2JqZWN0IGl0cyBub3JtYWwgY29sb3JcbkBwcm9wZXJ0eSBzZXBpYVxuKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLlNlcGlhRmlsdGVyLnByb3RvdHlwZSwgJ3NlcGlhJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnNlcGlhLnZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnNlcGlhLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKlxuICogVGhpcyBmaWx0ZXIgYXBwbGllcyBhIHR3aXN0IGVmZmVjdCBtYWtpbmcgZGlzcGxheSBvYmplY3RzIGFwcGVhciB0d2lzdGVkIGluIHRoZSBnaXZlbiBkaXJlY3Rpb25cbiAqIEBjbGFzcyBUd2lzdEZpbHRlclxuICogQGNvbnRydWN0b3JcbiAqL1xuUElYSS5Ud2lzdEZpbHRlciA9IGZ1bmN0aW9uKClcbntcbiAgICBQSVhJLkFic3RyYWN0RmlsdGVyLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMucGFzc2VzID0gW3RoaXNdO1xuXG4gICAgLy8gc2V0IHRoZSB1bmlmb3Jtc1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICAgIHJhZGl1czoge3R5cGU6ICcxZicsIHZhbHVlOjAuNX0sXG4gICAgICAgIGFuZ2xlOiB7dHlwZTogJzFmJywgdmFsdWU6NX0sXG4gICAgICAgIG9mZnNldDoge3R5cGU6ICcyZicsIHZhbHVlOnt4OjAuNSwgeTowLjV9fVxuICAgIH07XG5cbiAgICB0aGlzLmZyYWdtZW50U3JjID0gW1xuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG4gICAgICAgICd1bmlmb3JtIHZlYzQgZGltZW5zaW9uczsnLFxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcblxuICAgICAgICAndW5pZm9ybSBmbG9hdCByYWRpdXM7JyxcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgYW5nbGU7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiBvZmZzZXQ7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgdmVjMiBjb29yZCA9IHZUZXh0dXJlQ29vcmQgLSBvZmZzZXQ7JyxcbiAgICAgICAgJyAgIGZsb2F0IGRpc3RhbmNlID0gbGVuZ3RoKGNvb3JkKTsnLFxuXG4gICAgICAgICcgICBpZiAoZGlzdGFuY2UgPCByYWRpdXMpIHsnLFxuICAgICAgICAnICAgICAgIGZsb2F0IHJhdGlvID0gKHJhZGl1cyAtIGRpc3RhbmNlKSAvIHJhZGl1czsnLFxuICAgICAgICAnICAgICAgIGZsb2F0IGFuZ2xlTW9kID0gcmF0aW8gKiByYXRpbyAqIGFuZ2xlOycsXG4gICAgICAgICcgICAgICAgZmxvYXQgcyA9IHNpbihhbmdsZU1vZCk7JyxcbiAgICAgICAgJyAgICAgICBmbG9hdCBjID0gY29zKGFuZ2xlTW9kKTsnLFxuICAgICAgICAnICAgICAgIGNvb3JkID0gdmVjMihjb29yZC54ICogYyAtIGNvb3JkLnkgKiBzLCBjb29yZC54ICogcyArIGNvb3JkLnkgKiBjKTsnLFxuICAgICAgICAnICAgfScsXG5cbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgY29vcmQrb2Zmc2V0KTsnLFxuICAgICAgICAnfSdcbiAgICBdO1xufTtcblxuUElYSS5Ud2lzdEZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQSVhJLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSApO1xuUElYSS5Ud2lzdEZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLlR3aXN0RmlsdGVyO1xuXG4vKipcbiAqXG4gKiBUaGlzIHBvaW50IGRlc2NyaWJlcyB0aGUgdGhlIG9mZnNldCBvZiB0aGUgdHdpc3RcbiAqIEBwcm9wZXJ0eSBzaXplXG4gKiBAdHlwZSBQb2ludFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5Ud2lzdEZpbHRlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMub2Zmc2V0LnZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5vZmZzZXQudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKlxuICogVGhpcyByYWRpdXMgZGVzY3JpYmVzIHNpemUgb2YgdGhlIHR3aXN0XG4gKiBAcHJvcGVydHkgc2l6ZVxuICogQHR5cGUgTnVtYmVyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLlR3aXN0RmlsdGVyLnByb3RvdHlwZSwgJ3JhZGl1cycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5yYWRpdXMudmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqXG4gKiBUaGlzIHJhZGl1cyBkZXNjcmliZXMgYW5nbGUgb2YgdGhlIHR3aXN0XG4gKiBAcHJvcGVydHkgYW5nbGVcbiAqIEB0eXBlIE51bWJlclxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5Ud2lzdEZpbHRlci5wcm90b3R5cGUsICdhbmdsZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5hbmdsZS52YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuYW5nbGUudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59KTtcbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKlxuICogVGhpcyBsb3dlcnMgdGhlIGNvbG9yIGRlcHRoIG9mIHlvdXIgaW1hZ2UgYnkgdGhlIGdpdmVuIGFtb3VudCwgcHJvZHVjaW5nIGFuIGltYWdlIHdpdGggYSBzbWFsbGVyIHBhbGV0dGUuXG4gKiBAY2xhc3MgQ29sb3JTdGVwRmlsdGVyXG4gKiBAY29udHJ1Y3RvclxuICovXG5QSVhJLkNvbG9yU3RlcEZpbHRlciA9IGZ1bmN0aW9uKClcbntcbiAgICBQSVhJLkFic3RyYWN0RmlsdGVyLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMucGFzc2VzID0gW3RoaXNdO1xuXG4gICAgLy8gc2V0IHRoZSB1bmlmb3Jtc1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICAgIHN0ZXA6IHt0eXBlOiAnMWYnLCB2YWx1ZTogNX1cbiAgICB9O1xuXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgc3RlcDsnLFxuXG4gICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICcgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTsnLFxuICAgICAgICAnICAgY29sb3IgPSBmbG9vcihjb2xvciAqIHN0ZXApIC8gc3RlcDsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7JyxcbiAgICAgICAgJ30nXG4gICAgXTtcbn07XG5cblBJWEkuQ29sb3JTdGVwRmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBJWEkuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlICk7XG5QSVhJLkNvbG9yU3RlcEZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkNvbG9yU3RlcEZpbHRlcjtcblxuLyoqXG5UaGUgbnVtYmVyIG9mIHN0ZXBzLlxuQHByb3BlcnR5IHN0ZXBcbiovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5Db2xvclN0ZXBGaWx0ZXIucHJvdG90eXBlLCAnc3RlcCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5zdGVwLnZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnN0ZXAudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqIG9yaWdpbmFsIGZpbHRlcjogaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanMvYmxvYi9tYXN0ZXIvc3JjL2ZpbHRlcnMvZnVuL2RvdHNjcmVlbi5qc1xuICovXG5cbi8qKlxuICpcbiAqIFRoaXMgZmlsdGVyIGFwcGxpZXMgYSBkb3RzY3JlZW4gZWZmZWN0IG1ha2luZyBkaXNwbGF5IG9iamVjdHMgYXBwZWFyIHRvIGJlIG1hZGUgb3V0IG9mIGJsYWNrIGFuZCB3aGl0ZSBoYWxmdG9uZSBkb3RzIGxpa2UgYW4gb2xkIHByaW50ZXJcbiAqIEBjbGFzcyBEb3RTY3JlZW5GaWx0ZXJcbiAqIEBjb250cnVjdG9yXG4gKi9cblBJWEkuRG90U2NyZWVuRmlsdGVyID0gZnVuY3Rpb24oKVxue1xuICAgIFBJWEkuQWJzdHJhY3RGaWx0ZXIuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5wYXNzZXMgPSBbdGhpc107XG5cbiAgICAvLyBzZXQgdGhlIHVuaWZvcm1zXG4gICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgICAgc2NhbGU6IHt0eXBlOiAnMWYnLCB2YWx1ZToxfSxcbiAgICAgICAgYW5nbGU6IHt0eXBlOiAnMWYnLCB2YWx1ZTo1fSxcbiAgICAgICAgZGltZW5zaW9uczogICB7dHlwZTogJzRmdicsIHZhbHVlOlswLDAsMCwwXX1cbiAgICB9O1xuXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxuICAgICAgICAndW5pZm9ybSB2ZWM0IGRpbWVuc2lvbnM7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG5cbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgYW5nbGU7JyxcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgc2NhbGU7JyxcblxuICAgICAgICAnZmxvYXQgcGF0dGVybigpIHsnLFxuICAgICAgICAnICAgZmxvYXQgcyA9IHNpbihhbmdsZSksIGMgPSBjb3MoYW5nbGUpOycsXG4gICAgICAgICcgICB2ZWMyIHRleCA9IHZUZXh0dXJlQ29vcmQgKiBkaW1lbnNpb25zLnh5OycsXG4gICAgICAgICcgICB2ZWMyIHBvaW50ID0gdmVjMignLFxuICAgICAgICAnICAgICAgIGMgKiB0ZXgueCAtIHMgKiB0ZXgueSwnLFxuICAgICAgICAnICAgICAgIHMgKiB0ZXgueCArIGMgKiB0ZXgueScsXG4gICAgICAgICcgICApICogc2NhbGU7JyxcbiAgICAgICAgJyAgIHJldHVybiAoc2luKHBvaW50LngpICogc2luKHBvaW50LnkpKSAqIDQuMDsnLFxuICAgICAgICAnfScsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxuICAgICAgICAnICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7JyxcbiAgICAgICAgJyAgIGZsb2F0IGF2ZXJhZ2UgPSAoY29sb3IuciArIGNvbG9yLmcgKyBjb2xvci5iKSAvIDMuMDsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWMzKGF2ZXJhZ2UgKiAxMC4wIC0gNS4wICsgcGF0dGVybigpKSwgY29sb3IuYSk7JyxcbiAgICAgICAgJ30nXG4gICAgXTtcbn07XG5cblBJWEkuRG90U2NyZWVuRmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBJWEkuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlICk7XG5QSVhJLkRvdFNjcmVlbkZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkRvdFNjcmVlbkZpbHRlcjtcblxuLyoqXG4gKlxuICogVGhpcyBkZXNjcmliZXMgdGhlIHRoZSBzY2FsZVxuICogQHByb3BlcnR5IHNjYWxlXG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuRG90U2NyZWVuRmlsdGVyLnByb3RvdHlwZSwgJ3NjYWxlJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqXG4gKiBUaGlzIHJhZGl1cyBkZXNjcmliZXMgYW5nbGVcbiAqIEBwcm9wZXJ0eSBhbmdsZVxuICogQHR5cGUgTnVtYmVyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLkRvdFNjcmVlbkZpbHRlci5wcm90b3R5cGUsICdhbmdsZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5hbmdsZS52YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuYW5nbGUudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG5QSVhJLkNyb3NzSGF0Y2hGaWx0ZXIgPSBmdW5jdGlvbigpXG57XG4gICAgUElYSS5BYnN0cmFjdEZpbHRlci5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnBhc3NlcyA9IFt0aGlzXTtcblxuICAgIC8vIHNldCB0aGUgdW5pZm9ybXNcbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgICBibHVyOiB7dHlwZTogJzFmJywgdmFsdWU6IDEgLyA1MTJ9XG4gICAgfTtcblxuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBbXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgYmx1cjsnLFxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgIGZsb2F0IGx1bSA9IGxlbmd0aCh0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQueHkpLnJnYik7JyxcblxuICAgICAgICAnICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTsnLFxuXG4gICAgICAgICcgICAgaWYgKGx1bSA8IDEuMDApIHsnLFxuICAgICAgICAnICAgICAgICBpZiAobW9kKGdsX0ZyYWdDb29yZC54ICsgZ2xfRnJhZ0Nvb3JkLnksIDEwLjApID09IDAuMCkgeycsXG4gICAgICAgICcgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCk7JyxcbiAgICAgICAgJyAgICAgICAgfScsXG4gICAgICAgICcgICAgfScsXG5cbiAgICAgICAgJyAgICBpZiAobHVtIDwgMC43NSkgeycsXG4gICAgICAgICcgICAgICAgIGlmIChtb2QoZ2xfRnJhZ0Nvb3JkLnggLSBnbF9GcmFnQ29vcmQueSwgMTAuMCkgPT0gMC4wKSB7JyxcbiAgICAgICAgJyAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKTsnLFxuICAgICAgICAnICAgICAgICB9JyxcbiAgICAgICAgJyAgICB9JyxcblxuICAgICAgICAnICAgIGlmIChsdW0gPCAwLjUwKSB7JyxcbiAgICAgICAgJyAgICAgICAgaWYgKG1vZChnbF9GcmFnQ29vcmQueCArIGdsX0ZyYWdDb29yZC55IC0gNS4wLCAxMC4wKSA9PSAwLjApIHsnLFxuICAgICAgICAnICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApOycsXG4gICAgICAgICcgICAgICAgIH0nLFxuICAgICAgICAnICAgIH0nLFxuXG4gICAgICAgICcgICAgaWYgKGx1bSA8IDAuMykgeycsXG4gICAgICAgICcgICAgICAgIGlmIChtb2QoZ2xfRnJhZ0Nvb3JkLnggLSBnbF9GcmFnQ29vcmQueSAtIDUuMCwgMTAuMCkgPT0gMC4wKSB7JyxcbiAgICAgICAgJyAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKTsnLFxuICAgICAgICAnICAgICAgICB9JyxcbiAgICAgICAgJyAgICB9JyxcbiAgICAgICAgJ30nXG4gICAgXTtcbn07XG5cblBJWEkuQ3Jvc3NIYXRjaEZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQSVhJLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSApO1xuUElYSS5Dcm9zc0hhdGNoRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuQmx1cllGaWx0ZXI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLkNyb3NzSGF0Y2hGaWx0ZXIucHJvdG90eXBlLCAnYmx1cicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5ibHVyLnZhbHVlIC8gKDEvNzAwMCk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIC8vdGhpcy5wYWRkaW5nID0gdmFsdWU7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuYmx1ci52YWx1ZSA9ICgxLzcwMDApICogdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuUElYSS5SR0JTcGxpdEZpbHRlciA9IGZ1bmN0aW9uKClcbntcbiAgICBQSVhJLkFic3RyYWN0RmlsdGVyLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMucGFzc2VzID0gW3RoaXNdO1xuXG4gICAgLy8gc2V0IHRoZSB1bmlmb3Jtc1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICAgIHJlZDoge3R5cGU6ICcyZicsIHZhbHVlOiB7eDoyMCwgeToyMH19LFxuICAgICAgICBncmVlbjoge3R5cGU6ICcyZicsIHZhbHVlOiB7eDotMjAsIHk6MjB9fSxcbiAgICAgICAgYmx1ZToge3R5cGU6ICcyZicsIHZhbHVlOiB7eDoyMCwgeTotMjB9fSxcbiAgICAgICAgZGltZW5zaW9uczogICB7dHlwZTogJzRmdicsIHZhbHVlOlswLDAsMCwwXX1cbiAgICB9O1xuXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMyIHJlZDsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMyIGdyZWVuOycsXG4gICAgICAgICd1bmlmb3JtIHZlYzIgYmx1ZTsnLFxuICAgICAgICAndW5pZm9ybSB2ZWM0IGRpbWVuc2lvbnM7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvci5yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkICsgcmVkL2RpbWVuc2lvbnMueHkpLnI7JyxcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvci5nID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkICsgZ3JlZW4vZGltZW5zaW9ucy54eSkuZzsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yLmIgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQgKyBibHVlL2RpbWVuc2lvbnMueHkpLmI7JyxcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvci5hID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKS5hOycsXG4gICAgICAgICd9J1xuICAgIF07XG59O1xuXG5QSVhJLlJHQlNwbGl0RmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBJWEkuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlICk7XG5QSVhJLlJHQlNwbGl0RmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuUkdCU3BsaXRGaWx0ZXI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLlJHQlNwbGl0RmlsdGVyLnByb3RvdHlwZSwgJ2FuZ2xlJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmJsdXIudmFsdWUgLyAoMS83MDAwKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy90aGlzLnBhZGRpbmcgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5ibHVyLnZhbHVlID0gKDEvNzAwMCkgKiB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4gICAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFBJWEk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0cy5QSVhJID0gUElYSTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFBJWEkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuUElYSSA9IFBJWEk7XG4gICAgfVxufSkuY2FsbCh0aGlzKTsiLCIoZnVuY3Rpb24oKSB7XG5cbnZhciBQSVhJO1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0UElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xufSBlbHNlIHtcblx0UElYSSA9IHdpbmRvdy5QSVhJO1xufVxuLyoqXG4gKiBBUzMvanF1ZXJ5IHN0eWxlIGV2ZW50IGRpc3BhdGNoZXIuIFNsaWdodGx5IG1vZGlmaWVkLiBUaGVcbiAqIGpxdWVyeSBzdHlsZSBvbi9vZmYvdHJpZ2dlciBzdHlsZSBvZiBhZGRpbmcgbGlzdGVuZXJzIGlzXG4gKiBjdXJyZW50bHkgdGhlIHByZWZlcnJlZCBvbmUuXG4gKlxuICogVGhlIG9uIG1ldGhvZCBmb3IgYWRkaW5nIGxpc3RlbmVycyB0YWtlcyBhbiBleHRyYSBwYXJhbWV0ZXIgd2hpY2ggaXMgdGhlXG4gKiBzY29wZSBpbiB3aGljaCBsaXN0ZW5lcnMgc2hvdWxkIGJlIGNhbGxlZC4gU28gdGhpczpcbiAqXG4gKiAgICAgb2JqZWN0Lm9uKFwiZXZlbnRcIiwgbGlzdGVuZXIsIHRoaXMpO1xuICpcbiAqIEhhcyB0aGUgc2FtZSBmdW5jdGlvbiB3aGVuIGFkZGluZyBldmVudHMgYXM6XG4gKlxuICogICAgIG9iamVjdC5vbihcImV2ZW50XCIsIGxpc3RlbmVyLmJpbmQodGhpcykpO1xuICpcbiAqIEhvd2V2ZXIsIHRoZSBkaWZmZXJlbmNlIGlzIHRoYXQgaWYgd2UgdXNlIHRoZSBzZWNvbmQgbWV0aG9kIGl0XG4gKiB3aWxsIG5vdCBiZSBwb3NzaWJsZSB0byByZW1vdmUgdGhlIGxpc3RlbmVycyBsYXRlciwgdW5sZXNzXG4gKiB0aGUgY2xvc3VyZSBjcmVhdGVkIGJ5IGJpbmQgaXMgc3RvcmVkIHNvbWV3aGVyZS4gSWYgdGhlXG4gKiBmaXJzdCBtZXRob2QgaXMgdXNlZCwgd2UgY2FuIHJlbW92ZSB0aGUgbGlzdGVuZXIgd2l0aDpcbiAqXG4gKiAgICAgb2JqZWN0Lm9mZihcImV2ZW50XCIsIGxpc3RlbmVyLCB0aGlzKTtcbiAqXG4gKiBAY2xhc3MgRXZlbnREaXNwYXRjaGVyXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gRXZlbnREaXNwYXRjaGVyKCkge1xuXHR0aGlzLmxpc3RlbmVyTWFwID0ge307XG59XG5cbi8qKlxuICogQWRkIGV2ZW50IGxpc3RlbmVyLlxuICogQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyXG4gKi9cbkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgbGlzdGVuZXIsIHNjb3BlKSB7XG5cdGlmICghdGhpcy5saXN0ZW5lck1hcClcblx0XHR0aGlzLmxpc3RlbmVyTWFwID0ge307XG5cblx0aWYgKCFldmVudFR5cGUpXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgdHlwZSByZXF1aXJlZCBmb3IgZXZlbnQgZGlzcGF0Y2hlclwiKTtcblxuXHRpZiAoIWxpc3RlbmVyKVxuXHRcdHRocm93IG5ldyBFcnJvcihcIkxpc3RlbmVyIHJlcXVpcmVkIGZvciBldmVudCBkaXNwYXRjaGVyXCIpO1xuXG5cdHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyLCBzY29wZSk7XG5cblx0aWYgKCF0aGlzLmxpc3RlbmVyTWFwLmhhc093blByb3BlcnR5KGV2ZW50VHlwZSkpXG5cdFx0dGhpcy5saXN0ZW5lck1hcFtldmVudFR5cGVdID0gW107XG5cblx0dGhpcy5saXN0ZW5lck1hcFtldmVudFR5cGVdLnB1c2goe1xuXHRcdGxpc3RlbmVyOiBsaXN0ZW5lcixcblx0XHRzY29wZTogc2NvcGVcblx0fSk7XG59XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVyLlxuICogQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyXG4gKi9cbkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgbGlzdGVuZXIsIHNjb3BlKSB7XG5cdGlmICghdGhpcy5saXN0ZW5lck1hcClcblx0XHR0aGlzLmxpc3RlbmVyTWFwID0ge307XG5cblx0aWYgKCF0aGlzLmxpc3RlbmVyTWFwLmhhc093blByb3BlcnR5KGV2ZW50VHlwZSkpXG5cdFx0cmV0dXJuO1xuXG5cdHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyTWFwW2V2ZW50VHlwZV07XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgbGlzdGVuZXJPYmogPSBsaXN0ZW5lcnNbaV07XG5cblx0XHRpZiAobGlzdGVuZXIgPT0gbGlzdGVuZXJPYmoubGlzdGVuZXIgJiYgc2NvcGUgPT0gbGlzdGVuZXJPYmouc2NvcGUpIHtcblx0XHRcdGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRpLS07XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFsaXN0ZW5lcnMubGVuZ3RoKVxuXHRcdGRlbGV0ZSB0aGlzLmxpc3RlbmVyTWFwW2V2ZW50VHlwZV07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggZXZlbnQuXG4gKiBAbWV0aG9kIGRpc3BhdGNoRXZlbnRcbiAqL1xuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oZXZlbnQgLyogLi4uICovICkge1xuXHRpZiAoIXRoaXMubGlzdGVuZXJNYXApXG5cdFx0dGhpcy5saXN0ZW5lck1hcCA9IHt9O1xuXG5cdHZhciBldmVudFR5cGU7XG5cdHZhciBsaXN0ZW5lclBhcmFtcztcblxuXHRpZiAodHlwZW9mIGV2ZW50ID09IFwic3RyaW5nXCIpIHtcblx0XHRldmVudFR5cGUgPSBldmVudDtcblx0XHRsaXN0ZW5lclBhcmFtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdH0gZWxzZSB7XG5cdFx0ZXZlbnRUeXBlID0gZXZlbnQudHlwZTtcblx0XHRldmVudC50YXJnZXQgPSB0aGlzO1xuXHRcdGxpc3RlbmVyUGFyYW1zID0gW2V2ZW50XTtcblx0fVxuXG5cdGlmICghdGhpcy5saXN0ZW5lck1hcC5oYXNPd25Qcm9wZXJ0eShldmVudFR5cGUpKVxuXHRcdHJldHVybjtcblxuXHRmb3IgKHZhciBpIGluIHRoaXMubGlzdGVuZXJNYXBbZXZlbnRUeXBlXSkge1xuXHRcdHZhciBsaXN0ZW5lck9iaiA9IHRoaXMubGlzdGVuZXJNYXBbZXZlbnRUeXBlXVtpXTtcblx0XHRsaXN0ZW5lck9iai5saXN0ZW5lci5hcHBseShsaXN0ZW5lck9iai5zY29wZSwgbGlzdGVuZXJQYXJhbXMpO1xuXHR9XG59XG5cbi8qKlxuICogSnF1ZXJ5IHN0eWxlIGFsaWFzIGZvciBhZGRFdmVudExpc3RlbmVyXG4gKiBAbWV0aG9kIG9uXG4gKi9cbkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUub24gPSBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XG5cbi8qKlxuICogSnF1ZXJ5IHN0eWxlIGFsaWFzIGZvciByZW1vdmVFdmVudExpc3RlbmVyXG4gKiBAbWV0aG9kIG9mZlxuICovXG5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxuLyoqXG4gKiBKcXVlcnkgc3R5bGUgYWxpYXMgZm9yIGRpc3BhdGNoRXZlbnRcbiAqIEBtZXRob2QgdHJpZ2dlclxuICovXG5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLnRyaWdnZXIgPSBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQ7XG5cbi8qKlxuICogTWFrZSBzb21ldGhpbmcgYW4gZXZlbnQgZGlzcGF0Y2hlci4gQ2FuIGJlIHVzZWQgZm9yIG11bHRpcGxlIGluaGVyaXRhbmNlLlxuICogQG1ldGhvZCBpbml0XG4gKiBAc3RhdGljXG4gKi9cbkV2ZW50RGlzcGF0Y2hlci5pbml0ID0gZnVuY3Rpb24oY2xzKSB7XG5cdGNscy5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcblx0Y2xzLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXHRjbHMucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQ7XG5cdGNscy5wcm90b3R5cGUub24gPSBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLm9uO1xuXHRjbHMucHJvdG90eXBlLm9mZiA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUub2ZmO1xuXHRjbHMucHJvdG90eXBlLnRyaWdnZXIgPSBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLnRyaWdnZXI7XG59XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuXHRtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RGlzcGF0Y2hlcjtcbn1cblxuLyoqXG4gKiBLZWVwIGNvbnRlbnQgd2l0aCBhIGxvZ2ljIHNpemUgaW5zaWRlIGJvdW5kYXJpZXMuXG4gKiBAY2xhc3MgQ29udGVudFNjYWxlclxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIENvbnRlbnRTY2FsZXIoY29udGVudCkge1xuXHRQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIuY2FsbCh0aGlzKTtcblxuXHR0aGlzLmNvbnRlbnRXaWR0aCA9IDEwMDtcblx0dGhpcy5jb250ZW50SGVpZ2h0ID0gMTAwO1xuXG5cdHRoaXMuc2NyZWVuV2lkdGggPSAxMDA7XG5cdHRoaXMuc2NyZWVuSGVpZ2h0ID0gMTAwO1xuXG5cdHRoaXMudGhlTWFzayA9IG51bGw7XG5cblx0aWYgKGNvbnRlbnQpXG5cdFx0dGhpcy5zZXRDb250ZW50KGNvbnRlbnQpO1xuXG5cdHRoaXMudmVydGljYWxBbGlnbiA9IENvbnRlbnRTY2FsZXIuTUlERExFO1xuXHR0aGlzLmhvcml6b250YWxBbGlnbiA9IENvbnRlbnRTY2FsZXIuQ0VOVEVSO1xuXHR0aGlzLnNjYWxlTW9kZSA9IENvbnRlbnRTY2FsZXIuU0hPV19BTEw7XG5cblx0dGhpcy5taW5TY2FsZSA9IC0xO1xuXHR0aGlzLm1heFNjYWxlID0gLTE7XG5cblx0dGhpcy5tYXNrQ29udGVudEVuYWJsZWQgPSBmYWxzZTtcblx0dGhpcy5tYXNrQ29sb3IgPSAweDAwMDAwMDtcbn1cblxuQ29udGVudFNjYWxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUpO1xuQ29udGVudFNjYWxlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb250ZW50U2NhbGVyO1xuXG5Db250ZW50U2NhbGVyLlRPUCA9IFwidG9wXCI7XG5Db250ZW50U2NhbGVyLk1JRERMRSA9IFwibWlkZGxlXCI7XG5Db250ZW50U2NhbGVyLkJPVFRPTSA9IFwiYm90dG9tXCI7XG5cbkNvbnRlbnRTY2FsZXIuTEVGVCA9IFwibGVmdFwiO1xuQ29udGVudFNjYWxlci5DRU5URVIgPSBcImNlbnRlclwiO1xuQ29udGVudFNjYWxlci5SSUdIVCA9IFwicmlnaHRcIjtcblxuQ29udGVudFNjYWxlci5OT19CT1JERVIgPSBcIm5vQm9yZGVyXCI7XG5Db250ZW50U2NhbGVyLk5PX1NDQUxFID0gXCJub1NjYWxlXCI7XG5Db250ZW50U2NhbGVyLlNIT1dfQUxMID0gXCJzaG93QWxsXCI7XG5cbi8qKlxuICogU2hvdWxkIHRoZSBjb250ZW50IGJlIG1hc2tlZD9cbiAqIEBtZXRob2Qgc2V0TWFza0NvbnRlbnRFbmFibGVkXG4gKi9cbkNvbnRlbnRTY2FsZXIucHJvdG90eXBlLnNldE1hc2tDb250ZW50RW5hYmxlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdHRoaXMubWFza0NvbnRlbnRFbmFibGVkID0gdmFsdWU7XG5cdHRoaXMudXBkYXRlU2NhbGUoKTtcbn1cblxuLyoqXG4gKiBTZXQgY29sb3Igb2YgdGhlIG1hc2suXG4gKiBAbWV0aG9kIHNldE1hc2tDb2xvclxuICovXG5Db250ZW50U2NhbGVyLnByb3RvdHlwZS5zZXRNYXNrQ29sb3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHR0aGlzLm1hc2tDb2xvciA9IHZhbHVlO1xuXHR0aGlzLnVwZGF0ZVNjYWxlKCk7XG59XG5cbi8qKlxuICogU2V0IG1pbmltdW0gdmFsdWUgZm9yIHNjYWxlLlxuICogQG1ldGhvZCBzZXRNaW5TY2FsZVxuICovXG5Db250ZW50U2NhbGVyLnByb3RvdHlwZS5zZXRNaW5TY2FsZSA9IGZ1bmN0aW9uKG1pblNjYWxlKSB7XG5cdHRoaXMubWluU2NhbGUgPSBtaW5TY2FsZTtcblx0dGhpcy51cGRhdGVTY2FsZSgpO1xufVxuXG4vKipcbiAqIFNldCBtYXhpbXVtIHZhbHVlIGZvciBzY2FsZS5cbiAqIEBtZXRob2Qgc2V0TWF4U2NhbGVcbiAqL1xuQ29udGVudFNjYWxlci5wcm90b3R5cGUuc2V0TWF4U2NhbGUgPSBmdW5jdGlvbihtYXhTY2FsZSkge1xuXHR0aGlzLm1heFNjYWxlID0gbWF4U2NhbGU7XG5cdHRoaXMudXBkYXRlU2NhbGUoKTtcbn1cblxuLyoqXG4gKiBTZXQgY29udGVudCB0byB1c2UuXG4gKiBAbWV0aG9kIHNldENvbnRlbnRcbiAqL1xuQ29udGVudFNjYWxlci5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uKGNvbnRlbnQpIHtcblx0aWYgKHRoaXMuY29udGVudClcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb250ZW50IGFscmVhZHkgc2V0LlwiKTtcblxuXHR0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuXHR0aGlzLmFkZENoaWxkKHRoaXMuY29udGVudCk7XG5cblx0aWYgKHRoaXMudGhlTWFzaykge1xuXHRcdHRoaXMucmVtb3ZlQ2hpbGQodGhpcy50aGVNYXNrKTtcblx0XHR0aGlzLnRoZU1hc2sgPSBudWxsO1xuXHR9XG5cblx0dGhpcy50aGVNYXNrID0gbmV3IFBJWEkuR3JhcGhpY3MoKTtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLnRoZU1hc2spO1xuXG5cdHRoaXMudXBkYXRlU2NhbGUoKTtcbn1cblxuLyoqXG4gKiBTZXQgbG9naWMgc2l6ZSBvZiB0aGUgY29udGVudC5cbiAqIEBtZXRob2Qgc2V0Q29udGVudFNpemVcbiAqL1xuQ29udGVudFNjYWxlci5wcm90b3R5cGUuc2V0Q29udGVudFNpemUgPSBmdW5jdGlvbihjb250ZW50V2lkdGgsIGNvbnRlbnRIZWlnaHQpIHtcblx0dGhpcy5jb250ZW50V2lkdGggPSBjb250ZW50V2lkdGg7XG5cdHRoaXMuY29udGVudEhlaWdodCA9IGNvbnRlbnRIZWlnaHQ7XG5cdHRoaXMudXBkYXRlU2NhbGUoKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGFjdHVhbCBzY3JlZW4gc2l6ZS5cbiAqIEBtZXRob2Qgc2V0U2NyZWVuU2l6ZVxuICovXG5Db250ZW50U2NhbGVyLnByb3RvdHlwZS5zZXRTY3JlZW5TaXplID0gZnVuY3Rpb24oc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCkge1xuXHR0aGlzLnNjcmVlbldpZHRoID0gc2NyZWVuV2lkdGg7XG5cdHRoaXMuc2NyZWVuSGVpZ2h0ID0gc2NyZWVuSGVpZ2h0O1xuXHR0aGlzLnVwZGF0ZVNjYWxlKCk7XG59XG5cbi8qKlxuICogU2V0IGhvdyB0aGUgY29udGVudCBzaG91bGQgYmUgYWxpZ25lZCBvbiB0aGUgc2NyZWVuLlxuICogQG1ldGhvZCBzZXRWZXJ0aWNhbEFsaWduXG4gKi9cbkNvbnRlbnRTY2FsZXIucHJvdG90eXBlLnNldFZlcnRpY2FsQWxpZ24gPSBmdW5jdGlvbihhbGlnbikge1xuXHR0aGlzLnZlcnRpY2FsQWxpZ24gPSBhbGlnbjtcblx0dGhpcy51cGRhdGVTY2FsZSgpO1xufVxuXG4vKipcbiAqIFNldCBob3cgdGhlIGNvbnRlbnQgc2hvdWxkIGJlIGFsaWduZWQgb24gdGhlIHNjcmVlbi5cbiAqIEBtZXRob2Qgc2V0SG9yaXpvbnRhbEFsaWduXG4gKi9cbkNvbnRlbnRTY2FsZXIucHJvdG90eXBlLnNldEhvcml6b250YWxBbGlnbiA9IGZ1bmN0aW9uKGFsaWduKSB7XG5cdHRoaXMuaG9yaXpvbnRhbEFsaWduID0gYWxpZ247XG5cdHRoaXMudXBkYXRlU2NhbGUoKTtcbn1cblxuLyoqXG4gKiBTZXQgc2NhbGUgbW9kZS5cbiAqIEBtZXRob2Qgc2V0U2NhbGVNb2RlXG4gKi9cbkNvbnRlbnRTY2FsZXIucHJvdG90eXBlLnNldFNjYWxlTW9kZSA9IGZ1bmN0aW9uKHNjYWxlTW9kZSkge1xuXHR0aGlzLnNjYWxlTW9kZSA9IHNjYWxlTW9kZTtcblx0dGhpcy51cGRhdGVTY2FsZSgpO1xufVxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgc2NhbGluZy5cbiAqIEBtZXRob2QgdXBkYXRlU2NhbGVcbiAqIEBwcml2YXRlXG4gKi9cbkNvbnRlbnRTY2FsZXIucHJvdG90eXBlLnVwZGF0ZVNjYWxlID0gZnVuY3Rpb24oKSB7XG5cdHZhciBzY2FsZTtcblxuXHRpZiAodGhpcy5zY2FsZU1vZGUgPT0gQ29udGVudFNjYWxlci5OT19TQ0FMRSkge1xuXHRcdHNjYWxlID0gMTtcblx0fSBlbHNlIGlmICh0aGlzLnNjYWxlTW9kZSA9PSBDb250ZW50U2NhbGVyLk5PX0JPUkRFUikge1xuXHRcdGlmICh0aGlzLnNjcmVlbldpZHRoIC8gdGhpcy5jb250ZW50V2lkdGggPiB0aGlzLnNjcmVlbkhlaWdodCAvIHRoaXMuY29udGVudEhlaWdodClcblx0XHRcdHNjYWxlID0gdGhpcy5zY3JlZW5XaWR0aCAvIHRoaXMuY29udGVudFdpZHRoO1xuXG5cdFx0ZWxzZVxuXHRcdFx0c2NhbGUgPSB0aGlzLnNjcmVlbkhlaWdodCAvIHRoaXMuY29udGVudEhlaWdodDtcblx0fSBlbHNlIHtcblx0XHRpZiAodGhpcy5zY3JlZW5XaWR0aCAvIHRoaXMuY29udGVudFdpZHRoIDwgdGhpcy5zY3JlZW5IZWlnaHQgLyB0aGlzLmNvbnRlbnRIZWlnaHQpXG5cdFx0XHRzY2FsZSA9IHRoaXMuc2NyZWVuV2lkdGggLyB0aGlzLmNvbnRlbnRXaWR0aDtcblxuXHRcdGVsc2Vcblx0XHRcdHNjYWxlID0gdGhpcy5zY3JlZW5IZWlnaHQgLyB0aGlzLmNvbnRlbnRIZWlnaHQ7XG5cdH1cblxuXHRpZiAodGhpcy5taW5TY2FsZSA+IDAgJiYgc2NhbGUgPCB0aGlzLm1pblNjYWxlKVxuXHRcdHNjYWxlID0gdGhpcy5taW5TY2FsZTtcblxuXHRpZiAodGhpcy5tYXhTY2FsZSA+IDAgJiYgc2NhbGUgPiB0aGlzLm1heFNjYWxlKVxuXHRcdHNjYWxlID0gdGhpcy5tYXhTY2FsZTtcblxuXHR0aGlzLmNvbnRlbnQuc2NhbGUueCA9IHNjYWxlO1xuXHR0aGlzLmNvbnRlbnQuc2NhbGUueSA9IHNjYWxlO1xuXG5cdHZhciBzY2FsZWRXaWR0aCA9IHRoaXMuY29udGVudFdpZHRoICogc2NhbGU7XG5cdHZhciBzY2FsZWRIZWlnaHQgPSB0aGlzLmNvbnRlbnRIZWlnaHQgKiBzY2FsZTtcblxuXHR0aGlzLmNvbnRlbnQucG9zaXRpb24ueCA9ICh0aGlzLnNjcmVlbldpZHRoIC0gc2NhbGVkV2lkdGgpIC8gMjtcblxuXHRpZiAodGhpcy52ZXJ0aWNhbEFsaWduID09IENvbnRlbnRTY2FsZXIuVE9QKVxuXHRcdHRoaXMuY29udGVudC5wb3NpdGlvbi55ID0gMDtcblxuXHRlbHNlIGlmICh0aGlzLnZlcnRpY2FsQWxpZ24gPT0gQ29udGVudFNjYWxlci5CT1RUT00pXG5cdFx0dGhpcy5jb250ZW50LnBvc2l0aW9uLnkgPSB0aGlzLnNjcmVlbkhlaWdodCAtIHNjYWxlZEhlaWdodDtcblxuXHRlbHNlXG5cdFx0dGhpcy5jb250ZW50LnBvc2l0aW9uLnkgPSAodGhpcy5zY3JlZW5IZWlnaHQgLSBzY2FsZWRIZWlnaHQpIC8gMjtcblxuXHRpZiAodGhpcy5ob3Jpem9udGFsQWxpZ24gPT0gQ29udGVudFNjYWxlci5MRUZUKVxuXHRcdHRoaXMuY29udGVudC5wb3NpdGlvbi54ID0gMDtcblxuXHRlbHNlIGlmICh0aGlzLmhvcml6b250YWxBbGlnbiA9PSBDb250ZW50U2NhbGVyLlJJR0hUKVxuXHRcdHRoaXMuY29udGVudC5wb3NpdGlvbi54ID0gdGhpcy5zY3JlZW5XaWR0aCAtIHNjYWxlZFdpZHRoO1xuXG5cdGVsc2Vcblx0XHR0aGlzLmNvbnRlbnQucG9zaXRpb24ueCA9ICh0aGlzLnNjcmVlbldpZHRoIC0gc2NhbGVkV2lkdGgpIC8gMjtcblxuXHR2YXIgciA9IG5ldyBQSVhJLlJlY3RhbmdsZSh0aGlzLmNvbnRlbnQucG9zaXRpb24ueCwgdGhpcy5jb250ZW50LnBvc2l0aW9uLnksIHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuXHR2YXIgcmlnaHQgPSByLnggKyByLndpZHRoO1xuXHR2YXIgYm90dG9tID0gci55ICsgci5oZWlnaHQ7XG5cblx0dGhpcy50aGVNYXNrLmNsZWFyKCk7XG5cblx0aWYgKHRoaXMubWFza0NvbnRlbnRFbmFibGVkKSB7XG5cdFx0dGhpcy50aGVNYXNrLmJlZ2luRmlsbCh0aGlzLm1hc2tDb2xvciwgMSk7XG5cdFx0dGhpcy50aGVNYXNrLmRyYXdSZWN0KDAsIDAsIHRoaXMuc2NyZWVuV2lkdGgsIHIueSk7XG5cdFx0dGhpcy50aGVNYXNrLmRyYXdSZWN0KDAsIDAsIHIueCwgdGhpcy5zY3JlZW5IZWlnaHQpO1xuXHRcdHRoaXMudGhlTWFzay5kcmF3UmVjdChyaWdodCwgMCwgdGhpcy5zY3JlZW5XaWR0aCAtIHJpZ2h0LCB0aGlzLnNjcmVlbkhlaWdodCk7XG5cdFx0dGhpcy50aGVNYXNrLmRyYXdSZWN0KDAsIGJvdHRvbSwgdGhpcy5zY3JlZW5XaWR0aCwgdGhpcy5zY3JlZW5IZWlnaHQgLSBib3R0b20pO1xuXHRcdHRoaXMudGhlTWFzay5lbmRGaWxsKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBHZXQgdmlzaWJsZSByZWN0YW5nbGUuXG4gKiBAbWV0aG9kIGdldFZpc2libGVSZWN0XG4gKi9cbkNvbnRlbnRTY2FsZXIucHJvdG90eXBlLmdldFZpc2libGVSZWN0ID0gZnVuY3Rpb24oKSB7XG5cdHZhciB4ID0gLXRoaXMuY29udGVudC5wb3NpdGlvbi54IC8gdGhpcy5jb250ZW50LnNjYWxlLng7XG5cdHZhciB5ID0gLXRoaXMuY29udGVudC5wb3NpdGlvbi55IC8gdGhpcy5jb250ZW50LnNjYWxlLnk7XG5cblx0dmFyIHdpZHRoID0gdGhpcy5zY3JlZW5XaWR0aCAvIHRoaXMuY29udGVudC5zY2FsZS54O1xuXHR2YXIgaGVpZ2h0ID0gdGhpcy5zY3JlZW5IZWlnaHQgLyB0aGlzLmNvbnRlbnQuc2NhbGUueTtcblx0Ly8gdGhpcy5jb250ZW50LnBvc2l0aW9uLCB0aGlzLmNvbnRlbnQucG9zaXRpb24sIHRoaXMuc2NyZWVuV2lkdGgsIHRoaXMuc2NyZWVuSGVpZ2h0XG5cblx0cmV0dXJuIG5ldyBQSVhJLlJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbn1cbi8qKlxuICogTWFuYWdlcyB0aGUgbWFpbiBsb29wIGFuZCBzY2FsaW5nIG9mIGEgUElYSSBhcHBsaWNhdGlvbi5cbiAqIFRoZSBpbnRlbmRlZCB3YXkgb2YgdXNpbmcgdGhpcyBjbGFzcyBpcyB0byBleHRlbmQgaXQsIGZvciBleGFtcGxlOlxuICpcbiAqICAgICB2YXIgUElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xuICogICAgIHZhciBQaXhpQXBwID0gcmVxdWlyZShcIlBpeGlBcHBcIik7XG4gKiAgICAgdmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xuICpcbiAqICAgICBmdW5jdGlvbiBNeUFwcCgpIHtcbiAqICAgICAgICAgUGl4aUFwcC5jYWxsKHRoaXMpO1xuICpcbiAqICAgICAgICAgdmFyIHQgPSBuZXcgUElYSS5UZXh0KFwiSGVsbG8gUElYSS5qcyFcIik7XG4gKiAgICAgICAgIHRoaXMuYWRkQ2hpbGQodCk7XG4gKiAgICAgfVxuICpcbiAqICAgICBpbmhlcml0cyhNeUFwcCwgUGl4aUFwcCk7XG4gKlxuICogICAgIG5ldyBNeUFwcCgpO1xuICogQGNsYXNzIFBpeGlBcHBcbiAqL1xuZnVuY3Rpb24gUGl4aUFwcCh3aWR0aCwgaGVpZ2h0KSB7XG5cdFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKHRoaXMpO1xuXG5cdHRoaXMuX2FwcGxpY2F0aW9uV2lkdGggPSB3aWR0aDtcblx0dGhpcy5fYXBwbGljYXRpb25IZWlnaHQgPSBoZWlnaHQ7XG5cdHRoaXMuX2JhY2tncm91bmRDb2xvciA9IDB4ZmZmZmZmO1xuXG5cdHNldFRpbWVvdXQodGhpcy5vbkNoZWNrUmVhZHlUaW1lb3V0LmJpbmQodGhpcyksIDApO1xuXG5cdHRoaXMuY29udGVudFNjYWxlciA9IG5ldyBDb250ZW50U2NhbGVyKHRoaXMpO1xufVxuXG5QaXhpQXBwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZSk7XG5QaXhpQXBwLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBpeGlBcHA7XG5cbkV2ZW50RGlzcGF0Y2hlci5pbml0KFBpeGlBcHApO1xuXG4vKipcbiAqIERpc3BhdGNoZWQgaWYgdGhlIGFwcCBpcyByZXNpemVkLlxuICogQGV2ZW50IHJlc2l6ZVxuICovXG5cbi8qKlxuICogRGlzcGF0Y2hlZCBldmVyeSBmcmFtZSBiZWZvcmUgcmVuZGVyaW5nLlxuICogVGhlIHRpbWUgaXMgc2VuZCB0byB0aGUgbGlzdGVuaW5nIGZ1bmN0aW9uIGFzIHBhcmFtZXRlci5cbiAqIEBldmVudCBmcmFtZVxuICovXG5cblBpeGlBcHAuVE9QID0gQ29udGVudFNjYWxlci5UT1A7XG5QaXhpQXBwLk1JRERMRSA9IENvbnRlbnRTY2FsZXIuTUlERExFO1xuUGl4aUFwcC5CT1RUT00gPSBDb250ZW50U2NhbGVyLkJPVFRPTTtcblxuUGl4aUFwcC5MRUZUID0gQ29udGVudFNjYWxlci5MRUZUO1xuUGl4aUFwcC5DRU5URVIgPSBDb250ZW50U2NhbGVyLkNFTlRFUjtcblBpeGlBcHAuUklHSFQgPSBDb250ZW50U2NhbGVyLlJJR0hUO1xuXG5QaXhpQXBwLk5PX0JPUkRFUiA9IENvbnRlbnRTY2FsZXIuTk9fQk9SREVSO1xuUGl4aUFwcC5OT19TQ0FMRSA9IENvbnRlbnRTY2FsZXIuTk9fU0NBTEU7XG5QaXhpQXBwLlNIT1dfQUxMID0gQ29udGVudFNjYWxlci5TSE9XX0FMTDtcblxuLyoqXG4gKiBDaGVjayBpZiBpdCdzIHRpbWUgdG8gYXR0YWNoIG91cnNlbHZlcy5cbiAqIEBtZXRob2Qgb25DaGVja1JlYWR5VGltZW91dFxuICogQHByaXZhdGVcbiAqL1xuUGl4aUFwcC5wcm90b3R5cGUub25DaGVja1JlYWR5VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5hdHRhY2hlZFRvRWxlbWVudClcblx0XHRyZXR1cm47XG5cblx0aWYgKCFkb2N1bWVudC5ib2R5KSB7XG5cdFx0c2V0VGltZW91dCh0aGlzLm9uQ2hlY2tSZWFkeVRpbWVvdXQuYmluZCh0aGlzKSwgMCk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dGhpcy5hdHRhY2hUb0VsZW1lbnQoZG9jdW1lbnQuYm9keSk7XG59XG5cbi8qKlxuICogQXR0YWNoIHRvIGFuIGVsZW1lbnQgaW4gdGhlIGRvY3VtZW50LlxuICogSWYgdGhpcyBmdW5jdGlvbiBpcyBub3QgY2FsbGVkLCB0aGUgYXBwIHdpbGwgYmUgYXR0YWNoZWRcbiAqIHRvIGVudGlyZSBicm93c2VyIHdpbmRvdy5cbiAqIEBtZXRob2QgYXR0YWNoVG9FbGVtZW50XG4gKiBAcGFyYW0gZWxlbWVudCB7RE9NRWxlbWVudH0gVGhlIGVsZW1lbnQgdG8gYXR0YWNoIHRvLlxuICovXG5QaXhpQXBwLnByb3RvdHlwZS5hdHRhY2hUb0VsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cdGlmICh0aGlzLmF0dGFjaGVkVG9FbGVtZW50KVxuXHRcdHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgYXR0YWNoZWQhXCIpO1xuXG5cdGlmICh0eXBlb2YgZWxlbWVudCA9PSBcInN0cmluZ1wiKVxuXHRcdGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50KTtcblxuXHRpZiAoIWVsZW1lbnQpXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhhdCdzIG5vdCBhbiBlbGVtZW50IVwiKTtcblxuXHQvL2NvbnNvbGUubG9nKFwiKiogYXR0YWNoaW5nIHRvIGVsZW1lbnQsIHc9XCIgKyBlbGVtZW50LmNsaWVudFdpZHRoICsgXCIgaD1cIiArIGVsZW1lbnQuY2xpZW50SGVpZ2h0KTtcblxuXHR0aGlzLmNvbnRhaW5lckVsZW1lbnQgPSBlbGVtZW50O1xuXHR0aGlzLmF0dGFjaGVkVG9FbGVtZW50ID0gdHJ1ZTtcblxuXHR2YXIgdmlldztcblxuXHRpZiAobmF2aWdhdG9yLmlzQ29jb29uSlMpXG5cdFx0dmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmVlbmNhbnZhcycpO1xuXG5cdGVsc2Vcblx0XHR2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cblx0dmlldy5zdHlsZS5tYXJnaW4gPSAwO1xuXHR2aWV3LnN0eWxlLnBhZGRpbmcgPSAwO1xuXG5cdGlmICh0aGlzLmNvbnRhaW5lckVsZW1lbnQgPT0gZG9jdW1lbnQuYm9keSkge1xuXHRcdC8vY29uc29sZS5sb2coXCJzdHlsZTogXCIgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuaGVpZ2h0KTtcblxuXHRcdHZpZXcuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG5cblx0XHRkb2N1bWVudC5ib2R5LnN0eWxlLm1hcmdpbiA9IDA7XG5cdFx0ZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nID0gMDtcblx0XHRkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblxuXHRcdGRvY3VtZW50LmJvZHkub25yZXNpemUgPSB0aGlzLm9uV2luZG93UmVzaXplLmJpbmQodGhpcyk7XG5cdFx0d2luZG93Lm9ucmVzaXplID0gdGhpcy5vbldpbmRvd1Jlc2l6ZS5iaW5kKHRoaXMpO1xuXHR9XG5cblx0dGhpcy5yZW5kZXJlciA9IG5ldyBQSVhJLmF1dG9EZXRlY3RSZW5kZXJlcih0aGlzLmdldEVsZW1lbnRXaWR0aCgpLCB0aGlzLmdldEVsZW1lbnRIZWlnaHQoKSwgdmlldyk7XG5cdHRoaXMuY29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnJlbmRlcmVyLnZpZXcpO1xuXG5cdHRoaXMuc3RhZ2UgPSBuZXcgUElYSS5TdGFnZSh0aGlzLl9iYWNrZ3JvdW5kQ29sb3IpO1xuXG5cdHRoaXMudXBkYXRlQ29udGVudFNjYWxlcigpO1xuXHR0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMuY29udGVudFNjYWxlcik7XG5cblx0dGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zdGFnZSk7XG5cdHRoaXMuc2l6ZURpcnR5ID0gZmFsc2U7XG5cblx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLm9uQW5pbWF0aW9uRnJhbWUuYmluZCh0aGlzKSk7XG5cdHRoaXMudHJpZ2dlcihcInJlc2l6ZVwiKTtcblxuXHQvL2NvbnNvbGUubG9nKFwiYXR0YWNoZWQuLi5cIik7XG59XG5cbi8qKlxuICogVXBkYXRlIHRoZSBjb250ZW50IHNjYWxlci5cbiAqIEBtZXRob2QgdXBkYXRlQ29udGVudFNjYWxlclxuICogQHByaXZhdGVcbiAqL1xuUGl4aUFwcC5wcm90b3R5cGUudXBkYXRlQ29udGVudFNjYWxlciA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLmNvbnRlbnRTY2FsZXIuc2V0Q29udGVudFNpemUodGhpcy5fYXBwbGljYXRpb25XaWR0aCwgdGhpcy5fYXBwbGljYXRpb25IZWlnaHQpO1xuXHR0aGlzLmNvbnRlbnRTY2FsZXIuc2V0U2NyZWVuU2l6ZSh0aGlzLmdldEVsZW1lbnRXaWR0aCgpLCB0aGlzLmdldEVsZW1lbnRIZWlnaHQoKSk7XG59XG5cbi8qKlxuICogQW5pbWF0aW9uIGZyYW1lLiBSZW5kZXIgb3Vyc2VsZnMuXG4gKiBAbWV0aG9kIG9uQW5pbWF0aW9uRnJhbWVcbiAqIEBwcml2YXRlXG4gKi9cblBpeGlBcHAucHJvdG90eXBlLm9uQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbih0aW1lKSB7XG5cdC8vY29uc29sZS5sb2coXCJyZW5kZXJcIik7XG5cblx0aWYgKHRoaXMuc2l6ZURpcnR5KSB7XG5cdFx0dGhpcy51cGRhdGVDb250ZW50U2NhbGVyKCk7XG5cdFx0dGhpcy5yZW5kZXJlci5yZXNpemUodGhpcy5nZXRFbGVtZW50V2lkdGgoKSwgdGhpcy5nZXRFbGVtZW50SGVpZ2h0KCkpO1xuXHRcdHRoaXMuc2l6ZURpcnR5ID0gZmFsc2U7XG5cdH1cblxuXHR0aGlzLnRyaWdnZXIoXCJmcmFtZVwiLCB0aW1lKTtcblxuXHR0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnN0YWdlKTtcblx0Ly9UV0VFTi51cGRhdGUodGltZSk7XG5cblx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLm9uQW5pbWF0aW9uRnJhbWUuYmluZCh0aGlzKSk7XG59XG5cbi8qKlxuICogSGFuZGxlIHdpbmRvdyByZXNpemUuXG4gKiBAbWV0aG9kIG9uV2luZG93UmVzaXplXG4gKiBAcHJpdmF0ZVxuICovXG5QaXhpQXBwLnByb3RvdHlwZS5vbldpbmRvd1Jlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnNpemVEaXJ0eSA9IHRydWU7XG5cdHRoaXMudHJpZ2dlcihcInJlc2l6ZVwiKTtcbn1cblxuLyoqXG4gKiBHZXQgaGVpZ2h0IG9mIHRoZSBlbGVtZW50IHRoYXQgd2UgYXJlIGF0dGFjaGVkIHRvLlxuICogQG1ldGhvZCBnZXRFbGVtZW50SGVpZ2h0XG4gKiBAcHJpdmF0ZVxuICovXG5QaXhpQXBwLnByb3RvdHlwZS5nZXRFbGVtZW50SGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLmNvbnRhaW5lckVsZW1lbnQgPT0gZG9jdW1lbnQuYm9keSlcblx0XHRyZXR1cm4gd2luZG93LmlubmVySGVpZ2h0O1xuXG5cdHJldHVybiB0aGlzLmNvbnRhaW5lckVsZW1lbnQuY2xpZW50SGVpZ2h0O1xufVxuXG4vKipcbiAqIEdldCBoZWlnaHQgb2YgdGhlIGVsZW1lbnQgdGhhdCB3ZSBhcmUgYXR0YWNoZWQgdG8uXG4gKiBAbWV0aG9kIGdldEVsZW1lbnRXaWR0aFxuICogQHByaXZhdGVcbiAqL1xuUGl4aUFwcC5wcm90b3R5cGUuZ2V0RWxlbWVudFdpZHRoID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLmNvbnRhaW5lckVsZW1lbnQgPT0gZG9jdW1lbnQuYm9keSlcblx0XHRyZXR1cm4gd2luZG93LmlubmVyV2lkdGg7XG5cblx0cmV0dXJuIHRoaXMuY29udGFpbmVyRWxlbWVudC5jbGllbnRXaWR0aDtcbn1cblxuLyoqXG4gKiBUaGUgbG9naWMgd2lkdGggb2YgdGhlIGFwcGxpY2F0aW9uLlxuICogQHByb3BlcnR5IGFwcGxpY2F0aW9uV2lkdGhcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBpeGlBcHAucHJvdG90eXBlLCAnYXBwbGljYXRpb25XaWR0aCcsIHtcblx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYXBwbGljYXRpb25XaWR0aDtcblx0fSxcblx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHRoaXMuX2FwcGxpY2F0aW9uV2lkdGggPSB2YWx1ZTtcblx0XHR0aGlzLnNpemVEaXJ0eSA9IHRydWU7XG5cdH1cbn0pO1xuXG4vKipcbiAqIFRoZSBsb2dpYyBoZWlnaHQgb2YgdGhlIGFwcGxpY2F0aW9uLlxuICogQHByb3BlcnR5IGFwcGxpY2F0aW9uSGVpZ2h0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaXhpQXBwLnByb3RvdHlwZSwgJ2FwcGxpY2F0aW9uSGVpZ2h0Jywge1xuXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hcHBsaWNhdGlvbkhlaWdodDtcblx0fSxcblx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHRoaXMuX2FwcGxpY2F0aW9uSGVpZ2h0ID0gdmFsdWU7XG5cdFx0dGhpcy5zaXplRGlydHkgPSB0cnVlO1xuXHR9XG59KTtcblxuLyoqXG4gKiBIb3cgdGhlIGFwcGxpY2F0aW9uIHNob3VsZCBiZSB2ZXJ0aWNhbGx5IGFsaWduZWQgaW4gdGhlIHdpbmRvdy5cbiAqIEBwcm9wZXJ0eSB2ZXJ0aWNhbEFsaWduXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaXhpQXBwLnByb3RvdHlwZSwgXCJ2ZXJ0aWNhbEFsaWduXCIsIHtcblx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZW50U2NhbGVyLnZlcnRpY2FsQWxpZ247XG5cdH0sXG5cdHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzLmNvbnRlbnRTY2FsZXIuc2V0VmVydGljYWxBbGlnbih2YWx1ZSlcblx0fVxufSk7XG5cbi8qKlxuICogSG93IHRoZSBhcHBsaWNhdGlvbiBzaG91bGQgYmUgaG9yaXpvbnRhbGx5IGFsaWduZWQgaW4gdGhlIHdpbmRvdy5cbiAqIEBwcm9wZXJ0eSBob3Jpem9udGFsQWxpZ25cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBpeGlBcHAucHJvdG90eXBlLCBcImhvcml6b250YWxBbGlnblwiLCB7XG5cdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udGVudFNjYWxlci5ob3Jpem9udGFsQWxpZ247XG5cdH0sXG5cdHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzLmNvbnRlbnRTY2FsZXIuc2V0SG9yaXpvbnRhbEFsaWduKHZhbHVlKVxuXHR9XG59KTtcblxuLyoqXG4gKiBIb3cgc2hvdWxkIHRoZSBhcHBsaWNhdGlvbiBiZSBzY2FsZWQgdG8gZml0IHRoZSB3aW5kb3c/XG4gKiBBdmFpbGFibGUgdmF1ZXMgYXJlOlxuICogPHVsPlxuICogICA8bGk+XG4gKiAgICAgYFBpeGlBcHAuU0hPV19BTExgIC0gRW5zdXJlIHRoYXQgdGhlIHdob2xlIGFwcGxpY2F0aW9uIGFzIGRlZmluZWQgYnlcbiAqICAgICBgYXBwbGljYXRpb25XaWR0aGAgYW5kIGBhcHBsaWNhdGlvbkhlaWdodGAgaXMgdmlzaWJsZSBvbiB0aGUgc2NyZWVuLlxuICogICA8L2xpPlxuICogICA8bGk+XG4gKiAgICAgYFBpeGlBcHAuTk9fQk9SREVSYCAtIFNob3cgYXMgbXVjaCBhcyBwb3NzaWJsZSBvZiB0aGUgYXBwbGljYXRpb24sXG4gKiAgICAgYnV0IHNjYWxlIGl0IHNvIHRoYXQgdGhlcmUgd2lsbCBiZSBubyBib3JkZXIuXG4gKiAgIDwvbGk+XG4gKiAgIDxsaT5cbiAqICAgICBgUGl4aUFwcC5OT19TQ0FMRWAgLSBEb24ndCBzY2FsZSB0aGUgYXBwbGljYXRpb24gYXQgYWxsLlxuICogICA8L2xpPlxuICogPC91bD5cbiAqIEBwcm9wZXJ0eSBzY2FsZU1vZGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBpeGlBcHAucHJvdG90eXBlLCBcInNjYWxlTW9kZVwiLCB7XG5cdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udGVudFNjYWxlci5zY2FsZU1vZGU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzLmNvbnRlbnRTY2FsZXIuc2V0U2NhbGVNb2RlKHZhbHVlKVxuXHR9XG59KTtcblxuLyoqXG4gKiBHZXQgb3Igc2V0IHRoZSBtaW5pbXVtIGFsbG93ZWQgc2NhbGUgdmFsdWUuXG4gKiBAcHJvcGVydHkgbWluU2NhbGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBpeGlBcHAucHJvdG90eXBlLCBcIm1pblNjYWxlXCIsIHtcblx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZW50U2NhbGVyLm1pblNjYWxlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dGhpcy5jb250ZW50U2NhbGVyLnNldE1pblNjYWxlKHZhbHVlKVxuXHR9XG59KTtcblxuLyoqXG4gKiBHZXQgb3Igc2V0IHRoZSBtYXhpbXVtIGFsbG93ZWQgc2NhbGUgdmFsdWUuXG4gKiBAcHJvcGVydHkgbWluU2NhbGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBpeGlBcHAucHJvdG90eXBlLCBcIm1heFNjYWxlXCIsIHtcblx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZW50U2NhbGVyLm1heFNjYWxlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dGhpcy5jb250ZW50U2NhbGVyLnNldE1heFNjYWxlKHZhbHVlKVxuXHR9XG59KTtcblxuLyoqXG4gKiBTaG91bGQgdGhlcmUgYmUgYSBsZXR0ZXJib3ggbWF0dGUgYXJvdW5kIHRoZSBjb250ZW50PyBJLmUuXG4gKiBzaG91bGQgdGhlIGNvbnRlbnQgb3V0c2lkZSB0aGUgYXBwbGljYXRpb24gYXJlYSBiZSBtYXNrZWRcbiAqIGF3YXk/XG4gKiBAcHJvcGVydHkgbWF0dGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBpeGlBcHAucHJvdG90eXBlLCBcIm1hdHRlXCIsIHtcblx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZW50U2NhbGVyLm1hc2tDb250ZW50RW5hYmxlZFxuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dGhpcy5jb250ZW50U2NhbGVyLnNldE1hc2tDb250ZW50RW5hYmxlZCh2YWx1ZSk7XG5cdH1cbn0pO1xuXG4vKipcbiAqIFRoZSBjb2xvciBvZiB0aGUgbGV0dGVyYm94IG1hdHRlLiBUaGlzIGhhcyBlZmZlY3Qgb25seSBpZiB0aGUgXG4gKiBsZXR0ZXIgYm94IG1hdHRlIGlzIGVuYWJsZWQgdXNpbmcgdGhlIG1hdHRlIHByb3BlcnR5LlxuICogQHByb3BlcnR5IG1hdHRlQ29sb3JcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBpeGlBcHAucHJvdG90eXBlLCBcIm1hdHRlQ29sb3JcIiwge1xuXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRlbnRTY2FsZXIubWFza0NvbG9yO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dGhpcy5jb250ZW50U2NhbGVyLnNldE1hc2tDb2xvcih2YWx1ZSk7XG5cdH1cbn0pO1xuXG4vKipcbiAqIEdldHMgdGhlIHJlY3RhbmdsZSBvbiB0aGUgc2NyZWVuIHRoYXQgaXMgY3VycmVudGx5IHZpc2libGUuXG4gKiBUaGUgcmVjdGFuZ2xlIGlzIHJlcHJlc2VudGVkIGluIGFwcGxpY2F0aW9uIGNvb3JkaW5hdGVzLlxuICogQHByb3BlcnR5IHZpc2libGVSZWN0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaXhpQXBwLnByb3RvdHlwZSwgXCJ2aXNpYmxlUmVjdFwiLCB7XG5cdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuc2l6ZURpcnR5KSB7XG5cdFx0XHR0aGlzLnVwZGF0ZUNvbnRlbnRTY2FsZXIoKTtcblx0XHRcdHRoaXMucmVuZGVyZXIucmVzaXplKHRoaXMuZ2V0RWxlbWVudFdpZHRoKCksIHRoaXMuZ2V0RWxlbWVudEhlaWdodCgpKTtcblx0XHRcdHRoaXMuc2l6ZURpcnR5ID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuY29udGVudFNjYWxlci5nZXRWaXNpYmxlUmVjdCgpO1xuXHR9LFxufSk7XG5cbi8qKlxuICogVGhlIGJhY2tncm91bmQgY29sb3IgZm9yIHRoZSBhcHBsaWNhdGlvbi5cbiAqIERlZmF1bHQgaXMgMHhmZmZmZmYsIGkuZS4gd2hpdGUuXG4gKiBAcHJvcGVydHkgYmFja2dyb3VuZENvbG9yXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaXhpQXBwLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwge1xuXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kQ29sb3I7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzLl9iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZTtcblx0XHRpZiAodGhpcy5zdGFnZSlcblx0XHRcdHRoaXMuc3RhZ2Uuc2V0QmFja2dyb3VuZENvbG9yKHRoaXMuX2JhY2tncm91bmRDb2xvcik7XG5cdH1cbn0pO1xuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gUGl4aUFwcDtcbn0gZWxzZSB7XG5cdHdpbmRvdy5QaXhpQXBwID0gUGl4aUFwcDtcbn1cblxufSkuY2FsbCh0aGlzKTsiLCIvKipcbiAqIEEgc3Vic2V0IG9mIFByb21pc2VzL0ErLlxuICogQGNsYXNzIFRoZW5hYmxlXG4gKi9cbmZ1bmN0aW9uIFRoZW5hYmxlKCkge1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgVGhlbmFibGUpKVxuXHRcdHJldHVybiBuZXcgVGhlbmFibGUoKTtcblxuXHR0aGlzLmRlY2lkZWQgPSBmYWxzZTtcblx0dGhpcy5oYW5kbGVyc1VzZWQgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBUaGVuLlxuICogQG1ldGhvZCByZXNvbHZlXG4gKi9cblRoZW5hYmxlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24ocmVzb2x1dGlvbkhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpIHtcblx0aWYgKHRoaXMuaGFuZGxlcnNVc2VkKVxuXHRcdHRocm93IG5ldyBFcnJvcihcIkhhbmRsZXJzIGFscmVhZHkgcmVnaXN0ZXJlZCBvciBjYWxsZWQuXCIpO1xuXG5cdHRoaXMuaGFuZGxlcnNVc2VkID0gdHJ1ZTtcblx0dGhpcy5yZXNvbHV0aW9uSGFuZGxlciA9IHJlc29sdXRpb25IYW5kbGVyO1xuXHR0aGlzLnJlamVjdGlvbkhhbmRsZXIgPSByZWplY3Rpb25IYW5kbGVyO1xufVxuXG4vKipcbiAqIFJlc29sdmUuXG4gKiBAbWV0aG9kIHJlc29sdmVcbiAqL1xuVGhlbmFibGUucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZXN1bHQpIHtcblx0aWYgKHRoaXMuZGVjaWRlZClcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IGRlY2lkZWQuXCIpO1xuXG5cdHRoaXMuZGVjaWRlZCA9IHRydWU7XG5cdHByb2Nlc3MubmV4dFRpY2sodGhpcy5jYWxsSGFuZGxlci5iaW5kKHRoaXMsIHRydWUsIHJlc3VsdCkpO1xufVxuXG4vKipcbiAqIFJlamVjdC5cbiAqIEBtZXRob2QgcmVzb2x2ZVxuICovXG5UaGVuYWJsZS5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24ocmVhc29uKSB7XG5cdGlmICh0aGlzLmRlY2lkZWQpXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBkZWNpZGVkLlwiKTtcblxuXHR0aGlzLmRlY2lkZWQgPSB0cnVlO1xuXHRwcm9jZXNzLm5leHRUaWNrKHRoaXMuY2FsbEhhbmRsZXIuYmluZCh0aGlzLCBmYWxzZSwgcmVhc29uKSk7XG59XG5cbi8qKlxuICogQ2FsbCBoYW5kbGVyLlxuICogQG1ldGhvZCBjYWxsSGFuZGxlclxuICogQHByaXZhdGVcbiAqL1xuVGhlbmFibGUucHJvdG90eXBlLmNhbGxIYW5kbGVyID0gZnVuY3Rpb24ocmVzb2x2ZWQsIHBhcmFtZXRlcikge1xuXHR0aGlzLmhhbmRsZXJzVXNlZCA9IHRydWU7XG5cblx0dmFyIGhhbmRsZXI7XG5cblx0aWYgKHJlc29sdmVkKVxuXHRcdGhhbmRsZXIgPSB0aGlzLnJlc29sdXRpb25IYW5kbGVyO1xuXG5cdGVsc2Vcblx0XHRoYW5kbGVyID0gdGhpcy5yZWplY3Rpb25IYW5kbGVyO1xuXG5cdC8vY29uc29sZS5sb2coXCJpbiBjYWxsSGFuZGxlciwgaGFuZGxlcj1cIiArIGhhbmRsZXIpO1xuXG5cdGlmIChoYW5kbGVyKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGhhbmRsZXIocGFyYW1ldGVyKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKFwiVW5oYW5kbGVkOiBcIiArIGUpO1xuXHRcdFx0Y29uc29sZS5sb2coZS5zdGFjayk7XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFJldHVybiBhIHJlc29sdmVkIHRoZW5hYmxlLlxuICogQG1ldGhvZCByZXNvbHZlZFxuICovXG5UaGVuYWJsZS5yZXNvbHZlZCA9IGZ1bmN0aW9uKHBhcmFtZXRlcikge1xuXHR2YXIgdCA9IG5ldyBUaGVuYWJsZSgpO1xuXHR0LnJlc29sdmUocGFyYW1ldGVyKTtcblx0cmV0dXJuIHQ7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgcmVqZWN0ZWQgdGhlbmFibGUuXG4gKiBAbWV0aG9kIHJlamVjdGVkXG4gKi9cblRoZW5hYmxlLnJlamVjdGVkID0gZnVuY3Rpb24ocGFyYW1ldGVyKSB7XG5cdHZhciB0ID0gbmV3IFRoZW5hYmxlKCk7XG5cdHQucmVqZWN0KHBhcmFtZXRlcik7XG5cdHJldHVybiB0O1xufVxuXG4vKipcbiAqIFdhaXQgZm9yIGFsbCB0byByZXNvbHZlIG9yIGFueSB0byByZWplY3QuXG4gKiBAbWV0aG9kIGFsbFxuICovXG5UaGVuYWJsZS5hbGwgPSBmdW5jdGlvbiggLyogLi4uICovICkge1xuXHR2YXIgdGhlbmFibGUgPSBuZXcgVGhlbmFibGUoKTtcblx0dmFyIGk7XG5cdHZhciB0aGVuYWJsZXMgPSBbXTtcblx0dmFyIGRlY2lkZWQgPSBmYWxzZTtcblx0dmFyIHJlc29sdmVkQ291bnQgPSAwO1xuXG5cdGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG5cdFx0dGhlbmFibGVzID0gdGhlbmFibGVzLmNvbmNhdChhcmd1bWVudHNbaV0pO1xuXG5cdGZ1bmN0aW9uIG9uUmVzb2x2ZWQoKSB7XG5cdFx0cmVzb2x2ZWRDb3VudCsrO1xuXG5cdFx0aWYgKCFkZWNpZGVkICYmIHJlc29sdmVkQ291bnQgPj0gdGhlbmFibGVzLmxlbmd0aCkge1xuXHRcdFx0ZGVjaWRlZCA9IHRydWU7XG5cdFx0XHR0aGVuYWJsZS5yZXNvbHZlKCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gb25SZWplY3RlZChlKSB7XG5cdFx0aWYgKCFkZWNpZGVkKSB7XG5cdFx0XHRkZWNpZGVkID0gdHJ1ZTtcblx0XHRcdHRoZW5hYmxlLnJlamVjdChlKTtcblx0XHR9XG5cdH1cblxuXHRmb3IgKGkgPSAwOyBpIDwgdGhlbmFibGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dGhlbmFibGVzW2ldLnRoZW4ob25SZXNvbHZlZCwgb25SZWplY3RlZCk7XG5cdH1cblxuXHRyZXR1cm4gdGhlbmFibGU7XG59XG5cbi8qKlxuICogV2FpdCBmb3IgYW55IHRvIHJlc29sdmUgb3IgYWxsIHRvIHJlamVjdC5cbiAqIEBtZXRob2QgYWxsXG4gKi9cblRoZW5hYmxlLnJhY2UgPSBmdW5jdGlvbiggLyogLi4uICovICkge1xuXHR2YXIgdGhlbmFibGUgPSBuZXcgVGhlbmFibGUoKTtcblx0dmFyIGk7XG5cdHZhciB0aGVuYWJsZXMgPSBbXTtcblx0dmFyIGRlY2lkZWQgPSBmYWxzZTtcblx0dmFyIHJlc29sdmVkQ291bnQgPSAwO1xuXG5cdGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG5cdFx0dGhlbmFibGVzID0gdGhlbmFibGVzLmNvbmNhdChhcmd1bWVudHNbaV0pO1xuXG5cdGZ1bmN0aW9uIG9uUmVqZWN0ZWQoKSB7XG5cdFx0cmVzb2x2ZWRDb3VudCsrO1xuXG5cdFx0aWYgKCFkZWNpZGVkICYmIHJlc29sdmVkQ291bnQgPj0gdGhlbmFibGVzLmxlbmd0aCkge1xuXHRcdFx0ZGVjaWRlZCA9IHRydWU7XG5cdFx0XHR0aGVuYWJsZS5yZWplY3QoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBvblJlc29sdmVkKHIpIHtcblx0XHRpZiAoIWRlY2lkZWQpIHtcblx0XHRcdGRlY2lkZWQgPSB0cnVlO1xuXHRcdFx0dGhlbmFibGUucmVzb2x2ZShyKTtcblx0XHR9XG5cdH1cblxuXHRmb3IgKGkgPSAwOyBpIDwgdGhlbmFibGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dGhlbmFibGVzW2ldLnRoZW4ob25SZXNvbHZlZCwgb25SZWplY3RlZCk7XG5cdH1cblxuXHRyZXR1cm4gdGhlbmFibGU7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVzb2x2ZWQgVGhlbmFibGUuXG4gKiBAbWV0aG9kIHJlc29sdmVkXG4gKi9cblRoZW5hYmxlLnJlc29sdmVkID0gZnVuY3Rpb24ocmVzdWx0KSB7XG5cdHZhciB0ID0gbmV3IFRoZW5hYmxlO1xuXHR0LnJlc29sdmUocmVzdWx0KTtcblxuXHRyZXR1cm4gdDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSByZWplY3RlZCBUaGVuYWJsZS5cbiAqIEBtZXRob2QgcmVqZWN0ZWRcbiAqL1xuVGhlbmFibGUucmVqZWN0ZWQgPSBmdW5jdGlvbihyZWFzb24pIHtcblx0dmFyIHQgPSBuZXcgVGhlbmFibGU7XG5cdHQucmVqZWN0KHJlYXNvbik7XG5cblx0cmV0dXJuIHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGhlbmFibGU7Il19
