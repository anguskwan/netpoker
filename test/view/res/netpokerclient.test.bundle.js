require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],3:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],4:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],5:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":3,"./encode":4}],6:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":2,"querystring":5}],7:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],8:[function(require,module,exports){
var PixiTextInput = require("./src/PixiTextInput");

module.exports = PixiTextInput;
},{"./src/PixiTextInput":9}],9:[function(require,module,exports){
if (typeof module !== 'undefined') {
	PIXI = require("pixi.js");
}

/**
 * Text input field for pixi.js.
 * A simple example:
 *
 *     // We need a container
 *     var container = new PIXI.DisplayObjectContainer();
 *
 *     // Same style options as PIXI.Text
 *     var style={ ... };
 *
 *     var inputField = new PixiTextInput("hello",style);
 *     container.addChild(inputField);
 *
 * The style definitions accepted by the constructor are the same as those accepted by
 * [PIXI.Text](http://www.goodboydigital.com/pixijs/docs/classes/Text.html).
 * @class PixiTextInput
 * @constructor
 * @param {String} [text] The initial text.
 * @param {Object} [style] Style definition, same as for PIXI.Text
 */
function PixiTextInput(text, style) {
	PIXI.DisplayObjectContainer.call(this);

	if (!text)
		text = "";

	text = text.toString();

	if (style && style.wordWrap)
		throw "wordWrap is not supported for input fields";

	this._text = text;

	this.localWidth = 100;
	this._backgroundColor = 0xffffff;
	this._caretColor = 0x000000;
	this._background = true;

	this.style = style;
	this.textField = new PIXI.Text(this._text, style);

	this.localHeight =
		this.textField.determineFontHeight('font: ' + this.textField.style.font + ';') +
		this.textField.style.strokeThickness;
	this.backgroundGraphics = new PIXI.Graphics();
	this.textFieldMask = new PIXI.Graphics();
	this.caret = new PIXI.Graphics();
	this.drawElements();

	this.addChild(this.backgroundGraphics);
	this.addChild(this.textField);
	this.addChild(this.caret);
	this.addChild(this.textFieldMask);

	this.scrollIndex = 0;
	this._caretIndex = 0;
	this.caretFlashInterval = null;
	this.blur();
	this.updateCaretPosition();

	this.backgroundGraphics.interactive = true;
	this.backgroundGraphics.buttonMode = true;
	this.backgroundGraphics.defaultCursor = "text";

	this.backgroundGraphics.mousedown = this.onBackgroundMouseDown.bind(this);
	this.keyEventClosure = this.onKeyEvent.bind(this);
	this.windowBlurClosure = this.onWindowBlur.bind(this);
	this.documentMouseDownClosure = this.onDocumentMouseDown.bind(this);
	this.isFocusClick = false;

	this.updateText();

	this.textField.mask = this.textFieldMask;

	this.keypress = null;
	this.keydown = null;
	this.change = null;
}

PixiTextInput.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
PixiTextInput.prototype.constructor = PixiTextInput;

/**
 * Someone clicked.
 * @method onBackgroundMouseDown
 * @private
 */
PixiTextInput.prototype.onBackgroundMouseDown = function(e) {
	var x = e.getLocalPosition(this).x;
	this._caretIndex = this.getCaretIndexByCoord(x);
	this.updateCaretPosition();

	this.focus();

	this.isFocusClick = true;
	var scope = this;
	setTimeout(function() {
		scope.isFocusClick = false;
	}, 0);
}

/**
 * Focus this input field.
 * @method focus
 */
PixiTextInput.prototype.focus = function() {
	this.blur();

	document.addEventListener("keydown", this.keyEventClosure);
	document.addEventListener("keypress", this.keyEventClosure);
	document.addEventListener("mousedown", this.documentMouseDownClosure);
	window.addEventListener("blur", this.windowBlurClosure);

	this.showCaret();
}

/**
 * Handle key event.
 * @method onKeyEvent
 * @private
 */
PixiTextInput.prototype.onKeyEvent = function(e) {
	/*console.log("key event");
	console.log(e);*/

	if (e.type == "keypress") {
		if (e.charCode < 32)
			return;

		this._text =
			this._text.substring(0, this._caretIndex) +
			String.fromCharCode(e.charCode) +
			this._text.substring(this._caretIndex);

		this._caretIndex++;
		this.ensureCaretInView();
		this.showCaret();
		this.updateText();
		this.trigger(this.keypress, e);
		this.trigger(this.change);
	}

	if (e.type == "keydown") {
		switch (e.keyCode) {
			case 8:
				if (this._caretIndex > 0) {
					this._text =
						this._text.substring(0, this._caretIndex - 1) +
						this._text.substring(this._caretIndex);

					this._caretIndex--;
					this.ensureCaretInView();
					this.showCaret();
					this.updateText();
				}
				e.preventDefault();
				this.trigger(this.change);
				break;

			case 46:
				this._text =
					this._text.substring(0, this._caretIndex) +
					this._text.substring(this._caretIndex + 1);

				this.ensureCaretInView();
				this.updateCaretPosition();
				this.showCaret();
				this.updateText();
				e.preventDefault();
				this.trigger(this.change);
				break;

			case 39:
				this._caretIndex++;
				if (this._caretIndex > this._text.length)
					this._caretIndex = this._text.length;

				this.ensureCaretInView();
				this.updateCaretPosition();
				this.showCaret();
				this.updateText();
				break;

			case 37:
				this._caretIndex--;
				if (this._caretIndex < 0)
					this._caretIndex = 0;

				this.ensureCaretInView();
				this.updateCaretPosition();
				this.showCaret();
				this.updateText();
				break;
		}

		this.trigger(this.keydown, e);
	}
}

/**
 * Ensure the caret is not outside the bounds.
 * @method ensureCaretInView
 * @private
 */
PixiTextInput.prototype.ensureCaretInView = function() {
	this.updateCaretPosition();

	while (this.caret.position.x >= this.localWidth - 1) {
		this.scrollIndex++;
		this.updateCaretPosition();
	}

	while (this.caret.position.x < 0) {
		this.scrollIndex -= 2;
		if (this.scrollIndex < 0)
			this.scrollIndex = 0;
		this.updateCaretPosition();
	}
}

/**
 * Blur ourself.
 * @method blur
 */
PixiTextInput.prototype.blur = function() {
	document.removeEventListener("keydown", this.keyEventClosure);
	document.removeEventListener("keypress", this.keyEventClosure);
	document.removeEventListener("mousedown", this.documentMouseDownClosure);
	window.removeEventListener("blur", this.windowBlurClosure);

	this.hideCaret();
}

/**
 * Window blur.
 * @method onDocumentMouseDown
 * @private
 */
PixiTextInput.prototype.onDocumentMouseDown = function() {
	if (!this.isFocusClick)
		this.blur();
}

/**
 * Window blur.
 * @method onWindowBlur
 * @private
 */
PixiTextInput.prototype.onWindowBlur = function() {
	this.blur();
}

/**
 * Update caret Position.
 * @method updateCaretPosition
 * @private
 */
PixiTextInput.prototype.updateCaretPosition = function() {
	if (this._caretIndex < this.scrollIndex) {
		this.caret.position.x = -1;
		return;
	}

	var sub = this._text.substring(0, this._caretIndex).substring(this.scrollIndex);
	this.caret.position.x = this.textField.context.measureText(sub).width;
}

/**
 * Update text.
 * @method updateText
 * @private
 */
PixiTextInput.prototype.updateText = function() {
	this.textField.setText(this._text.substring(this.scrollIndex));
}

/**
 * Draw the background and caret.
 * @method drawElements
 * @private
 */
PixiTextInput.prototype.drawElements = function() {
	this.backgroundGraphics.clear();
	this.backgroundGraphics.beginFill(this._backgroundColor);

	if (this._background)
		this.backgroundGraphics.drawRect(0, 0, this.localWidth, this.localHeight);

	this.backgroundGraphics.endFill();
	this.backgroundGraphics.hitArea = new PIXI.Rectangle(0, 0, this.localWidth, this.localHeight);

	this.textFieldMask.clear();
	this.textFieldMask.beginFill(this._backgroundColor);
	this.textFieldMask.drawRect(0, 0, this.localWidth, this.localHeight);
	this.textFieldMask.endFill();

	this.caret.clear();
	this.caret.beginFill(this._caretColor);
	this.caret.drawRect(1, 1, 1, this.localHeight - 2);
	this.caret.endFill();
}

/**
 * Show caret.
 * @method showCaret
 * @private
 */
PixiTextInput.prototype.showCaret = function() {
	if (this.caretFlashInterval) {
		clearInterval(this.caretFlashInterval);
		this.caretFlashInterval = null;
	}

	this.caret.visible = true;
	this.caretFlashInterval = setInterval(this.onCaretFlashInterval.bind(this), 500);
}

/**
 * Hide caret.
 * @method hideCaret
 * @private
 */
PixiTextInput.prototype.hideCaret = function() {
	if (this.caretFlashInterval) {
		clearInterval(this.caretFlashInterval);
		this.caretFlashInterval = null;
	}

	this.caret.visible = false;
}

/**
 * Caret flash interval.
 * @method onCaretFlashInterval
 * @private
 */
PixiTextInput.prototype.onCaretFlashInterval = function() {
	this.caret.visible = !this.caret.visible;
}

/**
 * Map position to caret index.
 * @method getCaretIndexByCoord
 * @private
 */
PixiTextInput.prototype.getCaretIndexByCoord = function(x) {
	var smallest = 10000;
	var cand = 0;
	var visible = this._text.substring(this.scrollIndex);

	for (i = 0; i < visible.length + 1; i++) {
		var sub = visible.substring(0, i);
		var w = this.textField.context.measureText(sub).width;

		if (Math.abs(w - x) < smallest) {
			smallest = Math.abs(w - x);
			cand = i;
		}
	}

	return this.scrollIndex + cand;
}

/**
 * The width of the PixiTextInput. This is overridden to have a slightly
 * different behaivour than the other DisplayObjects. Setting the
 * width of the PixiTextInput does not change the scale, but it rather
 * makes the field larger. If you actually want to scale it,
 * use the scale property.
 * @property width
 * @type Number
 */
Object.defineProperty(PixiTextInput.prototype, "width", {
	get: function() {
		return this.scale.x * this.getLocalBounds().width;
	},

	set: function(v) {
		this.localWidth = v;
		this.drawElements();
		this.ensureCaretInView();
		this.updateText();
	}
});

/**
 * The text in the input field. Setting will have the implicit function of resetting the scroll
 * of the input field and removing focus.
 * @property text
 * @type String
 */
Object.defineProperty(PixiTextInput.prototype, "text", {
	get: function() {
		return this._text;
	},

	set: function(v) {
		this._text = v.toString();
		this.scrollIndex = 0;
		this.caretIndex = 0;
		this.blur();
		this.updateText();
	}
});

/**
 * The color of the background for the input field.
 * This needs to be specified as an integer, not using HTML
 * notation, e.g. for red background:
 *
 *     myInputText.backgroundColor = 0xff0000;
 *
 * In order for the background to be drawn, the `background`
 * property needs to be true. If not, this property will have
 * no effect.
 * @property backgroundColor
 * @type Integer
 */
Object.defineProperty(PixiTextInput.prototype, "backgroundColor", {
	get: function() {
		return this._backgroundColor;
	},

	set: function(v) {
		this._backgroundColor = v;
		this.drawElements();
	}
});

/**
 * The color of the caret.
 * @property caretColor
 * @type Integer
 */
Object.defineProperty(PixiTextInput.prototype, "caretColor", {
	get: function() {
		return this._caretColor;
	},

	set: function(v) {
		this._caretColor = v;
		this.drawElements();
	}
});

/**
 * Determines if the background should be drawn behind the text.
 * The color of the background is specified using the backgroundColor
 * property.
 * @property background
 * @type Boolean
 */
Object.defineProperty(PixiTextInput.prototype, "background", {
	get: function() {
		return this._background;
	},

	set: function(v) {
		this._background = v;
		this.drawElements();
	}
});

/**
 * Set text.
 * @method setText
 * @param {String} text The new text.
 */
PixiTextInput.prototype.setText = function(v) {
	this.text = v;
}

/**
 * Trigger an event function if it exists.
 * @method trigger
 * @private
 */
PixiTextInput.prototype.trigger = function(fn, e) {
	if (fn)
		fn(e);
}

if (typeof module !== 'undefined') {
	module.exports = PixiTextInput;
}
},{"pixi.js":"pixi.js"}],10:[function(require,module,exports){
/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/sole/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/sole/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */

// Date.now shim for (ahem) Internet Explo(d|r)er
if ( Date.now === undefined ) {

	Date.now = function () {

		return new Date().valueOf();

	};

}

var TWEEN = TWEEN || ( function () {

	var _tweens = [];

	return {

		REVISION: '14',

		getAll: function () {

			return _tweens;

		},

		removeAll: function () {

			_tweens = [];

		},

		add: function ( tween ) {

			_tweens.push( tween );

		},

		remove: function ( tween ) {

			var i = _tweens.indexOf( tween );

			if ( i !== -1 ) {

				_tweens.splice( i, 1 );

			}

		},

		update: function ( time ) {

			if ( _tweens.length === 0 ) return false;

			var i = 0;

			time = time !== undefined ? time : ( typeof window !== 'undefined' && window.performance !== undefined && window.performance.now !== undefined ? window.performance.now() : Date.now() );

			while ( i < _tweens.length ) {

				if ( _tweens[ i ].update( time ) ) {

					i++;

				} else {

					_tweens.splice( i, 1 );

				}

			}

			return true;

		}
	};

} )();

TWEEN.Tween = function ( object ) {

	var _object = object;
	var _valuesStart = {};
	var _valuesEnd = {};
	var _valuesStartRepeat = {};
	var _duration = 1000;
	var _repeat = 0;
	var _yoyo = false;
	var _isPlaying = false;
	var _reversed = false;
	var _delayTime = 0;
	var _startTime = null;
	var _easingFunction = TWEEN.Easing.Linear.None;
	var _interpolationFunction = TWEEN.Interpolation.Linear;
	var _chainedTweens = [];
	var _onStartCallback = null;
	var _onStartCallbackFired = false;
	var _onUpdateCallback = null;
	var _onCompleteCallback = null;
	var _onStopCallback = null;

	// Set all starting values present on the target object
	for ( var field in object ) {

		_valuesStart[ field ] = parseFloat(object[field], 10);

	}

	this.to = function ( properties, duration ) {

		if ( duration !== undefined ) {

			_duration = duration;

		}

		_valuesEnd = properties;

		return this;

	};

	this.start = function ( time ) {

		TWEEN.add( this );

		_isPlaying = true;

		_onStartCallbackFired = false;

		_startTime = time !== undefined ? time : ( typeof window !== 'undefined' && window.performance !== undefined && window.performance.now !== undefined ? window.performance.now() : Date.now() );
		_startTime += _delayTime;

		for ( var property in _valuesEnd ) {

			// check if an Array was provided as property value
			if ( _valuesEnd[ property ] instanceof Array ) {

				if ( _valuesEnd[ property ].length === 0 ) {

					continue;

				}

				// create a local copy of the Array with the start value at the front
				_valuesEnd[ property ] = [ _object[ property ] ].concat( _valuesEnd[ property ] );

			}

			_valuesStart[ property ] = _object[ property ];

			if( ( _valuesStart[ property ] instanceof Array ) === false ) {
				_valuesStart[ property ] *= 1.0; // Ensures we're using numbers, not strings
			}

			_valuesStartRepeat[ property ] = _valuesStart[ property ] || 0;

		}

		return this;

	};

	this.stop = function () {

		if ( !_isPlaying ) {
			return this;
		}

		TWEEN.remove( this );
		_isPlaying = false;

		if ( _onStopCallback !== null ) {

			_onStopCallback.call( _object );

		}

		this.stopChainedTweens();
		return this;

	};

	this.stopChainedTweens = function () {

		for ( var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++ ) {

			_chainedTweens[ i ].stop();

		}

	};

	this.delay = function ( amount ) {

		_delayTime = amount;
		return this;

	};

	this.repeat = function ( times ) {

		_repeat = times;
		return this;

	};

	this.yoyo = function( yoyo ) {

		_yoyo = yoyo;
		return this;

	};


	this.easing = function ( easing ) {

		_easingFunction = easing;
		return this;

	};

	this.interpolation = function ( interpolation ) {

		_interpolationFunction = interpolation;
		return this;

	};

	this.chain = function () {

		_chainedTweens = arguments;
		return this;

	};

	this.onStart = function ( callback ) {

		_onStartCallback = callback;
		return this;

	};

	this.onUpdate = function ( callback ) {

		_onUpdateCallback = callback;
		return this;

	};

	this.onComplete = function ( callback ) {

		_onCompleteCallback = callback;
		return this;

	};

	this.onStop = function ( callback ) {

		_onStopCallback = callback;
		return this;

	};

	this.update = function ( time ) {

		var property;

		if ( time < _startTime ) {

			return true;

		}

		if ( _onStartCallbackFired === false ) {

			if ( _onStartCallback !== null ) {

				_onStartCallback.call( _object );

			}

			_onStartCallbackFired = true;

		}

		var elapsed = ( time - _startTime ) / _duration;
		elapsed = elapsed > 1 ? 1 : elapsed;

		var value = _easingFunction( elapsed );

		for ( property in _valuesEnd ) {

			var start = _valuesStart[ property ] || 0;
			var end = _valuesEnd[ property ];

			if ( end instanceof Array ) {

				_object[ property ] = _interpolationFunction( end, value );

			} else {

				// Parses relative end values with start as base (e.g.: +10, -3)
				if ( typeof(end) === "string" ) {
					end = start + parseFloat(end, 10);
				}

				// protect against non numeric properties.
				if ( typeof(end) === "number" ) {
					_object[ property ] = start + ( end - start ) * value;
				}

			}

		}

		if ( _onUpdateCallback !== null ) {

			_onUpdateCallback.call( _object, value );

		}

		if ( elapsed == 1 ) {

			if ( _repeat > 0 ) {

				if( isFinite( _repeat ) ) {
					_repeat--;
				}

				// reassign starting values, restart by making startTime = now
				for( property in _valuesStartRepeat ) {

					if ( typeof( _valuesEnd[ property ] ) === "string" ) {
						_valuesStartRepeat[ property ] = _valuesStartRepeat[ property ] + parseFloat(_valuesEnd[ property ], 10);
					}

					if (_yoyo) {
						var tmp = _valuesStartRepeat[ property ];
						_valuesStartRepeat[ property ] = _valuesEnd[ property ];
						_valuesEnd[ property ] = tmp;
					}

					_valuesStart[ property ] = _valuesStartRepeat[ property ];

				}

				if (_yoyo) {
					_reversed = !_reversed;
				}

				_startTime = time + _delayTime;

				return true;

			} else {

				if ( _onCompleteCallback !== null ) {

					_onCompleteCallback.call( _object );

				}

				for ( var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++ ) {

					_chainedTweens[ i ].start( time );

				}

				return false;

			}

		}

		return true;

	};

};


TWEEN.Easing = {

	Linear: {

		None: function ( k ) {

			return k;

		}

	},

	Quadratic: {

		In: function ( k ) {

			return k * k;

		},

		Out: function ( k ) {

			return k * ( 2 - k );

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1 ) return 0.5 * k * k;
			return - 0.5 * ( --k * ( k - 2 ) - 1 );

		}

	},

	Cubic: {

		In: function ( k ) {

			return k * k * k;

		},

		Out: function ( k ) {

			return --k * k * k + 1;

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k;
			return 0.5 * ( ( k -= 2 ) * k * k + 2 );

		}

	},

	Quartic: {

		In: function ( k ) {

			return k * k * k * k;

		},

		Out: function ( k ) {

			return 1 - ( --k * k * k * k );

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1) return 0.5 * k * k * k * k;
			return - 0.5 * ( ( k -= 2 ) * k * k * k - 2 );

		}

	},

	Quintic: {

		In: function ( k ) {

			return k * k * k * k * k;

		},

		Out: function ( k ) {

			return --k * k * k * k * k + 1;

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k * k * k;
			return 0.5 * ( ( k -= 2 ) * k * k * k * k + 2 );

		}

	},

	Sinusoidal: {

		In: function ( k ) {

			return 1 - Math.cos( k * Math.PI / 2 );

		},

		Out: function ( k ) {

			return Math.sin( k * Math.PI / 2 );

		},

		InOut: function ( k ) {

			return 0.5 * ( 1 - Math.cos( Math.PI * k ) );

		}

	},

	Exponential: {

		In: function ( k ) {

			return k === 0 ? 0 : Math.pow( 1024, k - 1 );

		},

		Out: function ( k ) {

			return k === 1 ? 1 : 1 - Math.pow( 2, - 10 * k );

		},

		InOut: function ( k ) {

			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( ( k *= 2 ) < 1 ) return 0.5 * Math.pow( 1024, k - 1 );
			return 0.5 * ( - Math.pow( 2, - 10 * ( k - 1 ) ) + 2 );

		}

	},

	Circular: {

		In: function ( k ) {

			return 1 - Math.sqrt( 1 - k * k );

		},

		Out: function ( k ) {

			return Math.sqrt( 1 - ( --k * k ) );

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1) return - 0.5 * ( Math.sqrt( 1 - k * k) - 1);
			return 0.5 * ( Math.sqrt( 1 - ( k -= 2) * k) + 1);

		}

	},

	Elastic: {

		In: function ( k ) {

			var s, a = 0.1, p = 0.4;
			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( !a || a < 1 ) { a = 1; s = p / 4; }
			else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
			return - ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );

		},

		Out: function ( k ) {

			var s, a = 0.1, p = 0.4;
			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( !a || a < 1 ) { a = 1; s = p / 4; }
			else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
			return ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 );

		},

		InOut: function ( k ) {

			var s, a = 0.1, p = 0.4;
			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( !a || a < 1 ) { a = 1; s = p / 4; }
			else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
			if ( ( k *= 2 ) < 1 ) return - 0.5 * ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );
			return a * Math.pow( 2, -10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) * 0.5 + 1;

		}

	},

	Back: {

		In: function ( k ) {

			var s = 1.70158;
			return k * k * ( ( s + 1 ) * k - s );

		},

		Out: function ( k ) {

			var s = 1.70158;
			return --k * k * ( ( s + 1 ) * k + s ) + 1;

		},

		InOut: function ( k ) {

			var s = 1.70158 * 1.525;
			if ( ( k *= 2 ) < 1 ) return 0.5 * ( k * k * ( ( s + 1 ) * k - s ) );
			return 0.5 * ( ( k -= 2 ) * k * ( ( s + 1 ) * k + s ) + 2 );

		}

	},

	Bounce: {

		In: function ( k ) {

			return 1 - TWEEN.Easing.Bounce.Out( 1 - k );

		},

		Out: function ( k ) {

			if ( k < ( 1 / 2.75 ) ) {

				return 7.5625 * k * k;

			} else if ( k < ( 2 / 2.75 ) ) {

				return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;

			} else if ( k < ( 2.5 / 2.75 ) ) {

				return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;

			} else {

				return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;

			}

		},

		InOut: function ( k ) {

			if ( k < 0.5 ) return TWEEN.Easing.Bounce.In( k * 2 ) * 0.5;
			return TWEEN.Easing.Bounce.Out( k * 2 - 1 ) * 0.5 + 0.5;

		}

	}

};

TWEEN.Interpolation = {

	Linear: function ( v, k ) {

		var m = v.length - 1, f = m * k, i = Math.floor( f ), fn = TWEEN.Interpolation.Utils.Linear;

		if ( k < 0 ) return fn( v[ 0 ], v[ 1 ], f );
		if ( k > 1 ) return fn( v[ m ], v[ m - 1 ], m - f );

		return fn( v[ i ], v[ i + 1 > m ? m : i + 1 ], f - i );

	},

	Bezier: function ( v, k ) {

		var b = 0, n = v.length - 1, pw = Math.pow, bn = TWEEN.Interpolation.Utils.Bernstein, i;

		for ( i = 0; i <= n; i++ ) {
			b += pw( 1 - k, n - i ) * pw( k, i ) * v[ i ] * bn( n, i );
		}

		return b;

	},

	CatmullRom: function ( v, k ) {

		var m = v.length - 1, f = m * k, i = Math.floor( f ), fn = TWEEN.Interpolation.Utils.CatmullRom;

		if ( v[ 0 ] === v[ m ] ) {

			if ( k < 0 ) i = Math.floor( f = m * ( 1 + k ) );

			return fn( v[ ( i - 1 + m ) % m ], v[ i ], v[ ( i + 1 ) % m ], v[ ( i + 2 ) % m ], f - i );

		} else {

			if ( k < 0 ) return v[ 0 ] - ( fn( v[ 0 ], v[ 0 ], v[ 1 ], v[ 1 ], -f ) - v[ 0 ] );
			if ( k > 1 ) return v[ m ] - ( fn( v[ m ], v[ m ], v[ m - 1 ], v[ m - 1 ], f - m ) - v[ m ] );

			return fn( v[ i ? i - 1 : 0 ], v[ i ], v[ m < i + 1 ? m : i + 1 ], v[ m < i + 2 ? m : i + 2 ], f - i );

		}

	},

	Utils: {

		Linear: function ( p0, p1, t ) {

			return ( p1 - p0 ) * t + p0;

		},

		Bernstein: function ( n , i ) {

			var fc = TWEEN.Interpolation.Utils.Factorial;
			return fc( n ) / fc( i ) / fc( n - i );

		},

		Factorial: ( function () {

			var a = [ 1 ];

			return function ( n ) {

				var s = 1, i;
				if ( a[ n ] ) return a[ n ];
				for ( i = n; i > 1; i-- ) s *= i;
				return a[ n ] = s;

			};

		} )(),

		CatmullRom: function ( p0, p1, p2, p3, t ) {

			var v0 = ( p2 - p0 ) * 0.5, v1 = ( p3 - p1 ) * 0.5, t2 = t * t, t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

		}

	}

};

module.exports=TWEEN;
},{}],11:[function(require,module,exports){
/**
 * AS3/jquery style event dispatcher. Slightly modified. The
 * jquery style on/off/trigger style of adding listeners is
 * currently the preferred one.
 *
 * The on method for adding listeners takes an extra parameter which is the
 * scope in which listeners should be called. So this:
 *
 *     object.on("event", listener, this);
 *
 * Has the same function when adding events as:
 *
 *     object.on("event", listener.bind(this));
 *
 * However, the difference is that if we use the second method it
 * will not be possible to remove the listeners later, unless
 * the closure created by bind is stored somewhere. If the
 * first method is used, we can remove the listener with:
 *
 *     object.off("event", listener, this);
 *
 * @class EventDispatcher
 */
function EventDispatcher() {
	this.listenerMap = {};
}

/**
 * Add event listener.
 * @method addEventListener
 */
EventDispatcher.prototype.addEventListener = function(eventType, listener, scope) {
	if (!this.listenerMap)
		this.listenerMap = {};

	if (!eventType)
		throw new Error("Event type required for event dispatcher");

	if (!listener)
		throw new Error("Listener required for event dispatcher");

	this.removeEventListener(eventType, listener, scope);

	if (!this.listenerMap.hasOwnProperty(eventType))
		this.listenerMap[eventType] = [];

	this.listenerMap[eventType].push({
		listener: listener,
		scope: scope
	});
}

/**
 * Remove event listener.
 * @method removeEventListener
 */
EventDispatcher.prototype.removeEventListener = function(eventType, listener, scope) {
	if (!this.listenerMap)
		this.listenerMap = {};

	if (!this.listenerMap.hasOwnProperty(eventType))
		return;

	var listeners = this.listenerMap[eventType];

	for (var i = 0; i < listeners.length; i++) {
		var listenerObj = listeners[i];

		if (listener == listenerObj.listener && scope == listenerObj.scope) {
			listeners.splice(i, 1);
			i--;
		}
	}

	if (!listeners.length)
		delete this.listenerMap[eventType];
}

/**
 * Dispatch event.
 * @method dispatchEvent
 */
EventDispatcher.prototype.dispatchEvent = function(event /* ... */ ) {
	if (!this.listenerMap)
		this.listenerMap = {};

	var eventType;
	var listenerParams;

	if (typeof event == "string") {
		eventType = event;

		if (arguments.length > 1)
			listenerParams = Array.prototype.slice.call(arguments, 1);

		else listenerParams = [{
			type: eventType,
			target: this
		}];
	} else {
		eventType = event.type;
		event.target = this;
		listenerParams = [event];
	}

	if (!this.listenerMap.hasOwnProperty(eventType))
		return;

	var map = [];
	for (var i = 0; i < this.listenerMap[eventType].length; i++)
		map.push(this.listenerMap[eventType][i])

	for (var i = 0; i < map.length; i++) {
		var listenerObj = map[i];
		listenerObj.listener.apply(listenerObj.scope, listenerParams);
	}
}

/**
 * Jquery style alias for addEventListener
 * @method on
 */
EventDispatcher.prototype.on = EventDispatcher.prototype.addEventListener;

/**
 * Jquery style alias for removeEventListener
 * @method off
 */
EventDispatcher.prototype.off = EventDispatcher.prototype.removeEventListener;

/**
 * Jquery style alias for dispatchEvent
 * @method trigger
 */
EventDispatcher.prototype.trigger = EventDispatcher.prototype.dispatchEvent;

/**
 * Make something an event dispatcher. Can be used for multiple inheritance.
 * @method init
 * @static
 */
EventDispatcher.init = function(cls) {
	cls.prototype.addEventListener = EventDispatcher.prototype.addEventListener;
	cls.prototype.removeEventListener = EventDispatcher.prototype.removeEventListener;
	cls.prototype.dispatchEvent = EventDispatcher.prototype.dispatchEvent;
	cls.prototype.on = EventDispatcher.prototype.on;
	cls.prototype.off = EventDispatcher.prototype.off;
	cls.prototype.trigger = EventDispatcher.prototype.trigger;
}

if (typeof module !== 'undefined') {
	module.exports = EventDispatcher;
}
},{}],12:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var ShowDialogMessage = require("../../proto/messages/ShowDialogMessage");
var ButtonsMessage = require("../../proto/messages/ButtonsMessage");
var ChatMessage = require("../../proto/messages/ChatMessage");
var TableInfoMessage = require("../../proto/messages/TableInfoMessage");
var HandInfoMessage = require("../../proto/messages/HandInfoMessage");
var PresetButtonsMessage = require("../../proto/messages/PresetButtonsMessage");
var InterfaceStateMessage = require("../../proto/messages/InterfaceStateMessage");
var CheckboxMessage = require("../../proto/messages/CheckboxMessage");
var PreTournamentInfoMessage = require("../../proto/messages/PreTournamentInfoMessage");

/**
 * Control user interface.
 * @class InterfaceController
 */
function InterfaceController(messageSequencer, view) {
	this.messageSequencer = messageSequencer;
	this.view = view;

	this.messageSequencer.addMessageHandler(ButtonsMessage.TYPE, this.onButtonsMessage, this);
	this.messageSequencer.addMessageHandler(ShowDialogMessage.TYPE, this.onShowDialogMessage, this);
	this.messageSequencer.addMessageHandler(ChatMessage.TYPE, this.onChat, this);
	this.messageSequencer.addMessageHandler(TableInfoMessage.TYPE, this.onTableInfoMessage, this);
	this.messageSequencer.addMessageHandler(HandInfoMessage.TYPE, this.onHandInfoMessage, this);
	this.messageSequencer.addMessageHandler(InterfaceStateMessage.TYPE, this.onInterfaceStateMessage, this);
	this.messageSequencer.addMessageHandler(CheckboxMessage.TYPE, this.onCheckboxMessage, this);
	this.messageSequencer.addMessageHandler(PreTournamentInfoMessage.TYPE, this.onPreTournamentInfoMessage, this);

	this.messageSequencer.addMessageHandler(PresetButtonsMessage.TYPE, this.onPresetButtons, this);
}

/**
 * Buttons message.
 * @method onButtonsMessage
 */
InterfaceController.prototype.onButtonsMessage = function(m) {
	var buttonsView = this.view.getButtonsView();

	buttonsView.setButtons(m.getButtons(), m.sliderButtonIndex, parseInt(m.min, 10), parseInt(m.max, 10));
}

/**
 * PresetButtons message.
 * @method onPresetButtons
 */
InterfaceController.prototype.onPresetButtons = function(m) {
	var presetButtonsView = this.view.getPresetButtonsView();

	var buttons = presetButtonsView.getButtons();
	for (var i = 0; i < buttons.length; i++) {
		if (i > m.buttons.length) {
			buttons[i].hide();
		} else {
			var data = m.buttons[i];

			if (data == null) {
				buttons[i].hide();
			} else {
				buttons[i].show(data.button, data.value);
			}
		}
	}

	presetButtonsView.setCurrent(m.current);
}

/**
 * Show dialog.
 * @method onShowDialogMessage
 */
InterfaceController.prototype.onShowDialogMessage = function(m) {
	var dialogView = this.view.getDialogView();

	dialogView.show(m.getText(), m.getButtons(), m.getDefaultValue());
}


/**
 * On chat message.
 * @method onChat
 */
InterfaceController.prototype.onChat = function(m) {
	this.view.chatView.addText(m.user, m.text);
}

/**
 * Handle table info message.
 * @method onTableInfoMessage
 */
InterfaceController.prototype.onTableInfoMessage = function(m) {
	var tableInfoView = this.view.getTableInfoView();

	tableInfoView.setTableInfoText(m.getText());
	tableInfoView.setJoinButtonVisible(m.getShowJoinButton());
	tableInfoView.setLeaveButtonVisible(m.getShowLeaveButton());
}

/**
 * Handle hand info message.
 * @method onHandInfoMessage
 */
InterfaceController.prototype.onHandInfoMessage = function(m) {
	var tableInfoView = this.view.getTableInfoView();

	tableInfoView.setHandInfoText(m.getText());
}

/**
 * Handle interface state message.
 * @method onInterfaceStateMessage
 */
InterfaceController.prototype.onInterfaceStateMessage = function(m) {
	var settingsView = this.view.getSettingsView();

	settingsView.setVisibleButtons(m.getVisibleButtons());
}

/**
 * Handle checkbox message.
 * @method onCheckboxMessage
 */
InterfaceController.prototype.onCheckboxMessage = function(m) {
	console.log(m);

	var settingsView = this.view.getSettingsView();

	settingsView.setCheckboxChecked(m.getId(), m.getChecked());
}

/**
 * Handle pre torunament info message.
 * @method onPreTournamentInfoMessage
 */
InterfaceController.prototype.onPreTournamentInfoMessage = function(m) {
	var tableInfoView = this.view.getTableInfoView();

	tableInfoView.setPreTournamentInfoText(m.getText());
}

module.exports = InterfaceController;
},{"../../proto/messages/ButtonsMessage":46,"../../proto/messages/ChatMessage":47,"../../proto/messages/CheckboxMessage":48,"../../proto/messages/HandInfoMessage":55,"../../proto/messages/InterfaceStateMessage":57,"../../proto/messages/PreTournamentInfoMessage":61,"../../proto/messages/PresetButtonsMessage":63,"../../proto/messages/ShowDialogMessage":66,"../../proto/messages/TableInfoMessage":70}],13:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var EventDispatcher = require("yaed");
var Sequencer = require("../../utils/Sequencer");
var inherits=require("inherits");

/**
 * An item in a message sequence.
 * @class MessageSequenceItem
 */
function MessageSequenceItem(message) {
	EventDispatcher.call(this);
	this.message = message;
	this.waitTarget = null;
	this.waitEvent = null;
	this.waitClosure = null;
}

inherits(MessageSequenceItem, EventDispatcher);

/**
 * Get message.
 * @method getMessage
 */
MessageSequenceItem.prototype.getMessage = function() {
	//console.log("getting: " + this.message.type);

	return this.message;
}

/**
 * Are we waiting for an event?
 * @method isWaiting
 */
MessageSequenceItem.prototype.isWaiting = function() {
	return this.waitEvent != null;
}

/**
 * Notify complete.
 * @method notifyComplete
 */
MessageSequenceItem.prototype.notifyComplete = function() {
	this.trigger(Sequencer.COMPLETE);
}

/**
 * Wait for event before processing next message.
 * @method waitFor
 */
MessageSequenceItem.prototype.waitFor = function(target, event) {
	this.waitTarget = target;
	this.waitEvent = event;
	this.waitClosure = this.onTargetComplete.bind(this);

	this.waitTarget.addEventListener(this.waitEvent, this.waitClosure);
}

/**
 * Wait target complete.
 * @method onTargetComplete
 * @private
 */
MessageSequenceItem.prototype.onTargetComplete = function() {
	//console.log("target is complete");
	this.waitTarget.removeEventListener(this.waitEvent, this.waitClosure);
	this.notifyComplete();
}

module.exports = MessageSequenceItem;
},{"../../utils/Sequencer":79,"inherits":7,"yaed":11}],14:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var Sequencer = require("../../utils/Sequencer");
var EventDispatcher = require("yaed");
var MessageSequenceItem = require("./MessageSequenceItem");

/**
 * Sequences messages.
 * @class MessageSequencer
 */
function MessageSequencer() {
	this.sequencer = new Sequencer();
	this.messageDispatcher = new EventDispatcher();
	this.currentItem = null;
}

/**
 * Add a message for procesing.
 * @method enqueue
 */
MessageSequencer.prototype.enqueue = function(message) {
	if (!message.type)
		throw "Message doesn't have a type";

	var sequenceItem = new MessageSequenceItem(message);

	sequenceItem.on(Sequencer.START, this.onSequenceItemStart, this);

	this.sequencer.enqueue(sequenceItem);
}

/**
 * Sequence item start.
 * @method onSequenceItemStart
 * @private
 */
MessageSequencer.prototype.onSequenceItemStart = function(e) {
	//console.log("starting item...");
	var item = e.target;

	item.off(Sequencer.START, this.onSequenceItemStart, this);

	this.currentItem = item;
	this.messageDispatcher.trigger(item.getMessage());
	this.currentItem = null;

	if (!item.isWaiting())
		item.notifyComplete();
}

/**
 * Add message handler.
 * @method addMessageHandler
 */
MessageSequencer.prototype.addMessageHandler = function(messageType, handler, scope) {
	this.messageDispatcher.on(messageType, handler, scope);
}

/**
 * Wait for the target to dispatch an event before continuing to
 * process the messages in the que.
 * @method waitFor
 */
MessageSequencer.prototype.waitFor = function(target, event) {
	if (!this.currentItem)
		throw "Not waiting for event";

	this.currentItem.waitFor(target, event);
}

module.exports = MessageSequencer;
},{"../../utils/Sequencer":79,"./MessageSequenceItem":13,"yaed":11}],15:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var MessageSequencer = require("./MessageSequencer");
var ProtoConnection = require("../../proto/ProtoConnection");
var ButtonsView = require("../view/ButtonsView");
var ButtonClickMessage = require("../../proto/messages/ButtonClickMessage");
var SeatClickMessage = require("../../proto/messages/SeatClickMessage");
var PresetButtonClickMessage = require("../../proto/messages/PresetButtonClickMessage");
var NetPokerClientView = require("../view/NetPokerClientView");
var DialogView = require("../view/DialogView");
var TableInfoView = require("../view/TableInfoView");
var SettingsView = require("../view/SettingsView");
var TableController = require("./TableController");
var InterfaceController = require("./InterfaceController");
var ChatMessage = require("../../proto/messages/ChatMessage");
var CheckboxMessage = require("../../proto/messages/CheckboxMessage");
var ButtonData = require("../../proto/data/ButtonData");
var PresetButtonsView = require("../view/PresetButtonsView");

/**
 * Main controller
 * @class NetPokerClientController
 */
function NetPokerClientController(view) {
	this.netPokerClientView = view;
	this.protoConnection = null;
	this.messageSequencer = new MessageSequencer();

	this.tableController = new TableController(this.messageSequencer, this.netPokerClientView);
	this.interfaceController = new InterfaceController(this.messageSequencer, this.netPokerClientView);

	//console.log(this.netPokerClientView.getDialogView());

	this.netPokerClientView.getButtonsView().on(ButtonsView.BUTTON_CLICK, this.onButtonClick, this);
	this.netPokerClientView.getTableInfoView().on(TableInfoView.BUTTON_CLICK, this.onButtonClick, this);
	this.netPokerClientView.getDialogView().on(DialogView.BUTTON_CLICK, this.onButtonClick, this);
	this.netPokerClientView.on(NetPokerClientView.SEAT_CLICK, this.onSeatClick, this);

	this.netPokerClientView.chatView.addEventListener("chat", this.onViewChat, this);
	this.netPokerClientView.settingsView.addEventListener(SettingsView.BUY_CHIPS_CLICK, this.onBuyChipsButtonClick, this);
	this.netPokerClientView.settingsView.addEventListener(SettingsView.CHECKBOX_CHANGE, this.onCheckboxChange, this);

	this.netPokerClientView.getPresetButtonsView().addEventListener(PresetButtonsView.CHANGE, this.onPresetButtonsChange, this);
}


/**
 * Set connection.
 * @method setProtoConnection
 */
NetPokerClientController.prototype.setProtoConnection = function(protoConnection) {
	if (this.protoConnection) {
		this.protoConnection.off(ProtoConnection.MESSAGE, this.onProtoConnectionMessage, this);
	}

	this.protoConnection = protoConnection;
	this.netPokerClientView.clear();

	if (this.protoConnection) {
		this.protoConnection.on(ProtoConnection.MESSAGE, this.onProtoConnectionMessage, this);
	}
}

/**
 * Incoming message.
 * Enqueue for processing.
 * @method onProtoConnectionMessage
 * @private
 */
NetPokerClientController.prototype.onProtoConnectionMessage = function(e) {
	this.messageSequencer.enqueue(e.message);
}

/**
 * Button click.
 * This function handles clicks from both the dialog and game play buttons.
 * @method onButtonClick
 * @private
 */
NetPokerClientController.prototype.onButtonClick = function(e) {
	if (!this.protoConnection)
		return;

	console.log("button click, v=" + e.value);

	var m = new ButtonClickMessage(e.button, e.value);
	this.protoConnection.send(m);
}

/**
 * Seat click.
 * @method onSeatClick
 * @private
 */
NetPokerClientController.prototype.onSeatClick = function(e) {
	var m = new SeatClickMessage(e.seatIndex);
	this.protoConnection.send(m);
}

/**
 * On send chat message.
 * @method onViewChat
 */
NetPokerClientController.prototype.onViewChat = function(e) {
	var message = new ChatMessage();
	message.user = "";
	message.text = e.text;

	this.protoConnection.send(message);
}

/**
 * On buy chips button click.
 * @method onBuyChipsButtonClick
 */
NetPokerClientController.prototype.onBuyChipsButtonClick = function() {
	console.log("buy chips click");

	this.protoConnection.send(new ButtonClickMessage(ButtonData.BUY_CHIPS));
}

/**
 * PresetButtons change message.
 * @method onPresetButtonsChange
 */
NetPokerClientController.prototype.onPresetButtonsChange = function() {
	var presetButtonsView = this.netPokerClientView.getPresetButtonsView();
	var message = new PresetButtonClickMessage();

	var c = presetButtonsView.getCurrent();
	if (c != null) {
		message.button = c.id;
		message.value = c.value;
	}

	this.protoConnection.send(message);
}

/**
 * Checkbox change.
 * @method onCheckboxChange
 */
NetPokerClientController.prototype.onCheckboxChange = function(ev) {
	this.protoConnection.send(new CheckboxMessage(ev.checkboxId, ev.checked));
}

module.exports = NetPokerClientController;
},{"../../proto/ProtoConnection":39,"../../proto/data/ButtonData":40,"../../proto/messages/ButtonClickMessage":45,"../../proto/messages/ChatMessage":47,"../../proto/messages/CheckboxMessage":48,"../../proto/messages/PresetButtonClickMessage":62,"../../proto/messages/SeatClickMessage":64,"../view/ButtonsView":20,"../view/DialogView":27,"../view/NetPokerClientView":29,"../view/PresetButtonsView":32,"../view/SettingsView":36,"../view/TableInfoView":37,"./InterfaceController":12,"./MessageSequencer":14,"./TableController":16}],16:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var SeatInfoMessage = require("../../proto/messages/SeatInfoMessage");
var CommunityCardsMessage = require("../../proto/messages/CommunityCardsMessage");
var PocketCardsMessage = require("../../proto/messages/PocketCardsMessage");
var DealerButtonMessage = require("../../proto/messages/DealerButtonMessage");
var BetMessage = require("../../proto/messages/BetMessage");
var BetsToPotMessage = require("../../proto/messages/BetsToPotMessage");
var PotMessage = require("../../proto/messages/PotMessage");
var TimerMessage = require("../../proto/messages/TimerMessage");
var ActionMessage = require("../../proto/messages/ActionMessage");
var FoldCardsMessage = require("../../proto/messages/FoldCardsMessage");
var DelayMessage = require("../../proto/messages/DelayMessage");
var EventDispatcher = require("yaed");
var ClearMessage = require("../../proto/messages/ClearMessage");
var PayOutMessage = require("../../proto/messages/PayOutMessage");

/**
 * Control the table
 * @class TableController
 */
function TableController(messageSequencer, view) {
	this.messageSequencer = messageSequencer;
	this.view = view;

	this.messageSequencer.addMessageHandler(SeatInfoMessage.TYPE, this.onSeatInfoMessage, this);
	this.messageSequencer.addMessageHandler(CommunityCardsMessage.TYPE, this.onCommunityCardsMessage, this);
	this.messageSequencer.addMessageHandler(PocketCardsMessage.TYPE, this.onPocketCardsMessage, this);
	this.messageSequencer.addMessageHandler(DealerButtonMessage.TYPE, this.onDealerButtonMessage, this);
	this.messageSequencer.addMessageHandler(BetMessage.TYPE, this.onBetMessage, this);
	this.messageSequencer.addMessageHandler(BetsToPotMessage.TYPE, this.onBetsToPot, this);
	this.messageSequencer.addMessageHandler(PotMessage.TYPE, this.onPot, this);
	this.messageSequencer.addMessageHandler(TimerMessage.TYPE, this.onTimer, this);
	this.messageSequencer.addMessageHandler(ActionMessage.TYPE, this.onAction, this);
	this.messageSequencer.addMessageHandler(FoldCardsMessage.TYPE, this.onFoldCards, this);
	this.messageSequencer.addMessageHandler(DelayMessage.TYPE, this.onDelay, this);
	this.messageSequencer.addMessageHandler(ClearMessage.TYPE, this.onClear, this);
	this.messageSequencer.addMessageHandler(PayOutMessage.TYPE, this.onPayOut, this);
}
EventDispatcher.init(TableController);

/**
 * Seat info message.
 * @method onSeatInfoMessage
 */
TableController.prototype.onSeatInfoMessage = function(m) {
	var seatView = this.view.getSeatViewByIndex(m.getSeatIndex());

	seatView.setName(m.getName());
	seatView.setChips(m.getChips());
	seatView.setActive(m.isActive());
	seatView.setSitout(m.isSitout());
}

/**
 * Seat info message.
 * @method onCommunityCardsMessage
 */
TableController.prototype.onCommunityCardsMessage = function(m) {
	var i;

	console.log("got community cards!");
	console.log(m);

	for (i = 0; i < m.getCards().length; i++) {
		var cardData = m.getCards()[i];
		var cardView = this.view.getCommunityCards()[m.getFirstIndex() + i];

		cardView.setCardData(cardData);
		cardView.show(m.animate, i * 500);
	}
	if (m.getCards().length > 0) {
		var cardData = m.getCards()[m.getCards().length - 1];
		var cardView = this.view.getCommunityCards()[m.getFirstIndex() + m.getCards().length - 1];
		if(m.animate)
			this.messageSequencer.waitFor(cardView, "animationDone");
	}
}

/**
 * Pocket cards message.
 * @method onPocketCardsMessage
 */
TableController.prototype.onPocketCardsMessage = function(m) {
	var seatView = this.view.getSeatViewByIndex(m.getSeatIndex());
	var i;

	for (i = 0; i < m.getCards().length; i++) {
		var cardData = m.getCards()[i];
		var cardView = seatView.getPocketCards()[m.getFirstIndex() + i];

		if(m.animate)
			this.messageSequencer.waitFor(cardView, "animationDone");
		cardView.setCardData(cardData);
		cardView.show(m.animate, 10);
	}
}

/**
 * Dealer button message.
 * @method onDealerButtonMessage
 */
TableController.prototype.onDealerButtonMessage = function(m) {
	var dealerButtonView = this.view.getDealerButtonView();

	if (m.seatIndex < 0) {
		dealerButtonView.hide();
	} else {
		this.messageSequencer.waitFor(dealerButtonView, "animationDone");
		dealerButtonView.show(m.getSeatIndex(), m.getAnimate());
	}
};

/**
 * Bet message.
 * @method onBetMessage
 */
TableController.prototype.onBetMessage = function(m) {
	this.view.seatViews[m.seatIndex].betChips.setValue(m.value);
};

/**
 * Bets to pot.
 * @method onBetsToPot
 */
TableController.prototype.onBetsToPot = function(m) {
	var haveChips = false;

	for (var i = 0; i < this.view.seatViews.length; i++)
		if (this.view.seatViews[i].betChips.value > 0)
			haveChips = true;

	if (!haveChips)
		return;

	for (var i = 0; i < this.view.seatViews.length; i++)
		this.view.seatViews[i].betChips.animateIn();

	this.messageSequencer.waitFor(this.view.seatViews[0].betChips, "animationDone");
}

/**
 * Pot message.
 * @method onPot
 */
TableController.prototype.onPot = function(m) {
	this.view.potView.setValues(m.values);
};

/**
 * Timer message.
 * @method onTimer
 */
TableController.prototype.onTimer = function(m) {
	if (m.seatIndex < 0)
		this.view.timerView.hide();

	else {
		this.view.timerView.show(m.seatIndex);
		this.view.timerView.countdown(m.totalTime, m.timeLeft);
	}
};

/**
 * Action message.
 * @method onAction
 */
TableController.prototype.onAction = function(m) {
	if (m.seatIndex == null)
		m.seatIndex = 0;

	this.view.seatViews[m.seatIndex].action(m.action);
};

/**
 * Fold cards message.
 * @method onFoldCards
 */
TableController.prototype.onFoldCards = function(m) {
	this.view.seatViews[m.seatIndex].foldCards();

	this.messageSequencer.waitFor(this.view.seatViews[m.seatIndex], "animationDone");
};

/**
 * Delay message.
 * @method onDelay
 */
TableController.prototype.onDelay = function(m) {
	console.log("delay for  = " + m.delay);


	this.messageSequencer.waitFor(this, "timerDone");
	setTimeout(this.dispatchEvent.bind(this, "timerDone"), m.delay);

};

/**
 * Clear message.
 * @method onClear
 */
TableController.prototype.onClear = function(m) {

	var components = m.getComponents();

	for(var i = 0; i < components.length; i++) {
		switch(components[i]) {
			case ClearMessage.POT: {
				this.view.potView.setValues([]);
				break;
			}
			case ClearMessage.BETS: {
				for(var s = 0; s < this.view.seatViews.length; s++) {
					this.view.seatViews[s].betChips.setValue(0);
				}
				break;
			}
			case ClearMessage.CARDS: {
				for(var s = 0; s < this.view.seatViews.length; s++) {
					for(var c = 0; c < this.view.seatViews[s].pocketCards.length; c++) {
						this.view.seatViews[s].pocketCards[c].hide();
					}
				}

				for(var c = 0; c < this.view.communityCards.length; c++) {
					this.view.communityCards[c].hide();
				}
				break;
			}
			case ClearMessage.CHAT: {
				this.view.chatView.clear();
				break;
			}
		}
	}
}

/**
 * Pay out message.
 * @method onPayOut
 */
TableController.prototype.onPayOut = function(m) {
	for (var i = 0; i < m.values.length; i++)
		this.view.seatViews[i].betChips.setValue(m.values[i]);

	for (var i = 0; i < this.view.seatViews.length; i++)
		this.view.seatViews[i].betChips.animateOut();

	this.messageSequencer.waitFor(this.view.seatViews[0].betChips, "animationDone");
};


module.exports = TableController;
},{"../../proto/messages/ActionMessage":42,"../../proto/messages/BetMessage":43,"../../proto/messages/BetsToPotMessage":44,"../../proto/messages/ClearMessage":49,"../../proto/messages/CommunityCardsMessage":50,"../../proto/messages/DealerButtonMessage":51,"../../proto/messages/DelayMessage":52,"../../proto/messages/FoldCardsMessage":54,"../../proto/messages/PayOutMessage":58,"../../proto/messages/PocketCardsMessage":59,"../../proto/messages/PotMessage":60,"../../proto/messages/SeatInfoMessage":65,"../../proto/messages/TimerMessage":72,"yaed":11}],17:[function(require,module,exports){
module.exports = {
	"tableBackground": "__table.png",
	"seatPlate": "__seatPlate.png",
	"timerBackground": "__timerBackground.png",
	"dealerButton": "__dealerButton.png",
	"cardFrame": "__cardFrame.png",
	"cardBack": "__cardBack.png",
	"suitSymbol0": "__suitSymbol0.png",
	"suitSymbol1": "__suitSymbol1.png",
	"suitSymbol2": "__suitSymbol2.png",
	"suitSymbol3": "__suitSymbol3.png",
	"chip0": "__chip0.png",
	"chip1": "__chip1.png",
	"chip2": "__chip2.png",
	"chip3": "__chip3.png",
	"chip4": "__chip4.png",
	"dividerLine": "__dividerLine.png",
	"framePlate": "__framePlate.png",
	"bigButton": "__bigButton.png",
	"dialogButton": "__dialogButton.png",
	"textScrollbarTrack": "__textScrollbarTrack.png",
	"textScrollbarThumb": "__textScrollbarThumb.png",
	"wrenchIcon": "__wrenchIcon.png",
	"chatBackground": "__chatBackground.png",
	"checkboxBackground": "__checkboxBackground.png",
	"checkboxTick": "__checkboxTick.png",
	"buttonBackground": "__buttonBackground.png",
	"sliderBackground": "__sliderBackground.png",
	"sliderKnob": "__sliderKnob.png",
	"upArrow": "__upArrow.png",

	"chipsColor0": 0x404040,
	"chipsColor1": 0x008000,
	"chipsColor2": 0x808000,
	"chipsColor3": 0x000080,
	"chipsColor4": 0xff0000,

	"communityCardMargin": 1,
	"betAlign": "LCRRRRCLLL",

	"tablePosition": [101, 94],
	"potPosition": [485, 315],

	"timerOffset": [55, -30],
	"communityCardsPosition": [255, 190],

	"seatPosition0": [287, 118],
	"seatPosition1": [483, 112],
	"seatPosition2": [676, 118],
	"seatPosition3": [844, 247],
	"seatPosition4": [817, 413],
	"seatPosition5": [676, 490],
	"seatPosition6": [483, 495],
	"seatPosition7": [287, 490],
	"seatPosition8": [140, 413],
	"seatPosition9": [123, 247],

	"dealerButtonPosition0": [347, 133],
	"dealerButtonPosition1": [395, 133],
	"dealerButtonPosition2": [574, 133],
	"dealerButtonPosition3": [762, 267],
	"dealerButtonPosition4": [715, 358],
	"dealerButtonPosition5": [574, 434],
	"dealerButtonPosition6": [536, 432],
	"dealerButtonPosition7": [351, 432],
	"dealerButtonPosition8": [193, 362],
	"dealerButtonPosition9": [168, 266],

	"betPosition0": [225, 150],
	"betPosition1": [478, 150],
	"betPosition2": [730, 150],
	"betPosition3": [778, 196],
	"betPosition4": [748, 322],
	"betPosition5": [719, 360],
	"betPosition6": [481, 360],
	"betPosition7": [232, 360],
	"betPosition8": [199, 322],
	"betPosition9": [181, 200],

	"bigButtonPosition": [366, 575]
};
},{}],18:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

/**
 * View configuration.
 * @class ViewConfig
 */
function ViewConfig() {
	this.playAnimations = true;
}

/**
 * Should we play animations?
 * @method setPlayAnimations
 */
ViewConfig.prototype.setPlayAnimations = function(value) {
	this.playAnimations = value;
}

/**
 * Should we play animations?
 * @method getPlayAnimations
 */
ViewConfig.prototype.getPlayAnimations = function() {
	return this.playAnimations;
}

/**
 * Scale animation time.
 * @method scaleAnimationTime
 */
ViewConfig.prototype.scaleAnimationTime = function(millis) {
	if (this.playAnimations)
		return millis;

	return 1;
}

module.exports = ViewConfig;
},{}],19:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var Button = require("../../utils/Button");
var inherits = require("inherits");

/**
 * Big button.
 * @class BigButton
 */
function BigButton(resources) {
	Button.call(this);

	this.resources = resources;

	this.bigButtonTexture = this.resources.getTexture("bigButton");

	this.addChild(new PIXI.Sprite(this.bigButtonTexture));

	var style = {
		font: "bold 18px Arial",
		//fill: "#000000"
	};

	this.labelField = new PIXI.Text("[button]", style);
	this.labelField.position.y = 30;
	this.addChild(this.labelField);

	var style = {
		font: "bold 14px Arial"
		//fill: "#000000"
	};

	this.valueField = new PIXI.Text("[value]", style);
	this.valueField.position.y = 50;
	this.addChild(this.valueField);

	this.setLabel("TEST");
	this.setValue(123);
}

inherits(BigButton, Button);

/**
 * Set label for the button.
 * @method setLabel
 */
BigButton.prototype.setLabel = function(label) {
	this.labelField.setText(label);
	this.labelField.updateTransform();
	this.labelField.x = this.bigButtonTexture.width / 2 - this.labelField.width / 2;
}

/**
 * Set value.
 * @method setValue
 */
BigButton.prototype.setValue = function(value) {
	if (!value) {
		this.valueField.visible = false;
		value = "";
	} else {
		this.valueField.visible = true;
	}

	this.valueField.setText(value);
	this.valueField.updateTransform();
	this.valueField.x = this.bigButtonTexture.width / 2 - this.valueField.width / 2;
}

module.exports = BigButton;
},{"../../utils/Button":"Button","inherits":7,"pixi.js":"pixi.js"}],20:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var EventDispatcher = require("yaed");
var Button = require("../../utils/Button");
var Slider = require("../../utils/Slider");
var NineSlice = require("../../utils/NineSlice");
var BigButton = require("./BigButton");
var RaiseShortcutButton = require("./RaiseShortcutButton");
var inherits = require("inherits");

/**
 * Buttons
 * @class ButtonsView
 */
function ButtonsView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);

	this.resources = resources;

	this.buttonHolder = new PIXI.DisplayObjectContainer();
	this.addChild(this.buttonHolder);

	var sliderBackground = new NineSlice(this.resources.getTexture("sliderBackground"), 20, 0, 20, 0);
	sliderBackground.setLocalSize(300,sliderBackground.height);
	//sliderBackground.width = 300;

	var knob = new PIXI.Sprite(this.resources.getTexture("sliderKnob"));

	this.slider = new Slider(sliderBackground, knob);
	var pos = this.resources.getPoint("bigButtonPosition");
	this.slider.position.x = pos.x;
	this.slider.position.y = pos.y - 35;
	this.slider.addEventListener("change", this.onSliderChange, this);
	this.addChild(this.slider);


	this.buttonHolder.position.x = 366;
	this.buttonHolder.position.y = 575;

	this.buttons = [];

	for (var i = 0; i < 3; i++) {
		var button = new BigButton(this.resources);
		button.on(Button.CLICK, this.onButtonClick, this);
		button.position.x = i * 105;
		this.buttonHolder.addChild(button);
		this.buttons.push(button);
	}

	var raiseSprite = new PIXI.Sprite(this.resources.getTexture("sliderKnob"));
	var arrowSprite = new PIXI.Sprite(this.resources.getTexture("upArrow"));
	arrowSprite.position.x = (raiseSprite.width - arrowSprite.width)*0.5 - 0.5;
	arrowSprite.position.y = (raiseSprite.height - arrowSprite.height)*0.5 - 2;
	raiseSprite.addChild(arrowSprite);

	this.raiseMenuButton = new Button(raiseSprite);
	this.raiseMenuButton.addEventListener(Button.CLICK, this.onRaiseMenuButtonClick, this);
	this.raiseMenuButton.position.x = 2*105 + 70;
	this.raiseMenuButton.position.y = -5;
	this.buttonHolder.addChild(this.raiseMenuButton);

	this.raiseMenuButton.visible = false;
	this.createRaiseAmountMenu();

	this.setButtons([], 0, -1, -1);

	this.buttonsDatas = [];
}

inherits(ButtonsView, PIXI.DisplayObjectContainer);
EventDispatcher.init(ButtonsView);

ButtonsView.BUTTON_CLICK = "buttonClick";


/**
 * Create raise amount menu.
 * @method createRaiseAmountMenu
 */
ButtonsView.prototype.createRaiseAmountMenu = function() {
	this.raiseAmountMenu = new PIXI.DisplayObjectContainer();

	this.raiseMenuBackground = new NineSlice(this.resources.getTexture("chatBackground"), 10, 10, 10, 10);
	this.raiseMenuBackground.position.x = 0;
	this.raiseMenuBackground.position.y = 0;
	this.raiseMenuBackground.width = 125;
	this.raiseMenuBackground.height = 220;
	this.raiseAmountMenu.addChild(this.raiseMenuBackground);

	this.raiseAmountMenu.x = 645;
	this.raiseAmountMenu.y = 570 - this.raiseAmountMenu.height;
	this.addChild(this.raiseAmountMenu);

	var styleObject = {
		font: "bold 18px Arial",
	};

	var t = new PIXI.Text("RAISE TO", styleObject);
	t.position.x = (125 - t.width)*0.5;
	t.position.y = 10;
	this.raiseAmountMenu.addChild(t);

	this.raiseShortcutButtons = new Array();

	for(var i = 0; i < 6; i++) {
		var b = new RaiseShortcutButton(this.resources);
		b.addEventListener(Button.CLICK, this.onRaiseShortcutClick, this);
		b.position.x = 10;
		b.position.y = 35 + i*30;

		this.raiseAmountMenu.addChild(b);
		this.raiseShortcutButtons.push(b);
	}

/*
	PixiTextinput should be used.
	this.raiseAmountMenuInput=new TextField();
	this.raiseAmountMenuInput.x=10;
	this.raiseAmountMenuInput.y=40+30*5;
	this.raiseAmountMenuInput.width=105;
	this.raiseAmountMenuInput.height=19;
	this.raiseAmountMenuInput.border=true;
	this.raiseAmountMenuInput.borderColor=0x404040;
	this.raiseAmountMenuInput.background=true;
	this.raiseAmountMenuInput.multiline=false;
	this.raiseAmountMenuInput.type=TextFieldType.INPUT;
	this.raiseAmountMenuInput.addEventListener(Event.CHANGE,onRaiseAmountMenuInputChange);
	this.raiseAmountMenuInput.addEventListener(KeyboardEvent.KEY_DOWN,onRaiseAmountMenuInputKeyDown);
	this.raiseAmountMenu.addChild(this.raiseAmountMenuInput);
	*/

	this.raiseAmountMenu.visible = false;
}

/**
 * Raise amount button.
 * @method onRaiseMenuButtonClick
 */
ButtonsView.prototype.onRaiseShortcutClick = function() {
	/*var b = cast e.target;

	_raiseAmountMenu.visible=false;

	buttons[_sliderIndex].value=b.value;
	_slider.value=(buttons[_sliderIndex].value-_sliderMin)/(_sliderMax-_sliderMin);
	_raiseAmountMenuInput.text=Std.string(buttons[_sliderIndex].value);

	trace("value click: "+b.value);*/
}



/**
 * Raise amount button.
 * @method onRaiseMenuButtonClick
 */
ButtonsView.prototype.onRaiseMenuButtonClick = function() {
	this.raiseAmountMenu.visible = !this.raiseAmountMenu.visible;
/*
	if(this.raiseAmountMenu.visible) {
		this.stage.mousedown = this.onStageMouseDown.bind(this);
		// this.raiseAmountMenuInput.focus();
		// this.raiseAmountMenuInput.SelectAll
	}
	else {
		this.stage.mousedown = null;
	}*/
}

/**
 * Slider change.
 * @method onSliderChange
 */
ButtonsView.prototype.onSliderChange = function() {
	var newValue = Math.round(this.sliderMin + this.slider.getValue()*(this.sliderMax - this.sliderMin));
	this.buttons[this.sliderIndex].setValue(newValue);
	this.buttonDatas[this.sliderIndex].value = newValue;
	console.log("newValue = " + newValue);

	//this.raiseAmountMenuInput.setText(buttons[_sliderIndex].value.toString());
}

/**
 * Show slider.
 * @method showSlider
 */
ButtonsView.prototype.showSlider = function(index, min, max) {
	console.log("showSlider");
	this.sliderIndex = index;
	this.sliderMin = min;
	this.sliderMax = max;

	console.log("this.buttonDatas["+index+"] = " + this.buttonDatas[index].getValue() + ", min = " + min + ", max = " + max);
	this.slider.setValue((this.buttonDatas[index].getValue() - min)/(max - min));
	console.log("this.slider.getValue() = " + this.slider.getValue());
	this.slider.visible = true;
	this.slider.show();
}

/**
 * Clear.
 * @method clear
 */
ButtonsView.prototype.clear = function(buttonDatas) {
	this.setButtons([], 0, -1, -1);
	this.slider.visible = false;
}

/**
 * Set button datas.
 * @method setButtons
 */
ButtonsView.prototype.setButtons = function(buttonDatas, sliderButtonIndex, min, max) {
	this.buttonDatas = buttonDatas;

	for (var i = 0; i < this.buttons.length; i++) {
		var button = this.buttons[i];
		if (i >= buttonDatas.length) {
			button.visible = false;
			continue;
		}

		var buttonData = buttonDatas[i];

		button.visible = true;
		button.setLabel(buttonData.getButtonString());
		button.setValue(buttonData.getValue());

	}

	if((min >= 0) && (max >= 0))
		this.showSlider(sliderButtonIndex, min, max);

	this.buttonHolder.position.x = 366;

	if (buttonDatas.length < 3)
		this.buttonHolder.position.x += 45;
}

/**
 * Button click.
 * @method onButtonClick
 * @private
 */
ButtonsView.prototype.onButtonClick = function(e) {
	var buttonIndex = -1;

	for (var i = 0; i < this.buttons.length; i++) {
		this.buttons[i].visible = false;
		if (e.target == this.buttons[i])
			buttonIndex = i;
	}

	this.slider.visible = false;

	//console.log("button click: " + buttonIndex);
	var buttonData = this.buttonDatas[buttonIndex];

	this.trigger({
		type: ButtonsView.BUTTON_CLICK,
		button: buttonData.getButton(),
		value: buttonData.getValue()
	});
}

module.exports = ButtonsView;
},{"../../utils/Button":"Button","../../utils/NineSlice":"NineSlice","../../utils/Slider":80,"./BigButton":19,"./RaiseShortcutButton":33,"inherits":7,"pixi.js":"pixi.js","yaed":11}],21:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var inherits = require("inherits");

/**
 * The front view of a card.
 * @class CardFrontView
 */
function CardFrontView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);

	this.resources = resources;
};
inherits(CardFrontView, PIXI.DisplayObjectContainer);


CardFrontView.prototype.setCardData = function(cardData) {
	this.cardData = cardData;

	// cardDiamonds2 cardDiamonds3 cardDiamonds4 cardDiamonds5 ...  cardDiamondsQ  cardDiamondsK  cardDiamondsA
	var cardTexture;
	var customName = "card" + this.cardData.getLongSuitString() + this.cardData.getCardValueString();

	if (this.resources.keyExists(customName))
		cardTexture = this.resources.getTexture(customName);

	if (cardTexture) {
		this.frame = new PIXI.Sprite(cardTexture);
		this.addChild(this.frame);
	} else {
		this.frame = new PIXI.Sprite(this.resources.getTexture("cardFrame"));
		this.addChild(this.frame);


		this.suit = new PIXI.Sprite(this.resources.getTexture("suitSymbol" + this.cardData.getSuitIndex()));
		this.suit.position.x = 8;
		this.suit.position.y = 25;
		this.addChild(this.suit);

		var style = {
			font: "bold 16px Arial"
		};

		this.valueField = new PIXI.Text("[val]", style);
		this.addChild(this.valueField);
		this.valueField.style.fill = this.cardData.getColor();

		this.valueField.setText(this.cardData.getCardValueString());
		this.valueField.updateTransform();
		this.valueField.position.x = 17 - this.valueField.canvas.width / 2;
		this.valueField.position.y = 5;

		this.suit.setTexture(this.resources.getTexture("suitSymbol" + this.cardData.getSuitIndex()));
	}
};



module.exports = CardFrontView;
},{"inherits":7,"pixi.js":"pixi.js"}],22:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var CardFrontView = require("./CardFrontView");
var EventDispatcher = require("yaed");
var inherits = require("inherits");

/**
 * A card view.
 * @class CardView
 */
function CardView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);
	this.targetPosition = null;

	this.viewConfig = viewConfig;
	this.resources = resources;


	this.front = new CardFrontView(this.viewConfig, this.resources);//PIXI.Sprite(this.resources.getTexture("cardFrame"));
	this.addChild(this.front);
/*
	this.suit = new PIXI.Sprite(this.resources.getTexture("suitSymbol" + 0));
	this.suit.position.x = 8;
	this.suit.position.y = 25;
	this.addChild(this.suit);
*/
/*	var style = {
		font: "bold 16px Arial"
	};

	this.valueField = new PIXI.Text("[val]", style);
	this.valueField.position.x = 6;
	this.valueField.position.y = 5;
	this.addChild(this.valueField);
*/
	this.back = new PIXI.Sprite(this.resources.getTexture("cardBack"));
	this.addChild(this.back);


	this.maskGraphics = new PIXI.Graphics();
	this.maskGraphics.beginFill(0x000000);
	this.maskGraphics.drawRect(0, 0, this.back.width, this.back.height);
	this.maskGraphics.endFill();
	this.addChild(this.maskGraphics);

	this.mask = this.maskGraphics;
}

inherits(CardView, PIXI.DisplayObjectContainer);
EventDispatcher.init(CardView);

/**
 * Set card data.
 * @method setCardData
 */
CardView.prototype.setCardData = function(cardData) {
	this.cardData = cardData;


	if (this.cardData.isShown()) {
		/*
		this.back.visible = false;
		this.frame.visible = true;
*/
/*
		this.valueField.style.fill = this.cardData.getColor();

		this.valueField.setText(this.cardData.getCardValueString());
		this.valueField.updateTransform();
		this.valueField.position.x = 17 - this.valueField.canvas.width / 2;

		this.suit.setTexture(this.resources.getTexture("suitSymbol" + this.cardData.getSuitIndex()));
		*/
		this.front.setCardData(this.cardData);

		this.maskGraphics.beginFill(0x000000);
		this.maskGraphics.drawRect(0, 0, this.front.width, this.front.height);
		this.maskGraphics.endFill();
	}
	this.back.visible = true;
	this.front.visible = false;
}

/**
 * Set card data.
 * @method setCardData
 */
CardView.prototype.setTargetPosition = function(point) {
	this.targetPosition = point;

	this.position.x = point.x;
	this.position.y = point.y;
}

/**
 * Hide.
 * @method hide
 */
CardView.prototype.hide = function() {
	this.visible = false;
}

/**
 * Show.
 * @method show
 */
CardView.prototype.show = function(animate, delay) {
	/*if(delay == undefined)
		delay = 1;
	*/
	this.maskGraphics.scale.y = 1;
	this.position.x = this.targetPosition.x;
	this.position.y = this.targetPosition.y;
	if (!animate) {
		this.visible = true;
		this.onShowComplete();
		return;
	}
	this.mask.height = this.height;

	var destination = {
		x: this.position.x,
		y: this.position.y
	};
	this.position.x = (this.parent.width - this.width) * 0.5;
	this.position.y = -this.height;

	var diffX = this.position.x - destination.x;
	var diffY = this.position.y - destination.y;
	var diff = Math.sqrt(diffX * diffX + diffY * diffY);

	var tween = new TWEEN.Tween(this.position)
		//            .delay(delay)
		.to({
			x: destination.x,
			y: destination.y
		}, this.viewConfig.scaleAnimationTime(500))
		.easing(TWEEN.Easing.Quadratic.Out)
		.onStart(this.onShowStart.bind(this))
		.onComplete(this.onShowComplete.bind(this))
		.start();
}

/**
 * Show complete.
 * @method onShowComplete
 */
CardView.prototype.onShowStart = function() {
	this.visible = true;
}

/**
 * Show complete.
 * @method onShowComplete
 */
CardView.prototype.onShowComplete = function() {
	if (this.cardData.isShown()) {
		this.back.visible = false;
		this.front.visible = true;
	}
	this.dispatchEvent("animationDone", this);
}

/**
 * Fold.
 * @method fold
 */
CardView.prototype.fold = function() {
	var o = {
		x: this.targetPosition.x,
		y: this.targetPosition.y + 80
	};

	var time = this.viewConfig.scaleAnimationTime(500);
	this.t0 = new TWEEN.Tween(this.position)
		.to(o, time)
		.easing(TWEEN.Easing.Quadratic.Out)
		.onUpdate(this.onFoldUpdate.bind(this))
		.onComplete(this.onFoldComplete.bind(this))
		.start();
}

/**
 * Fold animation update.
 * @method onFoldUpdate
 */
CardView.prototype.onFoldUpdate = function(progress) {
	this.maskGraphics.scale.y = 1 - progress;
}

/**
 * Fold animation complete.
 * @method onFoldComplete
 */
CardView.prototype.onFoldComplete = function() {
	this.dispatchEvent("animationDone");
}

module.exports = CardView;
},{"./CardFrontView":21,"inherits":7,"pixi.js":"pixi.js","tween.js":10,"yaed":11}],23:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var NineSlice = require("../../utils/NineSlice");
var Slider = require("../../utils/Slider");
var PixiTextInput = require("pixitextinput");
var MouseOverGroup = require("../../utils/MouseOverGroup");
var EventDispatcher = require("yaed");
var inherits = require("inherits");

/**
 * Chat view.
 * @class ChatView
 */
function ChatView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);

	this.resources = resources;
	this.margin = 5;

	
	var chatPlate = new NineSlice(this.resources.getTexture("framePlate"), 10);
	chatPlate.position.x = 10;
	chatPlate.position.y = 540;
	chatPlate.setLocalSize(330, 130);
	this.addChild(chatPlate);

	var s = new NineSlice(this.resources.getTexture("framePlate"), 10);
	s.position.x = 10;
	s.position.y = 675;
	s.setLocalSize(330, 35);
	this.addChild(s);

	var styleObject = {
		font: "12px Arial",
		wordWrapWidth: 310,
		height: 114,
		border: true,
		color: 0xFFFFFF,
		borderColor: 0x404040,
		wordWrap: true,
		multiline: true
	};

	this.container = new PIXI.DisplayObjectContainer();
	this.addChild(this.container);
	this.container.position.x = 20;
	this.container.position.y = 548;

	this.chatMask = new PIXI.Graphics();
	this.chatMask.beginFill(123);
	this.chatMask.drawRect(0, 0, 310, 114);
	this.chatMask.endFill();
	this.container.addChild(this.chatMask);

	this.chatText = new PIXI.Text("", styleObject);
	this.container.addChild(this.chatText);
	this.chatText.mask = this.chatMask;



	var styleObject = {
		font: "14px Arial",
		width: 310,
		height: 19,
		border: true,
		borderColor: 0x404040,
		background: true,
		multiline: true
	};
	this.inputField = new PixiTextInput("", styleObject);
	this.inputField.position.x = this.container.position.x;
	this.inputField.position.y = 683;
	this.inputField.width = 310;
	this.inputField.keydown = this.onKeyDown.bind(this);

	var inputShadow = new PIXI.Graphics();
	inputShadow.beginFill(0x000000);
	inputShadow.drawRect(-1, -1, 311, 20);
	inputShadow.position.x = this.inputField.position.x;
	inputShadow.position.y = this.inputField.position.y;
	this.addChild(inputShadow);

	var inputBackground = new PIXI.Graphics();
	inputBackground.beginFill(0xFFFFFF);
	inputBackground.drawRect(0, 0, 310, 19);
	inputBackground.position.x = this.inputField.position.x;
	inputBackground.position.y = this.inputField.position.y;
	this.addChild(inputBackground);

	this.addChild(this.inputField);



	var slideBack = new NineSlice(this.resources.getTexture("textScrollbarTrack"), 10, 0, 10, 0);
	slideBack.width = 107;
	var slideKnob = new NineSlice(this.resources.getTexture("textScrollbarThumb"), 10, 0, 10, 0);
	slideKnob.width = 30;


	this.slider = new Slider(slideBack, slideKnob);
	this.slider.rotation = Math.PI*0.5;
	this.slider.position.x = 326;
	this.slider.position.y = 552;
	this.slider.setValue(1);
	this.slider.visible = false;
	this.slider.addEventListener("change", this.onSliderChange.bind(this));
	this.addChild(this.slider);


	this.mouseOverGroup = new MouseOverGroup();
	this.mouseOverGroup.addDisplayObject(this.chatText);
	this.mouseOverGroup.addDisplayObject(this.slider);
	this.mouseOverGroup.addDisplayObject(this.chatMask);
	this.mouseOverGroup.addDisplayObject(chatPlate);
	this.mouseOverGroup.addEventListener("mouseover", this.onChatFieldMouseOver, this);
	this.mouseOverGroup.addEventListener("mouseout", this.onChatFieldMouseOut, this);
	this.mouseOverGroup.addEventListener("mousedown", this.onChatFieldMouseDown, this);
	this.mouseOverGroup.addEventListener("mouseup", this.onChatFieldMouseUp, this);

	chatPlate.touchstart = this.onChatFieldMouseDown.bind(this);


	this.clear();
}

inherits(ChatView, PIXI.DisplayObjectContainer);
EventDispatcher.init(ChatView);



/**
 * Clear messages.
 * @method clear
 */
ChatView.prototype.clear = function() {
	this.chatText.setText("");
 	this.chatText.y = -Math.round(this.slider.getValue()*(this.chatText.height + this.margin - this.chatMask.height ));
	this.slider.setValue(1);
}


/**
 *  Add text.
 * @method clear
 */
ChatView.prototype.addText = function(user, text) {
	this.chatText.setText(this.chatText.text + user + ": " + text + "\n");
 	this.chatText.y = -Math.round(this.slider.getValue()*(this.chatText.height + this.margin - this.chatMask.height ));
	this.slider.setValue(1);
}

/**
 * On slider value change
 * @method onSliderChange
 */
 ChatView.prototype.onSliderChange = function() {
 	this.chatText.y = -Math.round(this.slider.getValue()*(this.chatText.height + this.margin - this.chatMask.height));
 }


/**
 * On mouse over
 * @method onChatFieldMouseOver
 */
 ChatView.prototype.onChatFieldMouseOver = function() {
	this.slider.show();
 }


/**
 * On mouse out
 * @method onChatFieldMouseOut
 */
 ChatView.prototype.onChatFieldMouseOut = function() {
	this.slider.hide();
 }

/**
 * On mouse down
 * @method onChatFieldMouseDown
 */
ChatView.prototype.onChatFieldMouseDown = function(interaction_object) {
	interaction_object.target.touchend = interaction_object.target.touchendoutside = this.onChatFieldMouseUp.bind(this);
	interaction_object.target.touchmove = this.onChatFieldMouseMove.bind(this);
	this.startMousePos = interaction_object.global.y;
	this.startPos = this.chatText.y;
	this.slider.show();
}

/**
 * On mouse up
 * @method onChatFieldMouseUp
 */
ChatView.prototype.onChatFieldMouseUp = function(interaction_object) {
	interaction_object.target.touchend = interaction_object.target.touchendoutside = null;
	interaction_object.target.touchmove = null;
	this.slider.hide();
}

/**
 * On mouse up
 * @method onChatFieldMouseUp
 */
ChatView.prototype.onChatFieldMouseMove = function(interaction_object) {
	var pos = interaction_object.global.y;
	var diff = pos - this.startMousePos;

	this.slider.setValue((-(this.startPos + diff)) / (this.chatText.height + this.margin - this.chatMask.height));
 	this.onSliderChange();
}

/**
 * On key down
 * @method onKeyDown
 */
 ChatView.prototype.onKeyDown = function(event) {
	if(event.keyCode == 13) {
		this.dispatchEvent("chat", {text: this.inputField.text});
		
		this.inputField.setText("");
		
	}
 }



module.exports = ChatView;

},{"../../utils/MouseOverGroup":77,"../../utils/NineSlice":"NineSlice","../../utils/Slider":80,"inherits":7,"pixi.js":"pixi.js","pixitextinput":8,"yaed":11}],24:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var EventDispatcher = require("yaed");
var inherits = require("inherits");

/**
 * A chips view.
 * @class ChipsView
 */
function ChipsView(viewConfig, resources, showToolTip) {
	PIXI.DisplayObjectContainer.call(this);
	this.targetPosition = null;

	this.viewConfig = viewConfig;
	this.resources = resources;

	this.align = "left";

	this.value = 0;

	this.denominations = [500000, 100000, 25000, 5000, 1000, 500, 100, 25, 5, 1];

	this.stackClips = new Array();
	this.holder = new PIXI.DisplayObjectContainer();
	this.addChild(this.holder);

	this.toolTip = null;

	if (showToolTip) {
		this.toolTip = new ToolTip();
		this.addChild(this.toolTip);
	}

}

inherits(ChipsView, PIXI.DisplayObjectContainer);
EventDispatcher.init(ChipsView);

/**
 * Set alignment.
 * @method setCardData
 */
ChipsView.prototype.setAlignment = function(align) {
	if (!align)
		throw new Error("unknown alignment: " + align);

	this.align = align;
}

/**
 * Set target position.
 * @method setTargetPosition
 */
ChipsView.prototype.setTargetPosition = function(position) {
	//console.log("setting target position: " + JSON.stringify(position));

	this.targetPosition = position;
	this.position.x = position.x;
	this.position.y = position.y;
}

/**
 * Set value.
 * @method setValue
 */
ChipsView.prototype.setValue = function(value) {
	this.value = value;

	var sprite;

	for (var i = 0; i < this.stackClips.length; i++)
		this.holder.removeChild(this.stackClips[i]);

	this.stackClips = new Array();

	if (this.toolTip != null)
		this.toolTip.text = "Bet: " + this.value.toString();

	var i;
	var stackClip = null;
	var stackPos = 0;
	var chipPos = 0;

	for (i = 0; i < this.denominations.length; i++) {
		var denomination = this.denominations[i];

		chipPos = 0;
		stackClip = null;
		while (value >= denomination) {
			if (stackClip == null) {
				stackClip = new PIXI.DisplayObjectContainer();
				stackClip.x = stackPos;
				stackPos += 40;
				this.holder.addChild(stackClip);
				this.stackClips.push(stackClip);
			}
			var texture = this.resources.getTexture("chip" + (i % 5));
			var chip = new PIXI.Sprite(texture);
			chip.position.y = chipPos;
			chipPos -= 5;
			stackClip.addChild(chip);
			value -= denomination;

			var denominationString;

			if (denomination >= 1000)
				denominationString = Math.round(denomination / 1000) + "K";

			else
				denominationString = denomination;

			if ((stackClip != null) && (value < denomination)) {

				var textField = new PIXI.Text(denominationString, {
					font: "bold 12px Arial",
					align: "center",
					fill: this.resources.getColor("chipsColor" + (i % 5))
				});
				textField.position.x = (stackClip.width - textField.width) * 0.5;
				textField.position.y = chipPos + 11;
				textField.alpha = 0.5;
				/*
				textField.width = stackClip.width - 1;
				textField.height = 20;*/

				stackClip.addChild(textField);
			}
		}
	}

	switch (this.align) {
		case "left":
		case "L":
			this.holder.x = 0;
			break;

		case "center":
		case "C":
			this.holder.x = -this.holder.width / 2;
			break;

		case "right":
		case "R":
			this.holder.x = -this.holder.width;
			break;

		default:
			throw new Error("unknown align: " + this.align);
	}
}

/**
 * Hide.
 * @method hide
 */
ChipsView.prototype.hide = function() {
	this.visible = false;
}

/**
 * Show.
 * @method show
 */
ChipsView.prototype.show = function() {
	this.visible = true;

	var destination = {
		x: this.targetPosition.x,
		y: this.targetPosition.y
	};
	this.position.x = (this.parent.width - this.width) * 0.5;
	this.position.y = -this.height;

	var diffX = this.position.x - destination.x;
	var diffY = this.position.y - destination.y;
	var diff = Math.sqrt(diffX * diffX + diffY * diffY);

	var tween = new TWEEN.Tween(this.position)
		.to({
			x: destination.x,
			y: destination.y
		}, 3 * diff)
		.easing(TWEEN.Easing.Quadratic.Out)
		.onComplete(this.onShowComplete.bind(this))
		.start();
}

/**
 * Show complete.
 * @method onShowComplete
 */
ChipsView.prototype.onShowComplete = function() {

	this.dispatchEvent("animationDone", this);
}

/**
 * Animate in.
 * @method animateIn
 */
ChipsView.prototype.animateIn = function() {
	var o = {
		y: this.resources.getPoint("potPosition").y
	};

	switch (this.align) {
		case "left":
		case "L":
			o.x = this.resources.getPoint("potPosition").x - this.width / 2;
			break;

		case "center":
		case "C":
			o.x = this.resources.getPoint("potPosition").x;
			break;

		case "right":
		case "R":
			o.x = this.resources.getPoint("potPosition").x + this.width / 2;
			break;

		default:
			throw new Error("unknown align: " + this.align);
			break;
	}

	var time = this.viewConfig.scaleAnimationTime(500);
	var tween = new TWEEN.Tween(this)
		.to({
			y: this.resources.getPoint("potPosition").y,
			x: o.x
		}, time)
		.onComplete(this.onInAnimationComplete.bind(this))
		.start();
}

/**
 * In animation complete.
 * @method onInAnimationComplete
 */
ChipsView.prototype.onInAnimationComplete = function() {
	this.setValue(0);

	this.position.x = this.targetPosition.x;
	this.position.y = this.targetPosition.y;

	this.dispatchEvent("animationDone", this);
}

/**
 * Animate out.
 * @method animateOut
 */
ChipsView.prototype.animateOut = function() {
	this.position.y = this.resources.getPoint("potPosition").y;

	switch (this.align) {
		case "left":
		case "L":
			this.position.x = this.resources.getPoint("potPosition").x - this.width / 2;
			break;

		case "center":
		case "C":
			this.position.x = this.resources.getPoint("potPosition").x;
			break;

		case "right":
		case "R":
			this.position.x = this.resources.getPoint("potPosition").x + this.width / 2;
			break;

		default:
			throw new Error("unknown align: " + this.align);
			break;
	}

	var o = {
		x: this.targetPosition.x,
		y: this.targetPosition.y
	};

	var time = this.viewConfig.scaleAnimationTime(500);
	var tween = new TWEEN.Tween(this)
		.to(o, time)
		.onComplete(this.onOutAnimationComplete.bind(this))
		.start();

}

/**
 * Out animation complete.
 * @method onOutAnimationComplete
 */
ChipsView.prototype.onOutAnimationComplete = function() {

	var time = 500;
	var tween = new TWEEN.Tween({
			x: 0
		})
		.to({
			x: 10
		}, time)
		.onComplete(this.onOutWaitAnimationComplete.bind(this))
		.start();

	this.position.x = this.targetPosition.x;
	this.position.y = this.targetPosition.y;

}

/**
 * Out wait animation complete.
 * @method onOutWaitAnimationComplete
 */
ChipsView.prototype.onOutWaitAnimationComplete = function() {

	this.setValue(0);

	this.dispatchEvent("animationDone", this);
}

module.exports = ChipsView;
},{"inherits":7,"pixi.js":"pixi.js","tween.js":10,"yaed":11}],25:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var EventDispatcher = require("yaed");
var inherits = require("inherits");

/**
 * Dialog view.
 * @class DealerButtonView
 */
function DealerButtonView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);

	this.viewConfig = viewConfig;
	this.resources = resources;

	var dealerButtonTexture = this.resources.getTexture("dealerButton");
	this.sprite = new PIXI.Sprite(dealerButtonTexture);
	this.addChild(this.sprite);
	this.hide();
}

inherits(DealerButtonView, PIXI.DisplayObjectContainer);
EventDispatcher.init(DealerButtonView);

/**
 * Set seat index
 * @method setSeatIndex
 */
DealerButtonView.prototype.setSeatIndex = function(seatIndex) {
	this.position.x = this.resources.getPoint("dealerButtonPosition"+seatIndex).x;
	this.position.y = this.resources.getPoint("dealerButtonPosition"+seatIndex).y;
	this.dispatchEvent("animationDone", this);
};

/**
 * Animate to seat index.
 * @method animateToSeatIndex
 */
DealerButtonView.prototype.animateToSeatIndex = function(seatIndex) {
	if (!this.visible) {
		this.setSeatIndex(seatIndex);
		// todo dispatch event that it's complete?
		this.dispatchEvent("animationDone", this);
		return;
	}
	var destination = this.resources.getPoint("dealerButtonPosition"+seatIndex);
	var diffX = this.position.x - destination.x;
	var diffY = this.position.y - destination.y;
	var diff = Math.sqrt(diffX * diffX + diffY * diffY);

	var tween = new TWEEN.Tween(this.position)
		.to({
			x: destination.x,
			y: destination.y
		}, this.viewConfig.scaleAnimationTime(5 * diff))
		.easing(TWEEN.Easing.Quadratic.Out)
		.onComplete(this.onShowComplete.bind(this))
		.start();
};

/**
 * Show Complete.
 * @method onShowComplete
 */
DealerButtonView.prototype.onShowComplete = function() {
	this.dispatchEvent("animationDone", this);
}

/**
 * Hide.
 * @method hide
 */
DealerButtonView.prototype.hide = function() {
	this.visible = false;
}

/**
 * Show.
 * @method show
 */
DealerButtonView.prototype.show = function(seatIndex, animate) {
	if (this.visible && animate) {
		this.animateToSeatIndex(seatIndex);
	} else {
		this.visible = true;
		this.setSeatIndex(seatIndex);
	}
}

module.exports = DealerButtonView;
},{"inherits":7,"pixi.js":"pixi.js","tween.js":10,"yaed":11}],26:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var Button = require("../../utils/Button");
var inherits = require("inherits");

/**
 * Dialog button.
 * @class DialogButton
 */
function DialogButton(resources) {
	Button.call(this);

	this.buttonTexture = resources.getTexture("dialogButton");
	this.addChild(new PIXI.Sprite(this.buttonTexture));

	var style = {
		font: "normal 14px Arial",
		fill: "#ffffff"
	};

	this.textField = new PIXI.Text("[test]", style);
	this.textField.position.y = 15;
	this.addChild(this.textField);

	this.setText("BTN");
}

inherits(DialogButton, Button);

/**
 * Set text for the button.
 * @method setText
 */
DialogButton.prototype.setText = function(text) {
	this.textField.setText(text);
	this.textField.updateTransform();
	this.textField.x = this.buttonTexture.width / 2 - this.textField.width / 2;
}

module.exports = DialogButton;
},{"../../utils/Button":"Button","inherits":7,"pixi.js":"pixi.js"}],27:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var NineSlice = require("../../utils/NineSlice");
var DialogButton = require("./DialogButton");
var ButtonData = require("../../proto/data/ButtonData");
var PixiTextInput = require("pixitextinput");
var EventDispatcher = require("yaed");
var inherits = require("inherits");

/**
 * Dialog view.
 * @class DialogView
 */
function DialogView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);

	this.resources = resources;

	var cover = new PIXI.Graphics();
	cover.beginFill(0x000000, .5);
	cover.drawRect(-1000, -1000, 960 + 2000, 720 + 2000);
	cover.endFill();
	cover.interactive = true;
	//cover.buttonMode = true;
	cover.hitArea = new PIXI.Rectangle(0, 0, 960, 720);
	this.addChild(cover);

	var b = new NineSlice(this.resources.getTexture("framePlate"), 10);
	b.setLocalSize(480, 270);
	b.position.x = 480 - 480 / 2;
	b.position.y = 360 - 270 / 2;
	this.addChild(b);

	style = {
		font: "normal 14px Arial"
	};

	this.textField = new PIXI.Text("[text]", style);
	this.textField.position.x = b.position.x + 20;
	this.textField.position.y = b.position.y + 20;
	this.addChild(this.textField);

	this.buttonsHolder = new PIXI.DisplayObjectContainer();
	this.buttonsHolder.position.y = 430;
	this.addChild(this.buttonsHolder);
	this.buttons = [];

	for (var i = 0; i < 2; i++) {
		var b = new DialogButton(this.resources);

		b.position.x = i * 90;
		b.on("click", this.onButtonClick, this);
		this.buttonsHolder.addChild(b);
		this.buttons.push(b);
	}

	style = {
		font: "normal 18px Arial"
	};

	this.inputField = new PixiTextInput("", style);
	this.inputField.position.x = this.textField.position.x;

	this.inputFrame = new PIXI.Graphics();
	this.inputFrame.beginFill(0x000000);
	this.inputFrame.drawRect(-1, -1, 102, 23);
	this.inputFrame.position.x = this.inputField.position.x;
	this.addChild(this.inputFrame);

	this.addChild(this.inputField);

	this.hide();
}

inherits(DialogView, PIXI.DisplayObjectContainer);
EventDispatcher.init(DialogView);

DialogView.BUTTON_CLICK = "buttonClick";

/**
 * Hide.
 * @method hide
 */
DialogView.prototype.hide = function() {
	this.visible = false;
}

/**
 * Show.
 * @method show
 */
DialogView.prototype.show = function(text, buttonIds, defaultValue) {
	this.visible = true;

	this.buttonIds = buttonIds;

	for (i = 0; i < this.buttons.length; i++) {
		if (i < buttonIds.length) {
			var button = this.buttons[i]
			button.setText(ButtonData.getButtonStringForId(buttonIds[i]));
			button.visible = true;
		} else {
			this.buttons[i].visible = false;
		}
	}

	this.buttonsHolder.x = 480 - buttonIds.length * 90 / 2;
	this.textField.setText(text);

	if (defaultValue) {
		this.inputField.position.y = this.textField.position.y + this.textField.height + 20;
		this.inputFrame.position.y = this.inputField.position.y;
		this.inputField.visible = true;
		this.inputFrame.visible = true;

		this.inputField.text = defaultValue;
		this.inputField.focus();
	} else {
		this.inputField.visible = false;
		this.inputFrame.visible = false;
	}
}

/**
 * Handle button click.
 * @method onButtonClick
 */
DialogView.prototype.onButtonClick = function(e) {
	var buttonIndex = -1;

	for (var i = 0; i < this.buttons.length; i++)
		if (e.target == this.buttons[i])
			buttonIndex = i;

	var value = null;
	if (this.inputField.visible)
		value = this.inputField.text;

	var ev = {
		type: DialogView.BUTTON_CLICK,
		button: this.buttonIds[buttonIndex],
		value: value
	};

	this.trigger(ev);
	this.hide();
}

module.exports = DialogView;
},{"../../proto/data/ButtonData":40,"../../utils/NineSlice":"NineSlice","./DialogButton":26,"inherits":7,"pixi.js":"pixi.js","pixitextinput":8,"yaed":11}],28:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var Gradient = require("../../utils/Gradient");
var inherits = require("inherits");

/**
 * Loading screen.
 * @class LoadingScreen
 */
function LoadingScreen() {
	PIXI.DisplayObjectContainer.call(this);

	var gradient = new Gradient();
	gradient.setSize(100, 100);
	gradient.addColorStop(0, "#ffffff");
	gradient.addColorStop(1, "#c0c0c0");

	var s = gradient.createSprite();
	s.position.x=-1000;
	s.position.y=-1000;
	s.width = 960+2000;
	s.height = 720+2000;
	this.addChild(s);

	var style = {
		font: "bold 20px Arial",
		fill: "#808080"
	};

	this.textField = new PIXI.Text("[text]", style);
	this.textField.position.x = 960 / 2;
	this.textField.position.y = 720 / 2 - this.textField.height / 2;
	this.addChild(this.textField);
}

inherits(LoadingScreen, PIXI.DisplayObjectContainer);

/**
 * Show.
 * @method show
 */
LoadingScreen.prototype.show = function(message) {
	this.textField.setText(message);
	this.textField.updateTransform();
	this.textField.x = 960 / 2 - this.textField.width / 2;
	this.visible = true;
}

/**
 * Hide.
 * @method hide
 */
LoadingScreen.prototype.hide = function() {
	this.visible = false;
}

module.exports = LoadingScreen;
},{"../../utils/Gradient":"Gradient","inherits":7,"pixi.js":"pixi.js"}],29:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var EventDispatcher = require("yaed");
var SeatView = require("./SeatView");
var CardView = require("./CardView");
var ChatView = require("./ChatView");
var Point = require("../../utils/Point");
var Gradient = require("../../utils/Gradient");
var ButtonsView = require("./ButtonsView");
var DialogView = require("./DialogView");
var DealerButtonView = require("./DealerButtonView");
var ChipsView = require("./ChipsView");
var PotView = require("./PotView");
var TimerView = require("./TimerView");
var SettingsView = require("../view/SettingsView");
var TableInfoView = require("../view/TableInfoView");
var PresetButtonsView = require("../view/PresetButtonsView");
var inherits = require("inherits");

/**
 * Net poker client view.
 * @class NetPokerClientView
 */
function NetPokerClientView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);

	this.viewConfig = viewConfig;
	this.resources = resources;
	this.setupBackground();

	this.tableContainer = new PIXI.DisplayObjectContainer();
	this.addChild(this.tableContainer);

	this.tableBackground = new PIXI.Sprite(this.resources.getTexture("tableBackground"));
	this.tableContainer.addChild(this.tableBackground);
	this.tableBackground.position.x = this.resources.getPoint("tablePosition").x;
	this.tableBackground.position.y = this.resources.getPoint("tablePosition").y;

	this.setupSeats();
	this.setupCommunityCards();

	this.timerView = new TimerView(this.viewConfig, this.resources);
	this.tableContainer.addChild(this.timerView);

	this.chatView = new ChatView(this.viewConfig, this.resources);
	this.addChild(this.chatView);

	this.buttonsView = new ButtonsView(this.viewConfig, this.resources);
	this.addChild(this.buttonsView);

	this.dealerButtonView = new DealerButtonView(this.viewConfig, this.resources);
	this.addChild(this.dealerButtonView);

	this.tableInfoView = new TableInfoView(this.viewConfig, this.resources);
	this.addChild(this.tableInfoView);

	this.potView = new PotView(this.viewConfig, this.resources);
	this.addChild(this.potView);
	this.potView.position.x = this.resources.getPoint("potPosition").x;
	this.potView.position.y = this.resources.getPoint("potPosition").y;

	this.settingsView = new SettingsView(this.viewConfig, this.resources);
	this.addChild(this.settingsView);

	this.dialogView = new DialogView(this.viewConfig, this.resources);
	this.addChild(this.dialogView);

	this.presetButtonsView = new PresetButtonsView(this.viewConfig, this.resources);
	this.addChild(this.presetButtonsView);

	this.setupChips();
}

inherits(NetPokerClientView, PIXI.DisplayObjectContainer);
EventDispatcher.init(NetPokerClientView);

NetPokerClientView.SEAT_CLICK = "seatClick";

/**
 * Setup background.
 * @method setupBackground
 */
NetPokerClientView.prototype.setupBackground = function() {
	var g = new PIXI.Graphics();
	g.beginFill(0x05391d, 1);
	g.drawRect(-1000, 0, 960 + 2000, 720);
	g.endFill();
	this.addChild(g);

	var g = new PIXI.Graphics();
	g.beginFill(0x909090, 1);
	g.drawRect(-1000, 720, 960 + 2000, 1000);
	g.endFill();
	this.addChild(g);

	var gradient = new Gradient();
	gradient.setSize(100, 100);
	gradient.addColorStop(0, "#606060");
	gradient.addColorStop(.05, "#a0a0a0");
	gradient.addColorStop(1, "#909090");

	var s = gradient.createSprite();
	s.position.y = 530;
	s.position.x = -1000;
	s.width = 960 + 2000;
	s.height = 190;
	this.addChild(s);

	var s = new PIXI.Sprite(this.resources.getTexture("dividerLine"));
	s.x = 345;
	s.y = 540;
	this.addChild(s);

	var s = new PIXI.Sprite(this.resources.getTexture("dividerLine"));
	s.x = 693;
	s.y = 540;
	this.addChild(s);
}

/**
 * Setup seats.
 * @method serupSeats
 */
NetPokerClientView.prototype.setupSeats = function() {
	var i, j;
	var pocketCards;

	this.seatViews = [];

	for (i = 0; i < 10; i++) {
		var seatView = new SeatView(this.resources, i);
		var p = seatView.position;

		for (j = 0; j < 2; j++) {
			var c = new CardView(this.viewConfig, this.resources);
			c.hide();
			c.setTargetPosition(Point(p.x + j * 30 - 60, p.y - 100));
			this.tableContainer.addChild(c);
			seatView.addPocketCard(c);
			seatView.on("click", this.onSeatClick, this);
		}

		this.tableContainer.addChild(seatView);
		this.seatViews.push(seatView);
	}
}

/**
 * Setup chips.
 * @method serupSeats
 */
NetPokerClientView.prototype.setupChips = function() {
	var i;
	for (i = 0; i < 10; i++) {
		var chipsView = new ChipsView(this.viewConfig, this.resources);
		this.seatViews[i].setBetChipsView(chipsView);

		chipsView.setAlignment(this.resources.getValue("betAlign").charAt(i));
		chipsView.setTargetPosition(this.resources.getPoint("betPosition"+i));
		this.tableContainer.addChild(chipsView);
	}
}

/**
 * Seat click.
 * @method onSeatClick
 * @private
 */
NetPokerClientView.prototype.onSeatClick = function(e) {
	var seatIndex = -1;

	for (var i = 0; i < this.seatViews.length; i++)
		if (e.target == this.seatViews[i])
			seatIndex = i;

	console.log("seat click: " + seatIndex);
	this.trigger({
		type: NetPokerClientView.SEAT_CLICK,
		seatIndex: seatIndex
	});
}

/**
 * Setup community cards.
 * @method setupCommunityCards
 * @private
 */
NetPokerClientView.prototype.setupCommunityCards = function() {
	this.communityCards = [];

	var p = this.resources.getPoint("communityCardsPosition");
	var margin = parseInt(this.resources.getValue("communityCardMargin"));
	for (i = 0; i < 5; i++) {
		var cardView = new CardView(this.viewConfig, this.resources);
		cardView.hide();
		cardView.setTargetPosition(Point(p.x + i * (cardView.back.width + margin), p.y));

		this.communityCards.push(cardView);
		this.tableContainer.addChild(cardView);
	}
}

/**
 * Get seat view by index.
 * @method getSeatViewByIndex
 */
NetPokerClientView.prototype.getSeatViewByIndex = function(index) {
	return this.seatViews[index];
}

/**
 * Get community cards.
 * @method getCommunityCards
 */
NetPokerClientView.prototype.getCommunityCards = function() {
	return this.communityCards;
}

/**
 * Get buttons view.
 * @method getButtonsView
 */
NetPokerClientView.prototype.getButtonsView = function() {
	return this.buttonsView;
}

/**
 * Get preset buttons view.
 * @method presetButtonsView
 */
NetPokerClientView.prototype.getPresetButtonsView = function() {
	return this.presetButtonsView;
}

/**
 * Get dialog view.
 * @method getDialogView
 */
NetPokerClientView.prototype.getDialogView = function() {
	return this.dialogView;
}

/**
 * Get dialog view.
 * @method getDealerButtonView
 */
NetPokerClientView.prototype.getDealerButtonView = function() {
	return this.dealerButtonView;
}

/**
 * Get table info view.
 * @method getTableInfoView
 */
NetPokerClientView.prototype.getTableInfoView = function() {
	return this.tableInfoView;
}

/**
 * Get settings view.
 * @method getSettingsView
 */
NetPokerClientView.prototype.getSettingsView = function() {
	return this.settingsView;
}

/**
 * Clear everything to an empty state.
 * @method clear
 */
NetPokerClientView.prototype.clear = function() {
	var i;

	for (i = 0; i < this.communityCards.length; i++)
		this.communityCards[i].hide();

	for (i = 0; i < this.seatViews.length; i++)
		this.seatViews[i].clear();

	this.timerView.hide();
	this.potView.setValues(new Array());
	this.dealerButtonView.hide();
	this.chatView.clear();

	this.presetButtonsView.hide();

	this.dialogView.hide();
	this.buttonsView.clear();

	this.tableInfoView.clear();
	this.settingsView.clear();
}

module.exports = NetPokerClientView;
},{"../../utils/Gradient":"Gradient","../../utils/Point":78,"../view/PresetButtonsView":32,"../view/SettingsView":36,"../view/TableInfoView":37,"./ButtonsView":20,"./CardView":22,"./ChatView":23,"./ChipsView":24,"./DealerButtonView":25,"./DialogView":27,"./PotView":30,"./SeatView":34,"./TimerView":38,"inherits":7,"pixi.js":"pixi.js","yaed":11}],30:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var EventDispatcher = require("yaed");
var ChipsView = require("./ChipsView");
var inherits = require("inherits");

/**
 * A pot view
 * @class PotView
 */
function PotView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);
	
	this.viewConfig = viewConfig
	this.resources = resources;
	this.value = 0;

	this.holder = new PIXI.DisplayObjectContainer();
	this.addChild(this.holder);

	this.stacks = new Array();
}

inherits(PotView, PIXI.DisplayObjectContainer);
EventDispatcher.init(PotView);

/**
 * Set value.
 * @method setValue
 */
PotView.prototype.setValues = function(values) {
	
	for(var i = 0; i < this.stacks.length; i++)
		this.holder.removeChild(this.stacks[i]);

	this.stacks = new Array();

	var pos = 0;

	for(var i = 0; i < values.length; i++) {
		var chips = new ChipsView(this.viewConfig, this.resources, false);
		this.stacks.push(chips);
		this.holder.addChild(chips);
		chips.setValue(values[i]);
		chips.x = pos;
		pos += Math.floor(chips.width + 20);

		var textField = new PIXI.Text(values[i], {
			font: "bold 12px Arial",
			align: "center",
			fill: "#ffffff"
		});

		textField.position.x = (chips.width - textField.width)*0.5;
		textField.position.y = 30;

		chips.addChild(textField);
	}

	this.holder.x = -this.holder.width*0.5;
}

/**
 * Hide.
 * @method hide
 */
PotView.prototype.hide = function() {
	this.visible = false;
}

/**
 * Show.
 * @method show
 */
PotView.prototype.show = function() {
	this.visible = true;

}

module.exports = PotView;
},{"./ChipsView":24,"inherits":7,"pixi.js":"pixi.js","tween.js":10,"yaed":11}],31:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var EventDispatcher = require("yaed");
var Checkbox = require("../../utils/Checkbox");
var ButtonData = require("../../proto/data/ButtonData");
var inherits = require("inherits");

/**
 * A pot view
 * @class PresetButton
 */
function PresetButton(resources) {
	PIXI.DisplayObjectContainer.call(this);
	
	this.resources = resources;

	this.id = null;
	this.visible = false;
	this.value = 0;

	var b = new PIXI.Sprite(this.resources.getTexture("checkboxBackground"));
	var t = new PIXI.Sprite(this.resources.getTexture("checkboxTick"));
	t.x = 1;

	this.checkbox = new Checkbox(b,t);
	this.checkbox.addEventListener("change", this.onCheckboxChange, this);
	this.addChild(this.checkbox);

	var styleObject = {
		font: "bold 12px Arial",
		wordWrap: true,
		wordWrapWidth: 250,
		fill: "white"
	};

	this.labelField = new PIXI.Text("", styleObject);
	this.labelField.position.x = 25;

	this.addChild(this.labelField);
}

inherits(PresetButton, PIXI.DisplayObjectContainer);
EventDispatcher.init(PresetButton);


PresetButton.CHANGE = "change";

/**
 * Preset button change.
 * @method onPresetButtonChange
 */
PresetButton.prototype.onCheckboxChange = function() {
	this.dispatchEvent(PresetButton.CHANGE);
}

/**
 * Set label.
 * @method setLabel
 */
PresetButton.prototype.setLabel = function(label) {
	this.labelField.setText(label);
	return label;
}

/**
 * Show.
 * @method show
 */
PresetButton.prototype.show = function(id, value) {
	this.id = id;
	this.value = value;

	if(this.value > 0)
		this.setLabel(ButtonData.getButtonStringForId(id)+" ("+this.value+")");

	else
		this.setLabel(ButtonData.getButtonStringForId(id));

	this.visible = true;
}

/**
 * Hide.
 * @method hide
 */
PresetButton.prototype.hide = function() {
	this.id = null;
	this.visible = false;
	this.value = 0;
	this.setChecked(false);
}

/**
 * Get checked.
 * @method getChecked
 */
PresetButton.prototype.getChecked = function() {
	return this.checkbox.getChecked();
}

/**
 * Set checked.
 * @method setChecked
 */
PresetButton.prototype.setChecked = function(b) {
	this.checkbox.setChecked(b);

	return this.checkbox.getChecked();
}

/**
 * Get value.
 * @method getValue
 */
PresetButton.prototype.getValue = function() {
	return this.value;
}

module.exports = PresetButton;
},{"../../proto/data/ButtonData":40,"../../utils/Checkbox":74,"inherits":7,"pixi.js":"pixi.js","tween.js":10,"yaed":11}],32:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var EventDispatcher = require("yaed");
var PresetButton = require("./PresetButton");
var inherits = require("inherits");

/**
 * A pot view
 * @class PresetButtonsView
 */
function PresetButtonsView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);

	this.resources = resources;

	this.buttons = new Array();
	var origin = this.resources.getPoint("bigButtonPosition");

	for (var i = 0; i < 6; i++) {
		var p = new PresetButton(this.resources);
		p.addEventListener(PresetButton.CHANGE, this.onPresetButtonChange, this);
		p.x = origin.x + 30 + 140 * (i % 2);
		p.y = origin.y + 35 * Math.floor(i / 2);
		this.addChild(p);
		this.buttons.push(p);
	}

	this.hide();
}

inherits(PresetButtonsView, PIXI.DisplayObjectContainer);
EventDispatcher.init(PresetButtonsView);

PresetButtonsView.CHANGE = "change";

/**
 * Preset button change.
 * @method onPresetButtonChange
 */
PresetButtonsView.prototype.onPresetButtonChange = function(ev) {

	for (var i = 0; i < this.buttons.length; i++) {
		var b = this.buttons[i];
		if (b != ev.target) {
			b.setChecked(false);
		}
	}

	this.dispatchEvent(PresetButtonsView.CHANGE);
}

/**
 * Hide.
 * @method hide
 */
PresetButtonsView.prototype.hide = function() {
	for (var i = 0; i < this.buttons.length; i++) {
		this.buttons[i].hide();
	}
}

/**
 * Show.
 * @method show
 */
PresetButtonsView.prototype.show = function() {
	this.visible = true;

}

/**
 * Get buttons.
 * @method getButtons
 */
PresetButtonsView.prototype.getButtons = function() {
	return this.buttons;
}

/**
 * Get current preset button.
 * @method getCurrent
 */
PresetButtonsView.prototype.getCurrent = function() {
	for (var i = 0; i < this.buttons.length; i++) {
		if (this.buttons[i].getChecked() == true) {
			return this.buttons[i];
		}
	}
	return null;
}

/**
 * Get current preset button.
 * @method setCurrent
 */
PresetButtonsView.prototype.setCurrent = function(id) {
	for (var i = 0; i < this.buttons.length; i++) {
		var b = this.buttons[i];
		if ((id != null) && (b.id == id)) {
			b.setChecked(true);
		} else {
			b.setChecked(false);
		}
	}
}

module.exports = PresetButtonsView;
},{"./PresetButton":31,"inherits":7,"pixi.js":"pixi.js","tween.js":10,"yaed":11}],33:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var Button = require("../../utils/Button");
var NineSlice = require("../../utils/NineSlice");
var EventDispatcher = require("yaed");
var Checkbox = require("../../utils/Checkbox");
var inherits = require("inherits");

/**
 * Raise shortcut button
 * @class RaiseShortcutButton
 */
function RaiseShortcutButton(resources) {
	var background = new NineSlice(resources.getTexture("buttonBackground"), 10, 5, 10, 5);
	background.setLocalSize(105, 25);
	Button.call(this, background);

	var styleObject = {
		width: 105,
		height: 20,
		font: "bold 14px Arial",
		color: "white"
	};
	this.label = new PIXI.Text("", styleObject);
	this.label.position.x = 8;
	this.label.position.y = 4;
	this.addChild(this.label);
}

inherits(RaiseShortcutButton, Button);
EventDispatcher.init(RaiseShortcutButton);

/**
 * Setter.
 * @method setText
 */
RaiseShortcutButton.prototype.setText = function(string) {
	this.label.setText(string);
	return string;
}

/**
 * Set enabled.
 * @method setEnabled
 */
RaiseShortcutButton.prototype.setEnabled = function(value) {
	if (value) {
		this.alpha = 1;
		this.interactive = true;
		this.buttonMode = true;
	} else {
		this.alpha = 0.5;
		this.interactive = false;
		this.buttonMode = false;
	}
	return value;
}

module.exports = RaiseShortcutButton;
},{"../../utils/Button":"Button","../../utils/Checkbox":74,"../../utils/NineSlice":"NineSlice","inherits":7,"pixi.js":"pixi.js","tween.js":10,"yaed":11}],34:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var Button = require("../../utils/Button");
var inherits = require("inherits");

/**
 * A seat view.
 * @class SeatView
 */
function SeatView(resources, seatIndex) {
	Button.call(this);

	this.pocketCards = [];
	this.resources = resources;
	this.seatIndex = seatIndex;

	var seatTexture = this.resources.getTexture("seatPlate");
	var seatSprite = new PIXI.Sprite(seatTexture);

	seatSprite.position.x = -seatTexture.width / 2;
	seatSprite.position.y = -seatTexture.height / 2;

	this.addChild(seatSprite);

	var pos = this.resources.getPoint("seatPosition" + this.seatIndex);

	this.position.x = pos.x;
	this.position.y = pos.y;

	var style;

	style = {
		font: "bold 20px Arial"
	};

	this.nameField = new PIXI.Text("[name]", style);
	this.nameField.position.y = -20;
	this.addChild(this.nameField);

	style = {
		font: "normal 12px Arial"
	};

	this.chipsField = new PIXI.Text("[name]", style);
	this.chipsField.position.y = 5;
	this.addChild(this.chipsField);

	style = {
		font: "bold 20px Arial"
	};

	this.actionField = new PIXI.Text("action", style);
	this.actionField.position.y = -13;
	this.addChild(this.actionField);
	this.actionField.alpha = 0;

	this.setName("");
	this.setChips("");

	this.betChips = null;
}

inherits(SeatView, Button);

/**
 * Set reference to bet chips.
 * @method setBetChipsView
 */
SeatView.prototype.setBetChipsView = function(value) {
	this.betChips = value;
}

/**
 * Set name.
 * @method setName
 */
SeatView.prototype.setName = function(name) {
	this.nameField.setText(name);
	this.nameField.updateTransform();

	this.nameField.position.x = -this.nameField.canvas.width / 2;
}

/**
 * Set name.
 * @method setChips
 */
SeatView.prototype.setChips = function(chips) {
	this.chipsField.setText(chips);
	this.chipsField.updateTransform();

	this.chipsField.position.x = -this.chipsField.canvas.width / 2;
}

/**
 * Set sitout.
 * @method setSitout
 */
SeatView.prototype.setSitout = function(sitout) {
	if (sitout)
		this.alpha = .5;

	else
		this.alpha = 1;
}

/**
 * Set sitout.
 * @method setActive
 */
SeatView.prototype.setActive = function(active) {
	this.visible = active;
}

/**
 * Add pocket card.
 * @method addPocketCard
 */
SeatView.prototype.addPocketCard = function(cardView) {
	this.pocketCards.push(cardView);
}

/**
 * Get pocket cards.
 * @method getPocketCards
 */
SeatView.prototype.getPocketCards = function() {
	return this.pocketCards;
}

/**
 * Fold cards.
 * @method foldCards
 */
SeatView.prototype.foldCards = function() {
	this.pocketCards[0].addEventListener("animationDone", this.onFoldComplete, this);
	for (var i = 0; i < this.pocketCards.length; i++) {
		this.pocketCards[i].fold();
	}
}

/**
 * Fold complete.
 * @method onFoldComplete
 */
SeatView.prototype.onFoldComplete = function() {
	this.pocketCards[0].removeEventListener("animationDone", this.onFoldComplete, this);
	this.dispatchEvent("animationDone");
}

/**
 * Show user action.
 * @method action
 */
SeatView.prototype.action = function(action) {
	this.actionField.setText(action);
	this.actionField.position.x = -this.actionField.canvas.width / 2;

	this.actionField.alpha = 1;
	this.nameField.alpha = 0;
	this.chipsField.alpha = 0;

	setTimeout(this.onTimer.bind(this), 1000);
}

/**
 * Show user action.
 * @method action
 */
SeatView.prototype.onTimer = function(action) {

	var t1 = new TWEEN.Tween(this.actionField)
		.to({
			alpha: 0
		}, 1000)
		.start();
	var t2 = new TWEEN.Tween(this.nameField)
		.to({
			alpha: 1
		}, 1000)
		.start();
	var t3 = new TWEEN.Tween(this.chipsField)
		.to({
			alpha: 1
		}, 1000)
		.start();

}

/**
 * Clear.
 * @method clear
 */
SeatView.prototype.clear = function() {
	var i;

	this.visible = true;
	this.sitout = false;
	this.betChips.setValue(0);
	this.setName("");
	this.setChips("");

	for (i = 0; i < this.pocketCards.length; i++)
		this.pocketCards[i].hide();
}

module.exports = SeatView;
},{"../../utils/Button":"Button","inherits":7,"pixi.js":"pixi.js","tween.js":10}],35:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var Button = require("../../utils/Button");
var NineSlice = require("../../utils/NineSlice");
var EventDispatcher = require("yaed");
var Checkbox = require("../../utils/Checkbox");
var inherits = require("inherits");

/**
 * Checkboxes view
 * @class SettingsCheckbox
 */
function SettingsCheckbox(resources, id, string) {
 	PIXI.DisplayObjectContainer.call(this);

 	this.resources = resources;
 	this.id = id;

 	var y = 0;

 	var styleObject = {
 		width: 200,
 		height: 25,
 		font: "bold 13px Arial",
 		color: "white"
 	};
 	this.label = new PIXI.Text(string, styleObject);
 	this.label.position.x = 25;
 	this.label.position.y = y + 1;
 	this.addChild(this.label);

 	var background = new PIXI.Sprite(this.resources.getTexture("checkboxBackground"));
 	var tick = new PIXI.Sprite(this.resources.getTexture("checkboxTick"));
 	tick.x = 1;

 	this.checkbox = new Checkbox(background, tick);
 	this.checkbox.position.y = y;
 	this.addChild(this.checkbox);

 	this.checkbox.addEventListener("change", this.onCheckboxChange, this);
}

inherits(SettingsCheckbox, PIXI.DisplayObjectContainer);
EventDispatcher.init(SettingsCheckbox);

/**
 * Checkbox change.
 * @method onCheckboxChange
 */
SettingsCheckbox.prototype.onCheckboxChange = function(interaction_object) {
	this.dispatchEvent("change", this);
}

/**
 * Getter.
 * @method getChecked
 */
SettingsCheckbox.prototype.getChecked = function() {
	return this.checkbox.getChecked();
}

/**
 * Setter.
 * @method setChecked
 */
SettingsCheckbox.prototype.setChecked = function(checked) {
	this.checkbox.setChecked(checked);
	return checked;
}

module.exports = SettingsCheckbox;
},{"../../utils/Button":"Button","../../utils/Checkbox":74,"../../utils/NineSlice":"NineSlice","inherits":7,"pixi.js":"pixi.js","tween.js":10,"yaed":11}],36:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var Button = require("../../utils/Button");
var NineSlice = require("../../utils/NineSlice");
var EventDispatcher = require("yaed");
var SettingsCheckbox = require("./SettingsCheckbox");
var RaiseShortcutButton = require("./RaiseShortcutButton");
var CheckboxMessage = require("../../proto/messages/CheckboxMessage");
var ButtonData = require("../../proto/data/ButtonData");
var inherits = require("inherits");

/**
 * A settings view
 * @class SettingsView
 */
function SettingsView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);

	this.viewConfig = viewConfig;
	this.resources = resources;

	var object = new PIXI.DisplayObjectContainer();
	var bg = new NineSlice(this.resources.getTexture("chatBackground"), 10, 10, 10, 10);
	bg.setLocalSize(30, 30);
	object.addChild(bg);

	var sprite = new PIXI.Sprite(this.resources.getTexture("wrenchIcon"));
	sprite.x = 5;
	sprite.y = 5;
	object.addChild(sprite);

	this.settingsButton = new Button(object);
	this.settingsButton.position.x = 960 - 10 - this.settingsButton.width;
	this.settingsButton.position.y = 543;
	this.settingsButton.addEventListener(Button.CLICK, this.onSettingsButtonClick, this);
	this.addChild(this.settingsButton);

	this.settingsMenu = new PIXI.DisplayObjectContainer();

	var mbg = new NineSlice(this.resources.getTexture("chatBackground"), 10, 10, 10, 10);
	mbg.setLocalSize(250, 100);
	this.settingsMenu.addChild(mbg);

	var styleObject = {
		font: "bold 14px Arial",
		color: "#FFFFFF",
		width: 200,
		height: 20
	};
	var label = new PIXI.Text("Settings", styleObject);
	label.position.x = 16;
	label.position.y = 10;

	this.settingsMenu.addChild(label);
	this.settingsMenu.position.x = 960 - 10 - this.settingsMenu.width;
	this.settingsMenu.position.y = 538 - this.settingsMenu.height;
	this.addChild(this.settingsMenu);

	this.settings = {};

	//console.log("setting up settings, viewconfig=" + this.viewConfig);

	this.createMenuSetting("playAnimations", "Play animations", 40, this.viewConfig.getPlayAnimations());
	this.createMenuSetting(CheckboxMessage.AUTO_MUCK_LOSING, "Muck losing hands", 65);

	this.createSetting(CheckboxMessage.AUTO_POST_BLINDS, "Post blinds", 0);
	this.createSetting(CheckboxMessage.SITOUT_NEXT, "Sit out", 25);

	this.settingsMenu.visible = false;

	this.buyChipsButton = new RaiseShortcutButton(this.resources);
	this.buyChipsButton.addEventListener("click", this.onBuyChipsClick, this);
	this.buyChipsButton.x = 700;
	this.buyChipsButton.y = 635;
	this.buyChipsButton.setText("Buy chips");
	this.addChild(this.buyChipsButton);

	this.buyChipsButton.visible = false;

	// Prevent mouse over from falling through, doesn't work.
	/*this.settingsMenu.interactive = true;
	this.settingsMenu.buttonMode = true;
	this.settingsMenu.mouseover = function() { console.log("test"); };
	this.settingsMenu.mouseout = function() { console.log("test"); };
	this.settingsMenu.mousedown = function() { console.log("test"); };
	this.settingsMenu.mouseup = function() { console.log("test"); };
	this.settingsMenu.click = function() { console.log("test"); };*/
}

inherits(SettingsView, PIXI.DisplayObjectContainer);
EventDispatcher.init(SettingsView);

SettingsView.BUY_CHIPS_CLICK = "buyChipsClick";
SettingsView.CHECKBOX_CHANGE = "checkboxChange";

/**
 * On buy chips button clicked.
 * @method onBuyChipsClick
 */
SettingsView.prototype.onBuyChipsClick = function(interaction_object) {
	console.log("buy chips click");
	this.dispatchEvent(SettingsView.BUY_CHIPS_CLICK);
}

/**
 * Create checkbox.
 * @method createMenuSetting
 */
SettingsView.prototype.createMenuSetting = function(id, string, y, def) {
	var setting = new SettingsCheckbox(this.resources, id, string);

	setting.y = y;
	setting.x = 16;
	this.settingsMenu.addChild(setting);

	setting.addEventListener("change", this.onCheckboxChange, this)

	this.settings[id] = setting;
	setting.setChecked(def);
}

/**
 * Create setting.
 * @method createSetting
 */
SettingsView.prototype.createSetting = function(id, string, y) {
	var setting = new SettingsCheckbox(this.resources, id, string);

	setting.y = 545 + y;
	setting.x = 700;
	this.addChild(setting);

	setting.addEventListener("change", this.onCheckboxChange, this)

	this.settings[id] = setting;
}

/**
 * Checkbox change.
 * @method onCheckboxChange
 */
SettingsView.prototype.onCheckboxChange = function(checkbox) {
	if (checkbox.id == "playAnimations") {
		this.viewConfig.setPlayAnimations(checkbox.getChecked());
		console.log("anims changed..");
	}

	this.dispatchEvent(SettingsView.CHECKBOX_CHANGE, {
		checkboxId: checkbox.id,
		checked: checkbox.getChecked()
	});
}

/**
 * Settings button click.
 * @method onSettingsButtonClick
 */
SettingsView.prototype.onSettingsButtonClick = function(interaction_object) {
	console.log("SettingsView.prototype.onSettingsButtonClick");
	this.settingsMenu.visible = !this.settingsMenu.visible;

	if (this.settingsMenu.visible) {
		this.stage.mousedown = this.stage.touchstart = this.onStageMouseDown.bind(this);
	} else {
		this.stage.mousedown = null;
	}
}

/**
 * Stage mouse down.
 * @method onStageMouseDown
 */
SettingsView.prototype.onStageMouseDown = function(interaction_object) {
	console.log("SettingsView.prototype.onStageMouseDown");
	if ((this.hitTest(this.settingsMenu, interaction_object)) || (this.hitTest(this.settingsButton, interaction_object))) {
		return;
	}

	this.stage.mousedown = null;
	this.settingsMenu.visible = false;
}

/**
 * Hit test.
 * @method hitTest
 */
SettingsView.prototype.hitTest = function(object, interaction_object) {
	if ((interaction_object.global.x > object.getBounds().x) && (interaction_object.global.x < (object.getBounds().x + object.getBounds().width)) &&
		(interaction_object.global.y > object.getBounds().y) && (interaction_object.global.y < (object.getBounds().y + object.getBounds().height))) {
		return true;
	}
	return false;
}

/**
 * Reset.
 * @method clear
 */
SettingsView.prototype.clear = function() {
	this.buyChipsButton.enabled = true;
	this.setVisibleButtons([]);

	this.setCheckboxChecked(CheckboxMessage.AUTO_POST_BLINDS, false);
	this.setCheckboxChecked(CheckboxMessage.AUTO_MUCK_LOSING, false);
	this.setCheckboxChecked(CheckboxMessage.SITOUT_NEXT, false);

	this.settingsMenu.visible = false;
	if (this.settingsMenu.visible)
		this.stage.mousedown = null;
}

/**
 * Set visible buttons.
 * @method setVisibleButtons
 */
SettingsView.prototype.setVisibleButtons = function(buttons) {
	this.buyChipsButton.visible = buttons.indexOf(ButtonData.BUY_CHIPS) != -1;
	this.settings[CheckboxMessage.AUTO_POST_BLINDS].visible = buttons.indexOf(CheckboxMessage.AUTO_POST_BLINDS) >= 0;
	this.settings[CheckboxMessage.SITOUT_NEXT].visible = buttons.indexOf(CheckboxMessage.SITOUT_NEXT) >= 0;

	var yp = 543;

	if (this.buyChipsButton.visible) {
		this.buyChipsButton.y = yp;
		yp += 35;
	} else {
		yp += 2;
	}

	if (this.settings[CheckboxMessage.AUTO_POST_BLINDS].visible) {
		this.settings[CheckboxMessage.AUTO_POST_BLINDS].y = yp;
		yp += 25;
	}

	if (this.settings[CheckboxMessage.SITOUT_NEXT].visible) {
		this.settings[CheckboxMessage.SITOUT_NEXT].y = yp;
		yp += 25;
	}
}

/**
 * Set checkbox state.
 * @method setCheckboxChecked
 */
SettingsView.prototype.setCheckboxChecked = function(id, checked) {
	//console.log("setting checkbox state for: " + id);

	this.settings[id].setChecked(checked);
}

module.exports = SettingsView;
},{"../../proto/data/ButtonData":40,"../../proto/messages/CheckboxMessage":48,"../../utils/Button":"Button","../../utils/NineSlice":"NineSlice","./RaiseShortcutButton":33,"./SettingsCheckbox":35,"inherits":7,"pixi.js":"pixi.js","tween.js":10,"yaed":11}],37:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var EventDispatcher = require("yaed");
var DialogButton = require("./DialogButton");
var inherits = require("inherits");
var ButtonData = require("../../proto/data/ButtonData");

/**
 * Show table info.
 * @class TableInfoView
 */
function TableInfoView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);

	this.viewConfig = viewConfig;
	this.resources = resources;

	var style = {
		font: "bold 24px Times New Roman",
		fill: "#ffffff",
		dropShadow: true,
		dropShadowColor: "#000000",
		dropShadowDistance: 2,
		stroke: "#000000",
		strokeThickness: 2,
		wordWrap: true,
		wordWrapWidth: 300
	};

	this.tableInfoText = new PIXI.Text("<TableInfoText>", style);
	this.tableInfoText.position.x = 355;
	this.tableInfoText.position.y = 540;
	this.addChild(this.tableInfoText);

	var style = {
		font: "bold 24px Times New Roman",
		fill: "#ffffff",
		align: "center"
	};

	this.preTournamentInfoText = new PIXI.Text("<PreTournamentInfoText>", style);
	this.preTournamentInfoText.position.y = 360;
	//this.preTournamentInfoText.position.y = 280;
	this.preTournamentInfoText.position.x = Math.round(960 - 300) / 2;
	this.preTournamentInfoText.alpha = .25;
	this.addChild(this.preTournamentInfoText);

	var style = {
		font: "bold 12px Arial",
		fill: "#ffffff",
		dropShadow: true,
		dropShadowColor: "#000000",
		dropShadowDistance: 1,
		stroke: "#000000",
		strokeThickness: 1,
	};

	this.handInfoText = new PIXI.Text("<HandInfoText>", style);
	this.handInfoText.position.y = 10;
	this.handInfoText.position.x = 960 - this.handInfoText.width;
	this.addChild(this.handInfoText);

	this.joinButton = new DialogButton(this.resources);
	this.joinButton.position.x = 355;
	this.joinButton.setText("JOIN");
	this.joinButton.visible = false;
	this.joinButton.on("click", this.onButtonClick, this);
	this.addChild(this.joinButton);

	this.leaveButton = new DialogButton(this.resources);
	this.leaveButton.position.x = 355;
	this.leaveButton.setText("LEAVE");
	this.leaveButton.visible = false;
	this.leaveButton.on("click", this.onButtonClick, this);
	this.addChild(this.leaveButton);
}

inherits(TableInfoView, PIXI.DisplayObjectContainer);
EventDispatcher.init(TableInfoView);

TableInfoView.BUTTON_CLICK = "buttonClick";

/**
 * Set table info text.
 * @method setTableInfoText
 */
TableInfoView.prototype.setTableInfoText = function(s) {
	if (!s)
		s = "";

	this.tableInfoText.setText(s);
	this.joinButton.position.y = this.tableInfoText.position.y + this.tableInfoText.height + 5;
	this.leaveButton.position.y = this.tableInfoText.position.y + this.tableInfoText.height + 5;
}

/**
 * Set pre tournament info text.
 * @method setPreTournamentInfoText
 */
TableInfoView.prototype.setPreTournamentInfoText = function(s) {
	if (!s)
		s = "";

	this.preTournamentInfoText.setText(s);
	this.preTournamentInfoText.position.x = 960 / 2 - this.preTournamentInfoText.width / 2;
}

/**
 * Join button.
 * @method setJoinButtonVisible
 */
TableInfoView.prototype.setJoinButtonVisible = function(value) {
	this.joinButton.visible = value;
}

/**
 * Join button
 * @method setLeaveButtonVisible
 */
TableInfoView.prototype.setLeaveButtonVisible = function(value) {
	this.leaveButton.visible = value;
}

/**
 * Set hand info text.
 * @method setTableInfoText
 */
TableInfoView.prototype.setHandInfoText = function(s) {
	if (!s)
		s = "";

	this.handInfoText.setText(s);
	this.handInfoText.updateTransform();
	this.handInfoText.position.x = 960 - this.handInfoText.width - 10;
}

/**
 * Clear.
 * @method clear
 */
TableInfoView.prototype.clear = function() {
	this.tableInfoText.setText("");
	this.handInfoText.setText("");
	this.preTournamentInfoText.setText("");
	this.joinButton.visible = false;
	this.leaveButton.visible = false;
}

/**
 * Button click
 * @method onButtonClick
 * @private
 */
TableInfoView.prototype.onButtonClick = function(e) {
	this.joinButton.visible = false;
	this.leaveButton.visible = false;

	var ev = {
		type: TableInfoView.BUTTON_CLICK
	};

	if (e.target == this.joinButton)
		ev.button = ButtonData.JOIN_TOURNAMENT;

	if (e.target == this.leaveButton)
		ev.button = ButtonData.LEAVE_TOURNAMENT;

	console.log("button click");
	this.trigger(ev);
}

module.exports = TableInfoView;
},{"../../proto/data/ButtonData":40,"./DialogButton":26,"inherits":7,"pixi.js":"pixi.js","yaed":11}],38:[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var EventDispatcher = require("yaed");
var inherits = require("inherits");

/**
 * A timer view
 * @class TimerView
 */
function TimerView(viewConfig, resources) {
	PIXI.DisplayObjectContainer.call(this);

	this.resources = resources

	this.timerClip = new PIXI.Sprite(this.resources.getTexture("timerBackground"));
	this.addChild(this.timerClip);


	this.canvas = new PIXI.Graphics();
	this.canvas.x = this.timerClip.width * 0.5;
	this.canvas.y = this.timerClip.height * 0.5;
	this.timerClip.addChild(this.canvas);

	this.timerClip.visible = false;

	this.tween = null;

	//this.showPercent(30);
}

inherits(TimerView, PIXI.DisplayObjectContainer);
EventDispatcher.init(TimerView);

/**
 * Hide.
 * @method hide
 */
TimerView.prototype.hide = function() {
	this.timerClip.visible = false;
	this.stop();
}

/**
 * Show.
 * @method show
 */
TimerView.prototype.show = function(seatIndex) {

	this.timerClip.visible = true;

	var seatPosition = this.resources.getPoint("seatPosition" + seatIndex);
	var timerOffset = this.resources.getPoint("timerOffset");

	this.timerClip.x = seatPosition.x + timerOffset.x;
	this.timerClip.y = seatPosition.y + timerOffset.y;

	this.stop();

}

/**
 * Stop.
 * @method stop
 */
TimerView.prototype.stop = function(seatIndex) {
	if (this.tween != null)
		this.tween.stop();

}

/**
 * Countdown.
 * @method countdown
 */
TimerView.prototype.countdown = function(totalTime, timeLeft) {
	this.stop();

	totalTime *= 1000;
	timeLeft *= 1000;

	var time = Date.now();
	this.startAt = time + timeLeft - totalTime;
	this.stopAt = time + timeLeft;

	this.tween = new TWEEN.Tween({
			time: time
		})
		.to({
			time: this.stopAt
		}, timeLeft)
		.onUpdate(this.onUpdate.bind(this))
		.onComplete(this.onComplete.bind(this))
		.start();

}

/**
 * On tween update.
 * @method onUpdate
 */
TimerView.prototype.onUpdate = function() {
	var time = Date.now();
	var percent = 100 * (time - this.startAt) / (this.stopAt - this.startAt);

	//	console.log("p = " + percent);

	this.showPercent(percent);
}

/**
 * On tween update.
 * @method onUpdate
 */
TimerView.prototype.onComplete = function() {
	var time = Date.now();
	var percent = 100;
	this.showPercent(percent);
	this.tween = null;
}

/**
 * Show percent.
 * @method showPercent
 */
TimerView.prototype.showPercent = function(value) {
	if (value < 0)
		value = 0;

	if (value > 100)
		value = 100;

	this.canvas.clear();

	this.canvas.beginFill(0xc00000);
	this.canvas.drawCircle(0, 0, 10);
	this.canvas.endFill();

	this.canvas.beginFill(0xffffff);
	this.canvas.moveTo(0, 0);
	for (var i = 0; i < 33; i++) {
		this.canvas.lineTo(
			10 * Math.cos(i * value * 2 * Math.PI / (32 * 100) - Math.PI / 2),
			10 * Math.sin(i * value * 2 * Math.PI / (32 * 100) - Math.PI / 2)
		);
	}

	this.canvas.lineTo(0, 0);
	this.canvas.endFill();

}

module.exports = TimerView;
},{"inherits":7,"pixi.js":"pixi.js","tween.js":10,"yaed":11}],39:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

var EventDispatcher = require("yaed");
var inherits = require("inherits");

var InitMessage = require("./messages/InitMessage");
var StateCompleteMessage = require("./messages/StateCompleteMessage");
var SeatInfoMessage = require("./messages/SeatInfoMessage");
var CommunityCardsMessage = require("./messages/CommunityCardsMessage");
var PocketCardsMessage = require("./messages/PocketCardsMessage");
var SeatClickMessage = require("./messages/SeatClickMessage");
var ShowDialogMessage = require("./messages/ShowDialogMessage");
var ButtonClickMessage = require("./messages/ButtonClickMessage");
var ButtonsMessage = require("./messages/ButtonsMessage");
var DelayMessage = require("./messages/DelayMessage");
var ClearMessage = require("./messages/ClearMessage");
var DealerButtonMessage = require("./messages/DealerButtonMessage");
var BetMessage = require("./messages/BetMessage");
var BetsToPotMessage = require("./messages/BetsToPotMessage");

var ActionMessage = require("./messages/ActionMessage");
var ChatMessage = require("./messages/ChatMessage");
var CheckboxMessage = require("./messages/CheckboxMessage");
var FadeTableMessage = require("./messages/FadeTableMessage");
var HandInfoMessage = require("./messages/HandInfoMessage");
var InterfaceStateMessage = require("./messages/InterfaceStateMessage");
var PayOutMessage = require("./messages/PayOutMessage");
var PotMessage = require("./messages/PotMessage");
var PresetButtonClickMessage = require("./messages/PresetButtonClickMessage");
var PresetButtonsMessage = require("./messages/PresetButtonsMessage");
var PreTournamentInfoMessage = require("./messages/PreTournamentInfoMessage");
var TableButtonClickMessage = require("./messages/TableButtonClickMessage");
var TableButtonsMessage = require("./messages/TableButtonsMessage");
var TableInfoMessage = require("./messages/TableInfoMessage");
var TestCaseRequestMessage = require("./messages/TestCaseRequestMessage");
var TimerMessage = require("./messages/TimerMessage");
var TournamentResultMessage = require("./messages/TournamentResultMessage");
var FoldCardsMessage = require("./messages/FoldCardsMessage");

/**
 * A protocol connection with an underlying connection.
 *
 * There are two ways to liten for connections, the first one and most straight
 * forward is the addMessageHandler, which registers a listener for a
 * particular network message. The first argument should be the message
 * class to listen for:
 *
 *     function onSeatInfoMessage(m) {
 *         // Check if the seat is active.
 *         m.isActive();
 *     }
 *
 *     protoConnection.addMessageHandler(SeatInfoMessage, onSeatInfoMessage);
 *
 * The second method is to listen to the ProtoConnection.MESSAGE dispatched
 * by the instance of the ProtoConnection. In this case, the listener
 * will be called for all messages received on the connection.
 *
 *     function onMessage(e) {
 *         var message=e.message;
 *
 *         // Is it a SeatInfoMessage?
 *         if (message instanceof SeatInfoMessage) {
 *             // ...
 *         }
 *     }
 *
 *     protoConnection.addMessageHandler(SeatInfoMessage, onMessage);
 *
 * The underlying connection should be an object that implements an "interface"
 * of a connection. It is not an interface per se, since JavaScript doesn't support
 * it. Anyway, the signature of this interface, is that the connection object
 * should have a `send` method which receives a object to be send. It should also
 * dispatch "message" events as messages are received, and "close" events if the
 * connection is closed by the remote party.
 *
 * @class ProtoConnection
 * @extends EventDispatcher
 * @constructor
 * @param connection The underlying connection object.
 */
function ProtoConnection(connection) {
	EventDispatcher.call(this);

	this.logMessages = false;
	this.messageDispatcher = new EventDispatcher();
	this.connection = connection;
	this.connection.addEventListener("message", this.onConnectionMessage, this);
	this.connection.addEventListener("close", this.onConnectionClose, this);
}

inherits(ProtoConnection, EventDispatcher);

/**
 * Triggers if the remote party closes the underlying connection.
 * @event ProtoConnection.CLOSE
 */
ProtoConnection.CLOSE = "close";

/**
 * Triggers when we receive a message from the remote party.
 * @event ProtoConnection.MESSAGE
 * @param {Object} message The message that was received.
 */
ProtoConnection.MESSAGE = "message";

ProtoConnection.MESSAGE_TYPES = {};
ProtoConnection.MESSAGE_TYPES[InitMessage.TYPE] = InitMessage;
ProtoConnection.MESSAGE_TYPES[StateCompleteMessage.TYPE] = StateCompleteMessage;
ProtoConnection.MESSAGE_TYPES[SeatInfoMessage.TYPE] = SeatInfoMessage;
ProtoConnection.MESSAGE_TYPES[CommunityCardsMessage.TYPE] = CommunityCardsMessage;
ProtoConnection.MESSAGE_TYPES[PocketCardsMessage.TYPE] = PocketCardsMessage;
ProtoConnection.MESSAGE_TYPES[SeatClickMessage.TYPE] = SeatClickMessage;
ProtoConnection.MESSAGE_TYPES[ShowDialogMessage.TYPE] = ShowDialogMessage;
ProtoConnection.MESSAGE_TYPES[ButtonClickMessage.TYPE] = ButtonClickMessage;
ProtoConnection.MESSAGE_TYPES[ButtonsMessage.TYPE] = ButtonsMessage;
ProtoConnection.MESSAGE_TYPES[DelayMessage.TYPE] = DelayMessage;
ProtoConnection.MESSAGE_TYPES[ClearMessage.TYPE] = ClearMessage;
ProtoConnection.MESSAGE_TYPES[DealerButtonMessage.TYPE] = DealerButtonMessage;
ProtoConnection.MESSAGE_TYPES[BetMessage.TYPE] = BetMessage;
ProtoConnection.MESSAGE_TYPES[BetsToPotMessage.TYPE] = BetsToPotMessage;

ProtoConnection.MESSAGE_TYPES[ActionMessage.TYPE] = ActionMessage;
ProtoConnection.MESSAGE_TYPES[ChatMessage.TYPE] = ChatMessage;
ProtoConnection.MESSAGE_TYPES[CheckboxMessage.TYPE] = CheckboxMessage;
ProtoConnection.MESSAGE_TYPES[FadeTableMessage.TYPE] = FadeTableMessage;
ProtoConnection.MESSAGE_TYPES[HandInfoMessage.TYPE] = HandInfoMessage;
ProtoConnection.MESSAGE_TYPES[InterfaceStateMessage.TYPE] = InterfaceStateMessage;
ProtoConnection.MESSAGE_TYPES[PayOutMessage.TYPE] = PayOutMessage;
ProtoConnection.MESSAGE_TYPES[PotMessage.TYPE] = PotMessage;
ProtoConnection.MESSAGE_TYPES[PresetButtonClickMessage.TYPE] = PresetButtonClickMessage;
ProtoConnection.MESSAGE_TYPES[PresetButtonsMessage.TYPE] = PresetButtonsMessage;
ProtoConnection.MESSAGE_TYPES[PreTournamentInfoMessage.TYPE] = PreTournamentInfoMessage;
ProtoConnection.MESSAGE_TYPES[TableButtonClickMessage.TYPE] = TableButtonClickMessage;
ProtoConnection.MESSAGE_TYPES[TableButtonsMessage.TYPE] = TableButtonsMessage;
ProtoConnection.MESSAGE_TYPES[TableInfoMessage.TYPE] = TableInfoMessage;
ProtoConnection.MESSAGE_TYPES[TestCaseRequestMessage.TYPE] = TestCaseRequestMessage;
ProtoConnection.MESSAGE_TYPES[TimerMessage.TYPE] = TimerMessage;
ProtoConnection.MESSAGE_TYPES[TournamentResultMessage.TYPE] = TournamentResultMessage;
ProtoConnection.MESSAGE_TYPES[FoldCardsMessage.TYPE] = FoldCardsMessage;

/**
 * Add message handler.
 * @method addMessageHandler
 */
ProtoConnection.prototype.addMessageHandler = function(messageType, handler, scope) {
	if (messageType.hasOwnProperty("TYPE"))
		messageType = messageType.TYPE;

	this.messageDispatcher.on(messageType, handler, scope);
}

/**
 * Remove message handler.
 * @method removeMessageHandler
 */
ProtoConnection.prototype.removeMessageHandler = function(messageType, handler, scope) {
	if (messageType.hasOwnProperty("TYPE"))
		messageType = messageType.TYPE;

	this.messageDispatcher.off(messageType, handler, scope);
}

/**
 * Connection message.
 * @method onConnectionMessage
 * @private
 */
ProtoConnection.prototype.onConnectionMessage = function(ev) {
	var message = ev.message;
	var constructor;

	if (this.logMessages)
		console.log("==> " + JSON.stringify(message));

	for (type in ProtoConnection.MESSAGE_TYPES) {
		if (message.type == type)
			constructor = ProtoConnection.MESSAGE_TYPES[type]
	}

	if (!constructor) {
		console.warn("unknown message: " + message.type);
		return;
	}

	var o = new constructor();
	o.unserialize(message);
	o.type = message.type;

	this.messageDispatcher.trigger(o);

	this.trigger({
		type: ProtoConnection.MESSAGE,
		message: o
	});
}

/**
 * Connection close.
 * @method onConnectionClose
 * @private
 */
ProtoConnection.prototype.onConnectionClose = function(ev) {
	this.connection.off("message", this.onConnectionMessage, this);
	this.connection.off("close", this.onConnectionClose, this);

	this.close();

	this.connection = null;

	this.trigger(ProtoConnection.CLOSE);
}

/**
 * Send a message.
 * @method send
 */
ProtoConnection.prototype.send = function(message) {
	var serialized = message.serialize();

	for (type in ProtoConnection.MESSAGE_TYPES) {
		if (message instanceof ProtoConnection.MESSAGE_TYPES[type])
			serialized.type = type;
	}

	if (!serialized.type)
		throw new Error("Unknown message type for send, message=" + message.constructor.name);

	//	console.log("sending: "+serialized);

	this.connection.send(serialized);
}

/**
 * Should messages be logged to console?
 * @method setLogMessages
 */
ProtoConnection.prototype.setLogMessages = function(value) {
	this.logMessages = value;
}

/**
 * Close the underlying connection. Only close it if the readyState is undefined,
 * i.e. we are in a node.js environment, or if it says that it is actually open.
 * @method close
 */
ProtoConnection.prototype.close = function() {
	if (!this.connection)
		return;

	if (this.connection.readyState === undefined ||
		this.connection.readyState == 1)
		this.connection.close();
}

/**
 * Get string representation.
 * @method toString
 */
ProtoConnection.prototype.toString = function() {
	return "<ProtoConnection>";
}

module.exports = ProtoConnection;
},{"./messages/ActionMessage":42,"./messages/BetMessage":43,"./messages/BetsToPotMessage":44,"./messages/ButtonClickMessage":45,"./messages/ButtonsMessage":46,"./messages/ChatMessage":47,"./messages/CheckboxMessage":48,"./messages/ClearMessage":49,"./messages/CommunityCardsMessage":50,"./messages/DealerButtonMessage":51,"./messages/DelayMessage":52,"./messages/FadeTableMessage":53,"./messages/FoldCardsMessage":54,"./messages/HandInfoMessage":55,"./messages/InitMessage":56,"./messages/InterfaceStateMessage":57,"./messages/PayOutMessage":58,"./messages/PocketCardsMessage":59,"./messages/PotMessage":60,"./messages/PreTournamentInfoMessage":61,"./messages/PresetButtonClickMessage":62,"./messages/PresetButtonsMessage":63,"./messages/SeatClickMessage":64,"./messages/SeatInfoMessage":65,"./messages/ShowDialogMessage":66,"./messages/StateCompleteMessage":67,"./messages/TableButtonClickMessage":68,"./messages/TableButtonsMessage":69,"./messages/TableInfoMessage":70,"./messages/TestCaseRequestMessage":71,"./messages/TimerMessage":72,"./messages/TournamentResultMessage":73,"inherits":7,"yaed":11}],40:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Button data.
 * @class ButtonData
 */
function ButtonData(button, value) {
	this.button = button;
	this.value = value;
}

ButtonData.RAISE = "raise";
ButtonData.FOLD = "fold";
ButtonData.BET = "bet";
ButtonData.SIT_OUT = "sitOut";
ButtonData.SIT_IN = "sitIn";
ButtonData.CALL = "call";
ButtonData.POST_BB = "postBB";
ButtonData.POST_SB = "postSB";
ButtonData.CANCEL = "cancel";
ButtonData.CHECK = "check";
ButtonData.SHOW = "show";
ButtonData.MUCK = "muck";
ButtonData.OK = "ok";
ButtonData.IM_BACK = "imBack";
ButtonData.LEAVE = "leave";
ButtonData.CHECK_FOLD = "checkFold";
ButtonData.CALL_ANY = "callAny";
ButtonData.RAISE_ANY = "raiseAny";
ButtonData.BUY_IN = "buyIn";
ButtonData.RE_BUY = "reBuy";
ButtonData.JOIN_TOURNAMENT = "joinTournament";
ButtonData.LEAVE_TOURNAMENT = "leaveTournament";

/**
 * Get button.
 * @method getButton
 */
ButtonData.prototype.getButton = function() {
	return this.button;
}

/**
 * Get button string for this button.
 * @method getButtonString
 */
ButtonData.prototype.getButtonString = function() {
	return ButtonData.getButtonStringForId(this.button);
}

/**
 * Get value.
 * @method getValue
 */
ButtonData.prototype.getValue = function() {
	return this.value;
}

/**
 * Get button string for id.
 * @method getButtonStringForId
 * @static
 */
ButtonData.getButtonStringForId = function(b) {
	switch (b) {
		case ButtonData.FOLD:
			return "FOLD";

		case ButtonData.CALL:
			return "CALL";

		case ButtonData.RAISE:
			return "RAISE TO";

		case ButtonData.BET:
			return "BET";

		case ButtonData.SIT_OUT:
			return "SIT OUT";

		case ButtonData.POST_BB:
			return "POST BB";

		case ButtonData.POST_SB:
			return "POST SB";

		case ButtonData.SIT_IN:
			return "SIT IN";

		case ButtonData.CANCEL:
			return "CANCEL";

		case ButtonData.CHECK:
			return "CHECK";

		case ButtonData.SHOW:
			return "SHOW";

		case ButtonData.MUCK:
			return "MUCK";

		case ButtonData.OK:
			return "OK";

		case ButtonData.IM_BACK:
			return "I'M BACK";

		case ButtonData.LEAVE:
			return "LEAVE";

		case ButtonData.CHECK_FOLD:
			return "CHECK / FOLD";

		case ButtonData.CALL_ANY:
			return "CALL ANY";

		case ButtonData.RAISE_ANY:
			return "RAISE ANY";

		case ButtonData.RE_BUY:
			return "RE-BUY";

		case ButtonData.BUY_IN:
			return "BUY IN";
	}

	return "";
}

ButtonData.prototype.toString = function() {
	return "<ButtonData button=" + this.button + ", value=" + this.value + ">";
}

module.exports = ButtonData;
},{}],41:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Card data.
 * @class CardData
 */
function CardData(value) {
	this.value = value;
}

CardData.CARD_VALUE_STRINGS =
	["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"];

CardData.SUIT_STRINGS =
	["D", "C", "H", "S"];
CardData.LONG_SUIT_STRINGS =
	["Diamonds", "Clubs", "Hearts", "Spades"];

CardData.HIDDEN = -1;

/**
 * Does this CardData represent a show card?
 * If not it should be rendered with its backside.
 * @method isShown
 */
CardData.prototype.isShown = function() {
	return this.value >= 0;
}

/**
 * Get card value.
 * This value represents the rank of the card, but starts on 0.
 * @method getCardValue
 */
CardData.prototype.getCardValue = function() {
	return this.value % 13;
}

/**
 * Get card value string.
 * @method getCardValueString
 */
CardData.prototype.getCardValueString = function() {
	return CardData.CARD_VALUE_STRINGS[this.value % 13];
}

/**
 * Get suit index.
 * @method getSuitIndex
 */
CardData.prototype.getSuitIndex = function() {
	return Math.floor(this.value / 13);
}

/**
 * Get suit string.
 * @method getSuitString
 */
CardData.prototype.getSuitString = function() {
	return CardData.SUIT_STRINGS[this.getSuitIndex()];
}

/**
 * Get long suit string.
 * @method getLongSuitString
 */
CardData.prototype.getLongSuitString = function() {
	return CardData.LONG_SUIT_STRINGS[this.getSuitIndex()];
}

/**
 * Get color.
 * @method getColor
 */
CardData.prototype.getColor = function() {
	if (this.getSuitIndex() % 2 != 0)
		return "#000000";

	else
		return "#ff0000";
}

/**
 * To string.
 * @method toString
 */
CardData.prototype.toString = function() {
	if (this.value < 0)
		return "XX";

	//	return "<card " + this.getCardValueString() + this.getSuitString() + ">";
	return this.getCardValueString() + this.getSuitString();
}

/**
 * Get value of the card.
 * @method getValue
 */
CardData.prototype.getValue = function() {
	return this.value;
}

/**
 * Compare with respect to value. Not really useful except for debugging!
 * @method compareValue
 * @static
 */
CardData.compareValue = function(a, b) {
	if (!(a instanceof CardData) || !(b instanceof CardData))
		throw new Error("Not comparing card data");

	if (a.getValue() > b.getValue())
		return 1;

	if (a.getValue() < b.getValue())
		return -1;

	return 0;
}

/**
 * Compare with respect to card value.
 * @method compareCardValue
 * @static
 */
CardData.compareCardValue = function(a, b) {
	if (!(a instanceof CardData) || !(b instanceof CardData))
		throw new Error("Not comparing card data");

	if (a.getCardValue() > b.getCardValue())
		return 1;

	if (a.getCardValue() < b.getCardValue())
		return -1;

	return 0;
}

/**
 * Compare with respect to suit.
 * @method compareSuit
 * @static
 */
CardData.compareSuitIndex = function(a, b) {
	if (!(a instanceof CardData) || !(b instanceof CardData))
		throw new Error("Not comparing card data");

	if (a.getSuitIndex() > b.getSuitIndex())
		return 1;

	if (a.getSuitIndex() < b.getSuitIndex())
		return -1;

	return 0;
}

/**
 * Create a card data from a string.
 * @method fromString
 * @static
 */
CardData.fromString = function(s) {
	var i;

	var cardValue = -1;
	for (i = 0; i < CardData.CARD_VALUE_STRINGS.length; i++) {
		var cand = CardData.CARD_VALUE_STRINGS[i];

		if (s.substring(0, cand.length).toUpperCase() == cand)
			cardValue = i;
	}

	if (cardValue < 0)
		throw new Error("Not a valid card string: " + s);

	var suitString = s.substring(CardData.CARD_VALUE_STRINGS[cardValue].length);

	var suitIndex = -1;
	for (i = 0; i < CardData.SUIT_STRINGS.length; i++) {
		var cand = CardData.SUIT_STRINGS[i];

		if (suitString.toUpperCase() == cand)
			suitIndex = i;
	}

	if (suitIndex < 0)
		throw new Error("Not a valid card string: " + s);

	return new CardData(suitIndex * 13 + cardValue);
}

module.exports = CardData;
},{}],42:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when player made an action.
 * @class ActionMessage
 */
function ActionMessage(seatIndex, action) {
	this.seatIndex = seatIndex;
	this.action = action;
}

ActionMessage.TYPE = "action";

ActionMessage.FOLD = "fold";
ActionMessage.CALL = "call";
ActionMessage.RAISE = "raise";
ActionMessage.CHECK = "check";
ActionMessage.BET = "bet";
ActionMessage.MUCK = "muck";
ActionMessage.ANTE = "ante";

/**
 * Seat index.
 * @method getSeatIndex
 */
ActionMessage.prototype.getSeatIndex = function() {
	return this.seatIndex;
}

/**
 * Getter.
 * @method getAction
 */
ActionMessage.prototype.getAction = function() {
	return this.action;
}

/**
 * Un-serialize.
 * @method unserialize
 */
ActionMessage.prototype.unserialize = function(data) {
	this.seatIndex = data.seatIndex;
	this.action = data.action;
}

/**
 * Serialize message.
 * @method serialize
 */
ActionMessage.prototype.serialize = function() {
	return {
		seatIndex: this.seatIndex,
		action: this.action
	};
}

module.exports = ActionMessage;
},{}],43:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when player has placed a bet.
 * @class BetMessage
 */
function BetMessage(seatIndex, value) {
	this.seatIndex = seatIndex;
	this.value = value;
}

BetMessage.TYPE = "bet";

/**
 * Getter.
 * @method getSeatIndex
 */
BetMessage.prototype.getSeatIndex = function() {
	return this.seatIndex;
}

/**
 * Getter.
 * @method getValue
 */
BetMessage.prototype.getValue = function() {
	return this.value;
}

/**
 * Un-serialize.
 * @method unserialize
 */
BetMessage.prototype.unserialize = function(data) {
	this.seatIndex = data.seatIndex;
	this.value = data.value;
}

/**
 * Serialize message.
 * @method serialize
 */
BetMessage.prototype.serialize = function() {
	return {
		seatIndex: this.seatIndex,
		value: this.value
	};
}

module.exports = BetMessage;
},{}],44:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when bets should be placed in pot.
 * @class BetsToPotMessage
 */
function BetsToPotMessage() {
}

BetsToPotMessage.TYPE = "betsToPot";

/**
 * Un-serialize.
 * @method unserialize
 */
BetsToPotMessage.prototype.unserialize = function(data) {
}

/**
 * Serialize message.
 * @method serialize
 */
BetsToPotMessage.prototype.serialize = function() {
	return {};
}

module.exports = BetsToPotMessage;
},{}],45:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Sent when the user clicks a button, either in a dialog or
 * for a game action.
 * @class ButtonClickMessage
 */
function ButtonClickMessage(button, value) {
	this.button = button;
	this.value = value;

//	console.log("Creating button click message, value=" + value);
}

ButtonClickMessage.TYPE = "buttonClick";

/**
 * The the button that was pressed.
 * @method getButton
 */
ButtonClickMessage.prototype.getButton = function() {
	return this.button;
}

/**
 * Setter.
 * @method getValue
 */
ButtonClickMessage.prototype.getValue = function() {
	return this.value;
}

/**
 * Un-serialize.
 * @method unserialize
 */
ButtonClickMessage.prototype.unserialize = function(data) {
	this.button = data.button;
	this.value = data.value;
}

/**
 * Serialize message.
 * @method serialize
 */
ButtonClickMessage.prototype.serialize = function() {
	return {
		button: this.button,
		value: this.value
	};
}

module.exports = ButtonClickMessage;
},{}],46:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

var ButtonData = require("../data/ButtonData");

/**
 * Message sent when the client should show game action buttons,
 * FOLD, RAISE etc.
 * @class ButtonsMessage
 */
function ButtonsMessage() {
	this.buttons = [];
	this.sliderButtonIndex = 0;
	this.min = -1;
	this.max = -1;
}

ButtonsMessage.TYPE = "buttons";

/**
 * Get an array of ButtonData indicating which buttons to show.
 * @method getButtons
 */
ButtonsMessage.prototype.getButtons = function() {
	return this.buttons;
}

/**
 * Add a button to be sent.
 * @method addButton
 */
ButtonsMessage.prototype.addButton = function(button) {
	this.buttons.push(button);
}

/**
 * Un-serialize.
 * @method unserialize.
 */
ButtonsMessage.prototype.unserialize = function(data) {
	this.buttons = [];

	for (var i = 0; i < data.buttons.length; i++) {
		var button = data.buttons[i];
		var buttonData = new ButtonData(button.button, button.value);
		this.addButton(buttonData);
	}
	this.sliderButtonIndex = data.sliderButtonIndex;
	this.min = data.min;
	this.max = data.max;
}

/**
 * Serialize message.
 * @method serialize
 */
ButtonsMessage.prototype.serialize = function() {
	var buttons = [];

	for (var i = 0; i < this.buttons.length; i++) {
		var button = {};
		button.button = this.buttons[i].getButton();
		button.value = this.buttons[i].getValue();
		buttons.push(button);
	}

	return {
		buttons: buttons,
		sliderButtonIndex: this.sliderButtonIndex,
		min: this.min,
		max: this.max
	};
}

module.exports = ButtonsMessage;
},{"../data/ButtonData":40}],47:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when something has occurred in the chat.
 * @class ChatMessage
 */
function ChatMessage(user, text) {
	this.user = user;
	this.text = text;
}

ChatMessage.TYPE = "chat";

/**
 * Get text.
 * @method getText
 */
ChatMessage.prototype.getText = function() {
	return this.text;
}

/**
 * Get user.
 * @method getUser
 */
ChatMessage.prototype.getUser = function() {
	return this.user;
}

/**
 * Un-serialize.
 * @method unserialize
 */
ChatMessage.prototype.unserialize = function(data) {
	this.text = data.text;
	this.user = data.user;
}

/**
 * Serialize message.
 * @method serialize
 */
ChatMessage.prototype.serialize = function() {
	return {
		text: this.text,
		user: this.user
	};
}

module.exports = ChatMessage;
},{}],48:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Sent when player has checked a checkbox.
 * @class CheckboxMessage
 */
function CheckboxMessage(id, checked) {
	this.id = id;
	this.checked = checked;
}

CheckboxMessage.TYPE = "checkbox";

CheckboxMessage.AUTO_POST_BLINDS = "autoPostBlinds";
CheckboxMessage.AUTO_MUCK_LOSING = "autoMuckLosing";
CheckboxMessage.SITOUT_NEXT = "sitoutNext";

/**
 * Id of checkbox.
 * @method getId
 */
CheckboxMessage.prototype.getId = function() {
	return this.id;
}

/**
 * Getter.
 * @method getValue
 */
CheckboxMessage.prototype.getChecked = function() {
	return this.checked;
}

/**
 * Un-serialize.
 * @method unserialize
 */
CheckboxMessage.prototype.unserialize = function(data) {
	this.id = data.id;
	this.checked = data.checked;
}

/**
 * Serialize message.
 * @method serialize
 */
CheckboxMessage.prototype.serialize = function() {
	return {
		id: this.id,
		checked: this.checked
	};
}

module.exports = CheckboxMessage;
},{}],49:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * @class ClearMessage
 */
function ClearMessage(components) {
	if (!components)
		components = [];

	this.components = components;
}

ClearMessage.TYPE = "clear";

ClearMessage.CARDS = "cards";
ClearMessage.BETS = "bets";
ClearMessage.POT = "pot";
ClearMessage.CHAT = "chat";

/**
 * Getter.
 * @method getComponents
 */
ClearMessage.prototype.getComponents = function() {
	return this.components;
}

/**
 * Un-serialize.
 * @method unserialize
 */
ClearMessage.prototype.unserialize = function(data) {
	this.components = data.components;
}

/**
 * Serialize message.
 * @method serialize
 */
ClearMessage.prototype.serialize = function() {
	return {
		components: this.components
	};
}

module.exports = ClearMessage;
},{}],50:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

var CardData = require("../data/CardData");

/**
 * Show community cards.
 * @class CommunityCardsMessage
 */
function CommunityCardsMessage(cards) {
	if (!cards)
		cards = [];

	this.animate = false;
	this.cards = cards;
	this.firstIndex = 0;
}

CommunityCardsMessage.TYPE = "communityCards";

/**
 * Animation or not?
 * @method setAnimate
 */
CommunityCardsMessage.prototype.setAnimate = function(value) {
	return this.animate = value;
}

/**
 * Set first index.
 * @method setFirstIndex
 */
CommunityCardsMessage.prototype.setFirstIndex = function(value) {
	return this.firstIndex = value;
}

/**
 * Add card.
 * @method addCard
 */
CommunityCardsMessage.prototype.addCard = function(c) {
	this.cards.push(c);
}

/**
 * Get card data.
 * @method getCards
 */
CommunityCardsMessage.prototype.getCards = function() {
	return this.cards;
}

/**
 * Get the index of the first card to be shown in the sequence.
 * @method getFirstIndex
 */
CommunityCardsMessage.prototype.getFirstIndex = function() {
	return this.firstIndex;
}

/**
 * Un-serialize.
 * @method unserialize.
 */
CommunityCardsMessage.prototype.unserialize = function(data) {
	var i;

	this.animate = data.animate;
	this.firstIndex = parseInt(data.firstIndex);
	this.cards = [];

	for (i = 0; i < data.cards.length; i++)
		this.cards.push(new CardData(data.cards[i]));
}

/**
 * Serialize message.
 * @method serialize
 */
CommunityCardsMessage.prototype.serialize = function() {
	var cards = [];

	for (i = 0; i < this.cards.length; i++)
		cards.push(this.cards[i].getValue());

	return {
		animate: this.animate,
		firstIndex: this.firstIndex,
		cards: cards
	};
}

module.exports = CommunityCardsMessage;
},{"../data/CardData":41}],51:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * @class DealerButtonMessage
 */
function DealerButtonMessage(seatIndex, animate) {
	this.seatIndex = seatIndex;
	this.animate = animate;
}

DealerButtonMessage.TYPE = "dealerButton";

/**
 * Getter.
 * @method getSeatIndex
 */
DealerButtonMessage.prototype.getSeatIndex = function() {
	return this.seatIndex;
}

/**
 * Getter.
 * @method getAnimate
 */
DealerButtonMessage.prototype.getAnimate = function() {
	return this.animate;
}

/**
 * Un-serialize.
 * @method unserialize
 */
DealerButtonMessage.prototype.unserialize = function(data) {
	this.seatIndex = data.seatIndex;
	this.animate = data.animate;
}

/**
 * Serialize message.
 * @method serialize
 */
DealerButtonMessage.prototype.serialize = function() {
	return {
		seatIndex: this.seatIndex,
		animate: this.animate
	};
}

module.exports = DealerButtonMessage;
},{}],52:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * @class DelayMessage
 */
function DelayMessage(delay) {
	this.delay = delay;
}

DelayMessage.TYPE = "delay";

/**
 * Getter.
 * @method getDelay
 */
DelayMessage.prototype.getDelay = function() {
	return this.delay;
}

/**
 * Un-serialize.
 * @method unserialize
 */
DelayMessage.prototype.unserialize = function(data) {
	this.delay = data.delay;
}

/**
 * Serialize message.
 * @method serialize
 */
DelayMessage.prototype.serialize = function() {
	return {
		delay: this.delay
	};
}

module.exports = DelayMessage;
},{}],53:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received table should fade.
 * @class FadeTableMessage
 */
function FadeTableMessage(visible, direction) {
	this.visible = visible;
	this.direction = direction;
}

FadeTableMessage.TYPE = "fadeTable";

/**
 * Getter.
 * @method getVisible
 */
FadeTableMessage.prototype.getVisible = function() {
	return this.visible;
}

/**
 * Getter.
 * @method getDirection
 */
FadeTableMessage.prototype.getDirection = function() {
	return this.direction;
}

/**
 * Un-serialize.
 * @method unserialize
 */
FadeTableMessage.prototype.unserialize = function(data) {
	this.visible = data.visible;
	this.direction = data.direction;
}

/**
 * Serialize message.
 * @method serialize
 */
FadeTableMessage.prototype.serialize = function() {
	return {
		visible: this.visible,
		direction: this.direction
	};
}

module.exports = FadeTableMessage;
},{}],54:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received player has folded.
 * @class FoldCardsMessage
 */
function FoldCardsMessage(seatIndex) {
	this.seatIndex = seatIndex;
}

FoldCardsMessage.TYPE = "foldCards";

/**
 * Getter.
 * @method getSeatIndex
 */
FoldCardsMessage.prototype.getSeatIndex = function() {
	return this.seatIndex;
}

/**
 * Un-serialize.
 * @method unserialize
 */
FoldCardsMessage.prototype.unserialize = function(data) {
	this.seatIndex = data.seatIndex;
}

/**
 * Serialize message.
 * @method serialize
 */
FoldCardsMessage.prototype.serialize = function() {
	return {
		seatIndex: this.seatIndex
	};
}

module.exports = FoldCardsMessage;
},{}],55:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when ?.
 * @class HandInfoMessage
 */
function HandInfoMessage(text, countdown) {
	this.text = text;
	this.countdown = countdown;
}

HandInfoMessage.TYPE = "handInfo";

/**
 * Getter.
 * @method getSeatIndex
 */
HandInfoMessage.prototype.getText = function() {
	return this.text;
}

/**
 * Getter.
 * @method getValue
 */
HandInfoMessage.prototype.getCountdown = function() {
	return this.countdown;
}

/**
 * Un-serialize.
 * @method unserialize
 */
HandInfoMessage.prototype.unserialize = function(data) {
	this.text = data.text;
	this.countdown = data.countdown;
}

/**
 * Serialize message.
 * @method serialize
 */
HandInfoMessage.prototype.serialize = function() {
	return {
		text: this.text,
		countdown: this.countdown
	};
}

module.exports = HandInfoMessage;
},{}],56:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * @class InitMessage
 */
function InitMessage(token) {
	this.token = token;
	this.tableId = null;
	this.viewCase = null;
	this.tournamentId = null;
}

InitMessage.TYPE = "init";

/**
 * get token.
 * @method getToken
 */
InitMessage.prototype.getToken = function() {
	return this.token;
}

/**
 * Set table id.
 * @method setTableId
 */
InitMessage.prototype.setTableId = function(id) {
	this.tableId = id;
}

/**
 * Get table id.
 * @method getTableId
 */
InitMessage.prototype.getTableId = function() {
	return this.tableId;
}

/**
 * Set table id.
 * @method setTournamentId
 */
InitMessage.prototype.setTournamentId = function(id) {
	this.tournamentId = id;
}

/**
 * Get table id.
 * @method getTournamentId
 */
InitMessage.prototype.getTournamentId = function() {
	return this.tournamentId;
}

/**
 * Set view case.
 * @method setTableId
 */
InitMessage.prototype.setViewCase = function(viewCase) {
	this.viewCase = viewCase;
}

/**
 * Get view case.
 * @method getTableId
 */
InitMessage.prototype.getViewCase = function() {
	return this.viewCase;
}

/**
 * Un-serialize.
 * @method unserialize.
 */
InitMessage.prototype.unserialize = function(data) {
	this.token = data.token;
	this.tableId = data.tableId;
	this.viewCase = data.viewCase;
	this.tournamentId = data.tournamentId;
}

/**
 * Serialize message.
 * @method serialize
 */
InitMessage.prototype.serialize = function() {
	return {
		token: this.token,
		tableId: this.tableId,
		viewCase: this.viewCase,
		tournamentId: this.tournamentId
	};
}

module.exports = InitMessage;
},{}],57:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when interface state has changed.
 * @class InterfaceStateMessage
 */
function InterfaceStateMessage(visibleButtons) {
	if (!visibleButtons)
		visibleButtons = [];

	this.visibleButtons = visibleButtons;
}

InterfaceStateMessage.TYPE = "interfaceState";

/**
 * Getter.
 * @method getVisibleButtons
 */
InterfaceStateMessage.prototype.getVisibleButtons = function() {
	return this.visibleButtons;
}

/**
 * Add a button to be shown.
 * @method addVisibleButton
 */
InterfaceStateMessage.prototype.addVisibleButton=function(buttonId) {
	this.visibleButtons.push(buttonId);
}

/**
 * Un-serialize.
 * @method unserialize
 */
InterfaceStateMessage.prototype.unserialize = function(data) {
	this.visibleButtons = data.visibleButtons;
}

/**
 * Serialize message.
 * @method serialize
 */
InterfaceStateMessage.prototype.serialize = function() {
	return {
		visibleButtons: this.visibleButtons
	};
}

module.exports = InterfaceStateMessage;
},{}],58:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when player has placed a bet.
 * @class PayOutMessage
 */
function PayOutMessage() {
	this.values = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
}

PayOutMessage.TYPE = "payOut";

/**
 * Getter.
 * @method getValues
 */
PayOutMessage.prototype.getValues = function() {
	return this.values;
}

/**
 * Set value at.
 * @method setValueAt
 */
PayOutMessage.prototype.setValueAt = function(seatIndex, value) {
	this.values[seatIndex] = value;
}

/**
 * Un-serialize.
 * @method unserialize
 */
PayOutMessage.prototype.unserialize = function(data) {
	for (var i = 0; i < data.values.length; i++) {
		this.values[i] = data.values[i];
	}
}

/**
 * Serialize message.
 * @method serialize
 */
PayOutMessage.prototype.serialize = function() {
	return {
		values: this.values
	};
}

module.exports = PayOutMessage;
},{}],59:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

var CardData = require("../data/CardData");

/**
 * Show pocket cards.
 * @class PocketCardsMessage
 */
function PocketCardsMessage(seatIndex) {
	this.animate = false;
	this.cards = [];
	this.firstIndex = 0;
	this.seatIndex = seatIndex;
}

PocketCardsMessage.TYPE = "pocketCards";

/**
 * Animation?
 * @method setAnimate
 */
PocketCardsMessage.prototype.setAnimate = function(value) {
	this.animate = value;
}

/**
 * Set first index.
 * @method setFirstIndex
 */
PocketCardsMessage.prototype.setFirstIndex = function(index) {
	this.firstIndex = index;
}

/**
 * Get array of CardData.
 * @method getCards
 */
PocketCardsMessage.prototype.getCards = function() {
	return this.cards;
}

/**
 * Add a card.
 * @method addCard
 */
PocketCardsMessage.prototype.addCard = function(c) {
	this.cards.push(c);
}

/**
 * Get first index.
 * @method getFirstIndex
 */
PocketCardsMessage.prototype.getFirstIndex = function() {
	return this.firstIndex;
}

/**
 * Get seat index.
 * @method getSeatIndex
 */
PocketCardsMessage.prototype.getSeatIndex = function() {
	return this.seatIndex;
}

/**
 * Un-serialize.
 * @method unserialize.
 */
PocketCardsMessage.prototype.unserialize = function(data) {
	var i;

	this.animate = data.animate;
	this.firstIndex = parseInt(data.firstIndex);
	this.cards = [];
	this.seatIndex = data.seatIndex;

	for (i = 0; i < data.cards.length; i++)
		this.cards.push(new CardData(data.cards[i]));
}

/**
 * Serialize message.
 * @method serialize
 */
PocketCardsMessage.prototype.serialize = function() {
	var cards = [];

	for (i = 0; i < this.cards.length; i++)
		cards.push(this.cards[i].getValue());

	return {
		animate: this.animate,
		firstIndex: this.firstIndex,
		cards: cards,
		seatIndex: this.seatIndex
	};
}

module.exports = PocketCardsMessage;
},{"../data/CardData":41}],60:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when player pot has changed.
 * @class PotMessage
 */
function PotMessage(values) {
	this.values = values == null ? new Array() : values;
}

PotMessage.TYPE = "pot";

/**
 * Getter.
 * @method getValues
 */
PotMessage.prototype.getValues = function() {
	return this.values;
}

/**
 * Un-serialize.
 * @method unserialize
 */
PotMessage.prototype.unserialize = function(data) {
	this.values = data.values;
}

/**
 * Serialize message.
 * @method serialize
 */
PotMessage.prototype.serialize = function() {
	return {
		values: this.values
	};
}

module.exports = PotMessage;
},{}],61:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when Pre tournament info message is dispatched.
 * @class PreTournamentInfoMessage
 */
function PreTournamentInfoMessage(text, countdown) {
	this.text = text;
	this.countdown = countdown;
}

PreTournamentInfoMessage.TYPE = "preTournamentInfo";

/**
 * Getter.
 * @method getText
 */
PreTournamentInfoMessage.prototype.getText = function() {
	return this.text;
}

/**
 * Getter.
 * @method getCountdown
 */
PreTournamentInfoMessage.prototype.getCountdown = function() {
	return this.countdown;
}

/**
 * Un-serialize.
 * @method unserialize
 */
PreTournamentInfoMessage.prototype.unserialize = function(data) {
	this.text = data.text;
	this.countdown = data.countdown;
}

/**
 * Serialize message.
 * @method serialize
 */
PreTournamentInfoMessage.prototype.serialize = function() {
	if (this.countdown < 0)
		this.countdown = 0;

	return {
		text: this.text,
		countdown: this.countdown
	};
}

module.exports = PreTournamentInfoMessage;
},{}],62:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when ?.
 * @class PresetButtonClickMessage
 */
function PresetButtonClickMessage(button, value) {
	if (!value)
		value = null;

	this.button = button;
	this.value = value;
}

PresetButtonClickMessage.TYPE = "presetButtonClick";

/**
 * Getter.
 * @method getButton
 */
PresetButtonClickMessage.prototype.getButton = function() {
	return this.button;
}

/**
 * Getter.
 * @method getValue
 */
PresetButtonClickMessage.prototype.getValue = function() {
	return this.value;
}

/**
 * Un-serialize.
 * @method unserialize
 */
PresetButtonClickMessage.prototype.unserialize = function(data) {
	this.button = data.button;
	this.value = data.value;
}

/**
 * Serialize message.
 * @method serialize
 */
PresetButtonClickMessage.prototype.serialize = function() {
	return {
		button: this.button,
		value: this.value
	};
}

module.exports = PresetButtonClickMessage;
},{}],63:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

var ButtonData = require("../data/ButtonData");

/**
 * Received when ?.
 * @class PresetButtonsMessage
 */
function PresetButtonsMessage() {
	this.buttons = new Array(7);
	this.current = null;
}

PresetButtonsMessage.TYPE = "presetButtons";

/**
 * Getter.
 * @method getButtons
 */
PresetButtonsMessage.prototype.getButtons = function() {
	return this.buttons;
}

/**
 * Getter.
 * @method getCurrent
 */
PresetButtonsMessage.prototype.getCurrent = function() {
	return this.current;
}

/**
 * Set buton data.
 * @method
 */
PresetButtonsMessage.prototype.setButtonDataAt = function(index, buttonData) {
	this.buttons[index] = buttonData;
}

/**
 * Un-serialize.
 * @method unserialize
 */
PresetButtonsMessage.prototype.unserialize = function(data) {
	this.current = data.current;

	this.buttons = new Array();

	for (var i = 0; i < data.buttons.length; i++) {
		var button = data.buttons[i];
		var buttonData = null;

		if (button != null) {
			buttonData = new ButtonData(button.button, button.value);
		}

		this.buttons.push(buttonData);
	}
}

/**
 * Serialize message.
 * @method serialize
 */
PresetButtonsMessage.prototype.serialize = function() {
	var object = {
		buttons: [],
		current: this.current
	};

	for (var i = 0; i < this.buttons.length; i++) {
		var buttonData = this.buttons[i];
		if (buttonData != null)
			object.buttons.push({
				button: buttonData.button,
				value: buttonData.value
			});

		else
			object.buttons.push(null);
	}

	return object;
}

module.exports = PresetButtonsMessage;
},{"../data/ButtonData":40}],64:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Message indicating that the user has clicked a seat.
 * @class SeatClickMessage
 */
function SeatClickMessage(seatIndex) {
	this.seatIndex=seatIndex;
}

SeatClickMessage.TYPE = "seatClick";

/**
 * Getter.
 * @method getSeatIndex
 */
SeatClickMessage.prototype.getSeatIndex = function() {
	return this.seatIndex;
}

/**
 * Un-serialize.
 * @method unserialize.
 */
SeatClickMessage.prototype.unserialize = function(data) {
	this.seatIndex = data.seatIndex;
}

/**
 * Serialize message.
 * @method serialize
 */
SeatClickMessage.prototype.serialize = function() {
	return {
		seatIndex: this.seatIndex,
	};
}

module.exports = SeatClickMessage;
},{}],65:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Show username and chips on seat.
 * @class SeatInfoMessage
 */
function SeatInfoMessage(seatIndex) {
	this.seatIndex = seatIndex;
	this.active = true;
	this.sitout = false;
	this.name = "";
	this.chips = "";
}

SeatInfoMessage.TYPE = "seatInfo";

/**
 * Getter.
 * @method getSeatIndex
 */
SeatInfoMessage.prototype.getSeatIndex = function() {
	return this.seatIndex;
}

/**
 * Getter.
 * @method getName
 */
SeatInfoMessage.prototype.getName = function() {
	return this.name;
}

/**
 * Getter.
 * @method getChips
 */
SeatInfoMessage.prototype.getChips = function() {
	return this.chips;
}

/**
 * Getter.
 * @method isSitout
 */
SeatInfoMessage.prototype.isSitout = function() {
	return this.sitout;
}

/**
 * Getter.
 * @method isActive
 */
SeatInfoMessage.prototype.isActive = function() {
	return this.active;
}

/**
 * Setter.
 * @method setActive
 */
SeatInfoMessage.prototype.setActive = function(v) {
	this.active = v;
}

/**
 * Set sitout.
 * @method setSitout
 */
SeatInfoMessage.prototype.setSitout = function(v) {
	this.sitout = v;
}

/**
 * Setter.
 * @method setName
 */
SeatInfoMessage.prototype.setName = function(v) {
	this.name = v;
}

/**
 * Setter.
 * @method setChips
 */
SeatInfoMessage.prototype.setChips = function(v) {
	this.chips = v;
}

/**
 * Un-serialize.
 * @method unserialize
 */
SeatInfoMessage.prototype.unserialize = function(data) {
	this.seatIndex = data.seatIndex;
	this.name = data.name;
	this.chips = data.chips;
	this.sitout = data.sitout;
	this.active = data.active;
}

/**
 * Serialize message.
 * @method serialize
 */
SeatInfoMessage.prototype.serialize = function() {
	return {
		seatIndex: this.seatIndex,
		name: this.name,
		chips: this.chips,
		sitout: this.sitout,
		active: this.active
	};
}

module.exports = SeatInfoMessage;
},{}],66:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Show dialog, for e.g. buy in.
 * @class ShowDialogMessage
 */
function ShowDialogMessage() {
	this.text = "";
	this.buttons = [];
	this.defaultValue = null;
}

ShowDialogMessage.TYPE = "showDialog";

/**
 * Add a button to the dialog.
 * @method addButton
 */
ShowDialogMessage.prototype.addButton = function(button) {
	this.buttons.push(button);
}

/**
 * Get text of the dialog.
 * @method getText
 */
ShowDialogMessage.prototype.getText = function() {
	return this.text;
}

/**
 * Get array of ButtonData to be shown in the dialog.
 * @method getButtons
 */
ShowDialogMessage.prototype.getButtons = function() {
	return this.buttons;
}

/**
 * Get default value.
 * @method getButtons
 */
ShowDialogMessage.prototype.getDefaultValue = function() {
	return this.defaultValue;
}

/**
 * Set default value.
 * @method setDefaultValue
 */
ShowDialogMessage.prototype.setDefaultValue = function(v) {
	this.defaultValue=v;
}

/**
 * Set text in the dialog.
 * @method setText
 */
ShowDialogMessage.prototype.setText = function(text) {
	this.text = text;
}

/**
 * Un-serialize.
 * @method unserialize.
 */
ShowDialogMessage.prototype.unserialize = function(data) {
	this.text = data.text;
	this.buttons = data.buttons;
	this.defaultValue = data.defaultValue;
}

/**
 * Serialize message.
 * @method serialize
 */
ShowDialogMessage.prototype.serialize = function() {
	return {
		text: this.text,
		buttons: this.buttons,
		defaultValue: this.defaultValue
	};
}

module.exports = ShowDialogMessage;
},{}],67:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * @class StateCompleteMessage
 */
function StateCompleteMessage() {}

StateCompleteMessage.TYPE = "stateComplete";

/**
 * Un-serialize.
 * @method unserialize.
 */
StateCompleteMessage.prototype.unserialize = function(data) {}

/**
 * Serialize message.
 * @method serialize
 */
StateCompleteMessage.prototype.serialize = function() {
	return {};
}

module.exports = StateCompleteMessage;
},{}],68:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when table button clicked.
 * @class TableButtonClickMessage
 */
function TableButtonClickMessage(tableIndex) {
	this.tableIndex = tableIndex;
}

TableButtonClickMessage.TYPE = "tableButtonClick";

/**
 * Getter.
 * @method getTableIndex
 */
TableButtonClickMessage.prototype.getTableIndex = function() {
	return this.tableIndex;
}

/**
 * Un-serialize.
 * @method unserialize
 */
TableButtonClickMessage.prototype.unserialize = function(data) {
	this.tableIndex = data.tableIndex;
}

/**
 * Serialize message.
 * @method serialize
 */
TableButtonClickMessage.prototype.serialize = function() {
	return {
		tableIndex: this.tableIndex
	};
}

module.exports = TableButtonClickMessage;
},{}],69:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when ?.
 * @class TableButtonsMessage
 */
function TableButtonsMessage() {
	this.enabled = new Array();
	this.currentIndex = -1;
	this.playerIndex = -1;
	this.infoLink = "";
}

TableButtonsMessage.TYPE = "tableButtons";

/**
 * Getter.
 * @method getEnabled
 */
TableButtonsMessage.prototype.getEnabled = function() {
	return this.enabled;
}

/**
 * Getter.
 * @method getCurrentIndex
 */
TableButtonsMessage.prototype.getCurrentIndex = function() {
	return this.currentIndex;
}

/**
 * Getter.
 * @method getPlayerIndex
 */
TableButtonsMessage.prototype.getPlayerIndex = function() {
	return this.playerIndex;
}

/**
 * Getter.
 * @method getInfoLink
 */
TableButtonsMessage.prototype.getInfoLink = function() {
	return this.infoLink;
}

/**
 * Un-serialize.
 * @method unserialize
 */
TableButtonsMessage.prototype.unserialize = function(data) {
	this.playerIndex = data.playerIndex;
	this.currentIndex = data.currentIndex;
	this.infoLink = data.infoLink;

	this.enabled = new Array();
	for(var i = 0; i < data.enabled.length; i++)
		this.enabled.push(data.enabled[i]);
}

/**
 * Serialize message.
 * @method serialize
 */
TableButtonsMessage.prototype.serialize = function() {
	var object = {
		currentIndex: this.currentIndex,
		playerIndex: this.playerIndex,
		enabled: [],
		infoLink: this.infoLink
	};

	for(var i = 0; i < this.enabled.length; i++)
		object.enabled.push(this.enabled[i]);

	return object;
}

module.exports = TableButtonsMessage;
},{}],70:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Set the big text that calls for user action,
 * such as "Welcome, please take a seat!".
 * @class TableInfoMessage
 */
function TableInfoMessage(text, countdown) {
	this.countdown = countdown;
	this.text = text;
	this.showJoinButton = false;
	this.showLeaveButton = false;
	this.infoLink = null;
	this.infoLinkText = null;
}

TableInfoMessage.TYPE = "tableInfo";

/**
 * Getter.
 * @method getCountdown
 */
TableInfoMessage.prototype.getCountdown = function() {
	return this.countdown;
}

/**
 * Getter.
 * @method getText
 */
TableInfoMessage.prototype.getText = function() {
	return this.text;
}

/**
 * Getter.
 * @method getShowJoinButton
 */
TableInfoMessage.prototype.getShowJoinButton = function() {
	return this.showJoinButton;
}

/**
 * Getter.
 * @method getShowLeaveButton
 */
TableInfoMessage.prototype.getShowLeaveButton = function() {
	return this.showLeaveButton;
}

/**
 * Setter.
 * @method getShowJoinButton
 */
TableInfoMessage.prototype.setShowJoinButton = function(value) {
	this.showJoinButton = value;
}

/**
 * Setter.
 * @method getShowLeaveButton
 */
TableInfoMessage.prototype.setShowLeaveButton = function(value) {
	this.showLeaveButton = value;
}

/**
 * Getter.
 * @method getInfoLink
 */
TableInfoMessage.prototype.getInfoLink = function() {
	return this.infoLink;
}

/**
 * Getter.
 * @method getInfoLinkText
 */
TableInfoMessage.prototype.getInfoLinkText = function() {
	return this.infoLinkText;
}

/**
 * Un-serialize.
 * @method unserialize
 */
TableInfoMessage.prototype.unserialize = function(data) {
	if (data.text != null)
		this.text = data.text;

	if (data.countdown != null)
		this.countdown = data.countdown;

	if (data.showJoinButton != null)
		this.showJoinButton = data.showJoinButton;

	if (data.showLeaveButton != null)
		this.showLeaveButton = data.showLeaveButton;

	if (data.infoLink != null)
		this.infoLink = data.infoLink;

	if (data.infoLinkText != null)
		this.infoLinkText = data.infoLinkText;
}

/**
 * Serialize message.
 * @method serialize
 */
TableInfoMessage.prototype.serialize = function() {
	return {
		text: this.text,
		countdown: this.countdown,
		showJoinButton: this.showJoinButton,
		showLeaveButton: this.showLeaveButton,
		infoLink: this.infoLink,
		infoLinkText: this.infoLinkText
	};
}

module.exports = TableInfoMessage;
},{}],71:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when ?.
 * @class TestCaseRequestMessage
 */
function TestCaseRequestMessage(testCase) {
	this.testCase = testCase;
}

TestCaseRequestMessage.TYPE = "testCaseRequest";

/**
 * Getter.
 * @method getTestCase
 */
TestCaseRequestMessage.prototype.getTestCase = function() {
	return this.testCase;
}

/**
 * Un-serialize.
 * @method unserialize
 */
TestCaseRequestMessage.prototype.unserialize = function(data) {
	this.testCase = data.testCase;
}

/**
 * Serialize message.
 * @method serialize
 */
TestCaseRequestMessage.prototype.serialize = function() {
	return {
		testCase: this.testCase
	};
}

module.exports = TestCaseRequestMessage;
},{}],72:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when ?.
 * @class TimerMessage
 */
function TimerMessage() {
	this.seatIndex = -1;
	this.totalTime = -1;
	this.timeLeft = -1;
}

TimerMessage.TYPE = "timer";

/**
 * Getter.
 * @method getSeatIndex
 */
TimerMessage.prototype.getSeatIndex = function() {
	return this.seatIndex;
}

/**
 * Getter.
 * @method getTotalTime
 */
TimerMessage.prototype.getTotalTime = function() {
	return this.totalTime;
}

/**
 * Getter.
 * @method getTimeLeft
 */
TimerMessage.prototype.getTimeLeft = function() {
	return this.timeLeft;
}

/**
 * Setter.
 * @method setSeatIndex
 */
TimerMessage.prototype.setSeatIndex = function(value) {
	this.seatIndex = value;
}

/**
 * Setter.
 * @method setTotalTime
 */
TimerMessage.prototype.setTotalTime = function(value) {
	this.totalTime = value;
}

/**
 * Setter.
 * @method setTimeLeft
 */
TimerMessage.prototype.setTimeLeft = function(value) {
	this.timeLeft = value;
}

/**
 * Un-serialize.
 * @method unserialize
 */
TimerMessage.prototype.unserialize = function(data) {
	this.seatIndex = data.seatIndex;
	this.totalTime = data.totalTime;
	this.timeLeft = data.timeLeft;
}

/**
 * Serialize message.
 * @method serialize
 */
TimerMessage.prototype.serialize = function() {
	return {
		seatIndex: this.seatIndex,
		totalTime: this.totalTime,
		timeLeft: this.timeLeft
	};
}

module.exports = TimerMessage;
},{}],73:[function(require,module,exports){
/**
 * Protocol.
 * @module proto
 */

/**
 * Received when tournament result message is dispatched.
 * @class TournamentResultMessage
 */
function TournamentResultMessage(text, rightColumnText) {
	this.text = text;
	this.rightColumnText = rightColumnText;
}

TournamentResultMessage.TYPE = "tournamentResult";

/**
 * Getter.
 * @method getText
 */
TournamentResultMessage.prototype.getText = function() {
	return this.text;
}

/**
 * Getter.
 * @method getRightColumnText
 */
TournamentResultMessage.prototype.getRightColumnText = function() {
	return this.rightColumnText;
}

/**
 * Un-serialize.
 * @method unserialize
 */
TournamentResultMessage.prototype.unserialize = function(data) {
	this.text = data.text;
	this.rightColumnText = data.rightColumnText;
}

/**
 * Serialize message.
 * @method serialize
 */
TournamentResultMessage.prototype.serialize = function() {
	return {
		text: this.text,
		rightColumnText: this.rightColumnText
	};
}

module.exports = TournamentResultMessage;
},{}],74:[function(require,module,exports){
/**
 * Utilities.
 * @module utils
 */

var PIXI = require("pixi.js");
var EventDispatcher = require("yaed");
var Button = require("./Button");
var inherits = require("inherits");

/**
 * Checkbox.
 * @class Checkbox
 */
function Checkbox(background, tick) {
	PIXI.DisplayObjectContainer.call(this);

	this.button = new Button(background);
	this.addChild(this.button);

	this.check = tick;
	this.addChild(this.check);

	this.button.addEventListener("click", this.onButtonClick, this);

	this.setChecked(false);
}

inherits(Checkbox, PIXI.DisplayObjectContainer);
EventDispatcher.init(Checkbox);

/**
 * Button click.
 * @method onButtonClick
 * @private
 */
Checkbox.prototype.onButtonClick = function() {
	this.check.visible = !this.check.visible;

	this.dispatchEvent("change");
}

/**
 * Setter.
 * @method setChecked
 */
Checkbox.prototype.setChecked = function(value) {
	this.check.visible = value;
	return value;
}

/**
 * Getter.
 * @method getChecked
 */
Checkbox.prototype.getChecked = function() {
	return this.check.visible;
}


module.exports = Checkbox;
},{"./Button":"Button","inherits":7,"pixi.js":"pixi.js","yaed":11}],75:[function(require,module,exports){
/**
 * Utilities.
 * @module utils
 */

var Thenable = require("tinp");
var inherits = require("inherits");
var EventDispatcher = require("yaed");
var HttpRequest = require("../utils/HttpRequest");

/**
 * A "connection" that loads its messages from a json file rather than
 * actually connecting.
 * @class MessageRequestConnection
 */
function MessageRequestConnection() {
	EventDispatcher.call(this);
	this.test = 1;
}

inherits(MessageRequestConnection, EventDispatcher);

MessageRequestConnection.CONNECT = "connect";
MessageRequestConnection.MESSAGE = "message";
MessageRequestConnection.CLOSE = "close";

/**
 * Connect.
 * @method connect
 */
MessageRequestConnection.prototype.connect = function(url) {
	var request = new HttpRequest(url);

	request.send().then(
		this.onRequestComplete.bind(this),
		this.onRequestError.bind(this)
	);
}

/**
 * @method onRequestComplete
 * @private
 */
MessageRequestConnection.prototype.onRequestComplete = function(body) {
	this.trigger(MessageRequestConnection.CONNECT);

	var lines = body.toString().split("\n");

	//console.log("MessageRequestConnection: lines="+lines.length);

	for (var i = 0; i < lines.length; i++) {
		var line = lines[i];

		//console.log("line: "+line);

		if (line.length && line[0] != "/") {
			console.log("trigger message: " + line);
			this.trigger({
				type: MessageRequestConnection.MESSAGE,
				message: JSON.parse(line)
			});
		}
	}
}

/**
 * @method onRequestComplete
 * @private
 */
MessageRequestConnection.prototype.onRequestError = function(e) {
	console.log("error in request connection");
	console.log(e);
	this.trigger(MessageRequestConnection.CLOSE);
}

/**
 * Send.
 * @method send
 */
MessageRequestConnection.prototype.send = function(m) {
	console.log('ignoring "send" for MessageRequestConnection');
}

module.exports = MessageRequestConnection;
},{"../utils/HttpRequest":"HttpRequest","inherits":7,"tinp":"tinp","yaed":11}],76:[function(require,module,exports){
/**
 * Utilities.
 * @module utils
 */

var EventDispatcher = require("yaed");
var Thenable = require("tinp");
var inherits = require("inherits");

/**
 * Message connection in a browser.
 * @class MessageWebSocketConnection
 */
function MessageWebSocketConnection() {
	EventDispatcher.call(this);
	this.test = 1;
}

inherits(MessageWebSocketConnection, EventDispatcher);

MessageWebSocketConnection.CONNECT = "connect";
MessageWebSocketConnection.MESSAGE = "message";
MessageWebSocketConnection.CLOSE = "close";

/**
 * Connect.
 * @method connect
 */
MessageWebSocketConnection.prototype.connect = function(url) {
	this.webSocket = new WebSocket(url);

	this.webSocket.onopen = this.onWebSocketOpen.bind(this);
	this.webSocket.onmessage = this.onWebSocketMessage.bind(this);
	this.webSocket.onclose = this.onWebSocketClose.bind(this);
	this.webSocket.onerror = this.onWebSocketError.bind(this);
}

/**
 * Send.
 * @method send
 */
MessageWebSocketConnection.prototype.send = function(m) {
	this.webSocket.send(JSON.stringify(m));
}

/**
 * Web socket open.
 * @method onWebSocketOpen
 * @private
 */
MessageWebSocketConnection.prototype.onWebSocketOpen = function() {
	this.trigger(MessageWebSocketConnection.CONNECT);
}

/**
 * Web socket message.
 * @method onWebSocketMessage
 * @private
 */
MessageWebSocketConnection.prototype.onWebSocketMessage = function(e) {
	var message = JSON.parse(e.data);

	this.trigger({
		type: MessageWebSocketConnection.MESSAGE,
		message: message
	});
}

/**
 * Web socket close.
 * @method onWebSocketClose
 * @private
 */
MessageWebSocketConnection.prototype.onWebSocketClose = function() {
	console.log("web socket close, ws=" + this.webSocket + " this=" + this.test);
	this.webSocket.close();
	this.clearWebSocket();

	this.trigger(MessageWebSocketConnection.CLOSE);
}

/**
 * Web socket error.
 * @method onWebSocketError
 * @private
 */
MessageWebSocketConnection.prototype.onWebSocketError = function() {
	console.log("web socket error, ws=" + this.webSocket + " this=" + this.test);

	this.webSocket.close();
	this.clearWebSocket();

	this.trigger(MessageWebSocketConnection.CLOSE);
}

/**
 * Clear the current web socket.
 * @method clearWebSocket
 */
MessageWebSocketConnection.prototype.clearWebSocket = function() {
	this.webSocket.onopen = null;
	this.webSocket.onmessage = null;
	this.webSocket.onclose = null;
	this.webSocket.onerror = null;

	this.webSocket = null;
}

module.exports = MessageWebSocketConnection;
},{"inherits":7,"tinp":"tinp","yaed":11}],77:[function(require,module,exports){
/**
 * Utilities.
 * @module utils
 */

var PIXI = require("pixi.js");
var EventDispatcher = require("yaed");
var inherits = require("inherits");

/**
 * MouseOverGroup. This is the class for the MouseOverGroup.
 * @class MouseOverGroup
 */
function MouseOverGroup() {
	this.objects = new Array();
	this.currentlyOver = false;
	this.mouseDown = false;

}
inherits(MouseOverGroup, PIXI.DisplayObjectContainer);
EventDispatcher.init(MouseOverGroup);


/**
 * Add displayobject to watchlist.
 * @method addDisplayObject
 */
MouseOverGroup.prototype.addDisplayObject = function(displayObject) {

	displayObject.interactive = true;
	displayObject.mouseoverEnabled = true;
	displayObject.mouseover = this.onObjectMouseOver.bind(this);
	displayObject.mouseout = this.onObjectMouseOut.bind(this);
	displayObject.mousedown = this.onObjectMouseDown.bind(this);
	this.objects.push(displayObject);

}


/**
 * Mouse over object.
 * @method onObjectMouseOver
 */
MouseOverGroup.prototype.onObjectMouseOver = function(interaction_object) {
	if(this.currentlyOver)
		return;

	this.currentlyOver = true;
	this.dispatchEvent("mouseover");
}


/**
 * Mouse out object.
 * @method onObjectMouseOut
 */
MouseOverGroup.prototype.onObjectMouseOut = function(interaction_object) {
	if(!this.currentlyOver || this.mouseDown)
		return;

	for(var i = 0; i < this.objects.length; i++)
		if(this.hitTest(this.objects[i], interaction_object))
			return;

	this.currentlyOver = false;
	this.dispatchEvent("mouseout");
}


/**
 * Hit test.
 * @method hitTest
 */
MouseOverGroup.prototype.hitTest = function(object, interaction_object) {
	if((interaction_object.global.x > object.getBounds().x ) && (interaction_object.global.x < (object.getBounds().x + object.getBounds().width)) &&
		(interaction_object.global.y > object.getBounds().y) && (interaction_object.global.y < (object.getBounds().y + object.getBounds().height))) {
		return true;		
	}
	return false;
}


/**
 * Mouse down object.
 * @method onObjectMouseDown
 */
MouseOverGroup.prototype.onObjectMouseDown = function(interaction_object) {
	this.mouseDown = true;
	interaction_object.target.mouseup = interaction_object.target.mouseupoutside = this.onStageMouseUp.bind(this);
}


/**
 * Mouse up stage.
 * @method onStageMouseUp
 */
MouseOverGroup.prototype.onStageMouseUp = function(interaction_object) {
	interaction_object.target.mouseup = interaction_object.target.mouseupoutside = null;
	this.mouseDown = false;

	if(this.currentlyOver) {
		var over = false;

		for(var i = 0; i < this.objects.length; i++)
			if(this.hitTest(this.objects[i], interaction_object))
				over = true;

		if(!over) {
			this.currentlyOver = false;
			this.dispatchEvent("mouseout");
		}
	}
}


module.exports = MouseOverGroup;


},{"inherits":7,"pixi.js":"pixi.js","yaed":11}],78:[function(require,module,exports){
/**
 * Utilities.
 * @module utils
 */

/**
 * Represents a point.
 * @class Point
 * @module utils
 */
function Point(x, y) {
	if (!(this instanceof Point))
		return new Point(x, y);

	this.x = x;
	this.y = y;
}

module.exports = Point;
},{}],79:[function(require,module,exports){
/**
 * Utilities.
 * @module utils
 */

var EventDispatcher = require("yaed");
var inherits = require("inherits");

/**
 * Perform tasks in a sequence.
 * Tasks, which should be event dispatchers,
 * are euqueued with the enqueue function,
 * a START event is dispatcher upon task
 * start, and the task is considered complete
 * as it dispatches a COMPLETE event.
 * @class Sequencer
 */
function Sequencer() {
	EventDispatcher.call(this);

	this.queue = [];
	this.currentTask = null;
	this.onTaskCompleteClosure = this.onTaskComplete.bind(this);
}

inherits(Sequencer, EventDispatcher);

Sequencer.START = "start";
Sequencer.COMPLETE = "complete";

/**
 * Enqueue a task to be performed.
 * @method enqueue
 */
Sequencer.prototype.enqueue = function(task) {
	if (!this.currentTask)
		this.startTask(task)

	else
		this.queue.push(task);
}

/**
 * Start the task.
 * @method startTask
 * @private
 */
Sequencer.prototype.startTask = function(task) {
	this.currentTask = task;

	this.currentTask.addEventListener(Sequencer.COMPLETE, this.onTaskCompleteClosure);
	this.currentTask.dispatchEvent({
		type: Sequencer.START
	});
}

/**
 * The current task is complete.
 * @method onTaskComplete
 * @private
 */
Sequencer.prototype.onTaskComplete = function() {
	this.currentTask.removeEventListener(Sequencer.COMPLETE, this.onTaskCompleteClosure);
	this.currentTask = null;

	if (this.queue.length > 0)
		this.startTask(this.queue.shift());

	else
		this.trigger(Sequencer.COMPLETE);

}

/**
 * Abort the sequence.
 * @method abort
 */
Sequencer.prototype.abort = function() {
	if (this.currentTask) {
		this.currentTask.removeEventListener(Sequencer.COMPLETE, this.onTaskCompleteClosure);
		this.currentTask = null;
	}

	this.queue = [];
}

module.exports = Sequencer;
},{"inherits":7,"yaed":11}],80:[function(require,module,exports){
/**
 * Utilities.
 * @module utils
 */

var PIXI = require("pixi.js");
var TWEEN = require("tween.js");
var EventDispatcher = require("yaed");
var inherits = require("inherits");

/**
 * Slider. This is the class for the slider.
 * @class Slider
 */
function Slider(background, knob) {
	PIXI.DisplayObjectContainer.call(this);

	this.background = background;
	this.knob = knob;

	this.addChild(this.background);
	this.addChild(this.knob);


	this.knob.buttonMode = true;
	this.knob.interactive = true;
	this.knob.mousedown = this.onKnobMouseDown.bind(this);

	this.background.buttonMode = true;
	this.background.interactive = true;
	this.background.mousedown = this.onBackgroundMouseDown.bind(this);

	this.fadeTween = null;
	this.alpha = 0;
}

inherits(Slider, PIXI.DisplayObjectContainer);
EventDispatcher.init(Slider);


/**
 * Mouse down on knob.
 * @method onKnobMouseDown
 */
Slider.prototype.onKnobMouseDown = function(interaction_object) {
	this.downPos = this.knob.position.x;
	this.downX = interaction_object.getLocalPosition(this).x;

	this.stage.mouseup = this.onStageMouseUp.bind(this);
	this.stage.mousemove = this.onStageMouseMove.bind(this);
}


/**
 * Mouse down on background.
 * @method onBackgroundMouseDown
 */
Slider.prototype.onBackgroundMouseDown = function(interaction_object) {
	this.downX = interaction_object.getLocalPosition(this).x;
	this.knob.x = interaction_object.getLocalPosition(this).x - this.knob.width*0.5;

	this.validateValue();

	this.downPos = this.knob.position.x;

	this.stage.mouseup = this.onStageMouseUp.bind(this);
	this.stage.mousemove = this.onStageMouseMove.bind(this);

	this.dispatchEvent("change");
}


/**
 * Mouse up.
 * @method onStageMouseUp
 */
Slider.prototype.onStageMouseUp = function(interaction_object) {
	this.stage.mouseup = null;
	this.stage.mousemove = null;
}


/**
 * Mouse move.
 * @method onStageMouseMove
 */
Slider.prototype.onStageMouseMove = function(interaction_object) {
	this.knob.x = this.downPos + (interaction_object.getLocalPosition(this).x - this.downX);

	this.validateValue();

	this.dispatchEvent("change");
}


/**
 * Validate position.
 * @method validateValue
 */
Slider.prototype.validateValue = function() {

	if(this.knob.x < 0)
		this.knob.x = 0;

	if(this.knob.x > (this.background.width - this.knob.width))
		this.knob.x = this.background.width - this.knob.width;
}


/**
 * Get value.
 * @method getValue
 */
Slider.prototype.getValue = function() {
	var fraction = this.knob.position.x/(this.background.width - this.knob.width);

	return fraction;
}


/**
 * Get value.
 * @method getValue
 */
Slider.prototype.setValue = function(value) {
	this.knob.x = this.background.position.x + value*(this.background.width - this.knob.width);

	this.validateValue();
	return this.getValue();
}


/**
 * Show.
 * @method show
 */
Slider.prototype.show = function() {
	this.visible = true;
	if(this.fadeTween != null)
		this.fadeTween.stop();
	this.fadeTween = new TWEEN.Tween(this)
			.to({alpha: 1}, 250)
			.start();
}

/**
 * Hide.
 * @method hide
 */
Slider.prototype.hide = function() {
	if(this.fadeTween != null)
		this.fadeTween.stop();
	this.fadeTween = new TWEEN.Tween(this)
			.to({alpha: 0}, 250)
			.onComplete(this.onHidden.bind(this))
			.start();
}

/**
 * On hidden.
 * @method onHidden
 */
Slider.prototype.onHidden = function() {
	this.visible = false;
}


module.exports = Slider;

},{"inherits":7,"pixi.js":"pixi.js","tween.js":10,"yaed":11}],81:[function(require,module,exports){
var url = require("url");

/**
 * URL utility.
 * @class UrlUtil
 */
function UrlUtil() {
	throw new Error("static");
}

/**
 * Make absolute url.
 * @method makeAbsolute
 */
UrlUtil.makeAbsolute = function(target) {
	var parsedUrl = url.parse(target);

	if (parsedUrl.protocol)
		return target;

	if (target.charAt(0) == "/") {
		var u = url.parse(window.location.href);

		u.pathname = target;

		return url.format(u);
	} else {
		var path;
		path = window.location.href.substring(0, window.location.href.lastIndexOf("/") + 1);
		return path + target;
	}
}

module.exports = UrlUtil;
},{"url":6}],"Button":[function(require,module,exports){
/**
 * Utilities.
 * @module utils
 */

var PIXI = require("pixi.js");
var EventDispatcher = require("yaed");
var inherits = require("inherits");

/**
 * Button.
 * @class Button
 */
function Button(content) {
	PIXI.DisplayObjectContainer.call(this);

	if (content)
		this.addChild(content);

	this.interactive = true;
	this.buttonMode = true;

	this.mouseover = this.onMouseover.bind(this);
	this.mouseout = this.touchend = this.touchendoutside = this.onMouseout.bind(this);
	this.mousedown = this.touchstart = this.onMousedown.bind(this);
	this.mouseup = this.onMouseup.bind(this);
	this.click = this.tap = this.onClick.bind(this);

	this.colorMatrixFilter = new PIXI.ColorMatrixFilter();
	this.colorMatrixFilter.matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

	this.filters = [this.colorMatrixFilter];
}

inherits(Button, PIXI.DisplayObjectContainer);
EventDispatcher.init(Button);

Button.LIGHT_MATRIX = [1.5, 0, 0, 0, 0, 1.5, 0, 0, 0, 0, 1.5, 0, 0, 0, 0, 1];
Button.DARK_MATRIX = [.75, 0, 0, 0, 0, .75, 0, 0, 0, 0, .75, 0, 0, 0, 0, 1];
Button.DEFAULT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

Button.CLICK = "click";

/**
 * Mouse over.
 * @method onMouseover
 * @private
 */
Button.prototype.onMouseover = function() {
	this.colorMatrixFilter.matrix = Button.LIGHT_MATRIX;
}

/**
 * Mouse out.
 * @method onMouseout
 * @private
 */
Button.prototype.onMouseout = function() {
	this.colorMatrixFilter.matrix = Button.DEFAULT_MATRIX;
}

/**
 * Mouse down.
 * @method onMousedown
 * @private
 */
Button.prototype.onMousedown = function() {
	this.colorMatrixFilter.matrix = Button.DARK_MATRIX;
}

/**
 * Mouse up.
 * @method onMouseup
 * @private
 */
Button.prototype.onMouseup = function() {
	this.colorMatrixFilter.matrix = Button.LIGHT_MATRIX;
}

/**
 * Click.
 * @method onClick
 * @private
 */
Button.prototype.onClick = function() {
	this.trigger(Button.CLICK);
}

module.exports = Button;
},{"inherits":7,"pixi.js":"pixi.js","yaed":11}],"Gradient":[function(require,module,exports){
/**
 * Utilities.
 * @module utils
 */

var PIXI = require("pixi.js");

/**
 * Create a sprite with a gradient.
 * @class Gradient
 */
function Gradient() {
	this.width = 100;
	this.height = 100;
	this.stops = [];
}

/**
 * Set size of the gradient.
 * @method setSize
 */
Gradient.prototype.setSize = function(w, h) {
	this.width = w;
	this.height = h;
}

/**
 * Add color stop.
 * @method addColorStop
 */
Gradient.prototype.addColorStop = function(weight, color) {
	this.stops.push({
		weight: weight,
		color: color
	});
}

/**
 * Render the sprite.
 * @method createSprite
 */
Gradient.prototype.createSprite = function() {
	//console.log("rendering gradient...");
	var c = document.createElement("canvas");
	c.width = this.width;
	c.height = this.height;

	var ctx = c.getContext("2d");
	var grd = ctx.createLinearGradient(0, 0, 0, this.height);
	var i;

	for (i = 0; i < this.stops.length; i++)
		grd.addColorStop(this.stops[i].weight, this.stops[i].color);

	ctx.fillStyle = grd;
	ctx.fillRect(0, 0, this.width, this.height);

	return new PIXI.Sprite(PIXI.Texture.fromCanvas(c));
}

module.exports = Gradient;
},{"pixi.js":"pixi.js"}],"HttpRequest":[function(require,module,exports){
var Thenable = require("tinp");

/**
 * Wraps XMLHttpRequest.
 * @class HttpRequest
 */
function HttpRequest(url) {
	this.url = url;
	this.thenable = null;
	this.resultType = null;
}

/**
 * Set result type.
 * @method setResultType
 */
HttpRequest.prototype.setResultType = function(type) {
	this.resultType = type;
}

/**
 * Set url.
 * @method setUrl
 */
HttpRequest.prototype.setUrl = function(url) {
	this.url = url;
}

/**
 * Send.
 * @method send
 */
HttpRequest.prototype.send = function(url) {
	if (this.thenable)
		throw new Error("Request already sent");

	if (url)
		this.url = url;

	this.thenable = new Thenable();

	this.request = new XMLHttpRequest();
	this.request.open("GET", this.url, true);

	this.request.onload = this.onRequestLoad.bind(this);
	this.request.onerror = this.onRequestError.bind(this);

	this.request.send();

	return this.thenable;
}

/**
 * @method onRequestLoad
 * @private
 */
HttpRequest.prototype.onRequestLoad = function() {
	if (this.request.status != 200) {
		this.thenable.reject(this.request.status);
		this.thenable = null;
		return;
	}

	var result = this.request.responseText;

	switch (this.resultType) {
		case "json":
			try {
				result = JSON.parse(this.request.responseText);
			} catch (e) {
				this.thenable.reject("JSON.parse: "+e);
				return;
			}
			break;
	}

	this.thenable.resolve(result);
}

/**
 * @method onRequestError
 * @private
 */
HttpRequest.prototype.onRequestError = function(e) {
	this.request = null;

	this.thenable.reject(e);
}

module.exports = HttpRequest;
},{"tinp":"tinp"}],"NetPokerClient":[function(require,module,exports){
/**
 * Client.
 * @module client
 */

var PIXI = require("pixi.js");
var PixiApp = require("pixiapp");
var NetPokerClientView = require("../view/NetPokerClientView");
var NetPokerClientController = require("../controller/NetPokerClientController");
var MessageWebSocketConnection = require("../../utils/MessageWebSocketConnection");
var MessageRequestConnection = require("../../utils/MessageRequestConnection");
var ProtoConnection = require("../../proto/ProtoConnection");
var LoadingScreen = require("../view/LoadingScreen");
var StateCompleteMessage = require("../../proto/messages/StateCompleteMessage");
var InitMessage = require("../../proto/messages/InitMessage");
var Resources = require("../resources/Resources");
var ViewConfig = require("../resources/ViewConfig");
var url = require("url");
var TWEEN = require("tween.js");
var inherits = require("inherits");
var UrlUtil = require("../../utils/UrlUtil");
var DefaultSkin = require("../resources/DefaultSkin");

/**
 * Main entry point for client.
 * @class NetPokerClient
 */
function NetPokerClient() {
	PixiApp.call(this, 960, 720);

	this.verticalAlign = PixiApp.TOP;

	this.resources = new Resources();
	this.resources.addSkinSource(DefaultSkin);
	this.resources.addSpriteSheet("netpokerclient.spritesheet.json");

	this.loadingScreen = new LoadingScreen();
	this.addChild(this.loadingScreen);
	this.enterAppState("LOADING", 0);
	this.loadingScreen.show("LOADING");

	this.url = null;
	this.tableId = null;
	this.tournamentId = null;
	this.viewConfig = new ViewConfig();

	this.on("frame", TWEEN.update);
}

inherits(NetPokerClient, PixiApp);

/**
 * Set url.
 * @method setUrl
 */
NetPokerClient.prototype.setUrl = function(url) {
	this.url = url;
}

/**
 * Set table id.
 * @method setTableId
 */
NetPokerClient.prototype.setTableId = function(tableId) {
	this.tableId = tableId;
}

/**
 * Set tournament id.
 * @method setTournamentId
 */
NetPokerClient.prototype.setTournamentId = function(tournamentId) {
	this.tournamentId = tournamentId;
}

/**
 * Set view case.
 * @method setViewCase
 */
NetPokerClient.prototype.setViewCase = function(viewCase) {
	console.log("****** running view case: " + viewCase);
	this.viewCase = viewCase;
}

/**
 * Set token.
 * @method setToken
 */
NetPokerClient.prototype.setToken = function(token) {
	this.token = token;
}

/**
 * Add skin source.
 * @method addSkinSource
 */
NetPokerClient.prototype.addSkinSource = function(skin) {
	this.resources.addSkinSource(skin);
}

/**
 * Add sprite sheet.
 * @method addSpriteSheet
 */
NetPokerClient.prototype.addSpriteSheet = function(spriteSheet) {
	this.resources.addSpriteSheet(spriteSheet);
}

/**
 * Set sprite sheet.
 * @method setSpriteSheet
 */
NetPokerClient.prototype.setSpriteSheet = function(spriteSheet) {
	this.resources.setSpriteSheet(spriteSheet);
}

/**
 * Run.
 * @method run
 */
NetPokerClient.prototype.run = function() {
	//console.log("loading resources.....");
	this.enterAppState("LOADING RESOURCES", 50);

	this.resources.load().then(
		this.onResourcesLoaded.bind(this),
		this.onResourcesError.bind(this)
	);
}

/**
 * Error while loading resources.
 * @method onResourcesError
 */
NetPokerClient.prototype.onResourcesError = function() {
	console.log("resource error");

	this.enterAppState("ERROR LOADING RESOURCES");
}

/**
 * Assets loaded, connect.
 * @method onAssetLoaderComplete
 * @private
 */
NetPokerClient.prototype.onResourcesLoaded = function() {
	//console.log("resources loaded complete...");

	this.netPokerClientView = new NetPokerClientView(this.viewConfig, this.resources);
	this.addChildAt(this.netPokerClientView, 0);

	this.netPokerClientController = new NetPokerClientController(this.netPokerClientView);
	this.connect();
}

/**
 * Connect.
 * @method connect
 * @private
 */
NetPokerClient.prototype.connect = function() {
	if (!this.url) {
		this.enterAppState("NEED URL");
		return;
	}

	var parsedUrl = url.parse(this.url);

	console.log(parsedUrl);

	if (!parsedUrl.protocol || parsedUrl.protocol == "http:" || parsedUrl.protocol == "https:") {
		this.url = UrlUtil.makeAbsolute(this.url);
		this.connection = new MessageRequestConnection();
	} else {
		this.connection = new MessageWebSocketConnection();
	}

	this.connection.on(MessageWebSocketConnection.CONNECT, this.onConnectionConnect, this);
	this.connection.on(MessageWebSocketConnection.CLOSE, this.onConnectionClose, this);

	console.log("Connecting to: " + this.url);

	this.enterAppState("CONNECTING", 65);
	this.connection.connect(this.url);
}

/**
 * Connection complete.
 * @method onConnectionConnect
 * @private
 */
NetPokerClient.prototype.onConnectionConnect = function() {
	console.log("**** connected");
	this.protoConnection = new ProtoConnection(this.connection);
	this.protoConnection.addMessageHandler(StateCompleteMessage, this.onStateCompleteMessage, this);
	this.netPokerClientController.setProtoConnection(this.protoConnection);
	this.enterAppState("INITIALIZING", 80);

	var initMessage = new InitMessage(this.token);

	if (this.tableId)
		initMessage.setTableId(this.tableId);

	if (this.tournamentId)
		initMessage.setTournamentId(this.tournamentId);

	if (this.viewCase)
		initMessage.setViewCase(this.viewCase);

	this.protoConnection.send(initMessage);
}

/**
 * State complete.
 * @method onStateCompleteMessage
 * @private
 */
NetPokerClient.prototype.onStateCompleteMessage = function() {
	this.enterAppState(null);
}

/**
 * Connection closed.
 * @method onConnectionClose
 * @private
 */
NetPokerClient.prototype.onConnectionClose = function() {
	console.log("**** connection closed");
	if (this.protoConnection)
		this.protoConnection.removeMessageHandler(StateCompleteMessage, this.onStateCompleteMessage, this);

	this.protoConnection = null;
	this.netPokerClientController.setProtoConnection(null);
	this.enterAppState("CONNECTION ERROR");
	setTimeout(this.connect.bind(this), 3000);
}

/**
 * Enter app state.
 * @method enterAppState
 * @private
 */
NetPokerClient.prototype.enterAppState = function(message, progress) {
	if (message)
		this.loadingScreen.show(message);

	else
		this.loadingScreen.hide();

	this.trigger({
		type: "appStateChange",
		message: message,
		progress: progress
	});
}

/**
 * Utility function to get all query string params.
 * @method getQueryStringParams
 * @static
 */
NetPokerClient.getQueryStringParams = function() {
	var params = {};
	(function() {

		var match,
			pl = /\+/g, // Regex for replacing addition symbol with a space
			search = /([^&=]+)=?([^&]*)/g,
			decode = function(s) {
				return decodeURIComponent(s.replace(pl, " "));
			},
			query = window.location.search.substring(1).replace(/amp;/g, "");

		while (match = search.exec(query))
			params[decode(match[1])] = decode(match[2]);
	})();

	return params;
}

module.exports = NetPokerClient;
},{"../../proto/ProtoConnection":39,"../../proto/messages/InitMessage":56,"../../proto/messages/StateCompleteMessage":67,"../../utils/MessageRequestConnection":75,"../../utils/MessageWebSocketConnection":76,"../../utils/UrlUtil":81,"../controller/NetPokerClientController":15,"../resources/DefaultSkin":17,"../resources/Resources":"Resources","../resources/ViewConfig":18,"../view/LoadingScreen":28,"../view/NetPokerClientView":29,"inherits":7,"pixi.js":"pixi.js","pixiapp":"pixiapp","tween.js":10,"url":6}],"NineSlice":[function(require,module,exports){
/**
 * Utilities.
 * @module utils
 */

var PIXI = require("pixi.js");
var inherits = require("inherits");

/**
 * Nine slice. This is a sprite that is a grid, and only the
 * middle part stretches when scaling.
 * @class NineSlice
 */
function NineSlice(texture, left, top, right, bottom) {
	PIXI.DisplayObjectContainer.call(this);

	this.texture = texture;

	if (!top)
		top = left;

	if (!right)
		right = left;

	if (!bottom)
		bottom = top;

	this.left = left;
	this.top = top;
	this.right = right;
	this.bottom = bottom;

	this.localWidth = texture.width;
	this.localHeight = texture.height;

	this.buildParts();
	this.updateSizes();
}

inherits(NineSlice, PIXI.DisplayObjectContainer);

/**
 * Build the parts for the slices.
 * @method buildParts
 * @private
 */
NineSlice.prototype.buildParts = function() {
	var xp = [0, this.left, this.texture.width - this.right, this.texture.width];
	var yp = [0, this.top, this.texture.height - this.bottom, this.texture.height];
	var hi, vi;

	this.parts = [];

	for (vi = 0; vi < 3; vi++) {
		for (hi = 0; hi < 3; hi++) {
			var w = xp[hi + 1] - xp[hi];
			var h = yp[vi + 1] - yp[vi];

			if (w != 0 && h != 0) {
				var texturePart = this.createTexturePart(xp[hi], yp[vi], w, h);
				var s = new PIXI.Sprite(texturePart);
				this.addChild(s);

				this.parts.push(s);
			} else {
				this.parts.push(null);
			}
		}
	}
}

/**
 * Update sizes.
 * @method updateSizes
 * @private
 */
NineSlice.prototype.updateSizes = function() {
	var xp = [0, this.left, this.localWidth - this.right, this.localWidth];
	var yp = [0, this.top, this.localHeight - this.bottom, this.localHeight];
	var hi, vi, i = 0;

	for (vi = 0; vi < 3; vi++) {
		for (hi = 0; hi < 3; hi++) {
			if (this.parts[i]) {
				var part = this.parts[i];

				part.position.x = xp[hi];
				part.position.y = yp[vi];
				part.width = xp[hi + 1] - xp[hi];
				part.height = yp[vi + 1] - yp[vi];
			}

			i++;
		}
	}
}

/**
 * Set local size.
 * @method setLocalSize
 */
NineSlice.prototype.setLocalSize = function(w, h) {
	this.localWidth = w;
	this.localHeight = h;
	this.updateSizes();
}

/**
 * Create texture part.
 * @method createTexturePart
 * @private
 */
NineSlice.prototype.createTexturePart = function(x, y, width, height) {
	var frame = {
		x: this.texture.frame.x + x,
		y: this.texture.frame.y + y,
		width: width,
		height: height
	};

	return new PIXI.Texture(this.texture, frame);
}

module.exports = NineSlice;
},{"inherits":7,"pixi.js":"pixi.js"}],"Resources":[function(require,module,exports){
var Thenable = require("tinp");
var PIXI = require("pixi.js");
var UrlUtil = require("../../utils/UrlUtil");
var HttpRequest = require("../../utils/HttpRequest");

/**
 * Resources
 * @class Resources
 */
function Resources() {
	this.spriteSheets = [];
	this.skinSources = [];
	this.data = [];
	this.loadThenable = null;
	this.skinSourceIndex = 0;
}

/**
 * Set sprite sheet.
 * @method setSpriteSheet
 */
Resources.prototype.setSpriteSheet = function(spriteSheet) {
	this.spriteSheets = [spriteSheet];
}

/**
 * Add a sprite sheet.
 * @method addSpriteSheet
 */
Resources.prototype.addSpriteSheet = function(spriteSheet) {
	this.spriteSheets.push(spriteSheet);
}

/**
 * Add a cascading skin source.
 * Object or url.
 * @method source
 */
Resources.prototype.addSkinSource = function(source) {
	this.skinSources.push(source);
}

/**
 * Get a Point resource.
 * @method getPoint
 */
Resources.prototype.getPoint = function(id) {
	this.assertKeyExists(id);

	return new PIXI.Point(this.data[id][0], this.data[id][1]);
}

/**
 * Get a string resource.
 * @method getString
 */
Resources.prototype.getString = function(id) {
	this.assertKeyExists(id);

	return this.data[id].toString();
}

/**
 * Get value.
 * @method getValue
 */
Resources.prototype.getValue = Resources.prototype.getString;

/**
 * Get color.
 * @method getValue
 */
Resources.prototype.getColor = Resources.prototype.getString;

/**
 * Get Texture.
 * @method getTexture
 */
Resources.prototype.getTexture = function(id) {
	var texture = PIXI.Texture.fromFrame(this.getString(id));

	return texture;
}

/**
 * Assert that the key exists.
 * @method assertKeyExists
 * @private
 */
Resources.prototype.assertKeyExists = function(id) {
	if (!this.data.hasOwnProperty(id))
		throw new Error("No such resource: " + id);
}

/**
 * Does this key exist?
 * @method keyExists
 */
Resources.prototype.keyExists = function(id) {
	return this.data.hasOwnProperty(id);
}

/**
 * Load resources.
 * @method load
 */
Resources.prototype.load = function() {
	if (this.loadThenable)
		throw new Error("Already loading");

	this.loadThenable = new Thenable();
	this.skinSourceIndex = 0;

	if (this.spriteSheets.length) {
		this.assetLoader = new PIXI.AssetLoader(this.spriteSheets);
		this.assetLoader.on("onComplete", this.onAssetLoaderComplete.bind(this));
		this.assetLoader.on("onProgress", this.onAssetLoaderProgress.bind(this));
		//console.log("loading assets: "+this.spriteSheets);
		this.assetLoader.load();
	} else {
		this.loadNextSkinSource();
	}

	return this.loadThenable;
}

/**
 * Asset loader progress.
 * @method onAssetLoaderProgress
 */
Resources.prototype.onAssetLoaderProgress = function(ev) {
	console.log("asset loader progress");
	/*	console.log(ev);

		ev.loader.ajaxRequest.onprogress = function() {
			console.log("request progres...");
		};

		ev.loader.ajaxRequest.addEventListener("progress", function() {
			console.log("progress...");
		});*/
}

/**
 * Asset loader complete.
 * @method onAssetLoaderComplete
 */
Resources.prototype.onAssetLoaderComplete = function() {
	//console.log("asset loader complete, loading skin");
	this.loadNextSkinSource();
}

/**
 * Process next skin source in sequence.
 * @method loadNextSkinSource
 * @private
 */
Resources.prototype.loadNextSkinSource = function() {
	if (this.skinSourceIndex >= this.skinSources.length) {
		//console.log("resolving thenable...");
		this.loadThenable.resolve();
		return;
	}

	var o = this.skinSources[this.skinSourceIndex];

	if (typeof o == "object") {
		this.processSkinData(o);
		return;
	}

	var request = new HttpRequest(UrlUtil.makeAbsolute(o));
	request.setResultType("json");

	request.send().then(
		this.onSkinSourceLoaded.bind(this),
		this.onSkinSourceLoadError.bind(this)
	);
}

/**
 * Skin source loaded.
 * @method onSkinSourceLoaded
 */
Resources.prototype.onSkinSourceLoaded = function(data) {
	this.processSkinData(data);
}

/**
 * Skin source load error.
 * @method onSkinSourceLoadError
 */
Resources.prototype.onSkinSourceLoadError = function(error) {
	this.loadThenable.reject(error);
}

/**
 * Process skin data.
 * @method processSkinData
 */
Resources.prototype.processSkinData = function(data) {
	for (i in data)
		this.data[i] = data[i];

	this.skinSourceIndex++;
	this.loadNextSkinSource();
}

module.exports = Resources;
},{"../../utils/HttpRequest":"HttpRequest","../../utils/UrlUtil":81,"pixi.js":"pixi.js","tinp":"tinp"}],"pixi.js":[function(require,module,exports){
/**
 * @license
 * pixi.js - v1.6.0
 * Copyright (c) 2012-2014, Mat Groves
 * http://goodboydigital.com/
 *
 * Compiled: 2014-07-18
 *
 * pixi.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license.php
 */
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

(function(){

    var root = this;

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * @module PIXI
 */
var PIXI = PIXI || {};

/* 
* 
* This file contains a lot of pixi consts which are used across the rendering engine
* @class Consts
*/
PIXI.WEBGL_RENDERER = 0;
PIXI.CANVAS_RENDERER = 1;

// useful for testing against if your lib is using pixi.
PIXI.VERSION = "v1.6.1";


// the various blend modes supported by pixi
PIXI.blendModes = {
    NORMAL:0,
    ADD:1,
    MULTIPLY:2,
    SCREEN:3,
    OVERLAY:4,
    DARKEN:5,
    LIGHTEN:6,
    COLOR_DODGE:7,
    COLOR_BURN:8,
    HARD_LIGHT:9,
    SOFT_LIGHT:10,
    DIFFERENCE:11,
    EXCLUSION:12,
    HUE:13,
    SATURATION:14,
    COLOR:15,
    LUMINOSITY:16
};

// the scale modes
PIXI.scaleModes = {
    DEFAULT:0,
    LINEAR:0,
    NEAREST:1
};

// used to create uids for various pixi objects..
PIXI._UID = 0;

if(typeof(Float32Array) != 'undefined')
{
    PIXI.Float32Array = Float32Array;
    PIXI.Uint16Array = Uint16Array;
}
else
{
    PIXI.Float32Array = Array;
    PIXI.Uint16Array = Array;
}

// interaction frequency 
PIXI.INTERACTION_FREQUENCY = 30;
PIXI.AUTO_PREVENT_DEFAULT = true;

PIXI.RAD_TO_DEG = 180 / Math.PI;
PIXI.DEG_TO_RAD = Math.PI / 180;


PIXI.dontSayHello = false;

PIXI.sayHello = function (type) 
{
    if(PIXI.dontSayHello)return;

    if ( navigator.userAgent.toLowerCase().indexOf('chrome') > -1 )
    {
        var args = [
            '%c %c %c Pixi.js ' + PIXI.VERSION + ' - ' + type + '  %c ' + ' %c ' + ' http://www.pixijs.com/  %c %c ♥%c♥%c♥ ',
            'background: #ff66a5',
            'background: #ff66a5',
            'color: #ff66a5; background: #030307;',
            'background: #ff66a5',
            'background: #ffc3dc',
            'background: #ff66a5',
            'color: #ff2424; background: #fff',
            'color: #ff2424; background: #fff',
            'color: #ff2424; background: #fff'
        ];

       

        console.log.apply(console, args);
    }
    else if (window['console'])
    {
        console.log('Pixi.js ' + PIXI.VERSION + ' - http://www.pixijs.com/');
    }

    PIXI.dontSayHello = true;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The Point object represents a location in a two-dimensional coordinate system, where x represents the horizontal axis and y represents the vertical axis.
 *
 * @class Point
 * @constructor
 * @param x {Number} position of the point on the x axis
 * @param y {Number} position of the point on the y axis
 */
PIXI.Point = function(x, y)
{
    /**
     * @property x
     * @type Number
     * @default 0
     */
    this.x = x || 0;

    /**
     * @property y
     * @type Number
     * @default 0
     */
    this.y = y || 0;
};

/**
 * Creates a clone of this point
 *
 * @method clone
 * @return {Point} a copy of the point
 */
PIXI.Point.prototype.clone = function()
{
    return new PIXI.Point(this.x, this.y);
};

/**
 * Sets the point to a new x and y position.
 * If y is ommited, both x and y will be set to x.
 * 
 * @method set
 * @param [x=0] {Number} position of the point on the x axis
 * @param [y=0] {Number} position of the point on the y axis
 */
PIXI.Point.prototype.set = function(x, y)
{
    this.x = x || 0;
    this.y = y || ( (y !== 0) ? this.x : 0 ) ;
};

// constructor
PIXI.Point.prototype.constructor = PIXI.Point;
/**
 * @author Mat Groves http://matgroves.com/
 */

/**
 * the Rectangle object is an area defined by its position, as indicated by its top-left corner point (x, y) and by its width and its height.
 *
 * @class Rectangle
 * @constructor
 * @param x {Number} The X coord of the upper-left corner of the rectangle
 * @param y {Number} The Y coord of the upper-left corner of the rectangle
 * @param width {Number} The overall width of this rectangle
 * @param height {Number} The overall height of this rectangle
 */
PIXI.Rectangle = function(x, y, width, height)
{
    /**
     * @property x
     * @type Number
     * @default 0
     */
    this.x = x || 0;

    /**
     * @property y
     * @type Number
     * @default 0
     */
    this.y = y || 0;

    /**
     * @property width
     * @type Number
     * @default 0
     */
    this.width = width || 0;

    /**
     * @property height
     * @type Number
     * @default 0
     */
    this.height = height || 0;
};

/**
 * Creates a clone of this Rectangle
 *
 * @method clone
 * @return {Rectangle} a copy of the rectangle
 */
PIXI.Rectangle.prototype.clone = function()
{
    return new PIXI.Rectangle(this.x, this.y, this.width, this.height);
};

/**
 * Checks whether the x and y coordinates passed to this function are contained within this Rectangle
 *
 * @method contains
 * @param x {Number} The X coordinate of the point to test
 * @param y {Number} The Y coordinate of the point to test
 * @return {Boolean} Whether the x/y coords are within this Rectangle
 */
PIXI.Rectangle.prototype.contains = function(x, y)
{
    if(this.width <= 0 || this.height <= 0)
        return false;

    var x1 = this.x;
    if(x >= x1 && x <= x1 + this.width)
    {
        var y1 = this.y;

        if(y >= y1 && y <= y1 + this.height)
        {
            return true;
        }
    }

    return false;
};

// constructor
PIXI.Rectangle.prototype.constructor = PIXI.Rectangle;

PIXI.EmptyRectangle = new PIXI.Rectangle(0,0,0,0);
/**
 * @author Adrien Brault <adrien.brault@gmail.com>
 */

/**
 * @class Polygon
 * @constructor
 * @param points* {Array<Point>|Array<Number>|Point...|Number...} This can be an array of Points that form the polygon,
 *      a flat array of numbers that will be interpreted as [x,y, x,y, ...], or the arguments passed can be
 *      all the points of the polygon e.g. `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the
 *      arguments passed can be flat x,y values e.g. `new PIXI.Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are
 *      Numbers.
 */
PIXI.Polygon = function(points)
{
    //if points isn't an array, use arguments as the array
    if(!(points instanceof Array))
        points = Array.prototype.slice.call(arguments);

    //if this is a flat array of numbers, convert it to points
    if(typeof points[0] === 'number') {
        var p = [];
        for(var i = 0, il = points.length; i < il; i+=2) {
            p.push(
                new PIXI.Point(points[i], points[i + 1])
            );
        }

        points = p;
    }

    this.points = points;
};

/**
 * Creates a clone of this polygon
 *
 * @method clone
 * @return {Polygon} a copy of the polygon
 */
PIXI.Polygon.prototype.clone = function()
{
    var points = [];
    for (var i=0; i<this.points.length; i++) {
        points.push(this.points[i].clone());
    }

    return new PIXI.Polygon(points);
};

/**
 * Checks whether the x and y coordinates passed to this function are contained within this polygon
 *
 * @method contains
 * @param x {Number} The X coordinate of the point to test
 * @param y {Number} The Y coordinate of the point to test
 * @return {Boolean} Whether the x/y coordinates are within this polygon
 */
PIXI.Polygon.prototype.contains = function(x, y)
{
    var inside = false;

    // use some raycasting to test hits
    // https://github.com/substack/point-in-polygon/blob/master/index.js
    for(var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {
        var xi = this.points[i].x, yi = this.points[i].y,
            xj = this.points[j].x, yj = this.points[j].y,
            intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);

        if(intersect) inside = !inside;
    }

    return inside;
};

// constructor
PIXI.Polygon.prototype.constructor = PIXI.Polygon;

/**
 * @author Chad Engler <chad@pantherdev.com>
 */

/**
 * The Circle object can be used to specify a hit area for displayObjects
 *
 * @class Circle
 * @constructor
 * @param x {Number} The X coordinate of the center of this circle
 * @param y {Number} The Y coordinate of the center of this circle
 * @param radius {Number} The radius of the circle
 */
PIXI.Circle = function(x, y, radius)
{
    /**
     * @property x
     * @type Number
     * @default 0
     */
    this.x = x || 0;

    /**
     * @property y
     * @type Number
     * @default 0
     */
    this.y = y || 0;

    /**
     * @property radius
     * @type Number
     * @default 0
     */
    this.radius = radius || 0;
};

/**
 * Creates a clone of this Circle instance
 *
 * @method clone
 * @return {Circle} a copy of the polygon
 */
PIXI.Circle.prototype.clone = function()
{
    return new PIXI.Circle(this.x, this.y, this.radius);
};

/**
 * Checks whether the x, and y coordinates passed to this function are contained within this circle
 *
 * @method contains
 * @param x {Number} The X coordinate of the point to test
 * @param y {Number} The Y coordinate of the point to test
 * @return {Boolean} Whether the x/y coordinates are within this polygon
 */
PIXI.Circle.prototype.contains = function(x, y)
{
    if(this.radius <= 0)
        return false;

    var dx = (this.x - x),
        dy = (this.y - y),
        r2 = this.radius * this.radius;

    dx *= dx;
    dy *= dy;

    return (dx + dy <= r2);
};

/**
* Returns the framing rectangle of the circle as a PIXI.Rectangle object
*
* @method getBounds
* @return {Rectangle} the framing rectangle
*/
PIXI.Circle.prototype.getBounds = function()
{
    return new PIXI.Rectangle(this.x - this.radius, this.y - this.radius, this.width, this.height);
};

// constructor
PIXI.Circle.prototype.constructor = PIXI.Circle;


/**
 * @author Chad Engler <chad@pantherdev.com>
 */

/**
 * The Ellipse object can be used to specify a hit area for displayObjects
 *
 * @class Ellipse
 * @constructor
 * @param x {Number} The X coordinate of the center of the ellipse
 * @param y {Number} The Y coordinate of the center of the ellipse
 * @param width {Number} The half width of this ellipse
 * @param height {Number} The half height of this ellipse
 */
PIXI.Ellipse = function(x, y, width, height)
{
    /**
     * @property x
     * @type Number
     * @default 0
     */
    this.x = x || 0;

    /**
     * @property y
     * @type Number
     * @default 0
     */
    this.y = y || 0;

    /**
     * @property width
     * @type Number
     * @default 0
     */
    this.width = width || 0;

    /**
     * @property height
     * @type Number
     * @default 0
     */
    this.height = height || 0;
};

/**
 * Creates a clone of this Ellipse instance
 *
 * @method clone
 * @return {Ellipse} a copy of the ellipse
 */
PIXI.Ellipse.prototype.clone = function()
{
    return new PIXI.Ellipse(this.x, this.y, this.width, this.height);
};

/**
 * Checks whether the x and y coordinates passed to this function are contained within this ellipse
 *
 * @method contains
 * @param x {Number} The X coordinate of the point to test
 * @param y {Number} The Y coordinate of the point to test
 * @return {Boolean} Whether the x/y coords are within this ellipse
 */
PIXI.Ellipse.prototype.contains = function(x, y)
{
    if(this.width <= 0 || this.height <= 0)
        return false;

    //normalize the coords to an ellipse with center 0,0
    var normx = ((x - this.x) / this.width),
        normy = ((y - this.y) / this.height);

    normx *= normx;
    normy *= normy;

    return (normx + normy <= 1);
};

/**
* Returns the framing rectangle of the ellipse as a PIXI.Rectangle object
*
* @method getBounds
* @return {Rectangle} the framing rectangle
*/
PIXI.Ellipse.prototype.getBounds = function()
{
    return new PIXI.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
};

// constructor
PIXI.Ellipse.prototype.constructor = PIXI.Ellipse;

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The Matrix class is now an object, which makes it a lot faster, 
 * here is a representation of it : 
 * | a | b | tx|
 * | c | d | ty|
 * | 0 | 0 | 1 |
 *
 * @class Matrix
 * @constructor
 */
PIXI.Matrix = function()
{
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;
};

/**
 * Creates a pixi matrix object based on the array given as a parameter
 *
 * @method fromArray
 * @param array {Array} The array that the matrix will be filled with
 */
PIXI.Matrix.prototype.fromArray = function(array)
{
    this.a = array[0];
    this.b = array[1];
    this.c = array[3];
    this.d = array[4];
    this.tx = array[2];
    this.ty = array[5];
};

/**
 * Creates an array from the current Matrix object
 *
 * @method toArray
 * @param transpose {Boolean} Whether we need to transpose the matrix or not
 * @return {Array} the newly created array which contains the matrix
 */
PIXI.Matrix.prototype.toArray = function(transpose)
{
    if(!this.array) this.array = new Float32Array(9);
    var array = this.array;

    if(transpose)
    {
        array[0] = this.a;
        array[1] = this.c;
        array[2] = 0;
        array[3] = this.b;
        array[4] = this.d;
        array[5] = 0;
        array[6] = this.tx;
        array[7] = this.ty;
        array[8] = 1;
    }
    else
    {
        array[0] = this.a;
        array[1] = this.b;
        array[2] = this.tx;
        array[3] = this.c;
        array[4] = this.d;
        array[5] = this.ty;
        array[6] = 0;
        array[7] = 0;
        array[8] = 1;
    }

    return array;
};

PIXI.identityMatrix = new PIXI.Matrix();

PIXI.determineMatrixArrayType = function() {
    return (typeof Float32Array !== 'undefined') ? Float32Array : Array;
};

/**
 * The Matrix2 class will choose the best type of array to use between
 * a regular javascript Array and a Float32Array if the latter is available
 *
 * @class Matrix2
 * @constructor
 */
PIXI.Matrix2 = PIXI.determineMatrixArrayType();

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The base class for all objects that are rendered on the screen. 
 * This is an abstract class and should not be used on its own rather it should be extended.
 *
 * @class DisplayObject
 * @constructor
 */
PIXI.DisplayObject = function()
{
    /**
     * The coordinate of the object relative to the local coordinates of the parent.
     *
     * @property position
     * @type Point
     */
    this.position = new PIXI.Point();

    /**
     * The scale factor of the object.
     *
     * @property scale
     * @type Point
     */
    this.scale = new PIXI.Point(1,1);//{x:1, y:1};

    /**
     * The pivot point of the displayObject that it rotates around
     *
     * @property pivot
     * @type Point
     */
    this.pivot = new PIXI.Point(0,0);

    /**
     * The rotation of the object in radians.
     *
     * @property rotation
     * @type Number
     */
    this.rotation = 0;

    /**
     * The opacity of the object.
     *
     * @property alpha
     * @type Number
     */
    this.alpha = 1;

    /**
     * The visibility of the object.
     *
     * @property visible
     * @type Boolean
     */
    this.visible = true;

    /**
     * This is the defined area that will pick up mouse / touch events. It is null by default.
     * Setting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)
     *
     * @property hitArea
     * @type Rectangle|Circle|Ellipse|Polygon
     */
    this.hitArea = null;

    /**
     * This is used to indicate if the displayObject should display a mouse hand cursor on rollover
     *
     * @property buttonMode
     * @type Boolean
     */
    this.buttonMode = false;

    /**
     * Can this object be rendered
     *
     * @property renderable
     * @type Boolean
     */
    this.renderable = false;

    /**
     * [read-only] The display object container that contains this display object.
     *
     * @property parent
     * @type DisplayObjectContainer
     * @readOnly
     */
    this.parent = null;

    /**
     * [read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.
     *
     * @property stage
     * @type Stage
     * @readOnly
     */
    this.stage = null;

    /**
     * [read-only] The multiplied alpha of the displayObject
     *
     * @property worldAlpha
     * @type Number
     * @readOnly
     */
    this.worldAlpha = 1;

    /**
     * [read-only] Whether or not the object is interactive, do not toggle directly! use the `interactive` property
     *
     * @property _interactive
     * @type Boolean
     * @readOnly
     * @private
     */
    this._interactive = false;

    /**
     * This is the cursor that will be used when the mouse is over this object. To enable this the element must have interaction = true and buttonMode = true
     * 
     * @property defaultCursor
     * @type String
     *
    */
    this.defaultCursor = 'pointer';

    /**
     * [read-only] Current transform of the object based on world (parent) factors
     *
     * @property worldTransform
     * @type Mat3
     * @readOnly
     * @private
     */
    this.worldTransform = new PIXI.Matrix();

    /**
     * [NYI] Unknown
     *
     * @property color
     * @type Array<>
     * @private
     */
    this.color = [];

    /**
     * [NYI] Holds whether or not this object is dynamic, for rendering optimization
     *
     * @property dynamic
     * @type Boolean
     * @private
     */
    this.dynamic = true;

    // cached sin rotation and cos rotation
    this._sr = 0;
    this._cr = 1;

    /**
     * The area the filter is applied to like the hitArea this is used as more of an optimisation
     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle
     *
     * @property filterArea
     * @type Rectangle
     */
    this.filterArea = null;//new PIXI.Rectangle(0,0,1,1);

    /**
     * The original, cached bounds of the object
     *
     * @property _bounds
     * @type Rectangle
     * @private
     */
    this._bounds = new PIXI.Rectangle(0, 0, 1, 1);
    /**
     * The most up-to-date bounds of the object
     *
     * @property _currentBounds
     * @type Rectangle
     * @private
     */
    this._currentBounds = null;
    /**
     * The original, cached mask of the object
     *
     * @property _currentBounds
     * @type Rectangle
     * @private
     */
    this._mask = null;

    this._cacheAsBitmap = false;
    this._cacheIsDirty = false;


    /*
     * MOUSE Callbacks
     */

    /**
     * A callback that is used when the users clicks on the displayObject with their mouse
     * @method click
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the user clicks the mouse down over the sprite
     * @method mousedown
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the user releases the mouse that was over the displayObject
     * for this callback to be fired the mouse must have been pressed down over the displayObject
     * @method mouseup
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the user releases the mouse that was over the displayObject but is no longer over the displayObject
     * for this callback to be fired, The touch must have started over the displayObject
     * @method mouseupoutside
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the users mouse rolls over the displayObject
     * @method mouseover
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the users mouse leaves the displayObject
     * @method mouseout
     * @param interactionData {InteractionData}
     */


    /*
     * TOUCH Callbacks
     */

    /**
     * A callback that is used when the users taps on the sprite with their finger
     * basically a touch version of click
     * @method tap
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the user touches over the displayObject
     * @method touchstart
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the user releases a touch over the displayObject
     * @method touchend
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the user releases the touch that was over the displayObject
     * for this callback to be fired, The touch must have started over the sprite
     * @method touchendoutside
     * @param interactionData {InteractionData}
     */
};

// constructor
PIXI.DisplayObject.prototype.constructor = PIXI.DisplayObject;

/**
 * [Deprecated] Indicates if the sprite will have touch and mouse interactivity. It is false by default
 * Instead of using this function you can now simply set the interactive property to true or false
 *
 * @method setInteractive
 * @param interactive {Boolean}
 * @deprecated Simply set the `interactive` property directly
 */
PIXI.DisplayObject.prototype.setInteractive = function(interactive)
{
    this.interactive = interactive;
};

/**
 * Indicates if the sprite will have touch and mouse interactivity. It is false by default
 *
 * @property interactive
 * @type Boolean
 * @default false
 */
Object.defineProperty(PIXI.DisplayObject.prototype, 'interactive', {
    get: function() {
        return this._interactive;
    },
    set: function(value) {
        this._interactive = value;

        // TODO more to be done here..
        // need to sort out a re-crawl!
        if(this.stage)this.stage.dirty = true;
    }
});

/**
 * [read-only] Indicates if the sprite is globaly visible.
 *
 * @property worldVisible
 * @type Boolean
 */
Object.defineProperty(PIXI.DisplayObject.prototype, 'worldVisible', {
    get: function() {
        var item = this;

        do
        {
            if(!item.visible)return false;
            item = item.parent;
        }
        while(item);

        return true;
    }
});

/**
 * Sets a mask for the displayObject. A mask is an object that limits the visibility of an object to the shape of the mask applied to it.
 * In PIXI a regular mask must be a PIXI.Graphics object. This allows for much faster masking in canvas as it utilises shape clipping.
 * To remove a mask, set this property to null.
 *
 * @property mask
 * @type Graphics
 */
Object.defineProperty(PIXI.DisplayObject.prototype, 'mask', {
    get: function() {
        return this._mask;
    },
    set: function(value) {

        if(this._mask)this._mask.isMask = false;
        this._mask = value;
        if(this._mask)this._mask.isMask = true;
    }
});

/**
 * Sets the filters for the displayObject.
 * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.
 * To remove filters simply set this property to 'null'
 * @property filters
 * @type Array An array of filters
 */
Object.defineProperty(PIXI.DisplayObject.prototype, 'filters', {
    get: function() {
        return this._filters;
    },
    set: function(value) {

        if(value)
        {
            // now put all the passes in one place..
            var passes = [];
            for (var i = 0; i < value.length; i++)
            {
                var filterPasses = value[i].passes;
                for (var j = 0; j < filterPasses.length; j++)
                {
                    passes.push(filterPasses[j]);
                }
            }

            // TODO change this as it is legacy
            this._filterBlock = {target:this, filterPasses:passes};
        }

        this._filters = value;
    }
});

/**
 * Set weather or not a the display objects is cached as a bitmap.
 * This basically takes a snap shot of the display object as it is at that moment. It can provide a performance benefit for complex static displayObjects
 * To remove filters simply set this property to 'null'
 * @property cacheAsBitmap
 * @type Boolean
 */
Object.defineProperty(PIXI.DisplayObject.prototype, 'cacheAsBitmap', {
    get: function() {
        return  this._cacheAsBitmap;
    },
    set: function(value) {

        if(this._cacheAsBitmap === value)return;

        if(value)
        {
            //this._cacheIsDirty = true;
            this._generateCachedSprite();
        }
        else
        {
            this._destroyCachedSprite();
        }

        this._cacheAsBitmap = value;
    }
});

/*
 * Updates the object transform for rendering
 *
 * @method updateTransform
 * @private
 */
PIXI.DisplayObject.prototype.updateTransform = function()
{
    // TODO OPTIMIZE THIS!! with dirty
    if(this.rotation !== this.rotationCache)
    {

        this.rotationCache = this.rotation;
        this._sr =  Math.sin(this.rotation);
        this._cr =  Math.cos(this.rotation);
    }

   // var localTransform = this.localTransform//.toArray();
    var parentTransform = this.parent.worldTransform;//.toArray();
    var worldTransform = this.worldTransform;//.toArray();

    var px = this.pivot.x;
    var py = this.pivot.y;

    var a00 = this._cr * this.scale.x,
        a01 = -this._sr * this.scale.y,
        a10 = this._sr * this.scale.x,
        a11 = this._cr * this.scale.y,
        a02 = this.position.x - a00 * px - py * a01,
        a12 = this.position.y - a11 * py - px * a10,
        b00 = parentTransform.a, b01 = parentTransform.b,
        b10 = parentTransform.c, b11 = parentTransform.d;

    worldTransform.a = b00 * a00 + b01 * a10;
    worldTransform.b = b00 * a01 + b01 * a11;
    worldTransform.tx = b00 * a02 + b01 * a12 + parentTransform.tx;

    worldTransform.c = b10 * a00 + b11 * a10;
    worldTransform.d = b10 * a01 + b11 * a11;
    worldTransform.ty = b10 * a02 + b11 * a12 + parentTransform.ty;

    this.worldAlpha = this.alpha * this.parent.worldAlpha;
};

/**
 * Retrieves the bounds of the displayObject as a rectangle object
 *
 * @method getBounds
 * @return {Rectangle} the rectangular bounding area
 */
PIXI.DisplayObject.prototype.getBounds = function( matrix )
{
    matrix = matrix;//just to get passed js hinting (and preserve inheritance)
    return PIXI.EmptyRectangle;
};

/**
 * Retrieves the local bounds of the displayObject as a rectangle object
 *
 * @method getLocalBounds
 * @return {Rectangle} the rectangular bounding area
 */
PIXI.DisplayObject.prototype.getLocalBounds = function()
{
    return this.getBounds(PIXI.identityMatrix);///PIXI.EmptyRectangle();
};


/**
 * Sets the object's stage reference, the stage this object is connected to
 *
 * @method setStageReference
 * @param stage {Stage} the stage that the object will have as its current stage reference
 */
PIXI.DisplayObject.prototype.setStageReference = function(stage)
{
    this.stage = stage;
    if(this._interactive)this.stage.dirty = true;
};

PIXI.DisplayObject.prototype.generateTexture = function(renderer)
{
    var bounds = this.getLocalBounds();

    var renderTexture = new PIXI.RenderTexture(bounds.width | 0, bounds.height | 0, renderer);
    renderTexture.render(this, new PIXI.Point(-bounds.x, -bounds.y) );

    return renderTexture;
};

PIXI.DisplayObject.prototype.updateCache = function()
{
    this._generateCachedSprite();
};

PIXI.DisplayObject.prototype._renderCachedSprite = function(renderSession)
{
    this._cachedSprite.worldAlpha = this.worldAlpha;
   
    if(renderSession.gl)
    {
        PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession);
    }
    else
    {
        PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, renderSession);
    }
};

PIXI.DisplayObject.prototype._generateCachedSprite = function()//renderSession)
{
    this._cacheAsBitmap = false;
    var bounds = this.getLocalBounds();
   
    if(!this._cachedSprite)
    {
        var renderTexture = new PIXI.RenderTexture(bounds.width | 0, bounds.height | 0);//, renderSession.renderer);
        
        this._cachedSprite = new PIXI.Sprite(renderTexture);
        this._cachedSprite.worldTransform = this.worldTransform;
    }
    else
    {
        this._cachedSprite.texture.resize(bounds.width | 0, bounds.height | 0);
    }

    //REMOVE filter!
    var tempFilters = this._filters;
    this._filters = null;

    this._cachedSprite.filters = tempFilters;
    this._cachedSprite.texture.render(this, new PIXI.Point(-bounds.x, -bounds.y) );

    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );
    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );

    this._filters = tempFilters;

    this._cacheAsBitmap = true;
};

/**
* Renders the object using the WebGL renderer
*
* @method _renderWebGL
* @param renderSession {RenderSession} 
* @private
*/
PIXI.DisplayObject.prototype._destroyCachedSprite = function()
{
    if(!this._cachedSprite)return;

    this._cachedSprite.texture.destroy(true);
  //  console.log("DESTROY")
    // let the gc collect the unused sprite
    // TODO could be object pooled!
    this._cachedSprite = null;
};


PIXI.DisplayObject.prototype._renderWebGL = function(renderSession)
{
    // OVERWRITE;
    // this line is just here to pass jshinting :)
    renderSession = renderSession;
};

/**
* Renders the object using the Canvas renderer
*
* @method _renderCanvas
* @param renderSession {RenderSession} 
* @private
*/
PIXI.DisplayObject.prototype._renderCanvas = function(renderSession)
{
    // OVERWRITE;
    // this line is just here to pass jshinting :)
    renderSession = renderSession;
};

/**
 * The position of the displayObject on the x axis relative to the local coordinates of the parent.
 *
 * @property x
 * @type Number
 */
Object.defineProperty(PIXI.DisplayObject.prototype, 'x', {
    get: function() {
        return  this.position.x;
    },
    set: function(value) {
        this.position.x = value;
    }
});

/**
 * The position of the displayObject on the y axis relative to the local coordinates of the parent.
 *
 * @property y
 * @type Number
 */
Object.defineProperty(PIXI.DisplayObject.prototype, 'y', {
    get: function() {
        return  this.position.y;
    },
    set: function(value) {
        this.position.y = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */


/**
 * A DisplayObjectContainer represents a collection of display objects.
 * It is the base class of all display objects that act as a container for other objects.
 *
 * @class DisplayObjectContainer
 * @extends DisplayObject
 * @constructor
 */
PIXI.DisplayObjectContainer = function()
{
    PIXI.DisplayObject.call( this );

    /**
     * [read-only] The array of children of this container.
     *
     * @property children
     * @type Array<DisplayObject>
     * @readOnly
     */
    this.children = [];
};

// constructor
PIXI.DisplayObjectContainer.prototype = Object.create( PIXI.DisplayObject.prototype );
PIXI.DisplayObjectContainer.prototype.constructor = PIXI.DisplayObjectContainer;

/**
 * The width of the displayObjectContainer, setting this will actually modify the scale to achieve the value set
 *
 * @property width
 * @type Number
 */

 
Object.defineProperty(PIXI.DisplayObjectContainer.prototype, 'width', {
    get: function() {
        return this.scale.x * this.getLocalBounds().width;
    },
    set: function(value) {
        
        var width = this.getLocalBounds().width;

        if(width !== 0)
        {
            this.scale.x = value / ( width/this.scale.x );
        }
        else
        {
            this.scale.x = 1;
        }

        
        this._width = value;
    }
});


/**
 * The height of the displayObjectContainer, setting this will actually modify the scale to achieve the value set
 *
 * @property height
 * @type Number
 */

Object.defineProperty(PIXI.DisplayObjectContainer.prototype, 'height', {
    get: function() {
        return  this.scale.y * this.getLocalBounds().height;
    },
    set: function(value) {

        var height = this.getLocalBounds().height;

        if(height !== 0)
        {
            this.scale.y = value / ( height/this.scale.y );
        }
        else
        {
            this.scale.y = 1;
        }

        this._height = value;
    }
});


/**
 * Adds a child to the container.
 *
 * @method addChild
 * @param child {DisplayObject} The DisplayObject to add to the container
 */
PIXI.DisplayObjectContainer.prototype.addChild = function(child)
{
    return this.addChildAt(child, this.children.length);
};

/**
 * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown
 *
 * @method addChildAt
 * @param child {DisplayObject} The child to add
 * @param index {Number} The index to place the child in
 */
PIXI.DisplayObjectContainer.prototype.addChildAt = function(child, index)
{
    if(index >= 0 && index <= this.children.length)
    {
        if(child.parent)
        {
            child.parent.removeChild(child);
        }

        child.parent = this;

        this.children.splice(index, 0, child);

        if(this.stage)child.setStageReference(this.stage);

        return child;
    }
    else
    {
        throw new Error(child + ' The index '+ index +' supplied is out of bounds ' + this.children.length);
    }
};

/**
 * [NYI] Swaps the depth of 2 displayObjects
 *
 * @method swapChildren
 * @param child {DisplayObject}
 * @param child2 {DisplayObject}
 * @private
 */
PIXI.DisplayObjectContainer.prototype.swapChildren = function(child, child2)
{
    if(child === child2) {
        return;
    }

    var index1 = this.children.indexOf(child);
    var index2 = this.children.indexOf(child2);

    if(index1 < 0 || index2 < 0) {
        throw new Error('swapChildren: Both the supplied DisplayObjects must be a child of the caller.');
    }

    this.children[index1] = child2;
    this.children[index2] = child;
    
};

/**
 * Returns the child at the specified index
 *
 * @method getChildAt
 * @param index {Number} The index to get the child from
 */
PIXI.DisplayObjectContainer.prototype.getChildAt = function(index)
{
    if(index >= 0 && index < this.children.length)
    {
        return this.children[index];
    }
    else
    {
        throw new Error('Supplied index does not exist in the child list, or the supplied DisplayObject must be a child of the caller');
    }
};

/**
 * Removes a child from the container.
 *
 * @method removeChild
 * @param child {DisplayObject} The DisplayObject to remove
 */
PIXI.DisplayObjectContainer.prototype.removeChild = function(child)
{
    return this.removeChildAt( this.children.indexOf( child ) );
};

/**
 * Removes a child from the specified index position in the child list of the container.
 *
 * @method removeChildAt
 * @param index {Number} The index to get the child from
 */
PIXI.DisplayObjectContainer.prototype.removeChildAt = function(index)
{
    var child = this.getChildAt( index );
    if(this.stage)
        child.removeStageReference();

    child.parent = undefined;
    this.children.splice( index, 1 );
    return child;
};

/**
* Removes all child instances from the child list of the container.
*
* @method removeChildren
* @param beginIndex {Number} The beginning position. Predefined value is 0.
* @param endIndex {Number} The ending position. Predefined value is children's array length.
*/
PIXI.DisplayObjectContainer.prototype.removeChildren = function(beginIndex, endIndex)
{
    var begin = beginIndex || 0;
    var end = typeof endIndex === 'number' ? endIndex : this.children.length;
    var range = end - begin;

    if (range > 0 && range <= end)
    {
        var removed = this.children.splice(begin, range);
        for (var i = 0; i < removed.length; i++) {
            var child = removed[i];
            if(this.stage)
                child.removeStageReference();
            child.parent = undefined;
        }
        return removed;
    }
    else
    {
        throw new Error( 'Range Error, numeric values are outside the acceptable range' );
    }
};

/*
 * Updates the container's childrens transform for rendering
 *
 * @method updateTransform
 * @private
 */
PIXI.DisplayObjectContainer.prototype.updateTransform = function()
{
    //this._currentBounds = null;

    if(!this.visible)return;

    PIXI.DisplayObject.prototype.updateTransform.call( this );

    if(this._cacheAsBitmap)return;

    for(var i=0,j=this.children.length; i<j; i++)
    {
        this.children[i].updateTransform();
    }
};

/**
 * Retrieves the bounds of the displayObjectContainer as a rectangle object
 *
 * @method getBounds
 * @return {Rectangle} the rectangular bounding area
 */
PIXI.DisplayObjectContainer.prototype.getBounds = function(matrix)
{
    if(this.children.length === 0)return PIXI.EmptyRectangle;

    // TODO the bounds have already been calculated this render session so return what we have
    if(matrix)
    {
        var matrixCache = this.worldTransform;
        this.worldTransform = matrix;
        this.updateTransform();
        this.worldTransform = matrixCache;
    }

    var minX = Infinity;
    var minY = Infinity;

    var maxX = -Infinity;
    var maxY = -Infinity;

    var childBounds;
    var childMaxX;
    var childMaxY;

    var childVisible = false;

    for(var i=0,j=this.children.length; i<j; i++)
    {
        var child = this.children[i];
        
        if(!child.visible)continue;

        childVisible = true;

        childBounds = this.children[i].getBounds( matrix );
     
        minX = minX < childBounds.x ? minX : childBounds.x;
        minY = minY < childBounds.y ? minY : childBounds.y;

        childMaxX = childBounds.width + childBounds.x;
        childMaxY = childBounds.height + childBounds.y;

        maxX = maxX > childMaxX ? maxX : childMaxX;
        maxY = maxY > childMaxY ? maxY : childMaxY;
    }

    if(!childVisible)
        return PIXI.EmptyRectangle;

    var bounds = this._bounds;

    bounds.x = minX;
    bounds.y = minY;
    bounds.width = maxX - minX;
    bounds.height = maxY - minY;

    // TODO: store a reference so that if this function gets called again in the render cycle we do not have to recalculate
    //this._currentBounds = bounds;
   
    return bounds;
};

PIXI.DisplayObjectContainer.prototype.getLocalBounds = function()
{
    var matrixCache = this.worldTransform;

    this.worldTransform = PIXI.identityMatrix;

    for(var i=0,j=this.children.length; i<j; i++)
    {
        this.children[i].updateTransform();
    }

    var bounds = this.getBounds();

    this.worldTransform = matrixCache;

    return bounds;
};

/**
 * Sets the container's stage reference, the stage this object is connected to
 *
 * @method setStageReference
 * @param stage {Stage} the stage that the container will have as its current stage reference
 */
PIXI.DisplayObjectContainer.prototype.setStageReference = function(stage)
{
    this.stage = stage;
    if(this._interactive)this.stage.dirty = true;

    for(var i=0,j=this.children.length; i<j; i++)
    {
        var child = this.children[i];
        child.setStageReference(stage);
    }
};

/**
 * removes the current stage reference of the container
 *
 * @method removeStageReference
 */
PIXI.DisplayObjectContainer.prototype.removeStageReference = function()
{

    for(var i=0,j=this.children.length; i<j; i++)
    {
        var child = this.children[i];
        child.removeStageReference();
    }

    if(this._interactive)this.stage.dirty = true;
    
    this.stage = null;
};

/**
* Renders the object using the WebGL renderer
*
* @method _renderWebGL
* @param renderSession {RenderSession} 
* @private
*/
PIXI.DisplayObjectContainer.prototype._renderWebGL = function(renderSession)
{
    if(!this.visible || this.alpha <= 0)return;
    
    if(this._cacheAsBitmap)
    {
        this._renderCachedSprite(renderSession);
        return;
    }
    
    var i,j;

    if(this._mask || this._filters)
    {
        
        // push filter first as we need to ensure the stencil buffer is correct for any masking
        if(this._filters)
        {
            renderSession.spriteBatch.flush();
            renderSession.filterManager.pushFilter(this._filterBlock);
        }

        if(this._mask)
        {
            renderSession.spriteBatch.stop();
            renderSession.maskManager.pushMask(this.mask, renderSession);
            renderSession.spriteBatch.start();
        }

        // simple render children!
        for(i=0,j=this.children.length; i<j; i++)
        {
            this.children[i]._renderWebGL(renderSession);
        }

        renderSession.spriteBatch.stop();

        if(this._mask)renderSession.maskManager.popMask(this._mask, renderSession);
        if(this._filters)renderSession.filterManager.popFilter();
        
        renderSession.spriteBatch.start();
    }
    else
    {
        // simple render children!
        for(i=0,j=this.children.length; i<j; i++)
        {
            this.children[i]._renderWebGL(renderSession);
        }
    }
};

/**
* Renders the object using the Canvas renderer
*
* @method _renderCanvas
* @param renderSession {RenderSession} 
* @private
*/
PIXI.DisplayObjectContainer.prototype._renderCanvas = function(renderSession)
{
    if(this.visible === false || this.alpha === 0)return;

    if(this._cacheAsBitmap)
    {

        this._renderCachedSprite(renderSession);
        return;
    }

    if(this._mask)
    {
        renderSession.maskManager.pushMask(this._mask, renderSession.context);
    }

    for(var i=0,j=this.children.length; i<j; i++)
    {
        var child = this.children[i];
        child._renderCanvas(renderSession);
    }

    if(this._mask)
    {
        renderSession.maskManager.popMask(renderSession.context);
    }
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The Sprite object is the base for all textured objects that are rendered to the screen
 *
 * @class Sprite
 * @extends DisplayObjectContainer
 * @constructor
 * @param texture {Texture} The texture for this sprite
 * 
 * A sprite can be created directly from an image like this : 
 * var sprite = new PIXI.Sprite.fromImage('assets/image.png');
 * yourStage.addChild(sprite);
 * then obviously don't forget to add it to the stage you have already created
 */
PIXI.Sprite = function(texture)
{
    PIXI.DisplayObjectContainer.call( this );

    /**
     * The anchor sets the origin point of the texture.
     * The default is 0,0 this means the texture's origin is the top left
     * Setting than anchor to 0.5,0.5 means the textures origin is centred
     * Setting the anchor to 1,1 would mean the textures origin points will be the bottom right corner
     *
     * @property anchor
     * @type Point
     */
    this.anchor = new PIXI.Point();

    /**
     * The texture that the sprite is using
     *
     * @property texture
     * @type Texture
     */
    this.texture = texture;

    /**
     * The width of the sprite (this is initially set by the texture)
     *
     * @property _width
     * @type Number
     * @private
     */
    this._width = 0;

    /**
     * The height of the sprite (this is initially set by the texture)
     *
     * @property _height
     * @type Number
     * @private
     */
    this._height = 0;


    /**
     * The tint applied to the sprite. This is a hex value
     *
     * @property tint
     * @type Number
     * @default 0xFFFFFF
     */
    this.tint = 0xFFFFFF;// * Math.random();
    
    /**
     * The blend mode to be applied to the sprite
     *
     * @property blendMode
     * @type Number
     * @default PIXI.blendModes.NORMAL;
     */
    this.blendMode = PIXI.blendModes.NORMAL;

    if(texture.baseTexture.hasLoaded)
    {
        this.onTextureUpdate();
    }
    else
    {
        this.onTextureUpdateBind = this.onTextureUpdate.bind(this);
        this.texture.addEventListener( 'update', this.onTextureUpdateBind );
    }

    this.renderable = true;
};

// constructor
PIXI.Sprite.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );
PIXI.Sprite.prototype.constructor = PIXI.Sprite;

/**
 * The width of the sprite, setting this will actually modify the scale to achieve the value set
 *
 * @property width
 * @type Number
 */
Object.defineProperty(PIXI.Sprite.prototype, 'width', {
    get: function() {
        return this.scale.x * this.texture.frame.width;
    },
    set: function(value) {
        this.scale.x = value / this.texture.frame.width;
        this._width = value;
    }
});

/**
 * The height of the sprite, setting this will actually modify the scale to achieve the value set
 *
 * @property height
 * @type Number
 */
Object.defineProperty(PIXI.Sprite.prototype, 'height', {
    get: function() {
        return  this.scale.y * this.texture.frame.height;
    },
    set: function(value) {
        this.scale.y = value / this.texture.frame.height;
        this._height = value;
    }
});

/**
 * Sets the texture of the sprite
 *
 * @method setTexture
 * @param texture {Texture} The PIXI texture that is displayed by the sprite
 */
PIXI.Sprite.prototype.setTexture = function(texture)
{
    this.texture = texture;
    this.cachedTint = 0xFFFFFF;
};

/**
 * When the texture is updated, this event will fire to update the scale and frame
 *
 * @method onTextureUpdate
 * @param event
 * @private
 */
PIXI.Sprite.prototype.onTextureUpdate = function()
{
    // so if _width is 0 then width was not set..
    if(this._width)this.scale.x = this._width / this.texture.frame.width;
    if(this._height)this.scale.y = this._height / this.texture.frame.height;


    //this.updateFrame = true;
};

/**
* Returns the framing rectangle of the sprite as a PIXI.Rectangle object
*
* @method getBounds
* @param matrix {Matrix} the transformation matrix of the sprite
* @return {Rectangle} the framing rectangle
*/
PIXI.Sprite.prototype.getBounds = function(matrix)
{

    var width = this.texture.frame.width;
    var height = this.texture.frame.height;

    var w0 = width * (1-this.anchor.x);
    var w1 = width * -this.anchor.x;

    var h0 = height * (1-this.anchor.y);
    var h1 = height * -this.anchor.y;

    var worldTransform = matrix || this.worldTransform ;

    var a = worldTransform.a;
    var b = worldTransform.c;
    var c = worldTransform.b;
    var d = worldTransform.d;
    var tx = worldTransform.tx;
    var ty = worldTransform.ty;

    var x1 = a * w1 + c * h1 + tx;
    var y1 = d * h1 + b * w1 + ty;

    var x2 = a * w0 + c * h1 + tx;
    var y2 = d * h1 + b * w0 + ty;

    var x3 = a * w0 + c * h0 + tx;
    var y3 = d * h0 + b * w0 + ty;

    var x4 =  a * w1 + c * h0 + tx;
    var y4 =  d * h0 + b * w1 + ty;

    var maxX = -Infinity;
    var maxY = -Infinity;

    var minX = Infinity;
    var minY = Infinity;

    minX = x1 < minX ? x1 : minX;
    minX = x2 < minX ? x2 : minX;
    minX = x3 < minX ? x3 : minX;
    minX = x4 < minX ? x4 : minX;

    minY = y1 < minY ? y1 : minY;
    minY = y2 < minY ? y2 : minY;
    minY = y3 < minY ? y3 : minY;
    minY = y4 < minY ? y4 : minY;

    maxX = x1 > maxX ? x1 : maxX;
    maxX = x2 > maxX ? x2 : maxX;
    maxX = x3 > maxX ? x3 : maxX;
    maxX = x4 > maxX ? x4 : maxX;

    maxY = y1 > maxY ? y1 : maxY;
    maxY = y2 > maxY ? y2 : maxY;
    maxY = y3 > maxY ? y3 : maxY;
    maxY = y4 > maxY ? y4 : maxY;

    var bounds = this._bounds;

    bounds.x = minX;
    bounds.width = maxX - minX;

    bounds.y = minY;
    bounds.height = maxY - minY;

    // store a reference so that if this function gets called again in the render cycle we do not have to recalculate
    this._currentBounds = bounds;

    return bounds;
};

/**
* Renders the object using the WebGL renderer
*
* @method _renderWebGL
* @param renderSession {RenderSession} 
* @private
*/
PIXI.Sprite.prototype._renderWebGL = function(renderSession)
{
    // if the sprite is not visible or the alpha is 0 then no need to render this element
    if(!this.visible || this.alpha <= 0)return;
    
    var i,j;

    // do a quick check to see if this element has a mask or a filter.
    if(this._mask || this._filters)
    {
        var spriteBatch =  renderSession.spriteBatch;

        // push filter first as we need to ensure the stencil buffer is correct for any masking
        if(this._filters)
        {
            spriteBatch.flush();
            renderSession.filterManager.pushFilter(this._filterBlock);
        }

        if(this._mask)
        {
            spriteBatch.stop();
            renderSession.maskManager.pushMask(this.mask, renderSession);
            spriteBatch.start();
        }

        // add this sprite to the batch
        spriteBatch.render(this);

        // now loop through the children and make sure they get rendered
        for(i=0,j=this.children.length; i<j; i++)
        {
            this.children[i]._renderWebGL(renderSession);
        }

        // time to stop the sprite batch as either a mask element or a filter draw will happen next
        spriteBatch.stop();

        if(this._mask)renderSession.maskManager.popMask(this._mask, renderSession);
        if(this._filters)renderSession.filterManager.popFilter();
        
        spriteBatch.start();
    }
    else
    {
        renderSession.spriteBatch.render(this);

        // simple render children!
        for(i=0,j=this.children.length; i<j; i++)
        {
            this.children[i]._renderWebGL(renderSession);
        }
    }

   
    //TODO check culling  
};

/**
* Renders the object using the Canvas renderer
*
* @method _renderCanvas
* @param renderSession {RenderSession} 
* @private
*/
PIXI.Sprite.prototype._renderCanvas = function(renderSession)
{
    // If the sprite is not visible or the alpha is 0 then no need to render this element
    if (this.visible === false || this.alpha === 0) return;
    
    if (this.blendMode !== renderSession.currentBlendMode)
    {
        renderSession.currentBlendMode = this.blendMode;
        renderSession.context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];
    }

    if (this._mask)
    {
        renderSession.maskManager.pushMask(this._mask, renderSession.context);
    }

    //  Ignore null sources
    if (this.texture.valid)
    {
        renderSession.context.globalAlpha = this.worldAlpha;

        //  Allow for pixel rounding
        if (renderSession.roundPixels)
        {
            renderSession.context.setTransform(
                this.worldTransform.a,
                this.worldTransform.c,
                this.worldTransform.b,
                this.worldTransform.d,
                this.worldTransform.tx | 0,
                this.worldTransform.ty | 0);
        }
        else
        {
            renderSession.context.setTransform(
                this.worldTransform.a,
                this.worldTransform.c,
                this.worldTransform.b,
                this.worldTransform.d,
                this.worldTransform.tx,
                this.worldTransform.ty);
        }

        //  If smoothingEnabled is supported and we need to change the smoothing property for this texture
        if (renderSession.smoothProperty && renderSession.scaleMode !== this.texture.baseTexture.scaleMode)
        {
            renderSession.scaleMode = this.texture.baseTexture.scaleMode;
            renderSession.context[renderSession.smoothProperty] = (renderSession.scaleMode === PIXI.scaleModes.LINEAR);
        }

        //  If the texture is trimmed we offset by the trim x/y, otherwise we use the frame dimensions
        var dx = (this.texture.trim) ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width;
        var dy = (this.texture.trim) ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height;

        if (this.tint !== 0xFFFFFF)
        {
            if (this.cachedTint !== this.tint)
            {
                this.cachedTint = this.tint;
                
                //  TODO clean up caching - how to clean up the caches?
                this.tintedTexture = PIXI.CanvasTinter.getTintedTexture(this, this.tint);
            }

            renderSession.context.drawImage(
                                this.tintedTexture,
                                0,
                                0,
                                this.texture.crop.width,
                                this.texture.crop.height,
                                dx,
                                dy,
                                this.texture.crop.width,
                                this.texture.crop.height);
        }
        else
        {
            renderSession.context.drawImage(
                                this.texture.baseTexture.source,
                                this.texture.crop.x,
                                this.texture.crop.y,
                                this.texture.crop.width,
                                this.texture.crop.height,
                                dx,
                                dy,
                                this.texture.crop.width,
                                this.texture.crop.height);
        }
    }

    // OVERWRITE
    for (var i = 0, j = this.children.length; i < j; i++)
    {
        this.children[i]._renderCanvas(renderSession);
    }

    if (this._mask)
    {
        renderSession.maskManager.popMask(renderSession.context);
    }
};

// some helper functions..

/**
 *
 * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
 * The frame ids are created when a Texture packer file has been loaded
 *
 * @method fromFrame
 * @static
 * @param frameId {String} The frame Id of the texture in the cache
 * @return {Sprite} A new Sprite using a texture from the texture cache matching the frameId
 */
PIXI.Sprite.fromFrame = function(frameId)
{
    var texture = PIXI.TextureCache[frameId];
    if(!texture) throw new Error('The frameId "' + frameId + '" does not exist in the texture cache' + this);
    return new PIXI.Sprite(texture);
};

/**
 *
 * Helper function that creates a sprite that will contain a texture based on an image url
 * If the image is not in the texture cache it will be loaded
 *
 * @method fromImage
 * @static
 * @param imageId {String} The image url of the texture
 * @return {Sprite} A new Sprite using a texture from the texture cache matching the image id
 */
PIXI.Sprite.fromImage = function(imageId, crossorigin, scaleMode)
{
    var texture = PIXI.Texture.fromImage(imageId, crossorigin, scaleMode);
    return new PIXI.Sprite(texture);
};

/**
 * @author Mat Groves http://matgroves.com/
 */

/**
 * The SpriteBatch class is a really fast version of the DisplayObjectContainer 
 * built solely for speed, so use when you need a lot of sprites or particles.
 * And it's extremely easy to use : 

    var container = new PIXI.SpriteBatch();
 
    stage.addChild(container);
 
    for(var i  = 0; i < 100; i++)
    {
        var sprite = new PIXI.Sprite.fromImage("myImage.png");
        container.addChild(sprite);
    }
 * And here you have a hundred sprites that will be renderer at the speed of light
 *
 * @class SpriteBatch
 * @constructor
 * @param texture {Texture}
 */
PIXI.SpriteBatch = function(texture)
{
    PIXI.DisplayObjectContainer.call( this);

    this.textureThing = texture;

    this.ready = false;
};

PIXI.SpriteBatch.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
PIXI.SpriteBatch.constructor = PIXI.SpriteBatch;

/*
 * Initialises the spriteBatch
 *
 * @method initWebGL
 * @param gl {WebGLContext} the current WebGL drawing context
 */
PIXI.SpriteBatch.prototype.initWebGL = function(gl)
{
    // TODO only one needed for the whole engine really?
    this.fastSpriteBatch = new PIXI.WebGLFastSpriteBatch(gl);

    this.ready = true;
};

/*
 * Updates the object transform for rendering
 *
 * @method updateTransform
 * @private
 */
PIXI.SpriteBatch.prototype.updateTransform = function()
{
   // TODO dont need to!
    PIXI.DisplayObject.prototype.updateTransform.call( this );
  //  PIXI.DisplayObjectContainer.prototype.updateTransform.call( this );
};

/**
* Renders the object using the WebGL renderer
*
* @method _renderWebGL
* @param renderSession {RenderSession} 
* @private
*/
PIXI.SpriteBatch.prototype._renderWebGL = function(renderSession)
{
    if(!this.visible || this.alpha <= 0 || !this.children.length)return;

    if(!this.ready)this.initWebGL( renderSession.gl );
    
    renderSession.spriteBatch.stop();
    
    renderSession.shaderManager.setShader(renderSession.shaderManager.fastShader);
    
    this.fastSpriteBatch.begin(this, renderSession);
    this.fastSpriteBatch.render(this);

    renderSession.spriteBatch.start();
 
};

/**
* Renders the object using the Canvas renderer
*
* @method _renderCanvas
* @param renderSession {RenderSession} 
* @private
*/
PIXI.SpriteBatch.prototype._renderCanvas = function(renderSession)
{
    var context = renderSession.context;
    context.globalAlpha = this.worldAlpha;

    PIXI.DisplayObject.prototype.updateTransform.call(this);

    var transform = this.worldTransform;
    // alow for trimming
       
    var isRotated = true;

    for (var i = 0; i < this.children.length; i++) {
       
        var child = this.children[i];

        if(!child.visible)continue;

        var texture = child.texture;
        var frame = texture.frame;

        context.globalAlpha = this.worldAlpha * child.alpha;

        if(child.rotation % (Math.PI * 2) === 0)
        {
            if(isRotated)
            {
                context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);
                isRotated = false;
            }

            // this is the fastest  way to optimise! - if rotation is 0 then we can avoid any kind of setTransform call
            context.drawImage(texture.baseTexture.source,
                                 frame.x,
                                 frame.y,
                                 frame.width,
                                 frame.height,
                                 ((child.anchor.x) * (-frame.width * child.scale.x) + child.position.x  + 0.5) | 0,
                                 ((child.anchor.y) * (-frame.height * child.scale.y) + child.position.y  + 0.5) | 0,
                                 frame.width * child.scale.x,
                                 frame.height * child.scale.y);
        }
        else
        {
            if(!isRotated)isRotated = true;
    
            PIXI.DisplayObject.prototype.updateTransform.call(child);
           
            var childTransform = child.worldTransform;

            // allow for trimming
           
            if (renderSession.roundPixels)
            {
                context.setTransform(childTransform.a, childTransform.c, childTransform.b, childTransform.d, childTransform.tx | 0, childTransform.ty | 0);
            }
            else
            {
                context.setTransform(childTransform.a, childTransform.c, childTransform.b, childTransform.d, childTransform.tx, childTransform.ty);
            }

            context.drawImage(texture.baseTexture.source,
                                 frame.x,
                                 frame.y,
                                 frame.width,
                                 frame.height,
                                 ((child.anchor.x) * (-frame.width) + 0.5) | 0,
                                 ((child.anchor.y) * (-frame.height) + 0.5) | 0,
                                 frame.width,
                                 frame.height);
           

        }

       // context.restore();
    }

//    context.restore();
};


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * A MovieClip is a simple way to display an animation depicted by a list of textures.
 *
 * @class MovieClip
 * @extends Sprite
 * @constructor
 * @param textures {Array<Texture>} an array of {Texture} objects that make up the animation
 */
PIXI.MovieClip = function(textures)
{
    PIXI.Sprite.call(this, textures[0]);

    /**
     * The array of textures that make up the animation
     *
     * @property textures
     * @type Array
     */
    this.textures = textures;

    /**
     * The speed that the MovieClip will play at. Higher is faster, lower is slower
     *
     * @property animationSpeed
     * @type Number
     * @default 1
     */
    this.animationSpeed = 1;

    /**
     * Whether or not the movie clip repeats after playing.
     *
     * @property loop
     * @type Boolean
     * @default true
     */
    this.loop = true;

    /**
     * Function to call when a MovieClip finishes playing
     *
     * @property onComplete
     * @type Function
     */
    this.onComplete = null;

    /**
     * [read-only] The MovieClips current frame index (this may not have to be a whole number)
     *
     * @property currentFrame
     * @type Number
     * @default 0
     * @readOnly
     */
    this.currentFrame = 0;

    /**
     * [read-only] Indicates if the MovieClip is currently playing
     *
     * @property playing
     * @type Boolean
     * @readOnly
     */
    this.playing = false;
};

// constructor
PIXI.MovieClip.prototype = Object.create( PIXI.Sprite.prototype );
PIXI.MovieClip.prototype.constructor = PIXI.MovieClip;

/**
* [read-only] totalFrames is the total number of frames in the MovieClip. This is the same as number of textures
* assigned to the MovieClip.
*
* @property totalFrames
* @type Number
* @default 0
* @readOnly
*/
Object.defineProperty( PIXI.MovieClip.prototype, 'totalFrames', {
	get: function() {

		return this.textures.length;
	}
});


/**
 * Stops the MovieClip
 *
 * @method stop
 */
PIXI.MovieClip.prototype.stop = function()
{
    this.playing = false;
};

/**
 * Plays the MovieClip
 *
 * @method play
 */
PIXI.MovieClip.prototype.play = function()
{
    this.playing = true;
};

/**
 * Stops the MovieClip and goes to a specific frame
 *
 * @method gotoAndStop
 * @param frameNumber {Number} frame index to stop at
 */
PIXI.MovieClip.prototype.gotoAndStop = function(frameNumber)
{
    this.playing = false;
    this.currentFrame = frameNumber;
    var round = (this.currentFrame + 0.5) | 0;
    this.setTexture(this.textures[round % this.textures.length]);
};

/**
 * Goes to a specific frame and begins playing the MovieClip
 *
 * @method gotoAndPlay
 * @param frameNumber {Number} frame index to start at
 */
PIXI.MovieClip.prototype.gotoAndPlay = function(frameNumber)
{
    this.currentFrame = frameNumber;
    this.playing = true;
};

/*
 * Updates the object transform for rendering
 *
 * @method updateTransform
 * @private
 */
PIXI.MovieClip.prototype.updateTransform = function()
{
    PIXI.Sprite.prototype.updateTransform.call(this);

    if(!this.playing)return;

    this.currentFrame += this.animationSpeed;

    var round = (this.currentFrame + 0.5) | 0;

    this.currentFrame = this.currentFrame % this.textures.length;

    if(this.loop || round < this.textures.length)
    {
        this.setTexture(this.textures[round % this.textures.length]);
    }
    else if(round >= this.textures.length)
    {
        this.gotoAndStop(this.textures.length - 1);
        if(this.onComplete)
        {
            this.onComplete();
        }
    }
};

/**
 * A short hand way of creating a movieclip from an array of frame ids
 *
 * @static
 * @method fromFrames
 * @param frames {Array} the array of frames ids the movieclip will use as its texture frames
 */
PIXI.MovieClip.fromFrames = function(frames)
{
    var textures = [];

    for (var i = 0; i < frames.length; i++)
    {
        textures.push(new PIXI.Texture.fromFrame(frames[i]));
    }

    return new PIXI.MovieClip(textures);
};

/**
 * A short hand way of creating a movieclip from an array of image ids
 *
 * @static
 * @method fromFrames
 * @param frames {Array} the array of image ids the movieclip will use as its texture frames
 */
PIXI.MovieClip.fromImages = function(images)
{
    var textures = [];

    for (var i = 0; i < images.length; i++)
    {
        textures.push(new PIXI.Texture.fromImage(images[i]));
    }

    return new PIXI.MovieClip(textures);
};
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */


PIXI.FilterBlock = function()
{
    this.visible = true;
    this.renderable = true;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 * - Modified by Tom Slezakowski http://www.tomslezakowski.com @TomSlezakowski (24/03/2014) - Added dropShadowColor.
 */

/**
 * A Text Object will create a line(s) of text. To split a line you can use '\n' 
 * or add a wordWrap property set to true and and wordWrapWidth property with a value
 * in the style object
 *
 * @class Text
 * @extends Sprite
 * @constructor
 * @param text {String} The copy that you would like the text to display
 * @param [style] {Object} The style parameters
 * @param [style.font] {String} default 'bold 20px Arial' The style and size of the font
 * @param [style.fill='black'] {String|Number} A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'
 * @param [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
 * @param [style.stroke] {String|Number} A canvas fillstyle that will be used on the text stroke e.g 'blue', '#FCFF00'
 * @param [style.strokeThickness=0] {Number} A number that represents the thickness of the stroke. Default is 0 (no stroke)
 * @param [style.wordWrap=false] {Boolean} Indicates if word wrap should be used
 * @param [style.wordWrapWidth=100] {Number} The width at which text will wrap, it needs wordWrap to be set to true
 * @param [style.dropShadow=false] {Boolean} Set a drop shadow for the text
 * @param [style.dropShadowColor='#000000'] {String} A fill style to be used on the dropshadow e.g 'red', '#00FF00'
 * @param [style.dropShadowAngle=Math.PI/4] {Number} Set a angle of the drop shadow
 * @param [style.dropShadowDistance=5] {Number} Set a distance of the drop shadow
 */
PIXI.Text = function(text, style)
{
    /**
     * The canvas element that everything is drawn to
     *
     * @property canvas
     * @type HTMLCanvasElement
     */
    this.canvas = document.createElement('canvas');

    /**
     * The canvas 2d context that everything is drawn with
     * @property context
     * @type HTMLCanvasElement 2d Context
     */
    this.context = this.canvas.getContext('2d');

    PIXI.Sprite.call(this, PIXI.Texture.fromCanvas(this.canvas));

    this.setText(text);
    this.setStyle(style);
};

// constructor
PIXI.Text.prototype = Object.create(PIXI.Sprite.prototype);
PIXI.Text.prototype.constructor = PIXI.Text;


/**
 * The width of the sprite, setting this will actually modify the scale to achieve the value set
 *
 * @property width
 * @type Number
 */
Object.defineProperty(PIXI.Text.prototype, 'width', {
    get: function() {

        if(this.dirty)
        {
            this.updateText();
            this.dirty = false;
        }


        return this.scale.x * this.texture.frame.width;
    },
    set: function(value) {
        this.scale.x = value / this.texture.frame.width;
        this._width = value;
    }
});

/**
 * The height of the Text, setting this will actually modify the scale to achieve the value set
 *
 * @property height
 * @type Number
 */
Object.defineProperty(PIXI.Text.prototype, 'height', {
    get: function() {

        if(this.dirty)
        {
            this.updateText();
            this.dirty = false;
        }


        return  this.scale.y * this.texture.frame.height;
    },
    set: function(value) {
        this.scale.y = value / this.texture.frame.height;
        this._height = value;
    }
});


/**
 * Set the style of the text
 *
 * @method setStyle
 * @param [style] {Object} The style parameters
 * @param [style.font='bold 20pt Arial'] {String} The style and size of the font
 * @param [style.fill='black'] {Object} A canvas fillstyle that will be used on the text eg 'red', '#00FF00'
 * @param [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
 * @param [style.stroke='black'] {String} A canvas fillstyle that will be used on the text stroke eg 'blue', '#FCFF00'
 * @param [style.strokeThickness=0] {Number} A number that represents the thickness of the stroke. Default is 0 (no stroke)
 * @param [style.wordWrap=false] {Boolean} Indicates if word wrap should be used
 * @param [style.wordWrapWidth=100] {Number} The width at which text will wrap
 * @param [style.dropShadow=false] {Boolean} Set a drop shadow for the text
 * @param [style.dropShadowColor='#000000'] {String} A fill style to be used on the dropshadow e.g 'red', '#00FF00'
 * @param [style.dropShadowAngle=Math.PI/4] {Number} Set a angle of the drop shadow
 * @param [style.dropShadowDistance=5] {Number} Set a distance of the drop shadow
 */
PIXI.Text.prototype.setStyle = function(style)
{
    style = style || {};
    style.font = style.font || 'bold 20pt Arial';
    style.fill = style.fill || 'black';
    style.align = style.align || 'left';
    style.stroke = style.stroke || 'black'; //provide a default, see: https://github.com/GoodBoyDigital/pixi.js/issues/136
    style.strokeThickness = style.strokeThickness || 0;
    style.wordWrap = style.wordWrap || false;
    style.wordWrapWidth = style.wordWrapWidth || 100;
    style.wordWrapWidth = style.wordWrapWidth || 100;
    
    style.dropShadow = style.dropShadow || false;
    style.dropShadowAngle = style.dropShadowAngle || Math.PI / 6;
    style.dropShadowDistance = style.dropShadowDistance || 4;
    style.dropShadowColor = style.dropShadowColor || 'black';

    this.style = style;
    this.dirty = true;
};

/**
 * Set the copy for the text object. To split a line you can use '\n'
 *
 * @method setText
 * @param {String} text The copy that you would like the text to display
 */
PIXI.Text.prototype.setText = function(text)
{
    this.text = text.toString() || ' ';
    this.dirty = true;

};

/**
 * Renders text and updates it when needed
 *
 * @method updateText
 * @private
 */
PIXI.Text.prototype.updateText = function()
{
    this.context.font = this.style.font;

    var outputText = this.text;

    // word wrap
    // preserve original text
    if(this.style.wordWrap)outputText = this.wordWrap(this.text);

    //split text into lines
    var lines = outputText.split(/(?:\r\n|\r|\n)/);

    //calculate text width
    var lineWidths = [];
    var maxLineWidth = 0;
    for (var i = 0; i < lines.length; i++)
    {
        var lineWidth = this.context.measureText(lines[i]).width;
        lineWidths[i] = lineWidth;
        maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }

    var width = maxLineWidth + this.style.strokeThickness;
    if(this.style.dropShadow)width += this.style.dropShadowDistance;

    this.canvas.width = width + this.context.lineWidth;
    //calculate text height
    var lineHeight = this.determineFontHeight('font: ' + this.style.font  + ';') + this.style.strokeThickness;
    
    var height = lineHeight * lines.length;
    if(this.style.dropShadow)height += this.style.dropShadowDistance;

    this.canvas.height = height;

    if(navigator.isCocoonJS) this.context.clearRect(0,0,this.canvas.width,this.canvas.height);
    
    this.context.font = this.style.font;
    this.context.strokeStyle = this.style.stroke;
    this.context.lineWidth = this.style.strokeThickness;
    this.context.textBaseline = 'top';

    var linePositionX;
    var linePositionY;

    if(this.style.dropShadow)
    {
        this.context.fillStyle = this.style.dropShadowColor;

        var xShadowOffset = Math.sin(this.style.dropShadowAngle) * this.style.dropShadowDistance;
        var yShadowOffset = Math.cos(this.style.dropShadowAngle) * this.style.dropShadowDistance;

        for (i = 0; i < lines.length; i++)
        {
            linePositionX = this.style.strokeThickness / 2;
            linePositionY = this.style.strokeThickness / 2 + i * lineHeight;

            if(this.style.align === 'right')
            {
                linePositionX += maxLineWidth - lineWidths[i];
            }
            else if(this.style.align === 'center')
            {
                linePositionX += (maxLineWidth - lineWidths[i]) / 2;
            }

            if(this.style.fill)
            {
                this.context.fillText(lines[i], linePositionX + xShadowOffset, linePositionY + yShadowOffset);
            }

          //  if(dropShadow)
        }
    }

    //set canvas text styles
    this.context.fillStyle = this.style.fill;
    
    //draw lines line by line
    for (i = 0; i < lines.length; i++)
    {
        linePositionX = this.style.strokeThickness / 2;
        linePositionY = this.style.strokeThickness / 2 + i * lineHeight;

        if(this.style.align === 'right')
        {
            linePositionX += maxLineWidth - lineWidths[i];
        }
        else if(this.style.align === 'center')
        {
            linePositionX += (maxLineWidth - lineWidths[i]) / 2;
        }

        if(this.style.stroke && this.style.strokeThickness)
        {
            this.context.strokeText(lines[i], linePositionX, linePositionY);
        }

        if(this.style.fill)
        {
            this.context.fillText(lines[i], linePositionX, linePositionY);
        }

      //  if(dropShadow)
    }


    this.updateTexture();
};

/**
 * Updates texture size based on canvas size
 *
 * @method updateTexture
 * @private
 */
PIXI.Text.prototype.updateTexture = function()
{
    this.texture.baseTexture.width = this.canvas.width;
    this.texture.baseTexture.height = this.canvas.height;
    this.texture.crop.width = this.texture.frame.width = this.canvas.width;
    this.texture.crop.height = this.texture.frame.height = this.canvas.height;

    this._width = this.canvas.width;
    this._height = this.canvas.height;

    this.requiresUpdate =  true;
};

/**
* Renders the object using the WebGL renderer
*
* @method _renderWebGL
* @param renderSession {RenderSession} 
* @private
*/
PIXI.Text.prototype._renderWebGL = function(renderSession)
{
    if(this.requiresUpdate)
    {
        this.requiresUpdate = false;
        PIXI.updateWebGLTexture(this.texture.baseTexture, renderSession.gl);
    }

    PIXI.Sprite.prototype._renderWebGL.call(this, renderSession);
};

/**
 * Updates the transform of this object
 *
 * @method updateTransform
 * @private
 */
PIXI.Text.prototype.updateTransform = function()
{
    if(this.dirty)
    {
        this.updateText();
        this.dirty = false;
    }

    PIXI.Sprite.prototype.updateTransform.call(this);
};

/*
 * http://stackoverflow.com/users/34441/ellisbben
 * great solution to the problem!
 * returns the height of the given font
 *
 * @method determineFontHeight
 * @param fontStyle {Object}
 * @private
 */
PIXI.Text.prototype.determineFontHeight = function(fontStyle)
{
    // build a little reference dictionary so if the font style has been used return a
    // cached version...
    var result = PIXI.Text.heightCache[fontStyle];

    if(!result)
    {
        var body = document.getElementsByTagName('body')[0];
        var dummy = document.createElement('div');
        var dummyText = document.createTextNode('M');
        dummy.appendChild(dummyText);
        dummy.setAttribute('style', fontStyle + ';position:absolute;top:0;left:0');
        body.appendChild(dummy);

        result = dummy.offsetHeight;
        PIXI.Text.heightCache[fontStyle] = result;

        body.removeChild(dummy);
    }

    return result;
};

/**
 * Applies newlines to a string to have it optimally fit into the horizontal
 * bounds set by the Text object's wordWrapWidth property.
 *
 * @method wordWrap
 * @param text {String}
 * @private
 */
PIXI.Text.prototype.wordWrap = function(text)
{
    // Greedy wrapping algorithm that will wrap words as the line grows longer
    // than its horizontal bounds.
    var result = '';
    var lines = text.split('\n');
    for (var i = 0; i < lines.length; i++)
    {
        var spaceLeft = this.style.wordWrapWidth;
        var words = lines[i].split(' ');
        for (var j = 0; j < words.length; j++)
        {
            var wordWidth = this.context.measureText(words[j]).width;
            var wordWidthWithSpace = wordWidth + this.context.measureText(' ').width;
            if(j === 0 || wordWidthWithSpace > spaceLeft)
            {
                // Skip printing the newline if it's the first word of the line that is
                // greater than the word wrap width.
                if(j > 0)
                {
                    result += '\n';
                }
                result += words[j];
                spaceLeft = this.style.wordWrapWidth - wordWidth;
            }
            else
            {
                spaceLeft -= wordWidthWithSpace;
                result += ' ' + words[j];
            }
        }

        if (i < lines.length-1)
        {
            result += '\n';
        }
    }
    return result;
};

/**
 * Destroys this text object
 *
 * @method destroy
 * @param destroyBaseTexture {Boolean} whether to destroy the base texture as well
 */
PIXI.Text.prototype.destroy = function(destroyBaseTexture)
{
    // make sure to reset the the context and canvas.. dont want this hanging around in memory!
    this.context = null;
    this.canvas = null;

    this.texture.destroy(destroyBaseTexture === undefined ? true : destroyBaseTexture);
};

PIXI.Text.heightCache = {};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * A Text Object will create a line(s) of text using bitmap font. To split a line you can use '\n', '\r' or '\r\n'
 * You can generate the fnt files using
 * http://www.angelcode.com/products/bmfont/ for windows or
 * http://www.bmglyph.com/ for mac.
 *
 * @class BitmapText
 * @extends DisplayObjectContainer
 * @constructor
 * @param text {String} The copy that you would like the text to display
 * @param style {Object} The style parameters
 * @param style.font {String} The size (optional) and bitmap font id (required) eq 'Arial' or '20px Arial' (must have loaded previously)
 * @param [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
 */
PIXI.BitmapText = function(text, style)
{
    PIXI.DisplayObjectContainer.call(this);

    this._pool = [];

    this.setText(text);
    this.setStyle(style);
    this.updateText();
    this.dirty = false;
};

// constructor
PIXI.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
PIXI.BitmapText.prototype.constructor = PIXI.BitmapText;

/**
 * Set the copy for the text object
 *
 * @method setText
 * @param text {String} The copy that you would like the text to display
 */
PIXI.BitmapText.prototype.setText = function(text)
{
    this.text = text || ' ';
    this.dirty = true;
};

/**
 * Set the style of the text
 * style.font {String} The size (optional) and bitmap font id (required) eq 'Arial' or '20px Arial' (must have loaded previously)
 * [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
 *
 * @method setStyle
 * @param style {Object} The style parameters, contained as properties of an object
 */
PIXI.BitmapText.prototype.setStyle = function(style)
{
    style = style || {};
    style.align = style.align || 'left';
    this.style = style;

    var font = style.font.split(' ');
    this.fontName = font[font.length - 1];
    this.fontSize = font.length >= 2 ? parseInt(font[font.length - 2], 10) : PIXI.BitmapText.fonts[this.fontName].size;

    this.dirty = true;
    this.tint = style.tint;
};

/**
 * Renders text and updates it when needed
 *
 * @method updateText
 * @private
 */
PIXI.BitmapText.prototype.updateText = function()
{
    var data = PIXI.BitmapText.fonts[this.fontName];
    var pos = new PIXI.Point();
    var prevCharCode = null;
    var chars = [];
    var maxLineWidth = 0;
    var lineWidths = [];
    var line = 0;
    var scale = this.fontSize / data.size;
    

    for(var i = 0; i < this.text.length; i++)
    {
        var charCode = this.text.charCodeAt(i);
        if(/(?:\r\n|\r|\n)/.test(this.text.charAt(i)))
        {
            lineWidths.push(pos.x);
            maxLineWidth = Math.max(maxLineWidth, pos.x);
            line++;

            pos.x = 0;
            pos.y += data.lineHeight;
            prevCharCode = null;
            continue;
        }

        var charData = data.chars[charCode];
        if(!charData) continue;

        if(prevCharCode && charData[prevCharCode])
        {
            pos.x += charData.kerning[prevCharCode];
        }
        chars.push({texture:charData.texture, line: line, charCode: charCode, position: new PIXI.Point(pos.x + charData.xOffset, pos.y + charData.yOffset)});
        pos.x += charData.xAdvance;

        prevCharCode = charCode;
    }

    lineWidths.push(pos.x);
    maxLineWidth = Math.max(maxLineWidth, pos.x);

    var lineAlignOffsets = [];
    for(i = 0; i <= line; i++)
    {
        var alignOffset = 0;
        if(this.style.align === 'right')
        {
            alignOffset = maxLineWidth - lineWidths[i];
        }
        else if(this.style.align === 'center')
        {
            alignOffset = (maxLineWidth - lineWidths[i]) / 2;
        }
        lineAlignOffsets.push(alignOffset);
    }

    var lenChildren = this.children.length;
    var lenChars = chars.length;
    var tint = this.tint || 0xFFFFFF;
    for(i = 0; i < lenChars; i++)
    {
        var c = i < lenChildren ? this.children[i] : this._pool.pop(); // get old child if have. if not - take from pool.

        if (c) c.setTexture(chars[i].texture); // check if got one before.
        else c = new PIXI.Sprite(chars[i].texture); // if no create new one.

        c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale;
        c.position.y = chars[i].position.y * scale;
        c.scale.x = c.scale.y = scale;
        c.tint = tint;
        if (!c.parent) this.addChild(c);
    }

    // remove unnecessary children.
    // and put their into the pool.
    while(this.children.length > lenChars)
    {
        var child = this.getChildAt(this.children.length - 1);
        this._pool.push(child);
        this.removeChild(child);
    }


    /**
     * [read-only] The width of the overall text, different from fontSize,
     * which is defined in the style object
     *
     * @property textWidth
     * @type Number
     */
    this.textWidth = maxLineWidth * scale;

    /**
     * [read-only] The height of the overall text, different from fontSize,
     * which is defined in the style object
     *
     * @property textHeight
     * @type Number
     */
    this.textHeight = (pos.y + data.lineHeight) * scale;
};

/**
 * Updates the transform of this object
 *
 * @method updateTransform
 * @private
 */
PIXI.BitmapText.prototype.updateTransform = function()
{
    if(this.dirty)
    {
        this.updateText();
        this.dirty = false;
    }

    PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
};

PIXI.BitmapText.fonts = {};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */
 
/**
 * Holds all information related to an Interaction event
 *
 * @class InteractionData
 * @constructor
 */
PIXI.InteractionData = function()
{
    /**
     * This point stores the global coords of where the touch/mouse event happened
     *
     * @property global
     * @type Point
     */
    this.global = new PIXI.Point();

   
    /**
     * The target Sprite that was interacted with
     *
     * @property target
     * @type Sprite
     */
    this.target = null;

    /**
     * When passed to an event handler, this will be the original DOM Event that was captured
     *
     * @property originalEvent
     * @type Event
     */
    this.originalEvent = null;
};

/**
 * This will return the local coordinates of the specified displayObject for this InteractionData
 *
 * @method getLocalPosition
 * @param displayObject {DisplayObject} The DisplayObject that you would like the local coords off
 * @return {Point} A point containing the coordinates of the InteractionData position relative to the DisplayObject
 */
PIXI.InteractionData.prototype.getLocalPosition = function(displayObject)
{
    var worldTransform = displayObject.worldTransform;
    var global = this.global;

    // do a cheeky transform to get the mouse coords;
    var a00 = worldTransform.a, a01 = worldTransform.b, a02 = worldTransform.tx,
        a10 = worldTransform.c, a11 = worldTransform.d, a12 = worldTransform.ty,
        id = 1 / (a00 * a11 + a01 * -a10);
    // set the mouse coords...
    return new PIXI.Point(a11 * id * global.x + -a01 * id * global.y + (a12 * a01 - a02 * a11) * id,
                               a00 * id * global.y + -a10 * id * global.x + (-a12 * a00 + a02 * a10) * id);
};

// constructor
PIXI.InteractionData.prototype.constructor = PIXI.InteractionData;
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

 /**
 * The interaction manager deals with mouse and touch events. Any DisplayObject can be interactive
 * if its interactive parameter is set to true
 * This manager also supports multitouch.
 *
 * @class InteractionManager
 * @constructor
 * @param stage {Stage} The stage to handle interactions
 */
PIXI.InteractionManager = function(stage)
{
    /**
     * a reference to the stage
     *
     * @property stage
     * @type Stage
     */
    this.stage = stage;

    /**
     * the mouse data
     *
     * @property mouse
     * @type InteractionData
     */
    this.mouse = new PIXI.InteractionData();

    /**
     * an object that stores current touches (InteractionData) by id reference
     *
     * @property touchs
     * @type Object
     */
    this.touchs = {};

    // helpers
    this.tempPoint = new PIXI.Point();

    /**
     * 
     * @property mouseoverEnabled
     * @type Boolean
     * @default
     */
    this.mouseoverEnabled = true;

    /**
     * tiny little interactiveData pool !
     * 
     * @property pool
     * @type Array
     */
    this.pool = [];

    /**
     * An array containing all the iterative items from the our interactive tree
     * @property interactiveItems
     * @type Array
     * @private
     *
     */
    this.interactiveItems = [];

    /**
     * Our canvas
     * @property interactionDOMElement
     * @type HTMLCanvasElement
     * @private
     */
    this.interactionDOMElement = null;

    //this will make it so that you dont have to call bind all the time
    this.onMouseMove = this.onMouseMove.bind( this );
    this.onMouseDown = this.onMouseDown.bind(this);
    this.onMouseOut = this.onMouseOut.bind(this);
    this.onMouseUp = this.onMouseUp.bind(this);

    this.onTouchStart = this.onTouchStart.bind(this);
    this.onTouchEnd = this.onTouchEnd.bind(this);
    this.onTouchMove = this.onTouchMove.bind(this);

    this.last = 0;

    /**
     * The css style of the cursor that is being used
     * @property currentCursorStyle
     * @type String
     *
     */
    this.currentCursorStyle = 'inherit';

    /**
     * Is set to true when the mouse is moved out of the canvas
     * @property mouseOut
     * @type Boolean
     *
     */
    this.mouseOut = false;
};

// constructor
PIXI.InteractionManager.prototype.constructor = PIXI.InteractionManager;

/**
 * Collects an interactive sprite recursively to have their interactions managed
 *
 * @method collectInteractiveSprite
 * @param displayObject {DisplayObject} the displayObject to collect
 * @param iParent {DisplayObject} the display object's parent
 * @private
 */
PIXI.InteractionManager.prototype.collectInteractiveSprite = function(displayObject, iParent)
{
    var children = displayObject.children;
    var length = children.length;

    // make an interaction tree... {item.__interactiveParent}
    for (var i = length-1; i >= 0; i--)
    {
        var child = children[i];

        // push all interactive bits
        if(child._interactive)
        {
            iParent.interactiveChildren = true;
            //child.__iParent = iParent;
            this.interactiveItems.push(child);

            if(child.children.length > 0)
            {
                this.collectInteractiveSprite(child, child);
            }
        }
        else
        {
            child.__iParent = null;

            if(child.children.length > 0)
            {
                this.collectInteractiveSprite(child, iParent);
            }
        }

    }
};

/**
 * Sets the target for event delegation
 *
 * @method setTarget
 * @param target {WebGLRenderer|CanvasRenderer} the renderer to bind events to
 * @private
 */
PIXI.InteractionManager.prototype.setTarget = function(target)
{
    this.target = target;

    //check if the dom element has been set. If it has don't do anything
    if( this.interactionDOMElement === null ) {

        this.setTargetDomElement( target.view );
    }

    
};


/**
 * Sets the DOM element which will receive mouse/touch events. This is useful for when you have other DOM
 * elements on top of the renderers Canvas element. With this you'll be able to delegate another DOM element
 * to receive those events
 *
 * @method setTargetDomElement
 * @param domElement {DOMElement} the DOM element which will receive mouse and touch events
 * @private
 */
PIXI.InteractionManager.prototype.setTargetDomElement = function(domElement)
{

    this.removeEvents();


    if (window.navigator.msPointerEnabled)
    {
        // time to remove some of that zoom in ja..
        domElement.style['-ms-content-zooming'] = 'none';
        domElement.style['-ms-touch-action'] = 'none';

        // DO some window specific touch!
    }

    this.interactionDOMElement = domElement;

    domElement.addEventListener('mousemove',  this.onMouseMove, true);
    domElement.addEventListener('mousedown',  this.onMouseDown, true);
    domElement.addEventListener('mouseout',   this.onMouseOut, true);

    // aint no multi touch just yet!
    domElement.addEventListener('touchstart', this.onTouchStart, true);
    domElement.addEventListener('touchend', this.onTouchEnd, true);
    domElement.addEventListener('touchmove', this.onTouchMove, true);

    window.addEventListener('mouseup',  this.onMouseUp, true);
};


PIXI.InteractionManager.prototype.removeEvents = function()
{
    if(!this.interactionDOMElement)return;

    this.interactionDOMElement.style['-ms-content-zooming'] = '';
    this.interactionDOMElement.style['-ms-touch-action'] = '';

    this.interactionDOMElement.removeEventListener('mousemove',  this.onMouseMove, true);
    this.interactionDOMElement.removeEventListener('mousedown',  this.onMouseDown, true);
    this.interactionDOMElement.removeEventListener('mouseout',   this.onMouseOut, true);

    // aint no multi touch just yet!
    this.interactionDOMElement.removeEventListener('touchstart', this.onTouchStart, true);
    this.interactionDOMElement.removeEventListener('touchend', this.onTouchEnd, true);
    this.interactionDOMElement.removeEventListener('touchmove', this.onTouchMove, true);

    this.interactionDOMElement = null;

    window.removeEventListener('mouseup',  this.onMouseUp, true);
};

/**
 * updates the state of interactive objects
 *
 * @method update
 * @private
 */
PIXI.InteractionManager.prototype.update = function()
{
    if(!this.target)return;

    // frequency of 30fps??
    var now = Date.now();
    var diff = now - this.last;
    diff = (diff * PIXI.INTERACTION_FREQUENCY ) / 1000;
    if(diff < 1)return;
    this.last = now;

    var i = 0;

    // ok.. so mouse events??
    // yes for now :)
    // OPTIMISE - how often to check??
    if(this.dirty)
    {
        this.rebuildInteractiveGraph();
    }

    // loop through interactive objects!
    var length = this.interactiveItems.length;
    var cursor = 'inherit';
    var over = false;

    for (i = 0; i < length; i++)
    {
        var item = this.interactiveItems[i];

        // OPTIMISATION - only calculate every time if the mousemove function exists..
        // OK so.. does the object have any other interactive functions?
        // hit-test the clip!
       // if(item.mouseover || item.mouseout || item.buttonMode)
       // {
        // ok so there are some functions so lets hit test it..
        item.__hit = this.hitTest(item, this.mouse);
        this.mouse.target = item;
        // ok so deal with interactions..
        // looks like there was a hit!
        if(item.__hit && !over)
        {
            if(item.buttonMode) cursor = item.defaultCursor;

            if(!item.interactiveChildren)over = true;

            if(!item.__isOver)
            {
                if(item.mouseover)item.mouseover(this.mouse);
                item.__isOver = true;
            }
        }
        else
        {
            if(item.__isOver)
            {
                // roll out!
                if(item.mouseout)item.mouseout(this.mouse);
                item.__isOver = false;
            }
        }
    }

    if( this.currentCursorStyle !== cursor )
    {
        this.currentCursorStyle = cursor;
        this.interactionDOMElement.style.cursor = cursor;
    }
};

PIXI.InteractionManager.prototype.rebuildInteractiveGraph = function()
{
    this.dirty = false;

    var len = this.interactiveItems.length;

    for (var i = 0; i < len; i++) {
        this.interactiveItems[i].interactiveChildren = false;
    }

    this.interactiveItems = [];

    if(this.stage.interactive)this.interactiveItems.push(this.stage);
    // go through and collect all the objects that are interactive..
    this.collectInteractiveSprite(this.stage, this.stage);
};

/**
 * Is called when the mouse moves across the renderer element
 *
 * @method onMouseMove
 * @param event {Event} The DOM event of the mouse moving
 * @private
 */
PIXI.InteractionManager.prototype.onMouseMove = function(event)
{
    if(this.dirty)
    {
        this.rebuildInteractiveGraph();
    }

    this.mouse.originalEvent = event || window.event; //IE uses window.event
    // TODO optimize by not check EVERY TIME! maybe half as often? //
    var rect = this.interactionDOMElement.getBoundingClientRect();

    this.mouse.global.x = (event.clientX - rect.left) * (this.target.width / rect.width);
    this.mouse.global.y = (event.clientY - rect.top) * ( this.target.height / rect.height);

    var length = this.interactiveItems.length;

    for (var i = 0; i < length; i++)
    {
        var item = this.interactiveItems[i];

        if(item.mousemove)
        {
            //call the function!
            item.mousemove(this.mouse);
        }
    }
};

/**
 * Is called when the mouse button is pressed down on the renderer element
 *
 * @method onMouseDown
 * @param event {Event} The DOM event of a mouse button being pressed down
 * @private
 */
PIXI.InteractionManager.prototype.onMouseDown = function(event)
{
    if(this.dirty)
    {
        this.rebuildInteractiveGraph();
    }

    this.mouse.originalEvent = event || window.event; //IE uses window.event

    if(PIXI.AUTO_PREVENT_DEFAULT)this.mouse.originalEvent.preventDefault();

    // loop through interaction tree...
    // hit test each item! ->
    // get interactive items under point??
    //stage.__i
    var length = this.interactiveItems.length;

    // while
    // hit test
    for (var i = 0; i < length; i++)
    {
        var item = this.interactiveItems[i];

        if(item.mousedown || item.click)
        {
            item.__mouseIsDown = true;
            item.__hit = this.hitTest(item, this.mouse);

            if(item.__hit)
            {
                //call the function!
                if(item.mousedown)item.mousedown(this.mouse);
                item.__isDown = true;

                // just the one!
                if(!item.interactiveChildren)break;
            }
        }
    }
};

/**
 * Is called when the mouse button is moved out of the renderer element
 *
 * @method onMouseOut
 * @param event {Event} The DOM event of a mouse button being moved out
 * @private 
 */
PIXI.InteractionManager.prototype.onMouseOut = function()
{
    if(this.dirty)
    {
        this.rebuildInteractiveGraph();
    }

    var length = this.interactiveItems.length;

    this.interactionDOMElement.style.cursor = 'inherit';

    for (var i = 0; i < length; i++)
    {
        var item = this.interactiveItems[i];
        if(item.__isOver)
        {
            this.mouse.target = item;
            if(item.mouseout)item.mouseout(this.mouse);
            item.__isOver = false;
        }
    }

    this.mouseOut = true;

    // move the mouse to an impossible position
    this.mouse.global.x = -10000;
    this.mouse.global.y = -10000;
};

/**
 * Is called when the mouse button is released on the renderer element
 *
 * @method onMouseUp
 * @param event {Event} The DOM event of a mouse button being released
 * @private
 */
PIXI.InteractionManager.prototype.onMouseUp = function(event)
{
    if(this.dirty)
    {
        this.rebuildInteractiveGraph();
    }

    this.mouse.originalEvent = event || window.event; //IE uses window.event

    var length = this.interactiveItems.length;
    var up = false;

    for (var i = 0; i < length; i++)
    {
        var item = this.interactiveItems[i];

        item.__hit = this.hitTest(item, this.mouse);

        if(item.__hit && !up)
        {
            //call the function!
            if(item.mouseup)
            {
                item.mouseup(this.mouse);
            }
            if(item.__isDown)
            {
                if(item.click)item.click(this.mouse);
            }

            if(!item.interactiveChildren)up = true;
        }
        else
        {
            if(item.__isDown)
            {
                if(item.mouseupoutside)item.mouseupoutside(this.mouse);
            }
        }

        item.__isDown = false;
        //}
    }
};

/**
 * Tests if the current mouse coordinates hit a sprite
 *
 * @method hitTest
 * @param item {DisplayObject} The displayObject to test for a hit
 * @param interactionData {InteractionData} The interactionData object to update in the case there is a hit
 * @private
 */
PIXI.InteractionManager.prototype.hitTest = function(item, interactionData)
{
    var global = interactionData.global;

    if( !item.worldVisible )return false;

    // temp fix for if the element is in a non visible
   
    var isSprite = (item instanceof PIXI.Sprite),
        worldTransform = item.worldTransform,
        a00 = worldTransform.a, a01 = worldTransform.b, a02 = worldTransform.tx,
        a10 = worldTransform.c, a11 = worldTransform.d, a12 = worldTransform.ty,
        id = 1 / (a00 * a11 + a01 * -a10),
        x = a11 * id * global.x + -a01 * id * global.y + (a12 * a01 - a02 * a11) * id,
        y = a00 * id * global.y + -a10 * id * global.x + (-a12 * a00 + a02 * a10) * id;

    interactionData.target = item;

    //a sprite or display object with a hit area defined
    if(item.hitArea && item.hitArea.contains) {
        if(item.hitArea.contains(x, y)) {
            //if(isSprite)
            interactionData.target = item;

            return true;
        }

        return false;
    }
    // a sprite with no hitarea defined
    else if(isSprite)
    {
        var width = item.texture.frame.width,
            height = item.texture.frame.height,
            x1 = -width * item.anchor.x,
            y1;

        if(x > x1 && x < x1 + width)
        {
            y1 = -height * item.anchor.y;

            if(y > y1 && y < y1 + height)
            {
                // set the target property if a hit is true!
                interactionData.target = item;
                return true;
            }
        }
    }

    var length = item.children.length;

    for (var i = 0; i < length; i++)
    {
        var tempItem = item.children[i];
        var hit = this.hitTest(tempItem, interactionData);
        if(hit)
        {
            // hmm.. TODO SET CORRECT TARGET?
            interactionData.target = item;
            return true;
        }
    }

    return false;
};

/**
 * Is called when a touch is moved across the renderer element
 *
 * @method onTouchMove
 * @param event {Event} The DOM event of a touch moving across the renderer view
 * @private
 */
PIXI.InteractionManager.prototype.onTouchMove = function(event)
{
    if(this.dirty)
    {
        this.rebuildInteractiveGraph();
    }

    var rect = this.interactionDOMElement.getBoundingClientRect();
    var changedTouches = event.changedTouches;
    var touchData;
    var i = 0;

    for (i = 0; i < changedTouches.length; i++)
    {
        var touchEvent = changedTouches[i];
        touchData = this.touchs[touchEvent.identifier];
        touchData.originalEvent =  event || window.event;

        // update the touch position
        touchData.global.x = (touchEvent.clientX - rect.left) * (this.target.width / rect.width);
        touchData.global.y = (touchEvent.clientY - rect.top)  * (this.target.height / rect.height);
        if(navigator.isCocoonJS) {
            touchData.global.x = touchEvent.clientX;
            touchData.global.y = touchEvent.clientY;
        }

        for (var j = 0; j < this.interactiveItems.length; j++)
        {
            var item = this.interactiveItems[j];
            if(item.touchmove && item.__touchData && item.__touchData[touchEvent.identifier]) item.touchmove(touchData);
        }
    }
};

/**
 * Is called when a touch is started on the renderer element
 *
 * @method onTouchStart
 * @param event {Event} The DOM event of a touch starting on the renderer view
 * @private
 */
PIXI.InteractionManager.prototype.onTouchStart = function(event)
{
    if(this.dirty)
    {
        this.rebuildInteractiveGraph();
    }

    var rect = this.interactionDOMElement.getBoundingClientRect();

    if(PIXI.AUTO_PREVENT_DEFAULT)event.preventDefault();
    
    var changedTouches = event.changedTouches;
    for (var i=0; i < changedTouches.length; i++)
    {
        var touchEvent = changedTouches[i];

        var touchData = this.pool.pop();
        if(!touchData)touchData = new PIXI.InteractionData();

        touchData.originalEvent =  event || window.event;

        this.touchs[touchEvent.identifier] = touchData;
        touchData.global.x = (touchEvent.clientX - rect.left) * (this.target.width / rect.width);
        touchData.global.y = (touchEvent.clientY - rect.top)  * (this.target.height / rect.height);
        if(navigator.isCocoonJS) {
            touchData.global.x = touchEvent.clientX;
            touchData.global.y = touchEvent.clientY;
        }

        var length = this.interactiveItems.length;

        for (var j = 0; j < length; j++)
        {
            var item = this.interactiveItems[j];

            if(item.touchstart || item.tap)
            {
                item.__hit = this.hitTest(item, touchData);

                if(item.__hit)
                {
                    //call the function!
                    if(item.touchstart)item.touchstart(touchData);
                    item.__isDown = true;
                    item.__touchData = item.__touchData || {};
                    item.__touchData[touchEvent.identifier] = touchData;

                    if(!item.interactiveChildren)break;
                }
            }
        }
    }
};

/**
 * Is called when a touch is ended on the renderer element
 *
 * @method onTouchEnd
 * @param event {Event} The DOM event of a touch ending on the renderer view
 * @private
 */
PIXI.InteractionManager.prototype.onTouchEnd = function(event)
{
    if(this.dirty)
    {
        this.rebuildInteractiveGraph();
    }
    
    //this.mouse.originalEvent = event || window.event; //IE uses window.event
    var rect = this.interactionDOMElement.getBoundingClientRect();
    var changedTouches = event.changedTouches;

    for (var i=0; i < changedTouches.length; i++)
    {
        var touchEvent = changedTouches[i];
        var touchData = this.touchs[touchEvent.identifier];
        var up = false;
        touchData.global.x = (touchEvent.clientX - rect.left) * (this.target.width / rect.width);
        touchData.global.y = (touchEvent.clientY - rect.top)  * (this.target.height / rect.height);
        if(navigator.isCocoonJS) {
            touchData.global.x = touchEvent.clientX;
            touchData.global.y = touchEvent.clientY;
        }

        var length = this.interactiveItems.length;
        for (var j = 0; j < length; j++)
        {
            var item = this.interactiveItems[j];

            if(item.__touchData && item.__touchData[touchEvent.identifier]) {

                item.__hit = this.hitTest(item, item.__touchData[touchEvent.identifier]);

                // so this one WAS down...
                touchData.originalEvent = event || window.event;
                // hitTest??

                if(item.touchend || item.tap)
                {
                    if(item.__hit && !up)
                    {
                        if(item.touchend)item.touchend(touchData);
                        if(item.__isDown)
                        {
                            if(item.tap)item.tap(touchData);
                        }

                        if(!item.interactiveChildren)up = true;
                    }
                    else
                    {
                        if(item.__isDown)
                        {
                            if(item.touchendoutside)item.touchendoutside(touchData);
                        }
                    }

                    item.__isDown = false;
                }

                item.__touchData[touchEvent.identifier] = null;
            }
        }
        // remove the touch..
        this.pool.push(touchData);
        this.touchs[touchEvent.identifier] = null;
    }
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * A Stage represents the root of the display tree. Everything connected to the stage is rendered
 *
 * @class Stage
 * @extends DisplayObjectContainer
 * @constructor
 * @param backgroundColor {Number} the background color of the stage, you have to pass this in is in hex format
 *      like: 0xFFFFFF for white
 * 
 * Creating a stage is a mandatory process when you use Pixi, which is as simple as this : 
 * var stage = new PIXI.Stage(0xFFFFFF);
 * where the parameter given is the background colour of the stage, in hex
 * you will use this stage instance to add your sprites to it and therefore to the renderer
 * Here is how to add a sprite to the stage : 
 * stage.addChild(sprite);
 */
PIXI.Stage = function(backgroundColor)
{
    PIXI.DisplayObjectContainer.call( this );

    /**
     * [read-only] Current transform of the object based on world (parent) factors
     *
     * @property worldTransform
     * @type Mat3
     * @readOnly
     * @private
     */
    this.worldTransform = new PIXI.Matrix();

    /**
     * Whether or not the stage is interactive
     *
     * @property interactive
     * @type Boolean
     */
    this.interactive = true;

    /**
     * The interaction manage for this stage, manages all interactive activity on the stage
     *
     * @property interactionManager
     * @type InteractionManager
     */
    this.interactionManager = new PIXI.InteractionManager(this);

    /**
     * Whether the stage is dirty and needs to have interactions updated
     *
     * @property dirty
     * @type Boolean
     * @private
     */
    this.dirty = true;

    //the stage is its own stage
    this.stage = this;

    //optimize hit detection a bit
    this.stage.hitArea = new PIXI.Rectangle(0,0,100000, 100000);

    this.setBackgroundColor(backgroundColor);
};

// constructor
PIXI.Stage.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );
PIXI.Stage.prototype.constructor = PIXI.Stage;

/**
 * Sets another DOM element which can receive mouse/touch interactions instead of the default Canvas element.
 * This is useful for when you have other DOM elements on top of the Canvas element.
 *
 * @method setInteractionDelegate
 * @param domElement {DOMElement} This new domElement which will receive mouse/touch events
 */
PIXI.Stage.prototype.setInteractionDelegate = function(domElement)
{
    this.interactionManager.setTargetDomElement( domElement );
};

/*
 * Updates the object transform for rendering
 *
 * @method updateTransform
 * @private
 */
PIXI.Stage.prototype.updateTransform = function()
{
    this.worldAlpha = 1;

    for(var i=0,j=this.children.length; i<j; i++)
    {
        this.children[i].updateTransform();
    }

    if(this.dirty)
    {
        this.dirty = false;
        // update interactive!
        this.interactionManager.dirty = true;
    }

    if(this.interactive)this.interactionManager.update();
};

/**
 * Sets the background color for the stage
 *
 * @method setBackgroundColor
 * @param backgroundColor {Number} the color of the background, easiest way to pass this in is in hex format
 *      like: 0xFFFFFF for white
 */
PIXI.Stage.prototype.setBackgroundColor = function(backgroundColor)
{
    this.backgroundColor = backgroundColor || 0x000000;
    this.backgroundColorSplit = PIXI.hex2rgb(this.backgroundColor);
    var hex = this.backgroundColor.toString(16);
    hex = '000000'.substr(0, 6 - hex.length) + hex;
    this.backgroundColorString = '#' + hex;
};

/**
 * This will return the point containing global coords of the mouse.
 *
 * @method getMousePosition
 * @return {Point} The point containing the coords of the global InteractionData position.
 */
PIXI.Stage.prototype.getMousePosition = function()
{
    return this.interactionManager.mouse.global;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */
 
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel

// MIT license

/**
 * A polyfill for requestAnimationFrame
 * You can actually use both requestAnimationFrame and requestAnimFrame, 
 * you will still benefit from the polyfill
 *
 * @method requestAnimationFrame
 */
/**
 * A polyfill for cancelAnimationFrame
 *
 * @method cancelAnimationFrame
 */
var lastTime = 0;
var vendors = ['ms', 'moz', 'webkit', 'o'];
for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||
        window[vendors[x] + 'CancelRequestAnimationFrame'];
}

if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function(callback) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function() { callback(currTime + timeToCall); },
          timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };
}

if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function(id) {
        clearTimeout(id);
    };
}

window.requestAnimFrame = window.requestAnimationFrame;

/**
 * Converts a hex color number to an [R, G, B] array
 *
 * @method hex2rgb
 * @param hex {Number}
 */
PIXI.hex2rgb = function(hex) {
    return [(hex >> 16 & 0xFF) / 255, ( hex >> 8 & 0xFF) / 255, (hex & 0xFF)/ 255];
};

/**
 * Converts a color as an [R, G, B] array to a hex number
 *
 * @method rgb2hex
 * @param rgb {Array}
 */
PIXI.rgb2hex = function(rgb) {
    return ((rgb[0]*255 << 16) + (rgb[1]*255 << 8) + rgb[2]*255);
};

/**
 * A polyfill for Function.prototype.bind
 *
 * @method bind
 */
if (typeof Function.prototype.bind !== 'function') {
    Function.prototype.bind = (function () {
        var slice = Array.prototype.slice;
        return function (thisArg) {
            var target = this, boundArgs = slice.call(arguments, 1);

            if (typeof target !== 'function') throw new TypeError();

            function bound() {
                var args = boundArgs.concat(slice.call(arguments));
                target.apply(this instanceof bound ? this : thisArg, args);
            }

            bound.prototype = (function F(proto) {
                if (proto) F.prototype = proto;
                if (!(this instanceof F)) return new F();
            })(target.prototype);

            return bound;
        };
    })();
}

/**
 * A wrapper for ajax requests to be handled cross browser
 *
 * @class AjaxRequest
 * @constructor
 */
PIXI.AjaxRequest = function()
{
    var activexmodes = ['Msxml2.XMLHTTP.6.0', 'Msxml2.XMLHTTP.3.0', 'Microsoft.XMLHTTP']; //activeX versions to check for in IE

    if (window.ActiveXObject)
    { //Test for support for ActiveXObject in IE first (as XMLHttpRequest in IE7 is broken)
        for (var i=0; i<activexmodes.length; i++)
        {
            try{
                return new window.ActiveXObject(activexmodes[i]);
            }
            catch(e) {
                //suppress error
            }
        }
    }
    else if (window.XMLHttpRequest) // if Mozilla, Safari etc
    {
        return new window.XMLHttpRequest();
    }
    else
    {
        return false;
    }
};
/*
PIXI.packColorRGBA = function(r, g, b, a)//r, g, b, a)
{
  //  console.log(r, b, c, d)
  return (Math.floor((r)*63) << 18) | (Math.floor((g)*63) << 12) | (Math.floor((b)*63) << 6);// | (Math.floor((a)*63))
  //  i = i | (Math.floor((a)*63));
   // return i;
   // var r = (i / 262144.0 ) / 64;
   // var g = (i / 4096.0)%64 / 64;
  //  var b = (i / 64.0)%64 / 64;
  //  var a = (i)%64 / 64;
     
  //  console.log(r, g, b, a);
  //  return i;

};
*/
/*
PIXI.packColorRGB = function(r, g, b)//r, g, b, a)
{
    return (Math.floor((r)*255) << 16) | (Math.floor((g)*255) << 8) | (Math.floor((b)*255));
};

PIXI.unpackColorRGB = function(r, g, b)//r, g, b, a)
{
    return (Math.floor((r)*255) << 16) | (Math.floor((g)*255) << 8) | (Math.floor((b)*255));
};
*/

/**
 * Checks whether the Canvas BlendModes are supported by the current browser
 *
 * @method canUseNewCanvasBlendModes
 * @return {Boolean} whether they are supported
 */
PIXI.canUseNewCanvasBlendModes = function()
{
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    var context = canvas.getContext('2d');
    context.fillStyle = '#000';
    context.fillRect(0,0,1,1);
    context.globalCompositeOperation = 'multiply';
    context.fillStyle = '#fff';
    context.fillRect(0,0,1,1);
    return context.getImageData(0,0,1,1).data[0] === 0;
};

/**
 * Given a number, this function returns the closest number that is a power of two
 * this function is taken from Starling Framework as its pretty neat ;)
 *
 * @method getNextPowerOfTwo
 * @param number {Number}
 * @return {Number} the closest number that is a power of two
 */
PIXI.getNextPowerOfTwo = function(number)
{
    if (number > 0 && (number & (number - 1)) === 0) // see: http://goo.gl/D9kPj
        return number;
    else
    {
        var result = 1;
        while (result < number) result <<= 1;
        return result;
    }
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */
 
/**
 * https://github.com/mrdoob/eventtarget.js/
 * THankS mr DOob!
 */

/**
 * Adds event emitter functionality to a class
 *
 * @class EventTarget
 * @example
 *      function MyEmitter() {
 *          PIXI.EventTarget.call(this); //mixes in event target stuff
 *      }
 *
 *      var em = new MyEmitter();
 *      em.emit({ type: 'eventName', data: 'some data' });
 */
PIXI.EventTarget = function () {

    /**
     * Holds all the listeners
     *
     * @property listeners
     * @type Object
     */
    var listeners = {};

    /**
     * Adds a listener for a specific event
     *
     * @method addEventListener
     * @param type {string} A string representing the event type to listen for.
     * @param listener {function} The callback function that will be fired when the event occurs
     */
    this.addEventListener = this.on = function ( type, listener ) {


        if ( listeners[ type ] === undefined ) {

            listeners[ type ] = [];

        }

        if ( listeners[ type ].indexOf( listener ) === - 1 ) {

            listeners[ type ].unshift( listener );
        }

    };

    /**
     * Fires the event, ie pretends that the event has happened
     *
     * @method dispatchEvent
     * @param event {Event} the event object
     */
    this.dispatchEvent = this.emit = function ( event ) {

        if ( !listeners[ event.type ] || !listeners[ event.type ].length ) {

            return;

        }


        for(var i = listeners[ event.type ].length-1; i >= 0; i--) {
//        for(var i = 0, l=listeners[ event.type ].length; i < l; i++) {


            listeners[ event.type ][ i ]( event );

        }

    };

    /**
     * Removes the specified listener that was assigned to the specified event type
     *
     * @method removeEventListener
     * @param type {string} A string representing the event type which will have its listener removed
     * @param listener {function} The callback function that was be fired when the event occured
     */
    this.removeEventListener = this.off = function ( type, listener ) {

        if ( listeners[ type ] === undefined ) return;

        var index = listeners[ type ].indexOf( listener );

        if ( index !== - 1 ) {

            listeners[ type ].splice( index, 1 );

        }

    };

    /**
     * Removes all the listeners that were active for the specified event type
     *
     * @method removeAllEventListeners
     * @param type {string} A string representing the event type which will have all its listeners removed
     */
	this.removeAllEventListeners = function( type ) {
		var a = listeners[type];
		if (a)
			a.length = 0;
	};
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * This helper function will automatically detect which renderer you should be using.
 * WebGL is the preferred renderer as it is a lot faster. If webGL is not supported by
 * the browser then this function will return a canvas renderer
 * @class autoDetectRenderer
 * @static
 * @param width=800 {Number} the width of the renderers view
 * @param height=600 {Number} the height of the renderers view
 * @param [view] {Canvas} the canvas to use as a view, optional 
 * @param [transparent=false] {Boolean} the transparency of the render view, default false
 * @param [antialias=false] {Boolean} sets antialias (only applicable in webGL chrome at the moment)
 *
 */
PIXI.autoDetectRenderer = function(width, height, view, transparent, antialias)
{
    if(!width)width = 800;
    if(!height)height = 600;

    // BORROWED from Mr Doob (mrdoob.com)
    var webgl = ( function () { try {
                                    var canvas = document.createElement( 'canvas' );
                                    return !! window.WebGLRenderingContext && ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) );
                                } catch( e ) {
                                    return false;
                                }
                            } )();

    if( webgl )
    {
        return new PIXI.WebGLRenderer(width, height, view, transparent, antialias);
    }

    return  new PIXI.CanvasRenderer(width, height, view, transparent);
};

/**
 * This helper function will automatically detect which renderer you should be using.
 * This function is very similar to the autoDetectRenderer function except that is will return a canvas renderer for android.
 * Even thought both android chrome suports webGL the canvas implementation perform better at the time of writing. 
 * This function will likely change and update as webGL performance imporoves on thease devices.
 * @class getRecommendedRenderer
 * @static
 * @param width=800 {Number} the width of the renderers view
 * @param height=600 {Number} the height of the renderers view
 * @param [view] {Canvas} the canvas to use as a view, optional 
 * @param [transparent=false] {Boolean} the transparency of the render view, default false
 * @param [antialias=false] {Boolean} sets antialias (only applicable in webGL chrome at the moment)
 *
 */
PIXI.autoDetectRecommendedRenderer = function(width, height, view, transparent, antialias)
{
    if(!width)width = 800;
    if(!height)height = 600;

    // BORROWED from Mr Doob (mrdoob.com)
    var webgl = ( function () { try {
                                    var canvas = document.createElement( 'canvas' );
                                    return !! window.WebGLRenderingContext && ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) );
                                } catch( e ) {
                                    return false;
                                }
                            } )();

    var isAndroid = /Android/i.test(navigator.userAgent);

    if( webgl && !isAndroid)
    {
        return new PIXI.WebGLRenderer(width, height, view, transparent, antialias);
    }

    return  new PIXI.CanvasRenderer(width, height, view, transparent);
};

/*
    PolyK library
    url: http://polyk.ivank.net
    Released under MIT licence.

    Copyright (c) 2012 Ivan Kuckir

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.

    This is an amazing lib!

    slightly modified by Mat Groves (matgroves.com);
*/

/**
 * Based on the Polyk library http://polyk.ivank.net released under MIT licence.
 * This is an amazing lib!
 * slightly modified by Mat Groves (matgroves.com);
 * @class PolyK
 *
 */
PIXI.PolyK = {};

/**
 * Triangulates shapes for webGL graphic fills
 *
 * @method Triangulate
 * 
 */
PIXI.PolyK.Triangulate = function(p)
{
    var sign = true;

    var n = p.length >> 1;
    if(n < 3) return [];

    var tgs = [];
    var avl = [];
    for(var i = 0; i < n; i++) avl.push(i);

    i = 0;
    var al = n;
    while(al > 3)
    {
        var i0 = avl[(i+0)%al];
        var i1 = avl[(i+1)%al];
        var i2 = avl[(i+2)%al];

        var ax = p[2*i0],  ay = p[2*i0+1];
        var bx = p[2*i1],  by = p[2*i1+1];
        var cx = p[2*i2],  cy = p[2*i2+1];

        var earFound = false;
        if(PIXI.PolyK._convex(ax, ay, bx, by, cx, cy, sign))
        {
            earFound = true;
            for(var j = 0; j < al; j++)
            {
                var vi = avl[j];
                if(vi === i0 || vi === i1 || vi === i2) continue;

                if(PIXI.PolyK._PointInTriangle(p[2*vi], p[2*vi+1], ax, ay, bx, by, cx, cy)) {
                    earFound = false;
                    break;
                }
            }
        }

        if(earFound)
        {
            tgs.push(i0, i1, i2);
            avl.splice((i+1)%al, 1);
            al--;
            i = 0;
        }
        else if(i++ > 3*al)
        {
            // need to flip flip reverse it!
            // reset!
            if(sign)
            {
                tgs = [];
                avl = [];
                for(i = 0; i < n; i++) avl.push(i);

                i = 0;
                al = n;

                sign = false;
            }
            else
            {
                window.console.log("PIXI Warning: shape too complex to fill");
                return [];
            }
        }
    }

    tgs.push(avl[0], avl[1], avl[2]);
    return tgs;
};

/**
 * Checks whether a point is within a triangle
 *
 * @method _PointInTriangle
 * @param px {Number} x coordinate of the point to test
 * @param py {Number} y coordinate of the point to test
 * @param ax {Number} x coordinate of the a point of the triangle
 * @param ay {Number} y coordinate of the a point of the triangle
 * @param bx {Number} x coordinate of the b point of the triangle
 * @param by {Number} y coordinate of the b point of the triangle
 * @param cx {Number} x coordinate of the c point of the triangle
 * @param cy {Number} y coordinate of the c point of the triangle
 * @private
 */
PIXI.PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy)
{
    var v0x = cx-ax;
    var v0y = cy-ay;
    var v1x = bx-ax;
    var v1y = by-ay;
    var v2x = px-ax;
    var v2y = py-ay;

    var dot00 = v0x*v0x+v0y*v0y;
    var dot01 = v0x*v1x+v0y*v1y;
    var dot02 = v0x*v2x+v0y*v2y;
    var dot11 = v1x*v1x+v1y*v1y;
    var dot12 = v1x*v2x+v1y*v2y;

    var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
    var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

    // Check if point is in triangle
    return (u >= 0) && (v >= 0) && (u + v < 1);
};

/**
 * Checks whether a shape is convex
 *
 * @method _convex
 * 
 * @private
 */
PIXI.PolyK._convex = function(ax, ay, bx, by, cx, cy, sign)
{
    return ((ay-by)*(cx-bx) + (bx-ax)*(cy-by) >= 0) === sign;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

// TODO Alvin and Mat
// Should we eventually create a Utils class ? 
// Or just move this file to the pixi.js file ?
PIXI.initDefaultShaders = function()
{
   
  //  PIXI.stripShader = new PIXI.StripShader();
//    PIXI.stripShader.init();

};

PIXI.CompileVertexShader = function(gl, shaderSrc)
{
    return PIXI._CompileShader(gl, shaderSrc, gl.VERTEX_SHADER);
};

PIXI.CompileFragmentShader = function(gl, shaderSrc)
{
    return PIXI._CompileShader(gl, shaderSrc, gl.FRAGMENT_SHADER);
};

PIXI._CompileShader = function(gl, shaderSrc, shaderType)
{
    var src = shaderSrc.join("\n");
    var shader = gl.createShader(shaderType);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        window.console.log(gl.getShaderInfoLog(shader));
        return null;
    }

    return shader;
};

PIXI.compileProgram = function(gl, vertexSrc, fragmentSrc)
{
    var fragmentShader = PIXI.CompileFragmentShader(gl, fragmentSrc);
    var vertexShader = PIXI.CompileVertexShader(gl, vertexSrc);

    var shaderProgram = gl.createProgram();

    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        window.console.log("Could not initialise shaders");
    }

    return shaderProgram;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 * @author Richard Davey http://www.photonstorm.com @photonstorm
 */

/**
* @class PixiShader
* @constructor
*/
PIXI.PixiShader = function(gl)
{
    this._UID = PIXI._UID++;
    
    /**
     * @property gl
     * @type WebGLContext
     */
    this.gl = gl;

    /**
    * @property {any} program - The WebGL program.
    */
    this.program = null;

    /**
    * @property {array} fragmentSrc - The fragment shader.
    */
    this.fragmentSrc = [
        'precision lowp float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform sampler2D uSampler;',
        'void main(void) {',
        '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',
        '}'
    ];

    /**
    * @property {number} textureCount - A local texture counter for multi-texture shaders.
    */
    this.textureCount = 0;

    this.attributes = [];

    this.init();
};

/**
* Initialises the shader
* @method init
*
*/
PIXI.PixiShader.prototype.init = function()
{
    var gl = this.gl;

    var program = PIXI.compileProgram(gl, this.vertexSrc || PIXI.PixiShader.defaultVertexSrc, this.fragmentSrc);
    
    gl.useProgram(program);

    // get and store the uniforms for the shader
    this.uSampler = gl.getUniformLocation(program, 'uSampler');
    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');
    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');
    this.dimensions = gl.getUniformLocation(program, 'dimensions');

    // get and store the attributes
    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');
    this.colorAttribute = gl.getAttribLocation(program, 'aColor');


    // Begin worst hack eva //

    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?
    // maybe its something to do with the current state of the gl context.
    // Im convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel
    // If theres any webGL people that know why could happen please help :)
    if(this.colorAttribute === -1)
    {
        this.colorAttribute = 2;
    }

    this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute];

    // End worst hack eva //

    // add those custom shaders!
    for (var key in this.uniforms)
    {
        // get the uniform locations..
        this.uniforms[key].uniformLocation = gl.getUniformLocation(program, key);
    }

    this.initUniforms();

    this.program = program;
};

/**
* Initialises the shader uniform values.
* Uniforms are specified in the GLSL_ES Specification: http://www.khronos.org/registry/webgl/specs/latest/1.0/
* http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf
*
* @method initUniforms
*/
PIXI.PixiShader.prototype.initUniforms = function()
{
    this.textureCount = 1;
    var gl = this.gl;
    var uniform;

    for (var key in this.uniforms)
    {
        uniform = this.uniforms[key];

        var type = uniform.type;

        if (type === 'sampler2D')
        {
            uniform._init = false;

            if (uniform.value !== null)
            {
                this.initSampler2D(uniform);
            }
        }
        else if (type === 'mat2' || type === 'mat3' || type === 'mat4')
        {
            //  These require special handling
            uniform.glMatrix = true;
            uniform.glValueLength = 1;

            if (type === 'mat2')
            {
                uniform.glFunc = gl.uniformMatrix2fv;
            }
            else if (type === 'mat3')
            {
                uniform.glFunc = gl.uniformMatrix3fv;
            }
            else if (type === 'mat4')
            {
                uniform.glFunc = gl.uniformMatrix4fv;
            }
        }
        else
        {
            //  GL function reference
            uniform.glFunc = gl['uniform' + type];

            if (type === '2f' || type === '2i')
            {
                uniform.glValueLength = 2;
            }
            else if (type === '3f' || type === '3i')
            {
                uniform.glValueLength = 3;
            }
            else if (type === '4f' || type === '4i')
            {
                uniform.glValueLength = 4;
            }
            else
            {
                uniform.glValueLength = 1;
            }
        }
    }

};

/**
* Initialises a Sampler2D uniform (which may only be available later on after initUniforms once the texture has loaded)
*
* @method initSampler2D
*/
PIXI.PixiShader.prototype.initSampler2D = function(uniform)
{
    if (!uniform.value || !uniform.value.baseTexture || !uniform.value.baseTexture.hasLoaded)
    {
        return;
    }

    var gl = this.gl;

    gl.activeTexture(gl['TEXTURE' + this.textureCount]);
    gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id]);

    //  Extended texture data
    if (uniform.textureData)
    {
        var data = uniform.textureData;

        // GLTexture = mag linear, min linear_mipmap_linear, wrap repeat + gl.generateMipmap(gl.TEXTURE_2D);
        // GLTextureLinear = mag/min linear, wrap clamp
        // GLTextureNearestRepeat = mag/min NEAREST, wrap repeat
        // GLTextureNearest = mag/min nearest, wrap clamp
        // AudioTexture = whatever + luminance + width 512, height 2, border 0
        // KeyTexture = whatever + luminance + width 256, height 2, border 0

        //  magFilter can be: gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR or gl.NEAREST
        //  wrapS/T can be: gl.CLAMP_TO_EDGE or gl.REPEAT

        var magFilter = (data.magFilter) ? data.magFilter : gl.LINEAR;
        var minFilter = (data.minFilter) ? data.minFilter : gl.LINEAR;
        var wrapS = (data.wrapS) ? data.wrapS : gl.CLAMP_TO_EDGE;
        var wrapT = (data.wrapT) ? data.wrapT : gl.CLAMP_TO_EDGE;
        var format = (data.luminance) ? gl.LUMINANCE : gl.RGBA;

        if (data.repeat)
        {
            wrapS = gl.REPEAT;
            wrapT = gl.REPEAT;
        }

        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY);

        if (data.width)
        {
            var width = (data.width) ? data.width : 512;
            var height = (data.height) ? data.height : 2;
            var border = (data.border) ? data.border : 0;

            // void texImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels);
            gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null);
        }
        else
        {
            //  void texImage2D(GLenum target, GLint level, GLenum internalformat, GLenum format, GLenum type, ImageData? pixels);
            gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.value.baseTexture.source);
        }

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
    }

    gl.uniform1i(uniform.uniformLocation, this.textureCount);

    uniform._init = true;

    this.textureCount++;

};

/**
* Updates the shader uniform values.
*
* @method syncUniforms
*/
PIXI.PixiShader.prototype.syncUniforms = function()
{
    this.textureCount = 1;
    var uniform;
    var gl = this.gl;

    //  This would probably be faster in an array and it would guarantee key order
    for (var key in this.uniforms)
    {
        uniform = this.uniforms[key];

        if (uniform.glValueLength === 1)
        {
            if (uniform.glMatrix === true)
            {
                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.transpose, uniform.value);
            }
            else
            {
                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value);
            }
        }
        else if (uniform.glValueLength === 2)
        {
            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y);
        }
        else if (uniform.glValueLength === 3)
        {
            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z);
        }
        else if (uniform.glValueLength === 4)
        {
            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z, uniform.value.w);
        }
        else if (uniform.type === 'sampler2D')
        {
            if (uniform._init)
            {
                gl.activeTexture(gl['TEXTURE' + this.textureCount]);
                gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id] || PIXI.createWebGLTexture( uniform.value.baseTexture, gl));
                gl.uniform1i(uniform.uniformLocation, this.textureCount);
                this.textureCount++;
            }
            else
            {
                this.initSampler2D(uniform);
            }
        }
    }

};

/**
* Destroys the shader
* @method destroy
*/
PIXI.PixiShader.prototype.destroy = function()
{
    this.gl.deleteProgram( this.program );
    this.uniforms = null;
    this.gl = null;

    this.attributes = null;
};

/**
* The Default Vertex shader source
* @property defaultVertexSrc
* @type String
*/
PIXI.PixiShader.defaultVertexSrc = [
    'attribute vec2 aVertexPosition;',
    'attribute vec2 aTextureCoord;',
    'attribute vec2 aColor;',

    'uniform vec2 projectionVector;',
    'uniform vec2 offsetVector;',

    'varying vec2 vTextureCoord;',
    'varying vec4 vColor;',

    'const vec2 center = vec2(-1.0, 1.0);',

    'void main(void) {',
    '   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);',
    '   vTextureCoord = aTextureCoord;',
    '   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;',
    '   vColor = vec4(color * aColor.x, aColor.x);',
    '}'
];

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 * @author Richard Davey http://www.photonstorm.com @photonstorm
 */

/**
* @class PixiFastShader
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.PixiFastShader = function(gl)
{
    this._UID = PIXI._UID++;
    
    /**
     * @property gl
     * @type WebGLContext
     */
    this.gl = gl;

    /**
     * @property {any} program - The WebGL program.
     */
    this.program = null;

    /**
     * @property {array} fragmentSrc - The fragment shader.
     */
    this.fragmentSrc = [
        'precision lowp float;',
        'varying vec2 vTextureCoord;',
        'varying float vColor;',
        'uniform sampler2D uSampler;',
        'void main(void) {',
        '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',
        '}'
    ];

    /**
    * @property {array} vertexSrc - The vertex shader
    */
    this.vertexSrc = [
        'attribute vec2 aVertexPosition;',
        'attribute vec2 aPositionCoord;',
        'attribute vec2 aScale;',
        'attribute float aRotation;',
        'attribute vec2 aTextureCoord;',
        'attribute float aColor;',

        'uniform vec2 projectionVector;',
        'uniform vec2 offsetVector;',
        'uniform mat3 uMatrix;',

        'varying vec2 vTextureCoord;',
        'varying float vColor;',

        'const vec2 center = vec2(-1.0, 1.0);',

        'void main(void) {',
        '   vec2 v;',
        '   vec2 sv = aVertexPosition * aScale;',
        '   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);',
        '   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);',
        '   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;',
        '   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);',
        '   vTextureCoord = aTextureCoord;',
      //  '   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;',
        '   vColor = aColor;',
        '}'
    ];


    /**
    * @property {number} textureCount - A local texture counter for multi-texture shaders.
    */
    this.textureCount = 0;

    
    this.init();
};

/**
* Initialises the shader
* @method init
*
*/
PIXI.PixiFastShader.prototype.init = function()
{

    var gl = this.gl;

    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
    
    gl.useProgram(program);

    // get and store the uniforms for the shader
    this.uSampler = gl.getUniformLocation(program, 'uSampler');

    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');
    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');
    this.dimensions = gl.getUniformLocation(program, 'dimensions');
    this.uMatrix = gl.getUniformLocation(program, 'uMatrix');

    // get and store the attributes
    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
    this.aPositionCoord = gl.getAttribLocation(program, 'aPositionCoord');

    this.aScale = gl.getAttribLocation(program, 'aScale');
    this.aRotation = gl.getAttribLocation(program, 'aRotation');

    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');
    this.colorAttribute = gl.getAttribLocation(program, 'aColor');
   

   
    // Begin worst hack eva //

    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?
    // maybe its somthing to do with the current state of the gl context.
    // Im convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel
    // If theres any webGL people that know why could happen please help :)
    if(this.colorAttribute === -1)
    {
        this.colorAttribute = 2;
    }

    this.attributes = [this.aVertexPosition, this.aPositionCoord,  this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute];
    
    // End worst hack eva //


    this.program = program;
};

/**
* Destroys the shader
* @method destroy
*
*/
PIXI.PixiFastShader.prototype.destroy = function()
{
    this.gl.deleteProgram( this.program );
    this.uniforms = null;
    this.gl = null;

    this.attributes = null;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */


PIXI.StripShader = function(gl)
{
    this._UID = PIXI._UID++;
    
    this.gl = gl;

    /**
    * @property {any} program - The WebGL program.
    */
    this.program = null;

    /**
     * @property {array} fragmentSrc - The fragment shader.
     */
    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
     //   'varying float vColor;',
        'uniform float alpha;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));',
      //  '   gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);',//gl_FragColor * alpha;',
        '}'
    ];

     /**
    * @property {array} fragmentSrc - The fragment shader.
    */
    this.vertexSrc  = [
        'attribute vec2 aVertexPosition;',
        'attribute vec2 aTextureCoord;',
        'uniform mat3 translationMatrix;',
        'uniform vec2 projectionVector;',
        'uniform vec2 offsetVector;',
      //  'uniform float alpha;',
       // 'uniform vec3 tint;',
        'varying vec2 vTextureCoord;',
      //  'varying vec4 vColor;',

        'void main(void) {',
        '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);',
        '   v -= offsetVector.xyx;',
        '   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);',
        '   vTextureCoord = aTextureCoord;',
       // '   vColor = aColor * vec4(tint * alpha, alpha);',
        '}'
    ];

    this.init();
};

/**
* Initialises the shader
* @method init
*
*/
PIXI.StripShader.prototype.init = function()
{
    var gl = this.gl;

    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
    gl.useProgram(program);

    // get and store the uniforms for the shader
    this.uSampler = gl.getUniformLocation(program, 'uSampler');
    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');
    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');
    this.colorAttribute = gl.getAttribLocation(program, 'aColor');
    //this.dimensions = gl.getUniformLocation(this.program, 'dimensions');

    // get and store the attributes
    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');

    this.attributes = [this.aVertexPosition, this.aTextureCoord];

    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');
    this.alpha = gl.getUniformLocation(program, 'alpha');

    this.program = program;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class PrimitiveShader
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.PrimitiveShader = function(gl)
{
    this._UID = PIXI._UID++;
 
    /**
     * @property gl
     * @type WebGLContext
     */
    this.gl = gl;

    /**
    * @property {any} program - The WebGL program.
    */
    this.program = null;

    /**
     * @property fragmentSrc
     * @type Array
     */
    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec4 vColor;',

        'void main(void) {',
        '   gl_FragColor = vColor;',
        '}'
    ];

    /**
     * @property vertexSrc
     * @type Array
     */
    this.vertexSrc  = [
        'attribute vec2 aVertexPosition;',
        'attribute vec4 aColor;',
        'uniform mat3 translationMatrix;',
        'uniform vec2 projectionVector;',
        'uniform vec2 offsetVector;',
        'uniform float alpha;',
        'uniform vec3 tint;',
        'varying vec4 vColor;',

        'void main(void) {',
        '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);',
        '   v -= offsetVector.xyx;',
        '   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);',
        '   vColor = aColor * vec4(tint * alpha, alpha);',
        '}'
    ];

    this.init();
};

/**
* Initialises the shader
* @method init
*
*/
PIXI.PrimitiveShader.prototype.init = function()
{

    var gl = this.gl;

    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
    gl.useProgram(program);

    // get and store the uniforms for the shader
    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');
    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');
    this.tintColor = gl.getUniformLocation(program, 'tint');


    // get and store the attributes
    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
    this.colorAttribute = gl.getAttribLocation(program, 'aColor');

    this.attributes = [this.aVertexPosition, this.colorAttribute];

    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');
    this.alpha = gl.getUniformLocation(program, 'alpha');

    this.program = program;
};

/**
* Destroys the shader
* @method destroy
*
*/
PIXI.PrimitiveShader.prototype.destroy = function()
{
    this.gl.deleteProgram( this.program );
    this.uniforms = null;
    this.gl = null;

    this.attribute = null;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class ComplexPrimitiveShader
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.ComplexPrimitiveShader = function(gl)
{
    this._UID = PIXI._UID++;
    /**
     * @property gl
     * @type WebGLContext
     */
    this.gl = gl;

    /**
    * @property {any} program - The WebGL program.
    */
    this.program = null;

    /**
     * @property fragmentSrc
     * @type Array
     */
    this.fragmentSrc = [
        'precision mediump float;',
        


        'varying vec4 vColor;',

        'void main(void) {',
        '   gl_FragColor = vColor;',
        '}'
    ];

    /**
     * @property vertexSrc
     * @type Array
     */
    this.vertexSrc  = [
        'attribute vec2 aVertexPosition;',
        //'attribute vec4 aColor;',
        'uniform mat3 translationMatrix;',
        'uniform vec2 projectionVector;',
        'uniform vec2 offsetVector;',
        
        'uniform vec3 tint;',
        'uniform float alpha;',
        'uniform vec3 color;',

        'varying vec4 vColor;',

        'void main(void) {',
        '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);',
        '   v -= offsetVector.xyx;',
        '   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);',
        '   vColor = vec4(color * alpha * tint, alpha);',//" * vec4(tint * alpha, alpha);',
        '}'
    ];

    this.init();
};

/**
* Initialises the shader
* @method init
*
*/
PIXI.ComplexPrimitiveShader.prototype.init = function()
{

    var gl = this.gl;

    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
    gl.useProgram(program);

    // get and store the uniforms for the shader
    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');
    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');
    this.tintColor = gl.getUniformLocation(program, 'tint');
    this.color = gl.getUniformLocation(program, 'color');


    // get and store the attributes
    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
   // this.colorAttribute = gl.getAttribLocation(program, 'aColor');

    this.attributes = [this.aVertexPosition, this.colorAttribute];

    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');
    this.alpha = gl.getUniformLocation(program, 'alpha');

    this.program = program;
};

/**
* Destroys the shader
* @method destroy
*
*/
PIXI.ComplexPrimitiveShader.prototype.destroy = function()
{
    this.gl.deleteProgram( this.program );
    this.uniforms = null;
    this.gl = null;

    this.attribute = null;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * A set of functions used by the webGL renderer to draw the primitive graphics data
 *
 * @class WebGLGraphics
 * @private
 * @static
 */
PIXI.WebGLGraphics = function()
{

};

/**
 * Renders the graphics object
 *
 * @static
 * @private
 * @method renderGraphics
 * @param graphics {Graphics}
 * @param renderSession {Object}
 */
PIXI.WebGLGraphics.renderGraphics = function(graphics, renderSession)//projection, offset)
{
    var gl = renderSession.gl;
    var projection = renderSession.projection,
        offset = renderSession.offset,
        shader = renderSession.shaderManager.primitiveShader,
        webGLData;

    if(graphics.dirty)
    {
        PIXI.WebGLGraphics.updateGraphics(graphics, gl);
    }

    var webGL = graphics._webGL[gl.id];

    // This  could be speeded up for sure!

    for (var i = 0; i < webGL.data.length; i++)
    {
        if(webGL.data[i].mode === 1)
        {
            webGLData = webGL.data[i];

            renderSession.stencilManager.pushStencil(graphics, webGLData, renderSession);

            // render quad..
            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );
            
            renderSession.stencilManager.popStencil(graphics, webGLData, renderSession);
            
            this.last = webGLData.mode;
        }
        else
        {
            webGLData = webGL.data[i];
           

            renderSession.shaderManager.setShader( shader );//activatePrimitiveShader();
            shader = renderSession.shaderManager.primitiveShader;
            gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));

            gl.uniform2f(shader.projectionVector, projection.x, -projection.y);
            gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);

            gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));

            gl.uniform1f(shader.alpha, graphics.worldAlpha);
            

            gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);

            gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);
            gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false,4 * 6, 2 * 4);

            // set the index buffer!
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
            gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );
        }
    }
};

/**
 * Updates the graphics object
 *
 * @static
 * @private
 * @method updateGraphics
 * @param graphicsData {Graphics} The graphics object to update
 * @param gl {WebGLContext} the current WebGL drawing context
 */
PIXI.WebGLGraphics.updateGraphics = function(graphics, gl)
{
    // get the contexts graphics object
    var webGL = graphics._webGL[gl.id];
    // if the graphics object does not exist in the webGL context time to create it!
    if(!webGL)webGL = graphics._webGL[gl.id] = {lastIndex:0, data:[], gl:gl};

    // flag the graphics as not dirty as we are about to update it...
    graphics.dirty = false;

    var i;

    // if the user cleared the graphics object we will need to clear every object
    if(graphics.clearDirty)
    {
        graphics.clearDirty = false;

        // lop through and return all the webGLDatas to the object pool so than can be reused later on
        for (i = 0; i < webGL.data.length; i++)
        {
            var graphicsData = webGL.data[i];
            graphicsData.reset();
            PIXI.WebGLGraphics.graphicsDataPool.push( graphicsData );
        }

        // clear the array and reset the index.. 
        webGL.data = [];
        webGL.lastIndex = 0;
    }

    
    var webGLData;
    
    // loop through the graphics datas and construct each one..
    // if the object is a complex fill then the new stencil buffer technique will be used
    // other wise graphics objects will be pushed into a batch..
    for (i = webGL.lastIndex; i < graphics.graphicsData.length; i++)
    {
        var data = graphics.graphicsData[i];

        if(data.type === PIXI.Graphics.POLY)
        {
            // MAKE SURE WE HAVE THE CORRECT TYPE..
            if(data.fill)
            {
                if(data.points.length > 6)
                {
                    if(data.points.length > 5 * 2)
                    {
                        webGLData = PIXI.WebGLGraphics.switchMode(webGL, 1);
                        PIXI.WebGLGraphics.buildComplexPoly(data, webGLData);
                    }
                    else
                    {
                        webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0);
                        PIXI.WebGLGraphics.buildPoly(data, webGLData);
                    }
                }
            }

            if(data.lineWidth > 0)
            {
                webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0);
                PIXI.WebGLGraphics.buildLine(data, webGLData);

            }
        }
        else
        {
            webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0);
            
            if(data.type === PIXI.Graphics.RECT)
            {
                PIXI.WebGLGraphics.buildRectangle(data, webGLData);
            }
            else if(data.type === PIXI.Graphics.CIRC || data.type === PIXI.Graphics.ELIP)
            {
                PIXI.WebGLGraphics.buildCircle(data, webGLData);
            }
            else if(data.type === PIXI.Graphics.RREC)
            {
                PIXI.WebGLGraphics.buildRoundedRectangle(data, webGLData);
            }
        }


        webGL.lastIndex++;
    }

    // upload all the dirty data...
    for (i = 0; i < webGL.data.length; i++)
    {
        webGLData = webGL.data[i];
        if(webGLData.dirty)webGLData.upload();
    }
};


PIXI.WebGLGraphics.switchMode = function(webGL, type)
{
    var webGLData;

    if(!webGL.data.length)
    {
        webGLData = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(webGL.gl);
        webGLData.mode = type;
        webGL.data.push(webGLData);
    }
    else
    {
        webGLData = webGL.data[webGL.data.length-1];

        if(webGLData.mode !== type || type === 1)
        {
            webGLData = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(webGL.gl);
            webGLData.mode = type;
            webGL.data.push(webGLData);
        }
    }

    webGLData.dirty = true;

    return webGLData;
};

/**
 * Builds a rectangle to draw
 *
 * @static
 * @private
 * @method buildRectangle
 * @param graphicsData {Graphics} The graphics object containing all the necessary properties
 * @param webGLData {Object}
 */
PIXI.WebGLGraphics.buildRectangle = function(graphicsData, webGLData)
{
    // --- //
    // need to convert points to a nice regular data
    //
    var rectData = graphicsData.points;
    var x = rectData[0];
    var y = rectData[1];
    var width = rectData[2];
    var height = rectData[3];


    if(graphicsData.fill)
    {
        var color = PIXI.hex2rgb(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vertPos = verts.length/6;

        // start
        verts.push(x, y);
        verts.push(r, g, b, alpha);

        verts.push(x + width, y);
        verts.push(r, g, b, alpha);

        verts.push(x , y + height);
        verts.push(r, g, b, alpha);

        verts.push(x + width, y + height);
        verts.push(r, g, b, alpha);

        // insert 2 dead triangles..
        indices.push(vertPos, vertPos, vertPos+1, vertPos+2, vertPos+3, vertPos+3);
    }

    if(graphicsData.lineWidth)
    {
        var tempPoints = graphicsData.points;

        graphicsData.points = [x, y,
                  x + width, y,
                  x + width, y + height,
                  x, y + height,
                  x, y];


        PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
};

/**
 * Builds a rounded rectangle to draw
 *
 * @static
 * @private
 * @method buildRoundedRectangle
 * @param graphicsData {Graphics} The graphics object containing all the necessary properties
 * @param webGLData {Object}
 */
PIXI.WebGLGraphics.buildRoundedRectangle = function(graphicsData, webGLData)
{

    var points = graphicsData.points;
    var x = points[0];
    var y = points[1];
    var width = points[2];
    var height = points[3];
    var radius = points[4];


    var recPoints = [];
    recPoints.push(x, y + radius);
    recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x, y + height - radius, x, y + height, x + radius, y + height));
    recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + width - radius, y + height, x + width, y + height, x + width, y + height - radius));
    recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + width, y + radius, x + width, y, x + width - radius, y));
    recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + radius, y, x, y, x, y + radius));


    if (graphicsData.fill) {
        var color = PIXI.hex2rgb(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vecPos = verts.length/6;

        var triangles = PIXI.PolyK.Triangulate(recPoints);

        var i = 0;
        for (i = 0; i < triangles.length; i+=3)
        {
            indices.push(triangles[i] + vecPos);
            indices.push(triangles[i] + vecPos);
            indices.push(triangles[i+1] + vecPos);
            indices.push(triangles[i+2] + vecPos);
            indices.push(triangles[i+2] + vecPos);
        }

        for (i = 0; i < recPoints.length; i++)
        {
            verts.push(recPoints[i], recPoints[++i], r, g, b, alpha);
        }
    }

    if (graphicsData.lineWidth) {
        var tempPoints = graphicsData.points;

        graphicsData.points = recPoints;

        PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
};

/**
 * Calcul the points for a quadratic bezier curve. (helper function..)
 * Based on : https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
 *
 * @param  {number}   fromX Origin point x
 * @param  {number}   fromY Origin point x
 * @param  {number}   cpX   Control point x
 * @param  {number}   cpY   Control point y
 * @param  {number}   toX   Destination point x
 * @param  {number}   toY   Destination point y
 * @return {number[]}
 */
PIXI.WebGLGraphics.quadraticBezierCurve = function(fromX, fromY, cpX, cpY, toX, toY) {
    var xa,
        ya,
        xb,
        yb,
        x,
        y,
        n = 20,
        points = [];

    function getPt(n1 , n2, perc) {
        var diff = n2 - n1;

        return n1 + ( diff * perc );
    }

    var j = 0;
    for (var i = 0; i <= n; i++ )
    {
        j = i / n;

        // The Green Line
        xa = getPt( fromX , cpX , j );
        ya = getPt( fromY , cpY , j );
        xb = getPt( cpX , toX , j );
        yb = getPt( cpY , toY , j );

        // The Black Dot
        x = getPt( xa , xb , j );
        y = getPt( ya , yb , j );

        points.push(x, y);
    }
    return points;
};

/**
 * Builds a circle to draw
 *
 * @static
 * @private
 * @method buildCircle
 * @param graphicsData {Graphics} The graphics object to draw
 * @param webGLData {Object}
 */
PIXI.WebGLGraphics.buildCircle = function(graphicsData, webGLData)
{
    
    // need to convert points to a nice regular data
    var rectData = graphicsData.points;
    var x = rectData[0];
    var y = rectData[1];
    var width = rectData[2];
    var height = rectData[3];

    var totalSegs = 40;
    var seg = (Math.PI * 2) / totalSegs ;

    var i = 0;

    if(graphicsData.fill)
    {
        var color = PIXI.hex2rgb(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vecPos = verts.length/6;

        indices.push(vecPos);

        for (i = 0; i < totalSegs + 1 ; i++)
        {
            verts.push(x,y, r, g, b, alpha);

            verts.push(x + Math.sin(seg * i) * width,
                       y + Math.cos(seg * i) * height,
                       r, g, b, alpha);

            indices.push(vecPos++, vecPos++);
        }

        indices.push(vecPos-1);
    }

    if(graphicsData.lineWidth)
    {
        var tempPoints = graphicsData.points;

        graphicsData.points = [];

        for (i = 0; i < totalSegs + 1; i++)
        {
            graphicsData.points.push(x + Math.sin(seg * i) * width,
                                     y + Math.cos(seg * i) * height);
        }

        PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
};

/**
 * Builds a line to draw
 *
 * @static
 * @private
 * @method buildLine
 * @param graphicsData {Graphics} The graphics object containing all the necessary properties
 * @param webGLData {Object}
 */
PIXI.WebGLGraphics.buildLine = function(graphicsData, webGLData)
{
    // TODO OPTIMISE!
    var i = 0;

    var points = graphicsData.points;
    if(points.length === 0)return;

    // if the line width is an odd number add 0.5 to align to a whole pixel
    if(graphicsData.lineWidth%2)
    {
        for (i = 0; i < points.length; i++) {
            points[i] += 0.5;
        }
    }

    // get first and last point.. figure out the middle!
    var firstPoint = new PIXI.Point( points[0], points[1] );
    var lastPoint = new PIXI.Point( points[points.length - 2], points[points.length - 1] );

    // if the first point is the last point - gonna have issues :)
    if(firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y)
    {
        // need to clone as we are going to slightly modify the shape..
        points = points.slice();

        points.pop();
        points.pop();

        lastPoint = new PIXI.Point( points[points.length - 2], points[points.length - 1] );

        var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) *0.5;
        var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) *0.5;

        points.unshift(midPointX, midPointY);
        points.push(midPointX, midPointY);
    }

    var verts = webGLData.points;
    var indices = webGLData.indices;
    var length = points.length / 2;
    var indexCount = points.length;
    var indexStart = verts.length/6;

    // DRAW the Line
    var width = graphicsData.lineWidth / 2;

    // sort color
    var color = PIXI.hex2rgb(graphicsData.lineColor);
    var alpha = graphicsData.lineAlpha;
    var r = color[0] * alpha;
    var g = color[1] * alpha;
    var b = color[2] * alpha;

    var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
    var perpx, perpy, perp2x, perp2y, perp3x, perp3y;
    var a1, b1, c1, a2, b2, c2;
    var denom, pdist, dist;

    p1x = points[0];
    p1y = points[1];

    p2x = points[2];
    p2y = points[3];

    perpx = -(p1y - p2y);
    perpy =  p1x - p2x;

    dist = Math.sqrt(perpx*perpx + perpy*perpy);

    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;

    // start
    verts.push(p1x - perpx , p1y - perpy,
                r, g, b, alpha);

    verts.push(p1x + perpx , p1y + perpy,
                r, g, b, alpha);

    for (i = 1; i < length-1; i++)
    {
        p1x = points[(i-1)*2];
        p1y = points[(i-1)*2 + 1];

        p2x = points[(i)*2];
        p2y = points[(i)*2 + 1];

        p3x = points[(i+1)*2];
        p3y = points[(i+1)*2 + 1];

        perpx = -(p1y - p2y);
        perpy = p1x - p2x;

        dist = Math.sqrt(perpx*perpx + perpy*perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;

        perp2x = -(p2y - p3y);
        perp2y = p2x - p3x;

        dist = Math.sqrt(perp2x*perp2x + perp2y*perp2y);
        perp2x /= dist;
        perp2y /= dist;
        perp2x *= width;
        perp2y *= width;

        a1 = (-perpy + p1y) - (-perpy + p2y);
        b1 = (-perpx + p2x) - (-perpx + p1x);
        c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
        a2 = (-perp2y + p3y) - (-perp2y + p2y);
        b2 = (-perp2x + p2x) - (-perp2x + p3x);
        c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);

        denom = a1*b2 - a2*b1;

        if(Math.abs(denom) < 0.1 )
        {

            denom+=10.1;
            verts.push(p2x - perpx , p2y - perpy,
                r, g, b, alpha);

            verts.push(p2x + perpx , p2y + perpy,
                r, g, b, alpha);

            continue;
        }

        px = (b1*c2 - b2*c1)/denom;
        py = (a2*c1 - a1*c2)/denom;


        pdist = (px -p2x) * (px -p2x) + (py -p2y) + (py -p2y);


        if(pdist > 140 * 140)
        {
            perp3x = perpx - perp2x;
            perp3y = perpy - perp2y;

            dist = Math.sqrt(perp3x*perp3x + perp3y*perp3y);
            perp3x /= dist;
            perp3y /= dist;
            perp3x *= width;
            perp3y *= width;

            verts.push(p2x - perp3x, p2y -perp3y);
            verts.push(r, g, b, alpha);

            verts.push(p2x + perp3x, p2y +perp3y);
            verts.push(r, g, b, alpha);

            verts.push(p2x - perp3x, p2y -perp3y);
            verts.push(r, g, b, alpha);

            indexCount++;
        }
        else
        {

            verts.push(px , py);
            verts.push(r, g, b, alpha);

            verts.push(p2x - (px-p2x), p2y - (py - p2y));
            verts.push(r, g, b, alpha);
        }
    }

    p1x = points[(length-2)*2];
    p1y = points[(length-2)*2 + 1];

    p2x = points[(length-1)*2];
    p2y = points[(length-1)*2 + 1];

    perpx = -(p1y - p2y);
    perpy = p1x - p2x;

    dist = Math.sqrt(perpx*perpx + perpy*perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;

    verts.push(p2x - perpx , p2y - perpy);
    verts.push(r, g, b, alpha);

    verts.push(p2x + perpx , p2y + perpy);
    verts.push(r, g, b, alpha);

    indices.push(indexStart);

    for (i = 0; i < indexCount; i++)
    {
        indices.push(indexStart++);
    }

    indices.push(indexStart-1);
};

/**
 * Builds a complex polygon to draw
 *
 * @static
 * @private
 * @method buildPoly
 * @param graphicsData {Graphics} The graphics object containing all the necessary properties
 * @param webGLData {Object}
 */
PIXI.WebGLGraphics.buildComplexPoly = function(graphicsData, webGLData)
{

    //TODO - no need to copy this as it gets turned into a FLoat32Array anyways..
    var points = graphicsData.points.slice();
    if(points.length < 6)return;

    // get first and last point.. figure out the middle!
    var indices = webGLData.indices;
    webGLData.points = points;
    webGLData.alpha = graphicsData.fillAlpha;
    webGLData.color = PIXI.hex2rgb(graphicsData.fillColor);

    /*
        calclate the bounds..
    */
    var minX = Infinity;
    var maxX = -Infinity;

    var minY = Infinity;
    var maxY = -Infinity;

    var x,y;

    // get size..
    for (var i = 0; i < points.length; i+=2)
    {
        x = points[i];
        y = points[i+1];

        minX = x < minX ? x : minX;
        maxX = x > maxX ? x : maxX;

        minY = y < minY ? y : minY;
        maxY = y > maxY ? y : maxY;
    }

    // add a quad to the end cos there is no point making another buffer!
    points.push(minX, minY,
                maxX, minY,
                maxX, maxY,
                minX, maxY);

    // push a quad onto the end.. 
    
    //TODO - this aint needed!
    var length = points.length / 2;
    for (i = 0; i < length; i++)
    {
        indices.push( i );
    }

};

PIXI.WebGLGraphics.buildPoly = function(graphicsData, webGLData)
{
    var points = graphicsData.points;
    if(points.length < 6)return;

    // get first and last point.. figure out the middle!
    var verts = webGLData.points;
    var indices = webGLData.indices;

    var length = points.length / 2;

    // sort color
    var color = PIXI.hex2rgb(graphicsData.fillColor);
    var alpha = graphicsData.fillAlpha;
    var r = color[0] * alpha;
    var g = color[1] * alpha;
    var b = color[2] * alpha;

    var triangles = PIXI.PolyK.Triangulate(points);
    var vertPos = verts.length / 6;

    var i = 0;

    for (i = 0; i < triangles.length; i+=3)
    {
        indices.push(triangles[i] + vertPos);
        indices.push(triangles[i] + vertPos);
        indices.push(triangles[i+1] + vertPos);
        indices.push(triangles[i+2] +vertPos);
        indices.push(triangles[i+2] + vertPos);
    }

    for (i = 0; i < length; i++)
    {
        verts.push(points[i * 2], points[i * 2 + 1],
                   r, g, b, alpha);
    }

};

PIXI.WebGLGraphics.graphicsDataPool = [];

PIXI.WebGLGraphicsData = function(gl)
{
    this.gl = gl;

    //TODO does this need to be split before uploding??
    this.color = [0,0,0]; // color split!
    this.points = [];
    this.indices = [];
    this.lastIndex = 0;
    this.buffer = gl.createBuffer();
    this.indexBuffer = gl.createBuffer();
    this.mode = 1;
    this.alpha = 1;
    this.dirty = true;
};

PIXI.WebGLGraphicsData.prototype.reset = function()
{
    this.points = [];
    this.indices = [];
    this.lastIndex = 0;
};

PIXI.WebGLGraphicsData.prototype.upload = function()
{
    var gl = this.gl;

//    this.lastIndex = graphics.graphicsData.length;
    this.glPoints = new Float32Array(this.points);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.glPoints, gl.STATIC_DRAW);

    this.glIndicies = new Uint16Array(this.indices);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.glIndicies, gl.STATIC_DRAW);

    this.dirty = false;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

PIXI.glContexts = []; // this is where we store the webGL contexts for easy access.

/**
 * the WebGLRenderer draws the stage and all its content onto a webGL enabled canvas. This renderer
 * should be used for browsers that support webGL. This Render works by automatically managing webGLBatch's.
 * So no need for Sprite Batch's or Sprite Cloud's
 * Dont forget to add the view to your DOM or you will not see anything :)
 *
 * @class WebGLRenderer
 * @constructor
 * @param width=0 {Number} the width of the canvas view
 * @param height=0 {Number} the height of the canvas view
 * @param view {HTMLCanvasElement} the canvas to use as a view, optional
 * @param transparent=false {Boolean} If the render view is transparent, default false
 * @param antialias=false {Boolean} sets antialias (only applicable in chrome at the moment)
 * @param preserveDrawingBuffer=false {Boolean} enables drawing buffer preservation, enable this if you need to call toDataUrl on the webgl context
 *
 */
PIXI.WebGLRenderer = function(width, height, view, transparent, antialias, preserveDrawingBuffer)
{
    if(!PIXI.defaultRenderer)
    {
        PIXI.sayHello('webGL');
        PIXI.defaultRenderer = this;
    }

    this.type = PIXI.WEBGL_RENDERER;

    // do a catch.. only 1 webGL renderer..
    /**
     * Whether the render view is transparent
     *
     * @property transparent
     * @type Boolean
     */
    this.transparent = !!transparent;

    /**
     * The value of the preserveDrawingBuffer flag affects whether or not the contents of the stencil buffer is retained after rendering.
     *
     * @property preserveDrawingBuffer
     * @type Boolean
     */
    this.preserveDrawingBuffer = preserveDrawingBuffer;

    /**
     * The width of the canvas view
     *
     * @property width
     * @type Number
     * @default 800
     */
    this.width = width || 800;

    /**
     * The height of the canvas view
     *
     * @property height
     * @type Number
     * @default 600
     */
    this.height = height || 600;

    /**
     * The canvas element that everything is drawn to
     *
     * @property view
     * @type HTMLCanvasElement
     */
    this.view = view || document.createElement( 'canvas' );
    this.view.width = this.width;
    this.view.height = this.height;

    // deal with losing context..
    this.contextLost = this.handleContextLost.bind(this);
    this.contextRestoredLost = this.handleContextRestored.bind(this);
    
    this.view.addEventListener('webglcontextlost', this.contextLost, false);
    this.view.addEventListener('webglcontextrestored', this.contextRestoredLost, false);

    this.options = {
        alpha: this.transparent,
        antialias:!!antialias, // SPEED UP??
        premultipliedAlpha:!!transparent,
        stencil:true,
        preserveDrawingBuffer: preserveDrawingBuffer
    };

    var gl = null;

    ['experimental-webgl', 'webgl'].forEach(function(name) {
        try {
            gl = gl || this.view.getContext(name,  this.options);
        } catch(e) {}
    }, this);

    if (!gl) {
        // fail, not able to get a context
        throw new Error('This browser does not support webGL. Try using the canvas renderer' + this);
    }

    this.gl = gl;
    this.glContextId = gl.id = PIXI.WebGLRenderer.glContextId ++;

    PIXI.glContexts[this.glContextId] = gl;

    if(!PIXI.blendModesWebGL)
    {
        PIXI.blendModesWebGL = [];

        PIXI.blendModesWebGL[PIXI.blendModes.NORMAL]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.ADD]           = [gl.SRC_ALPHA, gl.DST_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.MULTIPLY]      = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.SCREEN]        = [gl.SRC_ALPHA, gl.ONE];
        PIXI.blendModesWebGL[PIXI.blendModes.OVERLAY]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.DARKEN]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.LIGHTEN]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.COLOR_DODGE]   = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.COLOR_BURN]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.HARD_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.SOFT_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.DIFFERENCE]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.EXCLUSION]     = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.HUE]           = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.SATURATION]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.COLOR]         = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.LUMINOSITY]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
    }




    this.projection = new PIXI.Point();
    this.projection.x =  this.width/2;
    this.projection.y =  -this.height/2;

    this.offset = new PIXI.Point(0, 0);

    this.resize(this.width, this.height);
    this.contextLost = false;

    // time to create the render managers! each one focuses on managine a state in webGL
    this.shaderManager = new PIXI.WebGLShaderManager(gl);                   // deals with managing the shader programs and their attribs
    this.spriteBatch = new PIXI.WebGLSpriteBatch(gl);                       // manages the rendering of sprites
    //this.primitiveBatch = new PIXI.WebGLPrimitiveBatch(gl);               // primitive batch renderer
    this.maskManager = new PIXI.WebGLMaskManager(gl);                       // manages the masks using the stencil buffer
    this.filterManager = new PIXI.WebGLFilterManager(gl, this.transparent); // manages the filters
    this.stencilManager = new PIXI.WebGLStencilManager(gl);
    this.blendModeManager = new PIXI.WebGLBlendModeManager(gl);

    this.renderSession = {};
    this.renderSession.gl = this.gl;
    this.renderSession.drawCount = 0;
    this.renderSession.shaderManager = this.shaderManager;
    this.renderSession.maskManager = this.maskManager;
    this.renderSession.filterManager = this.filterManager;
    this.renderSession.blendModeManager = this.blendModeManager;
   // this.renderSession.primitiveBatch = this.primitiveBatch;
    this.renderSession.spriteBatch = this.spriteBatch;
    this.renderSession.stencilManager = this.stencilManager;
    this.renderSession.renderer = this;

    gl.useProgram(this.shaderManager.defaultShader.program);

    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);

    gl.enable(gl.BLEND);
    gl.colorMask(true, true, true, this.transparent);
};

// constructor
PIXI.WebGLRenderer.prototype.constructor = PIXI.WebGLRenderer;

/**
 * Renders the stage to its webGL view
 *
 * @method render
 * @param stage {Stage} the Stage element to be rendered
 */
PIXI.WebGLRenderer.prototype.render = function(stage)
{
    if(this.contextLost)return;


    // if rendering a new stage clear the batches..
    if(this.__stage !== stage)
    {
        if(stage.interactive)stage.interactionManager.removeEvents();

        // TODO make this work
        // dont think this is needed any more?
        this.__stage = stage;
    }

    // update any textures this includes uvs and uploading them to the gpu
    PIXI.WebGLRenderer.updateTextures();

    // update the scene graph
    stage.updateTransform();


    // interaction
    if(stage._interactive)
    {
        //need to add some events!
        if(!stage._interactiveEventsAdded)
        {
            stage._interactiveEventsAdded = true;
            stage.interactionManager.setTarget(this);
        }
    }
    
    var gl = this.gl;

    // -- Does this need to be set every frame? -- //
    //gl.colorMask(true, true, true, this.transparent);
    gl.viewport(0, 0, this.width, this.height);

    // make sure we are bound to the main frame buffer
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    if(this.transparent)
    {
        gl.clearColor(0, 0, 0, 0);
    }
    else
    {
        gl.clearColor(stage.backgroundColorSplit[0],stage.backgroundColorSplit[1],stage.backgroundColorSplit[2], 1);
    }


    gl.clear(gl.COLOR_BUFFER_BIT);

    this.renderDisplayObject( stage, this.projection );

    // interaction
    if(stage.interactive)
    {
        //need to add some events!
        if(!stage._interactiveEventsAdded)
        {
            stage._interactiveEventsAdded = true;
            stage.interactionManager.setTarget(this);
        }
    }
    else
    {
        if(stage._interactiveEventsAdded)
        {
            stage._interactiveEventsAdded = false;
            stage.interactionManager.setTarget(this);
        }
    }

    /*
    //can simulate context loss in Chrome like so:
     this.view.onmousedown = function(ev) {
     console.dir(this.gl.getSupportedExtensions());
        var ext = (
            gl.getExtension("WEBGL_scompressed_texture_s3tc")
       // gl.getExtension("WEBGL_compressed_texture_s3tc") ||
       // gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
       // gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc")
     );
     console.dir(ext);
     var loseCtx = this.gl.getExtension("WEBGL_lose_context");
      console.log("killing context");
      loseCtx.loseContext();
     setTimeout(function() {
          console.log("restoring context...");
          loseCtx.restoreContext();
      }.bind(this), 1000);
     }.bind(this);
     */
};

/**
 * Renders a display Object
 *
 * @method renderDIsplayObject
 * @param displayObject {DisplayObject} The DisplayObject to render
 * @param projection {Point} The projection
 * @param buffer {Array} a standard WebGL buffer 
 */
PIXI.WebGLRenderer.prototype.renderDisplayObject = function(displayObject, projection, buffer)
{
    this.renderSession.blendModeManager.setBlendMode(PIXI.blendModes.NORMAL);
    // reset the render session data..
    this.renderSession.drawCount = 0;
    this.renderSession.currentBlendMode = 9999;

    this.renderSession.projection = projection;
    this.renderSession.offset = this.offset;

    // start the sprite batch
    this.spriteBatch.begin(this.renderSession);

//    this.primitiveBatch.begin(this.renderSession);

    // start the filter manager
    this.filterManager.begin(this.renderSession, buffer);

    // render the scene!
    displayObject._renderWebGL(this.renderSession);

    // finish the sprite batch
    this.spriteBatch.end();

//    this.primitiveBatch.end();
};

/**
 * Updates the textures loaded into this webgl renderer
 *
 * @static
 * @method updateTextures
 * @private
 */
PIXI.WebGLRenderer.updateTextures = function()
{
    var i = 0;

    //TODO break this out into a texture manager...
  //  for (i = 0; i < PIXI.texturesToUpdate.length; i++)
  //      PIXI..updateWebGLTexture(PIXI.texturesToUpdate[i], this.gl);


    for (i=0; i < PIXI.Texture.frameUpdates.length; i++)
        PIXI.WebGLRenderer.updateTextureFrame(PIXI.Texture.frameUpdates[i]);

    for (i = 0; i < PIXI.texturesToDestroy.length; i++)
        PIXI.WebGLRenderer.destroyTexture(PIXI.texturesToDestroy[i]);

    PIXI.texturesToUpdate.length = 0;
    PIXI.texturesToDestroy.length = 0;
    PIXI.Texture.frameUpdates.length = 0;
};

/**
 * Destroys a loaded webgl texture
 *
 * @method destroyTexture
 * @param texture {Texture} The texture to update
 * @private
 */
PIXI.WebGLRenderer.destroyTexture = function(texture)
{
    //TODO break this out into a texture manager...

    for (var i = texture._glTextures.length - 1; i >= 0; i--)
    {
        var glTexture = texture._glTextures[i];
        var gl = PIXI.glContexts[i];

        if(gl && glTexture)
        {
            gl.deleteTexture(glTexture);
        }
    }

    texture._glTextures.length = 0;
};

/**
 *
 * @method updateTextureFrame
 * @param texture {Texture} The texture to update the frame from
 * @private
 */
PIXI.WebGLRenderer.updateTextureFrame = function(texture)
{
    //texture.updateFrame = false;

    // now set the uvs. Figured that the uv data sits with a texture rather than a sprite.
    // so uv data is stored on the texture itself
    texture._updateWebGLuvs();
};

/**
 * resizes the webGL view to the specified width and height
 *
 * @method resize
 * @param width {Number} the new width of the webGL view
 * @param height {Number} the new height of the webGL view
 */
PIXI.WebGLRenderer.prototype.resize = function(width, height)
{
    this.width = width;
    this.height = height;

    this.view.width = width;
    this.view.height = height;

    this.gl.viewport(0, 0, this.width, this.height);

    this.projection.x =  this.width/2;
    this.projection.y =  -this.height/2;
};

/**
 * Creates a WebGL texture
 *
 * @method createWebGLTexture
 * @param texture {Texture} the texture to render
 * @param gl {webglContext} the WebGL context
 * @static
 */
PIXI.createWebGLTexture = function(texture, gl)
{


    if(texture.hasLoaded)
    {
        texture._glTextures[gl.id] = gl.createTexture();

        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);

        // reguler...

        if(!texture._powerOf2)
        {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }
        else
        {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        }

        gl.bindTexture(gl.TEXTURE_2D, null);

        texture._dirty[gl.id] = false;
    }

    return  texture._glTextures[gl.id];
};

/**
 * Updates a WebGL texture
 *
 * @method updateWebGLTexture
 * @param texture {Texture} the texture to update
 * @param gl {webglContext} the WebGL context
 * @private
 */
PIXI.updateWebGLTexture = function(texture, gl)
{
    if( texture._glTextures[gl.id] )
    {
        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);

        // reguler...

        if(!texture._powerOf2)
        {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }
        else
        {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        }

        texture._dirty[gl.id] = false;
    }
    
};

/**
 * Handles a lost webgl context
 *
 * @method handleContextLost
 * @param event {Event}
 * @private
 */
PIXI.WebGLRenderer.prototype.handleContextLost = function(event)
{
    event.preventDefault();
    this.contextLost = true;
};

/**
 * Handles a restored webgl context
 *
 * @method handleContextRestored
 * @param event {Event}
 * @private
 */
PIXI.WebGLRenderer.prototype.handleContextRestored = function()
{

    //try 'experimental-webgl'
    try {
        this.gl = this.view.getContext('experimental-webgl',  this.options);
    } catch (e) {
        //try 'webgl'
        try {
            this.gl = this.view.getContext('webgl',  this.options);
        } catch (e2) {
            // fail, not able to get a context
            throw new Error(' This browser does not support webGL. Try using the canvas renderer' + this);
        }
    }

    var gl = this.gl;
    gl.id = PIXI.WebGLRenderer.glContextId ++;



    // need to set the context...
    this.shaderManager.setContext(gl);
    this.spriteBatch.setContext(gl);
    this.primitiveBatch.setContext(gl);
    this.maskManager.setContext(gl);
    this.filterManager.setContext(gl);


    this.renderSession.gl = this.gl;

    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);

    gl.enable(gl.BLEND);
    gl.colorMask(true, true, true, this.transparent);

    this.gl.viewport(0, 0, this.width, this.height);

    for(var key in PIXI.TextureCache)
    {
        var texture = PIXI.TextureCache[key].baseTexture;
        texture._glTextures = [];
    }

    /**
     * Whether the context was lost 
     * @property contextLost
     * @type Boolean
     */
    this.contextLost = false;

};

/**
 * Removes everything from the renderer (event listeners, spritebatch, etc...)
 *
 * @method destroy
 */
PIXI.WebGLRenderer.prototype.destroy = function()
{

    // deal with losing context..
    
    // remove listeners
    this.view.removeEventListener('webglcontextlost', this.contextLost);
    this.view.removeEventListener('webglcontextrestored', this.contextRestoredLost);

    PIXI.glContexts[this.glContextId] = null;

    this.projection = null;
    this.offset = null;

    // time to create the render managers! each one focuses on managine a state in webGL
    this.shaderManager.destroy();
    this.spriteBatch.destroy();
    this.primitiveBatch.destroy();
    this.maskManager.destroy();
    this.filterManager.destroy();

    this.shaderManager = null;
    this.spriteBatch = null;
    this.maskManager = null;
    this.filterManager = null;
    
    this.gl = null;
    //
    this.renderSession = null;
};


PIXI.WebGLRenderer.glContextId = 0;

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class WebGLMaskManager
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
* @private
*/
PIXI.WebGLBlendModeManager = function(gl)
{
    this.gl = gl;
    this.currentBlendMode = 99999;
};

/**
* Sets-up the given blendMode from WebGL's point of view
* @method setBlendMode 
*
* @param blendMode {Number} the blendMode, should be a Pixi const, such as PIXI.BlendModes.ADD
*/
PIXI.WebGLBlendModeManager.prototype.setBlendMode = function(blendMode)
{
    if(this.currentBlendMode === blendMode)return false;
 //   console.log("SWAP!")
    this.currentBlendMode = blendMode;
    
    var blendModeWebGL = PIXI.blendModesWebGL[this.currentBlendMode];
    this.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
    
    return true;
};

PIXI.WebGLBlendModeManager.prototype.destroy = function()
{
    this.gl = null;
};
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class WebGLMaskManager
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
* @private
*/
PIXI.WebGLMaskManager = function(gl)
{
    this.maskStack = [];
    this.maskPosition = 0;

    this.setContext(gl);

    this.reverse = false;
    this.count = 0;
};

/**
* Sets the drawing context to the one given in parameter
* @method setContext 
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.WebGLMaskManager.prototype.setContext = function(gl)
{
    this.gl = gl;
};

/**
* Applies the Mask and adds it to the current filter stack
* @method pushMask
* @param maskData {Array}
* @param renderSession {RenderSession}
*/
PIXI.WebGLMaskManager.prototype.pushMask = function(maskData, renderSession)
{
    var gl = renderSession.gl;

    if(maskData.dirty)
    {
        PIXI.WebGLGraphics.updateGraphics(maskData, gl);
    }

    if(!maskData._webGL[gl.id].data.length)return;

    renderSession.stencilManager.pushStencil(maskData, maskData._webGL[gl.id].data[0], renderSession);
};

/**
* Removes the last filter from the filter stack and doesn't return it
* @method popMask
*
* @param renderSession {RenderSession} an object containing all the useful parameters
*/
PIXI.WebGLMaskManager.prototype.popMask = function(maskData, renderSession)
{
    var gl = this.gl;
    renderSession.stencilManager.popStencil(maskData, maskData._webGL[gl.id].data[0], renderSession);
};


/**
* Destroys the mask stack
* @method destroy
*/
PIXI.WebGLMaskManager.prototype.destroy = function()
{
    this.maskStack = null;
    this.gl = null;
};
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */
 
//BA0285
//Intercontinental Hotel, 888 Howard Street
//San Francisco

/**
* @class WebGLStencilManager
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
* @private
*/
PIXI.WebGLStencilManager = function(gl)
{
   
    this.stencilStack = [];
    this.setContext(gl);
    this.reverse = true;
    this.count = 0;

};

/**
* Sets the drawing context to the one given in parameter
* @method setContext 
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.WebGLStencilManager.prototype.setContext = function(gl)
{
    this.gl = gl;
};

/**
* Applies the Mask and adds it to the current filter stack
* @method pushMask
* @param maskData {Array}
* @param renderSession {RenderSession}
*/
PIXI.WebGLStencilManager.prototype.pushStencil = function(graphics, webGLData, renderSession)
{
    var gl = this.gl;
    this.bindGraphics(graphics, webGLData, renderSession);

    if(this.stencilStack.length === 0)
    {
        gl.enable(gl.STENCIL_TEST);
        gl.clear(gl.STENCIL_BUFFER_BIT);
        this.reverse = true;
        this.count = 0;
    }

    this.stencilStack.push(webGLData);

    var level = this.count;

    gl.colorMask(false, false, false, false);

    gl.stencilFunc(gl.ALWAYS,0,0xFF);
    gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT);

    // draw the triangle strip!

    if(webGLData.mode === 1)
    {

        gl.drawElements(gl.TRIANGLE_FAN,  webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0 );
       
        if(this.reverse)
        {
            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
        }

        // draw a quad to increment..
        gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );
               
        if(this.reverse)
        {
            gl.stencilFunc(gl.EQUAL,0xFF-(level+1), 0xFF);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
        }

        this.reverse = !this.reverse;
    }
    else
    {
        if(!this.reverse)
        {
            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
        }

        gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );

        if(!this.reverse)
        {
            gl.stencilFunc(gl.EQUAL,0xFF-(level+1), 0xFF);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
        }
    }

    gl.colorMask(true, true, true, true);
    gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);

    this.count++;
};

//TODO this does not belong here!
PIXI.WebGLStencilManager.prototype.bindGraphics = function(graphics, webGLData, renderSession)
{
    //if(this._currentGraphics === graphics)return;
    this._currentGraphics = graphics;

    var gl = this.gl;

     // bind the graphics object..
    var projection = renderSession.projection,
        offset = renderSession.offset,
        shader;// = renderSession.shaderManager.primitiveShader;

    if(webGLData.mode === 1)
    {
        shader = renderSession.shaderManager.complexPrimativeShader;

        renderSession.shaderManager.setShader( shader );

        gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));

        gl.uniform2f(shader.projectionVector, projection.x, -projection.y);
        gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);

        gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));
        gl.uniform3fv(shader.color, webGLData.color);

        gl.uniform1f(shader.alpha, graphics.worldAlpha * webGLData.alpha);

        gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);

        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 2, 0);


        // now do the rest..
        // set the index buffer!
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
    }
    else
    {
        //renderSession.shaderManager.activatePrimitiveShader();
        shader = renderSession.shaderManager.primitiveShader;
        renderSession.shaderManager.setShader( shader );

        gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));

        gl.uniform2f(shader.projectionVector, projection.x, -projection.y);
        gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);

        gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));

        gl.uniform1f(shader.alpha, graphics.worldAlpha);
        
        gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);

        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);
        gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false,4 * 6, 2 * 4);

        // set the index buffer!
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
    }
};

PIXI.WebGLStencilManager.prototype.popStencil = function(graphics, webGLData, renderSession)
{
	var gl = this.gl;
    this.stencilStack.pop();
   
    this.count--;

    if(this.stencilStack.length === 0)
    {
        // the stack is empty!
        gl.disable(gl.STENCIL_TEST);

    }
    else
    {

        var level = this.count;

        this.bindGraphics(graphics, webGLData, renderSession);

        gl.colorMask(false, false, false, false);
    
        if(webGLData.mode === 1)
        {
            this.reverse = !this.reverse;

            if(this.reverse)
            {
                gl.stencilFunc(gl.EQUAL, 0xFF - (level+1), 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
            }

            // draw a quad to increment..
            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );
            
            gl.stencilFunc(gl.ALWAYS,0,0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT);

            // draw the triangle strip!
            gl.drawElements(gl.TRIANGLE_FAN,  webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0 );
           
            if(!this.reverse)
            {
                gl.stencilFunc(gl.EQUAL,0xFF-(level), 0xFF);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level, 0xFF);
            }

        }
        else
        {
          //  console.log("<<>>")
            if(!this.reverse)
            {
                gl.stencilFunc(gl.EQUAL, 0xFF - (level+1), 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
            }

            gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );

            if(!this.reverse)
            {
                gl.stencilFunc(gl.EQUAL,0xFF-(level), 0xFF);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level, 0xFF);
            }
        }

        gl.colorMask(true, true, true, true);
        gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);


    }

    //renderSession.shaderManager.deactivatePrimitiveShader();
};

/**
* Destroys the mask stack
* @method destroy
*/
PIXI.WebGLStencilManager.prototype.destroy = function()
{
    this.maskStack = null;
    this.gl = null;
};
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class WebGLShaderManager
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
* @private
*/
PIXI.WebGLShaderManager = function(gl)
{

    this.maxAttibs = 10;
    this.attribState = [];
    this.tempAttribState = [];
    this.shaderMap = [];

    for (var i = 0; i < this.maxAttibs; i++) {
        this.attribState[i] = false;
    }

    this.setContext(gl);
    // the final one is used for the rendering strips
};


/**
* Initialises the context and the properties
* @method setContext 
* @param gl {WebGLContext} the current WebGL drawing context
* @param transparent {Boolean} Whether or not the drawing context should be transparent
*/
PIXI.WebGLShaderManager.prototype.setContext = function(gl)
{
    this.gl = gl;
    
    // the next one is used for rendering primatives
    this.primitiveShader = new PIXI.PrimitiveShader(gl);

    // the next one is used for rendering triangle strips
    this.complexPrimativeShader = new PIXI.ComplexPrimitiveShader(gl);

    // this shader is used for the default sprite rendering
    this.defaultShader = new PIXI.PixiShader(gl);

    // this shader is used for the fast sprite rendering
    this.fastShader = new PIXI.PixiFastShader(gl);

    // the next one is used for rendering triangle strips
    this.stripShader = new PIXI.StripShader(gl);
    this.setShader(this.defaultShader);
};


/**
* Takes the attributes given in parameters 
* @method setAttribs
* @param attribs {Array} attribs 
*/
PIXI.WebGLShaderManager.prototype.setAttribs = function(attribs)
{
    // reset temp state

    var i;

    for (i = 0; i < this.tempAttribState.length; i++)
    {
        this.tempAttribState[i] = false;
    }

    // set the new attribs
    for (i = 0; i < attribs.length; i++)
    {
        var attribId = attribs[i];
        this.tempAttribState[attribId] = true;
    }

    var gl = this.gl;

    for (i = 0; i < this.attribState.length; i++)
    {
        if(this.attribState[i] !== this.tempAttribState[i])
        {
            this.attribState[i] = this.tempAttribState[i];

            if(this.tempAttribState[i])
            {
                gl.enableVertexAttribArray(i);
            }
            else
            {
                gl.disableVertexAttribArray(i);
            }
        }
    }
};

PIXI.WebGLShaderManager.prototype.setShader = function(shader)
{
    if(this._currentId === shader._UID)return false;
    
    this._currentId = shader._UID;

    this.currentShader = shader;

    this.gl.useProgram(shader.program);
    this.setAttribs(shader.attributes);

    return true;
};

/**
* Destroys
* @method destroy
*/
PIXI.WebGLShaderManager.prototype.destroy = function()
{
    this.attribState = null;

    this.tempAttribState = null;

    this.primitiveShader.destroy();

    this.defaultShader.destroy();

    this.fastShader.destroy();

    this.stripShader.destroy();

    this.gl = null;
};


/**
 * @author Mat Groves
 * 
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original pixi version!
 *
 * Heavily inspired by LibGDX's WebGLSpriteBatch:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/WebGLSpriteBatch.java
 */

 /**
 *
 * @class WebGLSpriteBatch
 * @private
 * @constructor
 * @param gl {WebGLContext} the current WebGL drawing context
 *
 */
PIXI.WebGLSpriteBatch = function(gl)
{

    /**
     * 
     *
     * @property vertSize
     * @type Number
     */
    this.vertSize = 6;

    /**
     * The number of images in the SpriteBatch before it flushes
     * @property size
     * @type Number
     */
    this.size = 2000;//Math.pow(2, 16) /  this.vertSize;

    //the total number of floats in our batch
    var numVerts = this.size * 4 *  this.vertSize;
    //the total number of indices in our batch
    var numIndices = this.size * 6;

    //vertex data

    /**
    * Holds the vertices
    *
    * @property vertices
    * @type Float32Array
    */
    this.vertices = new Float32Array(numVerts);

    //index data
    /**
     * Holds the indices
     *
     * @property indices
     * @type Uint16Array
     */
    this.indices = new Uint16Array(numIndices);
    
    this.lastIndexCount = 0;

    for (var i=0, j=0; i < numIndices; i += 6, j += 4)
    {
        this.indices[i + 0] = j + 0;
        this.indices[i + 1] = j + 1;
        this.indices[i + 2] = j + 2;
        this.indices[i + 3] = j + 0;
        this.indices[i + 4] = j + 2;
        this.indices[i + 5] = j + 3;
    }


    this.drawing = false;
    this.currentBatchSize = 0;
    this.currentBaseTexture = null;
    
    this.setContext(gl);

    this.dirty = true;

    this.textures = [];
    this.blendModes = [];
};

/**
* 
* @method setContext
*
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.WebGLSpriteBatch.prototype.setContext = function(gl)
{
    this.gl = gl;

    // create a couple of buffers
    this.vertexBuffer = gl.createBuffer();
    this.indexBuffer = gl.createBuffer();

    // 65535 is max index, so 65535 / 6 = 10922.


    //upload the index data
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);

    this.currentBlendMode = 99999;
};

/**
* 
* @method begin
*
* @param renderSession {RenderSession} the RenderSession
*/
PIXI.WebGLSpriteBatch.prototype.begin = function(renderSession)
{
    this.renderSession = renderSession;
    this.shader = this.renderSession.shaderManager.defaultShader;

    this.start();
};

/**
* 
* @method end
*
*/
PIXI.WebGLSpriteBatch.prototype.end = function()
{
    this.flush();
};

/**
* 
* @method render
* 
* @param sprite {Sprite} the sprite to render when using this spritebatch
*/
PIXI.WebGLSpriteBatch.prototype.render = function(sprite)
{
    var texture = sprite.texture;
    
   //TODO set blend modes.. 
    // check texture..
    if(this.currentBatchSize >= this.size)
    {
        //return;
        this.flush();
        this.currentBaseTexture = texture.baseTexture;
    }

    // get the uvs for the texture
    var uvs = texture._uvs;
    // if the uvs have not updated then no point rendering just yet!
    if(!uvs)return;

    // get the sprites current alpha
    var alpha = sprite.worldAlpha;
    var tint = sprite.tint;

    var verticies = this.vertices;


    // TODO trim??
    var aX = sprite.anchor.x;
    var aY = sprite.anchor.y;

    var w0, w1, h0, h1;
        
    if (texture.trim)
    {
        // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..
        var trim = texture.trim;

        w1 = trim.x - aX * trim.width;
        w0 = w1 + texture.crop.width;

        h1 = trim.y - aY * trim.height;
        h0 = h1 + texture.crop.height;

    }
    else
    {
        w0 = (texture.frame.width ) * (1-aX);
        w1 = (texture.frame.width ) * -aX;

        h0 = texture.frame.height * (1-aY);
        h1 = texture.frame.height * -aY;
    }

    var index = this.currentBatchSize * 4 * this.vertSize;

    var worldTransform = sprite.worldTransform;

    var a = worldTransform.a;//[0];
    var b = worldTransform.c;//[3];
    var c = worldTransform.b;//[1];
    var d = worldTransform.d;//[4];
    var tx = worldTransform.tx;//[2];
    var ty = worldTransform.ty;///[5];

    // xy
    verticies[index++] = a * w1 + c * h1 + tx;
    verticies[index++] = d * h1 + b * w1 + ty;
    // uv
    verticies[index++] = uvs.x0;
    verticies[index++] = uvs.y0;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;

    // xy
    verticies[index++] = a * w0 + c * h1 + tx;
    verticies[index++] = d * h1 + b * w0 + ty;
    // uv
    verticies[index++] = uvs.x1;
    verticies[index++] = uvs.y1;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;

    // xy
    verticies[index++] = a * w0 + c * h0 + tx;
    verticies[index++] = d * h0 + b * w0 + ty;
    // uv
    verticies[index++] = uvs.x2;
    verticies[index++] = uvs.y2;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;

    // xy
    verticies[index++] = a * w1 + c * h0 + tx;
    verticies[index++] = d * h0 + b * w1 + ty;
    // uv
    verticies[index++] = uvs.x3;
    verticies[index++] = uvs.y3;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;
    
    // increment the batchsize
    this.textures[this.currentBatchSize] = sprite.texture.baseTexture;
    this.blendModes[this.currentBatchSize] = sprite.blendMode;

    this.currentBatchSize++;

};

/**
* Renders a tilingSprite using the spriteBatch
* @method renderTilingSprite
* 
* @param sprite {TilingSprite} the tilingSprite to render
*/
PIXI.WebGLSpriteBatch.prototype.renderTilingSprite = function(tilingSprite)
{
    var texture = tilingSprite.tilingTexture;

    
    // check texture..
    if(this.currentBatchSize >= this.size)
    {
        //return;
        this.flush();
        this.currentBaseTexture = texture.baseTexture;
    }

     // set the textures uvs temporarily
    // TODO create a separate texture so that we can tile part of a texture

    if(!tilingSprite._uvs)tilingSprite._uvs = new PIXI.TextureUvs();

    var uvs = tilingSprite._uvs;

    tilingSprite.tilePosition.x %= texture.baseTexture.width * tilingSprite.tileScaleOffset.x;
    tilingSprite.tilePosition.y %= texture.baseTexture.height * tilingSprite.tileScaleOffset.y;

    var offsetX =  tilingSprite.tilePosition.x/(texture.baseTexture.width*tilingSprite.tileScaleOffset.x);
    var offsetY =  tilingSprite.tilePosition.y/(texture.baseTexture.height*tilingSprite.tileScaleOffset.y);

    var scaleX =  (tilingSprite.width / texture.baseTexture.width)  / (tilingSprite.tileScale.x * tilingSprite.tileScaleOffset.x);
    var scaleY =  (tilingSprite.height / texture.baseTexture.height) / (tilingSprite.tileScale.y * tilingSprite.tileScaleOffset.y);

    uvs.x0 = 0 - offsetX;
    uvs.y0 = 0 - offsetY;

    uvs.x1 = (1 * scaleX) - offsetX;
    uvs.y1 = 0 - offsetY;

    uvs.x2 = (1 * scaleX) - offsetX;
    uvs.y2 = (1 * scaleY) - offsetY;

    uvs.x3 = 0 - offsetX;
    uvs.y3 = (1 *scaleY) - offsetY;

    // get the tilingSprites current alpha
    var alpha = tilingSprite.worldAlpha;
    var tint = tilingSprite.tint;

    var  verticies = this.vertices;

    var width = tilingSprite.width;
    var height = tilingSprite.height;

    // TODO trim??
    var aX = tilingSprite.anchor.x;
    var aY = tilingSprite.anchor.y;
    var w0 = width * (1-aX);
    var w1 = width * -aX;

    var h0 = height * (1-aY);
    var h1 = height * -aY;

    var index = this.currentBatchSize * 4 * this.vertSize;

    var worldTransform = tilingSprite.worldTransform;

    var a = worldTransform.a;//[0];
    var b = worldTransform.c;//[3];
    var c = worldTransform.b;//[1];
    var d = worldTransform.d;//[4];
    var tx = worldTransform.tx;//[2];
    var ty = worldTransform.ty;///[5];

    // xy
    verticies[index++] = a * w1 + c * h1 + tx;
    verticies[index++] = d * h1 + b * w1 + ty;
    // uv
    verticies[index++] = uvs.x0;
    verticies[index++] = uvs.y0;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;

    // xy
    verticies[index++] = (a * w0 + c * h1 + tx);
    verticies[index++] = d * h1 + b * w0 + ty;
    // uv
    verticies[index++] = uvs.x1;
    verticies[index++] = uvs.y1;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;
    
    // xy
    verticies[index++] = a * w0 + c * h0 + tx;
    verticies[index++] = d * h0 + b * w0 + ty;
    // uv
    verticies[index++] = uvs.x2;
    verticies[index++] = uvs.y2;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;

    // xy
    verticies[index++] = a * w1 + c * h0 + tx;
    verticies[index++] = d * h0 + b * w1 + ty;
    // uv
    verticies[index++] = uvs.x3;
    verticies[index++] = uvs.y3;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;

    // increment the batchs
    this.textures[this.currentBatchSize] = texture.baseTexture;
    this.blendModes[this.currentBatchSize] = tilingSprite.blendMode;
    this.currentBatchSize++;
};


/**
* Renders the content and empties the current batch
*
* @method flush
* 
*/
PIXI.WebGLSpriteBatch.prototype.flush = function()
{
    // If the batch is length 0 then return as there is nothing to draw
    if (this.currentBatchSize===0)return;

    var gl = this.gl;

    this.renderSession.shaderManager.setShader(this.renderSession.shaderManager.defaultShader);

    if(this.dirty)
    {
        this.dirty = false;
        // bind the main texture
        gl.activeTexture(gl.TEXTURE0);

        // bind the buffers
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

        // set the projection
        var projection = this.renderSession.projection;
        gl.uniform2f(this.shader.projectionVector, projection.x, projection.y);

        // set the pointers
        var stride =  this.vertSize * 4;
        gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);
        gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, false, stride, 2 * 4);
        gl.vertexAttribPointer(this.shader.colorAttribute, 2, gl.FLOAT, false, stride, 4 * 4);

    }

    // upload the verts to the buffer  
    if(this.currentBatchSize > ( this.size * 0.5 ) )
    {
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);
    }
    else
    {
        var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);
    }

    var nextTexture, nextBlendMode;
    var batchSize = 0;
    var start = 0;

    var currentBaseTexture = null;
    var currentBlendMode = this.renderSession.blendModeManager.currentBlendMode;

    for (var i = 0, j = this.currentBatchSize; i < j; i++) {
        
        nextTexture = this.textures[i];
        nextBlendMode = this.blendModes[i];

        if(currentBaseTexture !== nextTexture || currentBlendMode !== nextBlendMode)
        {
            this.renderBatch(currentBaseTexture, batchSize, start);

            start = i;
            batchSize = 0;
            currentBaseTexture = nextTexture;
            currentBlendMode = nextBlendMode;
            
            this.renderSession.blendModeManager.setBlendMode( currentBlendMode );
        }

        batchSize++;
    }

    this.renderBatch(currentBaseTexture, batchSize, start);

    // then reset the batch!
    this.currentBatchSize = 0;
};

PIXI.WebGLSpriteBatch.prototype.renderBatch = function(texture, size, startIndex)
{
    if(size === 0)return;

    var gl = this.gl;
    // bind the current texture
    gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id] || PIXI.createWebGLTexture(texture, gl));

    // check if a texture is dirty..
    if(texture._dirty[gl.id])
    {
        PIXI.updateWebGLTexture(this.currentBaseTexture, gl);
    }

    // now draw those suckas!
    gl.drawElements(gl.TRIANGLES, size * 6, gl.UNSIGNED_SHORT, startIndex * 6 * 2);
    
    // increment the draw count
    this.renderSession.drawCount++;
};

/**
* 
* @method stop
*
*/
PIXI.WebGLSpriteBatch.prototype.stop = function()
{
    this.flush();
};

/**
* 
* @method start
*
*/
PIXI.WebGLSpriteBatch.prototype.start = function()
{
    this.dirty = true;
};

/**
* Destroys the SpriteBatch
* @method destroy
*/
PIXI.WebGLSpriteBatch.prototype.destroy = function()
{

    this.vertices = null;
    this.indices = null;
    
    this.gl.deleteBuffer( this.vertexBuffer );
    this.gl.deleteBuffer( this.indexBuffer );
    
    this.currentBaseTexture = null;
    
    this.gl = null;
};


/**
 * @author Mat Groves
 * 
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original pixi version!
 *
 * Heavily inspired by LibGDX's WebGLSpriteBatch:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/WebGLSpriteBatch.java
 */

PIXI.WebGLFastSpriteBatch = function(gl)
{
   

    this.vertSize = 10;
    this.maxSize = 6000;//Math.pow(2, 16) /  this.vertSize;
    this.size = this.maxSize;

    //the total number of floats in our batch
    var numVerts = this.size * 4 *  this.vertSize;
    //the total number of indices in our batch
    var numIndices = this.maxSize * 6;

     //vertex data
    this.vertices = new Float32Array(numVerts);
    //index data
    this.indices = new Uint16Array(numIndices);
    
    this.vertexBuffer = null;
    this.indexBuffer = null;

    this.lastIndexCount = 0;

    for (var i=0, j=0; i < numIndices; i += 6, j += 4)
    {
        this.indices[i + 0] = j + 0;
        this.indices[i + 1] = j + 1;
        this.indices[i + 2] = j + 2;
        this.indices[i + 3] = j + 0;
        this.indices[i + 4] = j + 2;
        this.indices[i + 5] = j + 3;
    }

    this.drawing = false;
    this.currentBatchSize = 0;
    this.currentBaseTexture = null;
   
    this.currentBlendMode = 0;
    this.renderSession = null;
    

    this.shader = null;

    this.matrix = null;

    this.setContext(gl);
};

PIXI.WebGLFastSpriteBatch.prototype.setContext = function(gl)
{
    this.gl = gl;

    // create a couple of buffers
    this.vertexBuffer = gl.createBuffer();
    this.indexBuffer = gl.createBuffer();

    // 65535 is max index, so 65535 / 6 = 10922.


    //upload the index data
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);
};

PIXI.WebGLFastSpriteBatch.prototype.begin = function(spriteBatch, renderSession)
{
    this.renderSession = renderSession;
    this.shader = this.renderSession.shaderManager.fastShader;

    this.matrix = spriteBatch.worldTransform.toArray(true);

    this.start();
};

PIXI.WebGLFastSpriteBatch.prototype.end = function()
{
    this.flush();
};


PIXI.WebGLFastSpriteBatch.prototype.render = function(spriteBatch)
{

    var children = spriteBatch.children;
    var sprite = children[0];

    // if the uvs have not updated then no point rendering just yet!
    
    // check texture.
    if(!sprite.texture._uvs)return;
   
    this.currentBaseTexture = sprite.texture.baseTexture;
    
    // check blend mode
    if(sprite.blendMode !== this.renderSession.blendModeManager.currentBlendMode)
    {
        this.flush();
        this.renderSession.blendModeManager.setBlendMode(sprite.blendMode);
    }
    
    for(var i=0,j= children.length; i<j; i++)
    {
        this.renderSprite(children[i]);
    }

    this.flush();
};

PIXI.WebGLFastSpriteBatch.prototype.renderSprite = function(sprite)
{
    //sprite = children[i];
    if(!sprite.visible)return;
    
    // TODO trim??
    if(sprite.texture.baseTexture !== this.currentBaseTexture)
    {
        this.flush();
        this.currentBaseTexture = sprite.texture.baseTexture;
        
        if(!sprite.texture._uvs)return;
    }

    var uvs, verticies = this.vertices, width, height, w0, w1, h0, h1, index;

    uvs = sprite.texture._uvs;


    width = sprite.texture.frame.width;
    height = sprite.texture.frame.height;

    if (sprite.texture.trim)
    {
        // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..
        var trim = sprite.texture.trim;

        w1 = trim.x - sprite.anchor.x * trim.width;
        w0 = w1 + sprite.texture.crop.width;

        h1 = trim.y - sprite.anchor.y * trim.height;
        h0 = h1 + sprite.texture.crop.height;
    }
    else
    {
        w0 = (sprite.texture.frame.width ) * (1-sprite.anchor.x);
        w1 = (sprite.texture.frame.width ) * -sprite.anchor.x;

        h0 = sprite.texture.frame.height * (1-sprite.anchor.y);
        h1 = sprite.texture.frame.height * -sprite.anchor.y;
    }

    index = this.currentBatchSize * 4 * this.vertSize;

    // xy
    verticies[index++] = w1;
    verticies[index++] = h1;

    verticies[index++] = sprite.position.x;
    verticies[index++] = sprite.position.y;

    //scale
    verticies[index++] = sprite.scale.x;
    verticies[index++] = sprite.scale.y;

    //rotation
    verticies[index++] = sprite.rotation;

    // uv
    verticies[index++] = uvs.x0;
    verticies[index++] = uvs.y1;
    // color
    verticies[index++] = sprite.alpha;
 

    // xy
    verticies[index++] = w0;
    verticies[index++] = h1;

    verticies[index++] = sprite.position.x;
    verticies[index++] = sprite.position.y;

    //scale
    verticies[index++] = sprite.scale.x;
    verticies[index++] = sprite.scale.y;

     //rotation
    verticies[index++] = sprite.rotation;

    // uv
    verticies[index++] = uvs.x1;
    verticies[index++] = uvs.y1;
    // color
    verticies[index++] = sprite.alpha;
  

    // xy
    verticies[index++] = w0;
    verticies[index++] = h0;

    verticies[index++] = sprite.position.x;
    verticies[index++] = sprite.position.y;

    //scale
    verticies[index++] = sprite.scale.x;
    verticies[index++] = sprite.scale.y;

     //rotation
    verticies[index++] = sprite.rotation;

    // uv
    verticies[index++] = uvs.x2;
    verticies[index++] = uvs.y2;
    // color
    verticies[index++] = sprite.alpha;
 



    // xy
    verticies[index++] = w1;
    verticies[index++] = h0;

    verticies[index++] = sprite.position.x;
    verticies[index++] = sprite.position.y;

    //scale
    verticies[index++] = sprite.scale.x;
    verticies[index++] = sprite.scale.y;

     //rotation
    verticies[index++] = sprite.rotation;

    // uv
    verticies[index++] = uvs.x3;
    verticies[index++] = uvs.y3;
    // color
    verticies[index++] = sprite.alpha;

    // increment the batchs
    this.currentBatchSize++;

    if(this.currentBatchSize >= this.size)
    {
        this.flush();
    }
};

PIXI.WebGLFastSpriteBatch.prototype.flush = function()
{

    // If the batch is length 0 then return as there is nothing to draw
    if (this.currentBatchSize===0)return;

    var gl = this.gl;
    
    // bind the current texture

    if(!this.currentBaseTexture._glTextures[gl.id])PIXI.createWebGLTexture(this.currentBaseTexture, gl);

    gl.bindTexture(gl.TEXTURE_2D, this.currentBaseTexture._glTextures[gl.id]);

    // upload the verts to the buffer

   
    if(this.currentBatchSize > ( this.size * 0.5 ) )
    {
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);
    }
    else
    {
        var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);
    }
    
    
    // now draw those suckas!
    gl.drawElements(gl.TRIANGLES, this.currentBatchSize * 6, gl.UNSIGNED_SHORT, 0);
   
    // then reset the batch!
    this.currentBatchSize = 0;

    // increment the draw count
    this.renderSession.drawCount++;
};


PIXI.WebGLFastSpriteBatch.prototype.stop = function()
{
    this.flush();
};

PIXI.WebGLFastSpriteBatch.prototype.start = function()
{
    var gl = this.gl;

    // bind the main texture
    gl.activeTexture(gl.TEXTURE0);

    // bind the buffers
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

    // set the projection
    var projection = this.renderSession.projection;
    gl.uniform2f(this.shader.projectionVector, projection.x, projection.y);

    // set the matrix
    gl.uniformMatrix3fv(this.shader.uMatrix, false, this.matrix);

    // set the pointers
    var stride =  this.vertSize * 4;

    gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);
    gl.vertexAttribPointer(this.shader.aPositionCoord, 2, gl.FLOAT, false, stride, 2 * 4);
    gl.vertexAttribPointer(this.shader.aScale, 2, gl.FLOAT, false, stride, 4 * 4);
    gl.vertexAttribPointer(this.shader.aRotation, 1, gl.FLOAT, false, stride, 6 * 4);
    gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, false, stride, 7 * 4);
    gl.vertexAttribPointer(this.shader.colorAttribute, 1, gl.FLOAT, false, stride, 9 * 4);

    
};



/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class WebGLFilterManager
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
* @param transparent {Boolean} Whether or not the drawing context should be transparent
* @private
*/
PIXI.WebGLFilterManager = function(gl, transparent)
{
    this.transparent = transparent;

    this.filterStack = [];
    
    this.offsetX = 0;
    this.offsetY = 0;

    this.setContext(gl);
};

// API
/**
* Initialises the context and the properties
* @method setContext 
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.WebGLFilterManager.prototype.setContext = function(gl)
{
    this.gl = gl;
    this.texturePool = [];

    this.initShaderBuffers();
};

/**
* 
* @method begin
* @param renderSession {RenderSession} 
* @param buffer {ArrayBuffer} 
*/
PIXI.WebGLFilterManager.prototype.begin = function(renderSession, buffer)
{
    this.renderSession = renderSession;
    this.defaultShader = renderSession.shaderManager.defaultShader;

    var projection = this.renderSession.projection;
   // console.log(this.width)
    this.width = projection.x * 2;
    this.height = -projection.y * 2;
    this.buffer = buffer;
};

/**
* Applies the filter and adds it to the current filter stack
* @method pushFilter
* @param filterBlock {Object} the filter that will be pushed to the current filter stack
*/
PIXI.WebGLFilterManager.prototype.pushFilter = function(filterBlock)
{
    var gl = this.gl;

    var projection = this.renderSession.projection;
    var offset = this.renderSession.offset;

    filterBlock._filterArea = filterBlock.target.filterArea || filterBlock.target.getBounds();


    // filter program
    // OPTIMISATION - the first filter is free if its a simple color change?
    this.filterStack.push(filterBlock);

    var filter = filterBlock.filterPasses[0];

    this.offsetX += filterBlock._filterArea.x;
    this.offsetY += filterBlock._filterArea.y;

    var texture = this.texturePool.pop();
    if(!texture)
    {
        texture = new PIXI.FilterTexture(this.gl, this.width, this.height);
    }
    else
    {
        texture.resize(this.width, this.height);
    }

    gl.bindTexture(gl.TEXTURE_2D,  texture.texture);

    var filterArea = filterBlock._filterArea;// filterBlock.target.getBounds();///filterBlock.target.filterArea;

    var padding = filter.padding;
    filterArea.x -= padding;
    filterArea.y -= padding;
    filterArea.width += padding * 2;
    filterArea.height += padding * 2;

    // cap filter to screen size..
    if(filterArea.x < 0)filterArea.x = 0;
    if(filterArea.width > this.width)filterArea.width = this.width;
    if(filterArea.y < 0)filterArea.y = 0;
    if(filterArea.height > this.height)filterArea.height = this.height;

    //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  filterArea.width, filterArea.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, texture.frameBuffer);

    // set view port
    gl.viewport(0, 0, filterArea.width, filterArea.height);

    projection.x = filterArea.width/2;
    projection.y = -filterArea.height/2;

    offset.x = -filterArea.x;
    offset.y = -filterArea.y;

    // update projection
    // now restore the regular shader..
    this.renderSession.shaderManager.setShader(this.defaultShader);
    gl.uniform2f(this.defaultShader.projectionVector, filterArea.width/2, -filterArea.height/2);
    gl.uniform2f(this.defaultShader.offsetVector, -filterArea.x, -filterArea.y);

    gl.colorMask(true, true, true, true);
    gl.clearColor(0,0,0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    filterBlock._glFilterTexture = texture;

};


/**
* Removes the last filter from the filter stack and doesn't return it
* @method popFilter
*/
PIXI.WebGLFilterManager.prototype.popFilter = function()
{
    var gl = this.gl;
    var filterBlock = this.filterStack.pop();
    var filterArea = filterBlock._filterArea;
    var texture = filterBlock._glFilterTexture;
    var projection = this.renderSession.projection;
    var offset = this.renderSession.offset;

    if(filterBlock.filterPasses.length > 1)
    {
        gl.viewport(0, 0, filterArea.width, filterArea.height);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);

        this.vertexArray[0] = 0;
        this.vertexArray[1] = filterArea.height;

        this.vertexArray[2] = filterArea.width;
        this.vertexArray[3] = filterArea.height;

        this.vertexArray[4] = 0;
        this.vertexArray[5] = 0;

        this.vertexArray[6] = filterArea.width;
        this.vertexArray[7] = 0;

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
        // now set the uvs..
        this.uvArray[2] = filterArea.width/this.width;
        this.uvArray[5] = filterArea.height/this.height;
        this.uvArray[6] = filterArea.width/this.width;
        this.uvArray[7] = filterArea.height/this.height;

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);

        var inputTexture = texture;
        var outputTexture = this.texturePool.pop();
        if(!outputTexture)outputTexture = new PIXI.FilterTexture(this.gl, this.width, this.height);
        outputTexture.resize(this.width, this.height);

        // need to clear this FBO as it may have some left over elements from a previous filter.
        gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer );
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.disable(gl.BLEND);

        for (var i = 0; i < filterBlock.filterPasses.length-1; i++)
        {
            var filterPass = filterBlock.filterPasses[i];

            gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer );

            // set texture
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);

            // draw texture..
            //filterPass.applyFilterPass(filterArea.width, filterArea.height);
            this.applyFilterPass(filterPass, filterArea, filterArea.width, filterArea.height);

            // swap the textures..
            var temp = inputTexture;
            inputTexture = outputTexture;
            outputTexture = temp;
        }

        gl.enable(gl.BLEND);

        texture = inputTexture;
        this.texturePool.push(outputTexture);
    }

    var filter = filterBlock.filterPasses[filterBlock.filterPasses.length-1];

    this.offsetX -= filterArea.x;
    this.offsetY -= filterArea.y;


    var sizeX = this.width;
    var sizeY = this.height;

    var offsetX = 0;
    var offsetY = 0;

    var buffer = this.buffer;

    // time to render the filters texture to the previous scene
    if(this.filterStack.length === 0)
    {
        gl.colorMask(true, true, true, true);//this.transparent);
    }
    else
    {
        var currentFilter = this.filterStack[this.filterStack.length-1];
        filterArea = currentFilter._filterArea;

        sizeX = filterArea.width;
        sizeY = filterArea.height;

        offsetX = filterArea.x;
        offsetY = filterArea.y;

        buffer =  currentFilter._glFilterTexture.frameBuffer;
    }



    // TODO need toremove thease global elements..
    projection.x = sizeX/2;
    projection.y = -sizeY/2;

    offset.x = offsetX;
    offset.y = offsetY;

    filterArea = filterBlock._filterArea;

    var x = filterArea.x-offsetX;
    var y = filterArea.y-offsetY;

    // update the buffers..
    // make sure to flip the y!
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);

    this.vertexArray[0] = x;
    this.vertexArray[1] = y + filterArea.height;

    this.vertexArray[2] = x + filterArea.width;
    this.vertexArray[3] = y + filterArea.height;

    this.vertexArray[4] = x;
    this.vertexArray[5] = y;

    this.vertexArray[6] = x + filterArea.width;
    this.vertexArray[7] = y;

    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);

    this.uvArray[2] = filterArea.width/this.width;
    this.uvArray[5] = filterArea.height/this.height;
    this.uvArray[6] = filterArea.width/this.width;
    this.uvArray[7] = filterArea.height/this.height;

    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);

   //console.log(this.vertexArray)
   //console.log(this.uvArray)
    //console.log(sizeX + " : " + sizeY)

    gl.viewport(0, 0, sizeX, sizeY);

    // bind the buffer
    gl.bindFramebuffer(gl.FRAMEBUFFER, buffer );

    // set the blend mode! 
    //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)

    // set texture
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture.texture);

    // apply!
    this.applyFilterPass(filter, filterArea, sizeX, sizeY);

    // now restore the regular shader..
    this.renderSession.shaderManager.setShader(this.defaultShader);
    gl.uniform2f(this.defaultShader.projectionVector, sizeX/2, -sizeY/2);
    gl.uniform2f(this.defaultShader.offsetVector, -offsetX, -offsetY);

    // return the texture to the pool
    this.texturePool.push(texture);
    filterBlock._glFilterTexture = null;
};


/**
* Applies the filter to the specified area
* @method applyFilterPass
* @param filter {AbstractFilter} the filter that needs to be applied
* @param filterArea {texture} TODO - might need an update
* @param width {Number} the horizontal range of the filter
* @param height {Number} the vertical range of the filter
*/
PIXI.WebGLFilterManager.prototype.applyFilterPass = function(filter, filterArea, width, height)
{
    // use program
    var gl = this.gl;
    var shader = filter.shaders[gl.id];

    if(!shader)
    {
        shader = new PIXI.PixiShader(gl);

        shader.fragmentSrc = filter.fragmentSrc;
        shader.uniforms = filter.uniforms;
        shader.init();

        filter.shaders[gl.id] = shader;
    }

    // set the shader
    this.renderSession.shaderManager.setShader(shader);

//    gl.useProgram(shader.program);

    gl.uniform2f(shader.projectionVector, width/2, -height/2);
    gl.uniform2f(shader.offsetVector, 0,0);

    if(filter.uniforms.dimensions)
    {
        filter.uniforms.dimensions.value[0] = this.width;//width;
        filter.uniforms.dimensions.value[1] = this.height;//height;
        filter.uniforms.dimensions.value[2] = this.vertexArray[0];
        filter.uniforms.dimensions.value[3] = this.vertexArray[5];//filterArea.height;
    }

  //  console.log(this.uvArray )
    shader.syncUniforms();

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
    gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
    gl.vertexAttribPointer(shader.colorAttribute, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

    // draw the filter...
    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

    this.renderSession.drawCount++;
};

/**
* Initialises the shader buffers
* @method initShaderBuffers
*/
PIXI.WebGLFilterManager.prototype.initShaderBuffers = function()
{
    var gl = this.gl;

    // create some buffers
    this.vertexBuffer = gl.createBuffer();
    this.uvBuffer = gl.createBuffer();
    this.colorBuffer = gl.createBuffer();
    this.indexBuffer = gl.createBuffer();


    // bind and upload the vertexs..
    // keep a reference to the vertexFloatData..
    this.vertexArray = new Float32Array([0.0, 0.0,
                                         1.0, 0.0,
                                         0.0, 1.0,
                                         1.0, 1.0]);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(
    gl.ARRAY_BUFFER,
    this.vertexArray,
    gl.STATIC_DRAW);


    // bind and upload the uv buffer
    this.uvArray = new Float32Array([0.0, 0.0,
                                     1.0, 0.0,
                                     0.0, 1.0,
                                     1.0, 1.0]);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
    gl.bufferData(
    gl.ARRAY_BUFFER,
    this.uvArray,
    gl.STATIC_DRAW);

    this.colorArray = new Float32Array([1.0, 0xFFFFFF,
                                        1.0, 0xFFFFFF,
                                        1.0, 0xFFFFFF,
                                        1.0, 0xFFFFFF]);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
    gl.bufferData(
    gl.ARRAY_BUFFER,
    this.colorArray,
    gl.STATIC_DRAW);

    // bind and upload the index
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(
    gl.ELEMENT_ARRAY_BUFFER,
    new Uint16Array([0, 1, 2, 1, 3, 2]),
    gl.STATIC_DRAW);
};

/**
* Destroys the filter and removes it from the filter stack
* @method destroy
*/
PIXI.WebGLFilterManager.prototype.destroy = function()
{
    var gl = this.gl;

    this.filterStack = null;
    
    this.offsetX = 0;
    this.offsetY = 0;

    // destroy textures
    for (var i = 0; i < this.texturePool.length; i++) {
        this.texturePool[i].destroy();
    }
    
    this.texturePool = null;

    //destroy buffers..
    gl.deleteBuffer(this.vertexBuffer);
    gl.deleteBuffer(this.uvBuffer);
    gl.deleteBuffer(this.colorBuffer);
    gl.deleteBuffer(this.indexBuffer);
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class FilterTexture
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
* @param width {Number} the horizontal range of the filter
* @param height {Number} the vertical range of the filter
* @param scaleMode {Number} Should be one of the PIXI.scaleMode consts
* @private
*/
PIXI.FilterTexture = function(gl, width, height, scaleMode)
{
    /**
     * @property gl
     * @type WebGLContext
     */
    this.gl = gl;

    // next time to create a frame buffer and texture
    this.frameBuffer = gl.createFramebuffer();
    this.texture = gl.createTexture();

    scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;

    gl.bindTexture(gl.TEXTURE_2D,  this.texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer );

    gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer );
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);

    // required for masking a mask??
    this.renderBuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.renderBuffer);
  
    this.resize(width, height);
};


/**
* Clears the filter texture
* @method clear
*/
PIXI.FilterTexture.prototype.clear = function()
{
    var gl = this.gl;
    
    gl.clearColor(0,0,0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
};

/**
 * Resizes the texture to the specified width and height
 *
 * @method resize
 * @param width {Number} the new width of the texture
 * @param height {Number} the new height of the texture
 */
PIXI.FilterTexture.prototype.resize = function(width, height)
{
    if(this.width === width && this.height === height) return;

    this.width = width;
    this.height = height;

    var gl = this.gl;

    gl.bindTexture(gl.TEXTURE_2D,  this.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

    // update the stencil buffer width and height
    gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
};

/**
* Destroys the filter texture
* @method destroy
*/
PIXI.FilterTexture.prototype.destroy = function()
{
    var gl = this.gl;
    gl.deleteFramebuffer( this.frameBuffer );
    gl.deleteTexture( this.texture );

    this.frameBuffer = null;
    this.texture = null;
};

/**
 * @author Mat Groves
 * 
 * 
 */
/**
 * A set of functions used to handle masking
 *
 * @class CanvasMaskManager
 */
PIXI.CanvasMaskManager = function()
{
    
};

/**
 * This method adds it to the current stack of masks
 *
 * @method pushMask
 * @param maskData the maskData that will be pushed
 * @param context {Context2D} the 2d drawing method of the canvas
 */
PIXI.CanvasMaskManager.prototype.pushMask = function(maskData, context)
{
    context.save();
    
    var cacheAlpha = maskData.alpha;
    var transform = maskData.worldTransform;

    context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);

    PIXI.CanvasGraphics.renderGraphicsMask(maskData, context);

    context.clip();

    maskData.worldAlpha = cacheAlpha;
};

/**
 * Restores the current drawing context to the state it was before the mask was applied
 *
 * @method popMask
 * @param context {Context2D} the 2d drawing method of the canvas
 */
PIXI.CanvasMaskManager.prototype.popMask = function(context)
{
    context.restore();
};

/**
 * @author Mat Groves
 * 
 * 
 */

/**
 * @class CanvasTinter
 * @constructor
 * @static
 */
PIXI.CanvasTinter = function()
{
    /// this.textureCach
};

//PIXI.CanvasTinter.cachTint = true;
    

/**
 * Basically this method just needs a sprite and a color and tints the sprite 
 * with the given color
 * 
 * @method getTintedTexture 
 * @param sprite {Sprite} the sprite to tint
 * @param color {Number} the color to use to tint the sprite with
 */
PIXI.CanvasTinter.getTintedTexture = function(sprite, color)
{

    var texture = sprite.texture;

    color = PIXI.CanvasTinter.roundColor(color);

    var stringColor = "#" + ("00000" + ( color | 0).toString(16)).substr(-6);
   
    texture.tintCache = texture.tintCache || {};

    if(texture.tintCache[stringColor]) return texture.tintCache[stringColor];

     // clone texture..
    var canvas = PIXI.CanvasTinter.canvas || document.createElement("canvas");
    
    //PIXI.CanvasTinter.tintWithPerPixel(texture, stringColor, canvas);

    
    PIXI.CanvasTinter.tintMethod(texture, color, canvas);

    if(PIXI.CanvasTinter.convertTintToImage)
    {
        // is this better?
        var tintImage = new Image();
        tintImage.src = canvas.toDataURL();

        texture.tintCache[stringColor] = tintImage;
    }
    else
    {
      
        texture.tintCache[stringColor] = canvas;
        // if we are not converting the texture to an image then we need to lose the reference to the canvas
        PIXI.CanvasTinter.canvas = null;

    }

    return canvas;
};

/**
 * Tint a texture using the "multiply" operation
 * @method tintWithMultiply
 * @param texture {texture} the texture to tint
 * @param color {Number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */
PIXI.CanvasTinter.tintWithMultiply = function(texture, color, canvas)
{
    var context = canvas.getContext( "2d" );

    var frame = texture.frame;

    canvas.width = frame.width;
    canvas.height = frame.height;

    context.fillStyle = "#" + ("00000" + ( color | 0).toString(16)).substr(-6);
    
    context.fillRect(0, 0, frame.width, frame.height);
    
    context.globalCompositeOperation = "multiply";

    context.drawImage(texture.baseTexture.source,
                           frame.x,
                           frame.y,
                           frame.width,
                           frame.height,
                           0,
                           0,
                           frame.width,
                           frame.height);

    context.globalCompositeOperation = "destination-atop";
    
    context.drawImage(texture.baseTexture.source,
                           frame.x,
                           frame.y,
                           frame.width,
                           frame.height,
                           0,
                           0,
                           frame.width,
                           frame.height);
};

/**
 * Tint a texture using the "overlay" operation
 * @method tintWithOverlay
 * @param texture {texture} the texture to tint
 * @param color {Number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */
PIXI.CanvasTinter.tintWithOverlay = function(texture, color, canvas)
{
    var context = canvas.getContext( "2d" );

    var frame = texture.frame;

    canvas.width = frame.width;
    canvas.height = frame.height;

    
    
    context.globalCompositeOperation = "copy";
    context.fillStyle = "#" + ("00000" + ( color | 0).toString(16)).substr(-6);
    context.fillRect(0, 0, frame.width, frame.height);

    context.globalCompositeOperation = "destination-atop";
    context.drawImage(texture.baseTexture.source,
                           frame.x,
                           frame.y,
                           frame.width,
                           frame.height,
                           0,
                           0,
                           frame.width,
                           frame.height);

    
    //context.globalCompositeOperation = "copy";

};

/**
 * Tint a texture pixel per pixel
 * @method tintPerPixel
 * @param texture {texture} the texture to tint
 * @param color {Number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */
PIXI.CanvasTinter.tintWithPerPixel = function(texture, color, canvas)
{
    var context = canvas.getContext( "2d" );

    var frame = texture.frame;

    canvas.width = frame.width;
    canvas.height = frame.height;
  
    context.globalCompositeOperation = "copy";
    context.drawImage(texture.baseTexture.source,
                           frame.x,
                           frame.y,
                           frame.width,
                           frame.height,
                           0,
                           0,
                           frame.width,
                           frame.height);

    var rgbValues = PIXI.hex2rgb(color);
    var r = rgbValues[0], g = rgbValues[1], b = rgbValues[2];

    var pixelData = context.getImageData(0, 0, frame.width, frame.height);

    var pixels = pixelData.data;

    for (var i = 0; i < pixels.length; i += 4)
    {
        pixels[i+0] *= r;
        pixels[i+1] *= g;
        pixels[i+2] *= b;
    }

    context.putImageData(pixelData, 0, 0);
};

/**
 * Rounds the specified color according to the PIXI.CanvasTinter.cacheStepsPerColorChannel
 * @method roundColor
 * @param color {number} the color to round, should be a hex color
 */
PIXI.CanvasTinter.roundColor = function(color)
{
    var step = PIXI.CanvasTinter.cacheStepsPerColorChannel;

    var rgbValues = PIXI.hex2rgb(color);

    rgbValues[0] = Math.min(255, (rgbValues[0] / step) * step);
    rgbValues[1] = Math.min(255, (rgbValues[1] / step) * step);
    rgbValues[2] = Math.min(255, (rgbValues[2] / step) * step);

    return PIXI.rgb2hex(rgbValues);
};

/**
 * 
 * Number of steps which will be used as a cap when rounding colors
 *
 * @property cacheStepsPerColorChannel
 * @type Number
 */
PIXI.CanvasTinter.cacheStepsPerColorChannel = 8;
/**
 * 
 * Number of steps which will be used as a cap when rounding colors
 *
 * @property convertTintToImage
 * @type Boolean
 */
PIXI.CanvasTinter.convertTintToImage = false;

/**
 * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method
 *
 * @property canUseMultiply
 * @type Boolean
 */
PIXI.CanvasTinter.canUseMultiply = PIXI.canUseNewCanvasBlendModes();

PIXI.CanvasTinter.tintMethod = PIXI.CanvasTinter.canUseMultiply ? PIXI.CanvasTinter.tintWithMultiply :  PIXI.CanvasTinter.tintWithPerPixel;


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * the CanvasRenderer draws the stage and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.
 * Dont forget to add the view to your DOM or you will not see anything :)
 *
 * @class CanvasRenderer
 * @constructor
 * @param width=800 {Number} the width of the canvas view
 * @param height=600 {Number} the height of the canvas view
 * @param [view] {HTMLCanvasElement} the canvas to use as a view, optional
 * @param [transparent=false] {Boolean} the transparency of the render view, default false
 */
PIXI.CanvasRenderer = function(width, height, view, transparent)
{
    if(!PIXI.defaultRenderer)
    {
        PIXI.sayHello("Canvas");
        PIXI.defaultRenderer = this;
    }

    this.type = PIXI.CANVAS_RENDERER;

    /**
     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.
     * If the Stage is NOT transparent Pixi will use a canvas sized fillRect operation every frame to set the canvas background color.
     * If the Stage is transparent Pixi will use clearRect to clear the canvas every frame.
     * Disable this by setting this to false. For example if your game has a canvas filling background image you often don't need this set.
     *
     * @property clearBeforeRender
     * @type Boolean
     * @default
     */
    this.clearBeforeRender = true;

    /**
     * Whether the render view is transparent
     *
     * @property transparent
     * @type Boolean
     */
    this.transparent = !!transparent;

    if(!PIXI.blendModesCanvas)
    {
        PIXI.blendModesCanvas = [];

        if(PIXI.canUseNewCanvasBlendModes())
        {
            PIXI.blendModesCanvas[PIXI.blendModes.NORMAL]   = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.ADD]      = "lighter"; //IS THIS OK???
            PIXI.blendModesCanvas[PIXI.blendModes.MULTIPLY] = "multiply";
            PIXI.blendModesCanvas[PIXI.blendModes.SCREEN]   = "screen";
            PIXI.blendModesCanvas[PIXI.blendModes.OVERLAY]  = "overlay";
            PIXI.blendModesCanvas[PIXI.blendModes.DARKEN]   = "darken";
            PIXI.blendModesCanvas[PIXI.blendModes.LIGHTEN]  = "lighten";
            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_DODGE] = "color-dodge";
            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_BURN] = "color-burn";
            PIXI.blendModesCanvas[PIXI.blendModes.HARD_LIGHT] = "hard-light";
            PIXI.blendModesCanvas[PIXI.blendModes.SOFT_LIGHT] = "soft-light";
            PIXI.blendModesCanvas[PIXI.blendModes.DIFFERENCE] = "difference";
            PIXI.blendModesCanvas[PIXI.blendModes.EXCLUSION] = "exclusion";
            PIXI.blendModesCanvas[PIXI.blendModes.HUE]       = "hue";
            PIXI.blendModesCanvas[PIXI.blendModes.SATURATION] = "saturation";
            PIXI.blendModesCanvas[PIXI.blendModes.COLOR]      = "color";
            PIXI.blendModesCanvas[PIXI.blendModes.LUMINOSITY] = "luminosity";
        }
        else
        {
            // this means that the browser does not support the cool new blend modes in canvas "cough" ie "cough"
            PIXI.blendModesCanvas[PIXI.blendModes.NORMAL]   = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.ADD]      = "lighter"; //IS THIS OK???
            PIXI.blendModesCanvas[PIXI.blendModes.MULTIPLY] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.SCREEN]   = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.OVERLAY]  = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.DARKEN]   = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.LIGHTEN]  = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_DODGE] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_BURN] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.HARD_LIGHT] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.SOFT_LIGHT] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.DIFFERENCE] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.EXCLUSION] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.HUE]       = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.SATURATION] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.COLOR]      = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.LUMINOSITY] = "source-over";
        }
    }

    /**
     * The width of the canvas view
     *
     * @property width
     * @type Number
     * @default 800
     */
    this.width = width || 800;

    /**
     * The height of the canvas view
     *
     * @property height
     * @type Number
     * @default 600
     */
    this.height = height || 600;

    /**
     * The canvas element that everything is drawn to
     *
     * @property view
     * @type HTMLCanvasElement
     */
    this.view = view || document.createElement( "canvas" );

    /**
     * The canvas 2d context that everything is drawn with
     * @property context
     * @type HTMLCanvasElement 2d Context
     */
    this.context = this.view.getContext( "2d", { alpha: this.transparent } );

    this.refresh = true;
    // hack to enable some hardware acceleration!
    //this.view.style["transform"] = "translatez(0)";

    this.view.width = this.width;
    this.view.height = this.height;
    this.count = 0;

    /**
     * Instance of a PIXI.CanvasMaskManager, handles masking when using the canvas renderer
     * @property CanvasMaskManager
     * @type CanvasMaskManager
     */
    this.maskManager = new PIXI.CanvasMaskManager();

    /**
     * The render session is just a bunch of parameter used for rendering
     * @property renderSession
     * @type Object
     */
    this.renderSession = {
        context: this.context,
        maskManager: this.maskManager,
        scaleMode: null,
        smoothProperty: null,

        /**
         * If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
         * Handy for crisp pixel art and speed on legacy devices.
         *
         */
        roundPixels: false
    };

    if("imageSmoothingEnabled" in this.context)
        this.renderSession.smoothProperty = "imageSmoothingEnabled";
    else if("webkitImageSmoothingEnabled" in this.context)
        this.renderSession.smoothProperty = "webkitImageSmoothingEnabled";
    else if("mozImageSmoothingEnabled" in this.context)
        this.renderSession.smoothProperty = "mozImageSmoothingEnabled";
    else if("oImageSmoothingEnabled" in this.context)
        this.renderSession.smoothProperty = "oImageSmoothingEnabled";
};

// constructor
PIXI.CanvasRenderer.prototype.constructor = PIXI.CanvasRenderer;

/**
 * Renders the stage to its canvas view
 *
 * @method render
 * @param stage {Stage} the Stage element to be rendered
 */
PIXI.CanvasRenderer.prototype.render = function(stage)
{
    // update textures if need be
    PIXI.texturesToUpdate.length = 0;
    PIXI.texturesToDestroy.length = 0;

    stage.updateTransform();

    this.context.setTransform(1,0,0,1,0,0);
    this.context.globalAlpha = 1;

    if (navigator.isCocoonJS && this.view.screencanvas) {
        this.context.fillStyle = "black";
        this.context.clear();
    }

    if (!this.transparent && this.clearBeforeRender)
    {
        this.context.fillStyle = stage.backgroundColorString;
        this.context.fillRect(0, 0, this.width, this.height);
    }
    else if (this.transparent && this.clearBeforeRender)
    {
        this.context.clearRect(0, 0, this.width, this.height);
    }

    this.renderDisplayObject(stage);

    // run interaction!
    if(stage.interactive)
    {
        //need to add some events!
        if(!stage._interactiveEventsAdded)
        {
            stage._interactiveEventsAdded = true;
            stage.interactionManager.setTarget(this);
        }
    }

    // remove frame updates..
    if(PIXI.Texture.frameUpdates.length > 0)
    {
        PIXI.Texture.frameUpdates.length = 0;
    }
};

/**
 * Resizes the canvas view to the specified width and height
 *
 * @method resize
 * @param width {Number} the new width of the canvas view
 * @param height {Number} the new height of the canvas view
 */
PIXI.CanvasRenderer.prototype.resize = function(width, height)
{
    this.width = width;
    this.height = height;

    this.view.width = width;
    this.view.height = height;
};

/**
 * Renders a display object
 *
 * @method renderDisplayObject
 * @param displayObject {DisplayObject} The displayObject to render
 * @param context {Context2D} the context 2d method of the canvas
 * @private
 */
PIXI.CanvasRenderer.prototype.renderDisplayObject = function(displayObject, context)
{
    // no longer recursive!
    //var transform;
    //var context = this.context;

    this.renderSession.context = context || this.context;
    displayObject._renderCanvas(this.renderSession);
};

/**
 * Renders a flat strip
 *
 * @method renderStripFlat
 * @param strip {Strip} The Strip to render
 * @private
 */
PIXI.CanvasRenderer.prototype.renderStripFlat = function(strip)
{
    var context = this.context;
    var verticies = strip.verticies;

    var length = verticies.length/2;
    this.count++;

    context.beginPath();
    for (var i=1; i < length-2; i++)
    {
        // draw some triangles!
        var index = i*2;

        var x0 = verticies[index],   x1 = verticies[index+2], x2 = verticies[index+4];
        var y0 = verticies[index+1], y1 = verticies[index+3], y2 = verticies[index+5];

        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
    }

    context.fillStyle = "#FF0000";
    context.fill();
    context.closePath();
};

/**
 * Renders a strip
 *
 * @method renderStrip
 * @param strip {Strip} The Strip to render
 * @private
 */
PIXI.CanvasRenderer.prototype.renderStrip = function(strip)
{
    var context = this.context;

    // draw triangles!!
    var verticies = strip.verticies;
    var uvs = strip.uvs;

    var length = verticies.length/2;
    this.count++;

    for (var i = 1; i < length-2; i++)
    {
        // draw some triangles!
        var index = i*2;

        var x0 = verticies[index],   x1 = verticies[index+2], x2 = verticies[index+4];
        var y0 = verticies[index+1], y1 = verticies[index+3], y2 = verticies[index+5];

        var u0 = uvs[index] * strip.texture.width,   u1 = uvs[index+2] * strip.texture.width, u2 = uvs[index+4]* strip.texture.width;
        var v0 = uvs[index+1]* strip.texture.height, v1 = uvs[index+3] * strip.texture.height, v2 = uvs[index+5]* strip.texture.height;

        context.save();
        context.beginPath();
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
        context.closePath();

        context.clip();

        // Compute matrix transform
        var delta = u0*v1 + v0*u2 + u1*v2 - v1*u2 - v0*u1 - u0*v2;
        var deltaA = x0*v1 + v0*x2 + x1*v2 - v1*x2 - v0*x1 - x0*v2;
        var deltaB = u0*x1 + x0*u2 + u1*x2 - x1*u2 - x0*u1 - u0*x2;
        var deltaC = u0*v1*x2 + v0*x1*u2 + x0*u1*v2 - x0*v1*u2 - v0*u1*x2 - u0*x1*v2;
        var deltaD = y0*v1 + v0*y2 + y1*v2 - v1*y2 - v0*y1 - y0*v2;
        var deltaE = u0*y1 + y0*u2 + u1*y2 - y1*u2 - y0*u1 - u0*y2;
        var deltaF = u0*v1*y2 + v0*y1*u2 + y0*u1*v2 - y0*v1*u2 - v0*u1*y2 - u0*y1*v2;

        context.transform(deltaA / delta, deltaD / delta,
                            deltaB / delta, deltaE / delta,
                            deltaC / delta, deltaF / delta);

        context.drawImage(strip.texture.baseTexture.source, 0, 0);
        context.restore();
    }
};

/**
 * Creates a Canvas element of the given size
 *
 * @method CanvasBuffer
 * @param width {Number} the width for the newly created canvas
 * @param height {Number} the height for the newly created canvas
 * @static
 * @private
 */
PIXI.CanvasBuffer = function(width, height)
{
    this.width = width;
    this.height = height;

    this.canvas = document.createElement( "canvas" );
    this.context = this.canvas.getContext( "2d" );

    this.canvas.width = width;
    this.canvas.height = height;
};

/**
 * Clears the canvas that was created by the CanvasBuffer class
 *
 * @method clear
 * @private
 */
PIXI.CanvasBuffer.prototype.clear = function()
{
    this.context.clearRect(0,0, this.width, this.height);
};

/**
 * Resizes the canvas that was created by the CanvasBuffer class to the specified width and height
 *
 * @method resize
 * @param width {Number} the new width of the canvas
 * @param height {Number} the new height of the canvas
 * @private
 */

PIXI.CanvasBuffer.prototype.resize = function(width, height)
{
    this.width = this.canvas.width = width;
    this.height = this.canvas.height = height;
};


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */


/**
 * A set of functions used by the canvas renderer to draw the primitive graphics data
 *
 * @class CanvasGraphics
 */
PIXI.CanvasGraphics = function()
{

};


/*
 * Renders the graphics object
 *
 * @static
 * @private
 * @method renderGraphics
 * @param graphics {Graphics} the actual graphics object to render
 * @param context {Context2D} the 2d drawing method of the canvas
 */
PIXI.CanvasGraphics.renderGraphics = function(graphics, context)
{
    var worldAlpha = graphics.worldAlpha;
    var color = '';

    for (var i = 0; i < graphics.graphicsData.length; i++)
    {
        var data = graphics.graphicsData[i];
        var points = data.points;

        context.strokeStyle = color = '#' + ('00000' + ( data.lineColor | 0).toString(16)).substr(-6);

        context.lineWidth = data.lineWidth;

        if(data.type === PIXI.Graphics.POLY)
        {
            context.beginPath();

            context.moveTo(points[0], points[1]);

            for (var j=1; j < points.length/2; j++)
            {
                context.lineTo(points[j * 2], points[j * 2 + 1]);
            }

            // if the first and last point are the same close the path - much neater :)
            if(points[0] === points[points.length-2] && points[1] === points[points.length-1])
            {
                context.closePath();
            }

            if(data.fill)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);
                context.fill();
            }
            if(data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.stroke();
            }
        }
        else if(data.type === PIXI.Graphics.RECT)
        {

            if(data.fillColor || data.fillColor === 0)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);
                context.fillRect(points[0], points[1], points[2], points[3]);

            }
            if(data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.strokeRect(points[0], points[1], points[2], points[3]);
            }

        }
        else if(data.type === PIXI.Graphics.CIRC)
        {
            // TODO - need to be Undefined!
            context.beginPath();
            context.arc(points[0], points[1], points[2],0,2*Math.PI);
            context.closePath();

            if(data.fill)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);
                context.fill();
            }
            if(data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.stroke();
            }
        }
        else if(data.type === PIXI.Graphics.ELIP)
        {

            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas

            var ellipseData =  data.points;

            var w = ellipseData[2] * 2;
            var h = ellipseData[3] * 2;

            var x = ellipseData[0] - w/2;
            var y = ellipseData[1] - h/2;

            context.beginPath();

            var kappa = 0.5522848,
                ox = (w / 2) * kappa, // control point offset horizontal
                oy = (h / 2) * kappa, // control point offset vertical
                xe = x + w,           // x-end
                ye = y + h,           // y-end
                xm = x + w / 2,       // x-middle
                ym = y + h / 2;       // y-middle

            context.moveTo(x, ym);
            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);

            context.closePath();

            if(data.fill)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);
                context.fill();
            }
            if(data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.stroke();
            }
        }
        else if (data.type === PIXI.Graphics.RREC)
        {
            var rx = points[0];
            var ry = points[1];
            var width = points[2];
            var height = points[3];
            var radius = points[4];

            var maxRadius = Math.min(width, height) / 2 | 0;
            radius = radius > maxRadius ? maxRadius : radius;

            context.beginPath();
            context.moveTo(rx, ry + radius);
            context.lineTo(rx, ry + height - radius);
            context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
            context.lineTo(rx + width - radius, ry + height);
            context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
            context.lineTo(rx + width, ry + radius);
            context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
            context.lineTo(rx + radius, ry);
            context.quadraticCurveTo(rx, ry, rx, ry + radius);
            context.closePath();

            if(data.fillColor || data.fillColor === 0)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);
                context.fill();

            }
            if(data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.stroke();
            }
        }
    }
};

/*
 * Renders a graphics mask
 *
 * @static
 * @private
 * @method renderGraphicsMask
 * @param graphics {Graphics} the graphics which will be used as a mask
 * @param context {Context2D} the context 2d method of the canvas
 */
PIXI.CanvasGraphics.renderGraphicsMask = function(graphics, context)
{
    var len = graphics.graphicsData.length;

    if(len === 0) return;

    if(len > 1)
    {
        len = 1;
        window.console.log('Pixi.js warning: masks in canvas can only mask using the first path in the graphics object');
    }

    for (var i = 0; i < 1; i++)
    {
        var data = graphics.graphicsData[i];
        var points = data.points;

        if(data.type === PIXI.Graphics.POLY)
        {
            context.beginPath();
            context.moveTo(points[0], points[1]);

            for (var j=1; j < points.length/2; j++)
            {
                context.lineTo(points[j * 2], points[j * 2 + 1]);
            }

            // if the first and last point are the same close the path - much neater :)
            if(points[0] === points[points.length-2] && points[1] === points[points.length-1])
            {
                context.closePath();
            }

        }
        else if(data.type === PIXI.Graphics.RECT)
        {
            context.beginPath();
            context.rect(points[0], points[1], points[2], points[3]);
            context.closePath();
        }
        else if(data.type === PIXI.Graphics.CIRC)
        {
            // TODO - need to be Undefined!
            context.beginPath();
            context.arc(points[0], points[1], points[2],0,2*Math.PI);
            context.closePath();
        }
        else if(data.type === PIXI.Graphics.ELIP)
        {

            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
            var ellipseData =  data.points;

            var w = ellipseData[2] * 2;
            var h = ellipseData[3] * 2;

            var x = ellipseData[0] - w/2;
            var y = ellipseData[1] - h/2;

            context.beginPath();

            var kappa = 0.5522848,
                ox = (w / 2) * kappa, // control point offset horizontal
                oy = (h / 2) * kappa, // control point offset vertical
                xe = x + w,           // x-end
                ye = y + h,           // y-end
                xm = x + w / 2,       // x-middle
                ym = y + h / 2;       // y-middle

            context.moveTo(x, ym);
            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
            context.closePath();
        }
        else if (data.type === PIXI.Graphics.RREC)
        {
            var rx = points[0];
            var ry = points[1];
            var width = points[2];
            var height = points[3];
            var radius = points[4];

            var maxRadius = Math.min(width, height) / 2 | 0;
            radius = radius > maxRadius ? maxRadius : radius;

            context.beginPath();
            context.moveTo(rx, ry + radius);
            context.lineTo(rx, ry + height - radius);
            context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
            context.lineTo(rx + width - radius, ry + height);
            context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
            context.lineTo(rx + width, ry + radius);
            context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
            context.lineTo(rx + radius, ry);
            context.quadraticCurveTo(rx, ry, rx, ry + radius);
            context.closePath();
        }
    }
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */


/**
 * The Graphics class contains a set of methods that you can use to create primitive shapes and lines.
 * It is important to know that with the webGL renderer only simple polygons can be filled at this stage
 * Complex polygons will not be filled. Heres an example of a complex polygon: http://www.goodboydigital.com/wp-content/uploads/2013/06/complexPolygon.png
 *
 * @class Graphics
 * @extends DisplayObjectContainer
 * @constructor
 */
PIXI.Graphics = function()
{
    PIXI.DisplayObjectContainer.call( this );

    this.renderable = true;

    /**
     * The alpha of the fill of this graphics object
     *
     * @property fillAlpha
     * @type Number
     */
    this.fillAlpha = 1;

    /**
     * The width of any lines drawn
     *
     * @property lineWidth
     * @type Number
     */
    this.lineWidth = 0;

    /**
     * The color of any lines drawn
     *
     * @property lineColor
     * @type String
     */
    this.lineColor = "black";

    /**
     * Graphics data
     *
     * @property graphicsData
     * @type Array
     * @private
     */
    this.graphicsData = [];


    /**
     * The tint applied to the graphic shape. This is a hex value
     *
     * @property tint
     * @type Number
     * @default 0xFFFFFF
     */
    this.tint = 0xFFFFFF;// * Math.random();
    
    /**
     * The blend mode to be applied to the graphic shape
     *
     * @property blendMode
     * @type Number
     * @default PIXI.blendModes.NORMAL;
     */
    this.blendMode = PIXI.blendModes.NORMAL;
    
    /**
     * Current path
     *
     * @property currentPath
     * @type Object
     * @private
     */
    this.currentPath = {points:[]};

    /**
     * Array containing some WebGL-related properties used by the WebGL renderer
     *
     * @property _webGL
     * @type Array
     * @private
     */
    this._webGL = [];

    /**
     * Whether this shape is being used as a mask
     *
     * @property isMask
     * @type isMask
     */
    this.isMask = false;

    /**
     * The bounds of the graphic shape as rectangle object
     *
     * @property bounds
     * @type Rectangle
     */
    this.bounds = null;

    /**
     * the bounds' padding used for bounds calculation
     *
     * @property boundsPadding
     * @type Number
     */
    this.boundsPadding = 10;

    /**
     * Used to detect if the graphics object has changed if this is set to true then the graphics object will be recalculated
     * 
     * @type {Boolean}
     */
    this.dirty = true;
};

// constructor
PIXI.Graphics.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );
PIXI.Graphics.prototype.constructor = PIXI.Graphics;

/**
 * If cacheAsBitmap is true the graphics object will then be rendered as if it was a sprite.
 * This is useful if your graphics element does not change often as it will speed up the rendering of the object
 * It is also usful as the graphics object will always be antialiased because it will be rendered using canvas
 * Not recommended if you are constanly redrawing the graphics element.
 *
 * @property cacheAsBitmap
 * @default false
 * @type Boolean
 * @private
 */
Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", {
    get: function() {
        return  this._cacheAsBitmap;
    },
    set: function(value) {
        this._cacheAsBitmap = value;

        if(this._cacheAsBitmap)
        {
            this._generateCachedSprite();
        }
        else
        {
            this.destroyCachedSprite();
            this.dirty = true;
        }

    }
});


/**
 * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo() method or the drawCircle() method.
 *
 * @method lineStyle
 * @param lineWidth {Number} width of the line to draw, will update the object's stored style
 * @param color {Number} color of the line to draw, will update the object's stored style
 * @param alpha {Number} alpha of the line to draw, will update the object's stored style
 */
PIXI.Graphics.prototype.lineStyle = function(lineWidth, color, alpha)
{
    if (!this.currentPath.points.length) this.graphicsData.pop();

    this.lineWidth = lineWidth || 0;
    this.lineColor = color || 0;
    this.lineAlpha = (arguments.length < 3) ? 1 : alpha;

    this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,
                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling, points:[], type:PIXI.Graphics.POLY};

    this.graphicsData.push(this.currentPath);

    return this;
};

/**
 * Moves the current drawing position to (x, y).
 *
 * @method moveTo
 * @param x {Number} the X coordinate to move to
 * @param y {Number} the Y coordinate to move to
 */
PIXI.Graphics.prototype.moveTo = function(x, y)
{
    if (!this.currentPath.points.length) this.graphicsData.pop();

    this.currentPath = this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,
                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling, points:[], type:PIXI.Graphics.POLY};

    this.currentPath.points.push(x, y);

    this.graphicsData.push(this.currentPath);

    return this;
};

/**
 * Draws a line using the current line style from the current drawing position to (x, y);
 * the current drawing position is then set to (x, y).
 *
 * @method lineTo
 * @param x {Number} the X coordinate to draw to
 * @param y {Number} the Y coordinate to draw to
 */
PIXI.Graphics.prototype.lineTo = function(x, y)
{
    this.currentPath.points.push(x, y);
    this.dirty = true;

    return this;
};

/**
 * Calculate the points for a quadratic bezier curve.
 * Based on : https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
 *
 * @method quadraticCurveTo
 * @param  {number}   cpX   Control point x
 * @param  {number}   cpY   Control point y
 * @param  {number}   toX   Destination point x
 * @param  {number}   toY   Destination point y
 * @return {PIXI.Graphics}
 */
PIXI.Graphics.prototype.quadraticCurveTo = function(cpX, cpY, toX, toY)
{
    if( this.currentPath.points.length === 0)this.moveTo(0,0);

    var xa,
    ya,
    n = 20,
    points = this.currentPath.points;
    if(points.length === 0)this.moveTo(0, 0);
    

    var fromX = points[points.length-2];
    var fromY = points[points.length-1];

    var j = 0;
    for (var i = 1; i <= n; i++ )
    {
        j = i / n;

        xa = fromX + ( (cpX - fromX) * j );
        ya = fromY + ( (cpY - fromY) * j );

        points.push( xa + ( ((cpX + ( (toX - cpX) * j )) - xa) * j ),
                     ya + ( ((cpY + ( (toY - cpY) * j )) - ya) * j ) );
    }


    this.dirty = true;

    return this;
};

/**
 * Calculate the points for a bezier curve.
 *
 * @method bezierCurveTo
 * @param  {number}   cpX    Control point x
 * @param  {number}   cpY    Control point y
 * @param  {number}   cpX2   Second Control point x
 * @param  {number}   cpY2   Second Control point y
 * @param  {number}   toX    Destination point x
 * @param  {number}   toY    Destination point y
 * @return {PIXI.Graphics}
 */
PIXI.Graphics.prototype.bezierCurveTo = function(cpX, cpY, cpX2, cpY2, toX, toY)
{
    if( this.currentPath.points.length === 0)this.moveTo(0,0);

    var n = 20,
    dt,
    dt2,
    dt3,
    t2,
    t3,
    points = this.currentPath.points;

    var fromX = points[points.length-2];
    var fromY = points[points.length-1];
    
    var j = 0;

    for (var i=1; i<n; i++)
    {
        j = i / n;

        dt = (1 - j);
        dt2 = dt * dt;
        dt3 = dt2 * dt;

        t2 = j * j;
        t3 = t2 * j;
        
        points.push( dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX,
                     dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
        
    }
    
    this.dirty = true;

    return this;
};

/*
 * the arcTo() method creates an arc/curve between two tangents on the canvas.
 * 
 * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
 *
 * @method arcTo
 * @param  {number}   x1        The x-coordinate of the beginning of the arc
 * @param  {number}   y1        The y-coordinate of the beginning of the arc
 * @param  {number}   x2        The x-coordinate of the end of the arc
 * @param  {number}   y2        The y-coordinate of the end of the arc
 * @param  {number}   radius    The radius of the arc
 * @return {PIXI.Graphics}
 */
PIXI.Graphics.prototype.arcTo = function(x1, y1, x2, y2, radius)
{
    // check that path contains subpaths
    if( this.currentPath.points.length === 0)this.moveTo(x1, y1);
    
    var points = this.currentPath.points;
    var fromX = points[points.length-2];
    var fromY = points[points.length-1];

//    points.push( x1,  y1);

    var a1 = fromY - y1;
    var b1 = fromX - x1;
    var a2 = y2   - y1;
    var b2 = x2   - x1;
    var mm = Math.abs(a1 * b2 - b1 * a2);

    if (mm < 1.0e-8 || radius === 0)
    {
        points.push(x1, y1);
    }
    else
    {
        var dd = a1 * a1 + b1 * b1;
        var cc = a2 * a2 + b2 * b2;
        var tt = a1 * a2 + b1 * b2;
        var k1 = radius * Math.sqrt(dd) / mm;
        var k2 = radius * Math.sqrt(cc) / mm;
        var j1 = k1 * tt / dd;
        var j2 = k2 * tt / cc;
        var cx = k1 * b2 + k2 * b1;
        var cy = k1 * a2 + k2 * a1;
        var px = b1 * (k2 + j1);
        var py = a1 * (k2 + j1);
        var qx = b2 * (k1 + j2);
        var qy = a2 * (k1 + j2);
        var startAngle = Math.atan2(py - cy, px - cx);
        var endAngle   = Math.atan2(qy - cy, qx - cx);
        // not required?
     //   points.push(px + x1 , py + y1);
        this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);
    }

    this.dirty = true;

    return this;
};

/**
 * The arc() method creates an arc/curve (used to create circles, or parts of circles).
 *
 * @method arc
 * @param  {number}   cx                The x-coordinate of the center of the circle
 * @param  {number}   cy                The y-coordinate of the center of the circle
 * @param  {number}   radius            The radius of the circle
 * @param  {number}   startAngle        The starting angle, in radians (0 is at the 3 o'clock position of the arc's circle)
 * @param  {number}   endAngle          The ending angle, in radians
 * @param  {number}   anticlockwise     Optional. Specifies whether the drawing should be counterclockwise or clockwise. False is default, and indicates clockwise, while true indicates counter-clockwise.
 * @return {PIXI.Graphics}
 */
PIXI.Graphics.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise)
{
    var startX = cx + Math.cos(startAngle) * radius;
    var startY = cy + Math.sin(startAngle) * radius;
    
    var points = this.currentPath.points;

    if(points.length !== 0 && points[points.length-2] !== startX || points[points.length-1] !== startY)
    {
        this.moveTo(startX, startY);
        points = this.currentPath.points;
    }

    if (startAngle === endAngle)return this;

    if( !anticlockwise && endAngle <= startAngle )
    {
        endAngle += Math.PI * 2;
    }
    else if( anticlockwise && startAngle <= endAngle )
    {
        startAngle += Math.PI * 2;
    }

    var sweep = anticlockwise ? (startAngle - endAngle) *-1 : (endAngle - startAngle);
    var segs =  ( Math.abs(sweep)/ (Math.PI * 2) ) * 40;

    if( sweep === 0 ) return this;

    var theta = sweep/(segs*2);
    var theta2 = theta*2;

    var cTheta = Math.cos(theta);
    var sTheta = Math.sin(theta);
    
    var segMinus = segs - 1;

    var remainder = ( segMinus % 1 ) / segMinus;

    for(var i=0; i<=segMinus; i++)
    {
        var real =  i + remainder * i;

    
        var angle = ((theta) + startAngle + (theta2 * real));

        var c = Math.cos(angle);
        var s = -Math.sin(angle);

        points.push(( (cTheta *  c) + (sTheta * s) ) * radius + cx,
                    ( (cTheta * -s) + (sTheta * c) ) * radius + cy);
    }

    this.dirty = true;

    return this;
};

/**
 * Draws a line using the current line style from the current drawing position to (x, y);
 * the current drawing position is then set to (x, y).
 *
 * @method lineTo
 * @param x {Number} the X coordinate to draw to
 * @param y {Number} the Y coordinate to draw to
 */
PIXI.Graphics.prototype.drawPath = function(path)
{
    if (!this.currentPath.points.length) this.graphicsData.pop();

    this.currentPath = this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,
                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling, points:[], type:PIXI.Graphics.POLY};

    this.graphicsData.push(this.currentPath);

    this.currentPath.points = this.currentPath.points.concat(path);
    this.dirty = true;

    return this;
};

/**
 * Specifies a simple one-color fill that subsequent calls to other Graphics methods
 * (such as lineTo() or drawCircle()) use when drawing.
 *
 * @method beginFill
 * @param color {Number} the color of the fill
 * @param alpha {Number} the alpha of the fill
 */
PIXI.Graphics.prototype.beginFill = function(color, alpha)
{

    this.filling = true;
    this.fillColor = color || 0;
    this.fillAlpha = (arguments.length < 2) ? 1 : alpha;

    return this;
};

/**
 * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
 *
 * @method endFill
 */
PIXI.Graphics.prototype.endFill = function()
{
    this.filling = false;
    this.fillColor = null;
    this.fillAlpha = 1;

    return this;
};

/**
 * @method drawRect
 *
 * @param x {Number} The X coord of the top-left of the rectangle
 * @param y {Number} The Y coord of the top-left of the rectangle
 * @param width {Number} The width of the rectangle
 * @param height {Number} The height of the rectangle
 */
PIXI.Graphics.prototype.drawRect = function( x, y, width, height )
{
    if (!this.currentPath.points.length) this.graphicsData.pop();

    this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,
                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling,
                        points:[x, y, width, height], type:PIXI.Graphics.RECT};

    this.graphicsData.push(this.currentPath);
    this.dirty = true;

    return this;
};

/**
 * @method drawRoundedRect
 *
 * @param x {Number} The X coord of the top-left of the rectangle
 * @param y {Number} The Y coord of the top-left of the rectangle
 * @param width {Number} The width of the rectangle
 * @param height {Number} The height of the rectangle
 * @param radius {Number} Radius of the rectangle corners
 */
PIXI.Graphics.prototype.drawRoundedRect = function( x, y, width, height, radius )
{
    if (!this.currentPath.points.length) this.graphicsData.pop();

    this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,
                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling,
                        points:[x, y, width, height, radius], type:PIXI.Graphics.RREC};

    this.graphicsData.push(this.currentPath);
    this.dirty = true;

    return this;
};

/**
 * Draws a circle.
 *
 * @method drawCircle
 * @param x {Number} The X coordinate of the center of the circle
 * @param y {Number} The Y coordinate of the center of the circle
 * @param radius {Number} The radius of the circle
 */
PIXI.Graphics.prototype.drawCircle = function(x, y, radius)
{

    if (!this.currentPath.points.length) this.graphicsData.pop();

    this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,
                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling,
                        points:[x, y, radius, radius], type:PIXI.Graphics.CIRC};

    this.graphicsData.push(this.currentPath);
    this.dirty = true;

    return this;
};

/**
 * Draws an ellipse.
 *
 * @method drawEllipse
 * @param x {Number} The X coordinate of the center of the ellipse
 * @param y {Number} The Y coordinate of the center of the ellipse
 * @param width {Number} The half width of the ellipse
 * @param height {Number} The half height of the ellipse
 */
PIXI.Graphics.prototype.drawEllipse = function(x, y, width, height)
{

    if (!this.currentPath.points.length) this.graphicsData.pop();

    this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,
                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling,
                        points:[x, y, width, height], type:PIXI.Graphics.ELIP};

    this.graphicsData.push(this.currentPath);
    this.dirty = true;

    return this;
};

/**
 * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
 *
 * @method clear
 */
PIXI.Graphics.prototype.clear = function()
{
    this.lineWidth = 0;
    this.filling = false;

    this.dirty = true;
    this.clearDirty = true;
    this.graphicsData = [];

    this.bounds = null; //new PIXI.Rectangle();

    return this;
};

/**
 * Useful function that returns a texture of the graphics object that can then be used to create sprites
 * This can be quite useful if your geometry is complicated and needs to be reused multiple times.
 *
 * @method generateTexture
 * @return {Texture} a texture of the graphics object
 */
PIXI.Graphics.prototype.generateTexture = function()
{
    var bounds = this.getBounds();

    var canvasBuffer = new PIXI.CanvasBuffer(bounds.width, bounds.height);
    var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);

    canvasBuffer.context.translate(-bounds.x,-bounds.y);
    
    PIXI.CanvasGraphics.renderGraphics(this, canvasBuffer.context);

    return texture;
};

/**
* Renders the object using the WebGL renderer
*
* @method _renderWebGL
* @param renderSession {RenderSession} 
* @private
*/
PIXI.Graphics.prototype._renderWebGL = function(renderSession)
{
    // if the sprite is not visible or the alpha is 0 then no need to render this element
    if(this.visible === false || this.alpha === 0 || this.isMask === true)return;
    

    if(this._cacheAsBitmap)
    {
       
        if(this.dirty)
        {
            this._generateCachedSprite();
            // we will also need to update the texture on the gpu too!
            PIXI.updateWebGLTexture(this._cachedSprite.texture.baseTexture, renderSession.gl);
            
            this.dirty =  false;
        }

        this._cachedSprite.alpha = this.alpha;
        PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession);

        return;
    }
    else
    {
        renderSession.spriteBatch.stop();
        renderSession.blendModeManager.setBlendMode(this.blendMode);

        if(this._mask)renderSession.maskManager.pushMask(this._mask, renderSession);
        if(this._filters)renderSession.filterManager.pushFilter(this._filterBlock);
      
        // check blend mode
        if(this.blendMode !== renderSession.spriteBatch.currentBlendMode)
        {
            renderSession.spriteBatch.currentBlendMode = this.blendMode;
            var blendModeWebGL = PIXI.blendModesWebGL[renderSession.spriteBatch.currentBlendMode];
            renderSession.spriteBatch.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
        }
        
      //  for (var i = this.graphicsData.length - 1; i >= 0; i--) {
        //    this.graphicsData[i]
            
//        };

        PIXI.WebGLGraphics.renderGraphics(this, renderSession);
        
        // only render if it has children!
        if(this.children.length)
        {
            renderSession.spriteBatch.start();

             // simple render children!
            for(var i=0, j=this.children.length; i<j; i++)
            {
                this.children[i]._renderWebGL(renderSession);
            }

            renderSession.spriteBatch.stop();
        }

        if(this._filters)renderSession.filterManager.popFilter();
        if(this._mask)renderSession.maskManager.popMask(this.mask, renderSession);
          
        renderSession.drawCount++;

        renderSession.spriteBatch.start();
    }
};

/**
* Renders the object using the Canvas renderer
*
* @method _renderCanvas
* @param renderSession {RenderSession} 
* @private
*/
PIXI.Graphics.prototype._renderCanvas = function(renderSession)
{
    // if the sprite is not visible or the alpha is 0 then no need to render this element
    if(this.visible === false || this.alpha === 0 || this.isMask === true)return;
    
    var context = renderSession.context;
    var transform = this.worldTransform;
    
    if(this.blendMode !== renderSession.currentBlendMode)
    {
        renderSession.currentBlendMode = this.blendMode;
        context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];
    }

    if(this._mask)
    {
        renderSession.maskManager.pushMask(this._mask, renderSession.context);
    }

    context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);
    PIXI.CanvasGraphics.renderGraphics(this, context);

     // simple render children!
    for(var i=0, j=this.children.length; i<j; i++)
    {
        this.children[i]._renderCanvas(renderSession);
    }

    if(this._mask)
    {
        renderSession.maskManager.popMask(renderSession.context);
    }
};

/**
 * Retrieves the bounds of the graphic shape as a rectangle object
 *
 * @method getBounds
 * @return {Rectangle} the rectangular bounding area
 */
PIXI.Graphics.prototype.getBounds = function( matrix )
{
    if(!this.bounds)this.updateBounds();

    var w0 = this.bounds.x;
    var w1 = this.bounds.width + this.bounds.x;

    var h0 = this.bounds.y;
    var h1 = this.bounds.height + this.bounds.y;

    var worldTransform = matrix || this.worldTransform;

    var a = worldTransform.a;
    var b = worldTransform.c;
    var c = worldTransform.b;
    var d = worldTransform.d;
    var tx = worldTransform.tx;
    var ty = worldTransform.ty;

    var x1 = a * w1 + c * h1 + tx;
    var y1 = d * h1 + b * w1 + ty;

    var x2 = a * w0 + c * h1 + tx;
    var y2 = d * h1 + b * w0 + ty;

    var x3 = a * w0 + c * h0 + tx;
    var y3 = d * h0 + b * w0 + ty;

    var x4 =  a * w1 + c * h0 + tx;
    var y4 =  d * h0 + b * w1 + ty;

    var maxX = x1;
    var maxY = y1;

    var minX = x1;
    var minY = y1;

    minX = x2 < minX ? x2 : minX;
    minX = x3 < minX ? x3 : minX;
    minX = x4 < minX ? x4 : minX;

    minY = y2 < minY ? y2 : minY;
    minY = y3 < minY ? y3 : minY;
    minY = y4 < minY ? y4 : minY;

    maxX = x2 > maxX ? x2 : maxX;
    maxX = x3 > maxX ? x3 : maxX;
    maxX = x4 > maxX ? x4 : maxX;

    maxY = y2 > maxY ? y2 : maxY;
    maxY = y3 > maxY ? y3 : maxY;
    maxY = y4 > maxY ? y4 : maxY;

    var bounds = this._bounds;

    bounds.x = minX;
    bounds.width = maxX - minX;

    bounds.y = minY;
    bounds.height = maxY - minY;

    return bounds;
};

/**
 * Update the bounds of the object
 *
 * @method updateBounds
 */
PIXI.Graphics.prototype.updateBounds = function()
{
    
    var minX = Infinity;
    var maxX = -Infinity;

    var minY = Infinity;
    var maxY = -Infinity;

    var points, x, y, w, h;

    for (var i = 0; i < this.graphicsData.length; i++) {
        var data = this.graphicsData[i];
        var type = data.type;
        var lineWidth = data.lineWidth;

        points = data.points;

        if(type === PIXI.Graphics.RECT)
        {
            x = points[0] - lineWidth/2;
            y = points[1] - lineWidth/2;
            w = points[2] + lineWidth;
            h = points[3] + lineWidth;

            minX = x < minX ? x : minX;
            maxX = x + w > maxX ? x + w : maxX;

            minY = y < minY ? x : minY;
            maxY = y + h > maxY ? y + h : maxY;
        }
        else if(type === PIXI.Graphics.CIRC || type === PIXI.Graphics.ELIP)
        {
            x = points[0];
            y = points[1];
            w = points[2] + lineWidth/2;
            h = points[3] + lineWidth/2;

            minX = x - w < minX ? x - w : minX;
            maxX = x + w > maxX ? x + w : maxX;

            minY = y - h < minY ? y - h : minY;
            maxY = y + h > maxY ? y + h : maxY;
        }
        else
        {
            // POLY
            for (var j = 0; j < points.length; j+=2)
            {

                x = points[j];
                y = points[j+1];
                minX = x-lineWidth < minX ? x-lineWidth : minX;
                maxX = x+lineWidth > maxX ? x+lineWidth : maxX;

                minY = y-lineWidth < minY ? y-lineWidth : minY;
                maxY = y+lineWidth > maxY ? y+lineWidth : maxY;
            }
        }
    }

    var padding = this.boundsPadding;
    this.bounds = new PIXI.Rectangle(minX - padding, minY - padding, (maxX - minX) + padding * 2, (maxY - minY) + padding * 2);
};


/**
 * Generates the cached sprite when the sprite has cacheAsBitmap = true
 *
 * @method _generateCachedSprite
 * @private
 */
PIXI.Graphics.prototype._generateCachedSprite = function()
{
    var bounds = this.getLocalBounds();

    if(!this._cachedSprite)
    {
        var canvasBuffer = new PIXI.CanvasBuffer(bounds.width, bounds.height);
        var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);
        
        this._cachedSprite = new PIXI.Sprite(texture);
        this._cachedSprite.buffer = canvasBuffer;

        this._cachedSprite.worldTransform = this.worldTransform;
    }
    else
    {
        this._cachedSprite.buffer.resize(bounds.width, bounds.height);
    }

    // leverage the anchor to account for the offset of the element
    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );
    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );

   // this._cachedSprite.buffer.context.save();
    this._cachedSprite.buffer.context.translate(-bounds.x,-bounds.y);
    
    PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context);
    this._cachedSprite.alpha = this.alpha;

   // this._cachedSprite.buffer.context.restore();
};

PIXI.Graphics.prototype.destroyCachedSprite = function()
{
    this._cachedSprite.texture.destroy(true);

    // let the gc collect the unused sprite
    // TODO could be object pooled!
    this._cachedSprite = null;
};


// SOME TYPES:
PIXI.Graphics.POLY = 0;
PIXI.Graphics.RECT = 1;
PIXI.Graphics.CIRC = 2;
PIXI.Graphics.ELIP = 3;
PIXI.Graphics.RREC = 4;


/**
 * @author Mat Groves http://matgroves.com/
 */

 /**
 * 
 * @class Strip
 * @extends DisplayObjectContainer
 * @constructor
 * @param texture {Texture} The texture to use
 * @param width {Number} the width 
 * @param height {Number} the height
 * 
 */
PIXI.Strip = function(texture)
{
    PIXI.DisplayObjectContainer.call( this );
    
    this.texture = texture;

    // set up the main bits..
    this.uvs = new PIXI.Float32Array([0, 1,
                                    1, 1,
                                    1, 0,
                                    0,1]);

    this.verticies = new PIXI.Float32Array([0, 0,
                      100,0,
                      100,100,
                      0, 100]);

    this.colors = new PIXI.Float32Array([1, 1, 1, 1]);

    this.indices = new PIXI.Uint16Array([0, 1, 2, 3]);
    

    this.dirty = true;
};

// constructor
PIXI.Strip.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
PIXI.Strip.prototype.constructor = PIXI.Strip;

PIXI.Strip.prototype._renderWebGL = function(renderSession)
{
    // if the sprite is not visible or the alpha is 0 then no need to render this element
    if(!this.visible || this.alpha <= 0)return;
    // render triangle strip..

    renderSession.spriteBatch.stop();

    // init! init!
    if(!this._vertexBuffer)this._initWebGL(renderSession);
    
    renderSession.shaderManager.setShader(renderSession.shaderManager.stripShader);

    this._renderStrip(renderSession);

    ///renderSession.shaderManager.activateDefaultShader();

    renderSession.spriteBatch.start();

    //TODO check culling  
};

PIXI.Strip.prototype._initWebGL = function(renderSession)
{
    // build the strip!
    var gl = renderSession.gl;
    
    this._vertexBuffer = gl.createBuffer();
    this._indexBuffer = gl.createBuffer();
    this._uvBuffer = gl.createBuffer();
    this._colorBuffer = gl.createBuffer();
    
    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.verticies, gl.DYNAMIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer);
    gl.bufferData(gl.ARRAY_BUFFER,  this.uvs, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this._colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.colors, gl.STATIC_DRAW);
 
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
};

PIXI.Strip.prototype._renderStrip = function(renderSession)
{
    var gl = renderSession.gl;
    var projection = renderSession.projection,
        offset = renderSession.offset,
        shader = renderSession.shaderManager.stripShader;


    // gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mat4Real);

    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

    // set uniforms
    gl.uniformMatrix3fv(shader.translationMatrix, false, this.worldTransform.toArray(true));
    gl.uniform2f(shader.projectionVector, projection.x, -projection.y);
    gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);
    gl.uniform1f(shader.alpha, 1);

    if(!this.dirty)
    {
        
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.verticies);
        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
        
        // update the uvs
        gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer);
        gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
            
        gl.activeTexture(gl.TEXTURE0);
         // bind the current texture
        gl.bindTexture(gl.TEXTURE_2D, this.texture.baseTexture._glTextures[gl.id] || PIXI.createWebGLTexture(this.texture.baseTexture, gl));
    
        // dont need to upload!
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    
    
    }
    else
    {

        this.dirty = false;
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.verticies, gl.STATIC_DRAW);
        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
        
        // update the uvs
        gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.uvs, gl.STATIC_DRAW);
        gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
            
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.texture.baseTexture._glTextures[gl.id] || PIXI.createWebGLTexture(this.texture.baseTexture, gl));
    
        // dont need to upload!
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
        
    }
    //console.log(gl.TRIANGLE_STRIP)
    //
    //
    gl.drawElements(gl.TRIANGLE_STRIP, this.indices.length, gl.UNSIGNED_SHORT, 0);
    
  
};

PIXI.Strip.prototype._renderCanvas = function(renderSession)
{
    var context = renderSession.context;
    
    var transform = this.worldTransform;

    if (renderSession.roundPixels)
    {
        context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx | 0, transform.ty | 0);
    }
    else
    {
        context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);
    }
        
    var strip = this;
    // draw triangles!!
    var verticies = strip.verticies;
    var uvs = strip.uvs;

    var length = verticies.length/2;
    this.count++;

    for (var i = 0; i < length-2; i++)
    {
        // draw some triangles!
        var index = i*2;

        var x0 = verticies[index],   x1 = verticies[index+2], x2 = verticies[index+4];
        var y0 = verticies[index+1], y1 = verticies[index+3], y2 = verticies[index+5];

        if(true)
        {

            //expand();
            var centerX = (x0 + x1 + x2)/3;
            var centerY = (y0 + y1 + y2)/3;

            var normX = x0 - centerX;
            var normY = y0 - centerY;

            var dist = Math.sqrt( normX * normX + normY * normY );
            x0 = centerX + (normX / dist) * (dist + 3);
            y0 = centerY + (normY / dist) * (dist + 3);

            // 
            
            normX = x1 - centerX;
            normY = y1 - centerY;

            dist = Math.sqrt( normX * normX + normY * normY );
            x1 = centerX + (normX / dist) * (dist + 3);
            y1 = centerY + (normY / dist) * (dist + 3);

            normX = x2 - centerX;
            normY = y2 - centerY;

            dist = Math.sqrt( normX * normX + normY * normY );
            x2 = centerX + (normX / dist) * (dist + 3);
            y2 = centerY + (normY / dist) * (dist + 3);

        }

        var u0 = uvs[index] * strip.texture.width,   u1 = uvs[index+2] * strip.texture.width, u2 = uvs[index+4]* strip.texture.width;
        var v0 = uvs[index+1]* strip.texture.height, v1 = uvs[index+3] * strip.texture.height, v2 = uvs[index+5]* strip.texture.height;

        context.save();
        context.beginPath();


        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);

        context.closePath();

        context.clip();

        // Compute matrix transform
        var delta = u0*v1 + v0*u2 + u1*v2 - v1*u2 - v0*u1 - u0*v2;
        var deltaA = x0*v1 + v0*x2 + x1*v2 - v1*x2 - v0*x1 - x0*v2;
        var deltaB = u0*x1 + x0*u2 + u1*x2 - x1*u2 - x0*u1 - u0*x2;
        var deltaC = u0*v1*x2 + v0*x1*u2 + x0*u1*v2 - x0*v1*u2 - v0*u1*x2 - u0*x1*v2;
        var deltaD = y0*v1 + v0*y2 + y1*v2 - v1*y2 - v0*y1 - y0*v2;
        var deltaE = u0*y1 + y0*u2 + u1*y2 - y1*u2 - y0*u1 - u0*y2;
        var deltaF = u0*v1*y2 + v0*y1*u2 + y0*u1*v2 - y0*v1*u2 - v0*u1*y2 - u0*y1*v2;

        context.transform(deltaA / delta, deltaD / delta,
                            deltaB / delta, deltaE / delta,
                            deltaC / delta, deltaF / delta);

        context.drawImage(strip.texture.baseTexture.source, 0, 0);
        context.restore();
    }
};

/*
 * Sets the texture that the Strip will use 
 *
 * @method setTexture
 * @param texture {Texture} the texture that will be used
 * @private
 */

/*
PIXI.Strip.prototype.setTexture = function(texture)
{
    //TODO SET THE TEXTURES
    //TODO VISIBILITY

    // stop current texture
    this.texture = texture;
    this.width   = texture.frame.width;
    this.height  = texture.frame.height;
    this.updateFrame = true;
};
*/

/**
 * When the texture is updated, this event will fire to update the scale and frame
 *
 * @method onTextureUpdate
 * @param event
 * @private
 */

PIXI.Strip.prototype.onTextureUpdate = function()
{
    this.updateFrame = true;
};
/* @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * 
 * @class Rope
 * @constructor
 * @param texture {Texture} The texture to use
 * @param points {Array}
 * 
 */
PIXI.Rope = function(texture, points)
{
    PIXI.Strip.call( this, texture );
    this.points = points;

    this.verticies = new PIXI.Float32Array(points.length * 4);
    this.uvs = new PIXI.Float32Array(points.length * 4);
    this.colors = new PIXI.Float32Array(points.length * 2);
    this.indices = new PIXI.Uint16Array(points.length * 2);
   

    this.refresh();
};


// constructor
PIXI.Rope.prototype = Object.create( PIXI.Strip.prototype );
PIXI.Rope.prototype.constructor = PIXI.Rope;

/*
 * Refreshes 
 *
 * @method refresh
 */
PIXI.Rope.prototype.refresh = function()
{
    var points = this.points;
    if(points.length < 1) return;

    var uvs = this.uvs;

    var lastPoint = points[0];
    var indices = this.indices;
    var colors = this.colors;

    this.count-=0.2;

    uvs[0] = 0;
    uvs[1] = 0;
    uvs[2] = 0;
    uvs[3] = 1;

    colors[0] = 1;
    colors[1] = 1;

    indices[0] = 0;
    indices[1] = 1;

    var total = points.length,
        point, index, amount;

    for (var i = 1; i < total; i++)
    {
        point = points[i];
        index = i * 4;
        // time to do some smart drawing!
        amount = i / (total-1);

        if(i%2)
        {
            uvs[index] = amount;
            uvs[index+1] = 0;

            uvs[index+2] = amount;
            uvs[index+3] = 1;
        }
        else
        {
            uvs[index] = amount;
            uvs[index+1] = 0;

            uvs[index+2] = amount;
            uvs[index+3] = 1;
        }

        index = i * 2;
        colors[index] = 1;
        colors[index+1] = 1;

        index = i * 2;
        indices[index] = index;
        indices[index + 1] = index + 1;

        lastPoint = point;
    }
};

/*
 * Updates the object transform for rendering
 *
 * @method updateTransform
 * @private
 */
PIXI.Rope.prototype.updateTransform = function()
{

    var points = this.points;
    if(points.length < 1)return;

    var lastPoint = points[0];
    var nextPoint;
    var perp = {x:0, y:0};

    this.count-=0.2;

    var verticies = this.verticies;
    var total = points.length,
        point, index, ratio, perpLength, num;

    for (var i = 0; i < total; i++)
    {
        point = points[i];
        index = i * 4;

        if(i < points.length-1)
        {
            nextPoint = points[i+1];
        }
        else
        {
            nextPoint = point;
        }

        perp.y = -(nextPoint.x - lastPoint.x);
        perp.x = nextPoint.y - lastPoint.y;

        ratio = (1 - (i / (total-1))) * 10;

        if(ratio > 1) ratio = 1;

        perpLength = Math.sqrt(perp.x * perp.x + perp.y * perp.y);
        num = this.texture.height / 2; //(20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;
        perp.x /= perpLength;
        perp.y /= perpLength;

        perp.x *= num;
        perp.y *= num;

        verticies[index] = point.x + perp.x;
        verticies[index+1] = point.y + perp.y;
        verticies[index+2] = point.x - perp.x;
        verticies[index+3] = point.y - perp.y;

        lastPoint = point;
    }

    PIXI.DisplayObjectContainer.prototype.updateTransform.call( this );
};
/*
 * Sets the texture that the Rope will use 
 *
 * @method setTexture
 * @param texture {Texture} the texture that will be used
 */
PIXI.Rope.prototype.setTexture = function(texture)
{
    // stop current texture
    this.texture = texture;
    //this.updateFrame = true;
};

/**
 * @author Mat Groves http://matgroves.com/
 */

/**
 * A tiling sprite is a fast way of rendering a tiling image
 *
 * @class TilingSprite
 * @extends Sprite
 * @constructor
 * @param texture {Texture} the texture of the tiling sprite
 * @param width {Number}  the width of the tiling sprite
 * @param height {Number} the height of the tiling sprite
 */
PIXI.TilingSprite = function(texture, width, height)
{
    PIXI.Sprite.call( this, texture);

    /**
     * The with of the tiling sprite
     *
     * @property width
     * @type Number
     */
    this._width = width || 100;

    /**
     * The height of the tiling sprite
     *
     * @property height
     * @type Number
     */
    this._height = height || 100;

    /**
     * The scaling of the image that is being tiled
     *
     * @property tileScale
     * @type Point
     */
    this.tileScale = new PIXI.Point(1,1);

    /**
     * A point that represents the scale of the texture object
     *
     * @property tileScaleOffset
     * @type Point
     */
    this.tileScaleOffset = new PIXI.Point(1,1);
    
    /**
     * The offset position of the image that is being tiled
     *
     * @property tilePosition
     * @type Point
     */
    this.tilePosition = new PIXI.Point(0,0);

    /**
     * Whether this sprite is renderable or not
     *
     * @property renderable
     * @type Boolean
     * @default true
     */
    this.renderable = true;

    /**
     * The tint applied to the sprite. This is a hex value
     *
     * @property tint
     * @type Number
     * @default 0xFFFFFF
     */
    this.tint = 0xFFFFFF;
    
    /**
     * The blend mode to be applied to the sprite
     *
     * @property blendMode
     * @type Number
     * @default PIXI.blendModes.NORMAL;
     */
    this.blendMode = PIXI.blendModes.NORMAL;

    

};

// constructor
PIXI.TilingSprite.prototype = Object.create(PIXI.Sprite.prototype);
PIXI.TilingSprite.prototype.constructor = PIXI.TilingSprite;


/**
 * The width of the sprite, setting this will actually modify the scale to achieve the value set
 *
 * @property width
 * @type Number
 */
Object.defineProperty(PIXI.TilingSprite.prototype, 'width', {
    get: function() {
        return this._width;
    },
    set: function(value) {
        
        this._width = value;
    }
});

/**
 * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set
 *
 * @property height
 * @type Number
 */
Object.defineProperty(PIXI.TilingSprite.prototype, 'height', {
    get: function() {
        return  this._height;
    },
    set: function(value) {
        this._height = value;
    }
});

PIXI.TilingSprite.prototype.setTexture = function(texture)
{
    if (this.texture === texture) return;

    this.texture = texture;

    this.refreshTexture = true;

    this.cachedTint = 0xFFFFFF;
};

/**
* Renders the object using the WebGL renderer
*
* @method _renderWebGL
* @param renderSession {RenderSession} 
* @private
*/
PIXI.TilingSprite.prototype._renderWebGL = function(renderSession)
{
    if (this.visible === false || this.alpha === 0) return;
    var i,j;

    if (this._mask)
    {
        renderSession.spriteBatch.stop();
        renderSession.maskManager.pushMask(this.mask, renderSession);
        renderSession.spriteBatch.start();
    }

    if (this._filters)
    {
        renderSession.spriteBatch.flush();
        renderSession.filterManager.pushFilter(this._filterBlock);
    }

   

    if (!this.tilingTexture || this.refreshTexture)
    {
        this.generateTilingTexture(true);

        if (this.tilingTexture && this.tilingTexture.needsUpdate)
        {
            //TODO - tweaking
            PIXI.updateWebGLTexture(this.tilingTexture.baseTexture, renderSession.gl);
            this.tilingTexture.needsUpdate = false;
           // this.tilingTexture._uvs = null;
        }
    }
    else
    {
        renderSession.spriteBatch.renderTilingSprite(this);
    }
    // simple render children!
    for (i=0,j=this.children.length; i<j; i++)
    {
        this.children[i]._renderWebGL(renderSession);
    }

    renderSession.spriteBatch.stop();

    if (this._filters) renderSession.filterManager.popFilter();
    if (this._mask) renderSession.maskManager.popMask(renderSession);
    
    renderSession.spriteBatch.start();
};

/**
* Renders the object using the Canvas renderer
*
* @method _renderCanvas
* @param renderSession {RenderSession} 
* @private
*/
PIXI.TilingSprite.prototype._renderCanvas = function(renderSession)
{
    if (this.visible === false || this.alpha === 0)return;
    
    var context = renderSession.context;

    if (this._mask)
    {
        renderSession.maskManager.pushMask(this._mask, context);
    }

    context.globalAlpha = this.worldAlpha;
    
    var transform = this.worldTransform;

    var i,j;

    context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx , transform.ty);

    if (!this.__tilePattern ||  this.refreshTexture)
    {
        this.generateTilingTexture(false);
    
        if (this.tilingTexture)
        {
            this.__tilePattern = context.createPattern(this.tilingTexture.baseTexture.source, 'repeat');
        }
        else
        {
            return;
        }
    }

    // check blend mode
    if (this.blendMode !== renderSession.currentBlendMode)
    {
        renderSession.currentBlendMode = this.blendMode;
        context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];
    }

    var tilePosition = this.tilePosition;
    var tileScale = this.tileScale;

    tilePosition.x %= this.tilingTexture.baseTexture.width;
    tilePosition.y %= this.tilingTexture.baseTexture.height;

    // offset
    context.scale(tileScale.x,tileScale.y);
    context.translate(tilePosition.x, tilePosition.y);

    context.fillStyle = this.__tilePattern;

    // make sure to account for the anchor point..
    context.fillRect(-tilePosition.x + (this.anchor.x * -this._width),
                    -tilePosition.y + (this.anchor.y * -this._height),
                    this._width / tileScale.x,
                    this._height / tileScale.y);

    context.scale(1 / tileScale.x, 1 / tileScale.y);
    context.translate(-tilePosition.x, -tilePosition.y);

    if (this._mask)
    {
        renderSession.maskManager.popMask(renderSession.context);
    }

    for (i=0,j=this.children.length; i<j; i++)
    {
        this.children[i]._renderCanvas(renderSession);
    }
};


/**
* Returns the framing rectangle of the sprite as a PIXI.Rectangle object
*
* @method getBounds
* @return {Rectangle} the framing rectangle
*/
PIXI.TilingSprite.prototype.getBounds = function()
{
    var width = this._width;
    var height = this._height;

    var w0 = width * (1-this.anchor.x);
    var w1 = width * -this.anchor.x;

    var h0 = height * (1-this.anchor.y);
    var h1 = height * -this.anchor.y;

    var worldTransform = this.worldTransform;

    var a = worldTransform.a;
    var b = worldTransform.c;
    var c = worldTransform.b;
    var d = worldTransform.d;
    var tx = worldTransform.tx;
    var ty = worldTransform.ty;
    
    var x1 = a * w1 + c * h1 + tx;
    var y1 = d * h1 + b * w1 + ty;

    var x2 = a * w0 + c * h1 + tx;
    var y2 = d * h1 + b * w0 + ty;

    var x3 = a * w0 + c * h0 + tx;
    var y3 = d * h0 + b * w0 + ty;

    var x4 =  a * w1 + c * h0 + tx;
    var y4 =  d * h0 + b * w1 + ty;

    var maxX = -Infinity;
    var maxY = -Infinity;

    var minX = Infinity;
    var minY = Infinity;

    minX = x1 < minX ? x1 : minX;
    minX = x2 < minX ? x2 : minX;
    minX = x3 < minX ? x3 : minX;
    minX = x4 < minX ? x4 : minX;

    minY = y1 < minY ? y1 : minY;
    minY = y2 < minY ? y2 : minY;
    minY = y3 < minY ? y3 : minY;
    minY = y4 < minY ? y4 : minY;

    maxX = x1 > maxX ? x1 : maxX;
    maxX = x2 > maxX ? x2 : maxX;
    maxX = x3 > maxX ? x3 : maxX;
    maxX = x4 > maxX ? x4 : maxX;

    maxY = y1 > maxY ? y1 : maxY;
    maxY = y2 > maxY ? y2 : maxY;
    maxY = y3 > maxY ? y3 : maxY;
    maxY = y4 > maxY ? y4 : maxY;

    var bounds = this._bounds;

    bounds.x = minX;
    bounds.width = maxX - minX;

    bounds.y = minY;
    bounds.height = maxY - minY;

    // store a reference so that if this function gets called again in the render cycle we do not have to recalculate
    this._currentBounds = bounds;

    return bounds;
};



/**
 * When the texture is updated, this event will fire to update the scale and frame
 *
 * @method onTextureUpdate
 * @param event
 * @private
 */
PIXI.TilingSprite.prototype.onTextureUpdate = function()
{
   // overriding the sprite version of this!
};


/**
* 
* @method generateTilingTexture
* 
* @param forcePowerOfTwo {Boolean} Whether we want to force the texture to be a power of two
*/
PIXI.TilingSprite.prototype.generateTilingTexture = function(forcePowerOfTwo)
{
    if (!this.texture.baseTexture.hasLoaded) return;

    var texture = this.texture;
    var frame = texture.frame;
    var targetWidth, targetHeight;

    //  Check that the frame is the same size as the base texture.
    var isFrame = frame.width !== texture.baseTexture.width || frame.height !== texture.baseTexture.height;

    var newTextureRequired = false;

    if (!forcePowerOfTwo)
    {
        if (isFrame)
        {
            targetWidth = frame.width;
            targetHeight = frame.height;
           
            newTextureRequired = true;
        }
    }
    else
    {
        targetWidth = PIXI.getNextPowerOfTwo(frame.width);
        targetHeight = PIXI.getNextPowerOfTwo(frame.height);

        if (frame.width !== targetWidth || frame.height !== targetHeight) newTextureRequired = true;
    }

    if (newTextureRequired)
    {
        var canvasBuffer;

        if (this.tilingTexture && this.tilingTexture.isTiling)
        {
            canvasBuffer = this.tilingTexture.canvasBuffer;
            canvasBuffer.resize(targetWidth, targetHeight);
            this.tilingTexture.baseTexture.width = targetWidth;
            this.tilingTexture.baseTexture.height = targetHeight;
            this.tilingTexture.needsUpdate = true;
        }
        else
        {
            canvasBuffer = new PIXI.CanvasBuffer(targetWidth, targetHeight);

            this.tilingTexture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);
            this.tilingTexture.canvasBuffer = canvasBuffer;
            this.tilingTexture.isTiling = true;
        }

        canvasBuffer.context.drawImage(texture.baseTexture.source,
                               texture.crop.x,
                               texture.crop.y,
                               texture.crop.width,
                               texture.crop.height,
                               0,
                               0,
                               targetWidth,
                               targetHeight);

        this.tileScaleOffset.x = frame.width / targetWidth;
        this.tileScaleOffset.y = frame.height / targetHeight;
    }
    else
    {
        //  TODO - switching?
        if (this.tilingTexture && this.tilingTexture.isTiling)
        {
            // destroy the tiling texture!
            // TODO could store this somewhere?
            this.tilingTexture.destroy(true);
        }

        this.tileScaleOffset.x = 1;
        this.tileScaleOffset.y = 1;
        this.tilingTexture = texture;
    }

    this.refreshTexture = false;
    this.tilingTexture.baseTexture._powerOf2 = true;
};
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 * based on pixi impact spine implementation made by Eemeli Kelokorpi (@ekelokorpi) https://github.com/ekelokorpi
 *
 * Awesome JS run time provided by EsotericSoftware
 * https://github.com/EsotericSoftware/spine-runtimes
 *
 */

/*
 * Awesome JS run time provided by EsotericSoftware
 *
 * https://github.com/EsotericSoftware/spine-runtimes
 *
 */



var spine = {};

spine.BoneData = function (name, parent) {
    this.name = name;
    this.parent = parent;
};
spine.BoneData.prototype = {
    length: 0,
    x: 0, y: 0,
    rotation: 0,
    scaleX: 1, scaleY: 1
};

spine.SlotData = function (name, boneData) {
    this.name = name;
    this.boneData = boneData;
};
spine.SlotData.prototype = {
    r: 1, g: 1, b: 1, a: 1,
    attachmentName: null
};

spine.Bone = function (boneData, parent) {
    this.data = boneData;
    this.parent = parent;
    this.setToSetupPose();
};
spine.Bone.yDown = false;
spine.Bone.prototype = {
    x: 0, y: 0,
    rotation: 0,
    scaleX: 1, scaleY: 1,
    m00: 0, m01: 0, worldX: 0, // a b x
    m10: 0, m11: 0, worldY: 0, // c d y
    worldRotation: 0,
    worldScaleX: 1, worldScaleY: 1,
    updateWorldTransform: function (flipX, flipY) {
        var parent = this.parent;
        if (parent != null) {
            this.worldX = this.x * parent.m00 + this.y * parent.m01 + parent.worldX;
            this.worldY = this.x * parent.m10 + this.y * parent.m11 + parent.worldY;
            this.worldScaleX = parent.worldScaleX * this.scaleX;
            this.worldScaleY = parent.worldScaleY * this.scaleY;
            this.worldRotation = parent.worldRotation + this.rotation;
        } else {
            this.worldX = this.x;
            this.worldY = this.y;
            this.worldScaleX = this.scaleX;
            this.worldScaleY = this.scaleY;
            this.worldRotation = this.rotation;
        }
        var radians = this.worldRotation * Math.PI / 180;
        var cos = Math.cos(radians);
        var sin = Math.sin(radians);
        this.m00 = cos * this.worldScaleX;
        this.m10 = sin * this.worldScaleX;
        this.m01 = -sin * this.worldScaleY;
        this.m11 = cos * this.worldScaleY;
        if (flipX) {
            this.m00 = -this.m00;
            this.m01 = -this.m01;
        }
        if (flipY) {
            this.m10 = -this.m10;
            this.m11 = -this.m11;
        }
        if (spine.Bone.yDown) {
            this.m10 = -this.m10;
            this.m11 = -this.m11;
        }
    },
    setToSetupPose: function () {
        var data = this.data;
        this.x = data.x;
        this.y = data.y;
        this.rotation = data.rotation;
        this.scaleX = data.scaleX;
        this.scaleY = data.scaleY;
    }
};

spine.Slot = function (slotData, skeleton, bone) {
    this.data = slotData;
    this.skeleton = skeleton;
    this.bone = bone;
    this.setToSetupPose();
};
spine.Slot.prototype = {
    r: 1, g: 1, b: 1, a: 1,
    _attachmentTime: 0,
    attachment: null,
    setAttachment: function (attachment) {
        this.attachment = attachment;
        this._attachmentTime = this.skeleton.time;
    },
    setAttachmentTime: function (time) {
        this._attachmentTime = this.skeleton.time - time;
    },
    getAttachmentTime: function () {
        return this.skeleton.time - this._attachmentTime;
    },
    setToSetupPose: function () {
        var data = this.data;
        this.r = data.r;
        this.g = data.g;
        this.b = data.b;
        this.a = data.a;

        var slotDatas = this.skeleton.data.slots;
        for (var i = 0, n = slotDatas.length; i < n; i++) {
            if (slotDatas[i] == data) {
                this.setAttachment(!data.attachmentName ? null : this.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));
                break;
            }
        }
    }
};

spine.Skin = function (name) {
    this.name = name;
    this.attachments = {};
};
spine.Skin.prototype = {
    addAttachment: function (slotIndex, name, attachment) {
        this.attachments[slotIndex + ":" + name] = attachment;
    },
    getAttachment: function (slotIndex, name) {
        return this.attachments[slotIndex + ":" + name];
    },
    _attachAll: function (skeleton, oldSkin) {
        for (var key in oldSkin.attachments) {
            var colon = key.indexOf(":");
            var slotIndex = parseInt(key.substring(0, colon), 10);
            var name = key.substring(colon + 1);
            var slot = skeleton.slots[slotIndex];
            if (slot.attachment && slot.attachment.name == name) {
                var attachment = this.getAttachment(slotIndex, name);
                if (attachment) slot.setAttachment(attachment);
            }
        }
    }
};

spine.Animation = function (name, timelines, duration) {
    this.name = name;
    this.timelines = timelines;
    this.duration = duration;
};
spine.Animation.prototype = {
    apply: function (skeleton, time, loop) {
        if (loop && this.duration) time %= this.duration;
        var timelines = this.timelines;
        for (var i = 0, n = timelines.length; i < n; i++)
            timelines[i].apply(skeleton, time, 1);
    },
    mix: function (skeleton, time, loop, alpha) {
        if (loop && this.duration) time %= this.duration;
        var timelines = this.timelines;
        for (var i = 0, n = timelines.length; i < n; i++)
            timelines[i].apply(skeleton, time, alpha);
    }
};

spine.binarySearch = function (values, target, step) {
    var low = 0;
    var high = Math.floor(values.length / step) - 2;
    if (!high) return step;
    var current = high >>> 1;
    while (true) {
        if (values[(current + 1) * step] <= target)
            low = current + 1;
        else
            high = current;
        if (low == high) return (low + 1) * step;
        current = (low + high) >>> 1;
    }
};
spine.linearSearch = function (values, target, step) {
    for (var i = 0, last = values.length - step; i <= last; i += step)
        if (values[i] > target) return i;
    return -1;
};

spine.Curves = function (frameCount) {
    this.curves = []; // dfx, dfy, ddfx, ddfy, dddfx, dddfy, ...
    this.curves.length = (frameCount - 1) * 6;
};
spine.Curves.prototype = {
    setLinear: function (frameIndex) {
        this.curves[frameIndex * 6] = 0/*LINEAR*/;
    },
    setStepped: function (frameIndex) {
        this.curves[frameIndex * 6] = -1/*STEPPED*/;
    },
    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.
     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of
     * the difference between the keyframe's values. */
    setCurve: function (frameIndex, cx1, cy1, cx2, cy2) {
        var subdiv_step = 1 / 10/*BEZIER_SEGMENTS*/;
        var subdiv_step2 = subdiv_step * subdiv_step;
        var subdiv_step3 = subdiv_step2 * subdiv_step;
        var pre1 = 3 * subdiv_step;
        var pre2 = 3 * subdiv_step2;
        var pre4 = 6 * subdiv_step2;
        var pre5 = 6 * subdiv_step3;
        var tmp1x = -cx1 * 2 + cx2;
        var tmp1y = -cy1 * 2 + cy2;
        var tmp2x = (cx1 - cx2) * 3 + 1;
        var tmp2y = (cy1 - cy2) * 3 + 1;
        var i = frameIndex * 6;
        var curves = this.curves;
        curves[i] = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv_step3;
        curves[i + 1] = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv_step3;
        curves[i + 2] = tmp1x * pre4 + tmp2x * pre5;
        curves[i + 3] = tmp1y * pre4 + tmp2y * pre5;
        curves[i + 4] = tmp2x * pre5;
        curves[i + 5] = tmp2y * pre5;
    },
    getCurvePercent: function (frameIndex, percent) {
        percent = percent < 0 ? 0 : (percent > 1 ? 1 : percent);
        var curveIndex = frameIndex * 6;
        var curves = this.curves;
        var dfx = curves[curveIndex];
        if (!dfx/*LINEAR*/) return percent;
        if (dfx == -1/*STEPPED*/) return 0;
        var dfy = curves[curveIndex + 1];
        var ddfx = curves[curveIndex + 2];
        var ddfy = curves[curveIndex + 3];
        var dddfx = curves[curveIndex + 4];
        var dddfy = curves[curveIndex + 5];
        var x = dfx, y = dfy;
        var i = 10/*BEZIER_SEGMENTS*/ - 2;
        while (true) {
            if (x >= percent) {
                var lastX = x - dfx;
                var lastY = y - dfy;
                return lastY + (y - lastY) * (percent - lastX) / (x - lastX);
            }
            if (!i) break;
            i--;
            dfx += ddfx;
            dfy += ddfy;
            ddfx += dddfx;
            ddfy += dddfy;
            x += dfx;
            y += dfy;
        }
        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.
    }
};

spine.RotateTimeline = function (frameCount) {
    this.curves = new spine.Curves(frameCount);
    this.frames = []; // time, angle, ...
    this.frames.length = frameCount * 2;
};
spine.RotateTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function () {
        return this.frames.length / 2;
    },
    setFrame: function (frameIndex, time, angle) {
        frameIndex *= 2;
        this.frames[frameIndex] = time;
        this.frames[frameIndex + 1] = angle;
    },
    apply: function (skeleton, time, alpha) {
        var frames = this.frames,
            amount;

        if (time < frames[0]) return; // Time is before first frame.

        var bone = skeleton.bones[this.boneIndex];

        if (time >= frames[frames.length - 2]) { // Time is after last frame.
            amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;
            while (amount > 180)
                amount -= 360;
            while (amount < -180)
                amount += 360;
            bone.rotation += amount * alpha;
            return;
        }

        // Interpolate between the last frame and the current frame.
        var frameIndex = spine.binarySearch(frames, time, 2);
        var lastFrameValue = frames[frameIndex - 1];
        var frameTime = frames[frameIndex];
        var percent = 1 - (time - frameTime) / (frames[frameIndex - 2/*LAST_FRAME_TIME*/] - frameTime);
        percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);

        amount = frames[frameIndex + 1/*FRAME_VALUE*/] - lastFrameValue;
        while (amount > 180)
            amount -= 360;
        while (amount < -180)
            amount += 360;
        amount = bone.data.rotation + (lastFrameValue + amount * percent) - bone.rotation;
        while (amount > 180)
            amount -= 360;
        while (amount < -180)
            amount += 360;
        bone.rotation += amount * alpha;
    }
};

spine.TranslateTimeline = function (frameCount) {
    this.curves = new spine.Curves(frameCount);
    this.frames = []; // time, x, y, ...
    this.frames.length = frameCount * 3;
};
spine.TranslateTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function () {
        return this.frames.length / 3;
    },
    setFrame: function (frameIndex, time, x, y) {
        frameIndex *= 3;
        this.frames[frameIndex] = time;
        this.frames[frameIndex + 1] = x;
        this.frames[frameIndex + 2] = y;
    },
    apply: function (skeleton, time, alpha) {
        var frames = this.frames;
        if (time < frames[0]) return; // Time is before first frame.

        var bone = skeleton.bones[this.boneIndex];

        if (time >= frames[frames.length - 3]) { // Time is after last frame.
            bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;
            bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;
            return;
        }

        // Interpolate between the last frame and the current frame.
        var frameIndex = spine.binarySearch(frames, time, 3);
        var lastFrameX = frames[frameIndex - 2];
        var lastFrameY = frames[frameIndex - 1];
        var frameTime = frames[frameIndex];
        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*LAST_FRAME_TIME*/] - frameTime);
        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);

        bone.x += (bone.data.x + lastFrameX + (frames[frameIndex + 1/*FRAME_X*/] - lastFrameX) * percent - bone.x) * alpha;
        bone.y += (bone.data.y + lastFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - lastFrameY) * percent - bone.y) * alpha;
    }
};

spine.ScaleTimeline = function (frameCount) {
    this.curves = new spine.Curves(frameCount);
    this.frames = []; // time, x, y, ...
    this.frames.length = frameCount * 3;
};
spine.ScaleTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function () {
        return this.frames.length / 3;
    },
    setFrame: function (frameIndex, time, x, y) {
        frameIndex *= 3;
        this.frames[frameIndex] = time;
        this.frames[frameIndex + 1] = x;
        this.frames[frameIndex + 2] = y;
    },
    apply: function (skeleton, time, alpha) {
        var frames = this.frames;
        if (time < frames[0]) return; // Time is before first frame.

        var bone = skeleton.bones[this.boneIndex];

        if (time >= frames[frames.length - 3]) { // Time is after last frame.
            bone.scaleX += (bone.data.scaleX - 1 + frames[frames.length - 2] - bone.scaleX) * alpha;
            bone.scaleY += (bone.data.scaleY - 1 + frames[frames.length - 1] - bone.scaleY) * alpha;
            return;
        }

        // Interpolate between the last frame and the current frame.
        var frameIndex = spine.binarySearch(frames, time, 3);
        var lastFrameX = frames[frameIndex - 2];
        var lastFrameY = frames[frameIndex - 1];
        var frameTime = frames[frameIndex];
        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*LAST_FRAME_TIME*/] - frameTime);
        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);

        bone.scaleX += (bone.data.scaleX - 1 + lastFrameX + (frames[frameIndex + 1/*FRAME_X*/] - lastFrameX) * percent - bone.scaleX) * alpha;
        bone.scaleY += (bone.data.scaleY - 1 + lastFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - lastFrameY) * percent - bone.scaleY) * alpha;
    }
};

spine.ColorTimeline = function (frameCount) {
    this.curves = new spine.Curves(frameCount);
    this.frames = []; // time, r, g, b, a, ...
    this.frames.length = frameCount * 5;
};
spine.ColorTimeline.prototype = {
    slotIndex: 0,
    getFrameCount: function () {
        return this.frames.length / 5;
    },
    setFrame: function (frameIndex, time, r, g, b, a) {
        frameIndex *= 5;
        this.frames[frameIndex] = time;
        this.frames[frameIndex + 1] = r;
        this.frames[frameIndex + 2] = g;
        this.frames[frameIndex + 3] = b;
        this.frames[frameIndex + 4] = a;
    },
    apply: function (skeleton, time, alpha) {
        var frames = this.frames;
        if (time < frames[0]) return; // Time is before first frame.

        var slot = skeleton.slots[this.slotIndex];

        if (time >= frames[frames.length - 5]) { // Time is after last frame.
            var i = frames.length - 1;
            slot.r = frames[i - 3];
            slot.g = frames[i - 2];
            slot.b = frames[i - 1];
            slot.a = frames[i];
            return;
        }

        // Interpolate between the last frame and the current frame.
        var frameIndex = spine.binarySearch(frames, time, 5);
        var lastFrameR = frames[frameIndex - 4];
        var lastFrameG = frames[frameIndex - 3];
        var lastFrameB = frames[frameIndex - 2];
        var lastFrameA = frames[frameIndex - 1];
        var frameTime = frames[frameIndex];
        var percent = 1 - (time - frameTime) / (frames[frameIndex - 5/*LAST_FRAME_TIME*/] - frameTime);
        percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);

        var r = lastFrameR + (frames[frameIndex + 1/*FRAME_R*/] - lastFrameR) * percent;
        var g = lastFrameG + (frames[frameIndex + 2/*FRAME_G*/] - lastFrameG) * percent;
        var b = lastFrameB + (frames[frameIndex + 3/*FRAME_B*/] - lastFrameB) * percent;
        var a = lastFrameA + (frames[frameIndex + 4/*FRAME_A*/] - lastFrameA) * percent;
        if (alpha < 1) {
            slot.r += (r - slot.r) * alpha;
            slot.g += (g - slot.g) * alpha;
            slot.b += (b - slot.b) * alpha;
            slot.a += (a - slot.a) * alpha;
        } else {
            slot.r = r;
            slot.g = g;
            slot.b = b;
            slot.a = a;
        }
    }
};

spine.AttachmentTimeline = function (frameCount) {
    this.curves = new spine.Curves(frameCount);
    this.frames = []; // time, ...
    this.frames.length = frameCount;
    this.attachmentNames = []; // time, ...
    this.attachmentNames.length = frameCount;
};
spine.AttachmentTimeline.prototype = {
    slotIndex: 0,
    getFrameCount: function () {
            return this.frames.length;
    },
    setFrame: function (frameIndex, time, attachmentName) {
        this.frames[frameIndex] = time;
        this.attachmentNames[frameIndex] = attachmentName;
    },
    apply: function (skeleton, time, alpha) {
        var frames = this.frames;
        if (time < frames[0]) return; // Time is before first frame.

        var frameIndex;
        if (time >= frames[frames.length - 1]) // Time is after last frame.
            frameIndex = frames.length - 1;
        else
            frameIndex = spine.binarySearch(frames, time, 1) - 1;

        var attachmentName = this.attachmentNames[frameIndex];
        skeleton.slots[this.slotIndex].setAttachment(!attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));
    }
};

spine.SkeletonData = function () {
    this.bones = [];
    this.slots = [];
    this.skins = [];
    this.animations = [];
};
spine.SkeletonData.prototype = {
    defaultSkin: null,
    /** @return May be null. */
    findBone: function (boneName) {
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
            if (bones[i].name == boneName) return bones[i];
        return null;
    },
    /** @return -1 if the bone was not found. */
    findBoneIndex: function (boneName) {
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
            if (bones[i].name == boneName) return i;
        return -1;
    },
    /** @return May be null. */
    findSlot: function (slotName) {
        var slots = this.slots;
        for (var i = 0, n = slots.length; i < n; i++) {
            if (slots[i].name == slotName) return slot[i];
        }
        return null;
    },
    /** @return -1 if the bone was not found. */
    findSlotIndex: function (slotName) {
        var slots = this.slots;
        for (var i = 0, n = slots.length; i < n; i++)
            if (slots[i].name == slotName) return i;
        return -1;
    },
    /** @return May be null. */
    findSkin: function (skinName) {
        var skins = this.skins;
        for (var i = 0, n = skins.length; i < n; i++)
            if (skins[i].name == skinName) return skins[i];
        return null;
    },
    /** @return May be null. */
    findAnimation: function (animationName) {
        var animations = this.animations;
        for (var i = 0, n = animations.length; i < n; i++)
            if (animations[i].name == animationName) return animations[i];
        return null;
    }
};

spine.Skeleton = function (skeletonData) {
    this.data = skeletonData;

    this.bones = [];
    for (var i = 0, n = skeletonData.bones.length; i < n; i++) {
        var boneData = skeletonData.bones[i];
        var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];
        this.bones.push(new spine.Bone(boneData, parent));
    }

    this.slots = [];
    this.drawOrder = [];
    for (i = 0, n = skeletonData.slots.length; i < n; i++) {
        var slotData = skeletonData.slots[i];
        var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];
        var slot = new spine.Slot(slotData, this, bone);
        this.slots.push(slot);
        this.drawOrder.push(slot);
    }
};
spine.Skeleton.prototype = {
    x: 0, y: 0,
    skin: null,
    r: 1, g: 1, b: 1, a: 1,
    time: 0,
    flipX: false, flipY: false,
    /** Updates the world transform for each bone. */
    updateWorldTransform: function () {
        var flipX = this.flipX;
        var flipY = this.flipY;
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
            bones[i].updateWorldTransform(flipX, flipY);
    },
    /** Sets the bones and slots to their setup pose values. */
    setToSetupPose: function () {
        this.setBonesToSetupPose();
        this.setSlotsToSetupPose();
    },
    setBonesToSetupPose: function () {
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
            bones[i].setToSetupPose();
    },
    setSlotsToSetupPose: function () {
        var slots = this.slots;
        for (var i = 0, n = slots.length; i < n; i++)
            slots[i].setToSetupPose(i);
    },
    /** @return May return null. */
    getRootBone: function () {
        return this.bones.length ? this.bones[0] : null;
    },
    /** @return May be null. */
    findBone: function (boneName) {
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
            if (bones[i].data.name == boneName) return bones[i];
        return null;
    },
    /** @return -1 if the bone was not found. */
    findBoneIndex: function (boneName) {
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
            if (bones[i].data.name == boneName) return i;
        return -1;
    },
    /** @return May be null. */
    findSlot: function (slotName) {
        var slots = this.slots;
        for (var i = 0, n = slots.length; i < n; i++)
            if (slots[i].data.name == slotName) return slots[i];
        return null;
    },
    /** @return -1 if the bone was not found. */
    findSlotIndex: function (slotName) {
        var slots = this.slots;
        for (var i = 0, n = slots.length; i < n; i++)
            if (slots[i].data.name == slotName) return i;
        return -1;
    },
    setSkinByName: function (skinName) {
        var skin = this.data.findSkin(skinName);
        if (!skin) throw "Skin not found: " + skinName;
        this.setSkin(skin);
    },
    /** Sets the skin used to look up attachments not found in the {@link SkeletonData#getDefaultSkin() default skin}. Attachments
     * from the new skin are attached if the corresponding attachment from the old skin was attached.
     * @param newSkin May be null. */
    setSkin: function (newSkin) {
        if (this.skin && newSkin) newSkin._attachAll(this, this.skin);
        this.skin = newSkin;
    },
    /** @return May be null. */
    getAttachmentBySlotName: function (slotName, attachmentName) {
        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);
    },
    /** @return May be null. */
    getAttachmentBySlotIndex: function (slotIndex, attachmentName) {
        if (this.skin) {
            var attachment = this.skin.getAttachment(slotIndex, attachmentName);
            if (attachment) return attachment;
        }
        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
        return null;
    },
    /** @param attachmentName May be null. */
    setAttachment: function (slotName, attachmentName) {
        var slots = this.slots;
        for (var i = 0, n = slots.size; i < n; i++) {
            var slot = slots[i];
            if (slot.data.name == slotName) {
                var attachment = null;
                if (attachmentName) {
                    attachment = this.getAttachment(i, attachmentName);
                    if (attachment == null) throw "Attachment not found: " + attachmentName + ", for slot: " + slotName;
                }
                slot.setAttachment(attachment);
                return;
            }
        }
        throw "Slot not found: " + slotName;
    },
    update: function (delta) {
        time += delta;
    }
};

spine.AttachmentType = {
    region: 0
};

spine.RegionAttachment = function () {
    this.offset = [];
    this.offset.length = 8;
    this.uvs = [];
    this.uvs.length = 8;
};
spine.RegionAttachment.prototype = {
    x: 0, y: 0,
    rotation: 0,
    scaleX: 1, scaleY: 1,
    width: 0, height: 0,
    rendererObject: null,
    regionOffsetX: 0, regionOffsetY: 0,
    regionWidth: 0, regionHeight: 0,
    regionOriginalWidth: 0, regionOriginalHeight: 0,
    setUVs: function (u, v, u2, v2, rotate) {
        var uvs = this.uvs;
        if (rotate) {
            uvs[2/*X2*/] = u;
            uvs[3/*Y2*/] = v2;
            uvs[4/*X3*/] = u;
            uvs[5/*Y3*/] = v;
            uvs[6/*X4*/] = u2;
            uvs[7/*Y4*/] = v;
            uvs[0/*X1*/] = u2;
            uvs[1/*Y1*/] = v2;
        } else {
            uvs[0/*X1*/] = u;
            uvs[1/*Y1*/] = v2;
            uvs[2/*X2*/] = u;
            uvs[3/*Y2*/] = v;
            uvs[4/*X3*/] = u2;
            uvs[5/*Y3*/] = v;
            uvs[6/*X4*/] = u2;
            uvs[7/*Y4*/] = v2;
        }
    },
    updateOffset: function () {
        var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;
        var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;
        var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;
        var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;
        var localX2 = localX + this.regionWidth * regionScaleX;
        var localY2 = localY + this.regionHeight * regionScaleY;
        var radians = this.rotation * Math.PI / 180;
        var cos = Math.cos(radians);
        var sin = Math.sin(radians);
        var localXCos = localX * cos + this.x;
        var localXSin = localX * sin;
        var localYCos = localY * cos + this.y;
        var localYSin = localY * sin;
        var localX2Cos = localX2 * cos + this.x;
        var localX2Sin = localX2 * sin;
        var localY2Cos = localY2 * cos + this.y;
        var localY2Sin = localY2 * sin;
        var offset = this.offset;
        offset[0/*X1*/] = localXCos - localYSin;
        offset[1/*Y1*/] = localYCos + localXSin;
        offset[2/*X2*/] = localXCos - localY2Sin;
        offset[3/*Y2*/] = localY2Cos + localXSin;
        offset[4/*X3*/] = localX2Cos - localY2Sin;
        offset[5/*Y3*/] = localY2Cos + localX2Sin;
        offset[6/*X4*/] = localX2Cos - localYSin;
        offset[7/*Y4*/] = localYCos + localX2Sin;
    },
    computeVertices: function (x, y, bone, vertices) {
        x += bone.worldX;
        y += bone.worldY;
        var m00 = bone.m00;
        var m01 = bone.m01;
        var m10 = bone.m10;
        var m11 = bone.m11;
        var offset = this.offset;
        vertices[0/*X1*/] = offset[0/*X1*/] * m00 + offset[1/*Y1*/] * m01 + x;
        vertices[1/*Y1*/] = offset[0/*X1*/] * m10 + offset[1/*Y1*/] * m11 + y;
        vertices[2/*X2*/] = offset[2/*X2*/] * m00 + offset[3/*Y2*/] * m01 + x;
        vertices[3/*Y2*/] = offset[2/*X2*/] * m10 + offset[3/*Y2*/] * m11 + y;
        vertices[4/*X3*/] = offset[4/*X3*/] * m00 + offset[5/*X3*/] * m01 + x;
        vertices[5/*X3*/] = offset[4/*X3*/] * m10 + offset[5/*X3*/] * m11 + y;
        vertices[6/*X4*/] = offset[6/*X4*/] * m00 + offset[7/*Y4*/] * m01 + x;
        vertices[7/*Y4*/] = offset[6/*X4*/] * m10 + offset[7/*Y4*/] * m11 + y;
    }
}

spine.AnimationStateData = function (skeletonData) {
    this.skeletonData = skeletonData;
    this.animationToMixTime = {};
};
spine.AnimationStateData.prototype = {
        defaultMix: 0,
    setMixByName: function (fromName, toName, duration) {
        var from = this.skeletonData.findAnimation(fromName);
        if (!from) throw "Animation not found: " + fromName;
        var to = this.skeletonData.findAnimation(toName);
        if (!to) throw "Animation not found: " + toName;
        this.setMix(from, to, duration);
    },
    setMix: function (from, to, duration) {
        this.animationToMixTime[from.name + ":" + to.name] = duration;
    },
    getMix: function (from, to) {
        var time = this.animationToMixTime[from.name + ":" + to.name];
            return time ? time : this.defaultMix;
    }
};

spine.AnimationState = function (stateData) {
    this.data = stateData;
    this.queue = [];
};
spine.AnimationState.prototype = {
    animationSpeed: 1,
    current: null,
    previous: null,
    currentTime: 0,
    previousTime: 0,
    currentLoop: false,
    previousLoop: false,
    mixTime: 0,
    mixDuration: 0,
    update: function (delta) {
        this.currentTime += (delta * this.animationSpeed); //timeScale: Multiply delta by the speed of animation required.
        this.previousTime += delta;
        this.mixTime += delta;

        if (this.queue.length > 0) {
            var entry = this.queue[0];
            if (this.currentTime >= entry.delay) {
                this._setAnimation(entry.animation, entry.loop);
                this.queue.shift();
            }
        }
    },
    apply: function (skeleton) {
        if (!this.current) return;
        if (this.previous) {
            this.previous.apply(skeleton, this.previousTime, this.previousLoop);
            var alpha = this.mixTime / this.mixDuration;
            if (alpha >= 1) {
                alpha = 1;
                this.previous = null;
            }
            this.current.mix(skeleton, this.currentTime, this.currentLoop, alpha);
        } else
            this.current.apply(skeleton, this.currentTime, this.currentLoop);
    },
    clearAnimation: function () {
        this.previous = null;
        this.current = null;
        this.queue.length = 0;
    },
    _setAnimation: function (animation, loop) {
        this.previous = null;
        if (animation && this.current) {
            this.mixDuration = this.data.getMix(this.current, animation);
            if (this.mixDuration > 0) {
                this.mixTime = 0;
                this.previous = this.current;
                this.previousTime = this.currentTime;
                this.previousLoop = this.currentLoop;
            }
        }
        this.current = animation;
        this.currentLoop = loop;
        this.currentTime = 0;
    },
    /** @see #setAnimation(Animation, Boolean) */
    setAnimationByName: function (animationName, loop) {
        var animation = this.data.skeletonData.findAnimation(animationName);
        if (!animation) throw "Animation not found: " + animationName;
        this.setAnimation(animation, loop);
    },
    /** Set the current animation. Any queued animations are cleared and the current animation time is set to 0.
     * @param animation May be null. */
    setAnimation: function (animation, loop) {
        this.queue.length = 0;
        this._setAnimation(animation, loop);
    },
    /** @see #addAnimation(Animation, Boolean, Number) */
    addAnimationByName: function (animationName, loop, delay) {
        var animation = this.data.skeletonData.findAnimation(animationName);
        if (!animation) throw "Animation not found: " + animationName;
        this.addAnimation(animation, loop, delay);
    },
    /** Adds an animation to be played delay seconds after the current or last queued animation.
     * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */
    addAnimation: function (animation, loop, delay) {
        var entry = {};
        entry.animation = animation;
        entry.loop = loop;

        if (!delay || delay <= 0) {
            var previousAnimation = this.queue.length ? this.queue[this.queue.length - 1].animation : this.current;
            if (previousAnimation != null)
                delay = previousAnimation.duration - this.data.getMix(previousAnimation, animation) + (delay || 0);
            else
                delay = 0;
        }
        entry.delay = delay;

        this.queue.push(entry);
    },
    /** Returns true if no animation is set or if the current time is greater than the animation duration, regardless of looping. */
    isComplete: function () {
        return !this.current || this.currentTime >= this.current.duration;
    }
};

spine.SkeletonJson = function (attachmentLoader) {
    this.attachmentLoader = attachmentLoader;
};
spine.SkeletonJson.prototype = {
    scale: 1,
    readSkeletonData: function (root) {
        /*jshint -W069*/
        var skeletonData = new spine.SkeletonData(),
            boneData;

        // Bones.
        var bones = root["bones"];
        for (var i = 0, n = bones.length; i < n; i++) {
            var boneMap = bones[i];
            var parent = null;
            if (boneMap["parent"]) {
                parent = skeletonData.findBone(boneMap["parent"]);
                if (!parent) throw "Parent bone not found: " + boneMap["parent"];
            }
            boneData = new spine.BoneData(boneMap["name"], parent);
            boneData.length = (boneMap["length"] || 0) * this.scale;
            boneData.x = (boneMap["x"] || 0) * this.scale;
            boneData.y = (boneMap["y"] || 0) * this.scale;
            boneData.rotation = (boneMap["rotation"] || 0);
            boneData.scaleX = boneMap["scaleX"] || 1;
            boneData.scaleY = boneMap["scaleY"] || 1;
            skeletonData.bones.push(boneData);
        }

        // Slots.
        var slots = root["slots"];
        for (i = 0, n = slots.length; i < n; i++) {
            var slotMap = slots[i];
            boneData = skeletonData.findBone(slotMap["bone"]);
            if (!boneData) throw "Slot bone not found: " + slotMap["bone"];
            var slotData = new spine.SlotData(slotMap["name"], boneData);

            var color = slotMap["color"];
            if (color) {
                slotData.r = spine.SkeletonJson.toColor(color, 0);
                slotData.g = spine.SkeletonJson.toColor(color, 1);
                slotData.b = spine.SkeletonJson.toColor(color, 2);
                slotData.a = spine.SkeletonJson.toColor(color, 3);
            }

            slotData.attachmentName = slotMap["attachment"];

            skeletonData.slots.push(slotData);
        }

        // Skins.
        var skins = root["skins"];
        for (var skinName in skins) {
            if (!skins.hasOwnProperty(skinName)) continue;
            var skinMap = skins[skinName];
            var skin = new spine.Skin(skinName);
            for (var slotName in skinMap) {
                if (!skinMap.hasOwnProperty(slotName)) continue;
                var slotIndex = skeletonData.findSlotIndex(slotName);
                var slotEntry = skinMap[slotName];
                for (var attachmentName in slotEntry) {
                    if (!slotEntry.hasOwnProperty(attachmentName)) continue;
                    var attachment = this.readAttachment(skin, attachmentName, slotEntry[attachmentName]);
                    if (attachment != null) skin.addAttachment(slotIndex, attachmentName, attachment);
                }
            }
            skeletonData.skins.push(skin);
            if (skin.name == "default") skeletonData.defaultSkin = skin;
        }

        // Animations.
        var animations = root["animations"];
        for (var animationName in animations) {
            if (!animations.hasOwnProperty(animationName)) continue;
            this.readAnimation(animationName, animations[animationName], skeletonData);
        }

        return skeletonData;
    },
    readAttachment: function (skin, name, map) {
        /*jshint -W069*/
        name = map["name"] || name;

        var type = spine.AttachmentType[map["type"] || "region"];

        if (type == spine.AttachmentType.region) {
            var attachment = new spine.RegionAttachment();
            attachment.x = (map["x"] || 0) * this.scale;
            attachment.y = (map["y"] || 0) * this.scale;
            attachment.scaleX = map["scaleX"] || 1;
            attachment.scaleY = map["scaleY"] || 1;
            attachment.rotation = map["rotation"] || 0;
            attachment.width = (map["width"] || 32) * this.scale;
            attachment.height = (map["height"] || 32) * this.scale;
            attachment.updateOffset();

            attachment.rendererObject = {};
            attachment.rendererObject.name = name;
            attachment.rendererObject.scale = {};
            attachment.rendererObject.scale.x = attachment.scaleX;
            attachment.rendererObject.scale.y = attachment.scaleY;
            attachment.rendererObject.rotation = -attachment.rotation * Math.PI / 180;
            return attachment;
        }

            throw "Unknown attachment type: " + type;
    },

    readAnimation: function (name, map, skeletonData) {
        /*jshint -W069*/
        var timelines = [];
        var duration = 0;
        var frameIndex, timeline, timelineName, valueMap, values,
            i, n;

        var bones = map["bones"];
        for (var boneName in bones) {
            if (!bones.hasOwnProperty(boneName)) continue;
            var boneIndex = skeletonData.findBoneIndex(boneName);
            if (boneIndex == -1) throw "Bone not found: " + boneName;
            var boneMap = bones[boneName];

            for (timelineName in boneMap) {
                if (!boneMap.hasOwnProperty(timelineName)) continue;
                values = boneMap[timelineName];
                if (timelineName == "rotate") {
                    timeline = new spine.RotateTimeline(values.length);
                    timeline.boneIndex = boneIndex;

                    frameIndex = 0;
                    for (i = 0, n = values.length; i < n; i++) {
                        valueMap = values[i];
                        timeline.setFrame(frameIndex, valueMap["time"], valueMap["angle"]);
                        spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
                        frameIndex++;
                    }
                    timelines.push(timeline);
                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);

                } else if (timelineName == "translate" || timelineName == "scale") {
                    var timelineScale = 1;
                    if (timelineName == "scale")
                        timeline = new spine.ScaleTimeline(values.length);
                    else {
                        timeline = new spine.TranslateTimeline(values.length);
                        timelineScale = this.scale;
                    }
                    timeline.boneIndex = boneIndex;

                    frameIndex = 0;
                    for (i = 0, n = values.length; i < n; i++) {
                        valueMap = values[i];
                        var x = (valueMap["x"] || 0) * timelineScale;
                        var y = (valueMap["y"] || 0) * timelineScale;
                        timeline.setFrame(frameIndex, valueMap["time"], x, y);
                        spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
                        frameIndex++;
                    }
                    timelines.push(timeline);
                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);

                } else
                    throw "Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")";
            }
        }
        var slots = map["slots"];
        for (var slotName in slots) {
            if (!slots.hasOwnProperty(slotName)) continue;
            var slotMap = slots[slotName];
            var slotIndex = skeletonData.findSlotIndex(slotName);

            for (timelineName in slotMap) {
                if (!slotMap.hasOwnProperty(timelineName)) continue;
                values = slotMap[timelineName];
                if (timelineName == "color") {
                    timeline = new spine.ColorTimeline(values.length);
                    timeline.slotIndex = slotIndex;

                    frameIndex = 0;
                    for (i = 0, n = values.length; i < n; i++) {
                        valueMap = values[i];
                        var color = valueMap["color"];
                        var r = spine.SkeletonJson.toColor(color, 0);
                        var g = spine.SkeletonJson.toColor(color, 1);
                        var b = spine.SkeletonJson.toColor(color, 2);
                        var a = spine.SkeletonJson.toColor(color, 3);
                        timeline.setFrame(frameIndex, valueMap["time"], r, g, b, a);
                        spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
                        frameIndex++;
                    }
                    timelines.push(timeline);
                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);

                } else if (timelineName == "attachment") {
                    timeline = new spine.AttachmentTimeline(values.length);
                    timeline.slotIndex = slotIndex;

                    frameIndex = 0;
                    for (i = 0, n = values.length; i < n; i++) {
                        valueMap = values[i];
                        timeline.setFrame(frameIndex++, valueMap["time"], valueMap["name"]);
                    }
                    timelines.push(timeline);
                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);

                } else
                    throw "Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")";
            }
        }
        skeletonData.animations.push(new spine.Animation(name, timelines, duration));
    }
};
spine.SkeletonJson.readCurve = function (timeline, frameIndex, valueMap) {
    /*jshint -W069*/
    var curve = valueMap["curve"];
    if (!curve) return;
    if (curve == "stepped")
        timeline.curves.setStepped(frameIndex);
    else if (curve instanceof Array)
        timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);
};
spine.SkeletonJson.toColor = function (hexString, colorIndex) {
    if (hexString.length != 8) throw "Color hexidecimal length must be 8, recieved: " + hexString;
    return parseInt(hexString.substr(colorIndex * 2, 2), 16) / 255;
};

spine.Atlas = function (atlasText, textureLoader) {
    this.textureLoader = textureLoader;
    this.pages = [];
    this.regions = [];

    var reader = new spine.AtlasReader(atlasText);
    var tuple = [];
    tuple.length = 4;
    var page = null;
    while (true) {
        var line = reader.readLine();
        if (line == null) break;
        line = reader.trim(line);
        if (!line.length)
            page = null;
        else if (!page) {
            page = new spine.AtlasPage();
            page.name = line;

            page.format = spine.Atlas.Format[reader.readValue()];

            reader.readTuple(tuple);
            page.minFilter = spine.Atlas.TextureFilter[tuple[0]];
            page.magFilter = spine.Atlas.TextureFilter[tuple[1]];

            var direction = reader.readValue();
            page.uWrap = spine.Atlas.TextureWrap.clampToEdge;
            page.vWrap = spine.Atlas.TextureWrap.clampToEdge;
            if (direction == "x")
                page.uWrap = spine.Atlas.TextureWrap.repeat;
            else if (direction == "y")
                page.vWrap = spine.Atlas.TextureWrap.repeat;
            else if (direction == "xy")
                page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;

            textureLoader.load(page, line);

            this.pages.push(page);

        } else {
            var region = new spine.AtlasRegion();
            region.name = line;
            region.page = page;

            region.rotate = reader.readValue() == "true";

            reader.readTuple(tuple);
            var x = parseInt(tuple[0], 10);
            var y = parseInt(tuple[1], 10);

            reader.readTuple(tuple);
            var width = parseInt(tuple[0], 10);
            var height = parseInt(tuple[1], 10);

            region.u = x / page.width;
            region.v = y / page.height;
            if (region.rotate) {
                region.u2 = (x + height) / page.width;
                region.v2 = (y + width) / page.height;
            } else {
                region.u2 = (x + width) / page.width;
                region.v2 = (y + height) / page.height;
            }
            region.x = x;
            region.y = y;
            region.width = Math.abs(width);
            region.height = Math.abs(height);

            if (reader.readTuple(tuple) == 4) { // split is optional
                region.splits = [parseInt(tuple[0], 10), parseInt(tuple[1], 10), parseInt(tuple[2], 10), parseInt(tuple[3], 10)];

                if (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits
                    region.pads = [parseInt(tuple[0], 10), parseInt(tuple[1], 10), parseInt(tuple[2], 10), parseInt(tuple[3], 10)];

                    reader.readTuple(tuple);
                }
            }

            region.originalWidth = parseInt(tuple[0], 10);
            region.originalHeight = parseInt(tuple[1], 10);

            reader.readTuple(tuple);
            region.offsetX = parseInt(tuple[0], 10);
            region.offsetY = parseInt(tuple[1], 10);

            region.index = parseInt(reader.readValue(), 10);

            this.regions.push(region);
        }
    }
};
spine.Atlas.prototype = {
    findRegion: function (name) {
        var regions = this.regions;
        for (var i = 0, n = regions.length; i < n; i++)
            if (regions[i].name == name) return regions[i];
        return null;
    },
    dispose: function () {
        var pages = this.pages;
        for (var i = 0, n = pages.length; i < n; i++)
            this.textureLoader.unload(pages[i].rendererObject);
    },
    updateUVs: function (page) {
        var regions = this.regions;
        for (var i = 0, n = regions.length; i < n; i++) {
            var region = regions[i];
            if (region.page != page) continue;
            region.u = region.x / page.width;
            region.v = region.y / page.height;
            if (region.rotate) {
                region.u2 = (region.x + region.height) / page.width;
                region.v2 = (region.y + region.width) / page.height;
            } else {
                region.u2 = (region.x + region.width) / page.width;
                region.v2 = (region.y + region.height) / page.height;
            }
        }
    }
};

spine.Atlas.Format = {
    alpha: 0,
    intensity: 1,
    luminanceAlpha: 2,
    rgb565: 3,
    rgba4444: 4,
    rgb888: 5,
    rgba8888: 6
};

spine.Atlas.TextureFilter = {
    nearest: 0,
    linear: 1,
    mipMap: 2,
    mipMapNearestNearest: 3,
    mipMapLinearNearest: 4,
    mipMapNearestLinear: 5,
    mipMapLinearLinear: 6
};

spine.Atlas.TextureWrap = {
    mirroredRepeat: 0,
    clampToEdge: 1,
    repeat: 2
};

spine.AtlasPage = function () {};
spine.AtlasPage.prototype = {
    name: null,
    format: null,
    minFilter: null,
    magFilter: null,
    uWrap: null,
    vWrap: null,
    rendererObject: null,
    width: 0,
    height: 0
};

spine.AtlasRegion = function () {};
spine.AtlasRegion.prototype = {
    page: null,
    name: null,
    x: 0, y: 0,
    width: 0, height: 0,
    u: 0, v: 0, u2: 0, v2: 0,
    offsetX: 0, offsetY: 0,
    originalWidth: 0, originalHeight: 0,
    index: 0,
    rotate: false,
    splits: null,
    pads: null
};

spine.AtlasReader = function (text) {
    this.lines = text.split(/\r\n|\r|\n/);
};
spine.AtlasReader.prototype = {
    index: 0,
    trim: function (value) {
        return value.replace(/^\s+|\s+$/g, "");
    },
    readLine: function () {
        if (this.index >= this.lines.length) return null;
        return this.lines[this.index++];
    },
    readValue: function () {
        var line = this.readLine();
        var colon = line.indexOf(":");
        if (colon == -1) throw "Invalid line: " + line;
        return this.trim(line.substring(colon + 1));
    },
    /** Returns the number of tuple values read (2 or 4). */
    readTuple: function (tuple) {
        var line = this.readLine();
        var colon = line.indexOf(":");
        if (colon == -1) throw "Invalid line: " + line;
        var i = 0, lastMatch= colon + 1;
        for (; i < 3; i++) {
            var comma = line.indexOf(",", lastMatch);
            if (comma == -1) {
                if (!i) throw "Invalid line: " + line;
                break;
            }
            tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));
            lastMatch = comma + 1;
        }
        tuple[i] = this.trim(line.substring(lastMatch));
        return i + 1;
    }
}

spine.AtlasAttachmentLoader = function (atlas) {
    this.atlas = atlas;
}
spine.AtlasAttachmentLoader.prototype = {
    newAttachment: function (skin, type, name) {
        switch (type) {
        case spine.AttachmentType.region:
            var region = this.atlas.findRegion(name);
            if (!region) throw "Region not found in atlas: " + name + " (" + type + ")";
            var attachment = new spine.RegionAttachment(name);
            attachment.rendererObject = region;
            attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);
            attachment.regionOffsetX = region.offsetX;
            attachment.regionOffsetY = region.offsetY;
            attachment.regionWidth = region.width;
            attachment.regionHeight = region.height;
            attachment.regionOriginalWidth = region.originalWidth;
            attachment.regionOriginalHeight = region.originalHeight;
            return attachment;
        }
        throw "Unknown attachment type: " + type;
    }
}

spine.Bone.yDown = true;
PIXI.AnimCache = {};

/**
 * A class that enables the you to import and run your spine animations in pixi.
 * Spine animation data needs to be loaded using the PIXI.AssetLoader or PIXI.SpineLoader before it can be used by this class
 * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source
 *
 * @class Spine
 * @extends DisplayObjectContainer
 * @constructor
 * @param url {String} The url of the spine anim file to be used
 */
PIXI.Spine = function (url) {
    PIXI.DisplayObjectContainer.call(this);

    this.spineData = PIXI.AnimCache[url];

    if (!this.spineData) {
        throw new Error("Spine data must be preloaded using PIXI.SpineLoader or PIXI.AssetLoader: " + url);
    }

    this.skeleton = new spine.Skeleton(this.spineData);
    this.skeleton.updateWorldTransform();

    this.stateData = new spine.AnimationStateData(this.spineData);
    this.state = new spine.AnimationState(this.stateData);

    this.slotContainers = [];

    for (var i = 0, n = this.skeleton.drawOrder.length; i < n; i++) {
        var slot = this.skeleton.drawOrder[i];
        var attachment = slot.attachment;
        var slotContainer = new PIXI.DisplayObjectContainer();
        this.slotContainers.push(slotContainer);
        this.addChild(slotContainer);
        if (!(attachment instanceof spine.RegionAttachment)) {
            continue;
        }
        var spriteName = attachment.rendererObject.name;
        var sprite = this.createSprite(slot, attachment.rendererObject);
        slot.currentSprite = sprite;
        slot.currentSpriteName = spriteName;
        slotContainer.addChild(sprite);
    }
};

PIXI.Spine.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
PIXI.Spine.prototype.constructor = PIXI.Spine;

/*
 * Updates the object transform for rendering
 *
 * @method updateTransform
 * @private
 */
PIXI.Spine.prototype.updateTransform = function () {
    this.lastTime = this.lastTime || Date.now();
    var timeDelta = (Date.now() - this.lastTime) * 0.001;
    this.lastTime = Date.now();
    this.state.update(timeDelta);
    this.state.apply(this.skeleton);
    this.skeleton.updateWorldTransform();

    var drawOrder = this.skeleton.drawOrder;
    for (var i = 0, n = drawOrder.length; i < n; i++) {
        var slot = drawOrder[i];
        var attachment = slot.attachment;
        var slotContainer = this.slotContainers[i];
        if (!(attachment instanceof spine.RegionAttachment)) {
            slotContainer.visible = false;
            continue;
        }

        if (attachment.rendererObject) {
            if (!slot.currentSpriteName || slot.currentSpriteName != attachment.name) {
                var spriteName = attachment.rendererObject.name;
                if (slot.currentSprite !== undefined) {
                    slot.currentSprite.visible = false;
                }
                slot.sprites = slot.sprites || {};
                if (slot.sprites[spriteName] !== undefined) {
                    slot.sprites[spriteName].visible = true;
                } else {
                    var sprite = this.createSprite(slot, attachment.rendererObject);
                    slotContainer.addChild(sprite);
                }
                slot.currentSprite = slot.sprites[spriteName];
                slot.currentSpriteName = spriteName;
            }
        }
        slotContainer.visible = true;

        var bone = slot.bone;

        slotContainer.position.x = bone.worldX + attachment.x * bone.m00 + attachment.y * bone.m01;
        slotContainer.position.y = bone.worldY + attachment.x * bone.m10 + attachment.y * bone.m11;
        slotContainer.scale.x = bone.worldScaleX;
        slotContainer.scale.y = bone.worldScaleY;

        slotContainer.rotation = -(slot.bone.worldRotation * Math.PI / 180);

        slotContainer.alpha = slot.a;
        slot.currentSprite.tint = PIXI.rgb2hex([slot.r,slot.g,slot.b]);
    }

    PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
};


PIXI.Spine.prototype.createSprite = function (slot, descriptor) {
    var name = PIXI.TextureCache[descriptor.name] ? descriptor.name : descriptor.name + ".png";
    var sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(name));
    sprite.scale = descriptor.scale;
    sprite.rotation = descriptor.rotation;
    sprite.anchor.x = sprite.anchor.y = 0.5;

    slot.sprites = slot.sprites || {};
    slot.sprites[descriptor.name] = sprite;
    return sprite;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

PIXI.BaseTextureCache = {};
PIXI.texturesToUpdate = [];
PIXI.texturesToDestroy = [];

PIXI.BaseTextureCacheIdGenerator = 0;

/**
 * A texture stores the information that represents an image. All textures have a base texture
 *
 * @class BaseTexture
 * @uses EventTarget
 * @constructor
 * @param source {String} the source object (image or canvas)
 * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts
 */
PIXI.BaseTexture = function(source, scaleMode)
{
    PIXI.EventTarget.call( this );

    /**
     * [read-only] The width of the base texture set when the image has loaded
     *
     * @property width
     * @type Number
     * @readOnly
     */
    this.width = 100;

    /**
     * [read-only] The height of the base texture set when the image has loaded
     *
     * @property height
     * @type Number
     * @readOnly
     */
    this.height = 100;

    /**
     * The scale mode to apply when scaling this texture
     * @property scaleMode
     * @type PIXI.scaleModes
     * @default PIXI.scaleModes.LINEAR
     */
    this.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;

    /**
     * [read-only] Describes if the base texture has loaded or not
     *
     * @property hasLoaded
     * @type Boolean
     * @readOnly
     */
    this.hasLoaded = false;

    /**
     * The source that is loaded to create the texture
     *
     * @property source
     * @type Image
     */
    this.source = source;

    //TODO will be used for futer pixi 1.5...
    this.id = PIXI.BaseTextureCacheIdGenerator++;

    /**
     * Controls if RGB channels should be premultiplied by Alpha  (WebGL only)
     *
     * @property
     * @type Boolean
     * @default TRUE
    */
    this.premultipliedAlpha = true;

    // used for webGL
    this._glTextures = [];
    
    // used for webGL teture updateing...
    this._dirty = [];
    
    if(!source)return;

    if((this.source.complete || this.source.getContext) && this.source.width && this.source.height)
    {
        this.hasLoaded = true;
        this.width = this.source.width;
        this.height = this.source.height;

        PIXI.texturesToUpdate.push(this);
    }
    else
    {

        var scope = this;
        this.source.onload = function() {

            scope.hasLoaded = true;
            scope.width = scope.source.width;
            scope.height = scope.source.height;

            for (var i = 0; i < scope._glTextures.length; i++)
            {
                scope._dirty[i] = true;
            }

            // add it to somewhere...
            scope.dispatchEvent( { type: 'loaded', content: scope } );
        };
        this.source.onerror = function() {
            scope.dispatchEvent( { type: 'error', content: scope } );
        };
    }

    this.imageUrl = null;
    this._powerOf2 = false;

    

};

PIXI.BaseTexture.prototype.constructor = PIXI.BaseTexture;

/**
 * Destroys this base texture
 *
 * @method destroy
 */
PIXI.BaseTexture.prototype.destroy = function()
{
    if(this.imageUrl)
    {
        delete PIXI.BaseTextureCache[this.imageUrl];
        delete PIXI.TextureCache[this.imageUrl];
        this.imageUrl = null;
        this.source.src = null;
    }
    else if (this.source && this.source._pixiId)
    {
        delete PIXI.BaseTextureCache[this.source._pixiId];
    }
    this.source = null;
    PIXI.texturesToDestroy.push(this);
};

/**
 * Changes the source image of the texture
 *
 * @method updateSourceImage
 * @param newSrc {String} the path of the image
 */
PIXI.BaseTexture.prototype.updateSourceImage = function(newSrc)
{
    this.hasLoaded = false;
    this.source.src = null;
    this.source.src = newSrc;
};

/**
 * Helper function that returns a base texture based on an image url
 * If the image is not in the base texture cache it will be created and loaded
 *
 * @static
 * @method fromImage
 * @param imageUrl {String} The image url of the texture
 * @param crossorigin {Boolean} 
 * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts
 * @return BaseTexture
 */
PIXI.BaseTexture.fromImage = function(imageUrl, crossorigin, scaleMode)
{
    var baseTexture = PIXI.BaseTextureCache[imageUrl];
    
    if(crossorigin === undefined && imageUrl.indexOf('data:') === -1) crossorigin = true;

    if(!baseTexture)
    {
        // new Image() breaks tex loading in some versions of Chrome.
        // See https://code.google.com/p/chromium/issues/detail?id=238071
        var image = new Image();//document.createElement('img');
        if (crossorigin)
        {
            image.crossOrigin = '';
        }
        image.src = imageUrl;
        baseTexture = new PIXI.BaseTexture(image, scaleMode);
        baseTexture.imageUrl = imageUrl;
        PIXI.BaseTextureCache[imageUrl] = baseTexture;
    }

    return baseTexture;
};

/**
 * Helper function that returns a base texture based on a canvas element
 * If the image is not in the base texture cache it will be created and loaded
 *
 * @static
 * @method fromCanvas
 * @param canvas {Canvas} The canvas element source of the texture
 * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts
 * @return BaseTexture
 */
PIXI.BaseTexture.fromCanvas = function(canvas, scaleMode)
{
    if(!canvas._pixiId)
    {
        canvas._pixiId = 'canvas_' + PIXI.TextureCacheIdGenerator++;
    }

    var baseTexture = PIXI.BaseTextureCache[canvas._pixiId];

    if(!baseTexture)
    {
        baseTexture = new PIXI.BaseTexture(canvas, scaleMode);
        PIXI.BaseTextureCache[canvas._pixiId] = baseTexture;
    }

    return baseTexture;
};



/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

PIXI.TextureCache = {};
PIXI.FrameCache = {};

PIXI.TextureCacheIdGenerator = 0;

/**
 * A texture stores the information that represents an image or part of an image. It cannot be added
 * to the display list directly. To do this use PIXI.Sprite. If no frame is provided then the whole image is used
 *
 * @class Texture
 * @uses EventTarget
 * @constructor
 * @param baseTexture {BaseTexture} The base texture source to create the texture from
 * @param frame {Rectangle} The rectangle frame of the texture to show
 */
PIXI.Texture = function(baseTexture, frame)
{
    PIXI.EventTarget.call( this );

    /**
     * Does this Texture have any frame data assigned to it?
     *
     * @property noFrame
     * @type Boolean
     */
    this.noFrame = false;

    if (!frame)
    {
        this.noFrame = true;
        frame = new PIXI.Rectangle(0,0,1,1);
    }

    if (baseTexture instanceof PIXI.Texture)
    {
        baseTexture = baseTexture.baseTexture;
    }

    /**
     * The base texture that this texture uses.
     *
     * @property baseTexture
     * @type BaseTexture
     */
    this.baseTexture = baseTexture;

    /**
     * The frame specifies the region of the base texture that this texture uses
     *
     * @property frame
     * @type Rectangle
     */
    this.frame = frame;

    /**
     * The trim point
     *
     * @property trim
     * @type Rectangle
     */
    this.trim = null;
    
    /**
     * This will let the renderer know if the texture is valid. If its not then it cannot be rendered.
     *
     * @property valid
     * @type Boolean
     */
    this.valid = false;

    /**
     * The context scope under which events are run.
     *
     * @property scope
     * @type Object
     */
    this.scope = this;

    /**
     * The WebGL UV data cache.
     *
     * @private
     * @property _uvs
     * @type Object
     */
    this._uvs = null;
    
    /**
     * The width of the Texture in pixels.
     *
     * @property width
     * @type Number
     */
    this.width = 0;

    /**
     * The height of the Texture in pixels.
     *
     * @property height
     * @type Number
     */
    this.height = 0;

    /**
     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
     *
     * @property crop
     * @type Rectangle
     */
    this.crop = new PIXI.Rectangle(0, 0, 1, 1);

    if (baseTexture.hasLoaded)
    {
        if (this.noFrame) frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height);
        this.setFrame(frame);
    }
    else
    {
        var scope = this;
        baseTexture.addEventListener('loaded', function(){ scope.onBaseTextureLoaded(); });
    }
};

PIXI.Texture.prototype.constructor = PIXI.Texture;

/**
 * Called when the base texture is loaded
 *
 * @method onBaseTextureLoaded
 * @param event
 * @private
 */
PIXI.Texture.prototype.onBaseTextureLoaded = function()
{
    var baseTexture = this.baseTexture;
    baseTexture.removeEventListener('loaded', this.onLoaded);

    if (this.noFrame) this.frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height);
    
    this.setFrame(this.frame);

    this.scope.dispatchEvent( { type: 'update', content: this } );
};

/**
 * Destroys this texture
 *
 * @method destroy
 * @param destroyBase {Boolean} Whether to destroy the base texture as well
 */
PIXI.Texture.prototype.destroy = function(destroyBase)
{
    if (destroyBase) this.baseTexture.destroy();

    this.valid = false;
};

/**
 * Specifies the region of the baseTexture that this texture will use.
 *
 * @method setFrame
 * @param frame {Rectangle} The frame of the texture to set it to
 */
PIXI.Texture.prototype.setFrame = function(frame)
{
    this.noFrame = false;

    this.frame = frame;
    this.width = frame.width;
    this.height = frame.height;

    this.crop.x = frame.x;
    this.crop.y = frame.y;
    this.crop.width = frame.width;
    this.crop.height = frame.height;

    if (!this.trim && (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height))
    {
        throw new Error('Texture Error: frame does not fit inside the base Texture dimensions ' + this);
    }

    this.valid = frame && frame.width && frame.height && this.baseTexture.source && this.baseTexture.hasLoaded;

    if (this.trim)
    {
        this.width = this.trim.width;
        this.height = this.trim.height;
        this.frame.width = this.trim.width;
        this.frame.height = this.trim.height;
    }

    if (this.valid) PIXI.Texture.frameUpdates.push(this);

};

/**
 * Updates the internal WebGL UV cache.
 *
 * @method _updateWebGLuvs
 * @private
 */
PIXI.Texture.prototype._updateWebGLuvs = function()
{
    if(!this._uvs)this._uvs = new PIXI.TextureUvs();

    var frame = this.crop;
    var tw = this.baseTexture.width;
    var th = this.baseTexture.height;

    this._uvs.x0 = frame.x / tw;
    this._uvs.y0 = frame.y / th;

    this._uvs.x1 = (frame.x + frame.width) / tw;
    this._uvs.y1 = frame.y / th;

    this._uvs.x2 = (frame.x + frame.width) / tw;
    this._uvs.y2 = (frame.y + frame.height) / th;

    this._uvs.x3 = frame.x / tw;
    this._uvs.y3 = (frame.y + frame.height) / th;

};

/**
 * Helper function that returns a texture based on an image url
 * If the image is not in the texture cache it will be  created and loaded
 *
 * @static
 * @method fromImage
 * @param imageUrl {String} The image url of the texture
 * @param crossorigin {Boolean} Whether requests should be treated as crossorigin
 * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts
 * @return Texture
 */
PIXI.Texture.fromImage = function(imageUrl, crossorigin, scaleMode)
{
    var texture = PIXI.TextureCache[imageUrl];

    if(!texture)
    {
        texture = new PIXI.Texture(PIXI.BaseTexture.fromImage(imageUrl, crossorigin, scaleMode));
        PIXI.TextureCache[imageUrl] = texture;
    }

    return texture;
};

/**
 * Helper function that returns a texture based on a frame id
 * If the frame id is not in the texture cache an error will be thrown
 *
 * @static
 * @method fromFrame
 * @param frameId {String} The frame id of the texture
 * @return Texture
 */
PIXI.Texture.fromFrame = function(frameId)
{
    var texture = PIXI.TextureCache[frameId];
    if(!texture) throw new Error('The frameId "' + frameId + '" does not exist in the texture cache ');
    return texture;
};

/**
 * Helper function that returns a texture based on a canvas element
 * If the canvas is not in the texture cache it will be  created and loaded
 *
 * @static
 * @method fromCanvas
 * @param canvas {Canvas} The canvas element source of the texture
 * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts
 * @return Texture
 */
PIXI.Texture.fromCanvas = function(canvas, scaleMode)
{
    var baseTexture = PIXI.BaseTexture.fromCanvas(canvas, scaleMode);

    return new PIXI.Texture( baseTexture );

};


/**
 * Adds a texture to the textureCache.
 *
 * @static
 * @method addTextureToCache
 * @param texture {Texture}
 * @param id {String} the id that the texture will be stored against.
 */
PIXI.Texture.addTextureToCache = function(texture, id)
{
    PIXI.TextureCache[id] = texture;
};

/**
 * Remove a texture from the textureCache.
 *
 * @static
 * @method removeTextureFromCache
 * @param id {String} the id of the texture to be removed
 * @return {Texture} the texture that was removed
 */
PIXI.Texture.removeTextureFromCache = function(id)
{
    var texture = PIXI.TextureCache[id];
    delete PIXI.TextureCache[id];
    delete PIXI.BaseTextureCache[id];
    return texture;
};

// this is more for webGL.. it contains updated frames..
PIXI.Texture.frameUpdates = [];

PIXI.TextureUvs = function()
{
    this.x0 = 0;
    this.y0 = 0;

    this.x1 = 0;
    this.y1 = 0;

    this.x2 = 0;
    this.y2 = 0;

    this.x3 = 0;
    this.y3 = 0;


};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 A RenderTexture is a special texture that allows any pixi displayObject to be rendered to it.

 __Hint__: All DisplayObjects (exmpl. Sprites) that render on RenderTexture should be preloaded.
 Otherwise black rectangles will be drawn instead.

 RenderTexture takes snapshot of DisplayObject passed to render method. If DisplayObject is passed to render method, position and rotation of it will be ignored. For example:

    var renderTexture = new PIXI.RenderTexture(800, 600);
    var sprite = PIXI.Sprite.fromImage("spinObj_01.png");
    sprite.position.x = 800/2;
    sprite.position.y = 600/2;
    sprite.anchor.x = 0.5;
    sprite.anchor.y = 0.5;
    renderTexture.render(sprite);

 Sprite in this case will be rendered to 0,0 position. To render this sprite at center DisplayObjectContainer should be used:

    var doc = new PIXI.DisplayObjectContainer();
    doc.addChild(sprite);
    renderTexture.render(doc);  // Renders to center of renderTexture

 * @class RenderTexture
 * @extends Texture
 * @constructor
 * @param width {Number} The width of the render texture
 * @param height {Number} The height of the render texture
 * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts
 */
PIXI.RenderTexture = function(width, height, renderer, scaleMode)
{
    PIXI.EventTarget.call( this );

    /**
     * The with of the render texture
     *
     * @property width
     * @type Number
     */
    this.width = width || 100;
    /**
     * The height of the render texture
     *
     * @property height
     * @type Number
     */
    this.height = height || 100;

    /**
     * The framing rectangle of the render texture
     *
     * @property frame
     * @type Rectangle
     */
    this.frame = new PIXI.Rectangle(0, 0, this.width, this.height);

    /**
     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
     *
     * @property crop
     * @type Rectangle
     */
    this.crop = new PIXI.Rectangle(0, 0, this.width, this.height);
    
    /**
     * The base texture object that this texture uses
     *
     * @property baseTexture
     * @type BaseTexture
     */
    this.baseTexture = new PIXI.BaseTexture();
    this.baseTexture.width = this.width;
    this.baseTexture.height = this.height;
    this.baseTexture._glTextures = [];

    this.baseTexture.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;

    this.baseTexture.hasLoaded = true;

    // each render texture can only belong to one renderer at the moment if its webGL
    this.renderer = renderer || PIXI.defaultRenderer;

    if(this.renderer.type === PIXI.WEBGL_RENDERER)
    {
        var gl = this.renderer.gl;

        this.textureBuffer = new PIXI.FilterTexture(gl, this.width, this.height, this.baseTexture.scaleMode);
        this.baseTexture._glTextures[gl.id] =  this.textureBuffer.texture;

        this.render = this.renderWebGL;
        this.projection = new PIXI.Point(this.width/2 , -this.height/2);
    }
    else
    {
        this.render = this.renderCanvas;
        this.textureBuffer = new PIXI.CanvasBuffer(this.width, this.height);
        this.baseTexture.source = this.textureBuffer.canvas;
    }

    this.valid = true;
    PIXI.Texture.frameUpdates.push(this);


};

PIXI.RenderTexture.prototype = Object.create(PIXI.Texture.prototype);
PIXI.RenderTexture.prototype.constructor = PIXI.RenderTexture;

/**
 * Resize the RenderTexture.
 *
 * @method resize
 * @param width {Number} The width to resize to.
 * @param height {Number} The height to resize to.
 * @param updateBase {Boolean} Should the baseTexture.width and height values be resized as well?
 */
PIXI.RenderTexture.prototype.resize = function(width, height, updateBase)
{
    if (width === this.width && height === this.height)
    {
        return;
    }

    this.width = this.frame.width = this.crop.width = width;
    this.height =  this.frame.height = this.crop.height = height;

    if (updateBase)
    {
        this.baseTexture.width = this.width;
        this.baseTexture.height = this.height;
    }

    if (this.renderer.type === PIXI.WEBGL_RENDERER)
    {
        this.projection.x = this.width / 2;
        this.projection.y = -this.height / 2;
    }
    
    this.textureBuffer.resize(this.width, this.height);
};

/**
 * Clears the RenderTexture.
 *
 * @method clear
 */
PIXI.RenderTexture.prototype.clear = function()
{
    if (this.renderer.type === PIXI.WEBGL_RENDERER)
    {
        this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
    }
    
    this.textureBuffer.clear();
};

/**
 * This function will draw the display object to the texture.
 *
 * @method renderWebGL
 * @param displayObject {DisplayObject} The display object to render this texture on
 * @param clear {Boolean} If true the texture will be cleared before the displayObject is drawn
 * @private
 */
PIXI.RenderTexture.prototype.renderWebGL = function(displayObject, position, clear)
{
    //TOOD replace position with matrix..
    var gl = this.renderer.gl;

    gl.colorMask(true, true, true, true);

    gl.viewport(0, 0, this.width, this.height);

    gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer );

    if(clear)this.textureBuffer.clear();


    // THIS WILL MESS WITH HIT TESTING!
    var children = displayObject.children;

    //TODO -? create a new one??? dont think so!
    var originalWorldTransform = displayObject.worldTransform;
    displayObject.worldTransform = PIXI.RenderTexture.tempMatrix;
    // modify to flip...
    displayObject.worldTransform.d = -1;
    displayObject.worldTransform.ty = this.projection.y * -2;

    if(position)
    {
        displayObject.worldTransform.tx = position.x;
        displayObject.worldTransform.ty -= position.y;
    }

    for(var i=0,j=children.length; i<j; i++)
    {
        children[i].updateTransform();
    }

    // update the textures!
    PIXI.WebGLRenderer.updateTextures();

    this.renderer.spriteBatch.dirty = true;
    
    this.renderer.renderDisplayObject(displayObject, this.projection, this.textureBuffer.frameBuffer);

    displayObject.worldTransform = originalWorldTransform;

    this.renderer.spriteBatch.dirty = true;
};


/**
 * This function will draw the display object to the texture.
 *
 * @method renderCanvas
 * @param displayObject {DisplayObject} The display object to render this texture on
 * @param clear {Boolean} If true the texture will be cleared before the displayObject is drawn
 * @private
 */
PIXI.RenderTexture.prototype.renderCanvas = function(displayObject, position, clear)
{
    var children = displayObject.children;

    var originalWorldTransform = displayObject.worldTransform;

    displayObject.worldTransform = PIXI.RenderTexture.tempMatrix;
    
    if(position)
    {
        displayObject.worldTransform.tx = position.x;
        displayObject.worldTransform.ty = position.y;
    }
    else
    {
        displayObject.worldTransform.tx = 0;
        displayObject.worldTransform.ty = 0;
    }

    for(var i = 0, j = children.length; i < j; i++)
    {
        children[i].updateTransform();
    }

    if(clear)this.textureBuffer.clear();

    var context = this.textureBuffer.context;

    this.renderer.renderDisplayObject(displayObject, context);

    context.setTransform(1,0,0,1,0,0);

    displayObject.worldTransform = originalWorldTransform;
};

PIXI.RenderTexture.tempMatrix = new PIXI.Matrix();


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * A Class that loads a bunch of images / sprite sheet / bitmap font files. Once the
 * assets have been loaded they are added to the PIXI Texture cache and can be accessed
 * easily through PIXI.Texture.fromImage() and PIXI.Sprite.fromImage()
 * When all items have been loaded this class will dispatch a 'onLoaded' event
 * As each individual item is loaded this class will dispatch a 'onProgress' event
 *
 * @class AssetLoader
 * @constructor
 * @uses EventTarget
 * @param {Array<String>} assetURLs an array of image/sprite sheet urls that you would like loaded
 *      supported. Supported image formats include 'jpeg', 'jpg', 'png', 'gif'. Supported
 *      sprite sheet data formats only include 'JSON' at this time. Supported bitmap font
 *      data formats include 'xml' and 'fnt'.
 * @param crossorigin {Boolean} Whether requests should be treated as crossorigin
 */
PIXI.AssetLoader = function(assetURLs, crossorigin)
{
    PIXI.EventTarget.call(this);

    /**
     * The array of asset URLs that are going to be loaded
     *
     * @property assetURLs
     * @type Array<String>
     */
    this.assetURLs = assetURLs;

    /**
     * Whether the requests should be treated as cross origin
     *
     * @property crossorigin
     * @type Boolean
     */
    this.crossorigin = crossorigin;

    /**
     * Maps file extension to loader types
     *
     * @property loadersByType
     * @type Object
     */
    this.loadersByType = {
        'jpg':  PIXI.ImageLoader,
        'jpeg': PIXI.ImageLoader,
        'png':  PIXI.ImageLoader,
        'gif':  PIXI.ImageLoader,
        'webp': PIXI.ImageLoader,
        'json': PIXI.JsonLoader,
        'atlas': PIXI.AtlasLoader,
        'anim': PIXI.SpineLoader,
        'xml':  PIXI.BitmapFontLoader,
        'fnt':  PIXI.BitmapFontLoader
    };
};

/**
 * Fired when an item has loaded
 * @event onProgress
 */

/**
 * Fired when all the assets have loaded
 * @event onComplete
 */

// constructor
PIXI.AssetLoader.prototype.constructor = PIXI.AssetLoader;

/**
 * Given a filename, returns its extension, wil
 *
 * @method _getDataType
 * @param str {String} the name of the asset
 */
PIXI.AssetLoader.prototype._getDataType = function(str)
{
    var test = 'data:';
    //starts with 'data:'
    var start = str.slice(0, test.length).toLowerCase();
    if (start === test) {
        var data = str.slice(test.length);

        var sepIdx = data.indexOf(',');
        if (sepIdx === -1) //malformed data URI scheme
            return null;

        //e.g. 'image/gif;base64' => 'image/gif'
        var info = data.slice(0, sepIdx).split(';')[0];

        //We might need to handle some special cases here...
        //standardize text/plain to 'txt' file extension
        if (!info || info.toLowerCase() === 'text/plain')
            return 'txt';

        //User specified mime type, try splitting it by '/'
        return info.split('/').pop().toLowerCase();
    }

    return null;
};

/**
 * Starts loading the assets sequentially
 *
 * @method load
 */
PIXI.AssetLoader.prototype.load = function()
{
    var scope = this;

    function onLoad(evt) {
        scope.onAssetLoaded(evt.content);
    }

    this.loadCount = this.assetURLs.length;

    for (var i=0; i < this.assetURLs.length; i++)
    {
        var fileName = this.assetURLs[i];
        //first see if we have a data URI scheme..
        var fileType = this._getDataType(fileName);

        //if not, assume it's a file URI
        if (!fileType)
            fileType = fileName.split('?').shift().split('.').pop().toLowerCase();

        var Constructor = this.loadersByType[fileType];
        if(!Constructor)
            throw new Error(fileType + ' is an unsupported file type');

        var loader = new Constructor(fileName, this.crossorigin);

        loader.addEventListener('loaded', onLoad);
        loader.load();
    }
};

/**
 * Invoked after each file is loaded
 *
 * @method onAssetLoaded
 * @private
 */
PIXI.AssetLoader.prototype.onAssetLoaded = function(loader)
{
    this.loadCount--;
    this.dispatchEvent({ type: 'onProgress', content: this, loader: loader });
    if (this.onProgress) this.onProgress(loader);

    if (!this.loadCount)
    {
        this.dispatchEvent({type: 'onComplete', content: this});
        if(this.onComplete) this.onComplete();
    }
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The json file loader is used to load in JSON data and parse it
 * When loaded this class will dispatch a 'loaded' event
 * If loading fails this class will dispatch an 'error' event
 *
 * @class JsonLoader
 * @uses EventTarget
 * @constructor
 * @param url {String} The url of the JSON file
 * @param crossorigin {Boolean} Whether requests should be treated as crossorigin
 */
PIXI.JsonLoader = function (url, crossorigin) {
    PIXI.EventTarget.call(this);

    /**
     * The url of the bitmap font data
     *
     * @property url
     * @type String
     */
    this.url = url;

    /**
     * Whether the requests should be treated as cross origin
     *
     * @property crossorigin
     * @type Boolean
     */
    this.crossorigin = crossorigin;

    /**
     * [read-only] The base url of the bitmap font data
     *
     * @property baseUrl
     * @type String
     * @readOnly
     */
    this.baseUrl = url.replace(/[^\/]*$/, '');

    /**
     * [read-only] Whether the data has loaded yet
     *
     * @property loaded
     * @type Boolean
     * @readOnly
     */
    this.loaded = false;

};

// constructor
PIXI.JsonLoader.prototype.constructor = PIXI.JsonLoader;

/**
 * Loads the JSON data
 *
 * @method load
 */
PIXI.JsonLoader.prototype.load = function () {

    var scope = this;

    if(window.XDomainRequest && scope.crossorigin)
    {
        this.ajaxRequest = new window.XDomainRequest();

        // XDomainRequest has a few querks. Occasionally it will abort requests
        // A way to avoid this is to make sure ALL callbacks are set even if not used
        // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9
        this.ajaxRequest.timeout = 3000;

        this.ajaxRequest.onerror = function () {
            scope.onError();
        };
           
        this.ajaxRequest.ontimeout = function () {
            scope.onError();
        };

        this.ajaxRequest.onprogress = function() {};

    }
    else if (window.XMLHttpRequest)
    {
        this.ajaxRequest = new window.XMLHttpRequest();
    }
    else
    {
        this.ajaxRequest = new window.ActiveXObject('Microsoft.XMLHTTP');
    }

    

    this.ajaxRequest.onload = function(){

        scope.onJSONLoaded();
    };

    this.ajaxRequest.open('GET',this.url,true);

    this.ajaxRequest.send();
};

/**
 * Invoke when JSON file is loaded
 *
 * @method onJSONLoaded
 * @private
 */
PIXI.JsonLoader.prototype.onJSONLoaded = function () {
    
    if(!this.ajaxRequest.responseText )
    {
        this.onError();
        return;
    }
   
    this.json = JSON.parse(this.ajaxRequest.responseText);

    if(this.json.frames)
    {
        // sprite sheet
        var scope = this;
        var textureUrl = this.baseUrl + this.json.meta.image;
        var image = new PIXI.ImageLoader(textureUrl, this.crossorigin);
        var frameData = this.json.frames;

        this.texture = image.texture.baseTexture;
        image.addEventListener('loaded', function() {
            scope.onLoaded();
        });

        for (var i in frameData)
        {
            var rect = frameData[i].frame;

            if (rect)
            {
                PIXI.TextureCache[i] = new PIXI.Texture(this.texture, {
                    x: rect.x,
                    y: rect.y,
                    width: rect.w,
                    height: rect.h
                });

                PIXI.TextureCache[i].crop = new PIXI.Rectangle(rect.x, rect.y, rect.w, rect.h);

                //  Check to see if the sprite is trimmed
                if (frameData[i].trimmed)
                {
                    var actualSize = frameData[i].sourceSize;
                    var realSize = frameData[i].spriteSourceSize;
                    PIXI.TextureCache[i].trim = new PIXI.Rectangle(realSize.x, realSize.y, actualSize.w, actualSize.h);
                }
            }
        }

        image.load();

    }
    else if(this.json.bones)
    {
        // spine animation
        var spineJsonParser = new spine.SkeletonJson();
        var skeletonData = spineJsonParser.readSkeletonData(this.json);
        PIXI.AnimCache[this.url] = skeletonData;
        this.onLoaded();
    }
    else
    {
        this.onLoaded();
    }
};

/**
 * Invoke when json file loaded
 *
 * @method onLoaded
 * @private
 */
PIXI.JsonLoader.prototype.onLoaded = function () {
    this.loaded = true;
    this.dispatchEvent({
        type: 'loaded',
        content: this
    });
};

/**
 * Invoke when error occured
 *
 * @method onError
 * @private
 */
PIXI.JsonLoader.prototype.onError = function () {

    this.dispatchEvent({
        type: 'error',
        content: this
    });
};

/**
 * @author Martin Kelm http://mkelm.github.com
 */

/**
 * The atlas file loader is used to load in Atlas data and parse it
 * When loaded this class will dispatch a 'loaded' event
 * If loading fails this class will dispatch an 'error' event
 * @class AtlasLoader
 * @extends EventTarget
 * @constructor
 * @param {String} url the url of the JSON file
 * @param {Boolean} crossorigin
 */

PIXI.AtlasLoader = function (url, crossorigin) {
    PIXI.EventTarget.call(this);
    this.url = url;
    this.baseUrl = url.replace(/[^\/]*$/, '');
    this.crossorigin = crossorigin;
    this.loaded = false;

};

// constructor
PIXI.AtlasLoader.constructor = PIXI.AtlasLoader;


 /**
 * Starts loading the JSON file
 *
 * @method load
 */
PIXI.AtlasLoader.prototype.load = function () {
    this.ajaxRequest = new PIXI.AjaxRequest();
    this.ajaxRequest.onreadystatechange = this.onAtlasLoaded.bind(this);

    this.ajaxRequest.open('GET', this.url, true);
    if (this.ajaxRequest.overrideMimeType) this.ajaxRequest.overrideMimeType('application/json');
    this.ajaxRequest.send(null);
};

/**
 * Invoke when JSON file is loaded
 * @method onAtlasLoaded
 * @private
 */
PIXI.AtlasLoader.prototype.onAtlasLoaded = function () {
    if (this.ajaxRequest.readyState === 4) {
        if (this.ajaxRequest.status === 200 || window.location.href.indexOf('http') === -1) {
            this.atlas = {
                meta : {
                    image : []
                },
                frames : []
            };
            var result = this.ajaxRequest.responseText.split(/\r?\n/);
            var lineCount = -3;

            var currentImageId = 0;
            var currentFrame = null;
            var nameInNextLine = false;

            var i = 0,
                j = 0,
                selfOnLoaded = this.onLoaded.bind(this);

            // parser without rotation support yet!
            for (i = 0; i < result.length; i++) {
                result[i] = result[i].replace(/^\s+|\s+$/g, '');
                if (result[i] === '') {
                    nameInNextLine = i+1;
                }
                if (result[i].length > 0) {
                    if (nameInNextLine === i) {
                        this.atlas.meta.image.push(result[i]);
                        currentImageId = this.atlas.meta.image.length - 1;
                        this.atlas.frames.push({});
                        lineCount = -3;
                    } else if (lineCount > 0) {
                        if (lineCount % 7 === 1) { // frame name
                            if (currentFrame != null) { //jshint ignore:line
                                this.atlas.frames[currentImageId][currentFrame.name] = currentFrame;
                            }
                            currentFrame = { name: result[i], frame : {} };
                        } else {
                            var text = result[i].split(' ');
                            if (lineCount % 7 === 3) { // position
                                currentFrame.frame.x = Number(text[1].replace(',', ''));
                                currentFrame.frame.y = Number(text[2]);
                            } else if (lineCount % 7 === 4) { // size
                                currentFrame.frame.w = Number(text[1].replace(',', ''));
                                currentFrame.frame.h = Number(text[2]);
                            } else if (lineCount % 7 === 5) { // real size
                                var realSize = {
                                    x : 0,
                                    y : 0,
                                    w : Number(text[1].replace(',', '')),
                                    h : Number(text[2])
                                };

                                if (realSize.w > currentFrame.frame.w || realSize.h > currentFrame.frame.h) {
                                    currentFrame.trimmed = true;
                                    currentFrame.realSize = realSize;
                                } else {
                                    currentFrame.trimmed = false;
                                }
                            }
                        }
                    }
                    lineCount++;
                }
            }

            if (currentFrame != null) { //jshint ignore:line
                this.atlas.frames[currentImageId][currentFrame.name] = currentFrame;
            }

            if (this.atlas.meta.image.length > 0) {
                this.images = [];
                for (j = 0; j < this.atlas.meta.image.length; j++) {
                    // sprite sheet
                    var textureUrl = this.baseUrl + this.atlas.meta.image[j];
                    var frameData = this.atlas.frames[j];
                    this.images.push(new PIXI.ImageLoader(textureUrl, this.crossorigin));

                    for (i in frameData) {
                        var rect = frameData[i].frame;
                        if (rect) {
                            PIXI.TextureCache[i] = new PIXI.Texture(this.images[j].texture.baseTexture, {
                                x: rect.x,
                                y: rect.y,
                                width: rect.w,
                                height: rect.h
                            });
                            if (frameData[i].trimmed) {
                                PIXI.TextureCache[i].realSize = frameData[i].realSize;
                                // trim in pixi not supported yet, todo update trim properties if it is done ...
                                PIXI.TextureCache[i].trim.x = 0;
                                PIXI.TextureCache[i].trim.y = 0;
                            }
                        }
                    }
                }

                this.currentImageId = 0;
                for (j = 0; j < this.images.length; j++) {
                    this.images[j].addEventListener('loaded', selfOnLoaded);
                }
                this.images[this.currentImageId].load();

            } else {
                this.onLoaded();
            }

        } else {
            this.onError();
        }
    }
};

/**
 * Invoke when json file has loaded
 * @method onLoaded
 * @private
 */
PIXI.AtlasLoader.prototype.onLoaded = function () {
    if (this.images.length - 1 > this.currentImageId) {
        this.currentImageId++;
        this.images[this.currentImageId].load();
    } else {
        this.loaded = true;
        this.dispatchEvent({
            type: 'loaded',
            content: this
        });
    }
};

/**
 * Invoke when error occured
 * @method onError
 * @private
 */
PIXI.AtlasLoader.prototype.onError = function () {
    this.dispatchEvent({
        type: 'error',
        content: this
    });
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The sprite sheet loader is used to load in JSON sprite sheet data
 * To generate the data you can use http://www.codeandweb.com/texturepacker and publish in the 'JSON' format
 * There is a free version so thats nice, although the paid version is great value for money.
 * It is highly recommended to use Sprite sheets (also know as a 'texture atlas') as it means sprites can be batched and drawn together for highly increased rendering speed.
 * Once the data has been loaded the frames are stored in the PIXI texture cache and can be accessed though PIXI.Texture.fromFrameId() and PIXI.Sprite.fromFrameId()
 * This loader will load the image file that the Spritesheet points to as well as the data.
 * When loaded this class will dispatch a 'loaded' event
 *
 * @class SpriteSheetLoader
 * @uses EventTarget
 * @constructor
 * @param url {String} The url of the sprite sheet JSON file
 * @param crossorigin {Boolean} Whether requests should be treated as crossorigin
 */
PIXI.SpriteSheetLoader = function (url, crossorigin) {
    /*
     * i use texture packer to load the assets..
     * http://www.codeandweb.com/texturepacker
     * make sure to set the format as 'JSON'
     */
    PIXI.EventTarget.call(this);

    /**
     * The url of the bitmap font data
     *
     * @property url
     * @type String
     */
    this.url = url;

    /**
     * Whether the requests should be treated as cross origin
     *
     * @property crossorigin
     * @type Boolean
     */
    this.crossorigin = crossorigin;

    /**
     * [read-only] The base url of the bitmap font data
     *
     * @property baseUrl
     * @type String
     * @readOnly
     */
    this.baseUrl = url.replace(/[^\/]*$/, '');

    /**
     * The texture being loaded
     *
     * @property texture
     * @type Texture
     */
    this.texture = null;

    /**
     * The frames of the sprite sheet
     *
     * @property frames
     * @type Object
     */
    this.frames = {};
};

// constructor
PIXI.SpriteSheetLoader.prototype.constructor = PIXI.SpriteSheetLoader;

/**
 * This will begin loading the JSON file
 *
 * @method load
 */
PIXI.SpriteSheetLoader.prototype.load = function () {
    var scope = this;
    var jsonLoader = new PIXI.JsonLoader(this.url, this.crossorigin);
    jsonLoader.addEventListener('loaded', function (event) {
        scope.json = event.content.json;
        scope.onLoaded();
    });
    jsonLoader.load();
};

/**
 * Invoke when all files are loaded (json and texture)
 *
 * @method onLoaded
 * @private
 */
PIXI.SpriteSheetLoader.prototype.onLoaded = function () {
    this.dispatchEvent({
        type: 'loaded',
        content: this
    });
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The image loader class is responsible for loading images file formats ('jpeg', 'jpg', 'png' and 'gif')
 * Once the image has been loaded it is stored in the PIXI texture cache and can be accessed though PIXI.Texture.fromFrameId() and PIXI.Sprite.fromFrameId()
 * When loaded this class will dispatch a 'loaded' event
 *
 * @class ImageLoader
 * @uses EventTarget
 * @constructor
 * @param url {String} The url of the image
 * @param crossorigin {Boolean} Whether requests should be treated as crossorigin
 */
PIXI.ImageLoader = function(url, crossorigin)
{
    PIXI.EventTarget.call(this);

    /**
     * The texture being loaded
     *
     * @property texture
     * @type Texture
     */
    this.texture = PIXI.Texture.fromImage(url, crossorigin);

    /**
     * if the image is loaded with loadFramedSpriteSheet
     * frames will contain the sprite sheet frames
     *
     */
    this.frames = [];
};

// constructor
PIXI.ImageLoader.prototype.constructor = PIXI.ImageLoader;

/**
 * Loads image or takes it from cache
 *
 * @method load
 */
PIXI.ImageLoader.prototype.load = function()
{
    if(!this.texture.baseTexture.hasLoaded)
    {
        var scope = this;
        this.texture.baseTexture.addEventListener('loaded', function()
        {
            scope.onLoaded();
        });
    }
    else
    {
        this.onLoaded();
    }
};

/**
 * Invoked when image file is loaded or it is already cached and ready to use
 *
 * @method onLoaded
 * @private
 */
PIXI.ImageLoader.prototype.onLoaded = function()
{
    this.dispatchEvent({type: 'loaded', content: this});
};

/**
 * Loads image and split it to uniform sized frames
 *
 *
 * @method loadFramedSpriteSheet
 * @param frameWidth {Number} width of each frame
 * @param frameHeight {Number} height of each frame
 * @param textureName {String} if given, the frames will be cached in <textureName>-<ord> format
 */
PIXI.ImageLoader.prototype.loadFramedSpriteSheet = function(frameWidth, frameHeight, textureName)
{
    this.frames = [];
    var cols = Math.floor(this.texture.width / frameWidth);
    var rows = Math.floor(this.texture.height / frameHeight);

    var i=0;
    for (var y=0; y<rows; y++)
    {
        for (var x=0; x<cols; x++,i++)
        {
            var texture = new PIXI.Texture(this.texture, {
                x: x*frameWidth,
                y: y*frameHeight,
                width: frameWidth,
                height: frameHeight
            });

            this.frames.push(texture);
            if (textureName) PIXI.TextureCache[textureName + '-' + i] = texture;
        }
    }

    if(!this.texture.baseTexture.hasLoaded)
    {
        var scope = this;
        this.texture.baseTexture.addEventListener('loaded', function() {
            scope.onLoaded();
        });
    }
    else
    {
        this.onLoaded();
    }
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The xml loader is used to load in XML bitmap font data ('xml' or 'fnt')
 * To generate the data you can use http://www.angelcode.com/products/bmfont/
 * This loader will also load the image file as the data.
 * When loaded this class will dispatch a 'loaded' event
 *
 * @class BitmapFontLoader
 * @uses EventTarget
 * @constructor
 * @param url {String} The url of the sprite sheet JSON file
 * @param crossorigin {Boolean} Whether requests should be treated as crossorigin
 */
PIXI.BitmapFontLoader = function(url, crossorigin)
{
    /*
     * I use texture packer to load the assets..
     * http://www.codeandweb.com/texturepacker
     * make sure to set the format as 'JSON'
     */
    PIXI.EventTarget.call(this);

    /**
     * The url of the bitmap font data
     *
     * @property url
     * @type String
     */
    this.url = url;

    /**
     * Whether the requests should be treated as cross origin
     *
     * @property crossorigin
     * @type Boolean
     */
    this.crossorigin = crossorigin;

    /**
     * [read-only] The base url of the bitmap font data
     *
     * @property baseUrl
     * @type String
     * @readOnly
     */
    this.baseUrl = url.replace(/[^\/]*$/, '');

    /**
     * [read-only] The texture of the bitmap font
     *
     * @property baseUrl
     * @type String
     */
    this.texture = null;
};

// constructor
PIXI.BitmapFontLoader.prototype.constructor = PIXI.BitmapFontLoader;

/**
 * Loads the XML font data
 *
 * @method load
 */
PIXI.BitmapFontLoader.prototype.load = function()
{
    this.ajaxRequest = new PIXI.AjaxRequest();
    var scope = this;
    this.ajaxRequest.onreadystatechange = function()
    {
        scope.onXMLLoaded();
    };

    this.ajaxRequest.open('GET', this.url, true);
    if (this.ajaxRequest.overrideMimeType) this.ajaxRequest.overrideMimeType('application/xml');
    this.ajaxRequest.send(null);
};

/**
 * Invoked when the XML file is loaded, parses the data
 *
 * @method onXMLLoaded
 * @private
 */
PIXI.BitmapFontLoader.prototype.onXMLLoaded = function()
{
    if (this.ajaxRequest.readyState === 4)
    {
        if (this.ajaxRequest.status === 200 || window.location.protocol.indexOf('http') === -1)
        {
            var responseXML = this.ajaxRequest.responseXML;
            if(!responseXML || /MSIE 9/i.test(navigator.userAgent) || navigator.isCocoonJS) {
                if(typeof(window.DOMParser) === 'function') {
                    var domparser = new DOMParser();
                    responseXML = domparser.parseFromString(this.ajaxRequest.responseText, 'text/xml');
                } else {
                    var div = document.createElement('div');
                    div.innerHTML = this.ajaxRequest.responseText;
                    responseXML = div;
                }
            }

            var textureUrl = this.baseUrl + responseXML.getElementsByTagName('page')[0].getAttribute('file');
            var image = new PIXI.ImageLoader(textureUrl, this.crossorigin);
            this.texture = image.texture.baseTexture;

            var data = {};
            var info = responseXML.getElementsByTagName('info')[0];
            var common = responseXML.getElementsByTagName('common')[0];
            data.font = info.getAttribute('face');
            data.size = parseInt(info.getAttribute('size'), 10);
            data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);
            data.chars = {};

            //parse letters
            var letters = responseXML.getElementsByTagName('char');

            for (var i = 0; i < letters.length; i++)
            {
                var charCode = parseInt(letters[i].getAttribute('id'), 10);

                var textureRect = new PIXI.Rectangle(
                    parseInt(letters[i].getAttribute('x'), 10),
                    parseInt(letters[i].getAttribute('y'), 10),
                    parseInt(letters[i].getAttribute('width'), 10),
                    parseInt(letters[i].getAttribute('height'), 10)
                );

                data.chars[charCode] = {
                    xOffset: parseInt(letters[i].getAttribute('xoffset'), 10),
                    yOffset: parseInt(letters[i].getAttribute('yoffset'), 10),
                    xAdvance: parseInt(letters[i].getAttribute('xadvance'), 10),
                    kerning: {},
                    texture: PIXI.TextureCache[charCode] = new PIXI.Texture(this.texture, textureRect)

                };
            }

            //parse kernings
            var kernings = responseXML.getElementsByTagName('kerning');
            for (i = 0; i < kernings.length; i++)
            {
                var first = parseInt(kernings[i].getAttribute('first'), 10);
                var second = parseInt(kernings[i].getAttribute('second'), 10);
                var amount = parseInt(kernings[i].getAttribute('amount'), 10);

                data.chars[second].kerning[first] = amount;

            }

            PIXI.BitmapText.fonts[data.font] = data;

            var scope = this;
            image.addEventListener('loaded', function() {
                scope.onLoaded();
            });
            image.load();
        }
    }
};

/**
 * Invoked when all files are loaded (xml/fnt and texture)
 *
 * @method onLoaded
 * @private
 */
PIXI.BitmapFontLoader.prototype.onLoaded = function()
{
    this.dispatchEvent({type: 'loaded', content: this});
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 * based on pixi impact spine implementation made by Eemeli Kelokorpi (@ekelokorpi) https://github.com/ekelokorpi
 *
 * Awesome JS run time provided by EsotericSoftware
 * https://github.com/EsotericSoftware/spine-runtimes
 *
 */

/**
 * The Spine loader is used to load in JSON spine data
 * To generate the data you need to use http://esotericsoftware.com/ and export in the "JSON" format
 * Due to a clash of names  You will need to change the extension of the spine file from *.json to *.anim for it to load
 * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source
 * You will need to generate a sprite sheet to accompany the spine data
 * When loaded this class will dispatch a "loaded" event
 *
 * @class Spine
 * @uses EventTarget
 * @constructor
 * @param url {String} The url of the JSON file
 * @param crossorigin {Boolean} Whether requests should be treated as crossorigin
 */
PIXI.SpineLoader = function(url, crossorigin)
{
    PIXI.EventTarget.call(this);

    /**
     * The url of the bitmap font data
     *
     * @property url
     * @type String
     */
    this.url = url;

    /**
     * Whether the requests should be treated as cross origin
     *
     * @property crossorigin
     * @type Boolean
     */
    this.crossorigin = crossorigin;

    /**
     * [read-only] Whether the data has loaded yet
     *
     * @property loaded
     * @type Boolean
     * @readOnly
     */
    this.loaded = false;
};

PIXI.SpineLoader.prototype.constructor = PIXI.SpineLoader;

/**
 * Loads the JSON data
 *
 * @method load
 */
PIXI.SpineLoader.prototype.load = function () {

    var scope = this;
    var jsonLoader = new PIXI.JsonLoader(this.url, this.crossorigin);
    jsonLoader.addEventListener("loaded", function (event) {
        scope.json = event.content.json;
        scope.onLoaded();
    });
    jsonLoader.load();
};

/**
 * Invoke when JSON file is loaded
 *
 * @method onLoaded
 * @private
 */
PIXI.SpineLoader.prototype.onLoaded = function () {
    this.loaded = true;
    this.dispatchEvent({type: "loaded", content: this});
};


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * This is the base class for creating a pixi.js filter. Currently only webGL supports filters.
 * If you want to make a custom filter this should be your base class.
 * @class AbstractFilter
 * @constructor
 * @param fragmentSrc
 * @param uniforms
 */
PIXI.AbstractFilter = function(fragmentSrc, uniforms)
{
    /**
    * An array of passes - some filters contain a few steps this array simply stores the steps in a liniear fashion.
    * For example the blur filter has two passes blurX and blurY.
    * @property passes
    * @type Array an array of filter objects
    * @private
    */
    this.passes = [this];

    /**
    * @property shaders
    * @type Array an array of shaders
    * @private
    */
    this.shaders = [];
    
    this.dirty = true;
    this.padding = 0;

    /**
    * @property uniforms
    * @type object
    * @private
    */
    this.uniforms = uniforms || {};
    /**
    * @property fragmentSrc
    * @type Array
    * @private
    */
    this.fragmentSrc = fragmentSrc || [];
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * The AlphaMaskFilter class uses the pixel values from the specified texture (called the displacement map) to perform a displacement of an object.
 * You can use this filter to apply all manor of crazy warping effects
 * Currently the r property of the texture is used to offset the x and the g propery of the texture is used to offset the y.
 * @class AlphaMaskFilter
 * @contructor
 * @param texture {Texture} The texture used for the displacemtent map * must be power of 2 texture at the moment
 */
PIXI.AlphaMaskFilter = function(texture)
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];
    texture.baseTexture._powerOf2 = true;

    // set the uniforms
    this.uniforms = {
        mask: {type: 'sampler2D', value:texture},
        mapDimensions:   {type: '2f', value:{x:1, y:5112}},
        dimensions:   {type: '4fv', value:[0,0,0,0]}
    };

    if(texture.baseTexture.hasLoaded)
    {
        this.uniforms.mask.value.x = texture.width;
        this.uniforms.mask.value.y = texture.height;
    }
    else
    {
        this.boundLoadedFunction = this.onTextureLoaded.bind(this);

        texture.baseTexture.on('loaded', this.boundLoadedFunction);
    }

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform sampler2D mask;',
        'uniform sampler2D uSampler;',
        'uniform vec2 offset;',
        'uniform vec4 dimensions;',
        'uniform vec2 mapDimensions;',

        'void main(void) {',
        '   vec2 mapCords = vTextureCoord.xy;',
        '   mapCords += (dimensions.zw + offset)/ dimensions.xy ;',
        '   mapCords.y *= -1.0;',
        '   mapCords.y += 1.0;',
        '   mapCords *= dimensions.xy / mapDimensions;',

        '   vec4 original =  texture2D(uSampler, vTextureCoord);',
        '   float maskAlpha =  texture2D(mask, mapCords).r;',
        '   original *= maskAlpha;',
        //'   original.rgb *= maskAlpha;',
        '   gl_FragColor =  original;',
        //'   gl_FragColor = gl_FragColor;',
        '}'
    ];
};

PIXI.AlphaMaskFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.AlphaMaskFilter.prototype.constructor = PIXI.AlphaMaskFilter;

PIXI.AlphaMaskFilter.prototype.onTextureLoaded = function()
{
    this.uniforms.mapDimensions.value.x = this.uniforms.mask.value.width;
    this.uniforms.mapDimensions.value.y = this.uniforms.mask.value.height;

    this.uniforms.mask.value.baseTexture.off('loaded', this.boundLoadedFunction);
};

/**
 * The texture used for the displacemtent map * must be power of 2 texture at the moment
 *
 * @property map
 * @type Texture
 */
Object.defineProperty(PIXI.AlphaMaskFilter.prototype, 'map', {
    get: function() {
        return this.uniforms.mask.value;
    },
    set: function(value) {
        this.uniforms.mask.value = value;
    }
});


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * The ColorMatrixFilter class lets you apply a 4x4 matrix transformation on the RGBA
 * color and alpha values of every pixel on your displayObject to produce a result
 * with a new set of RGBA color and alpha values. Its pretty powerful!
 * @class ColorMatrixFilter
 * @contructor
 */
PIXI.ColorMatrixFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        matrix: {type: 'mat4', value: [1,0,0,0,
                                       0,1,0,0,
                                       0,0,1,0,
                                       0,0,0,1]}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform float invert;',
        'uniform mat4 matrix;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '   gl_FragColor = texture2D(uSampler, vTextureCoord) * matrix;',
      //  '   gl_FragColor = gl_FragColor;',
        '}'
    ];
};

PIXI.ColorMatrixFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.ColorMatrixFilter.prototype.constructor = PIXI.ColorMatrixFilter;

/**
 * Sets the matrix of the color matrix filter
 *
 * @property matrix
 * @type Array and array of 26 numbers
 * @default [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]
 */
Object.defineProperty(PIXI.ColorMatrixFilter.prototype, 'matrix', {
    get: function() {
        return this.uniforms.matrix.value;
    },
    set: function(value) {
        this.uniforms.matrix.value = value;
    }
});
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * This turns your displayObjects to black and white.
 * @class GrayFilter
 * @contructor
 */
PIXI.GrayFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        gray: {type: '1f', value: 1}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform sampler2D uSampler;',
        'uniform float gray;',

        'void main(void) {',
        '   gl_FragColor = texture2D(uSampler, vTextureCoord);',
        '   gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.2126*gl_FragColor.r + 0.7152*gl_FragColor.g + 0.0722*gl_FragColor.b), gray);',
     //   '   gl_FragColor = gl_FragColor;',
        '}'
    ];
};

PIXI.GrayFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.GrayFilter.prototype.constructor = PIXI.GrayFilter;

/**
The strength of the gray. 1 will make the object black and white, 0 will make the object its normal color
@property gray
*/
Object.defineProperty(PIXI.GrayFilter.prototype, 'gray', {
    get: function() {
        return this.uniforms.gray.value;
    },
    set: function(value) {
        this.uniforms.gray.value = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * The DisplacementFilter class uses the pixel values from the specified texture (called the displacement map) to perform a displacement of an object.
 * You can use this filter to apply all manor of crazy warping effects
 * Currently the r property of the texture is used offset the x and the g propery of the texture is used to offset the y.
 * @class DisplacementFilter
 * @contructor
 * @param texture {Texture} The texture used for the displacemtent map * must be power of 2 texture at the moment
 */
PIXI.DisplacementFilter = function(texture)
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];
    texture.baseTexture._powerOf2 = true;

    // set the uniforms
    this.uniforms = {
        displacementMap: {type: 'sampler2D', value:texture},
        scale:           {type: '2f', value:{x:30, y:30}},
        offset:          {type: '2f', value:{x:0, y:0}},
        mapDimensions:   {type: '2f', value:{x:1, y:5112}},
        dimensions:   {type: '4fv', value:[0,0,0,0]}
    };

    if(texture.baseTexture.hasLoaded)
    {
        this.uniforms.mapDimensions.value.x = texture.width;
        this.uniforms.mapDimensions.value.y = texture.height;
    }
    else
    {
        this.boundLoadedFunction = this.onTextureLoaded.bind(this);

        texture.baseTexture.on('loaded', this.boundLoadedFunction);
    }

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform sampler2D displacementMap;',
        'uniform sampler2D uSampler;',
        'uniform vec2 scale;',
        'uniform vec2 offset;',
        'uniform vec4 dimensions;',
        'uniform vec2 mapDimensions;',// = vec2(256.0, 256.0);',
        // 'const vec2 textureDimensions = vec2(750.0, 750.0);',

        'void main(void) {',
        '   vec2 mapCords = vTextureCoord.xy;',
        //'   mapCords -= ;',
        '   mapCords += (dimensions.zw + offset)/ dimensions.xy ;',
        '   mapCords.y *= -1.0;',
        '   mapCords.y += 1.0;',
        '   vec2 matSample = texture2D(displacementMap, mapCords).xy;',
        '   matSample -= 0.5;',
        '   matSample *= scale;',
        '   matSample /= mapDimensions;',
        '   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x + matSample.x, vTextureCoord.y + matSample.y));',
        '   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb, 1.0);',
        '   vec2 cord = vTextureCoord;',

        //'   gl_FragColor =  texture2D(displacementMap, cord);',
     //   '   gl_FragColor = gl_FragColor;',
        '}'
    ];
};

PIXI.DisplacementFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.DisplacementFilter.prototype.constructor = PIXI.DisplacementFilter;

PIXI.DisplacementFilter.prototype.onTextureLoaded = function()
{
    this.uniforms.mapDimensions.value.x = this.uniforms.displacementMap.value.width;
    this.uniforms.mapDimensions.value.y = this.uniforms.displacementMap.value.height;

    this.uniforms.displacementMap.value.baseTexture.off('loaded', this.boundLoadedFunction);
};

/**
 * The texture used for the displacemtent map * must be power of 2 texture at the moment
 *
 * @property map
 * @type Texture
 */
Object.defineProperty(PIXI.DisplacementFilter.prototype, 'map', {
    get: function() {
        return this.uniforms.displacementMap.value;
    },
    set: function(value) {
        this.uniforms.displacementMap.value = value;
    }
});

/**
 * The multiplier used to scale the displacement result from the map calculation.
 *
 * @property scale
 * @type Point
 */
Object.defineProperty(PIXI.DisplacementFilter.prototype, 'scale', {
    get: function() {
        return this.uniforms.scale.value;
    },
    set: function(value) {
        this.uniforms.scale.value = value;
    }
});

/**
 * The offset used to move the displacement map.
 *
 * @property offset
 * @type Point
 */
Object.defineProperty(PIXI.DisplacementFilter.prototype, 'offset', {
    get: function() {
        return this.uniforms.offset.value;
    },
    set: function(value) {
        this.uniforms.offset.value = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * This filter applies a pixelate effect making display objects appear 'blocky'
 * @class PixelateFilter
 * @contructor
 */
PIXI.PixelateFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        invert: {type: '1f', value: 0},
        dimensions: {type: '4fv', value:new Float32Array([10000, 100, 10, 10])},
        pixelSize: {type: '2f', value:{x:10, y:10}}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform vec2 testDim;',
        'uniform vec4 dimensions;',
        'uniform vec2 pixelSize;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '   vec2 coord = vTextureCoord;',

        '   vec2 size = dimensions.xy/pixelSize;',

        '   vec2 color = floor( ( vTextureCoord * size ) ) / size + pixelSize/dimensions.xy * 0.5;',
        '   gl_FragColor = texture2D(uSampler, color);',
        '}'
    ];
};

PIXI.PixelateFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.PixelateFilter.prototype.constructor = PIXI.PixelateFilter;

/**
 *
 * This a point that describes the size of the blocs. x is the width of the block and y is the the height
 * @property size
 * @type Point
 */
Object.defineProperty(PIXI.PixelateFilter.prototype, 'size', {
    get: function() {
        return this.uniforms.pixelSize.value;
    },
    set: function(value) {
        this.dirty = true;
        this.uniforms.pixelSize.value = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

PIXI.BlurXFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        blur: {type: '1f', value: 1/512}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform float blur;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '   vec4 sum = vec4(0.0);',

        '   sum += texture2D(uSampler, vec2(vTextureCoord.x - 4.0*blur, vTextureCoord.y)) * 0.05;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x - 3.0*blur, vTextureCoord.y)) * 0.09;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x - 2.0*blur, vTextureCoord.y)) * 0.12;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x - blur, vTextureCoord.y)) * 0.15;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x + blur, vTextureCoord.y)) * 0.15;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x + 2.0*blur, vTextureCoord.y)) * 0.12;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x + 3.0*blur, vTextureCoord.y)) * 0.09;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x + 4.0*blur, vTextureCoord.y)) * 0.05;',

        '   gl_FragColor = sum;',
        '}'
    ];
};

PIXI.BlurXFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.BlurXFilter.prototype.constructor = PIXI.BlurXFilter;

Object.defineProperty(PIXI.BlurXFilter.prototype, 'blur', {
    get: function() {
        return this.uniforms.blur.value / (1/7000);
    },
    set: function(value) {

        this.dirty = true;
        this.uniforms.blur.value = (1/7000) * value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

PIXI.BlurYFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        blur: {type: '1f', value: 1/512}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform float blur;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '   vec4 sum = vec4(0.0);',

        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 4.0*blur)) * 0.05;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 3.0*blur)) * 0.09;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 2.0*blur)) * 0.12;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - blur)) * 0.15;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + blur)) * 0.15;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 2.0*blur)) * 0.12;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 3.0*blur)) * 0.09;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 4.0*blur)) * 0.05;',

        '   gl_FragColor = sum;',
        '}'
    ];
};

PIXI.BlurYFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.BlurYFilter.prototype.constructor = PIXI.BlurYFilter;

Object.defineProperty(PIXI.BlurYFilter.prototype, 'blur', {
    get: function() {
        return this.uniforms.blur.value / (1/7000);
    },
    set: function(value) {
        //this.padding = value;
        this.uniforms.blur.value = (1/7000) * value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * The BlurFilter applies a Gaussian blur to an object.
 * The strength of the blur can be set for x- and y-axis separately (always relative to the stage).
 *
 * @class BlurFilter
 * @contructor
 */
PIXI.BlurFilter = function()
{
    this.blurXFilter = new PIXI.BlurXFilter();
    this.blurYFilter = new PIXI.BlurYFilter();

    this.passes =[this.blurXFilter, this.blurYFilter];
};

/**
 * Sets the strength of both the blurX and blurY properties simultaneously
 *
 * @property blur
 * @type Number the strength of the blur
 * @default 2
 */
Object.defineProperty(PIXI.BlurFilter.prototype, 'blur', {
    get: function() {
        return this.blurXFilter.blur;
    },
    set: function(value) {
        this.blurXFilter.blur = this.blurYFilter.blur = value;
    }
});

/**
 * Sets the strength of the blurX property
 *
 * @property blurX
 * @type Number the strength of the blurX
 * @default 2
 */
Object.defineProperty(PIXI.BlurFilter.prototype, 'blurX', {
    get: function() {
        return this.blurXFilter.blur;
    },
    set: function(value) {
        this.blurXFilter.blur = value;
    }
});

/**
 * Sets the strength of the blurX property
 *
 * @property blurY
 * @type Number the strength of the blurY
 * @default 2
 */
Object.defineProperty(PIXI.BlurFilter.prototype, 'blurY', {
    get: function() {
        return this.blurYFilter.blur;
    },
    set: function(value) {
        this.blurYFilter.blur = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * This inverts your displayObjects colors.
 * @class InvertFilter
 * @contructor
 */
PIXI.InvertFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        invert: {type: '1f', value: 1}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform float invert;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '   gl_FragColor = texture2D(uSampler, vTextureCoord);',
        '   gl_FragColor.rgb = mix( (vec3(1)-gl_FragColor.rgb) * gl_FragColor.a, gl_FragColor.rgb, 1.0 - invert);',
        //'   gl_FragColor.rgb = gl_FragColor.rgb  * gl_FragColor.a;',
      //  '   gl_FragColor = gl_FragColor * vColor;',
        '}'
    ];
};

PIXI.InvertFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.InvertFilter.prototype.constructor = PIXI.InvertFilter;

/**
The strength of the invert. 1 will fully invert the colors, 0 will make the object its normal color
@property invert
*/
Object.defineProperty(PIXI.InvertFilter.prototype, 'invert', {
    get: function() {
        return this.uniforms.invert.value;
    },
    set: function(value) {
        this.uniforms.invert.value = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * This applies a sepia effect to your displayObjects.
 * @class SepiaFilter
 * @contructor
 */
PIXI.SepiaFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        sepia: {type: '1f', value: 1}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform float sepia;',
        'uniform sampler2D uSampler;',

        'const mat3 sepiaMatrix = mat3(0.3588, 0.7044, 0.1368, 0.2990, 0.5870, 0.1140, 0.2392, 0.4696, 0.0912);',

        'void main(void) {',
        '   gl_FragColor = texture2D(uSampler, vTextureCoord);',
        '   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb * sepiaMatrix, sepia);',
       // '   gl_FragColor = gl_FragColor * vColor;',
        '}'
    ];
};

PIXI.SepiaFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.SepiaFilter.prototype.constructor = PIXI.SepiaFilter;

/**
The strength of the sepia. 1 will apply the full sepia effect, 0 will make the object its normal color
@property sepia
*/
Object.defineProperty(PIXI.SepiaFilter.prototype, 'sepia', {
    get: function() {
        return this.uniforms.sepia.value;
    },
    set: function(value) {
        this.uniforms.sepia.value = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * This filter applies a twist effect making display objects appear twisted in the given direction
 * @class TwistFilter
 * @contructor
 */
PIXI.TwistFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        radius: {type: '1f', value:0.5},
        angle: {type: '1f', value:5},
        offset: {type: '2f', value:{x:0.5, y:0.5}}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform vec4 dimensions;',
        'uniform sampler2D uSampler;',

        'uniform float radius;',
        'uniform float angle;',
        'uniform vec2 offset;',

        'void main(void) {',
        '   vec2 coord = vTextureCoord - offset;',
        '   float distance = length(coord);',

        '   if (distance < radius) {',
        '       float ratio = (radius - distance) / radius;',
        '       float angleMod = ratio * ratio * angle;',
        '       float s = sin(angleMod);',
        '       float c = cos(angleMod);',
        '       coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);',
        '   }',

        '   gl_FragColor = texture2D(uSampler, coord+offset);',
        '}'
    ];
};

PIXI.TwistFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.TwistFilter.prototype.constructor = PIXI.TwistFilter;

/**
 *
 * This point describes the the offset of the twist
 * @property size
 * @type Point
 */
Object.defineProperty(PIXI.TwistFilter.prototype, 'offset', {
    get: function() {
        return this.uniforms.offset.value;
    },
    set: function(value) {
        this.dirty = true;
        this.uniforms.offset.value = value;
    }
});

/**
 *
 * This radius describes size of the twist
 * @property size
 * @type Number
 */
Object.defineProperty(PIXI.TwistFilter.prototype, 'radius', {
    get: function() {
        return this.uniforms.radius.value;
    },
    set: function(value) {
        this.dirty = true;
        this.uniforms.radius.value = value;
    }
});

/**
 *
 * This radius describes angle of the twist
 * @property angle
 * @type Number
 */
Object.defineProperty(PIXI.TwistFilter.prototype, 'angle', {
    get: function() {
        return this.uniforms.angle.value;
    },
    set: function(value) {
        this.dirty = true;
        this.uniforms.angle.value = value;
    }
});
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * This lowers the color depth of your image by the given amount, producing an image with a smaller palette.
 * @class ColorStepFilter
 * @contructor
 */
PIXI.ColorStepFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        step: {type: '1f', value: 5}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform sampler2D uSampler;',
        'uniform float step;',

        'void main(void) {',
        '   vec4 color = texture2D(uSampler, vTextureCoord);',
        '   color = floor(color * step) / step;',
        '   gl_FragColor = color;',
        '}'
    ];
};

PIXI.ColorStepFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.ColorStepFilter.prototype.constructor = PIXI.ColorStepFilter;

/**
The number of steps.
@property step
*/
Object.defineProperty(PIXI.ColorStepFilter.prototype, 'step', {
    get: function() {
        return this.uniforms.step.value;
    },
    set: function(value) {
        this.uniforms.step.value = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 * original filter: https://github.com/evanw/glfx.js/blob/master/src/filters/fun/dotscreen.js
 */

/**
 *
 * This filter applies a dotscreen effect making display objects appear to be made out of black and white halftone dots like an old printer
 * @class DotScreenFilter
 * @contructor
 */
PIXI.DotScreenFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        scale: {type: '1f', value:1},
        angle: {type: '1f', value:5},
        dimensions:   {type: '4fv', value:[0,0,0,0]}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform vec4 dimensions;',
        'uniform sampler2D uSampler;',

        'uniform float angle;',
        'uniform float scale;',

        'float pattern() {',
        '   float s = sin(angle), c = cos(angle);',
        '   vec2 tex = vTextureCoord * dimensions.xy;',
        '   vec2 point = vec2(',
        '       c * tex.x - s * tex.y,',
        '       s * tex.x + c * tex.y',
        '   ) * scale;',
        '   return (sin(point.x) * sin(point.y)) * 4.0;',
        '}',

        'void main() {',
        '   vec4 color = texture2D(uSampler, vTextureCoord);',
        '   float average = (color.r + color.g + color.b) / 3.0;',
        '   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);',
        '}'
    ];
};

PIXI.DotScreenFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.DotScreenFilter.prototype.constructor = PIXI.DotScreenFilter;

/**
 *
 * This describes the the scale
 * @property scale
 * @type Number
 */
Object.defineProperty(PIXI.DotScreenFilter.prototype, 'scale', {
    get: function() {
        return this.uniforms.scale.value;
    },
    set: function(value) {
        this.dirty = true;
        this.uniforms.scale.value = value;
    }
});

/**
 *
 * This radius describes angle
 * @property angle
 * @type Number
 */
Object.defineProperty(PIXI.DotScreenFilter.prototype, 'angle', {
    get: function() {
        return this.uniforms.angle.value;
    },
    set: function(value) {
        this.dirty = true;
        this.uniforms.angle.value = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

PIXI.CrossHatchFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        blur: {type: '1f', value: 1 / 512}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform float blur;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);',

        '    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);',

        '    if (lum < 1.00) {',
        '        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {',
        '            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',
        '        }',
        '    }',

        '    if (lum < 0.75) {',
        '        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {',
        '            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',
        '        }',
        '    }',

        '    if (lum < 0.50) {',
        '        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {',
        '            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',
        '        }',
        '    }',

        '    if (lum < 0.3) {',
        '        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {',
        '            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',
        '        }',
        '    }',
        '}'
    ];
};

PIXI.CrossHatchFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.CrossHatchFilter.prototype.constructor = PIXI.BlurYFilter;

Object.defineProperty(PIXI.CrossHatchFilter.prototype, 'blur', {
    get: function() {
        return this.uniforms.blur.value / (1/7000);
    },
    set: function(value) {
        //this.padding = value;
        this.uniforms.blur.value = (1/7000) * value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

PIXI.RGBSplitFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        red: {type: '2f', value: {x:20, y:20}},
        green: {type: '2f', value: {x:-20, y:20}},
        blue: {type: '2f', value: {x:20, y:-20}},
        dimensions:   {type: '4fv', value:[0,0,0,0]}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform vec2 red;',
        'uniform vec2 green;',
        'uniform vec2 blue;',
        'uniform vec4 dimensions;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/dimensions.xy).r;',
        '   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/dimensions.xy).g;',
        '   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/dimensions.xy).b;',
        '   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;',
        '}'
    ];
};

PIXI.RGBSplitFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.RGBSplitFilter.prototype.constructor = PIXI.RGBSplitFilter;

Object.defineProperty(PIXI.RGBSplitFilter.prototype, 'angle', {
    get: function() {
        return this.uniforms.blur.value / (1/7000);
    },
    set: function(value) {
        //this.padding = value;
        this.uniforms.blur.value = (1/7000) * value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

    if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = PIXI;
        }
        exports.PIXI = PIXI;
    } else if (typeof define !== 'undefined' && define.amd) {
        define(PIXI);
    } else {
        root.PIXI = PIXI;
    }
}).call(this);
},{}],"pixiapp":[function(require,module,exports){
(function() {

var PIXI;

if (typeof module !== 'undefined') {
	PIXI = require("pixi.js");
} else {
	PIXI = window.PIXI;
}
/**
 * AS3/jquery style event dispatcher. Slightly modified. The
 * jquery style on/off/trigger style of adding listeners is
 * currently the preferred one.
 *
 * The on method for adding listeners takes an extra parameter which is the
 * scope in which listeners should be called. So this:
 *
 *     object.on("event", listener, this);
 *
 * Has the same function when adding events as:
 *
 *     object.on("event", listener.bind(this));
 *
 * However, the difference is that if we use the second method it
 * will not be possible to remove the listeners later, unless
 * the closure created by bind is stored somewhere. If the
 * first method is used, we can remove the listener with:
 *
 *     object.off("event", listener, this);
 *
 * @class EventDispatcher
 * @internal
 */
function EventDispatcher() {
	this.listenerMap = {};
}

/**
 * Add event listener.
 * @method addEventListener
 */
EventDispatcher.prototype.addEventListener = function(eventType, listener, scope) {
	if (!this.listenerMap)
		this.listenerMap = {};

	if (!eventType)
		throw new Error("Event type required for event dispatcher");

	if (!listener)
		throw new Error("Listener required for event dispatcher");

	this.removeEventListener(eventType, listener, scope);

	if (!this.listenerMap.hasOwnProperty(eventType))
		this.listenerMap[eventType] = [];

	this.listenerMap[eventType].push({
		listener: listener,
		scope: scope
	});
}

/**
 * Remove event listener.
 * @method removeEventListener
 */
EventDispatcher.prototype.removeEventListener = function(eventType, listener, scope) {
	if (!this.listenerMap)
		this.listenerMap = {};

	if (!this.listenerMap.hasOwnProperty(eventType))
		return;

	var listeners = this.listenerMap[eventType];

	for (var i = 0; i < listeners.length; i++) {
		var listenerObj = listeners[i];

		if (listener == listenerObj.listener && scope == listenerObj.scope) {
			listeners.splice(i, 1);
			i--;
		}
	}

	if (!listeners.length)
		delete this.listenerMap[eventType];
}

/**
 * Dispatch event.
 * @method dispatchEvent
 */
EventDispatcher.prototype.dispatchEvent = function(event /* ... */ ) {
	if (!this.listenerMap)
		this.listenerMap = {};

	var eventType;
	var listenerParams;

	if (typeof event == "string") {
		eventType = event;
		listenerParams = Array.prototype.slice.call(arguments, 1);
	} else {
		eventType = event.type;
		event.target = this;
		listenerParams = [event];
	}

	if (!this.listenerMap.hasOwnProperty(eventType))
		return;

	for (var i in this.listenerMap[eventType]) {
		var listenerObj = this.listenerMap[eventType][i];
		listenerObj.listener.apply(listenerObj.scope, listenerParams);
	}
}

/**
 * Jquery style alias for addEventListener
 * @method on
 */
EventDispatcher.prototype.on = EventDispatcher.prototype.addEventListener;

/**
 * Jquery style alias for removeEventListener
 * @method off
 */
EventDispatcher.prototype.off = EventDispatcher.prototype.removeEventListener;

/**
 * Jquery style alias for dispatchEvent
 * @method trigger
 */
EventDispatcher.prototype.trigger = EventDispatcher.prototype.dispatchEvent;

/**
 * Make something an event dispatcher. Can be used for multiple inheritance.
 * @method init
 * @static
 */
EventDispatcher.init = function(cls) {
	cls.prototype.addEventListener = EventDispatcher.prototype.addEventListener;
	cls.prototype.removeEventListener = EventDispatcher.prototype.removeEventListener;
	cls.prototype.dispatchEvent = EventDispatcher.prototype.dispatchEvent;
	cls.prototype.on = EventDispatcher.prototype.on;
	cls.prototype.off = EventDispatcher.prototype.off;
	cls.prototype.trigger = EventDispatcher.prototype.trigger;
}

if (typeof module !== 'undefined') {
	module.exports = EventDispatcher;
}

/**
 * Keep content with a logic size inside boundaries.
 * @class ContentScaler
 * @internal
 */
function ContentScaler(content) {
	PIXI.DisplayObjectContainer.call(this);

	this.contentWidth = 100;
	this.contentHeight = 100;

	this.screenWidth = 100;
	this.screenHeight = 100;

	this.theMask = null;

	if (content)
		this.setContent(content);

	this.verticalAlign = ContentScaler.MIDDLE;
	this.horizontalAlign = ContentScaler.CENTER;
	this.scaleMode = ContentScaler.SHOW_ALL;

	this.minScale = -1;
	this.maxScale = -1;

	this.maskContentEnabled = false;
	this.maskColor = 0x000000;
}

ContentScaler.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
ContentScaler.prototype.constructor = ContentScaler;

ContentScaler.TOP = "top";
ContentScaler.MIDDLE = "middle";
ContentScaler.BOTTOM = "bottom";

ContentScaler.LEFT = "left";
ContentScaler.CENTER = "center";
ContentScaler.RIGHT = "right";

ContentScaler.NO_BORDER = "noBorder";
ContentScaler.NO_SCALE = "noScale";
ContentScaler.SHOW_ALL = "showAll";

/**
 * Should the content be masked?
 * @method setMaskContentEnabled
 */
ContentScaler.prototype.setMaskContentEnabled = function(value) {
	this.maskContentEnabled = value;
	this.updateScale();
}

/**
 * Set color of the mask.
 * @method setMaskColor
 */
ContentScaler.prototype.setMaskColor = function(value) {
	this.maskColor = value;
	this.updateScale();
}

/**
 * Set minimum value for scale.
 * @method setMinScale
 */
ContentScaler.prototype.setMinScale = function(minScale) {
	this.minScale = minScale;
	this.updateScale();
}

/**
 * Set maximum value for scale.
 * @method setMaxScale
 */
ContentScaler.prototype.setMaxScale = function(maxScale) {
	this.maxScale = maxScale;
	this.updateScale();
}

/**
 * Set content to use.
 * @method setContent
 */
ContentScaler.prototype.setContent = function(content) {
	if (this.content)
		throw new Error("Content already set.");

	this.content = content;
	this.addChild(this.content);

	if (this.theMask) {
		this.removeChild(this.theMask);
		this.theMask = null;
	}

	this.theMask = new PIXI.Graphics();
	this.addChild(this.theMask);

	this.updateScale();
}

/**
 * Set logic size of the content.
 * @method setContentSize
 */
ContentScaler.prototype.setContentSize = function(contentWidth, contentHeight) {
	this.contentWidth = contentWidth;
	this.contentHeight = contentHeight;
	this.updateScale();
}

/**
 * Set the actual screen size.
 * @method setScreenSize
 */
ContentScaler.prototype.setScreenSize = function(screenWidth, screenHeight) {
	this.screenWidth = screenWidth;
	this.screenHeight = screenHeight;
	this.updateScale();
}

/**
 * Set how the content should be aligned on the screen.
 * @method setVerticalAlign
 */
ContentScaler.prototype.setVerticalAlign = function(align) {
	this.verticalAlign = align;
	this.updateScale();
}

/**
 * Set how the content should be aligned on the screen.
 * @method setHorizontalAlign
 */
ContentScaler.prototype.setHorizontalAlign = function(align) {
	this.horizontalAlign = align;
	this.updateScale();
}

/**
 * Set scale mode.
 * @method setScaleMode
 */
ContentScaler.prototype.setScaleMode = function(scaleMode) {
	this.scaleMode = scaleMode;
	this.updateScale();
}

/**
 * Update the scaling.
 * @method updateScale
 * @private
 */
ContentScaler.prototype.updateScale = function() {
	var scale;

	if (this.scaleMode == ContentScaler.NO_SCALE) {
		scale = 1;
	} else if (this.scaleMode == ContentScaler.NO_BORDER) {
		if (this.screenWidth / this.contentWidth > this.screenHeight / this.contentHeight)
			scale = this.screenWidth / this.contentWidth;

		else
			scale = this.screenHeight / this.contentHeight;
	} else {
		if (this.screenWidth / this.contentWidth < this.screenHeight / this.contentHeight)
			scale = this.screenWidth / this.contentWidth;

		else
			scale = this.screenHeight / this.contentHeight;
	}

	if (this.minScale > 0 && scale < this.minScale)
		scale = this.minScale;

	if (this.maxScale > 0 && scale > this.maxScale)
		scale = this.maxScale;

	this.content.scale.x = scale;
	this.content.scale.y = scale;

	var scaledWidth = this.contentWidth * scale;
	var scaledHeight = this.contentHeight * scale;

	this.content.position.x = (this.screenWidth - scaledWidth) / 2;

	if (this.verticalAlign == ContentScaler.TOP)
		this.content.position.y = 0;

	else if (this.verticalAlign == ContentScaler.BOTTOM)
		this.content.position.y = this.screenHeight - scaledHeight;

	else
		this.content.position.y = (this.screenHeight - scaledHeight) / 2;

	if (this.horizontalAlign == ContentScaler.LEFT)
		this.content.position.x = 0;

	else if (this.horizontalAlign == ContentScaler.RIGHT)
		this.content.position.x = this.screenWidth - scaledWidth;

	else
		this.content.position.x = (this.screenWidth - scaledWidth) / 2;

	var r = new PIXI.Rectangle(this.content.position.x, this.content.position.y, scaledWidth, scaledHeight);
	var right = r.x + r.width;
	var bottom = r.y + r.height;

	this.theMask.clear();

	if (this.maskContentEnabled) {
		this.theMask.beginFill(this.maskColor, 1);
		this.theMask.drawRect(0, 0, this.screenWidth, r.y);
		this.theMask.drawRect(0, 0, r.x, this.screenHeight);
		this.theMask.drawRect(right, 0, this.screenWidth - right, this.screenHeight);
		this.theMask.drawRect(0, bottom, this.screenWidth, this.screenHeight - bottom);
		this.theMask.endFill();
	}
}

/**
 * Get visible rectangle.
 * @method getVisibleRect
 */
ContentScaler.prototype.getVisibleRect = function() {
	var x = -this.content.position.x / this.content.scale.x;
	var y = -this.content.position.y / this.content.scale.y;

	var width = this.screenWidth / this.content.scale.x;
	var height = this.screenHeight / this.content.scale.y;
	// this.content.position, this.content.position, this.screenWidth, this.screenHeight

	return new PIXI.Rectangle(x, y, width, height);
}
/**
 * Manages the main loop and scaling of a PIXI application.
 * The intended way of using this class is to extend it, for example:
 *
 *     var PIXI = require("pixi.js");
 *     var PixiApp = require("PixiApp");
 *     var inherits = require("inherits");
 *
 *     function MyApp() {
 *         PixiApp.call(this);
 *
 *         var t = new PIXI.Text("Hello PIXI.js!");
 *         this.addChild(t);
 *     }
 *
 *     inherits(MyApp, PixiApp);
 *
 *     new MyApp();
 * @class PixiApp
 */
function PixiApp(width, height) {
	PIXI.DisplayObjectContainer.call(this);

	this._applicationWidth = width;
	this._applicationHeight = height;
	this._backgroundColor = 0xffffff;

	setTimeout(this.onCheckReadyTimeout.bind(this), 0);

	this.contentScaler = new ContentScaler(this);
}

PixiApp.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
PixiApp.prototype.constructor = PixiApp;

EventDispatcher.init(PixiApp);

/**
 * Dispatched if the app is resized.
 * @event resize
 */

/**
 * Dispatched every frame before rendering.
 * The time is send to the listening function as parameter.
 * @event frame
 */

PixiApp.TOP = ContentScaler.TOP;
PixiApp.MIDDLE = ContentScaler.MIDDLE;
PixiApp.BOTTOM = ContentScaler.BOTTOM;

PixiApp.LEFT = ContentScaler.LEFT;
PixiApp.CENTER = ContentScaler.CENTER;
PixiApp.RIGHT = ContentScaler.RIGHT;

PixiApp.NO_BORDER = ContentScaler.NO_BORDER;
PixiApp.NO_SCALE = ContentScaler.NO_SCALE;
PixiApp.SHOW_ALL = ContentScaler.SHOW_ALL;

/**
 * Check if it's time to attach ourselves.
 * @method onCheckReadyTimeout
 * @private
 */
PixiApp.prototype.onCheckReadyTimeout = function() {
	if (this.attachedToElement)
		return;

	if (!document.body) {
		setTimeout(this.onCheckReadyTimeout.bind(this), 0);
		return;
	}

	this.attachToElement(document.body);
}

/**
 * Attach to an element in the document.
 * If this function is not called, the app will be attached
 * to entire browser window.
 * @method attachToElement
 * @param element {DOMElement} The element to attach to.
 */
PixiApp.prototype.attachToElement = function(element) {
	if (this.attachedToElement)
		throw new Error("Already attached!");

	if (typeof element == "string")
		element = document.getElementById(element);

	if (!element)
		throw new Error("That's not an element!");

	//console.log("** attaching to element, w=" + element.clientWidth + " h=" + element.clientHeight);

	this.containerElement = element;
	this.attachedToElement = true;

	var view;

	if (navigator.isCocoonJS)
		view = document.createElement('screencanvas');

	else
		view = document.createElement('canvas');

	view.style.margin = 0;
	view.style.padding = 0;

	if (this.containerElement == document.body) {
		//console.log("style: " + document.documentElement.style.height);

		view.style.position = "fixed";

		document.body.style.margin = 0;
		document.body.style.padding = 0;
		document.body.style.overflow = "hidden";

		document.body.onresize = this.onWindowResize.bind(this);
		window.onresize = this.onWindowResize.bind(this);
	}

	this.renderer = new PIXI.autoDetectRenderer(this.getElementWidth(), this.getElementHeight(), view);
	this.containerElement.appendChild(this.renderer.view);

	this.stage = new PIXI.Stage(this._backgroundColor);

	this.updateContentScaler();
	this.stage.addChild(this.contentScaler);

	this.renderer.render(this.stage);
	this.sizeDirty = false;

	window.requestAnimationFrame(this.onAnimationFrame.bind(this));
	this.trigger("resize");

	//console.log("attached...");
}

/**
 * Update the content scaler.
 * @method updateContentScaler
 * @private
 */
PixiApp.prototype.updateContentScaler = function() {
	this.contentScaler.setContentSize(this._applicationWidth, this._applicationHeight);
	this.contentScaler.setScreenSize(this.getElementWidth(), this.getElementHeight());
}

/**
 * Animation frame. Render ourselfs.
 * @method onAnimationFrame
 * @private
 */
PixiApp.prototype.onAnimationFrame = function(time) {
	//console.log("render");

	if (this.sizeDirty) {
		this.updateContentScaler();
		this.renderer.resize(this.getElementWidth(), this.getElementHeight());
		this.sizeDirty = false;
	}

	this.trigger("frame", time);

	this.renderer.render(this.stage);
	//TWEEN.update(time);

	window.requestAnimationFrame(this.onAnimationFrame.bind(this));
}

/**
 * Handle window resize.
 * @method onWindowResize
 * @private
 */
PixiApp.prototype.onWindowResize = function() {
	this.sizeDirty = true;
	this.trigger("resize");
}

/**
 * Get height of the element that we are attached to.
 * @method getElementHeight
 * @private
 */
PixiApp.prototype.getElementHeight = function() {
	if (this.containerElement == document.body)
		return window.innerHeight;

	return this.containerElement.clientHeight;
}

/**
 * Get height of the element that we are attached to.
 * @method getElementWidth
 * @private
 */
PixiApp.prototype.getElementWidth = function() {
	if (this.containerElement == document.body)
		return window.innerWidth;

	return this.containerElement.clientWidth;
}

/**
 * The logic width of the application.
 * @property applicationWidth
 */
Object.defineProperty(PixiApp.prototype, 'applicationWidth', {
	get: function() {
		return this._applicationWidth;
	},
	set: function(value) {
		this._applicationWidth = value;
		this.sizeDirty = true;
	}
});

/**
 * The logic height of the application.
 * @property applicationHeight
 */
Object.defineProperty(PixiApp.prototype, 'applicationHeight', {
	get: function() {
		return this._applicationHeight;
	},
	set: function(value) {
		this._applicationHeight = value;
		this.sizeDirty = true;
	}
});

/**
 * How the application should be vertically aligned in the window.
 * @property verticalAlign
 */
Object.defineProperty(PixiApp.prototype, "verticalAlign", {
	get: function() {
		return this.contentScaler.verticalAlign;
	},
	set: function(value) {
		this.contentScaler.setVerticalAlign(value)
	}
});

/**
 * How the application should be horizontally aligned in the window.
 * @property horizontalAlign
 */
Object.defineProperty(PixiApp.prototype, "horizontalAlign", {
	get: function() {
		return this.contentScaler.horizontalAlign;
	},
	set: function(value) {
		this.contentScaler.setHorizontalAlign(value)
	}
});

/**
 * How should the application be scaled to fit the window?
 * Available vaues are:
 * <ul>
 *   <li>
 *     `PixiApp.SHOW_ALL` - Ensure that the whole application as defined by
 *     `applicationWidth` and `applicationHeight` is visible on the screen.
 *   </li>
 *   <li>
 *     `PixiApp.NO_BORDER` - Show as much as possible of the application,
 *     but scale it so that there will be no border.
 *   </li>
 *   <li>
 *     `PixiApp.NO_SCALE` - Don't scale the application at all.
 *   </li>
 * </ul>
 * @property scaleMode
 */
Object.defineProperty(PixiApp.prototype, "scaleMode", {
	get: function() {
		return this.contentScaler.scaleMode;
	},
	set: function(value) {
		this.contentScaler.setScaleMode(value)
	}
});

/**
 * Get or set the minimum allowed scale value.
 * @property minScale
 */
Object.defineProperty(PixiApp.prototype, "minScale", {
	get: function() {
		return this.contentScaler.minScale;
	},
	set: function(value) {
		this.contentScaler.setMinScale(value)
	}
});

/**
 * Get or set the maximum allowed scale value.
 * @property minScale
 */
Object.defineProperty(PixiApp.prototype, "maxScale", {
	get: function() {
		return this.contentScaler.maxScale;
	},
	set: function(value) {
		this.contentScaler.setMaxScale(value)
	}
});

/**
 * Should there be a letterbox matte around the content? I.e.
 * should the content outside the application area be masked
 * away?
 * @property matte
 */
Object.defineProperty(PixiApp.prototype, "matte", {
	get: function() {
		return this.contentScaler.maskContentEnabled
	},
	set: function(value) {
		this.contentScaler.setMaskContentEnabled(value);
	}
});

/**
 * The color of the letterbox matte. This has effect only if the 
 * letter box matte is enabled using the matte property.
 * @property matteColor
 */
Object.defineProperty(PixiApp.prototype, "matteColor", {
	get: function() {
		return this.contentScaler.maskColor;
	},
	set: function(value) {
		this.contentScaler.setMaskColor(value);
	}
});

/**
 * Gets the rectangle on the screen that is currently visible.
 * The rectangle is represented in application coordinates.
 * @property visibleRect
 */
Object.defineProperty(PixiApp.prototype, "visibleRect", {
	get: function() {
		if (this.sizeDirty) {
			this.updateContentScaler();
			this.renderer.resize(this.getElementWidth(), this.getElementHeight());
			this.sizeDirty = false;
		}

		return this.contentScaler.getVisibleRect();
	},
});

/**
 * The background color for the application.
 * Default is 0xffffff, i.e. white.
 * @property backgroundColor
 */
Object.defineProperty(PixiApp.prototype, "backgroundColor", {
	get: function() {
		return this._backgroundColor;
	},
	set: function(value) {
		this._backgroundColor = value;
		if (this.stage)
			this.stage.setBackgroundColor(this._backgroundColor);
	}
});
if (typeof module !== 'undefined') {
	module.exports = PixiApp;
} else {
	window.PixiApp = PixiApp;
}

}).call(this);
},{"pixi.js":"pixi.js"}],"tinp":[function(require,module,exports){
(function (process){
/**
 * A subset of Promises/A+.
 * @class Thenable
 */
function Thenable() {
	if (!(this instanceof Thenable))
		return new Thenable();

	this.decided = false;
	this.handlersUsed = false;
}

/**
 * Then.
 * @method resolve
 */
Thenable.prototype.then = function(resolutionHandler, rejectionHandler) {
	if (this.handlersUsed)
		throw new Error("Handlers already registered or called.");

	this.handlersUsed = true;
	this.resolutionHandler = resolutionHandler;
	this.rejectionHandler = rejectionHandler;
}

/**
 * Resolve.
 * @method resolve
 */
Thenable.prototype.resolve = function(result) {
	if (this.decided)
		throw new Error("Already decided.");

	this.decided = true;
	process.nextTick(this.callHandler.bind(this, true, result));
}

/**
 * Reject.
 * @method resolve
 */
Thenable.prototype.reject = function(reason) {
	if (this.decided)
		throw new Error("Already decided.");

	this.decided = true;
	process.nextTick(this.callHandler.bind(this, false, reason));
}

/**
 * Call handler.
 * @method callHandler
 * @private
 */
Thenable.prototype.callHandler = function(resolved, parameter) {
	this.handlersUsed = true;

	var handler;

	if (resolved)
		handler = this.resolutionHandler;

	else
		handler = this.rejectionHandler;

	//console.log("in callHandler, handler=" + handler);

	if (handler) {
		try {
			handler(parameter);
		} catch (e) {
			console.error("Unhandled: " + e);
			console.log(e.stack);
			throw e;
		}
	}
}

/**
 * Return a resolved thenable.
 * @method resolved
 */
Thenable.resolved = function(parameter) {
	var t = new Thenable();
	t.resolve(parameter);
	return t;
}

/**
 * Return a rejected thenable.
 * @method rejected
 */
Thenable.rejected = function(parameter) {
	var t = new Thenable();
	t.reject(parameter);
	return t;
}

/**
 * Wait for all to resolve or any to reject.
 * @method all
 */
Thenable.all = function( /* ... */ ) {
	var thenable = new Thenable();
	var i;
	var thenables = [];
	var decided = false;
	var resolvedCount = 0;

	for (i = 0; i < arguments.length; i++)
		thenables = thenables.concat(arguments[i]);

	function onResolved() {
		resolvedCount++;

		if (!decided && resolvedCount >= thenables.length) {
			decided = true;
			thenable.resolve();
		}
	}

	function onRejected(e) {
		if (!decided) {
			decided = true;
			thenable.reject(e);
		}
	}

	for (i = 0; i < thenables.length; i++) {
		thenables[i].then(onResolved, onRejected);
	}

	return thenable;
}

/**
 * Wait for any to resolve or all to reject.
 * @method all
 */
Thenable.race = function( /* ... */ ) {
	var thenable = new Thenable();
	var i;
	var thenables = [];
	var decided = false;
	var resolvedCount = 0;

	for (i = 0; i < arguments.length; i++)
		thenables = thenables.concat(arguments[i]);

	function onRejected() {
		resolvedCount++;

		if (!decided && resolvedCount >= thenables.length) {
			decided = true;
			thenable.reject();
		}
	}

	function onResolved(r) {
		if (!decided) {
			decided = true;
			thenable.resolve(r);
		}
	}

	for (i = 0; i < thenables.length; i++) {
		thenables[i].then(onResolved, onRejected);
	}

	return thenable;
}

/**
 * Create a resolved Thenable.
 * @method resolved
 */
Thenable.resolved = function(result) {
	var t = new Thenable;
	t.resolve(result);

	return t;
}

/**
 * Create a rejected Thenable.
 * @method rejected
 */
Thenable.rejected = function(reason) {
	var t = new Thenable;
	t.reject(reason);

	return t;
}

module.exports = Thenable;
}).call(this,require('_process'))

},{"_process":1}]},{},[])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwibm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGl0ZXh0aW5wdXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGl4aXRleHRpbnB1dC9zcmMvUGl4aVRleHRJbnB1dC5qcyIsIm5vZGVfbW9kdWxlcy90d2Vlbi5qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy95YWVkL3NyYy9FdmVudERpc3BhdGNoZXIuanMiLCJzcmMvY2xpZW50L2NvbnRyb2xsZXIvSW50ZXJmYWNlQ29udHJvbGxlci5qcyIsInNyYy9jbGllbnQvY29udHJvbGxlci9NZXNzYWdlU2VxdWVuY2VJdGVtLmpzIiwic3JjL2NsaWVudC9jb250cm9sbGVyL01lc3NhZ2VTZXF1ZW5jZXIuanMiLCJzcmMvY2xpZW50L2NvbnRyb2xsZXIvTmV0UG9rZXJDbGllbnRDb250cm9sbGVyLmpzIiwic3JjL2NsaWVudC9jb250cm9sbGVyL1RhYmxlQ29udHJvbGxlci5qcyIsInNyYy9jbGllbnQvcmVzb3VyY2VzL0RlZmF1bHRTa2luLmpzIiwic3JjL2NsaWVudC9yZXNvdXJjZXMvVmlld0NvbmZpZy5qcyIsInNyYy9jbGllbnQvdmlldy9CaWdCdXR0b24uanMiLCJzcmMvY2xpZW50L3ZpZXcvQnV0dG9uc1ZpZXcuanMiLCJzcmMvY2xpZW50L3ZpZXcvQ2FyZEZyb250Vmlldy5qcyIsInNyYy9jbGllbnQvdmlldy9DYXJkVmlldy5qcyIsInNyYy9jbGllbnQvdmlldy9DaGF0Vmlldy5qcyIsInNyYy9jbGllbnQvdmlldy9DaGlwc1ZpZXcuanMiLCJzcmMvY2xpZW50L3ZpZXcvRGVhbGVyQnV0dG9uVmlldy5qcyIsInNyYy9jbGllbnQvdmlldy9EaWFsb2dCdXR0b24uanMiLCJzcmMvY2xpZW50L3ZpZXcvRGlhbG9nVmlldy5qcyIsInNyYy9jbGllbnQvdmlldy9Mb2FkaW5nU2NyZWVuLmpzIiwic3JjL2NsaWVudC92aWV3L05ldFBva2VyQ2xpZW50Vmlldy5qcyIsInNyYy9jbGllbnQvdmlldy9Qb3RWaWV3LmpzIiwic3JjL2NsaWVudC92aWV3L1ByZXNldEJ1dHRvbi5qcyIsInNyYy9jbGllbnQvdmlldy9QcmVzZXRCdXR0b25zVmlldy5qcyIsInNyYy9jbGllbnQvdmlldy9SYWlzZVNob3J0Y3V0QnV0dG9uLmpzIiwic3JjL2NsaWVudC92aWV3L1NlYXRWaWV3LmpzIiwic3JjL2NsaWVudC92aWV3L1NldHRpbmdzQ2hlY2tib3guanMiLCJzcmMvY2xpZW50L3ZpZXcvU2V0dGluZ3NWaWV3LmpzIiwic3JjL2NsaWVudC92aWV3L1RhYmxlSW5mb1ZpZXcuanMiLCJzcmMvY2xpZW50L3ZpZXcvVGltZXJWaWV3LmpzIiwic3JjL3Byb3RvL1Byb3RvQ29ubmVjdGlvbi5qcyIsInNyYy9wcm90by9kYXRhL0J1dHRvbkRhdGEuanMiLCJzcmMvcHJvdG8vZGF0YS9DYXJkRGF0YS5qcyIsInNyYy9wcm90by9tZXNzYWdlcy9BY3Rpb25NZXNzYWdlLmpzIiwic3JjL3Byb3RvL21lc3NhZ2VzL0JldE1lc3NhZ2UuanMiLCJzcmMvcHJvdG8vbWVzc2FnZXMvQmV0c1RvUG90TWVzc2FnZS5qcyIsInNyYy9wcm90by9tZXNzYWdlcy9CdXR0b25DbGlja01lc3NhZ2UuanMiLCJzcmMvcHJvdG8vbWVzc2FnZXMvQnV0dG9uc01lc3NhZ2UuanMiLCJzcmMvcHJvdG8vbWVzc2FnZXMvQ2hhdE1lc3NhZ2UuanMiLCJzcmMvcHJvdG8vbWVzc2FnZXMvQ2hlY2tib3hNZXNzYWdlLmpzIiwic3JjL3Byb3RvL21lc3NhZ2VzL0NsZWFyTWVzc2FnZS5qcyIsInNyYy9wcm90by9tZXNzYWdlcy9Db21tdW5pdHlDYXJkc01lc3NhZ2UuanMiLCJzcmMvcHJvdG8vbWVzc2FnZXMvRGVhbGVyQnV0dG9uTWVzc2FnZS5qcyIsInNyYy9wcm90by9tZXNzYWdlcy9EZWxheU1lc3NhZ2UuanMiLCJzcmMvcHJvdG8vbWVzc2FnZXMvRmFkZVRhYmxlTWVzc2FnZS5qcyIsInNyYy9wcm90by9tZXNzYWdlcy9Gb2xkQ2FyZHNNZXNzYWdlLmpzIiwic3JjL3Byb3RvL21lc3NhZ2VzL0hhbmRJbmZvTWVzc2FnZS5qcyIsInNyYy9wcm90by9tZXNzYWdlcy9Jbml0TWVzc2FnZS5qcyIsInNyYy9wcm90by9tZXNzYWdlcy9JbnRlcmZhY2VTdGF0ZU1lc3NhZ2UuanMiLCJzcmMvcHJvdG8vbWVzc2FnZXMvUGF5T3V0TWVzc2FnZS5qcyIsInNyYy9wcm90by9tZXNzYWdlcy9Qb2NrZXRDYXJkc01lc3NhZ2UuanMiLCJzcmMvcHJvdG8vbWVzc2FnZXMvUG90TWVzc2FnZS5qcyIsInNyYy9wcm90by9tZXNzYWdlcy9QcmVUb3VybmFtZW50SW5mb01lc3NhZ2UuanMiLCJzcmMvcHJvdG8vbWVzc2FnZXMvUHJlc2V0QnV0dG9uQ2xpY2tNZXNzYWdlLmpzIiwic3JjL3Byb3RvL21lc3NhZ2VzL1ByZXNldEJ1dHRvbnNNZXNzYWdlLmpzIiwic3JjL3Byb3RvL21lc3NhZ2VzL1NlYXRDbGlja01lc3NhZ2UuanMiLCJzcmMvcHJvdG8vbWVzc2FnZXMvU2VhdEluZm9NZXNzYWdlLmpzIiwic3JjL3Byb3RvL21lc3NhZ2VzL1Nob3dEaWFsb2dNZXNzYWdlLmpzIiwic3JjL3Byb3RvL21lc3NhZ2VzL1N0YXRlQ29tcGxldGVNZXNzYWdlLmpzIiwic3JjL3Byb3RvL21lc3NhZ2VzL1RhYmxlQnV0dG9uQ2xpY2tNZXNzYWdlLmpzIiwic3JjL3Byb3RvL21lc3NhZ2VzL1RhYmxlQnV0dG9uc01lc3NhZ2UuanMiLCJzcmMvcHJvdG8vbWVzc2FnZXMvVGFibGVJbmZvTWVzc2FnZS5qcyIsInNyYy9wcm90by9tZXNzYWdlcy9UZXN0Q2FzZVJlcXVlc3RNZXNzYWdlLmpzIiwic3JjL3Byb3RvL21lc3NhZ2VzL1RpbWVyTWVzc2FnZS5qcyIsInNyYy9wcm90by9tZXNzYWdlcy9Ub3VybmFtZW50UmVzdWx0TWVzc2FnZS5qcyIsInNyYy91dGlscy9DaGVja2JveC5qcyIsInNyYy91dGlscy9NZXNzYWdlUmVxdWVzdENvbm5lY3Rpb24uanMiLCJzcmMvdXRpbHMvTWVzc2FnZVdlYlNvY2tldENvbm5lY3Rpb24uanMiLCJzcmMvdXRpbHMvTW91c2VPdmVyR3JvdXAuanMiLCJzcmMvdXRpbHMvUG9pbnQuanMiLCJzcmMvdXRpbHMvU2VxdWVuY2VyLmpzIiwic3JjL3V0aWxzL1NsaWRlci5qcyIsInNyYy91dGlscy9VcmxVdGlsLmpzIiwic3JjL3V0aWxzL0J1dHRvbiIsInNyYy91dGlscy9HcmFkaWVudCIsInNyYy91dGlscy9IdHRwUmVxdWVzdCIsInNyYy9jbGllbnQvYXBwL05ldFBva2VyQ2xpZW50Iiwic3JjL3V0aWxzL05pbmVTbGljZSIsInNyYy9jbGllbnQvcmVzb3VyY2VzL1Jlc291cmNlcyIsInBpeGkuanMiLCJwaXhpYXBwIiwibm9kZV9tb2R1bGVzL3RpbnAvc3JjL1RoZW5hYmxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcHZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcHpmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuMy4yIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjMuMicsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlthLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFthLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIGlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueSBjb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyB0aGUgcGFydCBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGFzIG5vbiBBU0NJSSBjaGFyYWN0ZXJzLiBJLmUuIGl0IGRvc2VudCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIGluIEFTQ0lJLlxuICAgICAgdmFyIGRvbWFpbkFycmF5ID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgnLicpO1xuICAgICAgdmFyIG5ld091dCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb21haW5BcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcyA9IGRvbWFpbkFycmF5W2ldO1xuICAgICAgICBuZXdPdXQucHVzaChzLm1hdGNoKC9bXkEtWmEtejAtOV8tXS8pID9cbiAgICAgICAgICAgICd4bi0tJyArIHB1bnljb2RlLmVuY29kZShzKSA6IHMpO1xuICAgICAgfVxuICAgICAgdGhpcy5ob3N0bmFtZSA9IG5ld091dC5qb2luKCcuJyk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmIChpc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICBpc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAoaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIE9iamVjdC5rZXlzKHRoaXMpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIHJlc3VsdFtrXSA9IHRoaXNba107XG4gIH0sIHRoaXMpO1xuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgT2JqZWN0LmtleXMocmVsYXRpdmUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgaWYgKGsgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgIH0pO1xuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIE9iamVjdC5rZXlzKHJlbGF0aXZlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9KTtcbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIWlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICFpc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QpICYmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHxcbiAgICAgIGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIWlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICFpc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCI7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuICBhcmcgPT0gbnVsbDtcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwidmFyIFBpeGlUZXh0SW5wdXQgPSByZXF1aXJlKFwiLi9zcmMvUGl4aVRleHRJbnB1dFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQaXhpVGV4dElucHV0OyIsImlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuXHRQSVhJID0gcmVxdWlyZShcInBpeGkuanNcIik7XG59XG5cbi8qKlxuICogVGV4dCBpbnB1dCBmaWVsZCBmb3IgcGl4aS5qcy5cbiAqIEEgc2ltcGxlIGV4YW1wbGU6XG4gKlxuICogICAgIC8vIFdlIG5lZWQgYSBjb250YWluZXJcbiAqICAgICB2YXIgY29udGFpbmVyID0gbmV3IFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcigpO1xuICpcbiAqICAgICAvLyBTYW1lIHN0eWxlIG9wdGlvbnMgYXMgUElYSS5UZXh0XG4gKiAgICAgdmFyIHN0eWxlPXsgLi4uIH07XG4gKlxuICogICAgIHZhciBpbnB1dEZpZWxkID0gbmV3IFBpeGlUZXh0SW5wdXQoXCJoZWxsb1wiLHN0eWxlKTtcbiAqICAgICBjb250YWluZXIuYWRkQ2hpbGQoaW5wdXRGaWVsZCk7XG4gKlxuICogVGhlIHN0eWxlIGRlZmluaXRpb25zIGFjY2VwdGVkIGJ5IHRoZSBjb25zdHJ1Y3RvciBhcmUgdGhlIHNhbWUgYXMgdGhvc2UgYWNjZXB0ZWQgYnlcbiAqIFtQSVhJLlRleHRdKGh0dHA6Ly93d3cuZ29vZGJveWRpZ2l0YWwuY29tL3BpeGlqcy9kb2NzL2NsYXNzZXMvVGV4dC5odG1sKS5cbiAqIEBjbGFzcyBQaXhpVGV4dElucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdGV4dF0gVGhlIGluaXRpYWwgdGV4dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVdIFN0eWxlIGRlZmluaXRpb24sIHNhbWUgYXMgZm9yIFBJWEkuVGV4dFxuICovXG5mdW5jdGlvbiBQaXhpVGV4dElucHV0KHRleHQsIHN0eWxlKSB7XG5cdFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKHRoaXMpO1xuXG5cdGlmICghdGV4dClcblx0XHR0ZXh0ID0gXCJcIjtcblxuXHR0ZXh0ID0gdGV4dC50b1N0cmluZygpO1xuXG5cdGlmIChzdHlsZSAmJiBzdHlsZS53b3JkV3JhcClcblx0XHR0aHJvdyBcIndvcmRXcmFwIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGlucHV0IGZpZWxkc1wiO1xuXG5cdHRoaXMuX3RleHQgPSB0ZXh0O1xuXG5cdHRoaXMubG9jYWxXaWR0aCA9IDEwMDtcblx0dGhpcy5fYmFja2dyb3VuZENvbG9yID0gMHhmZmZmZmY7XG5cdHRoaXMuX2NhcmV0Q29sb3IgPSAweDAwMDAwMDtcblx0dGhpcy5fYmFja2dyb3VuZCA9IHRydWU7XG5cblx0dGhpcy5zdHlsZSA9IHN0eWxlO1xuXHR0aGlzLnRleHRGaWVsZCA9IG5ldyBQSVhJLlRleHQodGhpcy5fdGV4dCwgc3R5bGUpO1xuXG5cdHRoaXMubG9jYWxIZWlnaHQgPVxuXHRcdHRoaXMudGV4dEZpZWxkLmRldGVybWluZUZvbnRIZWlnaHQoJ2ZvbnQ6ICcgKyB0aGlzLnRleHRGaWVsZC5zdHlsZS5mb250ICsgJzsnKSArXG5cdFx0dGhpcy50ZXh0RmllbGQuc3R5bGUuc3Ryb2tlVGhpY2tuZXNzO1xuXHR0aGlzLmJhY2tncm91bmRHcmFwaGljcyA9IG5ldyBQSVhJLkdyYXBoaWNzKCk7XG5cdHRoaXMudGV4dEZpZWxkTWFzayA9IG5ldyBQSVhJLkdyYXBoaWNzKCk7XG5cdHRoaXMuY2FyZXQgPSBuZXcgUElYSS5HcmFwaGljcygpO1xuXHR0aGlzLmRyYXdFbGVtZW50cygpO1xuXG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5iYWNrZ3JvdW5kR3JhcGhpY3MpO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMudGV4dEZpZWxkKTtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLmNhcmV0KTtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLnRleHRGaWVsZE1hc2spO1xuXG5cdHRoaXMuc2Nyb2xsSW5kZXggPSAwO1xuXHR0aGlzLl9jYXJldEluZGV4ID0gMDtcblx0dGhpcy5jYXJldEZsYXNoSW50ZXJ2YWwgPSBudWxsO1xuXHR0aGlzLmJsdXIoKTtcblx0dGhpcy51cGRhdGVDYXJldFBvc2l0aW9uKCk7XG5cblx0dGhpcy5iYWNrZ3JvdW5kR3JhcGhpY3MuaW50ZXJhY3RpdmUgPSB0cnVlO1xuXHR0aGlzLmJhY2tncm91bmRHcmFwaGljcy5idXR0b25Nb2RlID0gdHJ1ZTtcblx0dGhpcy5iYWNrZ3JvdW5kR3JhcGhpY3MuZGVmYXVsdEN1cnNvciA9IFwidGV4dFwiO1xuXG5cdHRoaXMuYmFja2dyb3VuZEdyYXBoaWNzLm1vdXNlZG93biA9IHRoaXMub25CYWNrZ3JvdW5kTW91c2VEb3duLmJpbmQodGhpcyk7XG5cdHRoaXMua2V5RXZlbnRDbG9zdXJlID0gdGhpcy5vbktleUV2ZW50LmJpbmQodGhpcyk7XG5cdHRoaXMud2luZG93Qmx1ckNsb3N1cmUgPSB0aGlzLm9uV2luZG93Qmx1ci5iaW5kKHRoaXMpO1xuXHR0aGlzLmRvY3VtZW50TW91c2VEb3duQ2xvc3VyZSA9IHRoaXMub25Eb2N1bWVudE1vdXNlRG93bi5iaW5kKHRoaXMpO1xuXHR0aGlzLmlzRm9jdXNDbGljayA9IGZhbHNlO1xuXG5cdHRoaXMudXBkYXRlVGV4dCgpO1xuXG5cdHRoaXMudGV4dEZpZWxkLm1hc2sgPSB0aGlzLnRleHRGaWVsZE1hc2s7XG5cblx0dGhpcy5rZXlwcmVzcyA9IG51bGw7XG5cdHRoaXMua2V5ZG93biA9IG51bGw7XG5cdHRoaXMuY2hhbmdlID0gbnVsbDtcbn1cblxuUGl4aVRleHRJbnB1dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUpO1xuUGl4aVRleHRJbnB1dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQaXhpVGV4dElucHV0O1xuXG4vKipcbiAqIFNvbWVvbmUgY2xpY2tlZC5cbiAqIEBtZXRob2Qgb25CYWNrZ3JvdW5kTW91c2VEb3duXG4gKiBAcHJpdmF0ZVxuICovXG5QaXhpVGV4dElucHV0LnByb3RvdHlwZS5vbkJhY2tncm91bmRNb3VzZURvd24gPSBmdW5jdGlvbihlKSB7XG5cdHZhciB4ID0gZS5nZXRMb2NhbFBvc2l0aW9uKHRoaXMpLng7XG5cdHRoaXMuX2NhcmV0SW5kZXggPSB0aGlzLmdldENhcmV0SW5kZXhCeUNvb3JkKHgpO1xuXHR0aGlzLnVwZGF0ZUNhcmV0UG9zaXRpb24oKTtcblxuXHR0aGlzLmZvY3VzKCk7XG5cblx0dGhpcy5pc0ZvY3VzQ2xpY2sgPSB0cnVlO1xuXHR2YXIgc2NvcGUgPSB0aGlzO1xuXHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdHNjb3BlLmlzRm9jdXNDbGljayA9IGZhbHNlO1xuXHR9LCAwKTtcbn1cblxuLyoqXG4gKiBGb2N1cyB0aGlzIGlucHV0IGZpZWxkLlxuICogQG1ldGhvZCBmb2N1c1xuICovXG5QaXhpVGV4dElucHV0LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLmJsdXIoKTtcblxuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmtleUV2ZW50Q2xvc3VyZSk7XG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlwcmVzc1wiLCB0aGlzLmtleUV2ZW50Q2xvc3VyZSk7XG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5kb2N1bWVudE1vdXNlRG93bkNsb3N1cmUpO1xuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy53aW5kb3dCbHVyQ2xvc3VyZSk7XG5cblx0dGhpcy5zaG93Q2FyZXQoKTtcbn1cblxuLyoqXG4gKiBIYW5kbGUga2V5IGV2ZW50LlxuICogQG1ldGhvZCBvbktleUV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5QaXhpVGV4dElucHV0LnByb3RvdHlwZS5vbktleUV2ZW50ID0gZnVuY3Rpb24oZSkge1xuXHQvKmNvbnNvbGUubG9nKFwia2V5IGV2ZW50XCIpO1xuXHRjb25zb2xlLmxvZyhlKTsqL1xuXG5cdGlmIChlLnR5cGUgPT0gXCJrZXlwcmVzc1wiKSB7XG5cdFx0aWYgKGUuY2hhckNvZGUgPCAzMilcblx0XHRcdHJldHVybjtcblxuXHRcdHRoaXMuX3RleHQgPVxuXHRcdFx0dGhpcy5fdGV4dC5zdWJzdHJpbmcoMCwgdGhpcy5fY2FyZXRJbmRleCkgK1xuXHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZShlLmNoYXJDb2RlKSArXG5cdFx0XHR0aGlzLl90ZXh0LnN1YnN0cmluZyh0aGlzLl9jYXJldEluZGV4KTtcblxuXHRcdHRoaXMuX2NhcmV0SW5kZXgrKztcblx0XHR0aGlzLmVuc3VyZUNhcmV0SW5WaWV3KCk7XG5cdFx0dGhpcy5zaG93Q2FyZXQoKTtcblx0XHR0aGlzLnVwZGF0ZVRleHQoKTtcblx0XHR0aGlzLnRyaWdnZXIodGhpcy5rZXlwcmVzcywgZSk7XG5cdFx0dGhpcy50cmlnZ2VyKHRoaXMuY2hhbmdlKTtcblx0fVxuXG5cdGlmIChlLnR5cGUgPT0gXCJrZXlkb3duXCIpIHtcblx0XHRzd2l0Y2ggKGUua2V5Q29kZSkge1xuXHRcdFx0Y2FzZSA4OlxuXHRcdFx0XHRpZiAodGhpcy5fY2FyZXRJbmRleCA+IDApIHtcblx0XHRcdFx0XHR0aGlzLl90ZXh0ID1cblx0XHRcdFx0XHRcdHRoaXMuX3RleHQuc3Vic3RyaW5nKDAsIHRoaXMuX2NhcmV0SW5kZXggLSAxKSArXG5cdFx0XHRcdFx0XHR0aGlzLl90ZXh0LnN1YnN0cmluZyh0aGlzLl9jYXJldEluZGV4KTtcblxuXHRcdFx0XHRcdHRoaXMuX2NhcmV0SW5kZXgtLTtcblx0XHRcdFx0XHR0aGlzLmVuc3VyZUNhcmV0SW5WaWV3KCk7XG5cdFx0XHRcdFx0dGhpcy5zaG93Q2FyZXQoKTtcblx0XHRcdFx0XHR0aGlzLnVwZGF0ZVRleHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcih0aGlzLmNoYW5nZSk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIDQ2OlxuXHRcdFx0XHR0aGlzLl90ZXh0ID1cblx0XHRcdFx0XHR0aGlzLl90ZXh0LnN1YnN0cmluZygwLCB0aGlzLl9jYXJldEluZGV4KSArXG5cdFx0XHRcdFx0dGhpcy5fdGV4dC5zdWJzdHJpbmcodGhpcy5fY2FyZXRJbmRleCArIDEpO1xuXG5cdFx0XHRcdHRoaXMuZW5zdXJlQ2FyZXRJblZpZXcoKTtcblx0XHRcdFx0dGhpcy51cGRhdGVDYXJldFBvc2l0aW9uKCk7XG5cdFx0XHRcdHRoaXMuc2hvd0NhcmV0KCk7XG5cdFx0XHRcdHRoaXMudXBkYXRlVGV4dCgpO1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcih0aGlzLmNoYW5nZSk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIDM5OlxuXHRcdFx0XHR0aGlzLl9jYXJldEluZGV4Kys7XG5cdFx0XHRcdGlmICh0aGlzLl9jYXJldEluZGV4ID4gdGhpcy5fdGV4dC5sZW5ndGgpXG5cdFx0XHRcdFx0dGhpcy5fY2FyZXRJbmRleCA9IHRoaXMuX3RleHQubGVuZ3RoO1xuXG5cdFx0XHRcdHRoaXMuZW5zdXJlQ2FyZXRJblZpZXcoKTtcblx0XHRcdFx0dGhpcy51cGRhdGVDYXJldFBvc2l0aW9uKCk7XG5cdFx0XHRcdHRoaXMuc2hvd0NhcmV0KCk7XG5cdFx0XHRcdHRoaXMudXBkYXRlVGV4dCgpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAzNzpcblx0XHRcdFx0dGhpcy5fY2FyZXRJbmRleC0tO1xuXHRcdFx0XHRpZiAodGhpcy5fY2FyZXRJbmRleCA8IDApXG5cdFx0XHRcdFx0dGhpcy5fY2FyZXRJbmRleCA9IDA7XG5cblx0XHRcdFx0dGhpcy5lbnN1cmVDYXJldEluVmlldygpO1xuXHRcdFx0XHR0aGlzLnVwZGF0ZUNhcmV0UG9zaXRpb24oKTtcblx0XHRcdFx0dGhpcy5zaG93Q2FyZXQoKTtcblx0XHRcdFx0dGhpcy51cGRhdGVUZXh0KCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdHRoaXMudHJpZ2dlcih0aGlzLmtleWRvd24sIGUpO1xuXHR9XG59XG5cbi8qKlxuICogRW5zdXJlIHRoZSBjYXJldCBpcyBub3Qgb3V0c2lkZSB0aGUgYm91bmRzLlxuICogQG1ldGhvZCBlbnN1cmVDYXJldEluVmlld1xuICogQHByaXZhdGVcbiAqL1xuUGl4aVRleHRJbnB1dC5wcm90b3R5cGUuZW5zdXJlQ2FyZXRJblZpZXcgPSBmdW5jdGlvbigpIHtcblx0dGhpcy51cGRhdGVDYXJldFBvc2l0aW9uKCk7XG5cblx0d2hpbGUgKHRoaXMuY2FyZXQucG9zaXRpb24ueCA+PSB0aGlzLmxvY2FsV2lkdGggLSAxKSB7XG5cdFx0dGhpcy5zY3JvbGxJbmRleCsrO1xuXHRcdHRoaXMudXBkYXRlQ2FyZXRQb3NpdGlvbigpO1xuXHR9XG5cblx0d2hpbGUgKHRoaXMuY2FyZXQucG9zaXRpb24ueCA8IDApIHtcblx0XHR0aGlzLnNjcm9sbEluZGV4IC09IDI7XG5cdFx0aWYgKHRoaXMuc2Nyb2xsSW5kZXggPCAwKVxuXHRcdFx0dGhpcy5zY3JvbGxJbmRleCA9IDA7XG5cdFx0dGhpcy51cGRhdGVDYXJldFBvc2l0aW9uKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBCbHVyIG91cnNlbGYuXG4gKiBAbWV0aG9kIGJsdXJcbiAqL1xuUGl4aVRleHRJbnB1dC5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmtleUV2ZW50Q2xvc3VyZSk7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlwcmVzc1wiLCB0aGlzLmtleUV2ZW50Q2xvc3VyZSk7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5kb2N1bWVudE1vdXNlRG93bkNsb3N1cmUpO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy53aW5kb3dCbHVyQ2xvc3VyZSk7XG5cblx0dGhpcy5oaWRlQ2FyZXQoKTtcbn1cblxuLyoqXG4gKiBXaW5kb3cgYmx1ci5cbiAqIEBtZXRob2Qgb25Eb2N1bWVudE1vdXNlRG93blxuICogQHByaXZhdGVcbiAqL1xuUGl4aVRleHRJbnB1dC5wcm90b3R5cGUub25Eb2N1bWVudE1vdXNlRG93biA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIXRoaXMuaXNGb2N1c0NsaWNrKVxuXHRcdHRoaXMuYmx1cigpO1xufVxuXG4vKipcbiAqIFdpbmRvdyBibHVyLlxuICogQG1ldGhvZCBvbldpbmRvd0JsdXJcbiAqIEBwcml2YXRlXG4gKi9cblBpeGlUZXh0SW5wdXQucHJvdG90eXBlLm9uV2luZG93Qmx1ciA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLmJsdXIoKTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgY2FyZXQgUG9zaXRpb24uXG4gKiBAbWV0aG9kIHVwZGF0ZUNhcmV0UG9zaXRpb25cbiAqIEBwcml2YXRlXG4gKi9cblBpeGlUZXh0SW5wdXQucHJvdG90eXBlLnVwZGF0ZUNhcmV0UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuX2NhcmV0SW5kZXggPCB0aGlzLnNjcm9sbEluZGV4KSB7XG5cdFx0dGhpcy5jYXJldC5wb3NpdGlvbi54ID0gLTE7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIHN1YiA9IHRoaXMuX3RleHQuc3Vic3RyaW5nKDAsIHRoaXMuX2NhcmV0SW5kZXgpLnN1YnN0cmluZyh0aGlzLnNjcm9sbEluZGV4KTtcblx0dGhpcy5jYXJldC5wb3NpdGlvbi54ID0gdGhpcy50ZXh0RmllbGQuY29udGV4dC5tZWFzdXJlVGV4dChzdWIpLndpZHRoO1xufVxuXG4vKipcbiAqIFVwZGF0ZSB0ZXh0LlxuICogQG1ldGhvZCB1cGRhdGVUZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5QaXhpVGV4dElucHV0LnByb3RvdHlwZS51cGRhdGVUZXh0ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMudGV4dEZpZWxkLnNldFRleHQodGhpcy5fdGV4dC5zdWJzdHJpbmcodGhpcy5zY3JvbGxJbmRleCkpO1xufVxuXG4vKipcbiAqIERyYXcgdGhlIGJhY2tncm91bmQgYW5kIGNhcmV0LlxuICogQG1ldGhvZCBkcmF3RWxlbWVudHNcbiAqIEBwcml2YXRlXG4gKi9cblBpeGlUZXh0SW5wdXQucHJvdG90eXBlLmRyYXdFbGVtZW50cyA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLmJhY2tncm91bmRHcmFwaGljcy5jbGVhcigpO1xuXHR0aGlzLmJhY2tncm91bmRHcmFwaGljcy5iZWdpbkZpbGwodGhpcy5fYmFja2dyb3VuZENvbG9yKTtcblxuXHRpZiAodGhpcy5fYmFja2dyb3VuZClcblx0XHR0aGlzLmJhY2tncm91bmRHcmFwaGljcy5kcmF3UmVjdCgwLCAwLCB0aGlzLmxvY2FsV2lkdGgsIHRoaXMubG9jYWxIZWlnaHQpO1xuXG5cdHRoaXMuYmFja2dyb3VuZEdyYXBoaWNzLmVuZEZpbGwoKTtcblx0dGhpcy5iYWNrZ3JvdW5kR3JhcGhpY3MuaGl0QXJlYSA9IG5ldyBQSVhJLlJlY3RhbmdsZSgwLCAwLCB0aGlzLmxvY2FsV2lkdGgsIHRoaXMubG9jYWxIZWlnaHQpO1xuXG5cdHRoaXMudGV4dEZpZWxkTWFzay5jbGVhcigpO1xuXHR0aGlzLnRleHRGaWVsZE1hc2suYmVnaW5GaWxsKHRoaXMuX2JhY2tncm91bmRDb2xvcik7XG5cdHRoaXMudGV4dEZpZWxkTWFzay5kcmF3UmVjdCgwLCAwLCB0aGlzLmxvY2FsV2lkdGgsIHRoaXMubG9jYWxIZWlnaHQpO1xuXHR0aGlzLnRleHRGaWVsZE1hc2suZW5kRmlsbCgpO1xuXG5cdHRoaXMuY2FyZXQuY2xlYXIoKTtcblx0dGhpcy5jYXJldC5iZWdpbkZpbGwodGhpcy5fY2FyZXRDb2xvcik7XG5cdHRoaXMuY2FyZXQuZHJhd1JlY3QoMSwgMSwgMSwgdGhpcy5sb2NhbEhlaWdodCAtIDIpO1xuXHR0aGlzLmNhcmV0LmVuZEZpbGwoKTtcbn1cblxuLyoqXG4gKiBTaG93IGNhcmV0LlxuICogQG1ldGhvZCBzaG93Q2FyZXRcbiAqIEBwcml2YXRlXG4gKi9cblBpeGlUZXh0SW5wdXQucHJvdG90eXBlLnNob3dDYXJldCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5jYXJldEZsYXNoSW50ZXJ2YWwpIHtcblx0XHRjbGVhckludGVydmFsKHRoaXMuY2FyZXRGbGFzaEludGVydmFsKTtcblx0XHR0aGlzLmNhcmV0Rmxhc2hJbnRlcnZhbCA9IG51bGw7XG5cdH1cblxuXHR0aGlzLmNhcmV0LnZpc2libGUgPSB0cnVlO1xuXHR0aGlzLmNhcmV0Rmxhc2hJbnRlcnZhbCA9IHNldEludGVydmFsKHRoaXMub25DYXJldEZsYXNoSW50ZXJ2YWwuYmluZCh0aGlzKSwgNTAwKTtcbn1cblxuLyoqXG4gKiBIaWRlIGNhcmV0LlxuICogQG1ldGhvZCBoaWRlQ2FyZXRcbiAqIEBwcml2YXRlXG4gKi9cblBpeGlUZXh0SW5wdXQucHJvdG90eXBlLmhpZGVDYXJldCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5jYXJldEZsYXNoSW50ZXJ2YWwpIHtcblx0XHRjbGVhckludGVydmFsKHRoaXMuY2FyZXRGbGFzaEludGVydmFsKTtcblx0XHR0aGlzLmNhcmV0Rmxhc2hJbnRlcnZhbCA9IG51bGw7XG5cdH1cblxuXHR0aGlzLmNhcmV0LnZpc2libGUgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBDYXJldCBmbGFzaCBpbnRlcnZhbC5cbiAqIEBtZXRob2Qgb25DYXJldEZsYXNoSW50ZXJ2YWxcbiAqIEBwcml2YXRlXG4gKi9cblBpeGlUZXh0SW5wdXQucHJvdG90eXBlLm9uQ2FyZXRGbGFzaEludGVydmFsID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuY2FyZXQudmlzaWJsZSA9ICF0aGlzLmNhcmV0LnZpc2libGU7XG59XG5cbi8qKlxuICogTWFwIHBvc2l0aW9uIHRvIGNhcmV0IGluZGV4LlxuICogQG1ldGhvZCBnZXRDYXJldEluZGV4QnlDb29yZFxuICogQHByaXZhdGVcbiAqL1xuUGl4aVRleHRJbnB1dC5wcm90b3R5cGUuZ2V0Q2FyZXRJbmRleEJ5Q29vcmQgPSBmdW5jdGlvbih4KSB7XG5cdHZhciBzbWFsbGVzdCA9IDEwMDAwO1xuXHR2YXIgY2FuZCA9IDA7XG5cdHZhciB2aXNpYmxlID0gdGhpcy5fdGV4dC5zdWJzdHJpbmcodGhpcy5zY3JvbGxJbmRleCk7XG5cblx0Zm9yIChpID0gMDsgaSA8IHZpc2libGUubGVuZ3RoICsgMTsgaSsrKSB7XG5cdFx0dmFyIHN1YiA9IHZpc2libGUuc3Vic3RyaW5nKDAsIGkpO1xuXHRcdHZhciB3ID0gdGhpcy50ZXh0RmllbGQuY29udGV4dC5tZWFzdXJlVGV4dChzdWIpLndpZHRoO1xuXG5cdFx0aWYgKE1hdGguYWJzKHcgLSB4KSA8IHNtYWxsZXN0KSB7XG5cdFx0XHRzbWFsbGVzdCA9IE1hdGguYWJzKHcgLSB4KTtcblx0XHRcdGNhbmQgPSBpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0aGlzLnNjcm9sbEluZGV4ICsgY2FuZDtcbn1cblxuLyoqXG4gKiBUaGUgd2lkdGggb2YgdGhlIFBpeGlUZXh0SW5wdXQuIFRoaXMgaXMgb3ZlcnJpZGRlbiB0byBoYXZlIGEgc2xpZ2h0bHlcbiAqIGRpZmZlcmVudCBiZWhhaXZvdXIgdGhhbiB0aGUgb3RoZXIgRGlzcGxheU9iamVjdHMuIFNldHRpbmcgdGhlXG4gKiB3aWR0aCBvZiB0aGUgUGl4aVRleHRJbnB1dCBkb2VzIG5vdCBjaGFuZ2UgdGhlIHNjYWxlLCBidXQgaXQgcmF0aGVyXG4gKiBtYWtlcyB0aGUgZmllbGQgbGFyZ2VyLiBJZiB5b3UgYWN0dWFsbHkgd2FudCB0byBzY2FsZSBpdCxcbiAqIHVzZSB0aGUgc2NhbGUgcHJvcGVydHkuXG4gKiBAcHJvcGVydHkgd2lkdGhcbiAqIEB0eXBlIE51bWJlclxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGl4aVRleHRJbnB1dC5wcm90b3R5cGUsIFwid2lkdGhcIiwge1xuXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnNjYWxlLnggKiB0aGlzLmdldExvY2FsQm91bmRzKCkud2lkdGg7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih2KSB7XG5cdFx0dGhpcy5sb2NhbFdpZHRoID0gdjtcblx0XHR0aGlzLmRyYXdFbGVtZW50cygpO1xuXHRcdHRoaXMuZW5zdXJlQ2FyZXRJblZpZXcoKTtcblx0XHR0aGlzLnVwZGF0ZVRleHQoKTtcblx0fVxufSk7XG5cbi8qKlxuICogVGhlIHRleHQgaW4gdGhlIGlucHV0IGZpZWxkLiBTZXR0aW5nIHdpbGwgaGF2ZSB0aGUgaW1wbGljaXQgZnVuY3Rpb24gb2YgcmVzZXR0aW5nIHRoZSBzY3JvbGxcbiAqIG9mIHRoZSBpbnB1dCBmaWVsZCBhbmQgcmVtb3ZpbmcgZm9jdXMuXG4gKiBAcHJvcGVydHkgdGV4dFxuICogQHR5cGUgU3RyaW5nXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaXhpVGV4dElucHV0LnByb3RvdHlwZSwgXCJ0ZXh0XCIsIHtcblx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fdGV4dDtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHYpIHtcblx0XHR0aGlzLl90ZXh0ID0gdi50b1N0cmluZygpO1xuXHRcdHRoaXMuc2Nyb2xsSW5kZXggPSAwO1xuXHRcdHRoaXMuY2FyZXRJbmRleCA9IDA7XG5cdFx0dGhpcy5ibHVyKCk7XG5cdFx0dGhpcy51cGRhdGVUZXh0KCk7XG5cdH1cbn0pO1xuXG4vKipcbiAqIFRoZSBjb2xvciBvZiB0aGUgYmFja2dyb3VuZCBmb3IgdGhlIGlucHV0IGZpZWxkLlxuICogVGhpcyBuZWVkcyB0byBiZSBzcGVjaWZpZWQgYXMgYW4gaW50ZWdlciwgbm90IHVzaW5nIEhUTUxcbiAqIG5vdGF0aW9uLCBlLmcuIGZvciByZWQgYmFja2dyb3VuZDpcbiAqXG4gKiAgICAgbXlJbnB1dFRleHQuYmFja2dyb3VuZENvbG9yID0gMHhmZjAwMDA7XG4gKlxuICogSW4gb3JkZXIgZm9yIHRoZSBiYWNrZ3JvdW5kIHRvIGJlIGRyYXduLCB0aGUgYGJhY2tncm91bmRgXG4gKiBwcm9wZXJ0eSBuZWVkcyB0byBiZSB0cnVlLiBJZiBub3QsIHRoaXMgcHJvcGVydHkgd2lsbCBoYXZlXG4gKiBubyBlZmZlY3QuXG4gKiBAcHJvcGVydHkgYmFja2dyb3VuZENvbG9yXG4gKiBAdHlwZSBJbnRlZ2VyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaXhpVGV4dElucHV0LnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwge1xuXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kQ29sb3I7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih2KSB7XG5cdFx0dGhpcy5fYmFja2dyb3VuZENvbG9yID0gdjtcblx0XHR0aGlzLmRyYXdFbGVtZW50cygpO1xuXHR9XG59KTtcblxuLyoqXG4gKiBUaGUgY29sb3Igb2YgdGhlIGNhcmV0LlxuICogQHByb3BlcnR5IGNhcmV0Q29sb3JcbiAqIEB0eXBlIEludGVnZXJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBpeGlUZXh0SW5wdXQucHJvdG90eXBlLCBcImNhcmV0Q29sb3JcIiwge1xuXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jYXJldENvbG9yO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24odikge1xuXHRcdHRoaXMuX2NhcmV0Q29sb3IgPSB2O1xuXHRcdHRoaXMuZHJhd0VsZW1lbnRzKCk7XG5cdH1cbn0pO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGJhY2tncm91bmQgc2hvdWxkIGJlIGRyYXduIGJlaGluZCB0aGUgdGV4dC5cbiAqIFRoZSBjb2xvciBvZiB0aGUgYmFja2dyb3VuZCBpcyBzcGVjaWZpZWQgdXNpbmcgdGhlIGJhY2tncm91bmRDb2xvclxuICogcHJvcGVydHkuXG4gKiBAcHJvcGVydHkgYmFja2dyb3VuZFxuICogQHR5cGUgQm9vbGVhblxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGl4aVRleHRJbnB1dC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB7XG5cdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2JhY2tncm91bmQ7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih2KSB7XG5cdFx0dGhpcy5fYmFja2dyb3VuZCA9IHY7XG5cdFx0dGhpcy5kcmF3RWxlbWVudHMoKTtcblx0fVxufSk7XG5cbi8qKlxuICogU2V0IHRleHQuXG4gKiBAbWV0aG9kIHNldFRleHRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSBuZXcgdGV4dC5cbiAqL1xuUGl4aVRleHRJbnB1dC5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uKHYpIHtcblx0dGhpcy50ZXh0ID0gdjtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGFuIGV2ZW50IGZ1bmN0aW9uIGlmIGl0IGV4aXN0cy5cbiAqIEBtZXRob2QgdHJpZ2dlclxuICogQHByaXZhdGVcbiAqL1xuUGl4aVRleHRJbnB1dC5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uKGZuLCBlKSB7XG5cdGlmIChmbilcblx0XHRmbihlKTtcbn1cblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gUGl4aVRleHRJbnB1dDtcbn0iLCIvKipcbiAqIFR3ZWVuLmpzIC0gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc29sZS90d2Vlbi5qc1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc29sZS90d2Vlbi5qcy9ncmFwaHMvY29udHJpYnV0b3JzIGZvciB0aGUgZnVsbCBsaXN0IG9mIGNvbnRyaWJ1dG9ycy5cbiAqIFRoYW5rIHlvdSBhbGwsIHlvdSdyZSBhd2Vzb21lIVxuICovXG5cbi8vIERhdGUubm93IHNoaW0gZm9yIChhaGVtKSBJbnRlcm5ldCBFeHBsbyhkfHIpZXJcbmlmICggRGF0ZS5ub3cgPT09IHVuZGVmaW5lZCApIHtcblxuXHREYXRlLm5vdyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcblxuXHR9O1xuXG59XG5cbnZhciBUV0VFTiA9IFRXRUVOIHx8ICggZnVuY3Rpb24gKCkge1xuXG5cdHZhciBfdHdlZW5zID0gW107XG5cblx0cmV0dXJuIHtcblxuXHRcdFJFVklTSU9OOiAnMTQnLFxuXG5cdFx0Z2V0QWxsOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBfdHdlZW5zO1xuXG5cdFx0fSxcblxuXHRcdHJlbW92ZUFsbDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRfdHdlZW5zID0gW107XG5cblx0XHR9LFxuXG5cdFx0YWRkOiBmdW5jdGlvbiAoIHR3ZWVuICkge1xuXG5cdFx0XHRfdHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cblx0XHR9LFxuXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbiAoIHR3ZWVuICkge1xuXG5cdFx0XHR2YXIgaSA9IF90d2VlbnMuaW5kZXhPZiggdHdlZW4gKTtcblxuXHRcdFx0aWYgKCBpICE9PSAtMSApIHtcblxuXHRcdFx0XHRfdHdlZW5zLnNwbGljZSggaSwgMSApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0dXBkYXRlOiBmdW5jdGlvbiAoIHRpbWUgKSB7XG5cblx0XHRcdGlmICggX3R3ZWVucy5sZW5ndGggPT09IDAgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdHZhciBpID0gMDtcblxuXHRcdFx0dGltZSA9IHRpbWUgIT09IHVuZGVmaW5lZCA/IHRpbWUgOiAoIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wZXJmb3JtYW5jZSAhPT0gdW5kZWZpbmVkICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgIT09IHVuZGVmaW5lZCA/IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSA6IERhdGUubm93KCkgKTtcblxuXHRcdFx0d2hpbGUgKCBpIDwgX3R3ZWVucy5sZW5ndGggKSB7XG5cblx0XHRcdFx0aWYgKCBfdHdlZW5zWyBpIF0udXBkYXRlKCB0aW1lICkgKSB7XG5cblx0XHRcdFx0XHRpKys7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdF90d2VlbnMuc3BsaWNlKCBpLCAxICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXHR9O1xuXG59ICkoKTtcblxuVFdFRU4uVHdlZW4gPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHR2YXIgX29iamVjdCA9IG9iamVjdDtcblx0dmFyIF92YWx1ZXNTdGFydCA9IHt9O1xuXHR2YXIgX3ZhbHVlc0VuZCA9IHt9O1xuXHR2YXIgX3ZhbHVlc1N0YXJ0UmVwZWF0ID0ge307XG5cdHZhciBfZHVyYXRpb24gPSAxMDAwO1xuXHR2YXIgX3JlcGVhdCA9IDA7XG5cdHZhciBfeW95byA9IGZhbHNlO1xuXHR2YXIgX2lzUGxheWluZyA9IGZhbHNlO1xuXHR2YXIgX3JldmVyc2VkID0gZmFsc2U7XG5cdHZhciBfZGVsYXlUaW1lID0gMDtcblx0dmFyIF9zdGFydFRpbWUgPSBudWxsO1xuXHR2YXIgX2Vhc2luZ0Z1bmN0aW9uID0gVFdFRU4uRWFzaW5nLkxpbmVhci5Ob25lO1xuXHR2YXIgX2ludGVycG9sYXRpb25GdW5jdGlvbiA9IFRXRUVOLkludGVycG9sYXRpb24uTGluZWFyO1xuXHR2YXIgX2NoYWluZWRUd2VlbnMgPSBbXTtcblx0dmFyIF9vblN0YXJ0Q2FsbGJhY2sgPSBudWxsO1xuXHR2YXIgX29uU3RhcnRDYWxsYmFja0ZpcmVkID0gZmFsc2U7XG5cdHZhciBfb25VcGRhdGVDYWxsYmFjayA9IG51bGw7XG5cdHZhciBfb25Db21wbGV0ZUNhbGxiYWNrID0gbnVsbDtcblx0dmFyIF9vblN0b3BDYWxsYmFjayA9IG51bGw7XG5cblx0Ly8gU2V0IGFsbCBzdGFydGluZyB2YWx1ZXMgcHJlc2VudCBvbiB0aGUgdGFyZ2V0IG9iamVjdFxuXHRmb3IgKCB2YXIgZmllbGQgaW4gb2JqZWN0ICkge1xuXG5cdFx0X3ZhbHVlc1N0YXJ0WyBmaWVsZCBdID0gcGFyc2VGbG9hdChvYmplY3RbZmllbGRdLCAxMCk7XG5cblx0fVxuXG5cdHRoaXMudG8gPSBmdW5jdGlvbiAoIHByb3BlcnRpZXMsIGR1cmF0aW9uICkge1xuXG5cdFx0aWYgKCBkdXJhdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRfZHVyYXRpb24gPSBkdXJhdGlvbjtcblxuXHRcdH1cblxuXHRcdF92YWx1ZXNFbmQgPSBwcm9wZXJ0aWVzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLnN0YXJ0ID0gZnVuY3Rpb24gKCB0aW1lICkge1xuXG5cdFx0VFdFRU4uYWRkKCB0aGlzICk7XG5cblx0XHRfaXNQbGF5aW5nID0gdHJ1ZTtcblxuXHRcdF9vblN0YXJ0Q2FsbGJhY2tGaXJlZCA9IGZhbHNlO1xuXG5cdFx0X3N0YXJ0VGltZSA9IHRpbWUgIT09IHVuZGVmaW5lZCA/IHRpbWUgOiAoIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wZXJmb3JtYW5jZSAhPT0gdW5kZWZpbmVkICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgIT09IHVuZGVmaW5lZCA/IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSA6IERhdGUubm93KCkgKTtcblx0XHRfc3RhcnRUaW1lICs9IF9kZWxheVRpbWU7XG5cblx0XHRmb3IgKCB2YXIgcHJvcGVydHkgaW4gX3ZhbHVlc0VuZCApIHtcblxuXHRcdFx0Ly8gY2hlY2sgaWYgYW4gQXJyYXkgd2FzIHByb3ZpZGVkIGFzIHByb3BlcnR5IHZhbHVlXG5cdFx0XHRpZiAoIF92YWx1ZXNFbmRbIHByb3BlcnR5IF0gaW5zdGFuY2VvZiBBcnJheSApIHtcblxuXHRcdFx0XHRpZiAoIF92YWx1ZXNFbmRbIHByb3BlcnR5IF0ubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNyZWF0ZSBhIGxvY2FsIGNvcHkgb2YgdGhlIEFycmF5IHdpdGggdGhlIHN0YXJ0IHZhbHVlIGF0IHRoZSBmcm9udFxuXHRcdFx0XHRfdmFsdWVzRW5kWyBwcm9wZXJ0eSBdID0gWyBfb2JqZWN0WyBwcm9wZXJ0eSBdIF0uY29uY2F0KCBfdmFsdWVzRW5kWyBwcm9wZXJ0eSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X3ZhbHVlc1N0YXJ0WyBwcm9wZXJ0eSBdID0gX29iamVjdFsgcHJvcGVydHkgXTtcblxuXHRcdFx0aWYoICggX3ZhbHVlc1N0YXJ0WyBwcm9wZXJ0eSBdIGluc3RhbmNlb2YgQXJyYXkgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdF92YWx1ZXNTdGFydFsgcHJvcGVydHkgXSAqPSAxLjA7IC8vIEVuc3VyZXMgd2UncmUgdXNpbmcgbnVtYmVycywgbm90IHN0cmluZ3Ncblx0XHRcdH1cblxuXHRcdFx0X3ZhbHVlc1N0YXJ0UmVwZWF0WyBwcm9wZXJ0eSBdID0gX3ZhbHVlc1N0YXJ0WyBwcm9wZXJ0eSBdIHx8IDA7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMuc3RvcCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdGlmICggIV9pc1BsYXlpbmcgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRUV0VFTi5yZW1vdmUoIHRoaXMgKTtcblx0XHRfaXNQbGF5aW5nID0gZmFsc2U7XG5cblx0XHRpZiAoIF9vblN0b3BDYWxsYmFjayAhPT0gbnVsbCApIHtcblxuXHRcdFx0X29uU3RvcENhbGxiYWNrLmNhbGwoIF9vYmplY3QgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuc3RvcENoYWluZWRUd2VlbnMoKTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMuc3RvcENoYWluZWRUd2VlbnMgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIG51bUNoYWluZWRUd2VlbnMgPSBfY2hhaW5lZFR3ZWVucy5sZW5ndGg7IGkgPCBudW1DaGFpbmVkVHdlZW5zOyBpKysgKSB7XG5cblx0XHRcdF9jaGFpbmVkVHdlZW5zWyBpIF0uc3RvcCgpO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy5kZWxheSA9IGZ1bmN0aW9uICggYW1vdW50ICkge1xuXG5cdFx0X2RlbGF5VGltZSA9IGFtb3VudDtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMucmVwZWF0ID0gZnVuY3Rpb24gKCB0aW1lcyApIHtcblxuXHRcdF9yZXBlYXQgPSB0aW1lcztcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMueW95byA9IGZ1bmN0aW9uKCB5b3lvICkge1xuXG5cdFx0X3lveW8gPSB5b3lvO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblxuXHR0aGlzLmVhc2luZyA9IGZ1bmN0aW9uICggZWFzaW5nICkge1xuXG5cdFx0X2Vhc2luZ0Z1bmN0aW9uID0gZWFzaW5nO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5pbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKCBpbnRlcnBvbGF0aW9uICkge1xuXG5cdFx0X2ludGVycG9sYXRpb25GdW5jdGlvbiA9IGludGVycG9sYXRpb247XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLmNoYWluID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0X2NoYWluZWRUd2VlbnMgPSBhcmd1bWVudHM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLm9uU3RhcnQgPSBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0X29uU3RhcnRDYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5vblVwZGF0ZSA9IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHRfb25VcGRhdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5vbkNvbXBsZXRlID0gZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdF9vbkNvbXBsZXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMub25TdG9wID0gZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdF9vblN0b3BDYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoIHRpbWUgKSB7XG5cblx0XHR2YXIgcHJvcGVydHk7XG5cblx0XHRpZiAoIHRpbWUgPCBfc3RhcnRUaW1lICkge1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGlmICggX29uU3RhcnRDYWxsYmFja0ZpcmVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0aWYgKCBfb25TdGFydENhbGxiYWNrICE9PSBudWxsICkge1xuXG5cdFx0XHRcdF9vblN0YXJ0Q2FsbGJhY2suY2FsbCggX29iamVjdCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9vblN0YXJ0Q2FsbGJhY2tGaXJlZCA9IHRydWU7XG5cblx0XHR9XG5cblx0XHR2YXIgZWxhcHNlZCA9ICggdGltZSAtIF9zdGFydFRpbWUgKSAvIF9kdXJhdGlvbjtcblx0XHRlbGFwc2VkID0gZWxhcHNlZCA+IDEgPyAxIDogZWxhcHNlZDtcblxuXHRcdHZhciB2YWx1ZSA9IF9lYXNpbmdGdW5jdGlvbiggZWxhcHNlZCApO1xuXG5cdFx0Zm9yICggcHJvcGVydHkgaW4gX3ZhbHVlc0VuZCApIHtcblxuXHRcdFx0dmFyIHN0YXJ0ID0gX3ZhbHVlc1N0YXJ0WyBwcm9wZXJ0eSBdIHx8IDA7XG5cdFx0XHR2YXIgZW5kID0gX3ZhbHVlc0VuZFsgcHJvcGVydHkgXTtcblxuXHRcdFx0aWYgKCBlbmQgaW5zdGFuY2VvZiBBcnJheSApIHtcblxuXHRcdFx0XHRfb2JqZWN0WyBwcm9wZXJ0eSBdID0gX2ludGVycG9sYXRpb25GdW5jdGlvbiggZW5kLCB2YWx1ZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFBhcnNlcyByZWxhdGl2ZSBlbmQgdmFsdWVzIHdpdGggc3RhcnQgYXMgYmFzZSAoZS5nLjogKzEwLCAtMylcblx0XHRcdFx0aWYgKCB0eXBlb2YoZW5kKSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRlbmQgPSBzdGFydCArIHBhcnNlRmxvYXQoZW5kLCAxMCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBwcm90ZWN0IGFnYWluc3Qgbm9uIG51bWVyaWMgcHJvcGVydGllcy5cblx0XHRcdFx0aWYgKCB0eXBlb2YoZW5kKSA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRfb2JqZWN0WyBwcm9wZXJ0eSBdID0gc3RhcnQgKyAoIGVuZCAtIHN0YXJ0ICkgKiB2YWx1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIF9vblVwZGF0ZUNhbGxiYWNrICE9PSBudWxsICkge1xuXG5cdFx0XHRfb25VcGRhdGVDYWxsYmFjay5jYWxsKCBfb2JqZWN0LCB2YWx1ZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBlbGFwc2VkID09IDEgKSB7XG5cblx0XHRcdGlmICggX3JlcGVhdCA+IDAgKSB7XG5cblx0XHRcdFx0aWYoIGlzRmluaXRlKCBfcmVwZWF0ICkgKSB7XG5cdFx0XHRcdFx0X3JlcGVhdC0tO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVhc3NpZ24gc3RhcnRpbmcgdmFsdWVzLCByZXN0YXJ0IGJ5IG1ha2luZyBzdGFydFRpbWUgPSBub3dcblx0XHRcdFx0Zm9yKCBwcm9wZXJ0eSBpbiBfdmFsdWVzU3RhcnRSZXBlYXQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHR5cGVvZiggX3ZhbHVlc0VuZFsgcHJvcGVydHkgXSApID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdFx0X3ZhbHVlc1N0YXJ0UmVwZWF0WyBwcm9wZXJ0eSBdID0gX3ZhbHVlc1N0YXJ0UmVwZWF0WyBwcm9wZXJ0eSBdICsgcGFyc2VGbG9hdChfdmFsdWVzRW5kWyBwcm9wZXJ0eSBdLCAxMCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKF95b3lvKSB7XG5cdFx0XHRcdFx0XHR2YXIgdG1wID0gX3ZhbHVlc1N0YXJ0UmVwZWF0WyBwcm9wZXJ0eSBdO1xuXHRcdFx0XHRcdFx0X3ZhbHVlc1N0YXJ0UmVwZWF0WyBwcm9wZXJ0eSBdID0gX3ZhbHVlc0VuZFsgcHJvcGVydHkgXTtcblx0XHRcdFx0XHRcdF92YWx1ZXNFbmRbIHByb3BlcnR5IF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X3ZhbHVlc1N0YXJ0WyBwcm9wZXJ0eSBdID0gX3ZhbHVlc1N0YXJ0UmVwZWF0WyBwcm9wZXJ0eSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoX3lveW8pIHtcblx0XHRcdFx0XHRfcmV2ZXJzZWQgPSAhX3JldmVyc2VkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X3N0YXJ0VGltZSA9IHRpbWUgKyBfZGVsYXlUaW1lO1xuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggX29uQ29tcGxldGVDYWxsYmFjayAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdF9vbkNvbXBsZXRlQ2FsbGJhY2suY2FsbCggX29iamVjdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG51bUNoYWluZWRUd2VlbnMgPSBfY2hhaW5lZFR3ZWVucy5sZW5ndGg7IGkgPCBudW1DaGFpbmVkVHdlZW5zOyBpKysgKSB7XG5cblx0XHRcdFx0XHRfY2hhaW5lZFR3ZWVuc1sgaSBdLnN0YXJ0KCB0aW1lICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fTtcblxufTtcblxuXG5UV0VFTi5FYXNpbmcgPSB7XG5cblx0TGluZWFyOiB7XG5cblx0XHROb25lOiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiBrO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0UXVhZHJhdGljOiB7XG5cblx0XHRJbjogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gayAqIGs7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiBrICogKCAyIC0gayApO1xuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdGlmICggKCBrICo9IDIgKSA8IDEgKSByZXR1cm4gMC41ICogayAqIGs7XG5cdFx0XHRyZXR1cm4gLSAwLjUgKiAoIC0tayAqICggayAtIDIgKSAtIDEgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdEN1YmljOiB7XG5cblx0XHRJbjogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gayAqIGsgKiBrO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gLS1rICogayAqIGsgKyAxO1xuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdGlmICggKCBrICo9IDIgKSA8IDEgKSByZXR1cm4gMC41ICogayAqIGsgKiBrO1xuXHRcdFx0cmV0dXJuIDAuNSAqICggKCBrIC09IDIgKSAqIGsgKiBrICsgMiApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0UXVhcnRpYzoge1xuXG5cdFx0SW46IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIGsgKiBrICogayAqIGs7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiAxIC0gKCAtLWsgKiBrICogayAqIGsgKTtcblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRpZiAoICggayAqPSAyICkgPCAxKSByZXR1cm4gMC41ICogayAqIGsgKiBrICogaztcblx0XHRcdHJldHVybiAtIDAuNSAqICggKCBrIC09IDIgKSAqIGsgKiBrICogayAtIDIgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdFF1aW50aWM6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiBrICogayAqIGsgKiBrICogaztcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIC0tayAqIGsgKiBrICogayAqIGsgKyAxO1xuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdGlmICggKCBrICo9IDIgKSA8IDEgKSByZXR1cm4gMC41ICogayAqIGsgKiBrICogayAqIGs7XG5cdFx0XHRyZXR1cm4gMC41ICogKCAoIGsgLT0gMiApICogayAqIGsgKiBrICogayArIDIgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdFNpbnVzb2lkYWw6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiAxIC0gTWF0aC5jb3MoIGsgKiBNYXRoLlBJIC8gMiApO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5zaW4oIGsgKiBNYXRoLlBJIC8gMiApO1xuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiAwLjUgKiAoIDEgLSBNYXRoLmNvcyggTWF0aC5QSSAqIGsgKSApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0RXhwb25lbnRpYWw6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiBrID09PSAwID8gMCA6IE1hdGgucG93KCAxMDI0LCBrIC0gMSApO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gayA9PT0gMSA/IDEgOiAxIC0gTWF0aC5wb3coIDIsIC0gMTAgKiBrICk7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0aWYgKCBrID09PSAwICkgcmV0dXJuIDA7XG5cdFx0XHRpZiAoIGsgPT09IDEgKSByZXR1cm4gMTtcblx0XHRcdGlmICggKCBrICo9IDIgKSA8IDEgKSByZXR1cm4gMC41ICogTWF0aC5wb3coIDEwMjQsIGsgLSAxICk7XG5cdFx0XHRyZXR1cm4gMC41ICogKCAtIE1hdGgucG93KCAyLCAtIDEwICogKCBrIC0gMSApICkgKyAyICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRDaXJjdWxhcjoge1xuXG5cdFx0SW46IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIDEgLSBNYXRoLnNxcnQoIDEgLSBrICogayApO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCAxIC0gKCAtLWsgKiBrICkgKTtcblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRpZiAoICggayAqPSAyICkgPCAxKSByZXR1cm4gLSAwLjUgKiAoIE1hdGguc3FydCggMSAtIGsgKiBrKSAtIDEpO1xuXHRcdFx0cmV0dXJuIDAuNSAqICggTWF0aC5zcXJ0KCAxIC0gKCBrIC09IDIpICogaykgKyAxKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdEVsYXN0aWM6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHZhciBzLCBhID0gMC4xLCBwID0gMC40O1xuXHRcdFx0aWYgKCBrID09PSAwICkgcmV0dXJuIDA7XG5cdFx0XHRpZiAoIGsgPT09IDEgKSByZXR1cm4gMTtcblx0XHRcdGlmICggIWEgfHwgYSA8IDEgKSB7IGEgPSAxOyBzID0gcCAvIDQ7IH1cblx0XHRcdGVsc2UgcyA9IHAgKiBNYXRoLmFzaW4oIDEgLyBhICkgLyAoIDIgKiBNYXRoLlBJICk7XG5cdFx0XHRyZXR1cm4gLSAoIGEgKiBNYXRoLnBvdyggMiwgMTAgKiAoIGsgLT0gMSApICkgKiBNYXRoLnNpbiggKCBrIC0gcyApICogKCAyICogTWF0aC5QSSApIC8gcCApICk7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHZhciBzLCBhID0gMC4xLCBwID0gMC40O1xuXHRcdFx0aWYgKCBrID09PSAwICkgcmV0dXJuIDA7XG5cdFx0XHRpZiAoIGsgPT09IDEgKSByZXR1cm4gMTtcblx0XHRcdGlmICggIWEgfHwgYSA8IDEgKSB7IGEgPSAxOyBzID0gcCAvIDQ7IH1cblx0XHRcdGVsc2UgcyA9IHAgKiBNYXRoLmFzaW4oIDEgLyBhICkgLyAoIDIgKiBNYXRoLlBJICk7XG5cdFx0XHRyZXR1cm4gKCBhICogTWF0aC5wb3coIDIsIC0gMTAgKiBrKSAqIE1hdGguc2luKCAoIGsgLSBzICkgKiAoIDIgKiBNYXRoLlBJICkgLyBwICkgKyAxICk7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0dmFyIHMsIGEgPSAwLjEsIHAgPSAwLjQ7XG5cdFx0XHRpZiAoIGsgPT09IDAgKSByZXR1cm4gMDtcblx0XHRcdGlmICggayA9PT0gMSApIHJldHVybiAxO1xuXHRcdFx0aWYgKCAhYSB8fCBhIDwgMSApIHsgYSA9IDE7IHMgPSBwIC8gNDsgfVxuXHRcdFx0ZWxzZSBzID0gcCAqIE1hdGguYXNpbiggMSAvIGEgKSAvICggMiAqIE1hdGguUEkgKTtcblx0XHRcdGlmICggKCBrICo9IDIgKSA8IDEgKSByZXR1cm4gLSAwLjUgKiAoIGEgKiBNYXRoLnBvdyggMiwgMTAgKiAoIGsgLT0gMSApICkgKiBNYXRoLnNpbiggKCBrIC0gcyApICogKCAyICogTWF0aC5QSSApIC8gcCApICk7XG5cdFx0XHRyZXR1cm4gYSAqIE1hdGgucG93KCAyLCAtMTAgKiAoIGsgLT0gMSApICkgKiBNYXRoLnNpbiggKCBrIC0gcyApICogKCAyICogTWF0aC5QSSApIC8gcCApICogMC41ICsgMTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdEJhY2s6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHZhciBzID0gMS43MDE1ODtcblx0XHRcdHJldHVybiBrICogayAqICggKCBzICsgMSApICogayAtIHMgKTtcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdFx0cmV0dXJuIC0tayAqIGsgKiAoICggcyArIDEgKSAqIGsgKyBzICkgKyAxO1xuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHZhciBzID0gMS43MDE1OCAqIDEuNTI1O1xuXHRcdFx0aWYgKCAoIGsgKj0gMiApIDwgMSApIHJldHVybiAwLjUgKiAoIGsgKiBrICogKCAoIHMgKyAxICkgKiBrIC0gcyApICk7XG5cdFx0XHRyZXR1cm4gMC41ICogKCAoIGsgLT0gMiApICogayAqICggKCBzICsgMSApICogayArIHMgKSArIDIgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdEJvdW5jZToge1xuXG5cdFx0SW46IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIDEgLSBUV0VFTi5FYXNpbmcuQm91bmNlLk91dCggMSAtIGsgKTtcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0aWYgKCBrIDwgKCAxIC8gMi43NSApICkge1xuXG5cdFx0XHRcdHJldHVybiA3LjU2MjUgKiBrICogaztcblxuXHRcdFx0fSBlbHNlIGlmICggayA8ICggMiAvIDIuNzUgKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKCBrIC09ICggMS41IC8gMi43NSApICkgKiBrICsgMC43NTtcblxuXHRcdFx0fSBlbHNlIGlmICggayA8ICggMi41IC8gMi43NSApICkge1xuXG5cdFx0XHRcdHJldHVybiA3LjU2MjUgKiAoIGsgLT0gKCAyLjI1IC8gMi43NSApICkgKiBrICsgMC45Mzc1O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiA3LjU2MjUgKiAoIGsgLT0gKCAyLjYyNSAvIDIuNzUgKSApICogayArIDAuOTg0Mzc1O1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0aWYgKCBrIDwgMC41ICkgcmV0dXJuIFRXRUVOLkVhc2luZy5Cb3VuY2UuSW4oIGsgKiAyICkgKiAwLjU7XG5cdFx0XHRyZXR1cm4gVFdFRU4uRWFzaW5nLkJvdW5jZS5PdXQoIGsgKiAyIC0gMSApICogMC41ICsgMC41O1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxuVFdFRU4uSW50ZXJwb2xhdGlvbiA9IHtcblxuXHRMaW5lYXI6IGZ1bmN0aW9uICggdiwgayApIHtcblxuXHRcdHZhciBtID0gdi5sZW5ndGggLSAxLCBmID0gbSAqIGssIGkgPSBNYXRoLmZsb29yKCBmICksIGZuID0gVFdFRU4uSW50ZXJwb2xhdGlvbi5VdGlscy5MaW5lYXI7XG5cblx0XHRpZiAoIGsgPCAwICkgcmV0dXJuIGZuKCB2WyAwIF0sIHZbIDEgXSwgZiApO1xuXHRcdGlmICggayA+IDEgKSByZXR1cm4gZm4oIHZbIG0gXSwgdlsgbSAtIDEgXSwgbSAtIGYgKTtcblxuXHRcdHJldHVybiBmbiggdlsgaSBdLCB2WyBpICsgMSA+IG0gPyBtIDogaSArIDEgXSwgZiAtIGkgKTtcblxuXHR9LFxuXG5cdEJlemllcjogZnVuY3Rpb24gKCB2LCBrICkge1xuXG5cdFx0dmFyIGIgPSAwLCBuID0gdi5sZW5ndGggLSAxLCBwdyA9IE1hdGgucG93LCBibiA9IFRXRUVOLkludGVycG9sYXRpb24uVXRpbHMuQmVybnN0ZWluLCBpO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPD0gbjsgaSsrICkge1xuXHRcdFx0YiArPSBwdyggMSAtIGssIG4gLSBpICkgKiBwdyggaywgaSApICogdlsgaSBdICogYm4oIG4sIGkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYjtcblxuXHR9LFxuXG5cdENhdG11bGxSb206IGZ1bmN0aW9uICggdiwgayApIHtcblxuXHRcdHZhciBtID0gdi5sZW5ndGggLSAxLCBmID0gbSAqIGssIGkgPSBNYXRoLmZsb29yKCBmICksIGZuID0gVFdFRU4uSW50ZXJwb2xhdGlvbi5VdGlscy5DYXRtdWxsUm9tO1xuXG5cdFx0aWYgKCB2WyAwIF0gPT09IHZbIG0gXSApIHtcblxuXHRcdFx0aWYgKCBrIDwgMCApIGkgPSBNYXRoLmZsb29yKCBmID0gbSAqICggMSArIGsgKSApO1xuXG5cdFx0XHRyZXR1cm4gZm4oIHZbICggaSAtIDEgKyBtICkgJSBtIF0sIHZbIGkgXSwgdlsgKCBpICsgMSApICUgbSBdLCB2WyAoIGkgKyAyICkgJSBtIF0sIGYgLSBpICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoIGsgPCAwICkgcmV0dXJuIHZbIDAgXSAtICggZm4oIHZbIDAgXSwgdlsgMCBdLCB2WyAxIF0sIHZbIDEgXSwgLWYgKSAtIHZbIDAgXSApO1xuXHRcdFx0aWYgKCBrID4gMSApIHJldHVybiB2WyBtIF0gLSAoIGZuKCB2WyBtIF0sIHZbIG0gXSwgdlsgbSAtIDEgXSwgdlsgbSAtIDEgXSwgZiAtIG0gKSAtIHZbIG0gXSApO1xuXG5cdFx0XHRyZXR1cm4gZm4oIHZbIGkgPyBpIC0gMSA6IDAgXSwgdlsgaSBdLCB2WyBtIDwgaSArIDEgPyBtIDogaSArIDEgXSwgdlsgbSA8IGkgKyAyID8gbSA6IGkgKyAyIF0sIGYgLSBpICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRVdGlsczoge1xuXG5cdFx0TGluZWFyOiBmdW5jdGlvbiAoIHAwLCBwMSwgdCApIHtcblxuXHRcdFx0cmV0dXJuICggcDEgLSBwMCApICogdCArIHAwO1xuXG5cdFx0fSxcblxuXHRcdEJlcm5zdGVpbjogZnVuY3Rpb24gKCBuICwgaSApIHtcblxuXHRcdFx0dmFyIGZjID0gVFdFRU4uSW50ZXJwb2xhdGlvbi5VdGlscy5GYWN0b3JpYWw7XG5cdFx0XHRyZXR1cm4gZmMoIG4gKSAvIGZjKCBpICkgLyBmYyggbiAtIGkgKTtcblxuXHRcdH0sXG5cblx0XHRGYWN0b3JpYWw6ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgYSA9IFsgMSBdO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCBuICkge1xuXG5cdFx0XHRcdHZhciBzID0gMSwgaTtcblx0XHRcdFx0aWYgKCBhWyBuIF0gKSByZXR1cm4gYVsgbiBdO1xuXHRcdFx0XHRmb3IgKCBpID0gbjsgaSA+IDE7IGktLSApIHMgKj0gaTtcblx0XHRcdFx0cmV0dXJuIGFbIG4gXSA9IHM7XG5cblx0XHRcdH07XG5cblx0XHR9ICkoKSxcblxuXHRcdENhdG11bGxSb206IGZ1bmN0aW9uICggcDAsIHAxLCBwMiwgcDMsIHQgKSB7XG5cblx0XHRcdHZhciB2MCA9ICggcDIgLSBwMCApICogMC41LCB2MSA9ICggcDMgLSBwMSApICogMC41LCB0MiA9IHQgKiB0LCB0MyA9IHQgKiB0Mjtcblx0XHRcdHJldHVybiAoIDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEgKSAqIHQzICsgKCAtIDMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxubW9kdWxlLmV4cG9ydHM9VFdFRU47IiwiLyoqXG4gKiBBUzMvanF1ZXJ5IHN0eWxlIGV2ZW50IGRpc3BhdGNoZXIuIFNsaWdodGx5IG1vZGlmaWVkLiBUaGVcbiAqIGpxdWVyeSBzdHlsZSBvbi9vZmYvdHJpZ2dlciBzdHlsZSBvZiBhZGRpbmcgbGlzdGVuZXJzIGlzXG4gKiBjdXJyZW50bHkgdGhlIHByZWZlcnJlZCBvbmUuXG4gKlxuICogVGhlIG9uIG1ldGhvZCBmb3IgYWRkaW5nIGxpc3RlbmVycyB0YWtlcyBhbiBleHRyYSBwYXJhbWV0ZXIgd2hpY2ggaXMgdGhlXG4gKiBzY29wZSBpbiB3aGljaCBsaXN0ZW5lcnMgc2hvdWxkIGJlIGNhbGxlZC4gU28gdGhpczpcbiAqXG4gKiAgICAgb2JqZWN0Lm9uKFwiZXZlbnRcIiwgbGlzdGVuZXIsIHRoaXMpO1xuICpcbiAqIEhhcyB0aGUgc2FtZSBmdW5jdGlvbiB3aGVuIGFkZGluZyBldmVudHMgYXM6XG4gKlxuICogICAgIG9iamVjdC5vbihcImV2ZW50XCIsIGxpc3RlbmVyLmJpbmQodGhpcykpO1xuICpcbiAqIEhvd2V2ZXIsIHRoZSBkaWZmZXJlbmNlIGlzIHRoYXQgaWYgd2UgdXNlIHRoZSBzZWNvbmQgbWV0aG9kIGl0XG4gKiB3aWxsIG5vdCBiZSBwb3NzaWJsZSB0byByZW1vdmUgdGhlIGxpc3RlbmVycyBsYXRlciwgdW5sZXNzXG4gKiB0aGUgY2xvc3VyZSBjcmVhdGVkIGJ5IGJpbmQgaXMgc3RvcmVkIHNvbWV3aGVyZS4gSWYgdGhlXG4gKiBmaXJzdCBtZXRob2QgaXMgdXNlZCwgd2UgY2FuIHJlbW92ZSB0aGUgbGlzdGVuZXIgd2l0aDpcbiAqXG4gKiAgICAgb2JqZWN0Lm9mZihcImV2ZW50XCIsIGxpc3RlbmVyLCB0aGlzKTtcbiAqXG4gKiBAY2xhc3MgRXZlbnREaXNwYXRjaGVyXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RGlzcGF0Y2hlcigpIHtcblx0dGhpcy5saXN0ZW5lck1hcCA9IHt9O1xufVxuXG4vKipcbiAqIEFkZCBldmVudCBsaXN0ZW5lci5cbiAqIEBtZXRob2QgYWRkRXZlbnRMaXN0ZW5lclxuICovXG5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyLCBzY29wZSkge1xuXHRpZiAoIXRoaXMubGlzdGVuZXJNYXApXG5cdFx0dGhpcy5saXN0ZW5lck1hcCA9IHt9O1xuXG5cdGlmICghZXZlbnRUeXBlKVxuXHRcdHRocm93IG5ldyBFcnJvcihcIkV2ZW50IHR5cGUgcmVxdWlyZWQgZm9yIGV2ZW50IGRpc3BhdGNoZXJcIik7XG5cblx0aWYgKCFsaXN0ZW5lcilcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJMaXN0ZW5lciByZXF1aXJlZCBmb3IgZXZlbnQgZGlzcGF0Y2hlclwiKTtcblxuXHR0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lciwgc2NvcGUpO1xuXG5cdGlmICghdGhpcy5saXN0ZW5lck1hcC5oYXNPd25Qcm9wZXJ0eShldmVudFR5cGUpKVxuXHRcdHRoaXMubGlzdGVuZXJNYXBbZXZlbnRUeXBlXSA9IFtdO1xuXG5cdHRoaXMubGlzdGVuZXJNYXBbZXZlbnRUeXBlXS5wdXNoKHtcblx0XHRsaXN0ZW5lcjogbGlzdGVuZXIsXG5cdFx0c2NvcGU6IHNjb3BlXG5cdH0pO1xufVxuXG4vKipcbiAqIFJlbW92ZSBldmVudCBsaXN0ZW5lci5cbiAqIEBtZXRob2QgcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICovXG5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyLCBzY29wZSkge1xuXHRpZiAoIXRoaXMubGlzdGVuZXJNYXApXG5cdFx0dGhpcy5saXN0ZW5lck1hcCA9IHt9O1xuXG5cdGlmICghdGhpcy5saXN0ZW5lck1hcC5oYXNPd25Qcm9wZXJ0eShldmVudFR5cGUpKVxuXHRcdHJldHVybjtcblxuXHR2YXIgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lck1hcFtldmVudFR5cGVdO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGxpc3RlbmVyT2JqID0gbGlzdGVuZXJzW2ldO1xuXG5cdFx0aWYgKGxpc3RlbmVyID09IGxpc3RlbmVyT2JqLmxpc3RlbmVyICYmIHNjb3BlID09IGxpc3RlbmVyT2JqLnNjb3BlKSB7XG5cdFx0XHRsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0aS0tO1xuXHRcdH1cblx0fVxuXG5cdGlmICghbGlzdGVuZXJzLmxlbmd0aClcblx0XHRkZWxldGUgdGhpcy5saXN0ZW5lck1hcFtldmVudFR5cGVdO1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGV2ZW50LlxuICogQG1ldGhvZCBkaXNwYXRjaEV2ZW50XG4gKi9cbkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50IC8qIC4uLiAqLyApIHtcblx0aWYgKCF0aGlzLmxpc3RlbmVyTWFwKVxuXHRcdHRoaXMubGlzdGVuZXJNYXAgPSB7fTtcblxuXHR2YXIgZXZlbnRUeXBlO1xuXHR2YXIgbGlzdGVuZXJQYXJhbXM7XG5cblx0aWYgKHR5cGVvZiBldmVudCA9PSBcInN0cmluZ1wiKSB7XG5cdFx0ZXZlbnRUeXBlID0gZXZlbnQ7XG5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpXG5cdFx0XHRsaXN0ZW5lclBhcmFtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cblx0XHRlbHNlIGxpc3RlbmVyUGFyYW1zID0gW3tcblx0XHRcdHR5cGU6IGV2ZW50VHlwZSxcblx0XHRcdHRhcmdldDogdGhpc1xuXHRcdH1dO1xuXHR9IGVsc2Uge1xuXHRcdGV2ZW50VHlwZSA9IGV2ZW50LnR5cGU7XG5cdFx0ZXZlbnQudGFyZ2V0ID0gdGhpcztcblx0XHRsaXN0ZW5lclBhcmFtcyA9IFtldmVudF07XG5cdH1cblxuXHRpZiAoIXRoaXMubGlzdGVuZXJNYXAuaGFzT3duUHJvcGVydHkoZXZlbnRUeXBlKSlcblx0XHRyZXR1cm47XG5cblx0dmFyIG1hcCA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGlzdGVuZXJNYXBbZXZlbnRUeXBlXS5sZW5ndGg7IGkrKylcblx0XHRtYXAucHVzaCh0aGlzLmxpc3RlbmVyTWFwW2V2ZW50VHlwZV1baV0pXG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXAubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgbGlzdGVuZXJPYmogPSBtYXBbaV07XG5cdFx0bGlzdGVuZXJPYmoubGlzdGVuZXIuYXBwbHkobGlzdGVuZXJPYmouc2NvcGUsIGxpc3RlbmVyUGFyYW1zKTtcblx0fVxufVxuXG4vKipcbiAqIEpxdWVyeSBzdHlsZSBhbGlhcyBmb3IgYWRkRXZlbnRMaXN0ZW5lclxuICogQG1ldGhvZCBvblxuICovXG5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLm9uID0gRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuXG4vKipcbiAqIEpxdWVyeSBzdHlsZSBhbGlhcyBmb3IgcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICogQG1ldGhvZCBvZmZcbiAqL1xuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cbi8qKlxuICogSnF1ZXJ5IHN0eWxlIGFsaWFzIGZvciBkaXNwYXRjaEV2ZW50XG4gKiBAbWV0aG9kIHRyaWdnZXJcbiAqL1xuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS50cmlnZ2VyID0gRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50O1xuXG4vKipcbiAqIE1ha2Ugc29tZXRoaW5nIGFuIGV2ZW50IGRpc3BhdGNoZXIuIENhbiBiZSB1c2VkIGZvciBtdWx0aXBsZSBpbmhlcml0YW5jZS5cbiAqIEBtZXRob2QgaW5pdFxuICogQHN0YXRpY1xuICovXG5FdmVudERpc3BhdGNoZXIuaW5pdCA9IGZ1bmN0aW9uKGNscykge1xuXHRjbHMucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XG5cdGNscy5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblx0Y2xzLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50O1xuXHRjbHMucHJvdG90eXBlLm9uID0gRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5vbjtcblx0Y2xzLnByb3RvdHlwZS5vZmYgPSBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLm9mZjtcblx0Y2xzLnByb3RvdHlwZS50cmlnZ2VyID0gRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS50cmlnZ2VyO1xufVxuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBFdmVudERpc3BhdGNoZXI7XG59IiwiLyoqXG4gKiBDbGllbnQuXG4gKiBAbW9kdWxlIGNsaWVudFxuICovXG5cbnZhciBTaG93RGlhbG9nTWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9TaG93RGlhbG9nTWVzc2FnZVwiKTtcbnZhciBCdXR0b25zTWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9CdXR0b25zTWVzc2FnZVwiKTtcbnZhciBDaGF0TWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9DaGF0TWVzc2FnZVwiKTtcbnZhciBUYWJsZUluZm9NZXNzYWdlID0gcmVxdWlyZShcIi4uLy4uL3Byb3RvL21lc3NhZ2VzL1RhYmxlSW5mb01lc3NhZ2VcIik7XG52YXIgSGFuZEluZm9NZXNzYWdlID0gcmVxdWlyZShcIi4uLy4uL3Byb3RvL21lc3NhZ2VzL0hhbmRJbmZvTWVzc2FnZVwiKTtcbnZhciBQcmVzZXRCdXR0b25zTWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9QcmVzZXRCdXR0b25zTWVzc2FnZVwiKTtcbnZhciBJbnRlcmZhY2VTdGF0ZU1lc3NhZ2UgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vbWVzc2FnZXMvSW50ZXJmYWNlU3RhdGVNZXNzYWdlXCIpO1xudmFyIENoZWNrYm94TWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9DaGVja2JveE1lc3NhZ2VcIik7XG52YXIgUHJlVG91cm5hbWVudEluZm9NZXNzYWdlID0gcmVxdWlyZShcIi4uLy4uL3Byb3RvL21lc3NhZ2VzL1ByZVRvdXJuYW1lbnRJbmZvTWVzc2FnZVwiKTtcblxuLyoqXG4gKiBDb250cm9sIHVzZXIgaW50ZXJmYWNlLlxuICogQGNsYXNzIEludGVyZmFjZUNvbnRyb2xsZXJcbiAqL1xuZnVuY3Rpb24gSW50ZXJmYWNlQ29udHJvbGxlcihtZXNzYWdlU2VxdWVuY2VyLCB2aWV3KSB7XG5cdHRoaXMubWVzc2FnZVNlcXVlbmNlciA9IG1lc3NhZ2VTZXF1ZW5jZXI7XG5cdHRoaXMudmlldyA9IHZpZXc7XG5cblx0dGhpcy5tZXNzYWdlU2VxdWVuY2VyLmFkZE1lc3NhZ2VIYW5kbGVyKEJ1dHRvbnNNZXNzYWdlLlRZUEUsIHRoaXMub25CdXR0b25zTWVzc2FnZSwgdGhpcyk7XG5cdHRoaXMubWVzc2FnZVNlcXVlbmNlci5hZGRNZXNzYWdlSGFuZGxlcihTaG93RGlhbG9nTWVzc2FnZS5UWVBFLCB0aGlzLm9uU2hvd0RpYWxvZ01lc3NhZ2UsIHRoaXMpO1xuXHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIuYWRkTWVzc2FnZUhhbmRsZXIoQ2hhdE1lc3NhZ2UuVFlQRSwgdGhpcy5vbkNoYXQsIHRoaXMpO1xuXHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIuYWRkTWVzc2FnZUhhbmRsZXIoVGFibGVJbmZvTWVzc2FnZS5UWVBFLCB0aGlzLm9uVGFibGVJbmZvTWVzc2FnZSwgdGhpcyk7XG5cdHRoaXMubWVzc2FnZVNlcXVlbmNlci5hZGRNZXNzYWdlSGFuZGxlcihIYW5kSW5mb01lc3NhZ2UuVFlQRSwgdGhpcy5vbkhhbmRJbmZvTWVzc2FnZSwgdGhpcyk7XG5cdHRoaXMubWVzc2FnZVNlcXVlbmNlci5hZGRNZXNzYWdlSGFuZGxlcihJbnRlcmZhY2VTdGF0ZU1lc3NhZ2UuVFlQRSwgdGhpcy5vbkludGVyZmFjZVN0YXRlTWVzc2FnZSwgdGhpcyk7XG5cdHRoaXMubWVzc2FnZVNlcXVlbmNlci5hZGRNZXNzYWdlSGFuZGxlcihDaGVja2JveE1lc3NhZ2UuVFlQRSwgdGhpcy5vbkNoZWNrYm94TWVzc2FnZSwgdGhpcyk7XG5cdHRoaXMubWVzc2FnZVNlcXVlbmNlci5hZGRNZXNzYWdlSGFuZGxlcihQcmVUb3VybmFtZW50SW5mb01lc3NhZ2UuVFlQRSwgdGhpcy5vblByZVRvdXJuYW1lbnRJbmZvTWVzc2FnZSwgdGhpcyk7XG5cblx0dGhpcy5tZXNzYWdlU2VxdWVuY2VyLmFkZE1lc3NhZ2VIYW5kbGVyKFByZXNldEJ1dHRvbnNNZXNzYWdlLlRZUEUsIHRoaXMub25QcmVzZXRCdXR0b25zLCB0aGlzKTtcbn1cblxuLyoqXG4gKiBCdXR0b25zIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIG9uQnV0dG9uc01lc3NhZ2VcbiAqL1xuSW50ZXJmYWNlQ29udHJvbGxlci5wcm90b3R5cGUub25CdXR0b25zTWVzc2FnZSA9IGZ1bmN0aW9uKG0pIHtcblx0dmFyIGJ1dHRvbnNWaWV3ID0gdGhpcy52aWV3LmdldEJ1dHRvbnNWaWV3KCk7XG5cblx0YnV0dG9uc1ZpZXcuc2V0QnV0dG9ucyhtLmdldEJ1dHRvbnMoKSwgbS5zbGlkZXJCdXR0b25JbmRleCwgcGFyc2VJbnQobS5taW4sIDEwKSwgcGFyc2VJbnQobS5tYXgsIDEwKSk7XG59XG5cbi8qKlxuICogUHJlc2V0QnV0dG9ucyBtZXNzYWdlLlxuICogQG1ldGhvZCBvblByZXNldEJ1dHRvbnNcbiAqL1xuSW50ZXJmYWNlQ29udHJvbGxlci5wcm90b3R5cGUub25QcmVzZXRCdXR0b25zID0gZnVuY3Rpb24obSkge1xuXHR2YXIgcHJlc2V0QnV0dG9uc1ZpZXcgPSB0aGlzLnZpZXcuZ2V0UHJlc2V0QnV0dG9uc1ZpZXcoKTtcblxuXHR2YXIgYnV0dG9ucyA9IHByZXNldEJ1dHRvbnNWaWV3LmdldEJ1dHRvbnMoKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBidXR0b25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKGkgPiBtLmJ1dHRvbnMubGVuZ3RoKSB7XG5cdFx0XHRidXR0b25zW2ldLmhpZGUoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGRhdGEgPSBtLmJ1dHRvbnNbaV07XG5cblx0XHRcdGlmIChkYXRhID09IG51bGwpIHtcblx0XHRcdFx0YnV0dG9uc1tpXS5oaWRlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidXR0b25zW2ldLnNob3coZGF0YS5idXR0b24sIGRhdGEudmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHByZXNldEJ1dHRvbnNWaWV3LnNldEN1cnJlbnQobS5jdXJyZW50KTtcbn1cblxuLyoqXG4gKiBTaG93IGRpYWxvZy5cbiAqIEBtZXRob2Qgb25TaG93RGlhbG9nTWVzc2FnZVxuICovXG5JbnRlcmZhY2VDb250cm9sbGVyLnByb3RvdHlwZS5vblNob3dEaWFsb2dNZXNzYWdlID0gZnVuY3Rpb24obSkge1xuXHR2YXIgZGlhbG9nVmlldyA9IHRoaXMudmlldy5nZXREaWFsb2dWaWV3KCk7XG5cblx0ZGlhbG9nVmlldy5zaG93KG0uZ2V0VGV4dCgpLCBtLmdldEJ1dHRvbnMoKSwgbS5nZXREZWZhdWx0VmFsdWUoKSk7XG59XG5cblxuLyoqXG4gKiBPbiBjaGF0IG1lc3NhZ2UuXG4gKiBAbWV0aG9kIG9uQ2hhdFxuICovXG5JbnRlcmZhY2VDb250cm9sbGVyLnByb3RvdHlwZS5vbkNoYXQgPSBmdW5jdGlvbihtKSB7XG5cdHRoaXMudmlldy5jaGF0Vmlldy5hZGRUZXh0KG0udXNlciwgbS50ZXh0KTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgdGFibGUgaW5mbyBtZXNzYWdlLlxuICogQG1ldGhvZCBvblRhYmxlSW5mb01lc3NhZ2VcbiAqL1xuSW50ZXJmYWNlQ29udHJvbGxlci5wcm90b3R5cGUub25UYWJsZUluZm9NZXNzYWdlID0gZnVuY3Rpb24obSkge1xuXHR2YXIgdGFibGVJbmZvVmlldyA9IHRoaXMudmlldy5nZXRUYWJsZUluZm9WaWV3KCk7XG5cblx0dGFibGVJbmZvVmlldy5zZXRUYWJsZUluZm9UZXh0KG0uZ2V0VGV4dCgpKTtcblx0dGFibGVJbmZvVmlldy5zZXRKb2luQnV0dG9uVmlzaWJsZShtLmdldFNob3dKb2luQnV0dG9uKCkpO1xuXHR0YWJsZUluZm9WaWV3LnNldExlYXZlQnV0dG9uVmlzaWJsZShtLmdldFNob3dMZWF2ZUJ1dHRvbigpKTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgaGFuZCBpbmZvIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIG9uSGFuZEluZm9NZXNzYWdlXG4gKi9cbkludGVyZmFjZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uSGFuZEluZm9NZXNzYWdlID0gZnVuY3Rpb24obSkge1xuXHR2YXIgdGFibGVJbmZvVmlldyA9IHRoaXMudmlldy5nZXRUYWJsZUluZm9WaWV3KCk7XG5cblx0dGFibGVJbmZvVmlldy5zZXRIYW5kSW5mb1RleHQobS5nZXRUZXh0KCkpO1xufVxuXG4vKipcbiAqIEhhbmRsZSBpbnRlcmZhY2Ugc3RhdGUgbWVzc2FnZS5cbiAqIEBtZXRob2Qgb25JbnRlcmZhY2VTdGF0ZU1lc3NhZ2VcbiAqL1xuSW50ZXJmYWNlQ29udHJvbGxlci5wcm90b3R5cGUub25JbnRlcmZhY2VTdGF0ZU1lc3NhZ2UgPSBmdW5jdGlvbihtKSB7XG5cdHZhciBzZXR0aW5nc1ZpZXcgPSB0aGlzLnZpZXcuZ2V0U2V0dGluZ3NWaWV3KCk7XG5cblx0c2V0dGluZ3NWaWV3LnNldFZpc2libGVCdXR0b25zKG0uZ2V0VmlzaWJsZUJ1dHRvbnMoKSk7XG59XG5cbi8qKlxuICogSGFuZGxlIGNoZWNrYm94IG1lc3NhZ2UuXG4gKiBAbWV0aG9kIG9uQ2hlY2tib3hNZXNzYWdlXG4gKi9cbkludGVyZmFjZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uQ2hlY2tib3hNZXNzYWdlID0gZnVuY3Rpb24obSkge1xuXHRjb25zb2xlLmxvZyhtKTtcblxuXHR2YXIgc2V0dGluZ3NWaWV3ID0gdGhpcy52aWV3LmdldFNldHRpbmdzVmlldygpO1xuXG5cdHNldHRpbmdzVmlldy5zZXRDaGVja2JveENoZWNrZWQobS5nZXRJZCgpLCBtLmdldENoZWNrZWQoKSk7XG59XG5cbi8qKlxuICogSGFuZGxlIHByZSB0b3J1bmFtZW50IGluZm8gbWVzc2FnZS5cbiAqIEBtZXRob2Qgb25QcmVUb3VybmFtZW50SW5mb01lc3NhZ2VcbiAqL1xuSW50ZXJmYWNlQ29udHJvbGxlci5wcm90b3R5cGUub25QcmVUb3VybmFtZW50SW5mb01lc3NhZ2UgPSBmdW5jdGlvbihtKSB7XG5cdHZhciB0YWJsZUluZm9WaWV3ID0gdGhpcy52aWV3LmdldFRhYmxlSW5mb1ZpZXcoKTtcblxuXHR0YWJsZUluZm9WaWV3LnNldFByZVRvdXJuYW1lbnRJbmZvVGV4dChtLmdldFRleHQoKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJmYWNlQ29udHJvbGxlcjsiLCIvKipcbiAqIENsaWVudC5cbiAqIEBtb2R1bGUgY2xpZW50XG4gKi9cblxudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoXCJ5YWVkXCIpO1xudmFyIFNlcXVlbmNlciA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9TZXF1ZW5jZXJcIik7XG52YXIgaW5oZXJpdHM9cmVxdWlyZShcImluaGVyaXRzXCIpO1xuXG4vKipcbiAqIEFuIGl0ZW0gaW4gYSBtZXNzYWdlIHNlcXVlbmNlLlxuICogQGNsYXNzIE1lc3NhZ2VTZXF1ZW5jZUl0ZW1cbiAqL1xuZnVuY3Rpb24gTWVzc2FnZVNlcXVlbmNlSXRlbShtZXNzYWdlKSB7XG5cdEV2ZW50RGlzcGF0Y2hlci5jYWxsKHRoaXMpO1xuXHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXHR0aGlzLndhaXRUYXJnZXQgPSBudWxsO1xuXHR0aGlzLndhaXRFdmVudCA9IG51bGw7XG5cdHRoaXMud2FpdENsb3N1cmUgPSBudWxsO1xufVxuXG5pbmhlcml0cyhNZXNzYWdlU2VxdWVuY2VJdGVtLCBFdmVudERpc3BhdGNoZXIpO1xuXG4vKipcbiAqIEdldCBtZXNzYWdlLlxuICogQG1ldGhvZCBnZXRNZXNzYWdlXG4gKi9cbk1lc3NhZ2VTZXF1ZW5jZUl0ZW0ucHJvdG90eXBlLmdldE1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcblx0Ly9jb25zb2xlLmxvZyhcImdldHRpbmc6IFwiICsgdGhpcy5tZXNzYWdlLnR5cGUpO1xuXG5cdHJldHVybiB0aGlzLm1lc3NhZ2U7XG59XG5cbi8qKlxuICogQXJlIHdlIHdhaXRpbmcgZm9yIGFuIGV2ZW50P1xuICogQG1ldGhvZCBpc1dhaXRpbmdcbiAqL1xuTWVzc2FnZVNlcXVlbmNlSXRlbS5wcm90b3R5cGUuaXNXYWl0aW5nID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLndhaXRFdmVudCAhPSBudWxsO1xufVxuXG4vKipcbiAqIE5vdGlmeSBjb21wbGV0ZS5cbiAqIEBtZXRob2Qgbm90aWZ5Q29tcGxldGVcbiAqL1xuTWVzc2FnZVNlcXVlbmNlSXRlbS5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0dGhpcy50cmlnZ2VyKFNlcXVlbmNlci5DT01QTEVURSk7XG59XG5cbi8qKlxuICogV2FpdCBmb3IgZXZlbnQgYmVmb3JlIHByb2Nlc3NpbmcgbmV4dCBtZXNzYWdlLlxuICogQG1ldGhvZCB3YWl0Rm9yXG4gKi9cbk1lc3NhZ2VTZXF1ZW5jZUl0ZW0ucHJvdG90eXBlLndhaXRGb3IgPSBmdW5jdGlvbih0YXJnZXQsIGV2ZW50KSB7XG5cdHRoaXMud2FpdFRhcmdldCA9IHRhcmdldDtcblx0dGhpcy53YWl0RXZlbnQgPSBldmVudDtcblx0dGhpcy53YWl0Q2xvc3VyZSA9IHRoaXMub25UYXJnZXRDb21wbGV0ZS5iaW5kKHRoaXMpO1xuXG5cdHRoaXMud2FpdFRhcmdldC5hZGRFdmVudExpc3RlbmVyKHRoaXMud2FpdEV2ZW50LCB0aGlzLndhaXRDbG9zdXJlKTtcbn1cblxuLyoqXG4gKiBXYWl0IHRhcmdldCBjb21wbGV0ZS5cbiAqIEBtZXRob2Qgb25UYXJnZXRDb21wbGV0ZVxuICogQHByaXZhdGVcbiAqL1xuTWVzc2FnZVNlcXVlbmNlSXRlbS5wcm90b3R5cGUub25UYXJnZXRDb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHQvL2NvbnNvbGUubG9nKFwidGFyZ2V0IGlzIGNvbXBsZXRlXCIpO1xuXHR0aGlzLndhaXRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLndhaXRFdmVudCwgdGhpcy53YWl0Q2xvc3VyZSk7XG5cdHRoaXMubm90aWZ5Q29tcGxldGUoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlU2VxdWVuY2VJdGVtOyIsIi8qKlxuICogQ2xpZW50LlxuICogQG1vZHVsZSBjbGllbnRcbiAqL1xuXG52YXIgU2VxdWVuY2VyID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL1NlcXVlbmNlclwiKTtcbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKFwieWFlZFwiKTtcbnZhciBNZXNzYWdlU2VxdWVuY2VJdGVtID0gcmVxdWlyZShcIi4vTWVzc2FnZVNlcXVlbmNlSXRlbVwiKTtcblxuLyoqXG4gKiBTZXF1ZW5jZXMgbWVzc2FnZXMuXG4gKiBAY2xhc3MgTWVzc2FnZVNlcXVlbmNlclxuICovXG5mdW5jdGlvbiBNZXNzYWdlU2VxdWVuY2VyKCkge1xuXHR0aGlzLnNlcXVlbmNlciA9IG5ldyBTZXF1ZW5jZXIoKTtcblx0dGhpcy5tZXNzYWdlRGlzcGF0Y2hlciA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcblx0dGhpcy5jdXJyZW50SXRlbSA9IG51bGw7XG59XG5cbi8qKlxuICogQWRkIGEgbWVzc2FnZSBmb3IgcHJvY2VzaW5nLlxuICogQG1ldGhvZCBlbnF1ZXVlXG4gKi9cbk1lc3NhZ2VTZXF1ZW5jZXIucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdGlmICghbWVzc2FnZS50eXBlKVxuXHRcdHRocm93IFwiTWVzc2FnZSBkb2Vzbid0IGhhdmUgYSB0eXBlXCI7XG5cblx0dmFyIHNlcXVlbmNlSXRlbSA9IG5ldyBNZXNzYWdlU2VxdWVuY2VJdGVtKG1lc3NhZ2UpO1xuXG5cdHNlcXVlbmNlSXRlbS5vbihTZXF1ZW5jZXIuU1RBUlQsIHRoaXMub25TZXF1ZW5jZUl0ZW1TdGFydCwgdGhpcyk7XG5cblx0dGhpcy5zZXF1ZW5jZXIuZW5xdWV1ZShzZXF1ZW5jZUl0ZW0pO1xufVxuXG4vKipcbiAqIFNlcXVlbmNlIGl0ZW0gc3RhcnQuXG4gKiBAbWV0aG9kIG9uU2VxdWVuY2VJdGVtU3RhcnRcbiAqIEBwcml2YXRlXG4gKi9cbk1lc3NhZ2VTZXF1ZW5jZXIucHJvdG90eXBlLm9uU2VxdWVuY2VJdGVtU3RhcnQgPSBmdW5jdGlvbihlKSB7XG5cdC8vY29uc29sZS5sb2coXCJzdGFydGluZyBpdGVtLi4uXCIpO1xuXHR2YXIgaXRlbSA9IGUudGFyZ2V0O1xuXG5cdGl0ZW0ub2ZmKFNlcXVlbmNlci5TVEFSVCwgdGhpcy5vblNlcXVlbmNlSXRlbVN0YXJ0LCB0aGlzKTtcblxuXHR0aGlzLmN1cnJlbnRJdGVtID0gaXRlbTtcblx0dGhpcy5tZXNzYWdlRGlzcGF0Y2hlci50cmlnZ2VyKGl0ZW0uZ2V0TWVzc2FnZSgpKTtcblx0dGhpcy5jdXJyZW50SXRlbSA9IG51bGw7XG5cblx0aWYgKCFpdGVtLmlzV2FpdGluZygpKVxuXHRcdGl0ZW0ubm90aWZ5Q29tcGxldGUoKTtcbn1cblxuLyoqXG4gKiBBZGQgbWVzc2FnZSBoYW5kbGVyLlxuICogQG1ldGhvZCBhZGRNZXNzYWdlSGFuZGxlclxuICovXG5NZXNzYWdlU2VxdWVuY2VyLnByb3RvdHlwZS5hZGRNZXNzYWdlSGFuZGxlciA9IGZ1bmN0aW9uKG1lc3NhZ2VUeXBlLCBoYW5kbGVyLCBzY29wZSkge1xuXHR0aGlzLm1lc3NhZ2VEaXNwYXRjaGVyLm9uKG1lc3NhZ2VUeXBlLCBoYW5kbGVyLCBzY29wZSk7XG59XG5cbi8qKlxuICogV2FpdCBmb3IgdGhlIHRhcmdldCB0byBkaXNwYXRjaCBhbiBldmVudCBiZWZvcmUgY29udGludWluZyB0b1xuICogcHJvY2VzcyB0aGUgbWVzc2FnZXMgaW4gdGhlIHF1ZS5cbiAqIEBtZXRob2Qgd2FpdEZvclxuICovXG5NZXNzYWdlU2VxdWVuY2VyLnByb3RvdHlwZS53YWl0Rm9yID0gZnVuY3Rpb24odGFyZ2V0LCBldmVudCkge1xuXHRpZiAoIXRoaXMuY3VycmVudEl0ZW0pXG5cdFx0dGhyb3cgXCJOb3Qgd2FpdGluZyBmb3IgZXZlbnRcIjtcblxuXHR0aGlzLmN1cnJlbnRJdGVtLndhaXRGb3IodGFyZ2V0LCBldmVudCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZVNlcXVlbmNlcjsiLCIvKipcbiAqIENsaWVudC5cbiAqIEBtb2R1bGUgY2xpZW50XG4gKi9cblxudmFyIE1lc3NhZ2VTZXF1ZW5jZXIgPSByZXF1aXJlKFwiLi9NZXNzYWdlU2VxdWVuY2VyXCIpO1xudmFyIFByb3RvQ29ubmVjdGlvbiA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9Qcm90b0Nvbm5lY3Rpb25cIik7XG52YXIgQnV0dG9uc1ZpZXcgPSByZXF1aXJlKFwiLi4vdmlldy9CdXR0b25zVmlld1wiKTtcbnZhciBCdXR0b25DbGlja01lc3NhZ2UgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vbWVzc2FnZXMvQnV0dG9uQ2xpY2tNZXNzYWdlXCIpO1xudmFyIFNlYXRDbGlja01lc3NhZ2UgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vbWVzc2FnZXMvU2VhdENsaWNrTWVzc2FnZVwiKTtcbnZhciBQcmVzZXRCdXR0b25DbGlja01lc3NhZ2UgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vbWVzc2FnZXMvUHJlc2V0QnV0dG9uQ2xpY2tNZXNzYWdlXCIpO1xudmFyIE5ldFBva2VyQ2xpZW50VmlldyA9IHJlcXVpcmUoXCIuLi92aWV3L05ldFBva2VyQ2xpZW50Vmlld1wiKTtcbnZhciBEaWFsb2dWaWV3ID0gcmVxdWlyZShcIi4uL3ZpZXcvRGlhbG9nVmlld1wiKTtcbnZhciBUYWJsZUluZm9WaWV3ID0gcmVxdWlyZShcIi4uL3ZpZXcvVGFibGVJbmZvVmlld1wiKTtcbnZhciBTZXR0aW5nc1ZpZXcgPSByZXF1aXJlKFwiLi4vdmlldy9TZXR0aW5nc1ZpZXdcIik7XG52YXIgVGFibGVDb250cm9sbGVyID0gcmVxdWlyZShcIi4vVGFibGVDb250cm9sbGVyXCIpO1xudmFyIEludGVyZmFjZUNvbnRyb2xsZXIgPSByZXF1aXJlKFwiLi9JbnRlcmZhY2VDb250cm9sbGVyXCIpO1xudmFyIENoYXRNZXNzYWdlID0gcmVxdWlyZShcIi4uLy4uL3Byb3RvL21lc3NhZ2VzL0NoYXRNZXNzYWdlXCIpO1xudmFyIENoZWNrYm94TWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9DaGVja2JveE1lc3NhZ2VcIik7XG52YXIgQnV0dG9uRGF0YSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9kYXRhL0J1dHRvbkRhdGFcIik7XG52YXIgUHJlc2V0QnV0dG9uc1ZpZXcgPSByZXF1aXJlKFwiLi4vdmlldy9QcmVzZXRCdXR0b25zVmlld1wiKTtcblxuLyoqXG4gKiBNYWluIGNvbnRyb2xsZXJcbiAqIEBjbGFzcyBOZXRQb2tlckNsaWVudENvbnRyb2xsZXJcbiAqL1xuZnVuY3Rpb24gTmV0UG9rZXJDbGllbnRDb250cm9sbGVyKHZpZXcpIHtcblx0dGhpcy5uZXRQb2tlckNsaWVudFZpZXcgPSB2aWV3O1xuXHR0aGlzLnByb3RvQ29ubmVjdGlvbiA9IG51bGw7XG5cdHRoaXMubWVzc2FnZVNlcXVlbmNlciA9IG5ldyBNZXNzYWdlU2VxdWVuY2VyKCk7XG5cblx0dGhpcy50YWJsZUNvbnRyb2xsZXIgPSBuZXcgVGFibGVDb250cm9sbGVyKHRoaXMubWVzc2FnZVNlcXVlbmNlciwgdGhpcy5uZXRQb2tlckNsaWVudFZpZXcpO1xuXHR0aGlzLmludGVyZmFjZUNvbnRyb2xsZXIgPSBuZXcgSW50ZXJmYWNlQ29udHJvbGxlcih0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIsIHRoaXMubmV0UG9rZXJDbGllbnRWaWV3KTtcblxuXHQvL2NvbnNvbGUubG9nKHRoaXMubmV0UG9rZXJDbGllbnRWaWV3LmdldERpYWxvZ1ZpZXcoKSk7XG5cblx0dGhpcy5uZXRQb2tlckNsaWVudFZpZXcuZ2V0QnV0dG9uc1ZpZXcoKS5vbihCdXR0b25zVmlldy5CVVRUT05fQ0xJQ0ssIHRoaXMub25CdXR0b25DbGljaywgdGhpcyk7XG5cdHRoaXMubmV0UG9rZXJDbGllbnRWaWV3LmdldFRhYmxlSW5mb1ZpZXcoKS5vbihUYWJsZUluZm9WaWV3LkJVVFRPTl9DTElDSywgdGhpcy5vbkJ1dHRvbkNsaWNrLCB0aGlzKTtcblx0dGhpcy5uZXRQb2tlckNsaWVudFZpZXcuZ2V0RGlhbG9nVmlldygpLm9uKERpYWxvZ1ZpZXcuQlVUVE9OX0NMSUNLLCB0aGlzLm9uQnV0dG9uQ2xpY2ssIHRoaXMpO1xuXHR0aGlzLm5ldFBva2VyQ2xpZW50Vmlldy5vbihOZXRQb2tlckNsaWVudFZpZXcuU0VBVF9DTElDSywgdGhpcy5vblNlYXRDbGljaywgdGhpcyk7XG5cblx0dGhpcy5uZXRQb2tlckNsaWVudFZpZXcuY2hhdFZpZXcuYWRkRXZlbnRMaXN0ZW5lcihcImNoYXRcIiwgdGhpcy5vblZpZXdDaGF0LCB0aGlzKTtcblx0dGhpcy5uZXRQb2tlckNsaWVudFZpZXcuc2V0dGluZ3NWaWV3LmFkZEV2ZW50TGlzdGVuZXIoU2V0dGluZ3NWaWV3LkJVWV9DSElQU19DTElDSywgdGhpcy5vbkJ1eUNoaXBzQnV0dG9uQ2xpY2ssIHRoaXMpO1xuXHR0aGlzLm5ldFBva2VyQ2xpZW50Vmlldy5zZXR0aW5nc1ZpZXcuYWRkRXZlbnRMaXN0ZW5lcihTZXR0aW5nc1ZpZXcuQ0hFQ0tCT1hfQ0hBTkdFLCB0aGlzLm9uQ2hlY2tib3hDaGFuZ2UsIHRoaXMpO1xuXG5cdHRoaXMubmV0UG9rZXJDbGllbnRWaWV3LmdldFByZXNldEJ1dHRvbnNWaWV3KCkuYWRkRXZlbnRMaXN0ZW5lcihQcmVzZXRCdXR0b25zVmlldy5DSEFOR0UsIHRoaXMub25QcmVzZXRCdXR0b25zQ2hhbmdlLCB0aGlzKTtcbn1cblxuXG4vKipcbiAqIFNldCBjb25uZWN0aW9uLlxuICogQG1ldGhvZCBzZXRQcm90b0Nvbm5lY3Rpb25cbiAqL1xuTmV0UG9rZXJDbGllbnRDb250cm9sbGVyLnByb3RvdHlwZS5zZXRQcm90b0Nvbm5lY3Rpb24gPSBmdW5jdGlvbihwcm90b0Nvbm5lY3Rpb24pIHtcblx0aWYgKHRoaXMucHJvdG9Db25uZWN0aW9uKSB7XG5cdFx0dGhpcy5wcm90b0Nvbm5lY3Rpb24ub2ZmKFByb3RvQ29ubmVjdGlvbi5NRVNTQUdFLCB0aGlzLm9uUHJvdG9Db25uZWN0aW9uTWVzc2FnZSwgdGhpcyk7XG5cdH1cblxuXHR0aGlzLnByb3RvQ29ubmVjdGlvbiA9IHByb3RvQ29ubmVjdGlvbjtcblx0dGhpcy5uZXRQb2tlckNsaWVudFZpZXcuY2xlYXIoKTtcblxuXHRpZiAodGhpcy5wcm90b0Nvbm5lY3Rpb24pIHtcblx0XHR0aGlzLnByb3RvQ29ubmVjdGlvbi5vbihQcm90b0Nvbm5lY3Rpb24uTUVTU0FHRSwgdGhpcy5vblByb3RvQ29ubmVjdGlvbk1lc3NhZ2UsIHRoaXMpO1xuXHR9XG59XG5cbi8qKlxuICogSW5jb21pbmcgbWVzc2FnZS5cbiAqIEVucXVldWUgZm9yIHByb2Nlc3NpbmcuXG4gKsKgQG1ldGhvZCBvblByb3RvQ29ubmVjdGlvbk1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFBva2VyQ2xpZW50Q29udHJvbGxlci5wcm90b3R5cGUub25Qcm90b0Nvbm5lY3Rpb25NZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuXHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIuZW5xdWV1ZShlLm1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEJ1dHRvbiBjbGljay5cbiAqIFRoaXMgZnVuY3Rpb24gaGFuZGxlcyBjbGlja3MgZnJvbSBib3RoIHRoZSBkaWFsb2cgYW5kIGdhbWUgcGxheSBidXR0b25zLlxuICogQG1ldGhvZCBvbkJ1dHRvbkNsaWNrXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRQb2tlckNsaWVudENvbnRyb2xsZXIucHJvdG90eXBlLm9uQnV0dG9uQ2xpY2sgPSBmdW5jdGlvbihlKSB7XG5cdGlmICghdGhpcy5wcm90b0Nvbm5lY3Rpb24pXG5cdFx0cmV0dXJuO1xuXG5cdGNvbnNvbGUubG9nKFwiYnV0dG9uIGNsaWNrLCB2PVwiICsgZS52YWx1ZSk7XG5cblx0dmFyIG0gPSBuZXcgQnV0dG9uQ2xpY2tNZXNzYWdlKGUuYnV0dG9uLCBlLnZhbHVlKTtcblx0dGhpcy5wcm90b0Nvbm5lY3Rpb24uc2VuZChtKTtcbn1cblxuLyoqXG4gKiBTZWF0IGNsaWNrLlxuICogQG1ldGhvZCBvblNlYXRDbGlja1xuICogQHByaXZhdGVcbiAqL1xuTmV0UG9rZXJDbGllbnRDb250cm9sbGVyLnByb3RvdHlwZS5vblNlYXRDbGljayA9IGZ1bmN0aW9uKGUpIHtcblx0dmFyIG0gPSBuZXcgU2VhdENsaWNrTWVzc2FnZShlLnNlYXRJbmRleCk7XG5cdHRoaXMucHJvdG9Db25uZWN0aW9uLnNlbmQobSk7XG59XG5cbi8qKlxuICogT24gc2VuZCBjaGF0IG1lc3NhZ2UuXG4gKiBAbWV0aG9kIG9uVmlld0NoYXRcbiAqL1xuTmV0UG9rZXJDbGllbnRDb250cm9sbGVyLnByb3RvdHlwZS5vblZpZXdDaGF0ID0gZnVuY3Rpb24oZSkge1xuXHR2YXIgbWVzc2FnZSA9IG5ldyBDaGF0TWVzc2FnZSgpO1xuXHRtZXNzYWdlLnVzZXIgPSBcIlwiO1xuXHRtZXNzYWdlLnRleHQgPSBlLnRleHQ7XG5cblx0dGhpcy5wcm90b0Nvbm5lY3Rpb24uc2VuZChtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBPbiBidXkgY2hpcHMgYnV0dG9uIGNsaWNrLlxuICogQG1ldGhvZCBvbkJ1eUNoaXBzQnV0dG9uQ2xpY2tcbiAqL1xuTmV0UG9rZXJDbGllbnRDb250cm9sbGVyLnByb3RvdHlwZS5vbkJ1eUNoaXBzQnV0dG9uQ2xpY2sgPSBmdW5jdGlvbigpIHtcblx0Y29uc29sZS5sb2coXCJidXkgY2hpcHMgY2xpY2tcIik7XG5cblx0dGhpcy5wcm90b0Nvbm5lY3Rpb24uc2VuZChuZXcgQnV0dG9uQ2xpY2tNZXNzYWdlKEJ1dHRvbkRhdGEuQlVZX0NISVBTKSk7XG59XG5cbi8qKlxuICogUHJlc2V0QnV0dG9ucyBjaGFuZ2UgbWVzc2FnZS5cbiAqIEBtZXRob2Qgb25QcmVzZXRCdXR0b25zQ2hhbmdlXG4gKi9cbk5ldFBva2VyQ2xpZW50Q29udHJvbGxlci5wcm90b3R5cGUub25QcmVzZXRCdXR0b25zQ2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cdHZhciBwcmVzZXRCdXR0b25zVmlldyA9IHRoaXMubmV0UG9rZXJDbGllbnRWaWV3LmdldFByZXNldEJ1dHRvbnNWaWV3KCk7XG5cdHZhciBtZXNzYWdlID0gbmV3IFByZXNldEJ1dHRvbkNsaWNrTWVzc2FnZSgpO1xuXG5cdHZhciBjID0gcHJlc2V0QnV0dG9uc1ZpZXcuZ2V0Q3VycmVudCgpO1xuXHRpZiAoYyAhPSBudWxsKSB7XG5cdFx0bWVzc2FnZS5idXR0b24gPSBjLmlkO1xuXHRcdG1lc3NhZ2UudmFsdWUgPSBjLnZhbHVlO1xuXHR9XG5cblx0dGhpcy5wcm90b0Nvbm5lY3Rpb24uc2VuZChtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBDaGVja2JveCBjaGFuZ2UuXG4gKiBAbWV0aG9kIG9uQ2hlY2tib3hDaGFuZ2VcbiAqL1xuTmV0UG9rZXJDbGllbnRDb250cm9sbGVyLnByb3RvdHlwZS5vbkNoZWNrYm94Q2hhbmdlID0gZnVuY3Rpb24oZXYpIHtcblx0dGhpcy5wcm90b0Nvbm5lY3Rpb24uc2VuZChuZXcgQ2hlY2tib3hNZXNzYWdlKGV2LmNoZWNrYm94SWQsIGV2LmNoZWNrZWQpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBOZXRQb2tlckNsaWVudENvbnRyb2xsZXI7IiwiLyoqXG4gKiBDbGllbnQuXG4gKiBAbW9kdWxlIGNsaWVudFxuICovXG5cbnZhciBTZWF0SW5mb01lc3NhZ2UgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vbWVzc2FnZXMvU2VhdEluZm9NZXNzYWdlXCIpO1xudmFyIENvbW11bml0eUNhcmRzTWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9Db21tdW5pdHlDYXJkc01lc3NhZ2VcIik7XG52YXIgUG9ja2V0Q2FyZHNNZXNzYWdlID0gcmVxdWlyZShcIi4uLy4uL3Byb3RvL21lc3NhZ2VzL1BvY2tldENhcmRzTWVzc2FnZVwiKTtcbnZhciBEZWFsZXJCdXR0b25NZXNzYWdlID0gcmVxdWlyZShcIi4uLy4uL3Byb3RvL21lc3NhZ2VzL0RlYWxlckJ1dHRvbk1lc3NhZ2VcIik7XG52YXIgQmV0TWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9CZXRNZXNzYWdlXCIpO1xudmFyIEJldHNUb1BvdE1lc3NhZ2UgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vbWVzc2FnZXMvQmV0c1RvUG90TWVzc2FnZVwiKTtcbnZhciBQb3RNZXNzYWdlID0gcmVxdWlyZShcIi4uLy4uL3Byb3RvL21lc3NhZ2VzL1BvdE1lc3NhZ2VcIik7XG52YXIgVGltZXJNZXNzYWdlID0gcmVxdWlyZShcIi4uLy4uL3Byb3RvL21lc3NhZ2VzL1RpbWVyTWVzc2FnZVwiKTtcbnZhciBBY3Rpb25NZXNzYWdlID0gcmVxdWlyZShcIi4uLy4uL3Byb3RvL21lc3NhZ2VzL0FjdGlvbk1lc3NhZ2VcIik7XG52YXIgRm9sZENhcmRzTWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9Gb2xkQ2FyZHNNZXNzYWdlXCIpO1xudmFyIERlbGF5TWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9EZWxheU1lc3NhZ2VcIik7XG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZShcInlhZWRcIik7XG52YXIgQ2xlYXJNZXNzYWdlID0gcmVxdWlyZShcIi4uLy4uL3Byb3RvL21lc3NhZ2VzL0NsZWFyTWVzc2FnZVwiKTtcbnZhciBQYXlPdXRNZXNzYWdlID0gcmVxdWlyZShcIi4uLy4uL3Byb3RvL21lc3NhZ2VzL1BheU91dE1lc3NhZ2VcIik7XG5cbi8qKlxuICogQ29udHJvbCB0aGUgdGFibGVcbiAqIEBjbGFzcyBUYWJsZUNvbnRyb2xsZXJcbiAqL1xuZnVuY3Rpb24gVGFibGVDb250cm9sbGVyKG1lc3NhZ2VTZXF1ZW5jZXIsIHZpZXcpIHtcblx0dGhpcy5tZXNzYWdlU2VxdWVuY2VyID0gbWVzc2FnZVNlcXVlbmNlcjtcblx0dGhpcy52aWV3ID0gdmlldztcblxuXHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIuYWRkTWVzc2FnZUhhbmRsZXIoU2VhdEluZm9NZXNzYWdlLlRZUEUsIHRoaXMub25TZWF0SW5mb01lc3NhZ2UsIHRoaXMpO1xuXHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIuYWRkTWVzc2FnZUhhbmRsZXIoQ29tbXVuaXR5Q2FyZHNNZXNzYWdlLlRZUEUsIHRoaXMub25Db21tdW5pdHlDYXJkc01lc3NhZ2UsIHRoaXMpO1xuXHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIuYWRkTWVzc2FnZUhhbmRsZXIoUG9ja2V0Q2FyZHNNZXNzYWdlLlRZUEUsIHRoaXMub25Qb2NrZXRDYXJkc01lc3NhZ2UsIHRoaXMpO1xuXHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIuYWRkTWVzc2FnZUhhbmRsZXIoRGVhbGVyQnV0dG9uTWVzc2FnZS5UWVBFLCB0aGlzLm9uRGVhbGVyQnV0dG9uTWVzc2FnZSwgdGhpcyk7XG5cdHRoaXMubWVzc2FnZVNlcXVlbmNlci5hZGRNZXNzYWdlSGFuZGxlcihCZXRNZXNzYWdlLlRZUEUsIHRoaXMub25CZXRNZXNzYWdlLCB0aGlzKTtcblx0dGhpcy5tZXNzYWdlU2VxdWVuY2VyLmFkZE1lc3NhZ2VIYW5kbGVyKEJldHNUb1BvdE1lc3NhZ2UuVFlQRSwgdGhpcy5vbkJldHNUb1BvdCwgdGhpcyk7XG5cdHRoaXMubWVzc2FnZVNlcXVlbmNlci5hZGRNZXNzYWdlSGFuZGxlcihQb3RNZXNzYWdlLlRZUEUsIHRoaXMub25Qb3QsIHRoaXMpO1xuXHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIuYWRkTWVzc2FnZUhhbmRsZXIoVGltZXJNZXNzYWdlLlRZUEUsIHRoaXMub25UaW1lciwgdGhpcyk7XG5cdHRoaXMubWVzc2FnZVNlcXVlbmNlci5hZGRNZXNzYWdlSGFuZGxlcihBY3Rpb25NZXNzYWdlLlRZUEUsIHRoaXMub25BY3Rpb24sIHRoaXMpO1xuXHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIuYWRkTWVzc2FnZUhhbmRsZXIoRm9sZENhcmRzTWVzc2FnZS5UWVBFLCB0aGlzLm9uRm9sZENhcmRzLCB0aGlzKTtcblx0dGhpcy5tZXNzYWdlU2VxdWVuY2VyLmFkZE1lc3NhZ2VIYW5kbGVyKERlbGF5TWVzc2FnZS5UWVBFLCB0aGlzLm9uRGVsYXksIHRoaXMpO1xuXHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIuYWRkTWVzc2FnZUhhbmRsZXIoQ2xlYXJNZXNzYWdlLlRZUEUsIHRoaXMub25DbGVhciwgdGhpcyk7XG5cdHRoaXMubWVzc2FnZVNlcXVlbmNlci5hZGRNZXNzYWdlSGFuZGxlcihQYXlPdXRNZXNzYWdlLlRZUEUsIHRoaXMub25QYXlPdXQsIHRoaXMpO1xufVxuRXZlbnREaXNwYXRjaGVyLmluaXQoVGFibGVDb250cm9sbGVyKTtcblxuLyoqXG4gKiBTZWF0IGluZm8gbWVzc2FnZS5cbiAqIEBtZXRob2Qgb25TZWF0SW5mb01lc3NhZ2VcbiAqL1xuVGFibGVDb250cm9sbGVyLnByb3RvdHlwZS5vblNlYXRJbmZvTWVzc2FnZSA9IGZ1bmN0aW9uKG0pIHtcblx0dmFyIHNlYXRWaWV3ID0gdGhpcy52aWV3LmdldFNlYXRWaWV3QnlJbmRleChtLmdldFNlYXRJbmRleCgpKTtcblxuXHRzZWF0Vmlldy5zZXROYW1lKG0uZ2V0TmFtZSgpKTtcblx0c2VhdFZpZXcuc2V0Q2hpcHMobS5nZXRDaGlwcygpKTtcblx0c2VhdFZpZXcuc2V0QWN0aXZlKG0uaXNBY3RpdmUoKSk7XG5cdHNlYXRWaWV3LnNldFNpdG91dChtLmlzU2l0b3V0KCkpO1xufVxuXG4vKipcbiAqIFNlYXQgaW5mbyBtZXNzYWdlLlxuICogQG1ldGhvZCBvbkNvbW11bml0eUNhcmRzTWVzc2FnZVxuICovXG5UYWJsZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uQ29tbXVuaXR5Q2FyZHNNZXNzYWdlID0gZnVuY3Rpb24obSkge1xuXHR2YXIgaTtcblxuXHRjb25zb2xlLmxvZyhcImdvdCBjb21tdW5pdHkgY2FyZHMhXCIpO1xuXHRjb25zb2xlLmxvZyhtKTtcblxuXHRmb3IgKGkgPSAwOyBpIDwgbS5nZXRDYXJkcygpLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGNhcmREYXRhID0gbS5nZXRDYXJkcygpW2ldO1xuXHRcdHZhciBjYXJkVmlldyA9IHRoaXMudmlldy5nZXRDb21tdW5pdHlDYXJkcygpW20uZ2V0Rmlyc3RJbmRleCgpICsgaV07XG5cblx0XHRjYXJkVmlldy5zZXRDYXJkRGF0YShjYXJkRGF0YSk7XG5cdFx0Y2FyZFZpZXcuc2hvdyhtLmFuaW1hdGUsIGkgKiA1MDApO1xuXHR9XG5cdGlmIChtLmdldENhcmRzKCkubGVuZ3RoID4gMCkge1xuXHRcdHZhciBjYXJkRGF0YSA9IG0uZ2V0Q2FyZHMoKVttLmdldENhcmRzKCkubGVuZ3RoIC0gMV07XG5cdFx0dmFyIGNhcmRWaWV3ID0gdGhpcy52aWV3LmdldENvbW11bml0eUNhcmRzKClbbS5nZXRGaXJzdEluZGV4KCkgKyBtLmdldENhcmRzKCkubGVuZ3RoIC0gMV07XG5cdFx0aWYobS5hbmltYXRlKVxuXHRcdFx0dGhpcy5tZXNzYWdlU2VxdWVuY2VyLndhaXRGb3IoY2FyZFZpZXcsIFwiYW5pbWF0aW9uRG9uZVwiKTtcblx0fVxufVxuXG4vKipcbiAqIFBvY2tldCBjYXJkcyBtZXNzYWdlLlxuICogQG1ldGhvZCBvblBvY2tldENhcmRzTWVzc2FnZVxuICovXG5UYWJsZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uUG9ja2V0Q2FyZHNNZXNzYWdlID0gZnVuY3Rpb24obSkge1xuXHR2YXIgc2VhdFZpZXcgPSB0aGlzLnZpZXcuZ2V0U2VhdFZpZXdCeUluZGV4KG0uZ2V0U2VhdEluZGV4KCkpO1xuXHR2YXIgaTtcblxuXHRmb3IgKGkgPSAwOyBpIDwgbS5nZXRDYXJkcygpLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGNhcmREYXRhID0gbS5nZXRDYXJkcygpW2ldO1xuXHRcdHZhciBjYXJkVmlldyA9IHNlYXRWaWV3LmdldFBvY2tldENhcmRzKClbbS5nZXRGaXJzdEluZGV4KCkgKyBpXTtcblxuXHRcdGlmKG0uYW5pbWF0ZSlcblx0XHRcdHRoaXMubWVzc2FnZVNlcXVlbmNlci53YWl0Rm9yKGNhcmRWaWV3LCBcImFuaW1hdGlvbkRvbmVcIik7XG5cdFx0Y2FyZFZpZXcuc2V0Q2FyZERhdGEoY2FyZERhdGEpO1xuXHRcdGNhcmRWaWV3LnNob3cobS5hbmltYXRlLCAxMCk7XG5cdH1cbn1cblxuLyoqXG4gKiBEZWFsZXIgYnV0dG9uIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIG9uRGVhbGVyQnV0dG9uTWVzc2FnZVxuICovXG5UYWJsZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uRGVhbGVyQnV0dG9uTWVzc2FnZSA9IGZ1bmN0aW9uKG0pIHtcblx0dmFyIGRlYWxlckJ1dHRvblZpZXcgPSB0aGlzLnZpZXcuZ2V0RGVhbGVyQnV0dG9uVmlldygpO1xuXG5cdGlmIChtLnNlYXRJbmRleCA8IDApIHtcblx0XHRkZWFsZXJCdXR0b25WaWV3LmhpZGUoKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIud2FpdEZvcihkZWFsZXJCdXR0b25WaWV3LCBcImFuaW1hdGlvbkRvbmVcIik7XG5cdFx0ZGVhbGVyQnV0dG9uVmlldy5zaG93KG0uZ2V0U2VhdEluZGV4KCksIG0uZ2V0QW5pbWF0ZSgpKTtcblx0fVxufTtcblxuLyoqXG4gKiBCZXQgbWVzc2FnZS5cbiAqIEBtZXRob2Qgb25CZXRNZXNzYWdlXG4gKi9cblRhYmxlQ29udHJvbGxlci5wcm90b3R5cGUub25CZXRNZXNzYWdlID0gZnVuY3Rpb24obSkge1xuXHR0aGlzLnZpZXcuc2VhdFZpZXdzW20uc2VhdEluZGV4XS5iZXRDaGlwcy5zZXRWYWx1ZShtLnZhbHVlKTtcbn07XG5cbi8qKlxuICogQmV0cyB0byBwb3QuXG4gKiBAbWV0aG9kIG9uQmV0c1RvUG90XG4gKi9cblRhYmxlQ29udHJvbGxlci5wcm90b3R5cGUub25CZXRzVG9Qb3QgPSBmdW5jdGlvbihtKSB7XG5cdHZhciBoYXZlQ2hpcHMgPSBmYWxzZTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmlldy5zZWF0Vmlld3MubGVuZ3RoOyBpKyspXG5cdFx0aWYgKHRoaXMudmlldy5zZWF0Vmlld3NbaV0uYmV0Q2hpcHMudmFsdWUgPiAwKVxuXHRcdFx0aGF2ZUNoaXBzID0gdHJ1ZTtcblxuXHRpZiAoIWhhdmVDaGlwcylcblx0XHRyZXR1cm47XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZpZXcuc2VhdFZpZXdzLmxlbmd0aDsgaSsrKVxuXHRcdHRoaXMudmlldy5zZWF0Vmlld3NbaV0uYmV0Q2hpcHMuYW5pbWF0ZUluKCk7XG5cblx0dGhpcy5tZXNzYWdlU2VxdWVuY2VyLndhaXRGb3IodGhpcy52aWV3LnNlYXRWaWV3c1swXS5iZXRDaGlwcywgXCJhbmltYXRpb25Eb25lXCIpO1xufVxuXG4vKipcbiAqIFBvdCBtZXNzYWdlLlxuICogQG1ldGhvZCBvblBvdFxuICovXG5UYWJsZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uUG90ID0gZnVuY3Rpb24obSkge1xuXHR0aGlzLnZpZXcucG90Vmlldy5zZXRWYWx1ZXMobS52YWx1ZXMpO1xufTtcblxuLyoqXG4gKiBUaW1lciBtZXNzYWdlLlxuICogQG1ldGhvZCBvblRpbWVyXG4gKi9cblRhYmxlQ29udHJvbGxlci5wcm90b3R5cGUub25UaW1lciA9IGZ1bmN0aW9uKG0pIHtcblx0aWYgKG0uc2VhdEluZGV4IDwgMClcblx0XHR0aGlzLnZpZXcudGltZXJWaWV3LmhpZGUoKTtcblxuXHRlbHNlIHtcblx0XHR0aGlzLnZpZXcudGltZXJWaWV3LnNob3cobS5zZWF0SW5kZXgpO1xuXHRcdHRoaXMudmlldy50aW1lclZpZXcuY291bnRkb3duKG0udG90YWxUaW1lLCBtLnRpbWVMZWZ0KTtcblx0fVxufTtcblxuLyoqXG4gKiBBY3Rpb24gbWVzc2FnZS5cbiAqIEBtZXRob2Qgb25BY3Rpb25cbiAqL1xuVGFibGVDb250cm9sbGVyLnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKG0pIHtcblx0aWYgKG0uc2VhdEluZGV4ID09IG51bGwpXG5cdFx0bS5zZWF0SW5kZXggPSAwO1xuXG5cdHRoaXMudmlldy5zZWF0Vmlld3NbbS5zZWF0SW5kZXhdLmFjdGlvbihtLmFjdGlvbik7XG59O1xuXG4vKipcbiAqIEZvbGQgY2FyZHMgbWVzc2FnZS5cbiAqIEBtZXRob2Qgb25Gb2xkQ2FyZHNcbiAqL1xuVGFibGVDb250cm9sbGVyLnByb3RvdHlwZS5vbkZvbGRDYXJkcyA9IGZ1bmN0aW9uKG0pIHtcblx0dGhpcy52aWV3LnNlYXRWaWV3c1ttLnNlYXRJbmRleF0uZm9sZENhcmRzKCk7XG5cblx0dGhpcy5tZXNzYWdlU2VxdWVuY2VyLndhaXRGb3IodGhpcy52aWV3LnNlYXRWaWV3c1ttLnNlYXRJbmRleF0sIFwiYW5pbWF0aW9uRG9uZVwiKTtcbn07XG5cbi8qKlxuICogRGVsYXkgbWVzc2FnZS5cbiAqIEBtZXRob2Qgb25EZWxheVxuICovXG5UYWJsZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uRGVsYXkgPSBmdW5jdGlvbihtKSB7XG5cdGNvbnNvbGUubG9nKFwiZGVsYXkgZm9yICA9IFwiICsgbS5kZWxheSk7XG5cblxuXHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIud2FpdEZvcih0aGlzLCBcInRpbWVyRG9uZVwiKTtcblx0c2V0VGltZW91dCh0aGlzLmRpc3BhdGNoRXZlbnQuYmluZCh0aGlzLCBcInRpbWVyRG9uZVwiKSwgbS5kZWxheSk7XG5cbn07XG5cbi8qKlxuICogQ2xlYXIgbWVzc2FnZS5cbiAqIEBtZXRob2Qgb25DbGVhclxuICovXG5UYWJsZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uQ2xlYXIgPSBmdW5jdGlvbihtKSB7XG5cblx0dmFyIGNvbXBvbmVudHMgPSBtLmdldENvbXBvbmVudHMoKTtcblxuXHRmb3IodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdHN3aXRjaChjb21wb25lbnRzW2ldKSB7XG5cdFx0XHRjYXNlIENsZWFyTWVzc2FnZS5QT1Q6IHtcblx0XHRcdFx0dGhpcy52aWV3LnBvdFZpZXcuc2V0VmFsdWVzKFtdKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRjYXNlIENsZWFyTWVzc2FnZS5CRVRTOiB7XG5cdFx0XHRcdGZvcih2YXIgcyA9IDA7IHMgPCB0aGlzLnZpZXcuc2VhdFZpZXdzLmxlbmd0aDsgcysrKSB7XG5cdFx0XHRcdFx0dGhpcy52aWV3LnNlYXRWaWV3c1tzXS5iZXRDaGlwcy5zZXRWYWx1ZSgwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGNhc2UgQ2xlYXJNZXNzYWdlLkNBUkRTOiB7XG5cdFx0XHRcdGZvcih2YXIgcyA9IDA7IHMgPCB0aGlzLnZpZXcuc2VhdFZpZXdzLmxlbmd0aDsgcysrKSB7XG5cdFx0XHRcdFx0Zm9yKHZhciBjID0gMDsgYyA8IHRoaXMudmlldy5zZWF0Vmlld3Nbc10ucG9ja2V0Q2FyZHMubGVuZ3RoOyBjKyspIHtcblx0XHRcdFx0XHRcdHRoaXMudmlldy5zZWF0Vmlld3Nbc10ucG9ja2V0Q2FyZHNbY10uaGlkZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvcih2YXIgYyA9IDA7IGMgPCB0aGlzLnZpZXcuY29tbXVuaXR5Q2FyZHMubGVuZ3RoOyBjKyspIHtcblx0XHRcdFx0XHR0aGlzLnZpZXcuY29tbXVuaXR5Q2FyZHNbY10uaGlkZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0Y2FzZSBDbGVhck1lc3NhZ2UuQ0hBVDoge1xuXHRcdFx0XHR0aGlzLnZpZXcuY2hhdFZpZXcuY2xlYXIoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogUGF5IG91dCBtZXNzYWdlLlxuICogQG1ldGhvZCBvblBheU91dFxuICovXG5UYWJsZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uUGF5T3V0ID0gZnVuY3Rpb24obSkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG0udmFsdWVzLmxlbmd0aDsgaSsrKVxuXHRcdHRoaXMudmlldy5zZWF0Vmlld3NbaV0uYmV0Q2hpcHMuc2V0VmFsdWUobS52YWx1ZXNbaV0pO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52aWV3LnNlYXRWaWV3cy5sZW5ndGg7IGkrKylcblx0XHR0aGlzLnZpZXcuc2VhdFZpZXdzW2ldLmJldENoaXBzLmFuaW1hdGVPdXQoKTtcblxuXHR0aGlzLm1lc3NhZ2VTZXF1ZW5jZXIud2FpdEZvcih0aGlzLnZpZXcuc2VhdFZpZXdzWzBdLmJldENoaXBzLCBcImFuaW1hdGlvbkRvbmVcIik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVGFibGVDb250cm9sbGVyOyIsIm1vZHVsZS5leHBvcnRzID0ge1xuXHRcInRhYmxlQmFja2dyb3VuZFwiOiBcIl9fdGFibGUucG5nXCIsXG5cdFwic2VhdFBsYXRlXCI6IFwiX19zZWF0UGxhdGUucG5nXCIsXG5cdFwidGltZXJCYWNrZ3JvdW5kXCI6IFwiX190aW1lckJhY2tncm91bmQucG5nXCIsXG5cdFwiZGVhbGVyQnV0dG9uXCI6IFwiX19kZWFsZXJCdXR0b24ucG5nXCIsXG5cdFwiY2FyZEZyYW1lXCI6IFwiX19jYXJkRnJhbWUucG5nXCIsXG5cdFwiY2FyZEJhY2tcIjogXCJfX2NhcmRCYWNrLnBuZ1wiLFxuXHRcInN1aXRTeW1ib2wwXCI6IFwiX19zdWl0U3ltYm9sMC5wbmdcIixcblx0XCJzdWl0U3ltYm9sMVwiOiBcIl9fc3VpdFN5bWJvbDEucG5nXCIsXG5cdFwic3VpdFN5bWJvbDJcIjogXCJfX3N1aXRTeW1ib2wyLnBuZ1wiLFxuXHRcInN1aXRTeW1ib2wzXCI6IFwiX19zdWl0U3ltYm9sMy5wbmdcIixcblx0XCJjaGlwMFwiOiBcIl9fY2hpcDAucG5nXCIsXG5cdFwiY2hpcDFcIjogXCJfX2NoaXAxLnBuZ1wiLFxuXHRcImNoaXAyXCI6IFwiX19jaGlwMi5wbmdcIixcblx0XCJjaGlwM1wiOiBcIl9fY2hpcDMucG5nXCIsXG5cdFwiY2hpcDRcIjogXCJfX2NoaXA0LnBuZ1wiLFxuXHRcImRpdmlkZXJMaW5lXCI6IFwiX19kaXZpZGVyTGluZS5wbmdcIixcblx0XCJmcmFtZVBsYXRlXCI6IFwiX19mcmFtZVBsYXRlLnBuZ1wiLFxuXHRcImJpZ0J1dHRvblwiOiBcIl9fYmlnQnV0dG9uLnBuZ1wiLFxuXHRcImRpYWxvZ0J1dHRvblwiOiBcIl9fZGlhbG9nQnV0dG9uLnBuZ1wiLFxuXHRcInRleHRTY3JvbGxiYXJUcmFja1wiOiBcIl9fdGV4dFNjcm9sbGJhclRyYWNrLnBuZ1wiLFxuXHRcInRleHRTY3JvbGxiYXJUaHVtYlwiOiBcIl9fdGV4dFNjcm9sbGJhclRodW1iLnBuZ1wiLFxuXHRcIndyZW5jaEljb25cIjogXCJfX3dyZW5jaEljb24ucG5nXCIsXG5cdFwiY2hhdEJhY2tncm91bmRcIjogXCJfX2NoYXRCYWNrZ3JvdW5kLnBuZ1wiLFxuXHRcImNoZWNrYm94QmFja2dyb3VuZFwiOiBcIl9fY2hlY2tib3hCYWNrZ3JvdW5kLnBuZ1wiLFxuXHRcImNoZWNrYm94VGlja1wiOiBcIl9fY2hlY2tib3hUaWNrLnBuZ1wiLFxuXHRcImJ1dHRvbkJhY2tncm91bmRcIjogXCJfX2J1dHRvbkJhY2tncm91bmQucG5nXCIsXG5cdFwic2xpZGVyQmFja2dyb3VuZFwiOiBcIl9fc2xpZGVyQmFja2dyb3VuZC5wbmdcIixcblx0XCJzbGlkZXJLbm9iXCI6IFwiX19zbGlkZXJLbm9iLnBuZ1wiLFxuXHRcInVwQXJyb3dcIjogXCJfX3VwQXJyb3cucG5nXCIsXG5cblx0XCJjaGlwc0NvbG9yMFwiOiAweDQwNDA0MCxcblx0XCJjaGlwc0NvbG9yMVwiOiAweDAwODAwMCxcblx0XCJjaGlwc0NvbG9yMlwiOiAweDgwODAwMCxcblx0XCJjaGlwc0NvbG9yM1wiOiAweDAwMDA4MCxcblx0XCJjaGlwc0NvbG9yNFwiOiAweGZmMDAwMCxcblxuXHRcImNvbW11bml0eUNhcmRNYXJnaW5cIjogMSxcblx0XCJiZXRBbGlnblwiOiBcIkxDUlJSUkNMTExcIixcblxuXHRcInRhYmxlUG9zaXRpb25cIjogWzEwMSwgOTRdLFxuXHRcInBvdFBvc2l0aW9uXCI6IFs0ODUsIDMxNV0sXG5cblx0XCJ0aW1lck9mZnNldFwiOiBbNTUsIC0zMF0sXG5cdFwiY29tbXVuaXR5Q2FyZHNQb3NpdGlvblwiOiBbMjU1LCAxOTBdLFxuXG5cdFwic2VhdFBvc2l0aW9uMFwiOiBbMjg3LCAxMThdLFxuXHRcInNlYXRQb3NpdGlvbjFcIjogWzQ4MywgMTEyXSxcblx0XCJzZWF0UG9zaXRpb24yXCI6IFs2NzYsIDExOF0sXG5cdFwic2VhdFBvc2l0aW9uM1wiOiBbODQ0LCAyNDddLFxuXHRcInNlYXRQb3NpdGlvbjRcIjogWzgxNywgNDEzXSxcblx0XCJzZWF0UG9zaXRpb241XCI6IFs2NzYsIDQ5MF0sXG5cdFwic2VhdFBvc2l0aW9uNlwiOiBbNDgzLCA0OTVdLFxuXHRcInNlYXRQb3NpdGlvbjdcIjogWzI4NywgNDkwXSxcblx0XCJzZWF0UG9zaXRpb244XCI6IFsxNDAsIDQxM10sXG5cdFwic2VhdFBvc2l0aW9uOVwiOiBbMTIzLCAyNDddLFxuXG5cdFwiZGVhbGVyQnV0dG9uUG9zaXRpb24wXCI6IFszNDcsIDEzM10sXG5cdFwiZGVhbGVyQnV0dG9uUG9zaXRpb24xXCI6IFszOTUsIDEzM10sXG5cdFwiZGVhbGVyQnV0dG9uUG9zaXRpb24yXCI6IFs1NzQsIDEzM10sXG5cdFwiZGVhbGVyQnV0dG9uUG9zaXRpb24zXCI6IFs3NjIsIDI2N10sXG5cdFwiZGVhbGVyQnV0dG9uUG9zaXRpb240XCI6IFs3MTUsIDM1OF0sXG5cdFwiZGVhbGVyQnV0dG9uUG9zaXRpb241XCI6IFs1NzQsIDQzNF0sXG5cdFwiZGVhbGVyQnV0dG9uUG9zaXRpb242XCI6IFs1MzYsIDQzMl0sXG5cdFwiZGVhbGVyQnV0dG9uUG9zaXRpb243XCI6IFszNTEsIDQzMl0sXG5cdFwiZGVhbGVyQnV0dG9uUG9zaXRpb244XCI6IFsxOTMsIDM2Ml0sXG5cdFwiZGVhbGVyQnV0dG9uUG9zaXRpb245XCI6IFsxNjgsIDI2Nl0sXG5cblx0XCJiZXRQb3NpdGlvbjBcIjogWzIyNSwgMTUwXSxcblx0XCJiZXRQb3NpdGlvbjFcIjogWzQ3OCwgMTUwXSxcblx0XCJiZXRQb3NpdGlvbjJcIjogWzczMCwgMTUwXSxcblx0XCJiZXRQb3NpdGlvbjNcIjogWzc3OCwgMTk2XSxcblx0XCJiZXRQb3NpdGlvbjRcIjogWzc0OCwgMzIyXSxcblx0XCJiZXRQb3NpdGlvbjVcIjogWzcxOSwgMzYwXSxcblx0XCJiZXRQb3NpdGlvbjZcIjogWzQ4MSwgMzYwXSxcblx0XCJiZXRQb3NpdGlvbjdcIjogWzIzMiwgMzYwXSxcblx0XCJiZXRQb3NpdGlvbjhcIjogWzE5OSwgMzIyXSxcblx0XCJiZXRQb3NpdGlvbjlcIjogWzE4MSwgMjAwXSxcblxuXHRcImJpZ0J1dHRvblBvc2l0aW9uXCI6IFszNjYsIDU3NV1cbn07IiwiLyoqXG4gKiBDbGllbnQuXG4gKiBAbW9kdWxlIGNsaWVudFxuICovXG5cbi8qKlxuICogVmlldyBjb25maWd1cmF0aW9uLlxuICogQGNsYXNzIFZpZXdDb25maWdcbiAqL1xuZnVuY3Rpb24gVmlld0NvbmZpZygpIHtcblx0dGhpcy5wbGF5QW5pbWF0aW9ucyA9IHRydWU7XG59XG5cbi8qKlxuICogU2hvdWxkIHdlIHBsYXkgYW5pbWF0aW9ucz9cbiAqIEBtZXRob2Qgc2V0UGxheUFuaW1hdGlvbnNcbiAqL1xuVmlld0NvbmZpZy5wcm90b3R5cGUuc2V0UGxheUFuaW1hdGlvbnMgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHR0aGlzLnBsYXlBbmltYXRpb25zID0gdmFsdWU7XG59XG5cbi8qKlxuICogU2hvdWxkIHdlIHBsYXkgYW5pbWF0aW9ucz9cbiAqIEBtZXRob2QgZ2V0UGxheUFuaW1hdGlvbnNcbiAqL1xuVmlld0NvbmZpZy5wcm90b3R5cGUuZ2V0UGxheUFuaW1hdGlvbnMgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMucGxheUFuaW1hdGlvbnM7XG59XG5cbi8qKlxuICogU2NhbGUgYW5pbWF0aW9uIHRpbWUuXG4gKiBAbWV0aG9kIHNjYWxlQW5pbWF0aW9uVGltZVxuICovXG5WaWV3Q29uZmlnLnByb3RvdHlwZS5zY2FsZUFuaW1hdGlvblRpbWUgPSBmdW5jdGlvbihtaWxsaXMpIHtcblx0aWYgKHRoaXMucGxheUFuaW1hdGlvbnMpXG5cdFx0cmV0dXJuIG1pbGxpcztcblxuXHRyZXR1cm4gMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3Q29uZmlnOyIsIi8qKlxuICogQ2xpZW50LlxuICogQG1vZHVsZSBjbGllbnRcbiAqL1xuXG52YXIgUElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xudmFyIEJ1dHRvbiA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9CdXR0b25cIik7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiaW5oZXJpdHNcIik7XG5cbi8qKlxuICogQmlnIGJ1dHRvbi5cbiAqIEBjbGFzcyBCaWdCdXR0b25cbiAqL1xuZnVuY3Rpb24gQmlnQnV0dG9uKHJlc291cmNlcykge1xuXHRCdXR0b24uY2FsbCh0aGlzKTtcblxuXHR0aGlzLnJlc291cmNlcyA9IHJlc291cmNlcztcblxuXHR0aGlzLmJpZ0J1dHRvblRleHR1cmUgPSB0aGlzLnJlc291cmNlcy5nZXRUZXh0dXJlKFwiYmlnQnV0dG9uXCIpO1xuXG5cdHRoaXMuYWRkQ2hpbGQobmV3IFBJWEkuU3ByaXRlKHRoaXMuYmlnQnV0dG9uVGV4dHVyZSkpO1xuXG5cdHZhciBzdHlsZSA9IHtcblx0XHRmb250OiBcImJvbGQgMThweCBBcmlhbFwiLFxuXHRcdC8vZmlsbDogXCIjMDAwMDAwXCJcblx0fTtcblxuXHR0aGlzLmxhYmVsRmllbGQgPSBuZXcgUElYSS5UZXh0KFwiW2J1dHRvbl1cIiwgc3R5bGUpO1xuXHR0aGlzLmxhYmVsRmllbGQucG9zaXRpb24ueSA9IDMwO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMubGFiZWxGaWVsZCk7XG5cblx0dmFyIHN0eWxlID0ge1xuXHRcdGZvbnQ6IFwiYm9sZCAxNHB4IEFyaWFsXCJcblx0XHQvL2ZpbGw6IFwiIzAwMDAwMFwiXG5cdH07XG5cblx0dGhpcy52YWx1ZUZpZWxkID0gbmV3IFBJWEkuVGV4dChcIlt2YWx1ZV1cIiwgc3R5bGUpO1xuXHR0aGlzLnZhbHVlRmllbGQucG9zaXRpb24ueSA9IDUwO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMudmFsdWVGaWVsZCk7XG5cblx0dGhpcy5zZXRMYWJlbChcIlRFU1RcIik7XG5cdHRoaXMuc2V0VmFsdWUoMTIzKTtcbn1cblxuaW5oZXJpdHMoQmlnQnV0dG9uLCBCdXR0b24pO1xuXG4vKipcbiAqIFNldCBsYWJlbCBmb3IgdGhlIGJ1dHRvbi5cbiAqIEBtZXRob2Qgc2V0TGFiZWxcbiAqL1xuQmlnQnV0dG9uLnByb3RvdHlwZS5zZXRMYWJlbCA9IGZ1bmN0aW9uKGxhYmVsKSB7XG5cdHRoaXMubGFiZWxGaWVsZC5zZXRUZXh0KGxhYmVsKTtcblx0dGhpcy5sYWJlbEZpZWxkLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXHR0aGlzLmxhYmVsRmllbGQueCA9IHRoaXMuYmlnQnV0dG9uVGV4dHVyZS53aWR0aCAvIDIgLSB0aGlzLmxhYmVsRmllbGQud2lkdGggLyAyO1xufVxuXG4vKipcbiAqIFNldCB2YWx1ZS5cbiAqIEBtZXRob2Qgc2V0VmFsdWVcbiAqL1xuQmlnQnV0dG9uLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdGlmICghdmFsdWUpIHtcblx0XHR0aGlzLnZhbHVlRmllbGQudmlzaWJsZSA9IGZhbHNlO1xuXHRcdHZhbHVlID0gXCJcIjtcblx0fSBlbHNlIHtcblx0XHR0aGlzLnZhbHVlRmllbGQudmlzaWJsZSA9IHRydWU7XG5cdH1cblxuXHR0aGlzLnZhbHVlRmllbGQuc2V0VGV4dCh2YWx1ZSk7XG5cdHRoaXMudmFsdWVGaWVsZC51cGRhdGVUcmFuc2Zvcm0oKTtcblx0dGhpcy52YWx1ZUZpZWxkLnggPSB0aGlzLmJpZ0J1dHRvblRleHR1cmUud2lkdGggLyAyIC0gdGhpcy52YWx1ZUZpZWxkLndpZHRoIC8gMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCaWdCdXR0b247IiwiLyoqXG4gKiBDbGllbnQuXG4gKiBAbW9kdWxlIGNsaWVudFxuICovXG5cbnZhciBQSVhJID0gcmVxdWlyZShcInBpeGkuanNcIik7XG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZShcInlhZWRcIik7XG52YXIgQnV0dG9uID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL0J1dHRvblwiKTtcbnZhciBTbGlkZXIgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvU2xpZGVyXCIpO1xudmFyIE5pbmVTbGljZSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9OaW5lU2xpY2VcIik7XG52YXIgQmlnQnV0dG9uID0gcmVxdWlyZShcIi4vQmlnQnV0dG9uXCIpO1xudmFyIFJhaXNlU2hvcnRjdXRCdXR0b24gPSByZXF1aXJlKFwiLi9SYWlzZVNob3J0Y3V0QnV0dG9uXCIpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xuXG4vKipcbiAqIEJ1dHRvbnNcbiAqIEBjbGFzcyBCdXR0b25zVmlld1xuICovXG5mdW5jdGlvbiBCdXR0b25zVmlldyh2aWV3Q29uZmlnLCByZXNvdXJjZXMpIHtcblx0UElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLmNhbGwodGhpcyk7XG5cblx0dGhpcy5yZXNvdXJjZXMgPSByZXNvdXJjZXM7XG5cblx0dGhpcy5idXR0b25Ib2xkZXIgPSBuZXcgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyKCk7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5idXR0b25Ib2xkZXIpO1xuXG5cdHZhciBzbGlkZXJCYWNrZ3JvdW5kID0gbmV3IE5pbmVTbGljZSh0aGlzLnJlc291cmNlcy5nZXRUZXh0dXJlKFwic2xpZGVyQmFja2dyb3VuZFwiKSwgMjAsIDAsIDIwLCAwKTtcblx0c2xpZGVyQmFja2dyb3VuZC5zZXRMb2NhbFNpemUoMzAwLHNsaWRlckJhY2tncm91bmQuaGVpZ2h0KTtcblx0Ly9zbGlkZXJCYWNrZ3JvdW5kLndpZHRoID0gMzAwO1xuXG5cdHZhciBrbm9iID0gbmV3IFBJWEkuU3ByaXRlKHRoaXMucmVzb3VyY2VzLmdldFRleHR1cmUoXCJzbGlkZXJLbm9iXCIpKTtcblxuXHR0aGlzLnNsaWRlciA9IG5ldyBTbGlkZXIoc2xpZGVyQmFja2dyb3VuZCwga25vYik7XG5cdHZhciBwb3MgPSB0aGlzLnJlc291cmNlcy5nZXRQb2ludChcImJpZ0J1dHRvblBvc2l0aW9uXCIpO1xuXHR0aGlzLnNsaWRlci5wb3NpdGlvbi54ID0gcG9zLng7XG5cdHRoaXMuc2xpZGVyLnBvc2l0aW9uLnkgPSBwb3MueSAtIDM1O1xuXHR0aGlzLnNsaWRlci5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMub25TbGlkZXJDaGFuZ2UsIHRoaXMpO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMuc2xpZGVyKTtcblxuXG5cdHRoaXMuYnV0dG9uSG9sZGVyLnBvc2l0aW9uLnggPSAzNjY7XG5cdHRoaXMuYnV0dG9uSG9sZGVyLnBvc2l0aW9uLnkgPSA1NzU7XG5cblx0dGhpcy5idXR0b25zID0gW107XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHR2YXIgYnV0dG9uID0gbmV3IEJpZ0J1dHRvbih0aGlzLnJlc291cmNlcyk7XG5cdFx0YnV0dG9uLm9uKEJ1dHRvbi5DTElDSywgdGhpcy5vbkJ1dHRvbkNsaWNrLCB0aGlzKTtcblx0XHRidXR0b24ucG9zaXRpb24ueCA9IGkgKiAxMDU7XG5cdFx0dGhpcy5idXR0b25Ib2xkZXIuYWRkQ2hpbGQoYnV0dG9uKTtcblx0XHR0aGlzLmJ1dHRvbnMucHVzaChidXR0b24pO1xuXHR9XG5cblx0dmFyIHJhaXNlU3ByaXRlID0gbmV3IFBJWEkuU3ByaXRlKHRoaXMucmVzb3VyY2VzLmdldFRleHR1cmUoXCJzbGlkZXJLbm9iXCIpKTtcblx0dmFyIGFycm93U3ByaXRlID0gbmV3IFBJWEkuU3ByaXRlKHRoaXMucmVzb3VyY2VzLmdldFRleHR1cmUoXCJ1cEFycm93XCIpKTtcblx0YXJyb3dTcHJpdGUucG9zaXRpb24ueCA9IChyYWlzZVNwcml0ZS53aWR0aCAtIGFycm93U3ByaXRlLndpZHRoKSowLjUgLSAwLjU7XG5cdGFycm93U3ByaXRlLnBvc2l0aW9uLnkgPSAocmFpc2VTcHJpdGUuaGVpZ2h0IC0gYXJyb3dTcHJpdGUuaGVpZ2h0KSowLjUgLSAyO1xuXHRyYWlzZVNwcml0ZS5hZGRDaGlsZChhcnJvd1Nwcml0ZSk7XG5cblx0dGhpcy5yYWlzZU1lbnVCdXR0b24gPSBuZXcgQnV0dG9uKHJhaXNlU3ByaXRlKTtcblx0dGhpcy5yYWlzZU1lbnVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihCdXR0b24uQ0xJQ0ssIHRoaXMub25SYWlzZU1lbnVCdXR0b25DbGljaywgdGhpcyk7XG5cdHRoaXMucmFpc2VNZW51QnV0dG9uLnBvc2l0aW9uLnggPSAyKjEwNSArIDcwO1xuXHR0aGlzLnJhaXNlTWVudUJ1dHRvbi5wb3NpdGlvbi55ID0gLTU7XG5cdHRoaXMuYnV0dG9uSG9sZGVyLmFkZENoaWxkKHRoaXMucmFpc2VNZW51QnV0dG9uKTtcblxuXHR0aGlzLnJhaXNlTWVudUJ1dHRvbi52aXNpYmxlID0gZmFsc2U7XG5cdHRoaXMuY3JlYXRlUmFpc2VBbW91bnRNZW51KCk7XG5cblx0dGhpcy5zZXRCdXR0b25zKFtdLCAwLCAtMSwgLTEpO1xuXG5cdHRoaXMuYnV0dG9uc0RhdGFzID0gW107XG59XG5cbmluaGVyaXRzKEJ1dHRvbnNWaWV3LCBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIpO1xuRXZlbnREaXNwYXRjaGVyLmluaXQoQnV0dG9uc1ZpZXcpO1xuXG5CdXR0b25zVmlldy5CVVRUT05fQ0xJQ0sgPSBcImJ1dHRvbkNsaWNrXCI7XG5cblxuLyoqXG4gKiBDcmVhdGUgcmFpc2UgYW1vdW50IG1lbnUuXG4gKiBAbWV0aG9kIGNyZWF0ZVJhaXNlQW1vdW50TWVudVxuICovXG5CdXR0b25zVmlldy5wcm90b3R5cGUuY3JlYXRlUmFpc2VBbW91bnRNZW51ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMucmFpc2VBbW91bnRNZW51ID0gbmV3IFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcigpO1xuXG5cdHRoaXMucmFpc2VNZW51QmFja2dyb3VuZCA9IG5ldyBOaW5lU2xpY2UodGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcImNoYXRCYWNrZ3JvdW5kXCIpLCAxMCwgMTAsIDEwLCAxMCk7XG5cdHRoaXMucmFpc2VNZW51QmFja2dyb3VuZC5wb3NpdGlvbi54ID0gMDtcblx0dGhpcy5yYWlzZU1lbnVCYWNrZ3JvdW5kLnBvc2l0aW9uLnkgPSAwO1xuXHR0aGlzLnJhaXNlTWVudUJhY2tncm91bmQud2lkdGggPSAxMjU7XG5cdHRoaXMucmFpc2VNZW51QmFja2dyb3VuZC5oZWlnaHQgPSAyMjA7XG5cdHRoaXMucmFpc2VBbW91bnRNZW51LmFkZENoaWxkKHRoaXMucmFpc2VNZW51QmFja2dyb3VuZCk7XG5cblx0dGhpcy5yYWlzZUFtb3VudE1lbnUueCA9IDY0NTtcblx0dGhpcy5yYWlzZUFtb3VudE1lbnUueSA9IDU3MCAtIHRoaXMucmFpc2VBbW91bnRNZW51LmhlaWdodDtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLnJhaXNlQW1vdW50TWVudSk7XG5cblx0dmFyIHN0eWxlT2JqZWN0ID0ge1xuXHRcdGZvbnQ6IFwiYm9sZCAxOHB4IEFyaWFsXCIsXG5cdH07XG5cblx0dmFyIHQgPSBuZXcgUElYSS5UZXh0KFwiUkFJU0UgVE9cIiwgc3R5bGVPYmplY3QpO1xuXHR0LnBvc2l0aW9uLnggPSAoMTI1IC0gdC53aWR0aCkqMC41O1xuXHR0LnBvc2l0aW9uLnkgPSAxMDtcblx0dGhpcy5yYWlzZUFtb3VudE1lbnUuYWRkQ2hpbGQodCk7XG5cblx0dGhpcy5yYWlzZVNob3J0Y3V0QnV0dG9ucyA9IG5ldyBBcnJheSgpO1xuXG5cdGZvcih2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcblx0XHR2YXIgYiA9IG5ldyBSYWlzZVNob3J0Y3V0QnV0dG9uKHRoaXMucmVzb3VyY2VzKTtcblx0XHRiLmFkZEV2ZW50TGlzdGVuZXIoQnV0dG9uLkNMSUNLLCB0aGlzLm9uUmFpc2VTaG9ydGN1dENsaWNrLCB0aGlzKTtcblx0XHRiLnBvc2l0aW9uLnggPSAxMDtcblx0XHRiLnBvc2l0aW9uLnkgPSAzNSArIGkqMzA7XG5cblx0XHR0aGlzLnJhaXNlQW1vdW50TWVudS5hZGRDaGlsZChiKTtcblx0XHR0aGlzLnJhaXNlU2hvcnRjdXRCdXR0b25zLnB1c2goYik7XG5cdH1cblxuLypcblx0UGl4aVRleHRpbnB1dCBzaG91bGQgYmUgdXNlZC5cblx0dGhpcy5yYWlzZUFtb3VudE1lbnVJbnB1dD1uZXcgVGV4dEZpZWxkKCk7XG5cdHRoaXMucmFpc2VBbW91bnRNZW51SW5wdXQueD0xMDtcblx0dGhpcy5yYWlzZUFtb3VudE1lbnVJbnB1dC55PTQwKzMwKjU7XG5cdHRoaXMucmFpc2VBbW91bnRNZW51SW5wdXQud2lkdGg9MTA1O1xuXHR0aGlzLnJhaXNlQW1vdW50TWVudUlucHV0LmhlaWdodD0xOTtcblx0dGhpcy5yYWlzZUFtb3VudE1lbnVJbnB1dC5ib3JkZXI9dHJ1ZTtcblx0dGhpcy5yYWlzZUFtb3VudE1lbnVJbnB1dC5ib3JkZXJDb2xvcj0weDQwNDA0MDtcblx0dGhpcy5yYWlzZUFtb3VudE1lbnVJbnB1dC5iYWNrZ3JvdW5kPXRydWU7XG5cdHRoaXMucmFpc2VBbW91bnRNZW51SW5wdXQubXVsdGlsaW5lPWZhbHNlO1xuXHR0aGlzLnJhaXNlQW1vdW50TWVudUlucHV0LnR5cGU9VGV4dEZpZWxkVHlwZS5JTlBVVDtcblx0dGhpcy5yYWlzZUFtb3VudE1lbnVJbnB1dC5hZGRFdmVudExpc3RlbmVyKEV2ZW50LkNIQU5HRSxvblJhaXNlQW1vdW50TWVudUlucHV0Q2hhbmdlKTtcblx0dGhpcy5yYWlzZUFtb3VudE1lbnVJbnB1dC5hZGRFdmVudExpc3RlbmVyKEtleWJvYXJkRXZlbnQuS0VZX0RPV04sb25SYWlzZUFtb3VudE1lbnVJbnB1dEtleURvd24pO1xuXHR0aGlzLnJhaXNlQW1vdW50TWVudS5hZGRDaGlsZCh0aGlzLnJhaXNlQW1vdW50TWVudUlucHV0KTtcblx0Ki9cblxuXHR0aGlzLnJhaXNlQW1vdW50TWVudS52aXNpYmxlID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmFpc2UgYW1vdW50IGJ1dHRvbi5cbiAqIEBtZXRob2Qgb25SYWlzZU1lbnVCdXR0b25DbGlja1xuICovXG5CdXR0b25zVmlldy5wcm90b3R5cGUub25SYWlzZVNob3J0Y3V0Q2xpY2sgPSBmdW5jdGlvbigpIHtcblx0Lyp2YXIgYiA9IGNhc3QgZS50YXJnZXQ7XG5cblx0X3JhaXNlQW1vdW50TWVudS52aXNpYmxlPWZhbHNlO1xuXG5cdGJ1dHRvbnNbX3NsaWRlckluZGV4XS52YWx1ZT1iLnZhbHVlO1xuXHRfc2xpZGVyLnZhbHVlPShidXR0b25zW19zbGlkZXJJbmRleF0udmFsdWUtX3NsaWRlck1pbikvKF9zbGlkZXJNYXgtX3NsaWRlck1pbik7XG5cdF9yYWlzZUFtb3VudE1lbnVJbnB1dC50ZXh0PVN0ZC5zdHJpbmcoYnV0dG9uc1tfc2xpZGVySW5kZXhdLnZhbHVlKTtcblxuXHR0cmFjZShcInZhbHVlIGNsaWNrOiBcIitiLnZhbHVlKTsqL1xufVxuXG5cblxuLyoqXG4gKiBSYWlzZSBhbW91bnQgYnV0dG9uLlxuICogQG1ldGhvZCBvblJhaXNlTWVudUJ1dHRvbkNsaWNrXG4gKi9cbkJ1dHRvbnNWaWV3LnByb3RvdHlwZS5vblJhaXNlTWVudUJ1dHRvbkNsaWNrID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMucmFpc2VBbW91bnRNZW51LnZpc2libGUgPSAhdGhpcy5yYWlzZUFtb3VudE1lbnUudmlzaWJsZTtcbi8qXG5cdGlmKHRoaXMucmFpc2VBbW91bnRNZW51LnZpc2libGUpIHtcblx0XHR0aGlzLnN0YWdlLm1vdXNlZG93biA9IHRoaXMub25TdGFnZU1vdXNlRG93bi5iaW5kKHRoaXMpO1xuXHRcdC8vIHRoaXMucmFpc2VBbW91bnRNZW51SW5wdXQuZm9jdXMoKTtcblx0XHQvLyB0aGlzLnJhaXNlQW1vdW50TWVudUlucHV0LlNlbGVjdEFsbFxuXHR9XG5cdGVsc2Uge1xuXHRcdHRoaXMuc3RhZ2UubW91c2Vkb3duID0gbnVsbDtcblx0fSovXG59XG5cbi8qKlxuICogU2xpZGVyIGNoYW5nZS5cbiAqIEBtZXRob2Qgb25TbGlkZXJDaGFuZ2VcbiAqL1xuQnV0dG9uc1ZpZXcucHJvdG90eXBlLm9uU2xpZGVyQ2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cdHZhciBuZXdWYWx1ZSA9IE1hdGgucm91bmQodGhpcy5zbGlkZXJNaW4gKyB0aGlzLnNsaWRlci5nZXRWYWx1ZSgpKih0aGlzLnNsaWRlck1heCAtIHRoaXMuc2xpZGVyTWluKSk7XG5cdHRoaXMuYnV0dG9uc1t0aGlzLnNsaWRlckluZGV4XS5zZXRWYWx1ZShuZXdWYWx1ZSk7XG5cdHRoaXMuYnV0dG9uRGF0YXNbdGhpcy5zbGlkZXJJbmRleF0udmFsdWUgPSBuZXdWYWx1ZTtcblx0Y29uc29sZS5sb2coXCJuZXdWYWx1ZSA9IFwiICsgbmV3VmFsdWUpO1xuXG5cdC8vdGhpcy5yYWlzZUFtb3VudE1lbnVJbnB1dC5zZXRUZXh0KGJ1dHRvbnNbX3NsaWRlckluZGV4XS52YWx1ZS50b1N0cmluZygpKTtcbn1cblxuLyoqXG4gKiBTaG93IHNsaWRlci5cbiAqIEBtZXRob2Qgc2hvd1NsaWRlclxuICovXG5CdXR0b25zVmlldy5wcm90b3R5cGUuc2hvd1NsaWRlciA9IGZ1bmN0aW9uKGluZGV4LCBtaW4sIG1heCkge1xuXHRjb25zb2xlLmxvZyhcInNob3dTbGlkZXJcIik7XG5cdHRoaXMuc2xpZGVySW5kZXggPSBpbmRleDtcblx0dGhpcy5zbGlkZXJNaW4gPSBtaW47XG5cdHRoaXMuc2xpZGVyTWF4ID0gbWF4O1xuXG5cdGNvbnNvbGUubG9nKFwidGhpcy5idXR0b25EYXRhc1tcIitpbmRleCtcIl0gPSBcIiArIHRoaXMuYnV0dG9uRGF0YXNbaW5kZXhdLmdldFZhbHVlKCkgKyBcIiwgbWluID0gXCIgKyBtaW4gKyBcIiwgbWF4ID0gXCIgKyBtYXgpO1xuXHR0aGlzLnNsaWRlci5zZXRWYWx1ZSgodGhpcy5idXR0b25EYXRhc1tpbmRleF0uZ2V0VmFsdWUoKSAtIG1pbikvKG1heCAtIG1pbikpO1xuXHRjb25zb2xlLmxvZyhcInRoaXMuc2xpZGVyLmdldFZhbHVlKCkgPSBcIiArIHRoaXMuc2xpZGVyLmdldFZhbHVlKCkpO1xuXHR0aGlzLnNsaWRlci52aXNpYmxlID0gdHJ1ZTtcblx0dGhpcy5zbGlkZXIuc2hvdygpO1xufVxuXG4vKipcbiAqIENsZWFyLlxuICogQG1ldGhvZCBjbGVhclxuICovXG5CdXR0b25zVmlldy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbihidXR0b25EYXRhcykge1xuXHR0aGlzLnNldEJ1dHRvbnMoW10sIDAsIC0xLCAtMSk7XG5cdHRoaXMuc2xpZGVyLnZpc2libGUgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBTZXQgYnV0dG9uIGRhdGFzLlxuICogQG1ldGhvZCBzZXRCdXR0b25zXG4gKi9cbkJ1dHRvbnNWaWV3LnByb3RvdHlwZS5zZXRCdXR0b25zID0gZnVuY3Rpb24oYnV0dG9uRGF0YXMsIHNsaWRlckJ1dHRvbkluZGV4LCBtaW4sIG1heCkge1xuXHR0aGlzLmJ1dHRvbkRhdGFzID0gYnV0dG9uRGF0YXM7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJ1dHRvbnMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgYnV0dG9uID0gdGhpcy5idXR0b25zW2ldO1xuXHRcdGlmIChpID49IGJ1dHRvbkRhdGFzLmxlbmd0aCkge1xuXHRcdFx0YnV0dG9uLnZpc2libGUgPSBmYWxzZTtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHZhciBidXR0b25EYXRhID0gYnV0dG9uRGF0YXNbaV07XG5cblx0XHRidXR0b24udmlzaWJsZSA9IHRydWU7XG5cdFx0YnV0dG9uLnNldExhYmVsKGJ1dHRvbkRhdGEuZ2V0QnV0dG9uU3RyaW5nKCkpO1xuXHRcdGJ1dHRvbi5zZXRWYWx1ZShidXR0b25EYXRhLmdldFZhbHVlKCkpO1xuXG5cdH1cblxuXHRpZigobWluID49IDApICYmIChtYXggPj0gMCkpXG5cdFx0dGhpcy5zaG93U2xpZGVyKHNsaWRlckJ1dHRvbkluZGV4LCBtaW4sIG1heCk7XG5cblx0dGhpcy5idXR0b25Ib2xkZXIucG9zaXRpb24ueCA9IDM2NjtcblxuXHRpZiAoYnV0dG9uRGF0YXMubGVuZ3RoIDwgMylcblx0XHR0aGlzLmJ1dHRvbkhvbGRlci5wb3NpdGlvbi54ICs9IDQ1O1xufVxuXG4vKipcbiAqIEJ1dHRvbiBjbGljay5cbiAqIEBtZXRob2Qgb25CdXR0b25DbGlja1xuICogQHByaXZhdGVcbiAqL1xuQnV0dG9uc1ZpZXcucHJvdG90eXBlLm9uQnV0dG9uQ2xpY2sgPSBmdW5jdGlvbihlKSB7XG5cdHZhciBidXR0b25JbmRleCA9IC0xO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5idXR0b25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0dGhpcy5idXR0b25zW2ldLnZpc2libGUgPSBmYWxzZTtcblx0XHRpZiAoZS50YXJnZXQgPT0gdGhpcy5idXR0b25zW2ldKVxuXHRcdFx0YnV0dG9uSW5kZXggPSBpO1xuXHR9XG5cblx0dGhpcy5zbGlkZXIudmlzaWJsZSA9IGZhbHNlO1xuXG5cdC8vY29uc29sZS5sb2coXCJidXR0b24gY2xpY2s6IFwiICsgYnV0dG9uSW5kZXgpO1xuXHR2YXIgYnV0dG9uRGF0YSA9IHRoaXMuYnV0dG9uRGF0YXNbYnV0dG9uSW5kZXhdO1xuXG5cdHRoaXMudHJpZ2dlcih7XG5cdFx0dHlwZTogQnV0dG9uc1ZpZXcuQlVUVE9OX0NMSUNLLFxuXHRcdGJ1dHRvbjogYnV0dG9uRGF0YS5nZXRCdXR0b24oKSxcblx0XHR2YWx1ZTogYnV0dG9uRGF0YS5nZXRWYWx1ZSgpXG5cdH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1dHRvbnNWaWV3OyIsIi8qKlxuICogQ2xpZW50LlxuICogQG1vZHVsZSBjbGllbnRcbiAqL1xuXG52YXIgUElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xuXG4vKipcbiAqIFRoZSBmcm9udCB2aWV3IG9mIGEgY2FyZC5cbiAqIEBjbGFzcyBDYXJkRnJvbnRWaWV3XG4gKi9cbmZ1bmN0aW9uIENhcmRGcm9udFZpZXcodmlld0NvbmZpZywgcmVzb3VyY2VzKSB7XG5cdFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKHRoaXMpO1xuXG5cdHRoaXMucmVzb3VyY2VzID0gcmVzb3VyY2VzO1xufTtcbmluaGVyaXRzKENhcmRGcm9udFZpZXcsIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcik7XG5cblxuQ2FyZEZyb250Vmlldy5wcm90b3R5cGUuc2V0Q2FyZERhdGEgPSBmdW5jdGlvbihjYXJkRGF0YSkge1xuXHR0aGlzLmNhcmREYXRhID0gY2FyZERhdGE7XG5cblx0Ly8gY2FyZERpYW1vbmRzMiBjYXJkRGlhbW9uZHMzIGNhcmREaWFtb25kczQgY2FyZERpYW1vbmRzNSAuLi4gIGNhcmREaWFtb25kc1EgIGNhcmREaWFtb25kc0sgIGNhcmREaWFtb25kc0Fcblx0dmFyIGNhcmRUZXh0dXJlO1xuXHR2YXIgY3VzdG9tTmFtZSA9IFwiY2FyZFwiICsgdGhpcy5jYXJkRGF0YS5nZXRMb25nU3VpdFN0cmluZygpICsgdGhpcy5jYXJkRGF0YS5nZXRDYXJkVmFsdWVTdHJpbmcoKTtcblxuXHRpZiAodGhpcy5yZXNvdXJjZXMua2V5RXhpc3RzKGN1c3RvbU5hbWUpKVxuXHRcdGNhcmRUZXh0dXJlID0gdGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShjdXN0b21OYW1lKTtcblxuXHRpZiAoY2FyZFRleHR1cmUpIHtcblx0XHR0aGlzLmZyYW1lID0gbmV3IFBJWEkuU3ByaXRlKGNhcmRUZXh0dXJlKTtcblx0XHR0aGlzLmFkZENoaWxkKHRoaXMuZnJhbWUpO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuZnJhbWUgPSBuZXcgUElYSS5TcHJpdGUodGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcImNhcmRGcmFtZVwiKSk7XG5cdFx0dGhpcy5hZGRDaGlsZCh0aGlzLmZyYW1lKTtcblxuXG5cdFx0dGhpcy5zdWl0ID0gbmV3IFBJWEkuU3ByaXRlKHRoaXMucmVzb3VyY2VzLmdldFRleHR1cmUoXCJzdWl0U3ltYm9sXCIgKyB0aGlzLmNhcmREYXRhLmdldFN1aXRJbmRleCgpKSk7XG5cdFx0dGhpcy5zdWl0LnBvc2l0aW9uLnggPSA4O1xuXHRcdHRoaXMuc3VpdC5wb3NpdGlvbi55ID0gMjU7XG5cdFx0dGhpcy5hZGRDaGlsZCh0aGlzLnN1aXQpO1xuXG5cdFx0dmFyIHN0eWxlID0ge1xuXHRcdFx0Zm9udDogXCJib2xkIDE2cHggQXJpYWxcIlxuXHRcdH07XG5cblx0XHR0aGlzLnZhbHVlRmllbGQgPSBuZXcgUElYSS5UZXh0KFwiW3ZhbF1cIiwgc3R5bGUpO1xuXHRcdHRoaXMuYWRkQ2hpbGQodGhpcy52YWx1ZUZpZWxkKTtcblx0XHR0aGlzLnZhbHVlRmllbGQuc3R5bGUuZmlsbCA9IHRoaXMuY2FyZERhdGEuZ2V0Q29sb3IoKTtcblxuXHRcdHRoaXMudmFsdWVGaWVsZC5zZXRUZXh0KHRoaXMuY2FyZERhdGEuZ2V0Q2FyZFZhbHVlU3RyaW5nKCkpO1xuXHRcdHRoaXMudmFsdWVGaWVsZC51cGRhdGVUcmFuc2Zvcm0oKTtcblx0XHR0aGlzLnZhbHVlRmllbGQucG9zaXRpb24ueCA9IDE3IC0gdGhpcy52YWx1ZUZpZWxkLmNhbnZhcy53aWR0aCAvIDI7XG5cdFx0dGhpcy52YWx1ZUZpZWxkLnBvc2l0aW9uLnkgPSA1O1xuXG5cdFx0dGhpcy5zdWl0LnNldFRleHR1cmUodGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcInN1aXRTeW1ib2xcIiArIHRoaXMuY2FyZERhdGEuZ2V0U3VpdEluZGV4KCkpKTtcblx0fVxufTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gQ2FyZEZyb250VmlldzsiLCIvKipcbiAqIENsaWVudC5cbiAqIEBtb2R1bGUgY2xpZW50XG4gKi9cblxudmFyIFBJWEkgPSByZXF1aXJlKFwicGl4aS5qc1wiKTtcbnZhciBUV0VFTiA9IHJlcXVpcmUoXCJ0d2Vlbi5qc1wiKTtcbnZhciBDYXJkRnJvbnRWaWV3ID0gcmVxdWlyZShcIi4vQ2FyZEZyb250Vmlld1wiKTtcbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKFwieWFlZFwiKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCJpbmhlcml0c1wiKTtcblxuLyoqXG4gKiBBIGNhcmQgdmlldy5cbiAqIEBjbGFzcyBDYXJkVmlld1xuICovXG5mdW5jdGlvbiBDYXJkVmlldyh2aWV3Q29uZmlnLCByZXNvdXJjZXMpIHtcblx0UElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLmNhbGwodGhpcyk7XG5cdHRoaXMudGFyZ2V0UG9zaXRpb24gPSBudWxsO1xuXG5cdHRoaXMudmlld0NvbmZpZyA9IHZpZXdDb25maWc7XG5cdHRoaXMucmVzb3VyY2VzID0gcmVzb3VyY2VzO1xuXG5cblx0dGhpcy5mcm9udCA9IG5ldyBDYXJkRnJvbnRWaWV3KHRoaXMudmlld0NvbmZpZywgdGhpcy5yZXNvdXJjZXMpOy8vUElYSS5TcHJpdGUodGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcImNhcmRGcmFtZVwiKSk7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5mcm9udCk7XG4vKlxuXHR0aGlzLnN1aXQgPSBuZXcgUElYSS5TcHJpdGUodGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcInN1aXRTeW1ib2xcIiArIDApKTtcblx0dGhpcy5zdWl0LnBvc2l0aW9uLnggPSA4O1xuXHR0aGlzLnN1aXQucG9zaXRpb24ueSA9IDI1O1xuXHR0aGlzLmFkZENoaWxkKHRoaXMuc3VpdCk7XG4qL1xuLypcdHZhciBzdHlsZSA9IHtcblx0XHRmb250OiBcImJvbGQgMTZweCBBcmlhbFwiXG5cdH07XG5cblx0dGhpcy52YWx1ZUZpZWxkID0gbmV3IFBJWEkuVGV4dChcIlt2YWxdXCIsIHN0eWxlKTtcblx0dGhpcy52YWx1ZUZpZWxkLnBvc2l0aW9uLnggPSA2O1xuXHR0aGlzLnZhbHVlRmllbGQucG9zaXRpb24ueSA9IDU7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy52YWx1ZUZpZWxkKTtcbiovXG5cdHRoaXMuYmFjayA9IG5ldyBQSVhJLlNwcml0ZSh0aGlzLnJlc291cmNlcy5nZXRUZXh0dXJlKFwiY2FyZEJhY2tcIikpO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMuYmFjayk7XG5cblxuXHR0aGlzLm1hc2tHcmFwaGljcyA9IG5ldyBQSVhJLkdyYXBoaWNzKCk7XG5cdHRoaXMubWFza0dyYXBoaWNzLmJlZ2luRmlsbCgweDAwMDAwMCk7XG5cdHRoaXMubWFza0dyYXBoaWNzLmRyYXdSZWN0KDAsIDAsIHRoaXMuYmFjay53aWR0aCwgdGhpcy5iYWNrLmhlaWdodCk7XG5cdHRoaXMubWFza0dyYXBoaWNzLmVuZEZpbGwoKTtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLm1hc2tHcmFwaGljcyk7XG5cblx0dGhpcy5tYXNrID0gdGhpcy5tYXNrR3JhcGhpY3M7XG59XG5cbmluaGVyaXRzKENhcmRWaWV3LCBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIpO1xuRXZlbnREaXNwYXRjaGVyLmluaXQoQ2FyZFZpZXcpO1xuXG4vKipcbiAqIFNldCBjYXJkIGRhdGEuXG4gKiBAbWV0aG9kIHNldENhcmREYXRhXG4gKi9cbkNhcmRWaWV3LnByb3RvdHlwZS5zZXRDYXJkRGF0YSA9IGZ1bmN0aW9uKGNhcmREYXRhKSB7XG5cdHRoaXMuY2FyZERhdGEgPSBjYXJkRGF0YTtcblxuXG5cdGlmICh0aGlzLmNhcmREYXRhLmlzU2hvd24oKSkge1xuXHRcdC8qXG5cdFx0dGhpcy5iYWNrLnZpc2libGUgPSBmYWxzZTtcblx0XHR0aGlzLmZyYW1lLnZpc2libGUgPSB0cnVlO1xuKi9cbi8qXG5cdFx0dGhpcy52YWx1ZUZpZWxkLnN0eWxlLmZpbGwgPSB0aGlzLmNhcmREYXRhLmdldENvbG9yKCk7XG5cblx0XHR0aGlzLnZhbHVlRmllbGQuc2V0VGV4dCh0aGlzLmNhcmREYXRhLmdldENhcmRWYWx1ZVN0cmluZygpKTtcblx0XHR0aGlzLnZhbHVlRmllbGQudXBkYXRlVHJhbnNmb3JtKCk7XG5cdFx0dGhpcy52YWx1ZUZpZWxkLnBvc2l0aW9uLnggPSAxNyAtIHRoaXMudmFsdWVGaWVsZC5jYW52YXMud2lkdGggLyAyO1xuXG5cdFx0dGhpcy5zdWl0LnNldFRleHR1cmUodGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcInN1aXRTeW1ib2xcIiArIHRoaXMuY2FyZERhdGEuZ2V0U3VpdEluZGV4KCkpKTtcblx0XHQqL1xuXHRcdHRoaXMuZnJvbnQuc2V0Q2FyZERhdGEodGhpcy5jYXJkRGF0YSk7XG5cblx0XHR0aGlzLm1hc2tHcmFwaGljcy5iZWdpbkZpbGwoMHgwMDAwMDApO1xuXHRcdHRoaXMubWFza0dyYXBoaWNzLmRyYXdSZWN0KDAsIDAsIHRoaXMuZnJvbnQud2lkdGgsIHRoaXMuZnJvbnQuaGVpZ2h0KTtcblx0XHR0aGlzLm1hc2tHcmFwaGljcy5lbmRGaWxsKCk7XG5cdH1cblx0dGhpcy5iYWNrLnZpc2libGUgPSB0cnVlO1xuXHR0aGlzLmZyb250LnZpc2libGUgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBTZXQgY2FyZCBkYXRhLlxuICogQG1ldGhvZCBzZXRDYXJkRGF0YVxuICovXG5DYXJkVmlldy5wcm90b3R5cGUuc2V0VGFyZ2V0UG9zaXRpb24gPSBmdW5jdGlvbihwb2ludCkge1xuXHR0aGlzLnRhcmdldFBvc2l0aW9uID0gcG9pbnQ7XG5cblx0dGhpcy5wb3NpdGlvbi54ID0gcG9pbnQueDtcblx0dGhpcy5wb3NpdGlvbi55ID0gcG9pbnQueTtcbn1cblxuLyoqXG4gKiBIaWRlLlxuICogQG1ldGhvZCBoaWRlXG4gKi9cbkNhcmRWaWV3LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMudmlzaWJsZSA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFNob3cuXG4gKiBAbWV0aG9kIHNob3dcbiAqL1xuQ2FyZFZpZXcucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbihhbmltYXRlLCBkZWxheSkge1xuXHQvKmlmKGRlbGF5ID09IHVuZGVmaW5lZClcblx0XHRkZWxheSA9IDE7XG5cdCovXG5cdHRoaXMubWFza0dyYXBoaWNzLnNjYWxlLnkgPSAxO1xuXHR0aGlzLnBvc2l0aW9uLnggPSB0aGlzLnRhcmdldFBvc2l0aW9uLng7XG5cdHRoaXMucG9zaXRpb24ueSA9IHRoaXMudGFyZ2V0UG9zaXRpb24ueTtcblx0aWYgKCFhbmltYXRlKSB7XG5cdFx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblx0XHR0aGlzLm9uU2hvd0NvbXBsZXRlKCk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdHRoaXMubWFzay5oZWlnaHQgPSB0aGlzLmhlaWdodDtcblxuXHR2YXIgZGVzdGluYXRpb24gPSB7XG5cdFx0eDogdGhpcy5wb3NpdGlvbi54LFxuXHRcdHk6IHRoaXMucG9zaXRpb24ueVxuXHR9O1xuXHR0aGlzLnBvc2l0aW9uLnggPSAodGhpcy5wYXJlbnQud2lkdGggLSB0aGlzLndpZHRoKSAqIDAuNTtcblx0dGhpcy5wb3NpdGlvbi55ID0gLXRoaXMuaGVpZ2h0O1xuXG5cdHZhciBkaWZmWCA9IHRoaXMucG9zaXRpb24ueCAtIGRlc3RpbmF0aW9uLng7XG5cdHZhciBkaWZmWSA9IHRoaXMucG9zaXRpb24ueSAtIGRlc3RpbmF0aW9uLnk7XG5cdHZhciBkaWZmID0gTWF0aC5zcXJ0KGRpZmZYICogZGlmZlggKyBkaWZmWSAqIGRpZmZZKTtcblxuXHR2YXIgdHdlZW4gPSBuZXcgVFdFRU4uVHdlZW4odGhpcy5wb3NpdGlvbilcblx0XHQvLyAgICAgICAgICAgIC5kZWxheShkZWxheSlcblx0XHQudG8oe1xuXHRcdFx0eDogZGVzdGluYXRpb24ueCxcblx0XHRcdHk6IGRlc3RpbmF0aW9uLnlcblx0XHR9LCB0aGlzLnZpZXdDb25maWcuc2NhbGVBbmltYXRpb25UaW1lKDUwMCkpXG5cdFx0LmVhc2luZyhUV0VFTi5FYXNpbmcuUXVhZHJhdGljLk91dClcblx0XHQub25TdGFydCh0aGlzLm9uU2hvd1N0YXJ0LmJpbmQodGhpcykpXG5cdFx0Lm9uQ29tcGxldGUodGhpcy5vblNob3dDb21wbGV0ZS5iaW5kKHRoaXMpKVxuXHRcdC5zdGFydCgpO1xufVxuXG4vKipcbiAqIFNob3cgY29tcGxldGUuXG4gKiBAbWV0aG9kIG9uU2hvd0NvbXBsZXRlXG4gKi9cbkNhcmRWaWV3LnByb3RvdHlwZS5vblNob3dTdGFydCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnZpc2libGUgPSB0cnVlO1xufVxuXG4vKipcbiAqIFNob3cgY29tcGxldGUuXG4gKiBAbWV0aG9kIG9uU2hvd0NvbXBsZXRlXG4gKi9cbkNhcmRWaWV3LnByb3RvdHlwZS5vblNob3dDb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5jYXJkRGF0YS5pc1Nob3duKCkpIHtcblx0XHR0aGlzLmJhY2sudmlzaWJsZSA9IGZhbHNlO1xuXHRcdHRoaXMuZnJvbnQudmlzaWJsZSA9IHRydWU7XG5cdH1cblx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiYW5pbWF0aW9uRG9uZVwiLCB0aGlzKTtcbn1cblxuLyoqXG4gKiBGb2xkLlxuICogQG1ldGhvZCBmb2xkXG4gKi9cbkNhcmRWaWV3LnByb3RvdHlwZS5mb2xkID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvID0ge1xuXHRcdHg6IHRoaXMudGFyZ2V0UG9zaXRpb24ueCxcblx0XHR5OiB0aGlzLnRhcmdldFBvc2l0aW9uLnkgKyA4MFxuXHR9O1xuXG5cdHZhciB0aW1lID0gdGhpcy52aWV3Q29uZmlnLnNjYWxlQW5pbWF0aW9uVGltZSg1MDApO1xuXHR0aGlzLnQwID0gbmV3IFRXRUVOLlR3ZWVuKHRoaXMucG9zaXRpb24pXG5cdFx0LnRvKG8sIHRpbWUpXG5cdFx0LmVhc2luZyhUV0VFTi5FYXNpbmcuUXVhZHJhdGljLk91dClcblx0XHQub25VcGRhdGUodGhpcy5vbkZvbGRVcGRhdGUuYmluZCh0aGlzKSlcblx0XHQub25Db21wbGV0ZSh0aGlzLm9uRm9sZENvbXBsZXRlLmJpbmQodGhpcykpXG5cdFx0LnN0YXJ0KCk7XG59XG5cbi8qKlxuICogRm9sZCBhbmltYXRpb24gdXBkYXRlLlxuICogQG1ldGhvZCBvbkZvbGRVcGRhdGVcbiAqL1xuQ2FyZFZpZXcucHJvdG90eXBlLm9uRm9sZFVwZGF0ZSA9IGZ1bmN0aW9uKHByb2dyZXNzKSB7XG5cdHRoaXMubWFza0dyYXBoaWNzLnNjYWxlLnkgPSAxIC0gcHJvZ3Jlc3M7XG59XG5cbi8qKlxuICogRm9sZCBhbmltYXRpb24gY29tcGxldGUuXG4gKiBAbWV0aG9kIG9uRm9sZENvbXBsZXRlXG4gKi9cbkNhcmRWaWV3LnByb3RvdHlwZS5vbkZvbGRDb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJhbmltYXRpb25Eb25lXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENhcmRWaWV3OyIsIi8qKlxuICogQ2xpZW50LlxuICogQG1vZHVsZSBjbGllbnRcbiAqL1xuXG52YXIgUElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xudmFyIE5pbmVTbGljZSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9OaW5lU2xpY2VcIik7XG52YXIgU2xpZGVyID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL1NsaWRlclwiKTtcbnZhciBQaXhpVGV4dElucHV0ID0gcmVxdWlyZShcInBpeGl0ZXh0aW5wdXRcIik7XG52YXIgTW91c2VPdmVyR3JvdXAgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvTW91c2VPdmVyR3JvdXBcIik7XG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZShcInlhZWRcIik7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiaW5oZXJpdHNcIik7XG5cbi8qKlxuICogQ2hhdCB2aWV3LlxuICogQGNsYXNzIENoYXRWaWV3XG4gKi9cbmZ1bmN0aW9uIENoYXRWaWV3KHZpZXdDb25maWcsIHJlc291cmNlcykge1xuXHRQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIuY2FsbCh0aGlzKTtcblxuXHR0aGlzLnJlc291cmNlcyA9IHJlc291cmNlcztcblx0dGhpcy5tYXJnaW4gPSA1O1xuXG5cdFxuXHR2YXIgY2hhdFBsYXRlID0gbmV3IE5pbmVTbGljZSh0aGlzLnJlc291cmNlcy5nZXRUZXh0dXJlKFwiZnJhbWVQbGF0ZVwiKSwgMTApO1xuXHRjaGF0UGxhdGUucG9zaXRpb24ueCA9IDEwO1xuXHRjaGF0UGxhdGUucG9zaXRpb24ueSA9IDU0MDtcblx0Y2hhdFBsYXRlLnNldExvY2FsU2l6ZSgzMzAsIDEzMCk7XG5cdHRoaXMuYWRkQ2hpbGQoY2hhdFBsYXRlKTtcblxuXHR2YXIgcyA9IG5ldyBOaW5lU2xpY2UodGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcImZyYW1lUGxhdGVcIiksIDEwKTtcblx0cy5wb3NpdGlvbi54ID0gMTA7XG5cdHMucG9zaXRpb24ueSA9IDY3NTtcblx0cy5zZXRMb2NhbFNpemUoMzMwLCAzNSk7XG5cdHRoaXMuYWRkQ2hpbGQocyk7XG5cblx0dmFyIHN0eWxlT2JqZWN0ID0ge1xuXHRcdGZvbnQ6IFwiMTJweCBBcmlhbFwiLFxuXHRcdHdvcmRXcmFwV2lkdGg6IDMxMCxcblx0XHRoZWlnaHQ6IDExNCxcblx0XHRib3JkZXI6IHRydWUsXG5cdFx0Y29sb3I6IDB4RkZGRkZGLFxuXHRcdGJvcmRlckNvbG9yOiAweDQwNDA0MCxcblx0XHR3b3JkV3JhcDogdHJ1ZSxcblx0XHRtdWx0aWxpbmU6IHRydWVcblx0fTtcblxuXHR0aGlzLmNvbnRhaW5lciA9IG5ldyBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIoKTtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG5cdHRoaXMuY29udGFpbmVyLnBvc2l0aW9uLnggPSAyMDtcblx0dGhpcy5jb250YWluZXIucG9zaXRpb24ueSA9IDU0ODtcblxuXHR0aGlzLmNoYXRNYXNrID0gbmV3IFBJWEkuR3JhcGhpY3MoKTtcblx0dGhpcy5jaGF0TWFzay5iZWdpbkZpbGwoMTIzKTtcblx0dGhpcy5jaGF0TWFzay5kcmF3UmVjdCgwLCAwLCAzMTAsIDExNCk7XG5cdHRoaXMuY2hhdE1hc2suZW5kRmlsbCgpO1xuXHR0aGlzLmNvbnRhaW5lci5hZGRDaGlsZCh0aGlzLmNoYXRNYXNrKTtcblxuXHR0aGlzLmNoYXRUZXh0ID0gbmV3IFBJWEkuVGV4dChcIlwiLCBzdHlsZU9iamVjdCk7XG5cdHRoaXMuY29udGFpbmVyLmFkZENoaWxkKHRoaXMuY2hhdFRleHQpO1xuXHR0aGlzLmNoYXRUZXh0Lm1hc2sgPSB0aGlzLmNoYXRNYXNrO1xuXG5cblxuXHR2YXIgc3R5bGVPYmplY3QgPSB7XG5cdFx0Zm9udDogXCIxNHB4IEFyaWFsXCIsXG5cdFx0d2lkdGg6IDMxMCxcblx0XHRoZWlnaHQ6IDE5LFxuXHRcdGJvcmRlcjogdHJ1ZSxcblx0XHRib3JkZXJDb2xvcjogMHg0MDQwNDAsXG5cdFx0YmFja2dyb3VuZDogdHJ1ZSxcblx0XHRtdWx0aWxpbmU6IHRydWVcblx0fTtcblx0dGhpcy5pbnB1dEZpZWxkID0gbmV3IFBpeGlUZXh0SW5wdXQoXCJcIiwgc3R5bGVPYmplY3QpO1xuXHR0aGlzLmlucHV0RmllbGQucG9zaXRpb24ueCA9IHRoaXMuY29udGFpbmVyLnBvc2l0aW9uLng7XG5cdHRoaXMuaW5wdXRGaWVsZC5wb3NpdGlvbi55ID0gNjgzO1xuXHR0aGlzLmlucHV0RmllbGQud2lkdGggPSAzMTA7XG5cdHRoaXMuaW5wdXRGaWVsZC5rZXlkb3duID0gdGhpcy5vbktleURvd24uYmluZCh0aGlzKTtcblxuXHR2YXIgaW5wdXRTaGFkb3cgPSBuZXcgUElYSS5HcmFwaGljcygpO1xuXHRpbnB1dFNoYWRvdy5iZWdpbkZpbGwoMHgwMDAwMDApO1xuXHRpbnB1dFNoYWRvdy5kcmF3UmVjdCgtMSwgLTEsIDMxMSwgMjApO1xuXHRpbnB1dFNoYWRvdy5wb3NpdGlvbi54ID0gdGhpcy5pbnB1dEZpZWxkLnBvc2l0aW9uLng7XG5cdGlucHV0U2hhZG93LnBvc2l0aW9uLnkgPSB0aGlzLmlucHV0RmllbGQucG9zaXRpb24ueTtcblx0dGhpcy5hZGRDaGlsZChpbnB1dFNoYWRvdyk7XG5cblx0dmFyIGlucHV0QmFja2dyb3VuZCA9IG5ldyBQSVhJLkdyYXBoaWNzKCk7XG5cdGlucHV0QmFja2dyb3VuZC5iZWdpbkZpbGwoMHhGRkZGRkYpO1xuXHRpbnB1dEJhY2tncm91bmQuZHJhd1JlY3QoMCwgMCwgMzEwLCAxOSk7XG5cdGlucHV0QmFja2dyb3VuZC5wb3NpdGlvbi54ID0gdGhpcy5pbnB1dEZpZWxkLnBvc2l0aW9uLng7XG5cdGlucHV0QmFja2dyb3VuZC5wb3NpdGlvbi55ID0gdGhpcy5pbnB1dEZpZWxkLnBvc2l0aW9uLnk7XG5cdHRoaXMuYWRkQ2hpbGQoaW5wdXRCYWNrZ3JvdW5kKTtcblxuXHR0aGlzLmFkZENoaWxkKHRoaXMuaW5wdXRGaWVsZCk7XG5cblxuXG5cdHZhciBzbGlkZUJhY2sgPSBuZXcgTmluZVNsaWNlKHRoaXMucmVzb3VyY2VzLmdldFRleHR1cmUoXCJ0ZXh0U2Nyb2xsYmFyVHJhY2tcIiksIDEwLCAwLCAxMCwgMCk7XG5cdHNsaWRlQmFjay53aWR0aCA9IDEwNztcblx0dmFyIHNsaWRlS25vYiA9IG5ldyBOaW5lU2xpY2UodGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcInRleHRTY3JvbGxiYXJUaHVtYlwiKSwgMTAsIDAsIDEwLCAwKTtcblx0c2xpZGVLbm9iLndpZHRoID0gMzA7XG5cblxuXHR0aGlzLnNsaWRlciA9IG5ldyBTbGlkZXIoc2xpZGVCYWNrLCBzbGlkZUtub2IpO1xuXHR0aGlzLnNsaWRlci5yb3RhdGlvbiA9IE1hdGguUEkqMC41O1xuXHR0aGlzLnNsaWRlci5wb3NpdGlvbi54ID0gMzI2O1xuXHR0aGlzLnNsaWRlci5wb3NpdGlvbi55ID0gNTUyO1xuXHR0aGlzLnNsaWRlci5zZXRWYWx1ZSgxKTtcblx0dGhpcy5zbGlkZXIudmlzaWJsZSA9IGZhbHNlO1xuXHR0aGlzLnNsaWRlci5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMub25TbGlkZXJDaGFuZ2UuYmluZCh0aGlzKSk7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5zbGlkZXIpO1xuXG5cblx0dGhpcy5tb3VzZU92ZXJHcm91cCA9IG5ldyBNb3VzZU92ZXJHcm91cCgpO1xuXHR0aGlzLm1vdXNlT3Zlckdyb3VwLmFkZERpc3BsYXlPYmplY3QodGhpcy5jaGF0VGV4dCk7XG5cdHRoaXMubW91c2VPdmVyR3JvdXAuYWRkRGlzcGxheU9iamVjdCh0aGlzLnNsaWRlcik7XG5cdHRoaXMubW91c2VPdmVyR3JvdXAuYWRkRGlzcGxheU9iamVjdCh0aGlzLmNoYXRNYXNrKTtcblx0dGhpcy5tb3VzZU92ZXJHcm91cC5hZGREaXNwbGF5T2JqZWN0KGNoYXRQbGF0ZSk7XG5cdHRoaXMubW91c2VPdmVyR3JvdXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCB0aGlzLm9uQ2hhdEZpZWxkTW91c2VPdmVyLCB0aGlzKTtcblx0dGhpcy5tb3VzZU92ZXJHcm91cC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgdGhpcy5vbkNoYXRGaWVsZE1vdXNlT3V0LCB0aGlzKTtcblx0dGhpcy5tb3VzZU92ZXJHcm91cC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMub25DaGF0RmllbGRNb3VzZURvd24sIHRoaXMpO1xuXHR0aGlzLm1vdXNlT3Zlckdyb3VwLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMub25DaGF0RmllbGRNb3VzZVVwLCB0aGlzKTtcblxuXHRjaGF0UGxhdGUudG91Y2hzdGFydCA9IHRoaXMub25DaGF0RmllbGRNb3VzZURvd24uYmluZCh0aGlzKTtcblxuXG5cdHRoaXMuY2xlYXIoKTtcbn1cblxuaW5oZXJpdHMoQ2hhdFZpZXcsIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcik7XG5FdmVudERpc3BhdGNoZXIuaW5pdChDaGF0Vmlldyk7XG5cblxuXG4vKipcbiAqIENsZWFyIG1lc3NhZ2VzLlxuICogQG1ldGhvZCBjbGVhclxuICovXG5DaGF0Vmlldy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5jaGF0VGV4dC5zZXRUZXh0KFwiXCIpO1xuIFx0dGhpcy5jaGF0VGV4dC55ID0gLU1hdGgucm91bmQodGhpcy5zbGlkZXIuZ2V0VmFsdWUoKSoodGhpcy5jaGF0VGV4dC5oZWlnaHQgKyB0aGlzLm1hcmdpbiAtIHRoaXMuY2hhdE1hc2suaGVpZ2h0ICkpO1xuXHR0aGlzLnNsaWRlci5zZXRWYWx1ZSgxKTtcbn1cblxuXG4vKipcbiAqICBBZGQgdGV4dC5cbiAqIEBtZXRob2QgY2xlYXJcbiAqL1xuQ2hhdFZpZXcucHJvdG90eXBlLmFkZFRleHQgPSBmdW5jdGlvbih1c2VyLCB0ZXh0KSB7XG5cdHRoaXMuY2hhdFRleHQuc2V0VGV4dCh0aGlzLmNoYXRUZXh0LnRleHQgKyB1c2VyICsgXCI6IFwiICsgdGV4dCArIFwiXFxuXCIpO1xuIFx0dGhpcy5jaGF0VGV4dC55ID0gLU1hdGgucm91bmQodGhpcy5zbGlkZXIuZ2V0VmFsdWUoKSoodGhpcy5jaGF0VGV4dC5oZWlnaHQgKyB0aGlzLm1hcmdpbiAtIHRoaXMuY2hhdE1hc2suaGVpZ2h0ICkpO1xuXHR0aGlzLnNsaWRlci5zZXRWYWx1ZSgxKTtcbn1cblxuLyoqXG4gKiBPbiBzbGlkZXIgdmFsdWUgY2hhbmdlXG4gKiBAbWV0aG9kIG9uU2xpZGVyQ2hhbmdlXG4gKi9cbiBDaGF0Vmlldy5wcm90b3R5cGUub25TbGlkZXJDaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiBcdHRoaXMuY2hhdFRleHQueSA9IC1NYXRoLnJvdW5kKHRoaXMuc2xpZGVyLmdldFZhbHVlKCkqKHRoaXMuY2hhdFRleHQuaGVpZ2h0ICsgdGhpcy5tYXJnaW4gLSB0aGlzLmNoYXRNYXNrLmhlaWdodCkpO1xuIH1cblxuXG4vKipcbiAqIE9uIG1vdXNlIG92ZXJcbiAqIEBtZXRob2Qgb25DaGF0RmllbGRNb3VzZU92ZXJcbiAqL1xuIENoYXRWaWV3LnByb3RvdHlwZS5vbkNoYXRGaWVsZE1vdXNlT3ZlciA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnNsaWRlci5zaG93KCk7XG4gfVxuXG5cbi8qKlxuICogT24gbW91c2Ugb3V0XG4gKiBAbWV0aG9kIG9uQ2hhdEZpZWxkTW91c2VPdXRcbiAqL1xuIENoYXRWaWV3LnByb3RvdHlwZS5vbkNoYXRGaWVsZE1vdXNlT3V0ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuc2xpZGVyLmhpZGUoKTtcbiB9XG5cbi8qKlxuICogT24gbW91c2UgZG93blxuICogQG1ldGhvZCBvbkNoYXRGaWVsZE1vdXNlRG93blxuICovXG5DaGF0Vmlldy5wcm90b3R5cGUub25DaGF0RmllbGRNb3VzZURvd24gPSBmdW5jdGlvbihpbnRlcmFjdGlvbl9vYmplY3QpIHtcblx0aW50ZXJhY3Rpb25fb2JqZWN0LnRhcmdldC50b3VjaGVuZCA9IGludGVyYWN0aW9uX29iamVjdC50YXJnZXQudG91Y2hlbmRvdXRzaWRlID0gdGhpcy5vbkNoYXRGaWVsZE1vdXNlVXAuYmluZCh0aGlzKTtcblx0aW50ZXJhY3Rpb25fb2JqZWN0LnRhcmdldC50b3VjaG1vdmUgPSB0aGlzLm9uQ2hhdEZpZWxkTW91c2VNb3ZlLmJpbmQodGhpcyk7XG5cdHRoaXMuc3RhcnRNb3VzZVBvcyA9IGludGVyYWN0aW9uX29iamVjdC5nbG9iYWwueTtcblx0dGhpcy5zdGFydFBvcyA9IHRoaXMuY2hhdFRleHQueTtcblx0dGhpcy5zbGlkZXIuc2hvdygpO1xufVxuXG4vKipcbiAqIE9uIG1vdXNlIHVwXG4gKiBAbWV0aG9kIG9uQ2hhdEZpZWxkTW91c2VVcFxuICovXG5DaGF0Vmlldy5wcm90b3R5cGUub25DaGF0RmllbGRNb3VzZVVwID0gZnVuY3Rpb24oaW50ZXJhY3Rpb25fb2JqZWN0KSB7XG5cdGludGVyYWN0aW9uX29iamVjdC50YXJnZXQudG91Y2hlbmQgPSBpbnRlcmFjdGlvbl9vYmplY3QudGFyZ2V0LnRvdWNoZW5kb3V0c2lkZSA9IG51bGw7XG5cdGludGVyYWN0aW9uX29iamVjdC50YXJnZXQudG91Y2htb3ZlID0gbnVsbDtcblx0dGhpcy5zbGlkZXIuaGlkZSgpO1xufVxuXG4vKipcbiAqIE9uIG1vdXNlIHVwXG4gKiBAbWV0aG9kIG9uQ2hhdEZpZWxkTW91c2VVcFxuICovXG5DaGF0Vmlldy5wcm90b3R5cGUub25DaGF0RmllbGRNb3VzZU1vdmUgPSBmdW5jdGlvbihpbnRlcmFjdGlvbl9vYmplY3QpIHtcblx0dmFyIHBvcyA9IGludGVyYWN0aW9uX29iamVjdC5nbG9iYWwueTtcblx0dmFyIGRpZmYgPSBwb3MgLSB0aGlzLnN0YXJ0TW91c2VQb3M7XG5cblx0dGhpcy5zbGlkZXIuc2V0VmFsdWUoKC0odGhpcy5zdGFydFBvcyArIGRpZmYpKSAvICh0aGlzLmNoYXRUZXh0LmhlaWdodCArIHRoaXMubWFyZ2luIC0gdGhpcy5jaGF0TWFzay5oZWlnaHQpKTtcbiBcdHRoaXMub25TbGlkZXJDaGFuZ2UoKTtcbn1cblxuLyoqXG4gKiBPbiBrZXkgZG93blxuICogQG1ldGhvZCBvbktleURvd25cbiAqL1xuIENoYXRWaWV3LnByb3RvdHlwZS5vbktleURvd24gPSBmdW5jdGlvbihldmVudCkge1xuXHRpZihldmVudC5rZXlDb2RlID09IDEzKSB7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiY2hhdFwiLCB7dGV4dDogdGhpcy5pbnB1dEZpZWxkLnRleHR9KTtcblx0XHRcblx0XHR0aGlzLmlucHV0RmllbGQuc2V0VGV4dChcIlwiKTtcblx0XHRcblx0fVxuIH1cblxuXG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhdFZpZXc7XG4iLCIvKipcbiAqIENsaWVudC5cbiAqIEBtb2R1bGUgY2xpZW50XG4gKi9cblxudmFyIFBJWEkgPSByZXF1aXJlKFwicGl4aS5qc1wiKTtcbnZhciBUV0VFTiA9IHJlcXVpcmUoXCJ0d2Vlbi5qc1wiKTtcbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKFwieWFlZFwiKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCJpbmhlcml0c1wiKTtcblxuLyoqXG4gKiBBIGNoaXBzIHZpZXcuXG4gKiBAY2xhc3MgQ2hpcHNWaWV3XG4gKi9cbmZ1bmN0aW9uIENoaXBzVmlldyh2aWV3Q29uZmlnLCByZXNvdXJjZXMsIHNob3dUb29sVGlwKSB7XG5cdFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKHRoaXMpO1xuXHR0aGlzLnRhcmdldFBvc2l0aW9uID0gbnVsbDtcblxuXHR0aGlzLnZpZXdDb25maWcgPSB2aWV3Q29uZmlnO1xuXHR0aGlzLnJlc291cmNlcyA9IHJlc291cmNlcztcblxuXHR0aGlzLmFsaWduID0gXCJsZWZ0XCI7XG5cblx0dGhpcy52YWx1ZSA9IDA7XG5cblx0dGhpcy5kZW5vbWluYXRpb25zID0gWzUwMDAwMCwgMTAwMDAwLCAyNTAwMCwgNTAwMCwgMTAwMCwgNTAwLCAxMDAsIDI1LCA1LCAxXTtcblxuXHR0aGlzLnN0YWNrQ2xpcHMgPSBuZXcgQXJyYXkoKTtcblx0dGhpcy5ob2xkZXIgPSBuZXcgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyKCk7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5ob2xkZXIpO1xuXG5cdHRoaXMudG9vbFRpcCA9IG51bGw7XG5cblx0aWYgKHNob3dUb29sVGlwKSB7XG5cdFx0dGhpcy50b29sVGlwID0gbmV3IFRvb2xUaXAoKTtcblx0XHR0aGlzLmFkZENoaWxkKHRoaXMudG9vbFRpcCk7XG5cdH1cblxufVxuXG5pbmhlcml0cyhDaGlwc1ZpZXcsIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcik7XG5FdmVudERpc3BhdGNoZXIuaW5pdChDaGlwc1ZpZXcpO1xuXG4vKipcbiAqIFNldCBhbGlnbm1lbnQuXG4gKiBAbWV0aG9kIHNldENhcmREYXRhXG4gKi9cbkNoaXBzVmlldy5wcm90b3R5cGUuc2V0QWxpZ25tZW50ID0gZnVuY3Rpb24oYWxpZ24pIHtcblx0aWYgKCFhbGlnbilcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGFsaWdubWVudDogXCIgKyBhbGlnbik7XG5cblx0dGhpcy5hbGlnbiA9IGFsaWduO1xufVxuXG4vKipcbiAqIFNldCB0YXJnZXQgcG9zaXRpb24uXG4gKiBAbWV0aG9kIHNldFRhcmdldFBvc2l0aW9uXG4gKi9cbkNoaXBzVmlldy5wcm90b3R5cGUuc2V0VGFyZ2V0UG9zaXRpb24gPSBmdW5jdGlvbihwb3NpdGlvbikge1xuXHQvL2NvbnNvbGUubG9nKFwic2V0dGluZyB0YXJnZXQgcG9zaXRpb246IFwiICsgSlNPTi5zdHJpbmdpZnkocG9zaXRpb24pKTtcblxuXHR0aGlzLnRhcmdldFBvc2l0aW9uID0gcG9zaXRpb247XG5cdHRoaXMucG9zaXRpb24ueCA9IHBvc2l0aW9uLng7XG5cdHRoaXMucG9zaXRpb24ueSA9IHBvc2l0aW9uLnk7XG59XG5cbi8qKlxuICogU2V0IHZhbHVlLlxuICogQG1ldGhvZCBzZXRWYWx1ZVxuICovXG5DaGlwc1ZpZXcucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXG5cdHZhciBzcHJpdGU7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0YWNrQ2xpcHMubGVuZ3RoOyBpKyspXG5cdFx0dGhpcy5ob2xkZXIucmVtb3ZlQ2hpbGQodGhpcy5zdGFja0NsaXBzW2ldKTtcblxuXHR0aGlzLnN0YWNrQ2xpcHMgPSBuZXcgQXJyYXkoKTtcblxuXHRpZiAodGhpcy50b29sVGlwICE9IG51bGwpXG5cdFx0dGhpcy50b29sVGlwLnRleHQgPSBcIkJldDogXCIgKyB0aGlzLnZhbHVlLnRvU3RyaW5nKCk7XG5cblx0dmFyIGk7XG5cdHZhciBzdGFja0NsaXAgPSBudWxsO1xuXHR2YXIgc3RhY2tQb3MgPSAwO1xuXHR2YXIgY2hpcFBvcyA9IDA7XG5cblx0Zm9yIChpID0gMDsgaSA8IHRoaXMuZGVub21pbmF0aW9ucy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBkZW5vbWluYXRpb24gPSB0aGlzLmRlbm9taW5hdGlvbnNbaV07XG5cblx0XHRjaGlwUG9zID0gMDtcblx0XHRzdGFja0NsaXAgPSBudWxsO1xuXHRcdHdoaWxlICh2YWx1ZSA+PSBkZW5vbWluYXRpb24pIHtcblx0XHRcdGlmIChzdGFja0NsaXAgPT0gbnVsbCkge1xuXHRcdFx0XHRzdGFja0NsaXAgPSBuZXcgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyKCk7XG5cdFx0XHRcdHN0YWNrQ2xpcC54ID0gc3RhY2tQb3M7XG5cdFx0XHRcdHN0YWNrUG9zICs9IDQwO1xuXHRcdFx0XHR0aGlzLmhvbGRlci5hZGRDaGlsZChzdGFja0NsaXApO1xuXHRcdFx0XHR0aGlzLnN0YWNrQ2xpcHMucHVzaChzdGFja0NsaXApO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRleHR1cmUgPSB0aGlzLnJlc291cmNlcy5nZXRUZXh0dXJlKFwiY2hpcFwiICsgKGkgJSA1KSk7XG5cdFx0XHR2YXIgY2hpcCA9IG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlKTtcblx0XHRcdGNoaXAucG9zaXRpb24ueSA9IGNoaXBQb3M7XG5cdFx0XHRjaGlwUG9zIC09IDU7XG5cdFx0XHRzdGFja0NsaXAuYWRkQ2hpbGQoY2hpcCk7XG5cdFx0XHR2YWx1ZSAtPSBkZW5vbWluYXRpb247XG5cblx0XHRcdHZhciBkZW5vbWluYXRpb25TdHJpbmc7XG5cblx0XHRcdGlmIChkZW5vbWluYXRpb24gPj0gMTAwMClcblx0XHRcdFx0ZGVub21pbmF0aW9uU3RyaW5nID0gTWF0aC5yb3VuZChkZW5vbWluYXRpb24gLyAxMDAwKSArIFwiS1wiO1xuXG5cdFx0XHRlbHNlXG5cdFx0XHRcdGRlbm9taW5hdGlvblN0cmluZyA9IGRlbm9taW5hdGlvbjtcblxuXHRcdFx0aWYgKChzdGFja0NsaXAgIT0gbnVsbCkgJiYgKHZhbHVlIDwgZGVub21pbmF0aW9uKSkge1xuXG5cdFx0XHRcdHZhciB0ZXh0RmllbGQgPSBuZXcgUElYSS5UZXh0KGRlbm9taW5hdGlvblN0cmluZywge1xuXHRcdFx0XHRcdGZvbnQ6IFwiYm9sZCAxMnB4IEFyaWFsXCIsXG5cdFx0XHRcdFx0YWxpZ246IFwiY2VudGVyXCIsXG5cdFx0XHRcdFx0ZmlsbDogdGhpcy5yZXNvdXJjZXMuZ2V0Q29sb3IoXCJjaGlwc0NvbG9yXCIgKyAoaSAlIDUpKVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0dGV4dEZpZWxkLnBvc2l0aW9uLnggPSAoc3RhY2tDbGlwLndpZHRoIC0gdGV4dEZpZWxkLndpZHRoKSAqIDAuNTtcblx0XHRcdFx0dGV4dEZpZWxkLnBvc2l0aW9uLnkgPSBjaGlwUG9zICsgMTE7XG5cdFx0XHRcdHRleHRGaWVsZC5hbHBoYSA9IDAuNTtcblx0XHRcdFx0Lypcblx0XHRcdFx0dGV4dEZpZWxkLndpZHRoID0gc3RhY2tDbGlwLndpZHRoIC0gMTtcblx0XHRcdFx0dGV4dEZpZWxkLmhlaWdodCA9IDIwOyovXG5cblx0XHRcdFx0c3RhY2tDbGlwLmFkZENoaWxkKHRleHRGaWVsZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0c3dpdGNoICh0aGlzLmFsaWduKSB7XG5cdFx0Y2FzZSBcImxlZnRcIjpcblx0XHRjYXNlIFwiTFwiOlxuXHRcdFx0dGhpcy5ob2xkZXIueCA9IDA7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgXCJjZW50ZXJcIjpcblx0XHRjYXNlIFwiQ1wiOlxuXHRcdFx0dGhpcy5ob2xkZXIueCA9IC10aGlzLmhvbGRlci53aWR0aCAvIDI7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgXCJyaWdodFwiOlxuXHRcdGNhc2UgXCJSXCI6XG5cdFx0XHR0aGlzLmhvbGRlci54ID0gLXRoaXMuaG9sZGVyLndpZHRoO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBhbGlnbjogXCIgKyB0aGlzLmFsaWduKTtcblx0fVxufVxuXG4vKipcbiAqIEhpZGUuXG4gKiBAbWV0aG9kIGhpZGVcbiAqL1xuQ2hpcHNWaWV3LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMudmlzaWJsZSA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFNob3cuXG4gKiBAbWV0aG9kIHNob3dcbiAqL1xuQ2hpcHNWaWV3LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cblx0dmFyIGRlc3RpbmF0aW9uID0ge1xuXHRcdHg6IHRoaXMudGFyZ2V0UG9zaXRpb24ueCxcblx0XHR5OiB0aGlzLnRhcmdldFBvc2l0aW9uLnlcblx0fTtcblx0dGhpcy5wb3NpdGlvbi54ID0gKHRoaXMucGFyZW50LndpZHRoIC0gdGhpcy53aWR0aCkgKiAwLjU7XG5cdHRoaXMucG9zaXRpb24ueSA9IC10aGlzLmhlaWdodDtcblxuXHR2YXIgZGlmZlggPSB0aGlzLnBvc2l0aW9uLnggLSBkZXN0aW5hdGlvbi54O1xuXHR2YXIgZGlmZlkgPSB0aGlzLnBvc2l0aW9uLnkgLSBkZXN0aW5hdGlvbi55O1xuXHR2YXIgZGlmZiA9IE1hdGguc3FydChkaWZmWCAqIGRpZmZYICsgZGlmZlkgKiBkaWZmWSk7XG5cblx0dmFyIHR3ZWVuID0gbmV3IFRXRUVOLlR3ZWVuKHRoaXMucG9zaXRpb24pXG5cdFx0LnRvKHtcblx0XHRcdHg6IGRlc3RpbmF0aW9uLngsXG5cdFx0XHR5OiBkZXN0aW5hdGlvbi55XG5cdFx0fSwgMyAqIGRpZmYpXG5cdFx0LmVhc2luZyhUV0VFTi5FYXNpbmcuUXVhZHJhdGljLk91dClcblx0XHQub25Db21wbGV0ZSh0aGlzLm9uU2hvd0NvbXBsZXRlLmJpbmQodGhpcykpXG5cdFx0LnN0YXJ0KCk7XG59XG5cbi8qKlxuICogU2hvdyBjb21wbGV0ZS5cbiAqIEBtZXRob2Qgb25TaG93Q29tcGxldGVcbiAqL1xuQ2hpcHNWaWV3LnByb3RvdHlwZS5vblNob3dDb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXG5cdHRoaXMuZGlzcGF0Y2hFdmVudChcImFuaW1hdGlvbkRvbmVcIiwgdGhpcyk7XG59XG5cbi8qKlxuICogQW5pbWF0ZSBpbi5cbiAqIEBtZXRob2QgYW5pbWF0ZUluXG4gKi9cbkNoaXBzVmlldy5wcm90b3R5cGUuYW5pbWF0ZUluID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvID0ge1xuXHRcdHk6IHRoaXMucmVzb3VyY2VzLmdldFBvaW50KFwicG90UG9zaXRpb25cIikueVxuXHR9O1xuXG5cdHN3aXRjaCAodGhpcy5hbGlnbikge1xuXHRcdGNhc2UgXCJsZWZ0XCI6XG5cdFx0Y2FzZSBcIkxcIjpcblx0XHRcdG8ueCA9IHRoaXMucmVzb3VyY2VzLmdldFBvaW50KFwicG90UG9zaXRpb25cIikueCAtIHRoaXMud2lkdGggLyAyO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIFwiY2VudGVyXCI6XG5cdFx0Y2FzZSBcIkNcIjpcblx0XHRcdG8ueCA9IHRoaXMucmVzb3VyY2VzLmdldFBvaW50KFwicG90UG9zaXRpb25cIikueDtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBcInJpZ2h0XCI6XG5cdFx0Y2FzZSBcIlJcIjpcblx0XHRcdG8ueCA9IHRoaXMucmVzb3VyY2VzLmdldFBvaW50KFwicG90UG9zaXRpb25cIikueCArIHRoaXMud2lkdGggLyAyO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBhbGlnbjogXCIgKyB0aGlzLmFsaWduKTtcblx0XHRcdGJyZWFrO1xuXHR9XG5cblx0dmFyIHRpbWUgPSB0aGlzLnZpZXdDb25maWcuc2NhbGVBbmltYXRpb25UaW1lKDUwMCk7XG5cdHZhciB0d2VlbiA9IG5ldyBUV0VFTi5Ud2Vlbih0aGlzKVxuXHRcdC50byh7XG5cdFx0XHR5OiB0aGlzLnJlc291cmNlcy5nZXRQb2ludChcInBvdFBvc2l0aW9uXCIpLnksXG5cdFx0XHR4OiBvLnhcblx0XHR9LCB0aW1lKVxuXHRcdC5vbkNvbXBsZXRlKHRoaXMub25JbkFuaW1hdGlvbkNvbXBsZXRlLmJpbmQodGhpcykpXG5cdFx0LnN0YXJ0KCk7XG59XG5cbi8qKlxuICogSW4gYW5pbWF0aW9uIGNvbXBsZXRlLlxuICogQG1ldGhvZCBvbkluQW5pbWF0aW9uQ29tcGxldGVcbiAqL1xuQ2hpcHNWaWV3LnByb3RvdHlwZS5vbkluQW5pbWF0aW9uQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5zZXRWYWx1ZSgwKTtcblxuXHR0aGlzLnBvc2l0aW9uLnggPSB0aGlzLnRhcmdldFBvc2l0aW9uLng7XG5cdHRoaXMucG9zaXRpb24ueSA9IHRoaXMudGFyZ2V0UG9zaXRpb24ueTtcblxuXHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJhbmltYXRpb25Eb25lXCIsIHRoaXMpO1xufVxuXG4vKipcbiAqIEFuaW1hdGUgb3V0LlxuICogQG1ldGhvZCBhbmltYXRlT3V0XG4gKi9cbkNoaXBzVmlldy5wcm90b3R5cGUuYW5pbWF0ZU91dCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnBvc2l0aW9uLnkgPSB0aGlzLnJlc291cmNlcy5nZXRQb2ludChcInBvdFBvc2l0aW9uXCIpLnk7XG5cblx0c3dpdGNoICh0aGlzLmFsaWduKSB7XG5cdFx0Y2FzZSBcImxlZnRcIjpcblx0XHRjYXNlIFwiTFwiOlxuXHRcdFx0dGhpcy5wb3NpdGlvbi54ID0gdGhpcy5yZXNvdXJjZXMuZ2V0UG9pbnQoXCJwb3RQb3NpdGlvblwiKS54IC0gdGhpcy53aWR0aCAvIDI7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgXCJjZW50ZXJcIjpcblx0XHRjYXNlIFwiQ1wiOlxuXHRcdFx0dGhpcy5wb3NpdGlvbi54ID0gdGhpcy5yZXNvdXJjZXMuZ2V0UG9pbnQoXCJwb3RQb3NpdGlvblwiKS54O1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIFwicmlnaHRcIjpcblx0XHRjYXNlIFwiUlwiOlxuXHRcdFx0dGhpcy5wb3NpdGlvbi54ID0gdGhpcy5yZXNvdXJjZXMuZ2V0UG9pbnQoXCJwb3RQb3NpdGlvblwiKS54ICsgdGhpcy53aWR0aCAvIDI7XG5cdFx0XHRicmVhaztcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGFsaWduOiBcIiArIHRoaXMuYWxpZ24pO1xuXHRcdFx0YnJlYWs7XG5cdH1cblxuXHR2YXIgbyA9IHtcblx0XHR4OiB0aGlzLnRhcmdldFBvc2l0aW9uLngsXG5cdFx0eTogdGhpcy50YXJnZXRQb3NpdGlvbi55XG5cdH07XG5cblx0dmFyIHRpbWUgPSB0aGlzLnZpZXdDb25maWcuc2NhbGVBbmltYXRpb25UaW1lKDUwMCk7XG5cdHZhciB0d2VlbiA9IG5ldyBUV0VFTi5Ud2Vlbih0aGlzKVxuXHRcdC50byhvLCB0aW1lKVxuXHRcdC5vbkNvbXBsZXRlKHRoaXMub25PdXRBbmltYXRpb25Db21wbGV0ZS5iaW5kKHRoaXMpKVxuXHRcdC5zdGFydCgpO1xuXG59XG5cbi8qKlxuICogT3V0IGFuaW1hdGlvbiBjb21wbGV0ZS5cbiAqIEBtZXRob2Qgb25PdXRBbmltYXRpb25Db21wbGV0ZVxuICovXG5DaGlwc1ZpZXcucHJvdG90eXBlLm9uT3V0QW5pbWF0aW9uQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcblxuXHR2YXIgdGltZSA9IDUwMDtcblx0dmFyIHR3ZWVuID0gbmV3IFRXRUVOLlR3ZWVuKHtcblx0XHRcdHg6IDBcblx0XHR9KVxuXHRcdC50byh7XG5cdFx0XHR4OiAxMFxuXHRcdH0sIHRpbWUpXG5cdFx0Lm9uQ29tcGxldGUodGhpcy5vbk91dFdhaXRBbmltYXRpb25Db21wbGV0ZS5iaW5kKHRoaXMpKVxuXHRcdC5zdGFydCgpO1xuXG5cdHRoaXMucG9zaXRpb24ueCA9IHRoaXMudGFyZ2V0UG9zaXRpb24ueDtcblx0dGhpcy5wb3NpdGlvbi55ID0gdGhpcy50YXJnZXRQb3NpdGlvbi55O1xuXG59XG5cbi8qKlxuICogT3V0IHdhaXQgYW5pbWF0aW9uIGNvbXBsZXRlLlxuICogQG1ldGhvZCBvbk91dFdhaXRBbmltYXRpb25Db21wbGV0ZVxuICovXG5DaGlwc1ZpZXcucHJvdG90eXBlLm9uT3V0V2FpdEFuaW1hdGlvbkNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cblx0dGhpcy5zZXRWYWx1ZSgwKTtcblxuXHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJhbmltYXRpb25Eb25lXCIsIHRoaXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENoaXBzVmlldzsiLCIvKipcbiAqIENsaWVudC5cbiAqIEBtb2R1bGUgY2xpZW50XG4gKi9cblxudmFyIFBJWEkgPSByZXF1aXJlKFwicGl4aS5qc1wiKTtcbnZhciBUV0VFTiA9IHJlcXVpcmUoXCJ0d2Vlbi5qc1wiKTtcbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKFwieWFlZFwiKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCJpbmhlcml0c1wiKTtcblxuLyoqXG4gKiBEaWFsb2cgdmlldy5cbiAqIEBjbGFzcyBEZWFsZXJCdXR0b25WaWV3XG4gKi9cbmZ1bmN0aW9uIERlYWxlckJ1dHRvblZpZXcodmlld0NvbmZpZywgcmVzb3VyY2VzKSB7XG5cdFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKHRoaXMpO1xuXG5cdHRoaXMudmlld0NvbmZpZyA9IHZpZXdDb25maWc7XG5cdHRoaXMucmVzb3VyY2VzID0gcmVzb3VyY2VzO1xuXG5cdHZhciBkZWFsZXJCdXR0b25UZXh0dXJlID0gdGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcImRlYWxlckJ1dHRvblwiKTtcblx0dGhpcy5zcHJpdGUgPSBuZXcgUElYSS5TcHJpdGUoZGVhbGVyQnV0dG9uVGV4dHVyZSk7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5zcHJpdGUpO1xuXHR0aGlzLmhpZGUoKTtcbn1cblxuaW5oZXJpdHMoRGVhbGVyQnV0dG9uVmlldywgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyKTtcbkV2ZW50RGlzcGF0Y2hlci5pbml0KERlYWxlckJ1dHRvblZpZXcpO1xuXG4vKipcbiAqIFNldCBzZWF0IGluZGV4XG4gKiBAbWV0aG9kIHNldFNlYXRJbmRleFxuICovXG5EZWFsZXJCdXR0b25WaWV3LnByb3RvdHlwZS5zZXRTZWF0SW5kZXggPSBmdW5jdGlvbihzZWF0SW5kZXgpIHtcblx0dGhpcy5wb3NpdGlvbi54ID0gdGhpcy5yZXNvdXJjZXMuZ2V0UG9pbnQoXCJkZWFsZXJCdXR0b25Qb3NpdGlvblwiK3NlYXRJbmRleCkueDtcblx0dGhpcy5wb3NpdGlvbi55ID0gdGhpcy5yZXNvdXJjZXMuZ2V0UG9pbnQoXCJkZWFsZXJCdXR0b25Qb3NpdGlvblwiK3NlYXRJbmRleCkueTtcblx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiYW5pbWF0aW9uRG9uZVwiLCB0aGlzKTtcbn07XG5cbi8qKlxuICogQW5pbWF0ZSB0byBzZWF0IGluZGV4LlxuICogQG1ldGhvZCBhbmltYXRlVG9TZWF0SW5kZXhcbiAqL1xuRGVhbGVyQnV0dG9uVmlldy5wcm90b3R5cGUuYW5pbWF0ZVRvU2VhdEluZGV4ID0gZnVuY3Rpb24oc2VhdEluZGV4KSB7XG5cdGlmICghdGhpcy52aXNpYmxlKSB7XG5cdFx0dGhpcy5zZXRTZWF0SW5kZXgoc2VhdEluZGV4KTtcblx0XHQvLyB0b2RvIGRpc3BhdGNoIGV2ZW50IHRoYXQgaXQncyBjb21wbGV0ZT9cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJhbmltYXRpb25Eb25lXCIsIHRoaXMpO1xuXHRcdHJldHVybjtcblx0fVxuXHR2YXIgZGVzdGluYXRpb24gPSB0aGlzLnJlc291cmNlcy5nZXRQb2ludChcImRlYWxlckJ1dHRvblBvc2l0aW9uXCIrc2VhdEluZGV4KTtcblx0dmFyIGRpZmZYID0gdGhpcy5wb3NpdGlvbi54IC0gZGVzdGluYXRpb24ueDtcblx0dmFyIGRpZmZZID0gdGhpcy5wb3NpdGlvbi55IC0gZGVzdGluYXRpb24ueTtcblx0dmFyIGRpZmYgPSBNYXRoLnNxcnQoZGlmZlggKiBkaWZmWCArIGRpZmZZICogZGlmZlkpO1xuXG5cdHZhciB0d2VlbiA9IG5ldyBUV0VFTi5Ud2Vlbih0aGlzLnBvc2l0aW9uKVxuXHRcdC50byh7XG5cdFx0XHR4OiBkZXN0aW5hdGlvbi54LFxuXHRcdFx0eTogZGVzdGluYXRpb24ueVxuXHRcdH0sIHRoaXMudmlld0NvbmZpZy5zY2FsZUFuaW1hdGlvblRpbWUoNSAqIGRpZmYpKVxuXHRcdC5lYXNpbmcoVFdFRU4uRWFzaW5nLlF1YWRyYXRpYy5PdXQpXG5cdFx0Lm9uQ29tcGxldGUodGhpcy5vblNob3dDb21wbGV0ZS5iaW5kKHRoaXMpKVxuXHRcdC5zdGFydCgpO1xufTtcblxuLyoqXG4gKiBTaG93IENvbXBsZXRlLlxuICogQG1ldGhvZCBvblNob3dDb21wbGV0ZVxuICovXG5EZWFsZXJCdXR0b25WaWV3LnByb3RvdHlwZS5vblNob3dDb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJhbmltYXRpb25Eb25lXCIsIHRoaXMpO1xufVxuXG4vKipcbiAqIEhpZGUuXG4gKiBAbWV0aG9kIGhpZGVcbiAqL1xuRGVhbGVyQnV0dG9uVmlldy5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnZpc2libGUgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBTaG93LlxuICogQG1ldGhvZCBzaG93XG4gKi9cbkRlYWxlckJ1dHRvblZpZXcucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbihzZWF0SW5kZXgsIGFuaW1hdGUpIHtcblx0aWYgKHRoaXMudmlzaWJsZSAmJiBhbmltYXRlKSB7XG5cdFx0dGhpcy5hbmltYXRlVG9TZWF0SW5kZXgoc2VhdEluZGV4KTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXHRcdHRoaXMuc2V0U2VhdEluZGV4KHNlYXRJbmRleCk7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEZWFsZXJCdXR0b25WaWV3OyIsIi8qKlxuICogQ2xpZW50LlxuICogQG1vZHVsZSBjbGllbnRcbiAqL1xuXG52YXIgUElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xudmFyIEJ1dHRvbiA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9CdXR0b25cIik7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiaW5oZXJpdHNcIik7XG5cbi8qKlxuICogRGlhbG9nIGJ1dHRvbi5cbiAqIEBjbGFzcyBEaWFsb2dCdXR0b25cbiAqL1xuZnVuY3Rpb24gRGlhbG9nQnV0dG9uKHJlc291cmNlcykge1xuXHRCdXR0b24uY2FsbCh0aGlzKTtcblxuXHR0aGlzLmJ1dHRvblRleHR1cmUgPSByZXNvdXJjZXMuZ2V0VGV4dHVyZShcImRpYWxvZ0J1dHRvblwiKTtcblx0dGhpcy5hZGRDaGlsZChuZXcgUElYSS5TcHJpdGUodGhpcy5idXR0b25UZXh0dXJlKSk7XG5cblx0dmFyIHN0eWxlID0ge1xuXHRcdGZvbnQ6IFwibm9ybWFsIDE0cHggQXJpYWxcIixcblx0XHRmaWxsOiBcIiNmZmZmZmZcIlxuXHR9O1xuXG5cdHRoaXMudGV4dEZpZWxkID0gbmV3IFBJWEkuVGV4dChcIlt0ZXN0XVwiLCBzdHlsZSk7XG5cdHRoaXMudGV4dEZpZWxkLnBvc2l0aW9uLnkgPSAxNTtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLnRleHRGaWVsZCk7XG5cblx0dGhpcy5zZXRUZXh0KFwiQlROXCIpO1xufVxuXG5pbmhlcml0cyhEaWFsb2dCdXR0b24sIEJ1dHRvbik7XG5cbi8qKlxuICogU2V0IHRleHQgZm9yIHRoZSBidXR0b24uXG4gKiBAbWV0aG9kIHNldFRleHRcbiAqL1xuRGlhbG9nQnV0dG9uLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuXHR0aGlzLnRleHRGaWVsZC5zZXRUZXh0KHRleHQpO1xuXHR0aGlzLnRleHRGaWVsZC51cGRhdGVUcmFuc2Zvcm0oKTtcblx0dGhpcy50ZXh0RmllbGQueCA9IHRoaXMuYnV0dG9uVGV4dHVyZS53aWR0aCAvIDIgLSB0aGlzLnRleHRGaWVsZC53aWR0aCAvIDI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGlhbG9nQnV0dG9uOyIsIi8qKlxuICogQ2xpZW50LlxuICogQG1vZHVsZSBjbGllbnRcbiAqL1xuXG52YXIgUElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xudmFyIE5pbmVTbGljZSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9OaW5lU2xpY2VcIik7XG52YXIgRGlhbG9nQnV0dG9uID0gcmVxdWlyZShcIi4vRGlhbG9nQnV0dG9uXCIpO1xudmFyIEJ1dHRvbkRhdGEgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vZGF0YS9CdXR0b25EYXRhXCIpO1xudmFyIFBpeGlUZXh0SW5wdXQgPSByZXF1aXJlKFwicGl4aXRleHRpbnB1dFwiKTtcbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKFwieWFlZFwiKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCJpbmhlcml0c1wiKTtcblxuLyoqXG4gKiBEaWFsb2cgdmlldy5cbiAqIEBjbGFzcyBEaWFsb2dWaWV3XG4gKi9cbmZ1bmN0aW9uIERpYWxvZ1ZpZXcodmlld0NvbmZpZywgcmVzb3VyY2VzKSB7XG5cdFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKHRoaXMpO1xuXG5cdHRoaXMucmVzb3VyY2VzID0gcmVzb3VyY2VzO1xuXG5cdHZhciBjb3ZlciA9IG5ldyBQSVhJLkdyYXBoaWNzKCk7XG5cdGNvdmVyLmJlZ2luRmlsbCgweDAwMDAwMCwgLjUpO1xuXHRjb3Zlci5kcmF3UmVjdCgtMTAwMCwgLTEwMDAsIDk2MCArIDIwMDAsIDcyMCArIDIwMDApO1xuXHRjb3Zlci5lbmRGaWxsKCk7XG5cdGNvdmVyLmludGVyYWN0aXZlID0gdHJ1ZTtcblx0Ly9jb3Zlci5idXR0b25Nb2RlID0gdHJ1ZTtcblx0Y292ZXIuaGl0QXJlYSA9IG5ldyBQSVhJLlJlY3RhbmdsZSgwLCAwLCA5NjAsIDcyMCk7XG5cdHRoaXMuYWRkQ2hpbGQoY292ZXIpO1xuXG5cdHZhciBiID0gbmV3IE5pbmVTbGljZSh0aGlzLnJlc291cmNlcy5nZXRUZXh0dXJlKFwiZnJhbWVQbGF0ZVwiKSwgMTApO1xuXHRiLnNldExvY2FsU2l6ZSg0ODAsIDI3MCk7XG5cdGIucG9zaXRpb24ueCA9IDQ4MCAtIDQ4MCAvIDI7XG5cdGIucG9zaXRpb24ueSA9IDM2MCAtIDI3MCAvIDI7XG5cdHRoaXMuYWRkQ2hpbGQoYik7XG5cblx0c3R5bGUgPSB7XG5cdFx0Zm9udDogXCJub3JtYWwgMTRweCBBcmlhbFwiXG5cdH07XG5cblx0dGhpcy50ZXh0RmllbGQgPSBuZXcgUElYSS5UZXh0KFwiW3RleHRdXCIsIHN0eWxlKTtcblx0dGhpcy50ZXh0RmllbGQucG9zaXRpb24ueCA9IGIucG9zaXRpb24ueCArIDIwO1xuXHR0aGlzLnRleHRGaWVsZC5wb3NpdGlvbi55ID0gYi5wb3NpdGlvbi55ICsgMjA7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy50ZXh0RmllbGQpO1xuXG5cdHRoaXMuYnV0dG9uc0hvbGRlciA9IG5ldyBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIoKTtcblx0dGhpcy5idXR0b25zSG9sZGVyLnBvc2l0aW9uLnkgPSA0MzA7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5idXR0b25zSG9sZGVyKTtcblx0dGhpcy5idXR0b25zID0gW107XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcblx0XHR2YXIgYiA9IG5ldyBEaWFsb2dCdXR0b24odGhpcy5yZXNvdXJjZXMpO1xuXG5cdFx0Yi5wb3NpdGlvbi54ID0gaSAqIDkwO1xuXHRcdGIub24oXCJjbGlja1wiLCB0aGlzLm9uQnV0dG9uQ2xpY2ssIHRoaXMpO1xuXHRcdHRoaXMuYnV0dG9uc0hvbGRlci5hZGRDaGlsZChiKTtcblx0XHR0aGlzLmJ1dHRvbnMucHVzaChiKTtcblx0fVxuXG5cdHN0eWxlID0ge1xuXHRcdGZvbnQ6IFwibm9ybWFsIDE4cHggQXJpYWxcIlxuXHR9O1xuXG5cdHRoaXMuaW5wdXRGaWVsZCA9IG5ldyBQaXhpVGV4dElucHV0KFwiXCIsIHN0eWxlKTtcblx0dGhpcy5pbnB1dEZpZWxkLnBvc2l0aW9uLnggPSB0aGlzLnRleHRGaWVsZC5wb3NpdGlvbi54O1xuXG5cdHRoaXMuaW5wdXRGcmFtZSA9IG5ldyBQSVhJLkdyYXBoaWNzKCk7XG5cdHRoaXMuaW5wdXRGcmFtZS5iZWdpbkZpbGwoMHgwMDAwMDApO1xuXHR0aGlzLmlucHV0RnJhbWUuZHJhd1JlY3QoLTEsIC0xLCAxMDIsIDIzKTtcblx0dGhpcy5pbnB1dEZyYW1lLnBvc2l0aW9uLnggPSB0aGlzLmlucHV0RmllbGQucG9zaXRpb24ueDtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLmlucHV0RnJhbWUpO1xuXG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5pbnB1dEZpZWxkKTtcblxuXHR0aGlzLmhpZGUoKTtcbn1cblxuaW5oZXJpdHMoRGlhbG9nVmlldywgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyKTtcbkV2ZW50RGlzcGF0Y2hlci5pbml0KERpYWxvZ1ZpZXcpO1xuXG5EaWFsb2dWaWV3LkJVVFRPTl9DTElDSyA9IFwiYnV0dG9uQ2xpY2tcIjtcblxuLyoqXG4gKiBIaWRlLlxuICogQG1ldGhvZCBoaWRlXG4gKi9cbkRpYWxvZ1ZpZXcucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcblx0dGhpcy52aXNpYmxlID0gZmFsc2U7XG59XG5cbi8qKlxuICogU2hvdy5cbiAqIEBtZXRob2Qgc2hvd1xuICovXG5EaWFsb2dWaWV3LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24odGV4dCwgYnV0dG9uSWRzLCBkZWZhdWx0VmFsdWUpIHtcblx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuXHR0aGlzLmJ1dHRvbklkcyA9IGJ1dHRvbklkcztcblxuXHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5idXR0b25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKGkgPCBidXR0b25JZHMubGVuZ3RoKSB7XG5cdFx0XHR2YXIgYnV0dG9uID0gdGhpcy5idXR0b25zW2ldXG5cdFx0XHRidXR0b24uc2V0VGV4dChCdXR0b25EYXRhLmdldEJ1dHRvblN0cmluZ0ZvcklkKGJ1dHRvbklkc1tpXSkpO1xuXHRcdFx0YnV0dG9uLnZpc2libGUgPSB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmJ1dHRvbnNbaV0udmlzaWJsZSA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdHRoaXMuYnV0dG9uc0hvbGRlci54ID0gNDgwIC0gYnV0dG9uSWRzLmxlbmd0aCAqIDkwIC8gMjtcblx0dGhpcy50ZXh0RmllbGQuc2V0VGV4dCh0ZXh0KTtcblxuXHRpZiAoZGVmYXVsdFZhbHVlKSB7XG5cdFx0dGhpcy5pbnB1dEZpZWxkLnBvc2l0aW9uLnkgPSB0aGlzLnRleHRGaWVsZC5wb3NpdGlvbi55ICsgdGhpcy50ZXh0RmllbGQuaGVpZ2h0ICsgMjA7XG5cdFx0dGhpcy5pbnB1dEZyYW1lLnBvc2l0aW9uLnkgPSB0aGlzLmlucHV0RmllbGQucG9zaXRpb24ueTtcblx0XHR0aGlzLmlucHV0RmllbGQudmlzaWJsZSA9IHRydWU7XG5cdFx0dGhpcy5pbnB1dEZyYW1lLnZpc2libGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5pbnB1dEZpZWxkLnRleHQgPSBkZWZhdWx0VmFsdWU7XG5cdFx0dGhpcy5pbnB1dEZpZWxkLmZvY3VzKCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5pbnB1dEZpZWxkLnZpc2libGUgPSBmYWxzZTtcblx0XHR0aGlzLmlucHV0RnJhbWUudmlzaWJsZSA9IGZhbHNlO1xuXHR9XG59XG5cbi8qKlxuICogSGFuZGxlIGJ1dHRvbiBjbGljay5cbiAqIEBtZXRob2Qgb25CdXR0b25DbGlja1xuICovXG5EaWFsb2dWaWV3LnByb3RvdHlwZS5vbkJ1dHRvbkNsaWNrID0gZnVuY3Rpb24oZSkge1xuXHR2YXIgYnV0dG9uSW5kZXggPSAtMTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYnV0dG9ucy5sZW5ndGg7IGkrKylcblx0XHRpZiAoZS50YXJnZXQgPT0gdGhpcy5idXR0b25zW2ldKVxuXHRcdFx0YnV0dG9uSW5kZXggPSBpO1xuXG5cdHZhciB2YWx1ZSA9IG51bGw7XG5cdGlmICh0aGlzLmlucHV0RmllbGQudmlzaWJsZSlcblx0XHR2YWx1ZSA9IHRoaXMuaW5wdXRGaWVsZC50ZXh0O1xuXG5cdHZhciBldiA9IHtcblx0XHR0eXBlOiBEaWFsb2dWaWV3LkJVVFRPTl9DTElDSyxcblx0XHRidXR0b246IHRoaXMuYnV0dG9uSWRzW2J1dHRvbkluZGV4XSxcblx0XHR2YWx1ZTogdmFsdWVcblx0fTtcblxuXHR0aGlzLnRyaWdnZXIoZXYpO1xuXHR0aGlzLmhpZGUoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEaWFsb2dWaWV3OyIsIi8qKlxuICogQ2xpZW50LlxuICogQG1vZHVsZSBjbGllbnRcbiAqL1xuXG52YXIgUElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xudmFyIEdyYWRpZW50ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL0dyYWRpZW50XCIpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xuXG4vKipcbiAqIExvYWRpbmcgc2NyZWVuLlxuICogQGNsYXNzIExvYWRpbmdTY3JlZW5cbiAqL1xuZnVuY3Rpb24gTG9hZGluZ1NjcmVlbigpIHtcblx0UElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLmNhbGwodGhpcyk7XG5cblx0dmFyIGdyYWRpZW50ID0gbmV3IEdyYWRpZW50KCk7XG5cdGdyYWRpZW50LnNldFNpemUoMTAwLCAxMDApO1xuXHRncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgXCIjZmZmZmZmXCIpO1xuXHRncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgXCIjYzBjMGMwXCIpO1xuXG5cdHZhciBzID0gZ3JhZGllbnQuY3JlYXRlU3ByaXRlKCk7XG5cdHMucG9zaXRpb24ueD0tMTAwMDtcblx0cy5wb3NpdGlvbi55PS0xMDAwO1xuXHRzLndpZHRoID0gOTYwKzIwMDA7XG5cdHMuaGVpZ2h0ID0gNzIwKzIwMDA7XG5cdHRoaXMuYWRkQ2hpbGQocyk7XG5cblx0dmFyIHN0eWxlID0ge1xuXHRcdGZvbnQ6IFwiYm9sZCAyMHB4IEFyaWFsXCIsXG5cdFx0ZmlsbDogXCIjODA4MDgwXCJcblx0fTtcblxuXHR0aGlzLnRleHRGaWVsZCA9IG5ldyBQSVhJLlRleHQoXCJbdGV4dF1cIiwgc3R5bGUpO1xuXHR0aGlzLnRleHRGaWVsZC5wb3NpdGlvbi54ID0gOTYwIC8gMjtcblx0dGhpcy50ZXh0RmllbGQucG9zaXRpb24ueSA9IDcyMCAvIDIgLSB0aGlzLnRleHRGaWVsZC5oZWlnaHQgLyAyO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMudGV4dEZpZWxkKTtcbn1cblxuaW5oZXJpdHMoTG9hZGluZ1NjcmVlbiwgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyKTtcblxuLyoqXG4gKiBTaG93LlxuICogQG1ldGhvZCBzaG93XG4gKi9cbkxvYWRpbmdTY3JlZW4ucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdHRoaXMudGV4dEZpZWxkLnNldFRleHQobWVzc2FnZSk7XG5cdHRoaXMudGV4dEZpZWxkLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXHR0aGlzLnRleHRGaWVsZC54ID0gOTYwIC8gMiAtIHRoaXMudGV4dEZpZWxkLndpZHRoIC8gMjtcblx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBIaWRlLlxuICogQG1ldGhvZCBoaWRlXG4gKi9cbkxvYWRpbmdTY3JlZW4ucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcblx0dGhpcy52aXNpYmxlID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTG9hZGluZ1NjcmVlbjsiLCIvKipcbiAqIENsaWVudC5cbiAqIEBtb2R1bGUgY2xpZW50XG4gKi9cblxudmFyIFBJWEkgPSByZXF1aXJlKFwicGl4aS5qc1wiKTtcbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKFwieWFlZFwiKTtcbnZhciBTZWF0VmlldyA9IHJlcXVpcmUoXCIuL1NlYXRWaWV3XCIpO1xudmFyIENhcmRWaWV3ID0gcmVxdWlyZShcIi4vQ2FyZFZpZXdcIik7XG52YXIgQ2hhdFZpZXcgPSByZXF1aXJlKFwiLi9DaGF0Vmlld1wiKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9Qb2ludFwiKTtcbnZhciBHcmFkaWVudCA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9HcmFkaWVudFwiKTtcbnZhciBCdXR0b25zVmlldyA9IHJlcXVpcmUoXCIuL0J1dHRvbnNWaWV3XCIpO1xudmFyIERpYWxvZ1ZpZXcgPSByZXF1aXJlKFwiLi9EaWFsb2dWaWV3XCIpO1xudmFyIERlYWxlckJ1dHRvblZpZXcgPSByZXF1aXJlKFwiLi9EZWFsZXJCdXR0b25WaWV3XCIpO1xudmFyIENoaXBzVmlldyA9IHJlcXVpcmUoXCIuL0NoaXBzVmlld1wiKTtcbnZhciBQb3RWaWV3ID0gcmVxdWlyZShcIi4vUG90Vmlld1wiKTtcbnZhciBUaW1lclZpZXcgPSByZXF1aXJlKFwiLi9UaW1lclZpZXdcIik7XG52YXIgU2V0dGluZ3NWaWV3ID0gcmVxdWlyZShcIi4uL3ZpZXcvU2V0dGluZ3NWaWV3XCIpO1xudmFyIFRhYmxlSW5mb1ZpZXcgPSByZXF1aXJlKFwiLi4vdmlldy9UYWJsZUluZm9WaWV3XCIpO1xudmFyIFByZXNldEJ1dHRvbnNWaWV3ID0gcmVxdWlyZShcIi4uL3ZpZXcvUHJlc2V0QnV0dG9uc1ZpZXdcIik7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiaW5oZXJpdHNcIik7XG5cbi8qKlxuICogTmV0IHBva2VyIGNsaWVudCB2aWV3LlxuICogQGNsYXNzIE5ldFBva2VyQ2xpZW50Vmlld1xuICovXG5mdW5jdGlvbiBOZXRQb2tlckNsaWVudFZpZXcodmlld0NvbmZpZywgcmVzb3VyY2VzKSB7XG5cdFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKHRoaXMpO1xuXG5cdHRoaXMudmlld0NvbmZpZyA9IHZpZXdDb25maWc7XG5cdHRoaXMucmVzb3VyY2VzID0gcmVzb3VyY2VzO1xuXHR0aGlzLnNldHVwQmFja2dyb3VuZCgpO1xuXG5cdHRoaXMudGFibGVDb250YWluZXIgPSBuZXcgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyKCk7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy50YWJsZUNvbnRhaW5lcik7XG5cblx0dGhpcy50YWJsZUJhY2tncm91bmQgPSBuZXcgUElYSS5TcHJpdGUodGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcInRhYmxlQmFja2dyb3VuZFwiKSk7XG5cdHRoaXMudGFibGVDb250YWluZXIuYWRkQ2hpbGQodGhpcy50YWJsZUJhY2tncm91bmQpO1xuXHR0aGlzLnRhYmxlQmFja2dyb3VuZC5wb3NpdGlvbi54ID0gdGhpcy5yZXNvdXJjZXMuZ2V0UG9pbnQoXCJ0YWJsZVBvc2l0aW9uXCIpLng7XG5cdHRoaXMudGFibGVCYWNrZ3JvdW5kLnBvc2l0aW9uLnkgPSB0aGlzLnJlc291cmNlcy5nZXRQb2ludChcInRhYmxlUG9zaXRpb25cIikueTtcblxuXHR0aGlzLnNldHVwU2VhdHMoKTtcblx0dGhpcy5zZXR1cENvbW11bml0eUNhcmRzKCk7XG5cblx0dGhpcy50aW1lclZpZXcgPSBuZXcgVGltZXJWaWV3KHRoaXMudmlld0NvbmZpZywgdGhpcy5yZXNvdXJjZXMpO1xuXHR0aGlzLnRhYmxlQ29udGFpbmVyLmFkZENoaWxkKHRoaXMudGltZXJWaWV3KTtcblxuXHR0aGlzLmNoYXRWaWV3ID0gbmV3IENoYXRWaWV3KHRoaXMudmlld0NvbmZpZywgdGhpcy5yZXNvdXJjZXMpO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMuY2hhdFZpZXcpO1xuXG5cdHRoaXMuYnV0dG9uc1ZpZXcgPSBuZXcgQnV0dG9uc1ZpZXcodGhpcy52aWV3Q29uZmlnLCB0aGlzLnJlc291cmNlcyk7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5idXR0b25zVmlldyk7XG5cblx0dGhpcy5kZWFsZXJCdXR0b25WaWV3ID0gbmV3IERlYWxlckJ1dHRvblZpZXcodGhpcy52aWV3Q29uZmlnLCB0aGlzLnJlc291cmNlcyk7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5kZWFsZXJCdXR0b25WaWV3KTtcblxuXHR0aGlzLnRhYmxlSW5mb1ZpZXcgPSBuZXcgVGFibGVJbmZvVmlldyh0aGlzLnZpZXdDb25maWcsIHRoaXMucmVzb3VyY2VzKTtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLnRhYmxlSW5mb1ZpZXcpO1xuXG5cdHRoaXMucG90VmlldyA9IG5ldyBQb3RWaWV3KHRoaXMudmlld0NvbmZpZywgdGhpcy5yZXNvdXJjZXMpO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMucG90Vmlldyk7XG5cdHRoaXMucG90Vmlldy5wb3NpdGlvbi54ID0gdGhpcy5yZXNvdXJjZXMuZ2V0UG9pbnQoXCJwb3RQb3NpdGlvblwiKS54O1xuXHR0aGlzLnBvdFZpZXcucG9zaXRpb24ueSA9IHRoaXMucmVzb3VyY2VzLmdldFBvaW50KFwicG90UG9zaXRpb25cIikueTtcblxuXHR0aGlzLnNldHRpbmdzVmlldyA9IG5ldyBTZXR0aW5nc1ZpZXcodGhpcy52aWV3Q29uZmlnLCB0aGlzLnJlc291cmNlcyk7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5zZXR0aW5nc1ZpZXcpO1xuXG5cdHRoaXMuZGlhbG9nVmlldyA9IG5ldyBEaWFsb2dWaWV3KHRoaXMudmlld0NvbmZpZywgdGhpcy5yZXNvdXJjZXMpO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMuZGlhbG9nVmlldyk7XG5cblx0dGhpcy5wcmVzZXRCdXR0b25zVmlldyA9IG5ldyBQcmVzZXRCdXR0b25zVmlldyh0aGlzLnZpZXdDb25maWcsIHRoaXMucmVzb3VyY2VzKTtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLnByZXNldEJ1dHRvbnNWaWV3KTtcblxuXHR0aGlzLnNldHVwQ2hpcHMoKTtcbn1cblxuaW5oZXJpdHMoTmV0UG9rZXJDbGllbnRWaWV3LCBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIpO1xuRXZlbnREaXNwYXRjaGVyLmluaXQoTmV0UG9rZXJDbGllbnRWaWV3KTtcblxuTmV0UG9rZXJDbGllbnRWaWV3LlNFQVRfQ0xJQ0sgPSBcInNlYXRDbGlja1wiO1xuXG4vKipcbiAqIFNldHVwIGJhY2tncm91bmQuXG4gKiBAbWV0aG9kIHNldHVwQmFja2dyb3VuZFxuICovXG5OZXRQb2tlckNsaWVudFZpZXcucHJvdG90eXBlLnNldHVwQmFja2dyb3VuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgZyA9IG5ldyBQSVhJLkdyYXBoaWNzKCk7XG5cdGcuYmVnaW5GaWxsKDB4MDUzOTFkLCAxKTtcblx0Zy5kcmF3UmVjdCgtMTAwMCwgMCwgOTYwICsgMjAwMCwgNzIwKTtcblx0Zy5lbmRGaWxsKCk7XG5cdHRoaXMuYWRkQ2hpbGQoZyk7XG5cblx0dmFyIGcgPSBuZXcgUElYSS5HcmFwaGljcygpO1xuXHRnLmJlZ2luRmlsbCgweDkwOTA5MCwgMSk7XG5cdGcuZHJhd1JlY3QoLTEwMDAsIDcyMCwgOTYwICsgMjAwMCwgMTAwMCk7XG5cdGcuZW5kRmlsbCgpO1xuXHR0aGlzLmFkZENoaWxkKGcpO1xuXG5cdHZhciBncmFkaWVudCA9IG5ldyBHcmFkaWVudCgpO1xuXHRncmFkaWVudC5zZXRTaXplKDEwMCwgMTAwKTtcblx0Z3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIFwiIzYwNjA2MFwiKTtcblx0Z3JhZGllbnQuYWRkQ29sb3JTdG9wKC4wNSwgXCIjYTBhMGEwXCIpO1xuXHRncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgXCIjOTA5MDkwXCIpO1xuXG5cdHZhciBzID0gZ3JhZGllbnQuY3JlYXRlU3ByaXRlKCk7XG5cdHMucG9zaXRpb24ueSA9IDUzMDtcblx0cy5wb3NpdGlvbi54ID0gLTEwMDA7XG5cdHMud2lkdGggPSA5NjAgKyAyMDAwO1xuXHRzLmhlaWdodCA9IDE5MDtcblx0dGhpcy5hZGRDaGlsZChzKTtcblxuXHR2YXIgcyA9IG5ldyBQSVhJLlNwcml0ZSh0aGlzLnJlc291cmNlcy5nZXRUZXh0dXJlKFwiZGl2aWRlckxpbmVcIikpO1xuXHRzLnggPSAzNDU7XG5cdHMueSA9IDU0MDtcblx0dGhpcy5hZGRDaGlsZChzKTtcblxuXHR2YXIgcyA9IG5ldyBQSVhJLlNwcml0ZSh0aGlzLnJlc291cmNlcy5nZXRUZXh0dXJlKFwiZGl2aWRlckxpbmVcIikpO1xuXHRzLnggPSA2OTM7XG5cdHMueSA9IDU0MDtcblx0dGhpcy5hZGRDaGlsZChzKTtcbn1cblxuLyoqXG4gKiBTZXR1cCBzZWF0cy5cbiAqIEBtZXRob2Qgc2VydXBTZWF0c1xuICovXG5OZXRQb2tlckNsaWVudFZpZXcucHJvdG90eXBlLnNldHVwU2VhdHMgPSBmdW5jdGlvbigpIHtcblx0dmFyIGksIGo7XG5cdHZhciBwb2NrZXRDYXJkcztcblxuXHR0aGlzLnNlYXRWaWV3cyA9IFtdO1xuXG5cdGZvciAoaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0dmFyIHNlYXRWaWV3ID0gbmV3IFNlYXRWaWV3KHRoaXMucmVzb3VyY2VzLCBpKTtcblx0XHR2YXIgcCA9IHNlYXRWaWV3LnBvc2l0aW9uO1xuXG5cdFx0Zm9yIChqID0gMDsgaiA8IDI7IGorKykge1xuXHRcdFx0dmFyIGMgPSBuZXcgQ2FyZFZpZXcodGhpcy52aWV3Q29uZmlnLCB0aGlzLnJlc291cmNlcyk7XG5cdFx0XHRjLmhpZGUoKTtcblx0XHRcdGMuc2V0VGFyZ2V0UG9zaXRpb24oUG9pbnQocC54ICsgaiAqIDMwIC0gNjAsIHAueSAtIDEwMCkpO1xuXHRcdFx0dGhpcy50YWJsZUNvbnRhaW5lci5hZGRDaGlsZChjKTtcblx0XHRcdHNlYXRWaWV3LmFkZFBvY2tldENhcmQoYyk7XG5cdFx0XHRzZWF0Vmlldy5vbihcImNsaWNrXCIsIHRoaXMub25TZWF0Q2xpY2ssIHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMudGFibGVDb250YWluZXIuYWRkQ2hpbGQoc2VhdFZpZXcpO1xuXHRcdHRoaXMuc2VhdFZpZXdzLnB1c2goc2VhdFZpZXcpO1xuXHR9XG59XG5cbi8qKlxuICogU2V0dXAgY2hpcHMuXG4gKiBAbWV0aG9kIHNlcnVwU2VhdHNcbiAqL1xuTmV0UG9rZXJDbGllbnRWaWV3LnByb3RvdHlwZS5zZXR1cENoaXBzID0gZnVuY3Rpb24oKSB7XG5cdHZhciBpO1xuXHRmb3IgKGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdHZhciBjaGlwc1ZpZXcgPSBuZXcgQ2hpcHNWaWV3KHRoaXMudmlld0NvbmZpZywgdGhpcy5yZXNvdXJjZXMpO1xuXHRcdHRoaXMuc2VhdFZpZXdzW2ldLnNldEJldENoaXBzVmlldyhjaGlwc1ZpZXcpO1xuXG5cdFx0Y2hpcHNWaWV3LnNldEFsaWdubWVudCh0aGlzLnJlc291cmNlcy5nZXRWYWx1ZShcImJldEFsaWduXCIpLmNoYXJBdChpKSk7XG5cdFx0Y2hpcHNWaWV3LnNldFRhcmdldFBvc2l0aW9uKHRoaXMucmVzb3VyY2VzLmdldFBvaW50KFwiYmV0UG9zaXRpb25cIitpKSk7XG5cdFx0dGhpcy50YWJsZUNvbnRhaW5lci5hZGRDaGlsZChjaGlwc1ZpZXcpO1xuXHR9XG59XG5cbi8qKlxuICogU2VhdCBjbGljay5cbiAqIEBtZXRob2Qgb25TZWF0Q2xpY2tcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFBva2VyQ2xpZW50Vmlldy5wcm90b3R5cGUub25TZWF0Q2xpY2sgPSBmdW5jdGlvbihlKSB7XG5cdHZhciBzZWF0SW5kZXggPSAtMTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2VhdFZpZXdzLmxlbmd0aDsgaSsrKVxuXHRcdGlmIChlLnRhcmdldCA9PSB0aGlzLnNlYXRWaWV3c1tpXSlcblx0XHRcdHNlYXRJbmRleCA9IGk7XG5cblx0Y29uc29sZS5sb2coXCJzZWF0IGNsaWNrOiBcIiArIHNlYXRJbmRleCk7XG5cdHRoaXMudHJpZ2dlcih7XG5cdFx0dHlwZTogTmV0UG9rZXJDbGllbnRWaWV3LlNFQVRfQ0xJQ0ssXG5cdFx0c2VhdEluZGV4OiBzZWF0SW5kZXhcblx0fSk7XG59XG5cbi8qKlxuICogU2V0dXAgY29tbXVuaXR5IGNhcmRzLlxuICogQG1ldGhvZCBzZXR1cENvbW11bml0eUNhcmRzXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRQb2tlckNsaWVudFZpZXcucHJvdG90eXBlLnNldHVwQ29tbXVuaXR5Q2FyZHMgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5jb21tdW5pdHlDYXJkcyA9IFtdO1xuXG5cdHZhciBwID0gdGhpcy5yZXNvdXJjZXMuZ2V0UG9pbnQoXCJjb21tdW5pdHlDYXJkc1Bvc2l0aW9uXCIpO1xuXHR2YXIgbWFyZ2luID0gcGFyc2VJbnQodGhpcy5yZXNvdXJjZXMuZ2V0VmFsdWUoXCJjb21tdW5pdHlDYXJkTWFyZ2luXCIpKTtcblx0Zm9yIChpID0gMDsgaSA8IDU7IGkrKykge1xuXHRcdHZhciBjYXJkVmlldyA9IG5ldyBDYXJkVmlldyh0aGlzLnZpZXdDb25maWcsIHRoaXMucmVzb3VyY2VzKTtcblx0XHRjYXJkVmlldy5oaWRlKCk7XG5cdFx0Y2FyZFZpZXcuc2V0VGFyZ2V0UG9zaXRpb24oUG9pbnQocC54ICsgaSAqIChjYXJkVmlldy5iYWNrLndpZHRoICsgbWFyZ2luKSwgcC55KSk7XG5cblx0XHR0aGlzLmNvbW11bml0eUNhcmRzLnB1c2goY2FyZFZpZXcpO1xuXHRcdHRoaXMudGFibGVDb250YWluZXIuYWRkQ2hpbGQoY2FyZFZpZXcpO1xuXHR9XG59XG5cbi8qKlxuICogR2V0IHNlYXQgdmlldyBieSBpbmRleC5cbiAqIEBtZXRob2QgZ2V0U2VhdFZpZXdCeUluZGV4XG4gKi9cbk5ldFBva2VyQ2xpZW50Vmlldy5wcm90b3R5cGUuZ2V0U2VhdFZpZXdCeUluZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcblx0cmV0dXJuIHRoaXMuc2VhdFZpZXdzW2luZGV4XTtcbn1cblxuLyoqXG4gKiBHZXQgY29tbXVuaXR5IGNhcmRzLlxuICogQG1ldGhvZCBnZXRDb21tdW5pdHlDYXJkc1xuICovXG5OZXRQb2tlckNsaWVudFZpZXcucHJvdG90eXBlLmdldENvbW11bml0eUNhcmRzID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmNvbW11bml0eUNhcmRzO1xufVxuXG4vKipcbiAqIEdldCBidXR0b25zIHZpZXcuXG4gKiBAbWV0aG9kIGdldEJ1dHRvbnNWaWV3XG4gKi9cbk5ldFBva2VyQ2xpZW50Vmlldy5wcm90b3R5cGUuZ2V0QnV0dG9uc1ZpZXcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuYnV0dG9uc1ZpZXc7XG59XG5cbi8qKlxuICogR2V0IHByZXNldCBidXR0b25zIHZpZXcuXG4gKiBAbWV0aG9kIHByZXNldEJ1dHRvbnNWaWV3XG4gKi9cbk5ldFBva2VyQ2xpZW50Vmlldy5wcm90b3R5cGUuZ2V0UHJlc2V0QnV0dG9uc1ZpZXcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMucHJlc2V0QnV0dG9uc1ZpZXc7XG59XG5cbi8qKlxuICogR2V0IGRpYWxvZyB2aWV3LlxuICogQG1ldGhvZCBnZXREaWFsb2dWaWV3XG4gKi9cbk5ldFBva2VyQ2xpZW50Vmlldy5wcm90b3R5cGUuZ2V0RGlhbG9nVmlldyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5kaWFsb2dWaWV3O1xufVxuXG4vKipcbiAqIEdldCBkaWFsb2cgdmlldy5cbiAqIEBtZXRob2QgZ2V0RGVhbGVyQnV0dG9uVmlld1xuICovXG5OZXRQb2tlckNsaWVudFZpZXcucHJvdG90eXBlLmdldERlYWxlckJ1dHRvblZpZXcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuZGVhbGVyQnV0dG9uVmlldztcbn1cblxuLyoqXG4gKiBHZXQgdGFibGUgaW5mbyB2aWV3LlxuICogQG1ldGhvZCBnZXRUYWJsZUluZm9WaWV3XG4gKi9cbk5ldFBva2VyQ2xpZW50Vmlldy5wcm90b3R5cGUuZ2V0VGFibGVJbmZvVmlldyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy50YWJsZUluZm9WaWV3O1xufVxuXG4vKipcbiAqIEdldCBzZXR0aW5ncyB2aWV3LlxuICogQG1ldGhvZCBnZXRTZXR0aW5nc1ZpZXdcbiAqL1xuTmV0UG9rZXJDbGllbnRWaWV3LnByb3RvdHlwZS5nZXRTZXR0aW5nc1ZpZXcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuc2V0dGluZ3NWaWV3O1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZXJ5dGhpbmcgdG8gYW4gZW1wdHkgc3RhdGUuXG4gKiBAbWV0aG9kIGNsZWFyXG4gKi9cbk5ldFBva2VyQ2xpZW50Vmlldy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0dmFyIGk7XG5cblx0Zm9yIChpID0gMDsgaSA8IHRoaXMuY29tbXVuaXR5Q2FyZHMubGVuZ3RoOyBpKyspXG5cdFx0dGhpcy5jb21tdW5pdHlDYXJkc1tpXS5oaWRlKCk7XG5cblx0Zm9yIChpID0gMDsgaSA8IHRoaXMuc2VhdFZpZXdzLmxlbmd0aDsgaSsrKVxuXHRcdHRoaXMuc2VhdFZpZXdzW2ldLmNsZWFyKCk7XG5cblx0dGhpcy50aW1lclZpZXcuaGlkZSgpO1xuXHR0aGlzLnBvdFZpZXcuc2V0VmFsdWVzKG5ldyBBcnJheSgpKTtcblx0dGhpcy5kZWFsZXJCdXR0b25WaWV3LmhpZGUoKTtcblx0dGhpcy5jaGF0Vmlldy5jbGVhcigpO1xuXG5cdHRoaXMucHJlc2V0QnV0dG9uc1ZpZXcuaGlkZSgpO1xuXG5cdHRoaXMuZGlhbG9nVmlldy5oaWRlKCk7XG5cdHRoaXMuYnV0dG9uc1ZpZXcuY2xlYXIoKTtcblxuXHR0aGlzLnRhYmxlSW5mb1ZpZXcuY2xlYXIoKTtcblx0dGhpcy5zZXR0aW5nc1ZpZXcuY2xlYXIoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBOZXRQb2tlckNsaWVudFZpZXc7IiwiLyoqXG4gKiBDbGllbnQuXG4gKiBAbW9kdWxlIGNsaWVudFxuICovXG5cbnZhciBQSVhJID0gcmVxdWlyZShcInBpeGkuanNcIik7XG52YXIgVFdFRU4gPSByZXF1aXJlKFwidHdlZW4uanNcIik7XG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZShcInlhZWRcIik7XG52YXIgQ2hpcHNWaWV3ID0gcmVxdWlyZShcIi4vQ2hpcHNWaWV3XCIpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xuXG4vKipcbiAqIEEgcG90IHZpZXdcbiAqIEBjbGFzcyBQb3RWaWV3XG4gKi9cbmZ1bmN0aW9uIFBvdFZpZXcodmlld0NvbmZpZywgcmVzb3VyY2VzKSB7XG5cdFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKHRoaXMpO1xuXHRcblx0dGhpcy52aWV3Q29uZmlnID0gdmlld0NvbmZpZ1xuXHR0aGlzLnJlc291cmNlcyA9IHJlc291cmNlcztcblx0dGhpcy52YWx1ZSA9IDA7XG5cblx0dGhpcy5ob2xkZXIgPSBuZXcgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyKCk7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5ob2xkZXIpO1xuXG5cdHRoaXMuc3RhY2tzID0gbmV3IEFycmF5KCk7XG59XG5cbmluaGVyaXRzKFBvdFZpZXcsIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcik7XG5FdmVudERpc3BhdGNoZXIuaW5pdChQb3RWaWV3KTtcblxuLyoqXG4gKiBTZXQgdmFsdWUuXG4gKiBAbWV0aG9kIHNldFZhbHVlXG4gKi9cblBvdFZpZXcucHJvdG90eXBlLnNldFZhbHVlcyA9IGZ1bmN0aW9uKHZhbHVlcykge1xuXHRcblx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMuc3RhY2tzLmxlbmd0aDsgaSsrKVxuXHRcdHRoaXMuaG9sZGVyLnJlbW92ZUNoaWxkKHRoaXMuc3RhY2tzW2ldKTtcblxuXHR0aGlzLnN0YWNrcyA9IG5ldyBBcnJheSgpO1xuXG5cdHZhciBwb3MgPSAwO1xuXG5cdGZvcih2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgY2hpcHMgPSBuZXcgQ2hpcHNWaWV3KHRoaXMudmlld0NvbmZpZywgdGhpcy5yZXNvdXJjZXMsIGZhbHNlKTtcblx0XHR0aGlzLnN0YWNrcy5wdXNoKGNoaXBzKTtcblx0XHR0aGlzLmhvbGRlci5hZGRDaGlsZChjaGlwcyk7XG5cdFx0Y2hpcHMuc2V0VmFsdWUodmFsdWVzW2ldKTtcblx0XHRjaGlwcy54ID0gcG9zO1xuXHRcdHBvcyArPSBNYXRoLmZsb29yKGNoaXBzLndpZHRoICsgMjApO1xuXG5cdFx0dmFyIHRleHRGaWVsZCA9IG5ldyBQSVhJLlRleHQodmFsdWVzW2ldLCB7XG5cdFx0XHRmb250OiBcImJvbGQgMTJweCBBcmlhbFwiLFxuXHRcdFx0YWxpZ246IFwiY2VudGVyXCIsXG5cdFx0XHRmaWxsOiBcIiNmZmZmZmZcIlxuXHRcdH0pO1xuXG5cdFx0dGV4dEZpZWxkLnBvc2l0aW9uLnggPSAoY2hpcHMud2lkdGggLSB0ZXh0RmllbGQud2lkdGgpKjAuNTtcblx0XHR0ZXh0RmllbGQucG9zaXRpb24ueSA9IDMwO1xuXG5cdFx0Y2hpcHMuYWRkQ2hpbGQodGV4dEZpZWxkKTtcblx0fVxuXG5cdHRoaXMuaG9sZGVyLnggPSAtdGhpcy5ob2xkZXIud2lkdGgqMC41O1xufVxuXG4vKipcbiAqIEhpZGUuXG4gKiBAbWV0aG9kIGhpZGVcbiAqL1xuUG90Vmlldy5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnZpc2libGUgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBTaG93LlxuICogQG1ldGhvZCBzaG93XG4gKi9cblBvdFZpZXcucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcblx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvdFZpZXc7IiwiLyoqXG4gKiBDbGllbnQuXG4gKiBAbW9kdWxlIGNsaWVudFxuICovXG5cbnZhciBQSVhJID0gcmVxdWlyZShcInBpeGkuanNcIik7XG52YXIgVFdFRU4gPSByZXF1aXJlKFwidHdlZW4uanNcIik7XG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZShcInlhZWRcIik7XG52YXIgQ2hlY2tib3ggPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvQ2hlY2tib3hcIik7XG52YXIgQnV0dG9uRGF0YSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9kYXRhL0J1dHRvbkRhdGFcIik7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiaW5oZXJpdHNcIik7XG5cbi8qKlxuICogQSBwb3Qgdmlld1xuICogQGNsYXNzIFByZXNldEJ1dHRvblxuICovXG5mdW5jdGlvbiBQcmVzZXRCdXR0b24ocmVzb3VyY2VzKSB7XG5cdFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKHRoaXMpO1xuXHRcblx0dGhpcy5yZXNvdXJjZXMgPSByZXNvdXJjZXM7XG5cblx0dGhpcy5pZCA9IG51bGw7XG5cdHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuXHR0aGlzLnZhbHVlID0gMDtcblxuXHR2YXIgYiA9IG5ldyBQSVhJLlNwcml0ZSh0aGlzLnJlc291cmNlcy5nZXRUZXh0dXJlKFwiY2hlY2tib3hCYWNrZ3JvdW5kXCIpKTtcblx0dmFyIHQgPSBuZXcgUElYSS5TcHJpdGUodGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcImNoZWNrYm94VGlja1wiKSk7XG5cdHQueCA9IDE7XG5cblx0dGhpcy5jaGVja2JveCA9IG5ldyBDaGVja2JveChiLHQpO1xuXHR0aGlzLmNoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy5vbkNoZWNrYm94Q2hhbmdlLCB0aGlzKTtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLmNoZWNrYm94KTtcblxuXHR2YXIgc3R5bGVPYmplY3QgPSB7XG5cdFx0Zm9udDogXCJib2xkIDEycHggQXJpYWxcIixcblx0XHR3b3JkV3JhcDogdHJ1ZSxcblx0XHR3b3JkV3JhcFdpZHRoOiAyNTAsXG5cdFx0ZmlsbDogXCJ3aGl0ZVwiXG5cdH07XG5cblx0dGhpcy5sYWJlbEZpZWxkID0gbmV3IFBJWEkuVGV4dChcIlwiLCBzdHlsZU9iamVjdCk7XG5cdHRoaXMubGFiZWxGaWVsZC5wb3NpdGlvbi54ID0gMjU7XG5cblx0dGhpcy5hZGRDaGlsZCh0aGlzLmxhYmVsRmllbGQpO1xufVxuXG5pbmhlcml0cyhQcmVzZXRCdXR0b24sIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcik7XG5FdmVudERpc3BhdGNoZXIuaW5pdChQcmVzZXRCdXR0b24pO1xuXG5cblByZXNldEJ1dHRvbi5DSEFOR0UgPSBcImNoYW5nZVwiO1xuXG4vKipcbiAqIFByZXNldCBidXR0b24gY2hhbmdlLlxuICogQG1ldGhvZCBvblByZXNldEJ1dHRvbkNoYW5nZVxuICovXG5QcmVzZXRCdXR0b24ucHJvdG90eXBlLm9uQ2hlY2tib3hDaGFuZ2UgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5kaXNwYXRjaEV2ZW50KFByZXNldEJ1dHRvbi5DSEFOR0UpO1xufVxuXG4vKipcbiAqIFNldCBsYWJlbC5cbiAqIEBtZXRob2Qgc2V0TGFiZWxcbiAqL1xuUHJlc2V0QnV0dG9uLnByb3RvdHlwZS5zZXRMYWJlbCA9IGZ1bmN0aW9uKGxhYmVsKSB7XG5cdHRoaXMubGFiZWxGaWVsZC5zZXRUZXh0KGxhYmVsKTtcblx0cmV0dXJuIGxhYmVsO1xufVxuXG4vKipcbiAqIFNob3cuXG4gKiBAbWV0aG9kIHNob3dcbiAqL1xuUHJlc2V0QnV0dG9uLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oaWQsIHZhbHVlKSB7XG5cdHRoaXMuaWQgPSBpZDtcblx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXG5cdGlmKHRoaXMudmFsdWUgPiAwKVxuXHRcdHRoaXMuc2V0TGFiZWwoQnV0dG9uRGF0YS5nZXRCdXR0b25TdHJpbmdGb3JJZChpZCkrXCIgKFwiK3RoaXMudmFsdWUrXCIpXCIpO1xuXG5cdGVsc2Vcblx0XHR0aGlzLnNldExhYmVsKEJ1dHRvbkRhdGEuZ2V0QnV0dG9uU3RyaW5nRm9ySWQoaWQpKTtcblxuXHR0aGlzLnZpc2libGUgPSB0cnVlO1xufVxuXG4vKipcbiAqIEhpZGUuXG4gKiBAbWV0aG9kIGhpZGVcbiAqL1xuUHJlc2V0QnV0dG9uLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuaWQgPSBudWxsO1xuXHR0aGlzLnZpc2libGUgPSBmYWxzZTtcblx0dGhpcy52YWx1ZSA9IDA7XG5cdHRoaXMuc2V0Q2hlY2tlZChmYWxzZSk7XG59XG5cbi8qKlxuICogR2V0IGNoZWNrZWQuXG4gKiBAbWV0aG9kIGdldENoZWNrZWRcbiAqL1xuUHJlc2V0QnV0dG9uLnByb3RvdHlwZS5nZXRDaGVja2VkID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmNoZWNrYm94LmdldENoZWNrZWQoKTtcbn1cblxuLyoqXG4gKiBTZXQgY2hlY2tlZC5cbiAqIEBtZXRob2Qgc2V0Q2hlY2tlZFxuICovXG5QcmVzZXRCdXR0b24ucHJvdG90eXBlLnNldENoZWNrZWQgPSBmdW5jdGlvbihiKSB7XG5cdHRoaXMuY2hlY2tib3guc2V0Q2hlY2tlZChiKTtcblxuXHRyZXR1cm4gdGhpcy5jaGVja2JveC5nZXRDaGVja2VkKCk7XG59XG5cbi8qKlxuICogR2V0IHZhbHVlLlxuICogQG1ldGhvZCBnZXRWYWx1ZVxuICovXG5QcmVzZXRCdXR0b24ucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByZXNldEJ1dHRvbjsiLCIvKipcbiAqIENsaWVudC5cbiAqIEBtb2R1bGUgY2xpZW50XG4gKi9cblxudmFyIFBJWEkgPSByZXF1aXJlKFwicGl4aS5qc1wiKTtcbnZhciBUV0VFTiA9IHJlcXVpcmUoXCJ0d2Vlbi5qc1wiKTtcbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKFwieWFlZFwiKTtcbnZhciBQcmVzZXRCdXR0b24gPSByZXF1aXJlKFwiLi9QcmVzZXRCdXR0b25cIik7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiaW5oZXJpdHNcIik7XG5cbi8qKlxuICogQSBwb3Qgdmlld1xuICogQGNsYXNzIFByZXNldEJ1dHRvbnNWaWV3XG4gKi9cbmZ1bmN0aW9uIFByZXNldEJ1dHRvbnNWaWV3KHZpZXdDb25maWcsIHJlc291cmNlcykge1xuXHRQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIuY2FsbCh0aGlzKTtcblxuXHR0aGlzLnJlc291cmNlcyA9IHJlc291cmNlcztcblxuXHR0aGlzLmJ1dHRvbnMgPSBuZXcgQXJyYXkoKTtcblx0dmFyIG9yaWdpbiA9IHRoaXMucmVzb3VyY2VzLmdldFBvaW50KFwiYmlnQnV0dG9uUG9zaXRpb25cIik7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcblx0XHR2YXIgcCA9IG5ldyBQcmVzZXRCdXR0b24odGhpcy5yZXNvdXJjZXMpO1xuXHRcdHAuYWRkRXZlbnRMaXN0ZW5lcihQcmVzZXRCdXR0b24uQ0hBTkdFLCB0aGlzLm9uUHJlc2V0QnV0dG9uQ2hhbmdlLCB0aGlzKTtcblx0XHRwLnggPSBvcmlnaW4ueCArIDMwICsgMTQwICogKGkgJSAyKTtcblx0XHRwLnkgPSBvcmlnaW4ueSArIDM1ICogTWF0aC5mbG9vcihpIC8gMik7XG5cdFx0dGhpcy5hZGRDaGlsZChwKTtcblx0XHR0aGlzLmJ1dHRvbnMucHVzaChwKTtcblx0fVxuXG5cdHRoaXMuaGlkZSgpO1xufVxuXG5pbmhlcml0cyhQcmVzZXRCdXR0b25zVmlldywgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyKTtcbkV2ZW50RGlzcGF0Y2hlci5pbml0KFByZXNldEJ1dHRvbnNWaWV3KTtcblxuUHJlc2V0QnV0dG9uc1ZpZXcuQ0hBTkdFID0gXCJjaGFuZ2VcIjtcblxuLyoqXG4gKiBQcmVzZXQgYnV0dG9uIGNoYW5nZS5cbiAqIEBtZXRob2Qgb25QcmVzZXRCdXR0b25DaGFuZ2VcbiAqL1xuUHJlc2V0QnV0dG9uc1ZpZXcucHJvdG90eXBlLm9uUHJlc2V0QnV0dG9uQ2hhbmdlID0gZnVuY3Rpb24oZXYpIHtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYnV0dG9ucy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBiID0gdGhpcy5idXR0b25zW2ldO1xuXHRcdGlmIChiICE9IGV2LnRhcmdldCkge1xuXHRcdFx0Yi5zZXRDaGVja2VkKGZhbHNlKTtcblx0XHR9XG5cdH1cblxuXHR0aGlzLmRpc3BhdGNoRXZlbnQoUHJlc2V0QnV0dG9uc1ZpZXcuQ0hBTkdFKTtcbn1cblxuLyoqXG4gKiBIaWRlLlxuICogQG1ldGhvZCBoaWRlXG4gKi9cblByZXNldEJ1dHRvbnNWaWV3LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5idXR0b25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0dGhpcy5idXR0b25zW2ldLmhpZGUoKTtcblx0fVxufVxuXG4vKipcbiAqIFNob3cuXG4gKiBAbWV0aG9kIHNob3dcbiAqL1xuUHJlc2V0QnV0dG9uc1ZpZXcucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcblx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblxufVxuXG4vKipcbiAqIEdldCBidXR0b25zLlxuICogQG1ldGhvZCBnZXRCdXR0b25zXG4gKi9cblByZXNldEJ1dHRvbnNWaWV3LnByb3RvdHlwZS5nZXRCdXR0b25zID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmJ1dHRvbnM7XG59XG5cbi8qKlxuICogR2V0IGN1cnJlbnQgcHJlc2V0IGJ1dHRvbi5cbiAqIEBtZXRob2QgZ2V0Q3VycmVudFxuICovXG5QcmVzZXRCdXR0b25zVmlldy5wcm90b3R5cGUuZ2V0Q3VycmVudCA9IGZ1bmN0aW9uKCkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYnV0dG9ucy5sZW5ndGg7IGkrKykge1xuXHRcdGlmICh0aGlzLmJ1dHRvbnNbaV0uZ2V0Q2hlY2tlZCgpID09IHRydWUpIHtcblx0XHRcdHJldHVybiB0aGlzLmJ1dHRvbnNbaV07XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEdldCBjdXJyZW50IHByZXNldCBidXR0b24uXG4gKiBAbWV0aG9kIHNldEN1cnJlbnRcbiAqL1xuUHJlc2V0QnV0dG9uc1ZpZXcucHJvdG90eXBlLnNldEN1cnJlbnQgPSBmdW5jdGlvbihpZCkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYnV0dG9ucy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBiID0gdGhpcy5idXR0b25zW2ldO1xuXHRcdGlmICgoaWQgIT0gbnVsbCkgJiYgKGIuaWQgPT0gaWQpKSB7XG5cdFx0XHRiLnNldENoZWNrZWQodHJ1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGIuc2V0Q2hlY2tlZChmYWxzZSk7XG5cdFx0fVxuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHJlc2V0QnV0dG9uc1ZpZXc7IiwiLyoqXG4gKiBDbGllbnQuXG4gKiBAbW9kdWxlIGNsaWVudFxuICovXG5cbnZhciBQSVhJID0gcmVxdWlyZShcInBpeGkuanNcIik7XG52YXIgVFdFRU4gPSByZXF1aXJlKFwidHdlZW4uanNcIik7XG52YXIgQnV0dG9uID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL0J1dHRvblwiKTtcbnZhciBOaW5lU2xpY2UgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvTmluZVNsaWNlXCIpO1xudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoXCJ5YWVkXCIpO1xudmFyIENoZWNrYm94ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL0NoZWNrYm94XCIpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xuXG4vKipcbiAqIFJhaXNlIHNob3J0Y3V0IGJ1dHRvblxuICogQGNsYXNzIFJhaXNlU2hvcnRjdXRCdXR0b25cbiAqL1xuZnVuY3Rpb24gUmFpc2VTaG9ydGN1dEJ1dHRvbihyZXNvdXJjZXMpIHtcblx0dmFyIGJhY2tncm91bmQgPSBuZXcgTmluZVNsaWNlKHJlc291cmNlcy5nZXRUZXh0dXJlKFwiYnV0dG9uQmFja2dyb3VuZFwiKSwgMTAsIDUsIDEwLCA1KTtcblx0YmFja2dyb3VuZC5zZXRMb2NhbFNpemUoMTA1LCAyNSk7XG5cdEJ1dHRvbi5jYWxsKHRoaXMsIGJhY2tncm91bmQpO1xuXG5cdHZhciBzdHlsZU9iamVjdCA9IHtcblx0XHR3aWR0aDogMTA1LFxuXHRcdGhlaWdodDogMjAsXG5cdFx0Zm9udDogXCJib2xkIDE0cHggQXJpYWxcIixcblx0XHRjb2xvcjogXCJ3aGl0ZVwiXG5cdH07XG5cdHRoaXMubGFiZWwgPSBuZXcgUElYSS5UZXh0KFwiXCIsIHN0eWxlT2JqZWN0KTtcblx0dGhpcy5sYWJlbC5wb3NpdGlvbi54ID0gODtcblx0dGhpcy5sYWJlbC5wb3NpdGlvbi55ID0gNDtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLmxhYmVsKTtcbn1cblxuaW5oZXJpdHMoUmFpc2VTaG9ydGN1dEJ1dHRvbiwgQnV0dG9uKTtcbkV2ZW50RGlzcGF0Y2hlci5pbml0KFJhaXNlU2hvcnRjdXRCdXR0b24pO1xuXG4vKipcbiAqIFNldHRlci5cbiAqIEBtZXRob2Qgc2V0VGV4dFxuICovXG5SYWlzZVNob3J0Y3V0QnV0dG9uLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdHRoaXMubGFiZWwuc2V0VGV4dChzdHJpbmcpO1xuXHRyZXR1cm4gc3RyaW5nO1xufVxuXG4vKipcbiAqIFNldCBlbmFibGVkLlxuICogQG1ldGhvZCBzZXRFbmFibGVkXG4gKi9cblJhaXNlU2hvcnRjdXRCdXR0b24ucHJvdG90eXBlLnNldEVuYWJsZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRpZiAodmFsdWUpIHtcblx0XHR0aGlzLmFscGhhID0gMTtcblx0XHR0aGlzLmludGVyYWN0aXZlID0gdHJ1ZTtcblx0XHR0aGlzLmJ1dHRvbk1vZGUgPSB0cnVlO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuYWxwaGEgPSAwLjU7XG5cdFx0dGhpcy5pbnRlcmFjdGl2ZSA9IGZhbHNlO1xuXHRcdHRoaXMuYnV0dG9uTW9kZSA9IGZhbHNlO1xuXHR9XG5cdHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSYWlzZVNob3J0Y3V0QnV0dG9uOyIsIi8qKlxuICogQ2xpZW50LlxuICogQG1vZHVsZSBjbGllbnRcbiAqL1xuXG52YXIgUElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xudmFyIFRXRUVOID0gcmVxdWlyZShcInR3ZWVuLmpzXCIpO1xudmFyIEJ1dHRvbiA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9CdXR0b25cIik7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiaW5oZXJpdHNcIik7XG5cbi8qKlxuICogQSBzZWF0IHZpZXcuXG4gKiBAY2xhc3MgU2VhdFZpZXdcbiAqL1xuZnVuY3Rpb24gU2VhdFZpZXcocmVzb3VyY2VzLCBzZWF0SW5kZXgpIHtcblx0QnV0dG9uLmNhbGwodGhpcyk7XG5cblx0dGhpcy5wb2NrZXRDYXJkcyA9IFtdO1xuXHR0aGlzLnJlc291cmNlcyA9IHJlc291cmNlcztcblx0dGhpcy5zZWF0SW5kZXggPSBzZWF0SW5kZXg7XG5cblx0dmFyIHNlYXRUZXh0dXJlID0gdGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcInNlYXRQbGF0ZVwiKTtcblx0dmFyIHNlYXRTcHJpdGUgPSBuZXcgUElYSS5TcHJpdGUoc2VhdFRleHR1cmUpO1xuXG5cdHNlYXRTcHJpdGUucG9zaXRpb24ueCA9IC1zZWF0VGV4dHVyZS53aWR0aCAvIDI7XG5cdHNlYXRTcHJpdGUucG9zaXRpb24ueSA9IC1zZWF0VGV4dHVyZS5oZWlnaHQgLyAyO1xuXG5cdHRoaXMuYWRkQ2hpbGQoc2VhdFNwcml0ZSk7XG5cblx0dmFyIHBvcyA9IHRoaXMucmVzb3VyY2VzLmdldFBvaW50KFwic2VhdFBvc2l0aW9uXCIgKyB0aGlzLnNlYXRJbmRleCk7XG5cblx0dGhpcy5wb3NpdGlvbi54ID0gcG9zLng7XG5cdHRoaXMucG9zaXRpb24ueSA9IHBvcy55O1xuXG5cdHZhciBzdHlsZTtcblxuXHRzdHlsZSA9IHtcblx0XHRmb250OiBcImJvbGQgMjBweCBBcmlhbFwiXG5cdH07XG5cblx0dGhpcy5uYW1lRmllbGQgPSBuZXcgUElYSS5UZXh0KFwiW25hbWVdXCIsIHN0eWxlKTtcblx0dGhpcy5uYW1lRmllbGQucG9zaXRpb24ueSA9IC0yMDtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLm5hbWVGaWVsZCk7XG5cblx0c3R5bGUgPSB7XG5cdFx0Zm9udDogXCJub3JtYWwgMTJweCBBcmlhbFwiXG5cdH07XG5cblx0dGhpcy5jaGlwc0ZpZWxkID0gbmV3IFBJWEkuVGV4dChcIltuYW1lXVwiLCBzdHlsZSk7XG5cdHRoaXMuY2hpcHNGaWVsZC5wb3NpdGlvbi55ID0gNTtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLmNoaXBzRmllbGQpO1xuXG5cdHN0eWxlID0ge1xuXHRcdGZvbnQ6IFwiYm9sZCAyMHB4IEFyaWFsXCJcblx0fTtcblxuXHR0aGlzLmFjdGlvbkZpZWxkID0gbmV3IFBJWEkuVGV4dChcImFjdGlvblwiLCBzdHlsZSk7XG5cdHRoaXMuYWN0aW9uRmllbGQucG9zaXRpb24ueSA9IC0xMztcblx0dGhpcy5hZGRDaGlsZCh0aGlzLmFjdGlvbkZpZWxkKTtcblx0dGhpcy5hY3Rpb25GaWVsZC5hbHBoYSA9IDA7XG5cblx0dGhpcy5zZXROYW1lKFwiXCIpO1xuXHR0aGlzLnNldENoaXBzKFwiXCIpO1xuXG5cdHRoaXMuYmV0Q2hpcHMgPSBudWxsO1xufVxuXG5pbmhlcml0cyhTZWF0VmlldywgQnV0dG9uKTtcblxuLyoqXG4gKiBTZXQgcmVmZXJlbmNlIHRvIGJldCBjaGlwcy5cbiAqIEBtZXRob2Qgc2V0QmV0Q2hpcHNWaWV3XG4gKi9cblNlYXRWaWV3LnByb3RvdHlwZS5zZXRCZXRDaGlwc1ZpZXcgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHR0aGlzLmJldENoaXBzID0gdmFsdWU7XG59XG5cbi8qKlxuICogU2V0IG5hbWUuXG4gKiBAbWV0aG9kIHNldE5hbWVcbiAqL1xuU2VhdFZpZXcucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG5cdHRoaXMubmFtZUZpZWxkLnNldFRleHQobmFtZSk7XG5cdHRoaXMubmFtZUZpZWxkLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXG5cdHRoaXMubmFtZUZpZWxkLnBvc2l0aW9uLnggPSAtdGhpcy5uYW1lRmllbGQuY2FudmFzLndpZHRoIC8gMjtcbn1cblxuLyoqXG4gKiBTZXQgbmFtZS5cbiAqIEBtZXRob2Qgc2V0Q2hpcHNcbiAqL1xuU2VhdFZpZXcucHJvdG90eXBlLnNldENoaXBzID0gZnVuY3Rpb24oY2hpcHMpIHtcblx0dGhpcy5jaGlwc0ZpZWxkLnNldFRleHQoY2hpcHMpO1xuXHR0aGlzLmNoaXBzRmllbGQudXBkYXRlVHJhbnNmb3JtKCk7XG5cblx0dGhpcy5jaGlwc0ZpZWxkLnBvc2l0aW9uLnggPSAtdGhpcy5jaGlwc0ZpZWxkLmNhbnZhcy53aWR0aCAvIDI7XG59XG5cbi8qKlxuICogU2V0IHNpdG91dC5cbiAqIEBtZXRob2Qgc2V0U2l0b3V0XG4gKi9cblNlYXRWaWV3LnByb3RvdHlwZS5zZXRTaXRvdXQgPSBmdW5jdGlvbihzaXRvdXQpIHtcblx0aWYgKHNpdG91dClcblx0XHR0aGlzLmFscGhhID0gLjU7XG5cblx0ZWxzZVxuXHRcdHRoaXMuYWxwaGEgPSAxO1xufVxuXG4vKipcbiAqIFNldCBzaXRvdXQuXG4gKiBAbWV0aG9kIHNldEFjdGl2ZVxuICovXG5TZWF0Vmlldy5wcm90b3R5cGUuc2V0QWN0aXZlID0gZnVuY3Rpb24oYWN0aXZlKSB7XG5cdHRoaXMudmlzaWJsZSA9IGFjdGl2ZTtcbn1cblxuLyoqXG4gKiBBZGQgcG9ja2V0IGNhcmQuXG4gKiBAbWV0aG9kIGFkZFBvY2tldENhcmRcbiAqL1xuU2VhdFZpZXcucHJvdG90eXBlLmFkZFBvY2tldENhcmQgPSBmdW5jdGlvbihjYXJkVmlldykge1xuXHR0aGlzLnBvY2tldENhcmRzLnB1c2goY2FyZFZpZXcpO1xufVxuXG4vKipcbiAqIEdldCBwb2NrZXQgY2FyZHMuXG4gKiBAbWV0aG9kIGdldFBvY2tldENhcmRzXG4gKi9cblNlYXRWaWV3LnByb3RvdHlwZS5nZXRQb2NrZXRDYXJkcyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5wb2NrZXRDYXJkcztcbn1cblxuLyoqXG4gKiBGb2xkIGNhcmRzLlxuICogQG1ldGhvZCBmb2xkQ2FyZHNcbiAqL1xuU2VhdFZpZXcucHJvdG90eXBlLmZvbGRDYXJkcyA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnBvY2tldENhcmRzWzBdLmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25Eb25lXCIsIHRoaXMub25Gb2xkQ29tcGxldGUsIHRoaXMpO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9ja2V0Q2FyZHMubGVuZ3RoOyBpKyspIHtcblx0XHR0aGlzLnBvY2tldENhcmRzW2ldLmZvbGQoKTtcblx0fVxufVxuXG4vKipcbiAqIEZvbGQgY29tcGxldGUuXG4gKiBAbWV0aG9kIG9uRm9sZENvbXBsZXRlXG4gKi9cblNlYXRWaWV3LnByb3RvdHlwZS5vbkZvbGRDb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnBvY2tldENhcmRzWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25Eb25lXCIsIHRoaXMub25Gb2xkQ29tcGxldGUsIHRoaXMpO1xuXHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJhbmltYXRpb25Eb25lXCIpO1xufVxuXG4vKipcbiAqIFNob3cgdXNlciBhY3Rpb24uXG4gKiBAbWV0aG9kIGFjdGlvblxuICovXG5TZWF0Vmlldy5wcm90b3R5cGUuYWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uKSB7XG5cdHRoaXMuYWN0aW9uRmllbGQuc2V0VGV4dChhY3Rpb24pO1xuXHR0aGlzLmFjdGlvbkZpZWxkLnBvc2l0aW9uLnggPSAtdGhpcy5hY3Rpb25GaWVsZC5jYW52YXMud2lkdGggLyAyO1xuXG5cdHRoaXMuYWN0aW9uRmllbGQuYWxwaGEgPSAxO1xuXHR0aGlzLm5hbWVGaWVsZC5hbHBoYSA9IDA7XG5cdHRoaXMuY2hpcHNGaWVsZC5hbHBoYSA9IDA7XG5cblx0c2V0VGltZW91dCh0aGlzLm9uVGltZXIuYmluZCh0aGlzKSwgMTAwMCk7XG59XG5cbi8qKlxuICogU2hvdyB1c2VyIGFjdGlvbi5cbiAqIEBtZXRob2QgYWN0aW9uXG4gKi9cblNlYXRWaWV3LnByb3RvdHlwZS5vblRpbWVyID0gZnVuY3Rpb24oYWN0aW9uKSB7XG5cblx0dmFyIHQxID0gbmV3IFRXRUVOLlR3ZWVuKHRoaXMuYWN0aW9uRmllbGQpXG5cdFx0LnRvKHtcblx0XHRcdGFscGhhOiAwXG5cdFx0fSwgMTAwMClcblx0XHQuc3RhcnQoKTtcblx0dmFyIHQyID0gbmV3IFRXRUVOLlR3ZWVuKHRoaXMubmFtZUZpZWxkKVxuXHRcdC50byh7XG5cdFx0XHRhbHBoYTogMVxuXHRcdH0sIDEwMDApXG5cdFx0LnN0YXJ0KCk7XG5cdHZhciB0MyA9IG5ldyBUV0VFTi5Ud2Vlbih0aGlzLmNoaXBzRmllbGQpXG5cdFx0LnRvKHtcblx0XHRcdGFscGhhOiAxXG5cdFx0fSwgMTAwMClcblx0XHQuc3RhcnQoKTtcblxufVxuXG4vKipcbiAqIENsZWFyLlxuICogQG1ldGhvZCBjbGVhclxuICovXG5TZWF0Vmlldy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0dmFyIGk7XG5cblx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblx0dGhpcy5zaXRvdXQgPSBmYWxzZTtcblx0dGhpcy5iZXRDaGlwcy5zZXRWYWx1ZSgwKTtcblx0dGhpcy5zZXROYW1lKFwiXCIpO1xuXHR0aGlzLnNldENoaXBzKFwiXCIpO1xuXG5cdGZvciAoaSA9IDA7IGkgPCB0aGlzLnBvY2tldENhcmRzLmxlbmd0aDsgaSsrKVxuXHRcdHRoaXMucG9ja2V0Q2FyZHNbaV0uaGlkZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlYXRWaWV3OyIsIi8qKlxuICogQ2xpZW50LlxuICogQG1vZHVsZSBjbGllbnRcbiAqL1xuXG52YXIgUElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xudmFyIFRXRUVOID0gcmVxdWlyZShcInR3ZWVuLmpzXCIpO1xudmFyIEJ1dHRvbiA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9CdXR0b25cIik7XG52YXIgTmluZVNsaWNlID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL05pbmVTbGljZVwiKTtcbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKFwieWFlZFwiKTtcbnZhciBDaGVja2JveCA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9DaGVja2JveFwiKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCJpbmhlcml0c1wiKTtcblxuLyoqXG4gKiBDaGVja2JveGVzIHZpZXdcbiAqIEBjbGFzcyBTZXR0aW5nc0NoZWNrYm94XG4gKi9cbmZ1bmN0aW9uIFNldHRpbmdzQ2hlY2tib3gocmVzb3VyY2VzLCBpZCwgc3RyaW5nKSB7XG4gXHRQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIuY2FsbCh0aGlzKTtcblxuIFx0dGhpcy5yZXNvdXJjZXMgPSByZXNvdXJjZXM7XG4gXHR0aGlzLmlkID0gaWQ7XG5cbiBcdHZhciB5ID0gMDtcblxuIFx0dmFyIHN0eWxlT2JqZWN0ID0ge1xuIFx0XHR3aWR0aDogMjAwLFxuIFx0XHRoZWlnaHQ6IDI1LFxuIFx0XHRmb250OiBcImJvbGQgMTNweCBBcmlhbFwiLFxuIFx0XHRjb2xvcjogXCJ3aGl0ZVwiXG4gXHR9O1xuIFx0dGhpcy5sYWJlbCA9IG5ldyBQSVhJLlRleHQoc3RyaW5nLCBzdHlsZU9iamVjdCk7XG4gXHR0aGlzLmxhYmVsLnBvc2l0aW9uLnggPSAyNTtcbiBcdHRoaXMubGFiZWwucG9zaXRpb24ueSA9IHkgKyAxO1xuIFx0dGhpcy5hZGRDaGlsZCh0aGlzLmxhYmVsKTtcblxuIFx0dmFyIGJhY2tncm91bmQgPSBuZXcgUElYSS5TcHJpdGUodGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcImNoZWNrYm94QmFja2dyb3VuZFwiKSk7XG4gXHR2YXIgdGljayA9IG5ldyBQSVhJLlNwcml0ZSh0aGlzLnJlc291cmNlcy5nZXRUZXh0dXJlKFwiY2hlY2tib3hUaWNrXCIpKTtcbiBcdHRpY2sueCA9IDE7XG5cbiBcdHRoaXMuY2hlY2tib3ggPSBuZXcgQ2hlY2tib3goYmFja2dyb3VuZCwgdGljayk7XG4gXHR0aGlzLmNoZWNrYm94LnBvc2l0aW9uLnkgPSB5O1xuIFx0dGhpcy5hZGRDaGlsZCh0aGlzLmNoZWNrYm94KTtcblxuIFx0dGhpcy5jaGVja2JveC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMub25DaGVja2JveENoYW5nZSwgdGhpcyk7XG59XG5cbmluaGVyaXRzKFNldHRpbmdzQ2hlY2tib3gsIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcik7XG5FdmVudERpc3BhdGNoZXIuaW5pdChTZXR0aW5nc0NoZWNrYm94KTtcblxuLyoqXG4gKiBDaGVja2JveCBjaGFuZ2UuXG4gKiBAbWV0aG9kIG9uQ2hlY2tib3hDaGFuZ2VcbiAqL1xuU2V0dGluZ3NDaGVja2JveC5wcm90b3R5cGUub25DaGVja2JveENoYW5nZSA9IGZ1bmN0aW9uKGludGVyYWN0aW9uX29iamVjdCkge1xuXHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJjaGFuZ2VcIiwgdGhpcyk7XG59XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRDaGVja2VkXG4gKi9cblNldHRpbmdzQ2hlY2tib3gucHJvdG90eXBlLmdldENoZWNrZWQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuY2hlY2tib3guZ2V0Q2hlY2tlZCgpO1xufVxuXG4vKipcbiAqIFNldHRlci5cbiAqIEBtZXRob2Qgc2V0Q2hlY2tlZFxuICovXG5TZXR0aW5nc0NoZWNrYm94LnByb3RvdHlwZS5zZXRDaGVja2VkID0gZnVuY3Rpb24oY2hlY2tlZCkge1xuXHR0aGlzLmNoZWNrYm94LnNldENoZWNrZWQoY2hlY2tlZCk7XG5cdHJldHVybiBjaGVja2VkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNldHRpbmdzQ2hlY2tib3g7IiwiLyoqXG4gKiBDbGllbnQuXG4gKiBAbW9kdWxlIGNsaWVudFxuICovXG5cbnZhciBQSVhJID0gcmVxdWlyZShcInBpeGkuanNcIik7XG52YXIgVFdFRU4gPSByZXF1aXJlKFwidHdlZW4uanNcIik7XG52YXIgQnV0dG9uID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL0J1dHRvblwiKTtcbnZhciBOaW5lU2xpY2UgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvTmluZVNsaWNlXCIpO1xudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoXCJ5YWVkXCIpO1xudmFyIFNldHRpbmdzQ2hlY2tib3ggPSByZXF1aXJlKFwiLi9TZXR0aW5nc0NoZWNrYm94XCIpO1xudmFyIFJhaXNlU2hvcnRjdXRCdXR0b24gPSByZXF1aXJlKFwiLi9SYWlzZVNob3J0Y3V0QnV0dG9uXCIpO1xudmFyIENoZWNrYm94TWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9DaGVja2JveE1lc3NhZ2VcIik7XG52YXIgQnV0dG9uRGF0YSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9kYXRhL0J1dHRvbkRhdGFcIik7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiaW5oZXJpdHNcIik7XG5cbi8qKlxuICogQSBzZXR0aW5ncyB2aWV3XG4gKiBAY2xhc3MgU2V0dGluZ3NWaWV3XG4gKi9cbmZ1bmN0aW9uIFNldHRpbmdzVmlldyh2aWV3Q29uZmlnLCByZXNvdXJjZXMpIHtcblx0UElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLmNhbGwodGhpcyk7XG5cblx0dGhpcy52aWV3Q29uZmlnID0gdmlld0NvbmZpZztcblx0dGhpcy5yZXNvdXJjZXMgPSByZXNvdXJjZXM7XG5cblx0dmFyIG9iamVjdCA9IG5ldyBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIoKTtcblx0dmFyIGJnID0gbmV3IE5pbmVTbGljZSh0aGlzLnJlc291cmNlcy5nZXRUZXh0dXJlKFwiY2hhdEJhY2tncm91bmRcIiksIDEwLCAxMCwgMTAsIDEwKTtcblx0Ymcuc2V0TG9jYWxTaXplKDMwLCAzMCk7XG5cdG9iamVjdC5hZGRDaGlsZChiZyk7XG5cblx0dmFyIHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZSh0aGlzLnJlc291cmNlcy5nZXRUZXh0dXJlKFwid3JlbmNoSWNvblwiKSk7XG5cdHNwcml0ZS54ID0gNTtcblx0c3ByaXRlLnkgPSA1O1xuXHRvYmplY3QuYWRkQ2hpbGQoc3ByaXRlKTtcblxuXHR0aGlzLnNldHRpbmdzQnV0dG9uID0gbmV3IEJ1dHRvbihvYmplY3QpO1xuXHR0aGlzLnNldHRpbmdzQnV0dG9uLnBvc2l0aW9uLnggPSA5NjAgLSAxMCAtIHRoaXMuc2V0dGluZ3NCdXR0b24ud2lkdGg7XG5cdHRoaXMuc2V0dGluZ3NCdXR0b24ucG9zaXRpb24ueSA9IDU0Mztcblx0dGhpcy5zZXR0aW5nc0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKEJ1dHRvbi5DTElDSywgdGhpcy5vblNldHRpbmdzQnV0dG9uQ2xpY2ssIHRoaXMpO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMuc2V0dGluZ3NCdXR0b24pO1xuXG5cdHRoaXMuc2V0dGluZ3NNZW51ID0gbmV3IFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcigpO1xuXG5cdHZhciBtYmcgPSBuZXcgTmluZVNsaWNlKHRoaXMucmVzb3VyY2VzLmdldFRleHR1cmUoXCJjaGF0QmFja2dyb3VuZFwiKSwgMTAsIDEwLCAxMCwgMTApO1xuXHRtYmcuc2V0TG9jYWxTaXplKDI1MCwgMTAwKTtcblx0dGhpcy5zZXR0aW5nc01lbnUuYWRkQ2hpbGQobWJnKTtcblxuXHR2YXIgc3R5bGVPYmplY3QgPSB7XG5cdFx0Zm9udDogXCJib2xkIDE0cHggQXJpYWxcIixcblx0XHRjb2xvcjogXCIjRkZGRkZGXCIsXG5cdFx0d2lkdGg6IDIwMCxcblx0XHRoZWlnaHQ6IDIwXG5cdH07XG5cdHZhciBsYWJlbCA9IG5ldyBQSVhJLlRleHQoXCJTZXR0aW5nc1wiLCBzdHlsZU9iamVjdCk7XG5cdGxhYmVsLnBvc2l0aW9uLnggPSAxNjtcblx0bGFiZWwucG9zaXRpb24ueSA9IDEwO1xuXG5cdHRoaXMuc2V0dGluZ3NNZW51LmFkZENoaWxkKGxhYmVsKTtcblx0dGhpcy5zZXR0aW5nc01lbnUucG9zaXRpb24ueCA9IDk2MCAtIDEwIC0gdGhpcy5zZXR0aW5nc01lbnUud2lkdGg7XG5cdHRoaXMuc2V0dGluZ3NNZW51LnBvc2l0aW9uLnkgPSA1MzggLSB0aGlzLnNldHRpbmdzTWVudS5oZWlnaHQ7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5zZXR0aW5nc01lbnUpO1xuXG5cdHRoaXMuc2V0dGluZ3MgPSB7fTtcblxuXHQvL2NvbnNvbGUubG9nKFwic2V0dGluZyB1cCBzZXR0aW5ncywgdmlld2NvbmZpZz1cIiArIHRoaXMudmlld0NvbmZpZyk7XG5cblx0dGhpcy5jcmVhdGVNZW51U2V0dGluZyhcInBsYXlBbmltYXRpb25zXCIsIFwiUGxheSBhbmltYXRpb25zXCIsIDQwLCB0aGlzLnZpZXdDb25maWcuZ2V0UGxheUFuaW1hdGlvbnMoKSk7XG5cdHRoaXMuY3JlYXRlTWVudVNldHRpbmcoQ2hlY2tib3hNZXNzYWdlLkFVVE9fTVVDS19MT1NJTkcsIFwiTXVjayBsb3NpbmcgaGFuZHNcIiwgNjUpO1xuXG5cdHRoaXMuY3JlYXRlU2V0dGluZyhDaGVja2JveE1lc3NhZ2UuQVVUT19QT1NUX0JMSU5EUywgXCJQb3N0IGJsaW5kc1wiLCAwKTtcblx0dGhpcy5jcmVhdGVTZXR0aW5nKENoZWNrYm94TWVzc2FnZS5TSVRPVVRfTkVYVCwgXCJTaXQgb3V0XCIsIDI1KTtcblxuXHR0aGlzLnNldHRpbmdzTWVudS52aXNpYmxlID0gZmFsc2U7XG5cblx0dGhpcy5idXlDaGlwc0J1dHRvbiA9IG5ldyBSYWlzZVNob3J0Y3V0QnV0dG9uKHRoaXMucmVzb3VyY2VzKTtcblx0dGhpcy5idXlDaGlwc0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5vbkJ1eUNoaXBzQ2xpY2ssIHRoaXMpO1xuXHR0aGlzLmJ1eUNoaXBzQnV0dG9uLnggPSA3MDA7XG5cdHRoaXMuYnV5Q2hpcHNCdXR0b24ueSA9IDYzNTtcblx0dGhpcy5idXlDaGlwc0J1dHRvbi5zZXRUZXh0KFwiQnV5IGNoaXBzXCIpO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMuYnV5Q2hpcHNCdXR0b24pO1xuXG5cdHRoaXMuYnV5Q2hpcHNCdXR0b24udmlzaWJsZSA9IGZhbHNlO1xuXG5cdC8vIFByZXZlbnQgbW91c2Ugb3ZlciBmcm9tIGZhbGxpbmcgdGhyb3VnaCwgZG9lc24ndCB3b3JrLlxuXHQvKnRoaXMuc2V0dGluZ3NNZW51LmludGVyYWN0aXZlID0gdHJ1ZTtcblx0dGhpcy5zZXR0aW5nc01lbnUuYnV0dG9uTW9kZSA9IHRydWU7XG5cdHRoaXMuc2V0dGluZ3NNZW51Lm1vdXNlb3ZlciA9IGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZyhcInRlc3RcIik7IH07XG5cdHRoaXMuc2V0dGluZ3NNZW51Lm1vdXNlb3V0ID0gZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKFwidGVzdFwiKTsgfTtcblx0dGhpcy5zZXR0aW5nc01lbnUubW91c2Vkb3duID0gZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKFwidGVzdFwiKTsgfTtcblx0dGhpcy5zZXR0aW5nc01lbnUubW91c2V1cCA9IGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZyhcInRlc3RcIik7IH07XG5cdHRoaXMuc2V0dGluZ3NNZW51LmNsaWNrID0gZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKFwidGVzdFwiKTsgfTsqL1xufVxuXG5pbmhlcml0cyhTZXR0aW5nc1ZpZXcsIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcik7XG5FdmVudERpc3BhdGNoZXIuaW5pdChTZXR0aW5nc1ZpZXcpO1xuXG5TZXR0aW5nc1ZpZXcuQlVZX0NISVBTX0NMSUNLID0gXCJidXlDaGlwc0NsaWNrXCI7XG5TZXR0aW5nc1ZpZXcuQ0hFQ0tCT1hfQ0hBTkdFID0gXCJjaGVja2JveENoYW5nZVwiO1xuXG4vKipcbiAqIE9uIGJ1eSBjaGlwcyBidXR0b24gY2xpY2tlZC5cbiAqIEBtZXRob2Qgb25CdXlDaGlwc0NsaWNrXG4gKi9cblNldHRpbmdzVmlldy5wcm90b3R5cGUub25CdXlDaGlwc0NsaWNrID0gZnVuY3Rpb24oaW50ZXJhY3Rpb25fb2JqZWN0KSB7XG5cdGNvbnNvbGUubG9nKFwiYnV5IGNoaXBzIGNsaWNrXCIpO1xuXHR0aGlzLmRpc3BhdGNoRXZlbnQoU2V0dGluZ3NWaWV3LkJVWV9DSElQU19DTElDSyk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGNoZWNrYm94LlxuICogQG1ldGhvZCBjcmVhdGVNZW51U2V0dGluZ1xuICovXG5TZXR0aW5nc1ZpZXcucHJvdG90eXBlLmNyZWF0ZU1lbnVTZXR0aW5nID0gZnVuY3Rpb24oaWQsIHN0cmluZywgeSwgZGVmKSB7XG5cdHZhciBzZXR0aW5nID0gbmV3IFNldHRpbmdzQ2hlY2tib3godGhpcy5yZXNvdXJjZXMsIGlkLCBzdHJpbmcpO1xuXG5cdHNldHRpbmcueSA9IHk7XG5cdHNldHRpbmcueCA9IDE2O1xuXHR0aGlzLnNldHRpbmdzTWVudS5hZGRDaGlsZChzZXR0aW5nKTtcblxuXHRzZXR0aW5nLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy5vbkNoZWNrYm94Q2hhbmdlLCB0aGlzKVxuXG5cdHRoaXMuc2V0dGluZ3NbaWRdID0gc2V0dGluZztcblx0c2V0dGluZy5zZXRDaGVja2VkKGRlZik7XG59XG5cbi8qKlxuICogQ3JlYXRlIHNldHRpbmcuXG4gKiBAbWV0aG9kIGNyZWF0ZVNldHRpbmdcbiAqL1xuU2V0dGluZ3NWaWV3LnByb3RvdHlwZS5jcmVhdGVTZXR0aW5nID0gZnVuY3Rpb24oaWQsIHN0cmluZywgeSkge1xuXHR2YXIgc2V0dGluZyA9IG5ldyBTZXR0aW5nc0NoZWNrYm94KHRoaXMucmVzb3VyY2VzLCBpZCwgc3RyaW5nKTtcblxuXHRzZXR0aW5nLnkgPSA1NDUgKyB5O1xuXHRzZXR0aW5nLnggPSA3MDA7XG5cdHRoaXMuYWRkQ2hpbGQoc2V0dGluZyk7XG5cblx0c2V0dGluZy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMub25DaGVja2JveENoYW5nZSwgdGhpcylcblxuXHR0aGlzLnNldHRpbmdzW2lkXSA9IHNldHRpbmc7XG59XG5cbi8qKlxuICogQ2hlY2tib3ggY2hhbmdlLlxuICogQG1ldGhvZCBvbkNoZWNrYm94Q2hhbmdlXG4gKi9cblNldHRpbmdzVmlldy5wcm90b3R5cGUub25DaGVja2JveENoYW5nZSA9IGZ1bmN0aW9uKGNoZWNrYm94KSB7XG5cdGlmIChjaGVja2JveC5pZCA9PSBcInBsYXlBbmltYXRpb25zXCIpIHtcblx0XHR0aGlzLnZpZXdDb25maWcuc2V0UGxheUFuaW1hdGlvbnMoY2hlY2tib3guZ2V0Q2hlY2tlZCgpKTtcblx0XHRjb25zb2xlLmxvZyhcImFuaW1zIGNoYW5nZWQuLlwiKTtcblx0fVxuXG5cdHRoaXMuZGlzcGF0Y2hFdmVudChTZXR0aW5nc1ZpZXcuQ0hFQ0tCT1hfQ0hBTkdFLCB7XG5cdFx0Y2hlY2tib3hJZDogY2hlY2tib3guaWQsXG5cdFx0Y2hlY2tlZDogY2hlY2tib3guZ2V0Q2hlY2tlZCgpXG5cdH0pO1xufVxuXG4vKipcbiAqIFNldHRpbmdzIGJ1dHRvbiBjbGljay5cbiAqIEBtZXRob2Qgb25TZXR0aW5nc0J1dHRvbkNsaWNrXG4gKi9cblNldHRpbmdzVmlldy5wcm90b3R5cGUub25TZXR0aW5nc0J1dHRvbkNsaWNrID0gZnVuY3Rpb24oaW50ZXJhY3Rpb25fb2JqZWN0KSB7XG5cdGNvbnNvbGUubG9nKFwiU2V0dGluZ3NWaWV3LnByb3RvdHlwZS5vblNldHRpbmdzQnV0dG9uQ2xpY2tcIik7XG5cdHRoaXMuc2V0dGluZ3NNZW51LnZpc2libGUgPSAhdGhpcy5zZXR0aW5nc01lbnUudmlzaWJsZTtcblxuXHRpZiAodGhpcy5zZXR0aW5nc01lbnUudmlzaWJsZSkge1xuXHRcdHRoaXMuc3RhZ2UubW91c2Vkb3duID0gdGhpcy5zdGFnZS50b3VjaHN0YXJ0ID0gdGhpcy5vblN0YWdlTW91c2VEb3duLmJpbmQodGhpcyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5zdGFnZS5tb3VzZWRvd24gPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogU3RhZ2UgbW91c2UgZG93bi5cbiAqIEBtZXRob2Qgb25TdGFnZU1vdXNlRG93blxuICovXG5TZXR0aW5nc1ZpZXcucHJvdG90eXBlLm9uU3RhZ2VNb3VzZURvd24gPSBmdW5jdGlvbihpbnRlcmFjdGlvbl9vYmplY3QpIHtcblx0Y29uc29sZS5sb2coXCJTZXR0aW5nc1ZpZXcucHJvdG90eXBlLm9uU3RhZ2VNb3VzZURvd25cIik7XG5cdGlmICgodGhpcy5oaXRUZXN0KHRoaXMuc2V0dGluZ3NNZW51LCBpbnRlcmFjdGlvbl9vYmplY3QpKSB8fCAodGhpcy5oaXRUZXN0KHRoaXMuc2V0dGluZ3NCdXR0b24sIGludGVyYWN0aW9uX29iamVjdCkpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dGhpcy5zdGFnZS5tb3VzZWRvd24gPSBudWxsO1xuXHR0aGlzLnNldHRpbmdzTWVudS52aXNpYmxlID0gZmFsc2U7XG59XG5cbi8qKlxuICogSGl0IHRlc3QuXG4gKiBAbWV0aG9kIGhpdFRlc3RcbiAqL1xuU2V0dGluZ3NWaWV3LnByb3RvdHlwZS5oaXRUZXN0ID0gZnVuY3Rpb24ob2JqZWN0LCBpbnRlcmFjdGlvbl9vYmplY3QpIHtcblx0aWYgKChpbnRlcmFjdGlvbl9vYmplY3QuZ2xvYmFsLnggPiBvYmplY3QuZ2V0Qm91bmRzKCkueCkgJiYgKGludGVyYWN0aW9uX29iamVjdC5nbG9iYWwueCA8IChvYmplY3QuZ2V0Qm91bmRzKCkueCArIG9iamVjdC5nZXRCb3VuZHMoKS53aWR0aCkpICYmXG5cdFx0KGludGVyYWN0aW9uX29iamVjdC5nbG9iYWwueSA+IG9iamVjdC5nZXRCb3VuZHMoKS55KSAmJiAoaW50ZXJhY3Rpb25fb2JqZWN0Lmdsb2JhbC55IDwgKG9iamVjdC5nZXRCb3VuZHMoKS55ICsgb2JqZWN0LmdldEJvdW5kcygpLmhlaWdodCkpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJlc2V0LlxuICogQG1ldGhvZCBjbGVhclxuICovXG5TZXR0aW5nc1ZpZXcucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuYnV5Q2hpcHNCdXR0b24uZW5hYmxlZCA9IHRydWU7XG5cdHRoaXMuc2V0VmlzaWJsZUJ1dHRvbnMoW10pO1xuXG5cdHRoaXMuc2V0Q2hlY2tib3hDaGVja2VkKENoZWNrYm94TWVzc2FnZS5BVVRPX1BPU1RfQkxJTkRTLCBmYWxzZSk7XG5cdHRoaXMuc2V0Q2hlY2tib3hDaGVja2VkKENoZWNrYm94TWVzc2FnZS5BVVRPX01VQ0tfTE9TSU5HLCBmYWxzZSk7XG5cdHRoaXMuc2V0Q2hlY2tib3hDaGVja2VkKENoZWNrYm94TWVzc2FnZS5TSVRPVVRfTkVYVCwgZmFsc2UpO1xuXG5cdHRoaXMuc2V0dGluZ3NNZW51LnZpc2libGUgPSBmYWxzZTtcblx0aWYgKHRoaXMuc2V0dGluZ3NNZW51LnZpc2libGUpXG5cdFx0dGhpcy5zdGFnZS5tb3VzZWRvd24gPSBudWxsO1xufVxuXG4vKipcbiAqIFNldCB2aXNpYmxlIGJ1dHRvbnMuXG4gKiBAbWV0aG9kIHNldFZpc2libGVCdXR0b25zXG4gKi9cblNldHRpbmdzVmlldy5wcm90b3R5cGUuc2V0VmlzaWJsZUJ1dHRvbnMgPSBmdW5jdGlvbihidXR0b25zKSB7XG5cdHRoaXMuYnV5Q2hpcHNCdXR0b24udmlzaWJsZSA9IGJ1dHRvbnMuaW5kZXhPZihCdXR0b25EYXRhLkJVWV9DSElQUykgIT0gLTE7XG5cdHRoaXMuc2V0dGluZ3NbQ2hlY2tib3hNZXNzYWdlLkFVVE9fUE9TVF9CTElORFNdLnZpc2libGUgPSBidXR0b25zLmluZGV4T2YoQ2hlY2tib3hNZXNzYWdlLkFVVE9fUE9TVF9CTElORFMpID49IDA7XG5cdHRoaXMuc2V0dGluZ3NbQ2hlY2tib3hNZXNzYWdlLlNJVE9VVF9ORVhUXS52aXNpYmxlID0gYnV0dG9ucy5pbmRleE9mKENoZWNrYm94TWVzc2FnZS5TSVRPVVRfTkVYVCkgPj0gMDtcblxuXHR2YXIgeXAgPSA1NDM7XG5cblx0aWYgKHRoaXMuYnV5Q2hpcHNCdXR0b24udmlzaWJsZSkge1xuXHRcdHRoaXMuYnV5Q2hpcHNCdXR0b24ueSA9IHlwO1xuXHRcdHlwICs9IDM1O1xuXHR9IGVsc2Uge1xuXHRcdHlwICs9IDI7XG5cdH1cblxuXHRpZiAodGhpcy5zZXR0aW5nc1tDaGVja2JveE1lc3NhZ2UuQVVUT19QT1NUX0JMSU5EU10udmlzaWJsZSkge1xuXHRcdHRoaXMuc2V0dGluZ3NbQ2hlY2tib3hNZXNzYWdlLkFVVE9fUE9TVF9CTElORFNdLnkgPSB5cDtcblx0XHR5cCArPSAyNTtcblx0fVxuXG5cdGlmICh0aGlzLnNldHRpbmdzW0NoZWNrYm94TWVzc2FnZS5TSVRPVVRfTkVYVF0udmlzaWJsZSkge1xuXHRcdHRoaXMuc2V0dGluZ3NbQ2hlY2tib3hNZXNzYWdlLlNJVE9VVF9ORVhUXS55ID0geXA7XG5cdFx0eXAgKz0gMjU7XG5cdH1cbn1cblxuLyoqXG4gKiBTZXQgY2hlY2tib3ggc3RhdGUuXG4gKiBAbWV0aG9kIHNldENoZWNrYm94Q2hlY2tlZFxuICovXG5TZXR0aW5nc1ZpZXcucHJvdG90eXBlLnNldENoZWNrYm94Q2hlY2tlZCA9IGZ1bmN0aW9uKGlkLCBjaGVja2VkKSB7XG5cdC8vY29uc29sZS5sb2coXCJzZXR0aW5nIGNoZWNrYm94IHN0YXRlIGZvcjogXCIgKyBpZCk7XG5cblx0dGhpcy5zZXR0aW5nc1tpZF0uc2V0Q2hlY2tlZChjaGVja2VkKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZXR0aW5nc1ZpZXc7IiwiLyoqXG4gKiBDbGllbnQuXG4gKiBAbW9kdWxlIGNsaWVudFxuICovXG5cbnZhciBQSVhJID0gcmVxdWlyZShcInBpeGkuanNcIik7XG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZShcInlhZWRcIik7XG52YXIgRGlhbG9nQnV0dG9uID0gcmVxdWlyZShcIi4vRGlhbG9nQnV0dG9uXCIpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xudmFyIEJ1dHRvbkRhdGEgPSByZXF1aXJlKFwiLi4vLi4vcHJvdG8vZGF0YS9CdXR0b25EYXRhXCIpO1xuXG4vKipcbiAqIFNob3cgdGFibGUgaW5mby5cbiAqIEBjbGFzcyBUYWJsZUluZm9WaWV3XG4gKi9cbmZ1bmN0aW9uIFRhYmxlSW5mb1ZpZXcodmlld0NvbmZpZywgcmVzb3VyY2VzKSB7XG5cdFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKHRoaXMpO1xuXG5cdHRoaXMudmlld0NvbmZpZyA9IHZpZXdDb25maWc7XG5cdHRoaXMucmVzb3VyY2VzID0gcmVzb3VyY2VzO1xuXG5cdHZhciBzdHlsZSA9IHtcblx0XHRmb250OiBcImJvbGQgMjRweCBUaW1lcyBOZXcgUm9tYW5cIixcblx0XHRmaWxsOiBcIiNmZmZmZmZcIixcblx0XHRkcm9wU2hhZG93OiB0cnVlLFxuXHRcdGRyb3BTaGFkb3dDb2xvcjogXCIjMDAwMDAwXCIsXG5cdFx0ZHJvcFNoYWRvd0Rpc3RhbmNlOiAyLFxuXHRcdHN0cm9rZTogXCIjMDAwMDAwXCIsXG5cdFx0c3Ryb2tlVGhpY2tuZXNzOiAyLFxuXHRcdHdvcmRXcmFwOiB0cnVlLFxuXHRcdHdvcmRXcmFwV2lkdGg6IDMwMFxuXHR9O1xuXG5cdHRoaXMudGFibGVJbmZvVGV4dCA9IG5ldyBQSVhJLlRleHQoXCI8VGFibGVJbmZvVGV4dD5cIiwgc3R5bGUpO1xuXHR0aGlzLnRhYmxlSW5mb1RleHQucG9zaXRpb24ueCA9IDM1NTtcblx0dGhpcy50YWJsZUluZm9UZXh0LnBvc2l0aW9uLnkgPSA1NDA7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy50YWJsZUluZm9UZXh0KTtcblxuXHR2YXIgc3R5bGUgPSB7XG5cdFx0Zm9udDogXCJib2xkIDI0cHggVGltZXMgTmV3IFJvbWFuXCIsXG5cdFx0ZmlsbDogXCIjZmZmZmZmXCIsXG5cdFx0YWxpZ246IFwiY2VudGVyXCJcblx0fTtcblxuXHR0aGlzLnByZVRvdXJuYW1lbnRJbmZvVGV4dCA9IG5ldyBQSVhJLlRleHQoXCI8UHJlVG91cm5hbWVudEluZm9UZXh0PlwiLCBzdHlsZSk7XG5cdHRoaXMucHJlVG91cm5hbWVudEluZm9UZXh0LnBvc2l0aW9uLnkgPSAzNjA7XG5cdC8vdGhpcy5wcmVUb3VybmFtZW50SW5mb1RleHQucG9zaXRpb24ueSA9IDI4MDtcblx0dGhpcy5wcmVUb3VybmFtZW50SW5mb1RleHQucG9zaXRpb24ueCA9IE1hdGgucm91bmQoOTYwIC0gMzAwKSAvIDI7XG5cdHRoaXMucHJlVG91cm5hbWVudEluZm9UZXh0LmFscGhhID0gLjI1O1xuXHR0aGlzLmFkZENoaWxkKHRoaXMucHJlVG91cm5hbWVudEluZm9UZXh0KTtcblxuXHR2YXIgc3R5bGUgPSB7XG5cdFx0Zm9udDogXCJib2xkIDEycHggQXJpYWxcIixcblx0XHRmaWxsOiBcIiNmZmZmZmZcIixcblx0XHRkcm9wU2hhZG93OiB0cnVlLFxuXHRcdGRyb3BTaGFkb3dDb2xvcjogXCIjMDAwMDAwXCIsXG5cdFx0ZHJvcFNoYWRvd0Rpc3RhbmNlOiAxLFxuXHRcdHN0cm9rZTogXCIjMDAwMDAwXCIsXG5cdFx0c3Ryb2tlVGhpY2tuZXNzOiAxLFxuXHR9O1xuXG5cdHRoaXMuaGFuZEluZm9UZXh0ID0gbmV3IFBJWEkuVGV4dChcIjxIYW5kSW5mb1RleHQ+XCIsIHN0eWxlKTtcblx0dGhpcy5oYW5kSW5mb1RleHQucG9zaXRpb24ueSA9IDEwO1xuXHR0aGlzLmhhbmRJbmZvVGV4dC5wb3NpdGlvbi54ID0gOTYwIC0gdGhpcy5oYW5kSW5mb1RleHQud2lkdGg7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5oYW5kSW5mb1RleHQpO1xuXG5cdHRoaXMuam9pbkJ1dHRvbiA9IG5ldyBEaWFsb2dCdXR0b24odGhpcy5yZXNvdXJjZXMpO1xuXHR0aGlzLmpvaW5CdXR0b24ucG9zaXRpb24ueCA9IDM1NTtcblx0dGhpcy5qb2luQnV0dG9uLnNldFRleHQoXCJKT0lOXCIpO1xuXHR0aGlzLmpvaW5CdXR0b24udmlzaWJsZSA9IGZhbHNlO1xuXHR0aGlzLmpvaW5CdXR0b24ub24oXCJjbGlja1wiLCB0aGlzLm9uQnV0dG9uQ2xpY2ssIHRoaXMpO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMuam9pbkJ1dHRvbik7XG5cblx0dGhpcy5sZWF2ZUJ1dHRvbiA9IG5ldyBEaWFsb2dCdXR0b24odGhpcy5yZXNvdXJjZXMpO1xuXHR0aGlzLmxlYXZlQnV0dG9uLnBvc2l0aW9uLnggPSAzNTU7XG5cdHRoaXMubGVhdmVCdXR0b24uc2V0VGV4dChcIkxFQVZFXCIpO1xuXHR0aGlzLmxlYXZlQnV0dG9uLnZpc2libGUgPSBmYWxzZTtcblx0dGhpcy5sZWF2ZUJ1dHRvbi5vbihcImNsaWNrXCIsIHRoaXMub25CdXR0b25DbGljaywgdGhpcyk7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5sZWF2ZUJ1dHRvbik7XG59XG5cbmluaGVyaXRzKFRhYmxlSW5mb1ZpZXcsIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcik7XG5FdmVudERpc3BhdGNoZXIuaW5pdChUYWJsZUluZm9WaWV3KTtcblxuVGFibGVJbmZvVmlldy5CVVRUT05fQ0xJQ0sgPSBcImJ1dHRvbkNsaWNrXCI7XG5cbi8qKlxuICogU2V0IHRhYmxlIGluZm8gdGV4dC5cbiAqIEBtZXRob2Qgc2V0VGFibGVJbmZvVGV4dFxuICovXG5UYWJsZUluZm9WaWV3LnByb3RvdHlwZS5zZXRUYWJsZUluZm9UZXh0ID0gZnVuY3Rpb24ocykge1xuXHRpZiAoIXMpXG5cdFx0cyA9IFwiXCI7XG5cblx0dGhpcy50YWJsZUluZm9UZXh0LnNldFRleHQocyk7XG5cdHRoaXMuam9pbkJ1dHRvbi5wb3NpdGlvbi55ID0gdGhpcy50YWJsZUluZm9UZXh0LnBvc2l0aW9uLnkgKyB0aGlzLnRhYmxlSW5mb1RleHQuaGVpZ2h0ICsgNTtcblx0dGhpcy5sZWF2ZUJ1dHRvbi5wb3NpdGlvbi55ID0gdGhpcy50YWJsZUluZm9UZXh0LnBvc2l0aW9uLnkgKyB0aGlzLnRhYmxlSW5mb1RleHQuaGVpZ2h0ICsgNTtcbn1cblxuLyoqXG4gKiBTZXQgcHJlIHRvdXJuYW1lbnQgaW5mbyB0ZXh0LlxuICogQG1ldGhvZCBzZXRQcmVUb3VybmFtZW50SW5mb1RleHRcbiAqL1xuVGFibGVJbmZvVmlldy5wcm90b3R5cGUuc2V0UHJlVG91cm5hbWVudEluZm9UZXh0ID0gZnVuY3Rpb24ocykge1xuXHRpZiAoIXMpXG5cdFx0cyA9IFwiXCI7XG5cblx0dGhpcy5wcmVUb3VybmFtZW50SW5mb1RleHQuc2V0VGV4dChzKTtcblx0dGhpcy5wcmVUb3VybmFtZW50SW5mb1RleHQucG9zaXRpb24ueCA9IDk2MCAvIDIgLSB0aGlzLnByZVRvdXJuYW1lbnRJbmZvVGV4dC53aWR0aCAvIDI7XG59XG5cbi8qKlxuICogSm9pbiBidXR0b24uXG4gKiBAbWV0aG9kIHNldEpvaW5CdXR0b25WaXNpYmxlXG4gKi9cblRhYmxlSW5mb1ZpZXcucHJvdG90eXBlLnNldEpvaW5CdXR0b25WaXNpYmxlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0dGhpcy5qb2luQnV0dG9uLnZpc2libGUgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBKb2luIGJ1dHRvblxuICogQG1ldGhvZCBzZXRMZWF2ZUJ1dHRvblZpc2libGVcbiAqL1xuVGFibGVJbmZvVmlldy5wcm90b3R5cGUuc2V0TGVhdmVCdXR0b25WaXNpYmxlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0dGhpcy5sZWF2ZUJ1dHRvbi52aXNpYmxlID0gdmFsdWU7XG59XG5cbi8qKlxuICogU2V0IGhhbmQgaW5mbyB0ZXh0LlxuICogQG1ldGhvZCBzZXRUYWJsZUluZm9UZXh0XG4gKi9cblRhYmxlSW5mb1ZpZXcucHJvdG90eXBlLnNldEhhbmRJbmZvVGV4dCA9IGZ1bmN0aW9uKHMpIHtcblx0aWYgKCFzKVxuXHRcdHMgPSBcIlwiO1xuXG5cdHRoaXMuaGFuZEluZm9UZXh0LnNldFRleHQocyk7XG5cdHRoaXMuaGFuZEluZm9UZXh0LnVwZGF0ZVRyYW5zZm9ybSgpO1xuXHR0aGlzLmhhbmRJbmZvVGV4dC5wb3NpdGlvbi54ID0gOTYwIC0gdGhpcy5oYW5kSW5mb1RleHQud2lkdGggLSAxMDtcbn1cblxuLyoqXG4gKiBDbGVhci5cbiAqIEBtZXRob2QgY2xlYXJcbiAqL1xuVGFibGVJbmZvVmlldy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0dGhpcy50YWJsZUluZm9UZXh0LnNldFRleHQoXCJcIik7XG5cdHRoaXMuaGFuZEluZm9UZXh0LnNldFRleHQoXCJcIik7XG5cdHRoaXMucHJlVG91cm5hbWVudEluZm9UZXh0LnNldFRleHQoXCJcIik7XG5cdHRoaXMuam9pbkJ1dHRvbi52aXNpYmxlID0gZmFsc2U7XG5cdHRoaXMubGVhdmVCdXR0b24udmlzaWJsZSA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEJ1dHRvbiBjbGlja1xuICogQG1ldGhvZCBvbkJ1dHRvbkNsaWNrXG4gKiBAcHJpdmF0ZVxuICovXG5UYWJsZUluZm9WaWV3LnByb3RvdHlwZS5vbkJ1dHRvbkNsaWNrID0gZnVuY3Rpb24oZSkge1xuXHR0aGlzLmpvaW5CdXR0b24udmlzaWJsZSA9IGZhbHNlO1xuXHR0aGlzLmxlYXZlQnV0dG9uLnZpc2libGUgPSBmYWxzZTtcblxuXHR2YXIgZXYgPSB7XG5cdFx0dHlwZTogVGFibGVJbmZvVmlldy5CVVRUT05fQ0xJQ0tcblx0fTtcblxuXHRpZiAoZS50YXJnZXQgPT0gdGhpcy5qb2luQnV0dG9uKVxuXHRcdGV2LmJ1dHRvbiA9IEJ1dHRvbkRhdGEuSk9JTl9UT1VSTkFNRU5UO1xuXG5cdGlmIChlLnRhcmdldCA9PSB0aGlzLmxlYXZlQnV0dG9uKVxuXHRcdGV2LmJ1dHRvbiA9IEJ1dHRvbkRhdGEuTEVBVkVfVE9VUk5BTUVOVDtcblxuXHRjb25zb2xlLmxvZyhcImJ1dHRvbiBjbGlja1wiKTtcblx0dGhpcy50cmlnZ2VyKGV2KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUYWJsZUluZm9WaWV3OyIsIi8qKlxuICogQ2xpZW50LlxuICogQG1vZHVsZSBjbGllbnRcbiAqL1xuXG52YXIgUElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xudmFyIFRXRUVOID0gcmVxdWlyZShcInR3ZWVuLmpzXCIpO1xudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoXCJ5YWVkXCIpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xuXG4vKipcbiAqIEEgdGltZXIgdmlld1xuICogQGNsYXNzIFRpbWVyVmlld1xuICovXG5mdW5jdGlvbiBUaW1lclZpZXcodmlld0NvbmZpZywgcmVzb3VyY2VzKSB7XG5cdFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKHRoaXMpO1xuXG5cdHRoaXMucmVzb3VyY2VzID0gcmVzb3VyY2VzXG5cblx0dGhpcy50aW1lckNsaXAgPSBuZXcgUElYSS5TcHJpdGUodGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZShcInRpbWVyQmFja2dyb3VuZFwiKSk7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy50aW1lckNsaXApO1xuXG5cblx0dGhpcy5jYW52YXMgPSBuZXcgUElYSS5HcmFwaGljcygpO1xuXHR0aGlzLmNhbnZhcy54ID0gdGhpcy50aW1lckNsaXAud2lkdGggKiAwLjU7XG5cdHRoaXMuY2FudmFzLnkgPSB0aGlzLnRpbWVyQ2xpcC5oZWlnaHQgKiAwLjU7XG5cdHRoaXMudGltZXJDbGlwLmFkZENoaWxkKHRoaXMuY2FudmFzKTtcblxuXHR0aGlzLnRpbWVyQ2xpcC52aXNpYmxlID0gZmFsc2U7XG5cblx0dGhpcy50d2VlbiA9IG51bGw7XG5cblx0Ly90aGlzLnNob3dQZXJjZW50KDMwKTtcbn1cblxuaW5oZXJpdHMoVGltZXJWaWV3LCBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIpO1xuRXZlbnREaXNwYXRjaGVyLmluaXQoVGltZXJWaWV3KTtcblxuLyoqXG4gKiBIaWRlLlxuICogQG1ldGhvZCBoaWRlXG4gKi9cblRpbWVyVmlldy5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnRpbWVyQ2xpcC52aXNpYmxlID0gZmFsc2U7XG5cdHRoaXMuc3RvcCgpO1xufVxuXG4vKipcbiAqIFNob3cuXG4gKiBAbWV0aG9kIHNob3dcbiAqL1xuVGltZXJWaWV3LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oc2VhdEluZGV4KSB7XG5cblx0dGhpcy50aW1lckNsaXAudmlzaWJsZSA9IHRydWU7XG5cblx0dmFyIHNlYXRQb3NpdGlvbiA9IHRoaXMucmVzb3VyY2VzLmdldFBvaW50KFwic2VhdFBvc2l0aW9uXCIgKyBzZWF0SW5kZXgpO1xuXHR2YXIgdGltZXJPZmZzZXQgPSB0aGlzLnJlc291cmNlcy5nZXRQb2ludChcInRpbWVyT2Zmc2V0XCIpO1xuXG5cdHRoaXMudGltZXJDbGlwLnggPSBzZWF0UG9zaXRpb24ueCArIHRpbWVyT2Zmc2V0Lng7XG5cdHRoaXMudGltZXJDbGlwLnkgPSBzZWF0UG9zaXRpb24ueSArIHRpbWVyT2Zmc2V0Lnk7XG5cblx0dGhpcy5zdG9wKCk7XG5cbn1cblxuLyoqXG4gKiBTdG9wLlxuICogQG1ldGhvZCBzdG9wXG4gKi9cblRpbWVyVmlldy5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKHNlYXRJbmRleCkge1xuXHRpZiAodGhpcy50d2VlbiAhPSBudWxsKVxuXHRcdHRoaXMudHdlZW4uc3RvcCgpO1xuXG59XG5cbi8qKlxuICogQ291bnRkb3duLlxuICogQG1ldGhvZCBjb3VudGRvd25cbiAqL1xuVGltZXJWaWV3LnByb3RvdHlwZS5jb3VudGRvd24gPSBmdW5jdGlvbih0b3RhbFRpbWUsIHRpbWVMZWZ0KSB7XG5cdHRoaXMuc3RvcCgpO1xuXG5cdHRvdGFsVGltZSAqPSAxMDAwO1xuXHR0aW1lTGVmdCAqPSAxMDAwO1xuXG5cdHZhciB0aW1lID0gRGF0ZS5ub3coKTtcblx0dGhpcy5zdGFydEF0ID0gdGltZSArIHRpbWVMZWZ0IC0gdG90YWxUaW1lO1xuXHR0aGlzLnN0b3BBdCA9IHRpbWUgKyB0aW1lTGVmdDtcblxuXHR0aGlzLnR3ZWVuID0gbmV3IFRXRUVOLlR3ZWVuKHtcblx0XHRcdHRpbWU6IHRpbWVcblx0XHR9KVxuXHRcdC50byh7XG5cdFx0XHR0aW1lOiB0aGlzLnN0b3BBdFxuXHRcdH0sIHRpbWVMZWZ0KVxuXHRcdC5vblVwZGF0ZSh0aGlzLm9uVXBkYXRlLmJpbmQodGhpcykpXG5cdFx0Lm9uQ29tcGxldGUodGhpcy5vbkNvbXBsZXRlLmJpbmQodGhpcykpXG5cdFx0LnN0YXJ0KCk7XG5cbn1cblxuLyoqXG4gKiBPbiB0d2VlbiB1cGRhdGUuXG4gKiBAbWV0aG9kIG9uVXBkYXRlXG4gKi9cblRpbWVyVmlldy5wcm90b3R5cGUub25VcGRhdGUgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWUgPSBEYXRlLm5vdygpO1xuXHR2YXIgcGVyY2VudCA9IDEwMCAqICh0aW1lIC0gdGhpcy5zdGFydEF0KSAvICh0aGlzLnN0b3BBdCAtIHRoaXMuc3RhcnRBdCk7XG5cblx0Ly9cdGNvbnNvbGUubG9nKFwicCA9IFwiICsgcGVyY2VudCk7XG5cblx0dGhpcy5zaG93UGVyY2VudChwZXJjZW50KTtcbn1cblxuLyoqXG4gKiBPbiB0d2VlbiB1cGRhdGUuXG4gKiBAbWV0aG9kIG9uVXBkYXRlXG4gKi9cblRpbWVyVmlldy5wcm90b3R5cGUub25Db21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZSA9IERhdGUubm93KCk7XG5cdHZhciBwZXJjZW50ID0gMTAwO1xuXHR0aGlzLnNob3dQZXJjZW50KHBlcmNlbnQpO1xuXHR0aGlzLnR3ZWVuID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTaG93IHBlcmNlbnQuXG4gKiBAbWV0aG9kIHNob3dQZXJjZW50XG4gKi9cblRpbWVyVmlldy5wcm90b3R5cGUuc2hvd1BlcmNlbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRpZiAodmFsdWUgPCAwKVxuXHRcdHZhbHVlID0gMDtcblxuXHRpZiAodmFsdWUgPiAxMDApXG5cdFx0dmFsdWUgPSAxMDA7XG5cblx0dGhpcy5jYW52YXMuY2xlYXIoKTtcblxuXHR0aGlzLmNhbnZhcy5iZWdpbkZpbGwoMHhjMDAwMDApO1xuXHR0aGlzLmNhbnZhcy5kcmF3Q2lyY2xlKDAsIDAsIDEwKTtcblx0dGhpcy5jYW52YXMuZW5kRmlsbCgpO1xuXG5cdHRoaXMuY2FudmFzLmJlZ2luRmlsbCgweGZmZmZmZik7XG5cdHRoaXMuY2FudmFzLm1vdmVUbygwLCAwKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzMzsgaSsrKSB7XG5cdFx0dGhpcy5jYW52YXMubGluZVRvKFxuXHRcdFx0MTAgKiBNYXRoLmNvcyhpICogdmFsdWUgKiAyICogTWF0aC5QSSAvICgzMiAqIDEwMCkgLSBNYXRoLlBJIC8gMiksXG5cdFx0XHQxMCAqIE1hdGguc2luKGkgKiB2YWx1ZSAqIDIgKiBNYXRoLlBJIC8gKDMyICogMTAwKSAtIE1hdGguUEkgLyAyKVxuXHRcdCk7XG5cdH1cblxuXHR0aGlzLmNhbnZhcy5saW5lVG8oMCwgMCk7XG5cdHRoaXMuY2FudmFzLmVuZEZpbGwoKTtcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVyVmlldzsiLCIvKipcbiAqIFByb3RvY29sLlxuICogQG1vZHVsZSBwcm90b1xuICovXG5cbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKFwieWFlZFwiKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCJpbmhlcml0c1wiKTtcblxudmFyIEluaXRNZXNzYWdlID0gcmVxdWlyZShcIi4vbWVzc2FnZXMvSW5pdE1lc3NhZ2VcIik7XG52YXIgU3RhdGVDb21wbGV0ZU1lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9TdGF0ZUNvbXBsZXRlTWVzc2FnZVwiKTtcbnZhciBTZWF0SW5mb01lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9TZWF0SW5mb01lc3NhZ2VcIik7XG52YXIgQ29tbXVuaXR5Q2FyZHNNZXNzYWdlID0gcmVxdWlyZShcIi4vbWVzc2FnZXMvQ29tbXVuaXR5Q2FyZHNNZXNzYWdlXCIpO1xudmFyIFBvY2tldENhcmRzTWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL1BvY2tldENhcmRzTWVzc2FnZVwiKTtcbnZhciBTZWF0Q2xpY2tNZXNzYWdlID0gcmVxdWlyZShcIi4vbWVzc2FnZXMvU2VhdENsaWNrTWVzc2FnZVwiKTtcbnZhciBTaG93RGlhbG9nTWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL1Nob3dEaWFsb2dNZXNzYWdlXCIpO1xudmFyIEJ1dHRvbkNsaWNrTWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL0J1dHRvbkNsaWNrTWVzc2FnZVwiKTtcbnZhciBCdXR0b25zTWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL0J1dHRvbnNNZXNzYWdlXCIpO1xudmFyIERlbGF5TWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL0RlbGF5TWVzc2FnZVwiKTtcbnZhciBDbGVhck1lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9DbGVhck1lc3NhZ2VcIik7XG52YXIgRGVhbGVyQnV0dG9uTWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL0RlYWxlckJ1dHRvbk1lc3NhZ2VcIik7XG52YXIgQmV0TWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL0JldE1lc3NhZ2VcIik7XG52YXIgQmV0c1RvUG90TWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL0JldHNUb1BvdE1lc3NhZ2VcIik7XG5cbnZhciBBY3Rpb25NZXNzYWdlID0gcmVxdWlyZShcIi4vbWVzc2FnZXMvQWN0aW9uTWVzc2FnZVwiKTtcbnZhciBDaGF0TWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL0NoYXRNZXNzYWdlXCIpO1xudmFyIENoZWNrYm94TWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL0NoZWNrYm94TWVzc2FnZVwiKTtcbnZhciBGYWRlVGFibGVNZXNzYWdlID0gcmVxdWlyZShcIi4vbWVzc2FnZXMvRmFkZVRhYmxlTWVzc2FnZVwiKTtcbnZhciBIYW5kSW5mb01lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9IYW5kSW5mb01lc3NhZ2VcIik7XG52YXIgSW50ZXJmYWNlU3RhdGVNZXNzYWdlID0gcmVxdWlyZShcIi4vbWVzc2FnZXMvSW50ZXJmYWNlU3RhdGVNZXNzYWdlXCIpO1xudmFyIFBheU91dE1lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9QYXlPdXRNZXNzYWdlXCIpO1xudmFyIFBvdE1lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9Qb3RNZXNzYWdlXCIpO1xudmFyIFByZXNldEJ1dHRvbkNsaWNrTWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL1ByZXNldEJ1dHRvbkNsaWNrTWVzc2FnZVwiKTtcbnZhciBQcmVzZXRCdXR0b25zTWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL1ByZXNldEJ1dHRvbnNNZXNzYWdlXCIpO1xudmFyIFByZVRvdXJuYW1lbnRJbmZvTWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL1ByZVRvdXJuYW1lbnRJbmZvTWVzc2FnZVwiKTtcbnZhciBUYWJsZUJ1dHRvbkNsaWNrTWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL1RhYmxlQnV0dG9uQ2xpY2tNZXNzYWdlXCIpO1xudmFyIFRhYmxlQnV0dG9uc01lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9UYWJsZUJ1dHRvbnNNZXNzYWdlXCIpO1xudmFyIFRhYmxlSW5mb01lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9UYWJsZUluZm9NZXNzYWdlXCIpO1xudmFyIFRlc3RDYXNlUmVxdWVzdE1lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9UZXN0Q2FzZVJlcXVlc3RNZXNzYWdlXCIpO1xudmFyIFRpbWVyTWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL1RpbWVyTWVzc2FnZVwiKTtcbnZhciBUb3VybmFtZW50UmVzdWx0TWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL1RvdXJuYW1lbnRSZXN1bHRNZXNzYWdlXCIpO1xudmFyIEZvbGRDYXJkc01lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy9Gb2xkQ2FyZHNNZXNzYWdlXCIpO1xuXG4vKipcbiAqIEEgcHJvdG9jb2wgY29ubmVjdGlvbiB3aXRoIGFuIHVuZGVybHlpbmcgY29ubmVjdGlvbi5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIHdheXMgdG8gbGl0ZW4gZm9yIGNvbm5lY3Rpb25zLCB0aGUgZmlyc3Qgb25lIGFuZCBtb3N0IHN0cmFpZ2h0XG4gKiBmb3J3YXJkIGlzIHRoZSBhZGRNZXNzYWdlSGFuZGxlciwgd2hpY2ggcmVnaXN0ZXJzIGEgbGlzdGVuZXIgZm9yIGFcbiAqIHBhcnRpY3VsYXIgbmV0d29yayBtZXNzYWdlLiBUaGUgZmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIHRoZSBtZXNzYWdlXG4gKiBjbGFzcyB0byBsaXN0ZW4gZm9yOlxuICpcbiAqICAgICBmdW5jdGlvbiBvblNlYXRJbmZvTWVzc2FnZShtKSB7XG4gKiAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBzZWF0IGlzIGFjdGl2ZS5cbiAqICAgICAgICAgbS5pc0FjdGl2ZSgpO1xuICogICAgIH1cbiAqXG4gKiAgICAgcHJvdG9Db25uZWN0aW9uLmFkZE1lc3NhZ2VIYW5kbGVyKFNlYXRJbmZvTWVzc2FnZSwgb25TZWF0SW5mb01lc3NhZ2UpO1xuICpcbiAqIFRoZSBzZWNvbmQgbWV0aG9kIGlzIHRvIGxpc3RlbiB0byB0aGUgUHJvdG9Db25uZWN0aW9uLk1FU1NBR0UgZGlzcGF0Y2hlZFxuICogYnkgdGhlIGluc3RhbmNlIG9mIHRoZSBQcm90b0Nvbm5lY3Rpb24uIEluIHRoaXMgY2FzZSwgdGhlIGxpc3RlbmVyXG4gKiB3aWxsIGJlIGNhbGxlZCBmb3IgYWxsIG1lc3NhZ2VzIHJlY2VpdmVkIG9uIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqICAgICBmdW5jdGlvbiBvbk1lc3NhZ2UoZSkge1xuICogICAgICAgICB2YXIgbWVzc2FnZT1lLm1lc3NhZ2U7XG4gKlxuICogICAgICAgICAvLyBJcyBpdCBhIFNlYXRJbmZvTWVzc2FnZT9cbiAqICAgICAgICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBTZWF0SW5mb01lc3NhZ2UpIHtcbiAqICAgICAgICAgICAgIC8vIC4uLlxuICogICAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqICAgICBwcm90b0Nvbm5lY3Rpb24uYWRkTWVzc2FnZUhhbmRsZXIoU2VhdEluZm9NZXNzYWdlLCBvbk1lc3NhZ2UpO1xuICpcbiAqIFRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb24gc2hvdWxkIGJlIGFuIG9iamVjdCB0aGF0IGltcGxlbWVudHMgYW4gXCJpbnRlcmZhY2VcIlxuICogb2YgYSBjb25uZWN0aW9uLiBJdCBpcyBub3QgYW4gaW50ZXJmYWNlIHBlciBzZSwgc2luY2UgSmF2YVNjcmlwdCBkb2Vzbid0IHN1cHBvcnRcbiAqIGl0LiBBbnl3YXksIHRoZSBzaWduYXR1cmUgb2YgdGhpcyBpbnRlcmZhY2UsIGlzIHRoYXQgdGhlIGNvbm5lY3Rpb24gb2JqZWN0XG4gKiBzaG91bGQgaGF2ZSBhIGBzZW5kYCBtZXRob2Qgd2hpY2ggcmVjZWl2ZXMgYSBvYmplY3QgdG8gYmUgc2VuZC4gSXQgc2hvdWxkIGFsc29cbiAqIGRpc3BhdGNoIFwibWVzc2FnZVwiIGV2ZW50cyBhcyBtZXNzYWdlcyBhcmUgcmVjZWl2ZWQsIGFuZCBcImNsb3NlXCIgZXZlbnRzIGlmIHRoZVxuICogY29ubmVjdGlvbiBpcyBjbG9zZWQgYnkgdGhlIHJlbW90ZSBwYXJ0eS5cbiAqXG4gKiBAY2xhc3MgUHJvdG9Db25uZWN0aW9uXG4gKiBAZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGNvbm5lY3Rpb24gVGhlIHVuZGVybHlpbmcgY29ubmVjdGlvbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIFByb3RvQ29ubmVjdGlvbihjb25uZWN0aW9uKSB7XG5cdEV2ZW50RGlzcGF0Y2hlci5jYWxsKHRoaXMpO1xuXG5cdHRoaXMubG9nTWVzc2FnZXMgPSBmYWxzZTtcblx0dGhpcy5tZXNzYWdlRGlzcGF0Y2hlciA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcblx0dGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcblx0dGhpcy5jb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMub25Db25uZWN0aW9uTWVzc2FnZSwgdGhpcyk7XG5cdHRoaXMuY29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgdGhpcy5vbkNvbm5lY3Rpb25DbG9zZSwgdGhpcyk7XG59XG5cbmluaGVyaXRzKFByb3RvQ29ubmVjdGlvbiwgRXZlbnREaXNwYXRjaGVyKTtcblxuLyoqXG4gKiBUcmlnZ2VycyBpZiB0aGUgcmVtb3RlIHBhcnR5IGNsb3NlcyB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uLlxuICogQGV2ZW50IFByb3RvQ29ubmVjdGlvbi5DTE9TRVxuICovXG5Qcm90b0Nvbm5lY3Rpb24uQ0xPU0UgPSBcImNsb3NlXCI7XG5cbi8qKlxuICogVHJpZ2dlcnMgd2hlbiB3ZSByZWNlaXZlIGEgbWVzc2FnZSBmcm9tIHRoZSByZW1vdGUgcGFydHkuXG4gKiBAZXZlbnQgUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VcbiAqIEBwYXJhbSB7T2JqZWN0fSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRoYXQgd2FzIHJlY2VpdmVkLlxuICovXG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRSA9IFwibWVzc2FnZVwiO1xuXG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFUyA9IHt9O1xuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVNbSW5pdE1lc3NhZ2UuVFlQRV0gPSBJbml0TWVzc2FnZTtcblByb3RvQ29ubmVjdGlvbi5NRVNTQUdFX1RZUEVTW1N0YXRlQ29tcGxldGVNZXNzYWdlLlRZUEVdID0gU3RhdGVDb21wbGV0ZU1lc3NhZ2U7XG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tTZWF0SW5mb01lc3NhZ2UuVFlQRV0gPSBTZWF0SW5mb01lc3NhZ2U7XG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tDb21tdW5pdHlDYXJkc01lc3NhZ2UuVFlQRV0gPSBDb21tdW5pdHlDYXJkc01lc3NhZ2U7XG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tQb2NrZXRDYXJkc01lc3NhZ2UuVFlQRV0gPSBQb2NrZXRDYXJkc01lc3NhZ2U7XG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tTZWF0Q2xpY2tNZXNzYWdlLlRZUEVdID0gU2VhdENsaWNrTWVzc2FnZTtcblByb3RvQ29ubmVjdGlvbi5NRVNTQUdFX1RZUEVTW1Nob3dEaWFsb2dNZXNzYWdlLlRZUEVdID0gU2hvd0RpYWxvZ01lc3NhZ2U7XG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tCdXR0b25DbGlja01lc3NhZ2UuVFlQRV0gPSBCdXR0b25DbGlja01lc3NhZ2U7XG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tCdXR0b25zTWVzc2FnZS5UWVBFXSA9IEJ1dHRvbnNNZXNzYWdlO1xuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVNbRGVsYXlNZXNzYWdlLlRZUEVdID0gRGVsYXlNZXNzYWdlO1xuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVNbQ2xlYXJNZXNzYWdlLlRZUEVdID0gQ2xlYXJNZXNzYWdlO1xuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVNbRGVhbGVyQnV0dG9uTWVzc2FnZS5UWVBFXSA9IERlYWxlckJ1dHRvbk1lc3NhZ2U7XG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tCZXRNZXNzYWdlLlRZUEVdID0gQmV0TWVzc2FnZTtcblByb3RvQ29ubmVjdGlvbi5NRVNTQUdFX1RZUEVTW0JldHNUb1BvdE1lc3NhZ2UuVFlQRV0gPSBCZXRzVG9Qb3RNZXNzYWdlO1xuXG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tBY3Rpb25NZXNzYWdlLlRZUEVdID0gQWN0aW9uTWVzc2FnZTtcblByb3RvQ29ubmVjdGlvbi5NRVNTQUdFX1RZUEVTW0NoYXRNZXNzYWdlLlRZUEVdID0gQ2hhdE1lc3NhZ2U7XG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tDaGVja2JveE1lc3NhZ2UuVFlQRV0gPSBDaGVja2JveE1lc3NhZ2U7XG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tGYWRlVGFibGVNZXNzYWdlLlRZUEVdID0gRmFkZVRhYmxlTWVzc2FnZTtcblByb3RvQ29ubmVjdGlvbi5NRVNTQUdFX1RZUEVTW0hhbmRJbmZvTWVzc2FnZS5UWVBFXSA9IEhhbmRJbmZvTWVzc2FnZTtcblByb3RvQ29ubmVjdGlvbi5NRVNTQUdFX1RZUEVTW0ludGVyZmFjZVN0YXRlTWVzc2FnZS5UWVBFXSA9IEludGVyZmFjZVN0YXRlTWVzc2FnZTtcblByb3RvQ29ubmVjdGlvbi5NRVNTQUdFX1RZUEVTW1BheU91dE1lc3NhZ2UuVFlQRV0gPSBQYXlPdXRNZXNzYWdlO1xuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVNbUG90TWVzc2FnZS5UWVBFXSA9IFBvdE1lc3NhZ2U7XG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tQcmVzZXRCdXR0b25DbGlja01lc3NhZ2UuVFlQRV0gPSBQcmVzZXRCdXR0b25DbGlja01lc3NhZ2U7XG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tQcmVzZXRCdXR0b25zTWVzc2FnZS5UWVBFXSA9IFByZXNldEJ1dHRvbnNNZXNzYWdlO1xuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVNbUHJlVG91cm5hbWVudEluZm9NZXNzYWdlLlRZUEVdID0gUHJlVG91cm5hbWVudEluZm9NZXNzYWdlO1xuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVNbVGFibGVCdXR0b25DbGlja01lc3NhZ2UuVFlQRV0gPSBUYWJsZUJ1dHRvbkNsaWNrTWVzc2FnZTtcblByb3RvQ29ubmVjdGlvbi5NRVNTQUdFX1RZUEVTW1RhYmxlQnV0dG9uc01lc3NhZ2UuVFlQRV0gPSBUYWJsZUJ1dHRvbnNNZXNzYWdlO1xuUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVNbVGFibGVJbmZvTWVzc2FnZS5UWVBFXSA9IFRhYmxlSW5mb01lc3NhZ2U7XG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tUZXN0Q2FzZVJlcXVlc3RNZXNzYWdlLlRZUEVdID0gVGVzdENhc2VSZXF1ZXN0TWVzc2FnZTtcblByb3RvQ29ubmVjdGlvbi5NRVNTQUdFX1RZUEVTW1RpbWVyTWVzc2FnZS5UWVBFXSA9IFRpbWVyTWVzc2FnZTtcblByb3RvQ29ubmVjdGlvbi5NRVNTQUdFX1RZUEVTW1RvdXJuYW1lbnRSZXN1bHRNZXNzYWdlLlRZUEVdID0gVG91cm5hbWVudFJlc3VsdE1lc3NhZ2U7XG5Qcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1tGb2xkQ2FyZHNNZXNzYWdlLlRZUEVdID0gRm9sZENhcmRzTWVzc2FnZTtcblxuLyoqXG4gKiBBZGQgbWVzc2FnZSBoYW5kbGVyLlxuICogQG1ldGhvZCBhZGRNZXNzYWdlSGFuZGxlclxuICovXG5Qcm90b0Nvbm5lY3Rpb24ucHJvdG90eXBlLmFkZE1lc3NhZ2VIYW5kbGVyID0gZnVuY3Rpb24obWVzc2FnZVR5cGUsIGhhbmRsZXIsIHNjb3BlKSB7XG5cdGlmIChtZXNzYWdlVHlwZS5oYXNPd25Qcm9wZXJ0eShcIlRZUEVcIikpXG5cdFx0bWVzc2FnZVR5cGUgPSBtZXNzYWdlVHlwZS5UWVBFO1xuXG5cdHRoaXMubWVzc2FnZURpc3BhdGNoZXIub24obWVzc2FnZVR5cGUsIGhhbmRsZXIsIHNjb3BlKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgbWVzc2FnZSBoYW5kbGVyLlxuICogQG1ldGhvZCByZW1vdmVNZXNzYWdlSGFuZGxlclxuICovXG5Qcm90b0Nvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZU1lc3NhZ2VIYW5kbGVyID0gZnVuY3Rpb24obWVzc2FnZVR5cGUsIGhhbmRsZXIsIHNjb3BlKSB7XG5cdGlmIChtZXNzYWdlVHlwZS5oYXNPd25Qcm9wZXJ0eShcIlRZUEVcIikpXG5cdFx0bWVzc2FnZVR5cGUgPSBtZXNzYWdlVHlwZS5UWVBFO1xuXG5cdHRoaXMubWVzc2FnZURpc3BhdGNoZXIub2ZmKG1lc3NhZ2VUeXBlLCBoYW5kbGVyLCBzY29wZSk7XG59XG5cbi8qKlxuICogQ29ubmVjdGlvbiBtZXNzYWdlLlxuICogQG1ldGhvZCBvbkNvbm5lY3Rpb25NZXNzYWdlXG4gKiBAcHJpdmF0ZVxuICovXG5Qcm90b0Nvbm5lY3Rpb24ucHJvdG90eXBlLm9uQ29ubmVjdGlvbk1lc3NhZ2UgPSBmdW5jdGlvbihldikge1xuXHR2YXIgbWVzc2FnZSA9IGV2Lm1lc3NhZ2U7XG5cdHZhciBjb25zdHJ1Y3RvcjtcblxuXHRpZiAodGhpcy5sb2dNZXNzYWdlcylcblx0XHRjb25zb2xlLmxvZyhcIj09PiBcIiArIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKTtcblxuXHRmb3IgKHR5cGUgaW4gUHJvdG9Db25uZWN0aW9uLk1FU1NBR0VfVFlQRVMpIHtcblx0XHRpZiAobWVzc2FnZS50eXBlID09IHR5cGUpXG5cdFx0XHRjb25zdHJ1Y3RvciA9IFByb3RvQ29ubmVjdGlvbi5NRVNTQUdFX1RZUEVTW3R5cGVdXG5cdH1cblxuXHRpZiAoIWNvbnN0cnVjdG9yKSB7XG5cdFx0Y29uc29sZS53YXJuKFwidW5rbm93biBtZXNzYWdlOiBcIiArIG1lc3NhZ2UudHlwZSk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIG8gPSBuZXcgY29uc3RydWN0b3IoKTtcblx0by51bnNlcmlhbGl6ZShtZXNzYWdlKTtcblx0by50eXBlID0gbWVzc2FnZS50eXBlO1xuXG5cdHRoaXMubWVzc2FnZURpc3BhdGNoZXIudHJpZ2dlcihvKTtcblxuXHR0aGlzLnRyaWdnZXIoe1xuXHRcdHR5cGU6IFByb3RvQ29ubmVjdGlvbi5NRVNTQUdFLFxuXHRcdG1lc3NhZ2U6IG9cblx0fSk7XG59XG5cbi8qKlxuICogQ29ubmVjdGlvbiBjbG9zZS5cbiAqIEBtZXRob2Qgb25Db25uZWN0aW9uQ2xvc2VcbiAqIEBwcml2YXRlXG4gKi9cblByb3RvQ29ubmVjdGlvbi5wcm90b3R5cGUub25Db25uZWN0aW9uQ2xvc2UgPSBmdW5jdGlvbihldikge1xuXHR0aGlzLmNvbm5lY3Rpb24ub2ZmKFwibWVzc2FnZVwiLCB0aGlzLm9uQ29ubmVjdGlvbk1lc3NhZ2UsIHRoaXMpO1xuXHR0aGlzLmNvbm5lY3Rpb24ub2ZmKFwiY2xvc2VcIiwgdGhpcy5vbkNvbm5lY3Rpb25DbG9zZSwgdGhpcyk7XG5cblx0dGhpcy5jbG9zZSgpO1xuXG5cdHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG5cblx0dGhpcy50cmlnZ2VyKFByb3RvQ29ubmVjdGlvbi5DTE9TRSk7XG59XG5cbi8qKlxuICogU2VuZCBhIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIHNlbmRcbiAqL1xuUHJvdG9Db25uZWN0aW9uLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXHR2YXIgc2VyaWFsaXplZCA9IG1lc3NhZ2Uuc2VyaWFsaXplKCk7XG5cblx0Zm9yICh0eXBlIGluIFByb3RvQ29ubmVjdGlvbi5NRVNTQUdFX1RZUEVTKSB7XG5cdFx0aWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBQcm90b0Nvbm5lY3Rpb24uTUVTU0FHRV9UWVBFU1t0eXBlXSlcblx0XHRcdHNlcmlhbGl6ZWQudHlwZSA9IHR5cGU7XG5cdH1cblxuXHRpZiAoIXNlcmlhbGl6ZWQudHlwZSlcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG1lc3NhZ2UgdHlwZSBmb3Igc2VuZCwgbWVzc2FnZT1cIiArIG1lc3NhZ2UuY29uc3RydWN0b3IubmFtZSk7XG5cblx0Ly9cdGNvbnNvbGUubG9nKFwic2VuZGluZzogXCIrc2VyaWFsaXplZCk7XG5cblx0dGhpcy5jb25uZWN0aW9uLnNlbmQoc2VyaWFsaXplZCk7XG59XG5cbi8qKlxuICogU2hvdWxkIG1lc3NhZ2VzIGJlIGxvZ2dlZCB0byBjb25zb2xlP1xuICogQG1ldGhvZCBzZXRMb2dNZXNzYWdlc1xuICovXG5Qcm90b0Nvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvZ01lc3NhZ2VzID0gZnVuY3Rpb24odmFsdWUpIHtcblx0dGhpcy5sb2dNZXNzYWdlcyA9IHZhbHVlO1xufVxuXG4vKipcbiAqIENsb3NlIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb24uIE9ubHkgY2xvc2UgaXQgaWYgdGhlIHJlYWR5U3RhdGUgaXMgdW5kZWZpbmVkLFxuICogaS5lLiB3ZSBhcmUgaW4gYSBub2RlLmpzIGVudmlyb25tZW50LCBvciBpZiBpdCBzYXlzIHRoYXQgaXQgaXMgYWN0dWFsbHkgb3Blbi5cbiAqIEBtZXRob2QgY2xvc2VcbiAqL1xuUHJvdG9Db25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIXRoaXMuY29ubmVjdGlvbilcblx0XHRyZXR1cm47XG5cblx0aWYgKHRoaXMuY29ubmVjdGlvbi5yZWFkeVN0YXRlID09PSB1bmRlZmluZWQgfHxcblx0XHR0aGlzLmNvbm5lY3Rpb24ucmVhZHlTdGF0ZSA9PSAxKVxuXHRcdHRoaXMuY29ubmVjdGlvbi5jbG9zZSgpO1xufVxuXG4vKipcbiAqIEdldCBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKiBAbWV0aG9kIHRvU3RyaW5nXG4gKi9cblByb3RvQ29ubmVjdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIFwiPFByb3RvQ29ubmVjdGlvbj5cIjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQcm90b0Nvbm5lY3Rpb247IiwiLyoqXG4gKiBQcm90b2NvbC5cbiAqIEBtb2R1bGUgcHJvdG9cbiAqL1xuXG4vKipcbiAqIEJ1dHRvbiBkYXRhLlxuICogQGNsYXNzIEJ1dHRvbkRhdGFcbiAqL1xuZnVuY3Rpb24gQnV0dG9uRGF0YShidXR0b24sIHZhbHVlKSB7XG5cdHRoaXMuYnV0dG9uID0gYnV0dG9uO1xuXHR0aGlzLnZhbHVlID0gdmFsdWU7XG59XG5cbkJ1dHRvbkRhdGEuUkFJU0UgPSBcInJhaXNlXCI7XG5CdXR0b25EYXRhLkZPTEQgPSBcImZvbGRcIjtcbkJ1dHRvbkRhdGEuQkVUID0gXCJiZXRcIjtcbkJ1dHRvbkRhdGEuU0lUX09VVCA9IFwic2l0T3V0XCI7XG5CdXR0b25EYXRhLlNJVF9JTiA9IFwic2l0SW5cIjtcbkJ1dHRvbkRhdGEuQ0FMTCA9IFwiY2FsbFwiO1xuQnV0dG9uRGF0YS5QT1NUX0JCID0gXCJwb3N0QkJcIjtcbkJ1dHRvbkRhdGEuUE9TVF9TQiA9IFwicG9zdFNCXCI7XG5CdXR0b25EYXRhLkNBTkNFTCA9IFwiY2FuY2VsXCI7XG5CdXR0b25EYXRhLkNIRUNLID0gXCJjaGVja1wiO1xuQnV0dG9uRGF0YS5TSE9XID0gXCJzaG93XCI7XG5CdXR0b25EYXRhLk1VQ0sgPSBcIm11Y2tcIjtcbkJ1dHRvbkRhdGEuT0sgPSBcIm9rXCI7XG5CdXR0b25EYXRhLklNX0JBQ0sgPSBcImltQmFja1wiO1xuQnV0dG9uRGF0YS5MRUFWRSA9IFwibGVhdmVcIjtcbkJ1dHRvbkRhdGEuQ0hFQ0tfRk9MRCA9IFwiY2hlY2tGb2xkXCI7XG5CdXR0b25EYXRhLkNBTExfQU5ZID0gXCJjYWxsQW55XCI7XG5CdXR0b25EYXRhLlJBSVNFX0FOWSA9IFwicmFpc2VBbnlcIjtcbkJ1dHRvbkRhdGEuQlVZX0lOID0gXCJidXlJblwiO1xuQnV0dG9uRGF0YS5SRV9CVVkgPSBcInJlQnV5XCI7XG5CdXR0b25EYXRhLkpPSU5fVE9VUk5BTUVOVCA9IFwiam9pblRvdXJuYW1lbnRcIjtcbkJ1dHRvbkRhdGEuTEVBVkVfVE9VUk5BTUVOVCA9IFwibGVhdmVUb3VybmFtZW50XCI7XG5cbi8qKlxuICogR2V0IGJ1dHRvbi5cbiAqIEBtZXRob2QgZ2V0QnV0dG9uXG4gKi9cbkJ1dHRvbkRhdGEucHJvdG90eXBlLmdldEJ1dHRvbiA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5idXR0b247XG59XG5cbi8qKlxuICogR2V0IGJ1dHRvbiBzdHJpbmcgZm9yIHRoaXMgYnV0dG9uLlxuICogQG1ldGhvZCBnZXRCdXR0b25TdHJpbmdcbiAqL1xuQnV0dG9uRGF0YS5wcm90b3R5cGUuZ2V0QnV0dG9uU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBCdXR0b25EYXRhLmdldEJ1dHRvblN0cmluZ0ZvcklkKHRoaXMuYnV0dG9uKTtcbn1cblxuLyoqXG4gKiBHZXQgdmFsdWUuXG4gKiBAbWV0aG9kIGdldFZhbHVlXG4gKi9cbkJ1dHRvbkRhdGEucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnZhbHVlO1xufVxuXG4vKipcbiAqIEdldCBidXR0b24gc3RyaW5nIGZvciBpZC5cbiAqIEBtZXRob2QgZ2V0QnV0dG9uU3RyaW5nRm9ySWRcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uRGF0YS5nZXRCdXR0b25TdHJpbmdGb3JJZCA9IGZ1bmN0aW9uKGIpIHtcblx0c3dpdGNoIChiKSB7XG5cdFx0Y2FzZSBCdXR0b25EYXRhLkZPTEQ6XG5cdFx0XHRyZXR1cm4gXCJGT0xEXCI7XG5cblx0XHRjYXNlIEJ1dHRvbkRhdGEuQ0FMTDpcblx0XHRcdHJldHVybiBcIkNBTExcIjtcblxuXHRcdGNhc2UgQnV0dG9uRGF0YS5SQUlTRTpcblx0XHRcdHJldHVybiBcIlJBSVNFIFRPXCI7XG5cblx0XHRjYXNlIEJ1dHRvbkRhdGEuQkVUOlxuXHRcdFx0cmV0dXJuIFwiQkVUXCI7XG5cblx0XHRjYXNlIEJ1dHRvbkRhdGEuU0lUX09VVDpcblx0XHRcdHJldHVybiBcIlNJVCBPVVRcIjtcblxuXHRcdGNhc2UgQnV0dG9uRGF0YS5QT1NUX0JCOlxuXHRcdFx0cmV0dXJuIFwiUE9TVCBCQlwiO1xuXG5cdFx0Y2FzZSBCdXR0b25EYXRhLlBPU1RfU0I6XG5cdFx0XHRyZXR1cm4gXCJQT1NUIFNCXCI7XG5cblx0XHRjYXNlIEJ1dHRvbkRhdGEuU0lUX0lOOlxuXHRcdFx0cmV0dXJuIFwiU0lUIElOXCI7XG5cblx0XHRjYXNlIEJ1dHRvbkRhdGEuQ0FOQ0VMOlxuXHRcdFx0cmV0dXJuIFwiQ0FOQ0VMXCI7XG5cblx0XHRjYXNlIEJ1dHRvbkRhdGEuQ0hFQ0s6XG5cdFx0XHRyZXR1cm4gXCJDSEVDS1wiO1xuXG5cdFx0Y2FzZSBCdXR0b25EYXRhLlNIT1c6XG5cdFx0XHRyZXR1cm4gXCJTSE9XXCI7XG5cblx0XHRjYXNlIEJ1dHRvbkRhdGEuTVVDSzpcblx0XHRcdHJldHVybiBcIk1VQ0tcIjtcblxuXHRcdGNhc2UgQnV0dG9uRGF0YS5PSzpcblx0XHRcdHJldHVybiBcIk9LXCI7XG5cblx0XHRjYXNlIEJ1dHRvbkRhdGEuSU1fQkFDSzpcblx0XHRcdHJldHVybiBcIkknTSBCQUNLXCI7XG5cblx0XHRjYXNlIEJ1dHRvbkRhdGEuTEVBVkU6XG5cdFx0XHRyZXR1cm4gXCJMRUFWRVwiO1xuXG5cdFx0Y2FzZSBCdXR0b25EYXRhLkNIRUNLX0ZPTEQ6XG5cdFx0XHRyZXR1cm4gXCJDSEVDSyAvIEZPTERcIjtcblxuXHRcdGNhc2UgQnV0dG9uRGF0YS5DQUxMX0FOWTpcblx0XHRcdHJldHVybiBcIkNBTEwgQU5ZXCI7XG5cblx0XHRjYXNlIEJ1dHRvbkRhdGEuUkFJU0VfQU5ZOlxuXHRcdFx0cmV0dXJuIFwiUkFJU0UgQU5ZXCI7XG5cblx0XHRjYXNlIEJ1dHRvbkRhdGEuUkVfQlVZOlxuXHRcdFx0cmV0dXJuIFwiUkUtQlVZXCI7XG5cblx0XHRjYXNlIEJ1dHRvbkRhdGEuQlVZX0lOOlxuXHRcdFx0cmV0dXJuIFwiQlVZIElOXCI7XG5cdH1cblxuXHRyZXR1cm4gXCJcIjtcbn1cblxuQnV0dG9uRGF0YS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIFwiPEJ1dHRvbkRhdGEgYnV0dG9uPVwiICsgdGhpcy5idXR0b24gKyBcIiwgdmFsdWU9XCIgKyB0aGlzLnZhbHVlICsgXCI+XCI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQnV0dG9uRGF0YTsiLCIvKipcbiAqIFByb3RvY29sLlxuICogQG1vZHVsZSBwcm90b1xuICovXG5cbi8qKlxuICogQ2FyZCBkYXRhLlxuICogQGNsYXNzIENhcmREYXRhXG4gKi9cbmZ1bmN0aW9uIENhcmREYXRhKHZhbHVlKSB7XG5cdHRoaXMudmFsdWUgPSB2YWx1ZTtcbn1cblxuQ2FyZERhdGEuQ0FSRF9WQUxVRV9TVFJJTkdTID1cblx0W1wiMlwiLCBcIjNcIiwgXCI0XCIsIFwiNVwiLCBcIjZcIiwgXCI3XCIsIFwiOFwiLCBcIjlcIiwgXCIxMFwiLCBcIkpcIiwgXCJRXCIsIFwiS1wiLCBcIkFcIl07XG5cbkNhcmREYXRhLlNVSVRfU1RSSU5HUyA9XG5cdFtcIkRcIiwgXCJDXCIsIFwiSFwiLCBcIlNcIl07XG5DYXJkRGF0YS5MT05HX1NVSVRfU1RSSU5HUyA9XG5cdFtcIkRpYW1vbmRzXCIsIFwiQ2x1YnNcIiwgXCJIZWFydHNcIiwgXCJTcGFkZXNcIl07XG5cbkNhcmREYXRhLkhJRERFTiA9IC0xO1xuXG4vKipcbiAqIERvZXMgdGhpcyBDYXJkRGF0YSByZXByZXNlbnQgYSBzaG93IGNhcmQ/XG4gKiBJZiBub3QgaXQgc2hvdWxkIGJlIHJlbmRlcmVkIHdpdGggaXRzIGJhY2tzaWRlLlxuICogQG1ldGhvZCBpc1Nob3duXG4gKi9cbkNhcmREYXRhLnByb3RvdHlwZS5pc1Nob3duID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnZhbHVlID49IDA7XG59XG5cbi8qKlxuICogR2V0IGNhcmQgdmFsdWUuXG4gKiBUaGlzIHZhbHVlIHJlcHJlc2VudHMgdGhlIHJhbmsgb2YgdGhlIGNhcmQsIGJ1dCBzdGFydHMgb24gMC5cbiAqIEBtZXRob2QgZ2V0Q2FyZFZhbHVlXG4gKi9cbkNhcmREYXRhLnByb3RvdHlwZS5nZXRDYXJkVmFsdWUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMudmFsdWUgJSAxMztcbn1cblxuLyoqXG4gKiBHZXQgY2FyZCB2YWx1ZSBzdHJpbmcuXG4gKiBAbWV0aG9kIGdldENhcmRWYWx1ZVN0cmluZ1xuICovXG5DYXJkRGF0YS5wcm90b3R5cGUuZ2V0Q2FyZFZhbHVlU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBDYXJkRGF0YS5DQVJEX1ZBTFVFX1NUUklOR1NbdGhpcy52YWx1ZSAlIDEzXTtcbn1cblxuLyoqXG4gKiBHZXQgc3VpdCBpbmRleC5cbiAqIEBtZXRob2QgZ2V0U3VpdEluZGV4XG4gKi9cbkNhcmREYXRhLnByb3RvdHlwZS5nZXRTdWl0SW5kZXggPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZSAvIDEzKTtcbn1cblxuLyoqXG4gKiBHZXQgc3VpdCBzdHJpbmcuXG4gKiBAbWV0aG9kIGdldFN1aXRTdHJpbmdcbiAqL1xuQ2FyZERhdGEucHJvdG90eXBlLmdldFN1aXRTdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIENhcmREYXRhLlNVSVRfU1RSSU5HU1t0aGlzLmdldFN1aXRJbmRleCgpXTtcbn1cblxuLyoqXG4gKiBHZXQgbG9uZyBzdWl0IHN0cmluZy5cbiAqIEBtZXRob2QgZ2V0TG9uZ1N1aXRTdHJpbmdcbiAqL1xuQ2FyZERhdGEucHJvdG90eXBlLmdldExvbmdTdWl0U3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBDYXJkRGF0YS5MT05HX1NVSVRfU1RSSU5HU1t0aGlzLmdldFN1aXRJbmRleCgpXTtcbn1cblxuLyoqXG4gKiBHZXQgY29sb3IuXG4gKiBAbWV0aG9kIGdldENvbG9yXG4gKi9cbkNhcmREYXRhLnByb3RvdHlwZS5nZXRDb2xvciA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5nZXRTdWl0SW5kZXgoKSAlIDIgIT0gMClcblx0XHRyZXR1cm4gXCIjMDAwMDAwXCI7XG5cblx0ZWxzZVxuXHRcdHJldHVybiBcIiNmZjAwMDBcIjtcbn1cblxuLyoqXG4gKiBUbyBzdHJpbmcuXG4gKiBAbWV0aG9kIHRvU3RyaW5nXG4gKi9cbkNhcmREYXRhLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy52YWx1ZSA8IDApXG5cdFx0cmV0dXJuIFwiWFhcIjtcblxuXHQvL1x0cmV0dXJuIFwiPGNhcmQgXCIgKyB0aGlzLmdldENhcmRWYWx1ZVN0cmluZygpICsgdGhpcy5nZXRTdWl0U3RyaW5nKCkgKyBcIj5cIjtcblx0cmV0dXJuIHRoaXMuZ2V0Q2FyZFZhbHVlU3RyaW5nKCkgKyB0aGlzLmdldFN1aXRTdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBHZXQgdmFsdWUgb2YgdGhlIGNhcmQuXG4gKiBAbWV0aG9kIGdldFZhbHVlXG4gKi9cbkNhcmREYXRhLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy52YWx1ZTtcbn1cblxuLyoqXG4gKiBDb21wYXJlIHdpdGggcmVzcGVjdCB0byB2YWx1ZS4gTm90IHJlYWxseSB1c2VmdWwgZXhjZXB0IGZvciBkZWJ1Z2dpbmchXG4gKiBAbWV0aG9kIGNvbXBhcmVWYWx1ZVxuICogQHN0YXRpY1xuICovXG5DYXJkRGF0YS5jb21wYXJlVmFsdWUgPSBmdW5jdGlvbihhLCBiKSB7XG5cdGlmICghKGEgaW5zdGFuY2VvZiBDYXJkRGF0YSkgfHwgIShiIGluc3RhbmNlb2YgQ2FyZERhdGEpKVxuXHRcdHRocm93IG5ldyBFcnJvcihcIk5vdCBjb21wYXJpbmcgY2FyZCBkYXRhXCIpO1xuXG5cdGlmIChhLmdldFZhbHVlKCkgPiBiLmdldFZhbHVlKCkpXG5cdFx0cmV0dXJuIDE7XG5cblx0aWYgKGEuZ2V0VmFsdWUoKSA8IGIuZ2V0VmFsdWUoKSlcblx0XHRyZXR1cm4gLTE7XG5cblx0cmV0dXJuIDA7XG59XG5cbi8qKlxuICogQ29tcGFyZSB3aXRoIHJlc3BlY3QgdG8gY2FyZCB2YWx1ZS5cbiAqIEBtZXRob2QgY29tcGFyZUNhcmRWYWx1ZVxuICogQHN0YXRpY1xuICovXG5DYXJkRGF0YS5jb21wYXJlQ2FyZFZhbHVlID0gZnVuY3Rpb24oYSwgYikge1xuXHRpZiAoIShhIGluc3RhbmNlb2YgQ2FyZERhdGEpIHx8ICEoYiBpbnN0YW5jZW9mIENhcmREYXRhKSlcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJOb3QgY29tcGFyaW5nIGNhcmQgZGF0YVwiKTtcblxuXHRpZiAoYS5nZXRDYXJkVmFsdWUoKSA+IGIuZ2V0Q2FyZFZhbHVlKCkpXG5cdFx0cmV0dXJuIDE7XG5cblx0aWYgKGEuZ2V0Q2FyZFZhbHVlKCkgPCBiLmdldENhcmRWYWx1ZSgpKVxuXHRcdHJldHVybiAtMTtcblxuXHRyZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBDb21wYXJlIHdpdGggcmVzcGVjdCB0byBzdWl0LlxuICogQG1ldGhvZCBjb21wYXJlU3VpdFxuICogQHN0YXRpY1xuICovXG5DYXJkRGF0YS5jb21wYXJlU3VpdEluZGV4ID0gZnVuY3Rpb24oYSwgYikge1xuXHRpZiAoIShhIGluc3RhbmNlb2YgQ2FyZERhdGEpIHx8ICEoYiBpbnN0YW5jZW9mIENhcmREYXRhKSlcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJOb3QgY29tcGFyaW5nIGNhcmQgZGF0YVwiKTtcblxuXHRpZiAoYS5nZXRTdWl0SW5kZXgoKSA+IGIuZ2V0U3VpdEluZGV4KCkpXG5cdFx0cmV0dXJuIDE7XG5cblx0aWYgKGEuZ2V0U3VpdEluZGV4KCkgPCBiLmdldFN1aXRJbmRleCgpKVxuXHRcdHJldHVybiAtMTtcblxuXHRyZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYXJkIGRhdGEgZnJvbSBhIHN0cmluZy5cbiAqIEBtZXRob2QgZnJvbVN0cmluZ1xuICogQHN0YXRpY1xuICovXG5DYXJkRGF0YS5mcm9tU3RyaW5nID0gZnVuY3Rpb24ocykge1xuXHR2YXIgaTtcblxuXHR2YXIgY2FyZFZhbHVlID0gLTE7XG5cdGZvciAoaSA9IDA7IGkgPCBDYXJkRGF0YS5DQVJEX1ZBTFVFX1NUUklOR1MubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgY2FuZCA9IENhcmREYXRhLkNBUkRfVkFMVUVfU1RSSU5HU1tpXTtcblxuXHRcdGlmIChzLnN1YnN0cmluZygwLCBjYW5kLmxlbmd0aCkudG9VcHBlckNhc2UoKSA9PSBjYW5kKVxuXHRcdFx0Y2FyZFZhbHVlID0gaTtcblx0fVxuXG5cdGlmIChjYXJkVmFsdWUgPCAwKVxuXHRcdHRocm93IG5ldyBFcnJvcihcIk5vdCBhIHZhbGlkIGNhcmQgc3RyaW5nOiBcIiArIHMpO1xuXG5cdHZhciBzdWl0U3RyaW5nID0gcy5zdWJzdHJpbmcoQ2FyZERhdGEuQ0FSRF9WQUxVRV9TVFJJTkdTW2NhcmRWYWx1ZV0ubGVuZ3RoKTtcblxuXHR2YXIgc3VpdEluZGV4ID0gLTE7XG5cdGZvciAoaSA9IDA7IGkgPCBDYXJkRGF0YS5TVUlUX1NUUklOR1MubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgY2FuZCA9IENhcmREYXRhLlNVSVRfU1RSSU5HU1tpXTtcblxuXHRcdGlmIChzdWl0U3RyaW5nLnRvVXBwZXJDYXNlKCkgPT0gY2FuZClcblx0XHRcdHN1aXRJbmRleCA9IGk7XG5cdH1cblxuXHRpZiAoc3VpdEluZGV4IDwgMClcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSB2YWxpZCBjYXJkIHN0cmluZzogXCIgKyBzKTtcblxuXHRyZXR1cm4gbmV3IENhcmREYXRhKHN1aXRJbmRleCAqIDEzICsgY2FyZFZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDYXJkRGF0YTsiLCIvKipcbiAqIFByb3RvY29sLlxuICogQG1vZHVsZSBwcm90b1xuICovXG5cbi8qKlxuICogUmVjZWl2ZWQgd2hlbiBwbGF5ZXIgbWFkZSBhbiBhY3Rpb24uXG4gKiBAY2xhc3MgQWN0aW9uTWVzc2FnZVxuICovXG5mdW5jdGlvbiBBY3Rpb25NZXNzYWdlKHNlYXRJbmRleCwgYWN0aW9uKSB7XG5cdHRoaXMuc2VhdEluZGV4ID0gc2VhdEluZGV4O1xuXHR0aGlzLmFjdGlvbiA9IGFjdGlvbjtcbn1cblxuQWN0aW9uTWVzc2FnZS5UWVBFID0gXCJhY3Rpb25cIjtcblxuQWN0aW9uTWVzc2FnZS5GT0xEID0gXCJmb2xkXCI7XG5BY3Rpb25NZXNzYWdlLkNBTEwgPSBcImNhbGxcIjtcbkFjdGlvbk1lc3NhZ2UuUkFJU0UgPSBcInJhaXNlXCI7XG5BY3Rpb25NZXNzYWdlLkNIRUNLID0gXCJjaGVja1wiO1xuQWN0aW9uTWVzc2FnZS5CRVQgPSBcImJldFwiO1xuQWN0aW9uTWVzc2FnZS5NVUNLID0gXCJtdWNrXCI7XG5BY3Rpb25NZXNzYWdlLkFOVEUgPSBcImFudGVcIjtcblxuLyoqXG4gKiBTZWF0IGluZGV4LlxuICogQG1ldGhvZCBnZXRTZWF0SW5kZXhcbiAqL1xuQWN0aW9uTWVzc2FnZS5wcm90b3R5cGUuZ2V0U2VhdEluZGV4ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnNlYXRJbmRleDtcbn1cblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldEFjdGlvblxuICovXG5BY3Rpb25NZXNzYWdlLnByb3RvdHlwZS5nZXRBY3Rpb24gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuYWN0aW9uO1xufVxuXG4vKipcbiAqIFVuLXNlcmlhbGl6ZS5cbiAqIEBtZXRob2QgdW5zZXJpYWxpemVcbiAqL1xuQWN0aW9uTWVzc2FnZS5wcm90b3R5cGUudW5zZXJpYWxpemUgPSBmdW5jdGlvbihkYXRhKSB7XG5cdHRoaXMuc2VhdEluZGV4ID0gZGF0YS5zZWF0SW5kZXg7XG5cdHRoaXMuYWN0aW9uID0gZGF0YS5hY3Rpb247XG59XG5cbi8qKlxuICogU2VyaWFsaXplIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIHNlcmlhbGl6ZVxuICovXG5BY3Rpb25NZXNzYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHtcblx0XHRzZWF0SW5kZXg6IHRoaXMuc2VhdEluZGV4LFxuXHRcdGFjdGlvbjogdGhpcy5hY3Rpb25cblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBY3Rpb25NZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxuLyoqXG4gKiBSZWNlaXZlZCB3aGVuIHBsYXllciBoYXMgcGxhY2VkIGEgYmV0LlxuICogQGNsYXNzIEJldE1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gQmV0TWVzc2FnZShzZWF0SW5kZXgsIHZhbHVlKSB7XG5cdHRoaXMuc2VhdEluZGV4ID0gc2VhdEluZGV4O1xuXHR0aGlzLnZhbHVlID0gdmFsdWU7XG59XG5cbkJldE1lc3NhZ2UuVFlQRSA9IFwiYmV0XCI7XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRTZWF0SW5kZXhcbiAqL1xuQmV0TWVzc2FnZS5wcm90b3R5cGUuZ2V0U2VhdEluZGV4ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnNlYXRJbmRleDtcbn1cblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldFZhbHVlXG4gKi9cbkJldE1lc3NhZ2UucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnZhbHVlO1xufVxuXG4vKipcbiAqIFVuLXNlcmlhbGl6ZS5cbiAqIEBtZXRob2QgdW5zZXJpYWxpemVcbiAqL1xuQmV0TWVzc2FnZS5wcm90b3R5cGUudW5zZXJpYWxpemUgPSBmdW5jdGlvbihkYXRhKSB7XG5cdHRoaXMuc2VhdEluZGV4ID0gZGF0YS5zZWF0SW5kZXg7XG5cdHRoaXMudmFsdWUgPSBkYXRhLnZhbHVlO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZXJpYWxpemVcbiAqL1xuQmV0TWVzc2FnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB7XG5cdFx0c2VhdEluZGV4OiB0aGlzLnNlYXRJbmRleCxcblx0XHR2YWx1ZTogdGhpcy52YWx1ZVxuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJldE1lc3NhZ2U7IiwiLyoqXG4gKiBQcm90b2NvbC5cbiAqIEBtb2R1bGUgcHJvdG9cbiAqL1xuXG4vKipcbiAqIFJlY2VpdmVkIHdoZW4gYmV0cyBzaG91bGQgYmUgcGxhY2VkIGluIHBvdC5cbiAqIEBjbGFzcyBCZXRzVG9Qb3RNZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIEJldHNUb1BvdE1lc3NhZ2UoKSB7XG59XG5cbkJldHNUb1BvdE1lc3NhZ2UuVFlQRSA9IFwiYmV0c1RvUG90XCI7XG5cbi8qKlxuICogVW4tc2VyaWFsaXplLlxuICogQG1ldGhvZCB1bnNlcmlhbGl6ZVxuICovXG5CZXRzVG9Qb3RNZXNzYWdlLnByb3RvdHlwZS51bnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgbWVzc2FnZS5cbiAqIEBtZXRob2Qgc2VyaWFsaXplXG4gKi9cbkJldHNUb1BvdE1lc3NhZ2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4ge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQmV0c1RvUG90TWVzc2FnZTsiLCIvKipcbiAqIFByb3RvY29sLlxuICogQG1vZHVsZSBwcm90b1xuICovXG5cbi8qKlxuICogU2VudCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBhIGJ1dHRvbiwgZWl0aGVyIGluIGEgZGlhbG9nIG9yXG4gKiBmb3IgYSBnYW1lIGFjdGlvbi5cbiAqIEBjbGFzcyBCdXR0b25DbGlja01lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gQnV0dG9uQ2xpY2tNZXNzYWdlKGJ1dHRvbiwgdmFsdWUpIHtcblx0dGhpcy5idXR0b24gPSBidXR0b247XG5cdHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuLy9cdGNvbnNvbGUubG9nKFwiQ3JlYXRpbmcgYnV0dG9uIGNsaWNrIG1lc3NhZ2UsIHZhbHVlPVwiICsgdmFsdWUpO1xufVxuXG5CdXR0b25DbGlja01lc3NhZ2UuVFlQRSA9IFwiYnV0dG9uQ2xpY2tcIjtcblxuLyoqXG4gKiBUaGUgdGhlIGJ1dHRvbiB0aGF0IHdhcyBwcmVzc2VkLlxuICogQG1ldGhvZCBnZXRCdXR0b25cbiAqL1xuQnV0dG9uQ2xpY2tNZXNzYWdlLnByb3RvdHlwZS5nZXRCdXR0b24gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuYnV0dG9uO1xufVxuXG4vKipcbiAqIFNldHRlci5cbiAqIEBtZXRob2QgZ2V0VmFsdWVcbiAqL1xuQnV0dG9uQ2xpY2tNZXNzYWdlLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy52YWx1ZTtcbn1cblxuLyoqXG4gKiBVbi1zZXJpYWxpemUuXG4gKiBAbWV0aG9kIHVuc2VyaWFsaXplXG4gKi9cbkJ1dHRvbkNsaWNrTWVzc2FnZS5wcm90b3R5cGUudW5zZXJpYWxpemUgPSBmdW5jdGlvbihkYXRhKSB7XG5cdHRoaXMuYnV0dG9uID0gZGF0YS5idXR0b247XG5cdHRoaXMudmFsdWUgPSBkYXRhLnZhbHVlO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZXJpYWxpemVcbiAqL1xuQnV0dG9uQ2xpY2tNZXNzYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHtcblx0XHRidXR0b246IHRoaXMuYnV0dG9uLFxuXHRcdHZhbHVlOiB0aGlzLnZhbHVlXG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQnV0dG9uQ2xpY2tNZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxudmFyIEJ1dHRvbkRhdGEgPSByZXF1aXJlKFwiLi4vZGF0YS9CdXR0b25EYXRhXCIpO1xuXG4vKipcbiAqIE1lc3NhZ2Ugc2VudCB3aGVuIHRoZSBjbGllbnQgc2hvdWxkIHNob3cgZ2FtZSBhY3Rpb24gYnV0dG9ucyxcbiAqIEZPTEQsIFJBSVNFIGV0Yy5cbiAqIEBjbGFzcyBCdXR0b25zTWVzc2FnZVxuICovXG5mdW5jdGlvbiBCdXR0b25zTWVzc2FnZSgpIHtcblx0dGhpcy5idXR0b25zID0gW107XG5cdHRoaXMuc2xpZGVyQnV0dG9uSW5kZXggPSAwO1xuXHR0aGlzLm1pbiA9IC0xO1xuXHR0aGlzLm1heCA9IC0xO1xufVxuXG5CdXR0b25zTWVzc2FnZS5UWVBFID0gXCJidXR0b25zXCI7XG5cbi8qKlxuICogR2V0IGFuIGFycmF5IG9mIEJ1dHRvbkRhdGEgaW5kaWNhdGluZyB3aGljaCBidXR0b25zIHRvIHNob3cuXG4gKiBAbWV0aG9kIGdldEJ1dHRvbnNcbiAqL1xuQnV0dG9uc01lc3NhZ2UucHJvdG90eXBlLmdldEJ1dHRvbnMgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuYnV0dG9ucztcbn1cblxuLyoqXG4gKiBBZGQgYSBidXR0b24gdG8gYmUgc2VudC5cbiAqIEBtZXRob2QgYWRkQnV0dG9uXG4gKi9cbkJ1dHRvbnNNZXNzYWdlLnByb3RvdHlwZS5hZGRCdXR0b24gPSBmdW5jdGlvbihidXR0b24pIHtcblx0dGhpcy5idXR0b25zLnB1c2goYnV0dG9uKTtcbn1cblxuLyoqXG4gKiBVbi1zZXJpYWxpemUuXG4gKiBAbWV0aG9kIHVuc2VyaWFsaXplLlxuICovXG5CdXR0b25zTWVzc2FnZS5wcm90b3R5cGUudW5zZXJpYWxpemUgPSBmdW5jdGlvbihkYXRhKSB7XG5cdHRoaXMuYnV0dG9ucyA9IFtdO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5idXR0b25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGJ1dHRvbiA9IGRhdGEuYnV0dG9uc1tpXTtcblx0XHR2YXIgYnV0dG9uRGF0YSA9IG5ldyBCdXR0b25EYXRhKGJ1dHRvbi5idXR0b24sIGJ1dHRvbi52YWx1ZSk7XG5cdFx0dGhpcy5hZGRCdXR0b24oYnV0dG9uRGF0YSk7XG5cdH1cblx0dGhpcy5zbGlkZXJCdXR0b25JbmRleCA9IGRhdGEuc2xpZGVyQnV0dG9uSW5kZXg7XG5cdHRoaXMubWluID0gZGF0YS5taW47XG5cdHRoaXMubWF4ID0gZGF0YS5tYXg7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIHNlcmlhbGl6ZVxuICovXG5CdXR0b25zTWVzc2FnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdHZhciBidXR0b25zID0gW107XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJ1dHRvbnMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgYnV0dG9uID0ge307XG5cdFx0YnV0dG9uLmJ1dHRvbiA9IHRoaXMuYnV0dG9uc1tpXS5nZXRCdXR0b24oKTtcblx0XHRidXR0b24udmFsdWUgPSB0aGlzLmJ1dHRvbnNbaV0uZ2V0VmFsdWUoKTtcblx0XHRidXR0b25zLnB1c2goYnV0dG9uKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0YnV0dG9uczogYnV0dG9ucyxcblx0XHRzbGlkZXJCdXR0b25JbmRleDogdGhpcy5zbGlkZXJCdXR0b25JbmRleCxcblx0XHRtaW46IHRoaXMubWluLFxuXHRcdG1heDogdGhpcy5tYXhcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCdXR0b25zTWVzc2FnZTsiLCIvKipcbiAqIFByb3RvY29sLlxuICogQG1vZHVsZSBwcm90b1xuICovXG5cbi8qKlxuICogUmVjZWl2ZWQgd2hlbiBzb21ldGhpbmcgaGFzIG9jY3VycmVkIGluIHRoZSBjaGF0LlxuICogQGNsYXNzIENoYXRNZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIENoYXRNZXNzYWdlKHVzZXIsIHRleHQpIHtcblx0dGhpcy51c2VyID0gdXNlcjtcblx0dGhpcy50ZXh0ID0gdGV4dDtcbn1cblxuQ2hhdE1lc3NhZ2UuVFlQRSA9IFwiY2hhdFwiO1xuXG4vKipcbiAqIEdldCB0ZXh0LlxuICogQG1ldGhvZCBnZXRUZXh0XG4gKi9cbkNoYXRNZXNzYWdlLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnRleHQ7XG59XG5cbi8qKlxuICogR2V0IHVzZXIuXG4gKiBAbWV0aG9kIGdldFVzZXJcbiAqL1xuQ2hhdE1lc3NhZ2UucHJvdG90eXBlLmdldFVzZXIgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMudXNlcjtcbn1cblxuLyoqXG4gKiBVbi1zZXJpYWxpemUuXG4gKiBAbWV0aG9kIHVuc2VyaWFsaXplXG4gKi9cbkNoYXRNZXNzYWdlLnByb3RvdHlwZS51bnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0dGhpcy50ZXh0ID0gZGF0YS50ZXh0O1xuXHR0aGlzLnVzZXIgPSBkYXRhLnVzZXI7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIHNlcmlhbGl6ZVxuICovXG5DaGF0TWVzc2FnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB7XG5cdFx0dGV4dDogdGhpcy50ZXh0LFxuXHRcdHVzZXI6IHRoaXMudXNlclxuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENoYXRNZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxuLyoqXG4gKiBTZW50IHdoZW4gcGxheWVyIGhhcyBjaGVja2VkIGEgY2hlY2tib3guXG4gKiBAY2xhc3MgQ2hlY2tib3hNZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIENoZWNrYm94TWVzc2FnZShpZCwgY2hlY2tlZCkge1xuXHR0aGlzLmlkID0gaWQ7XG5cdHRoaXMuY2hlY2tlZCA9IGNoZWNrZWQ7XG59XG5cbkNoZWNrYm94TWVzc2FnZS5UWVBFID0gXCJjaGVja2JveFwiO1xuXG5DaGVja2JveE1lc3NhZ2UuQVVUT19QT1NUX0JMSU5EUyA9IFwiYXV0b1Bvc3RCbGluZHNcIjtcbkNoZWNrYm94TWVzc2FnZS5BVVRPX01VQ0tfTE9TSU5HID0gXCJhdXRvTXVja0xvc2luZ1wiO1xuQ2hlY2tib3hNZXNzYWdlLlNJVE9VVF9ORVhUID0gXCJzaXRvdXROZXh0XCI7XG5cbi8qKlxuICogSWQgb2YgY2hlY2tib3guXG4gKiBAbWV0aG9kIGdldElkXG4gKi9cbkNoZWNrYm94TWVzc2FnZS5wcm90b3R5cGUuZ2V0SWQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuaWQ7XG59XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRWYWx1ZVxuICovXG5DaGVja2JveE1lc3NhZ2UucHJvdG90eXBlLmdldENoZWNrZWQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuY2hlY2tlZDtcbn1cblxuLyoqXG4gKiBVbi1zZXJpYWxpemUuXG4gKiBAbWV0aG9kIHVuc2VyaWFsaXplXG4gKi9cbkNoZWNrYm94TWVzc2FnZS5wcm90b3R5cGUudW5zZXJpYWxpemUgPSBmdW5jdGlvbihkYXRhKSB7XG5cdHRoaXMuaWQgPSBkYXRhLmlkO1xuXHR0aGlzLmNoZWNrZWQgPSBkYXRhLmNoZWNrZWQ7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIHNlcmlhbGl6ZVxuICovXG5DaGVja2JveE1lc3NhZ2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4ge1xuXHRcdGlkOiB0aGlzLmlkLFxuXHRcdGNoZWNrZWQ6IHRoaXMuY2hlY2tlZFxuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENoZWNrYm94TWVzc2FnZTsiLCIvKipcbiAqIFByb3RvY29sLlxuICogQG1vZHVsZSBwcm90b1xuICovXG5cbi8qKlxuICogQGNsYXNzIENsZWFyTWVzc2FnZVxuICovXG5mdW5jdGlvbiBDbGVhck1lc3NhZ2UoY29tcG9uZW50cykge1xuXHRpZiAoIWNvbXBvbmVudHMpXG5cdFx0Y29tcG9uZW50cyA9IFtdO1xuXG5cdHRoaXMuY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG59XG5cbkNsZWFyTWVzc2FnZS5UWVBFID0gXCJjbGVhclwiO1xuXG5DbGVhck1lc3NhZ2UuQ0FSRFMgPSBcImNhcmRzXCI7XG5DbGVhck1lc3NhZ2UuQkVUUyA9IFwiYmV0c1wiO1xuQ2xlYXJNZXNzYWdlLlBPVCA9IFwicG90XCI7XG5DbGVhck1lc3NhZ2UuQ0hBVCA9IFwiY2hhdFwiO1xuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0Q29tcG9uZW50c1xuICovXG5DbGVhck1lc3NhZ2UucHJvdG90eXBlLmdldENvbXBvbmVudHMgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuY29tcG9uZW50cztcbn1cblxuLyoqXG4gKiBVbi1zZXJpYWxpemUuXG4gKiBAbWV0aG9kIHVuc2VyaWFsaXplXG4gKi9cbkNsZWFyTWVzc2FnZS5wcm90b3R5cGUudW5zZXJpYWxpemUgPSBmdW5jdGlvbihkYXRhKSB7XG5cdHRoaXMuY29tcG9uZW50cyA9IGRhdGEuY29tcG9uZW50cztcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgbWVzc2FnZS5cbiAqIEBtZXRob2Qgc2VyaWFsaXplXG4gKi9cbkNsZWFyTWVzc2FnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB7XG5cdFx0Y29tcG9uZW50czogdGhpcy5jb21wb25lbnRzXG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xlYXJNZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxudmFyIENhcmREYXRhID0gcmVxdWlyZShcIi4uL2RhdGEvQ2FyZERhdGFcIik7XG5cbi8qKlxuICogU2hvdyBjb21tdW5pdHkgY2FyZHMuXG4gKiBAY2xhc3MgQ29tbXVuaXR5Q2FyZHNNZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIENvbW11bml0eUNhcmRzTWVzc2FnZShjYXJkcykge1xuXHRpZiAoIWNhcmRzKVxuXHRcdGNhcmRzID0gW107XG5cblx0dGhpcy5hbmltYXRlID0gZmFsc2U7XG5cdHRoaXMuY2FyZHMgPSBjYXJkcztcblx0dGhpcy5maXJzdEluZGV4ID0gMDtcbn1cblxuQ29tbXVuaXR5Q2FyZHNNZXNzYWdlLlRZUEUgPSBcImNvbW11bml0eUNhcmRzXCI7XG5cbi8qKlxuICogQW5pbWF0aW9uIG9yIG5vdD9cbiAqIEBtZXRob2Qgc2V0QW5pbWF0ZVxuICovXG5Db21tdW5pdHlDYXJkc01lc3NhZ2UucHJvdG90eXBlLnNldEFuaW1hdGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRyZXR1cm4gdGhpcy5hbmltYXRlID0gdmFsdWU7XG59XG5cbi8qKlxuICogU2V0IGZpcnN0IGluZGV4LlxuICogQG1ldGhvZCBzZXRGaXJzdEluZGV4XG4gKi9cbkNvbW11bml0eUNhcmRzTWVzc2FnZS5wcm90b3R5cGUuc2V0Rmlyc3RJbmRleCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdHJldHVybiB0aGlzLmZpcnN0SW5kZXggPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBBZGQgY2FyZC5cbiAqIEBtZXRob2QgYWRkQ2FyZFxuICovXG5Db21tdW5pdHlDYXJkc01lc3NhZ2UucHJvdG90eXBlLmFkZENhcmQgPSBmdW5jdGlvbihjKSB7XG5cdHRoaXMuY2FyZHMucHVzaChjKTtcbn1cblxuLyoqXG4gKiBHZXQgY2FyZCBkYXRhLlxuICogQG1ldGhvZCBnZXRDYXJkc1xuICovXG5Db21tdW5pdHlDYXJkc01lc3NhZ2UucHJvdG90eXBlLmdldENhcmRzID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmNhcmRzO1xufVxuXG4vKipcbiAqIEdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNhcmQgdG8gYmUgc2hvd24gaW4gdGhlIHNlcXVlbmNlLlxuICogQG1ldGhvZCBnZXRGaXJzdEluZGV4XG4gKi9cbkNvbW11bml0eUNhcmRzTWVzc2FnZS5wcm90b3R5cGUuZ2V0Rmlyc3RJbmRleCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5maXJzdEluZGV4O1xufVxuXG4vKipcbiAqIFVuLXNlcmlhbGl6ZS5cbiAqIEBtZXRob2QgdW5zZXJpYWxpemUuXG4gKi9cbkNvbW11bml0eUNhcmRzTWVzc2FnZS5wcm90b3R5cGUudW5zZXJpYWxpemUgPSBmdW5jdGlvbihkYXRhKSB7XG5cdHZhciBpO1xuXG5cdHRoaXMuYW5pbWF0ZSA9IGRhdGEuYW5pbWF0ZTtcblx0dGhpcy5maXJzdEluZGV4ID0gcGFyc2VJbnQoZGF0YS5maXJzdEluZGV4KTtcblx0dGhpcy5jYXJkcyA9IFtdO1xuXG5cdGZvciAoaSA9IDA7IGkgPCBkYXRhLmNhcmRzLmxlbmd0aDsgaSsrKVxuXHRcdHRoaXMuY2FyZHMucHVzaChuZXcgQ2FyZERhdGEoZGF0YS5jYXJkc1tpXSkpO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZXJpYWxpemVcbiAqL1xuQ29tbXVuaXR5Q2FyZHNNZXNzYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0dmFyIGNhcmRzID0gW107XG5cblx0Zm9yIChpID0gMDsgaSA8IHRoaXMuY2FyZHMubGVuZ3RoOyBpKyspXG5cdFx0Y2FyZHMucHVzaCh0aGlzLmNhcmRzW2ldLmdldFZhbHVlKCkpO1xuXG5cdHJldHVybiB7XG5cdFx0YW5pbWF0ZTogdGhpcy5hbmltYXRlLFxuXHRcdGZpcnN0SW5kZXg6IHRoaXMuZmlyc3RJbmRleCxcblx0XHRjYXJkczogY2FyZHNcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21tdW5pdHlDYXJkc01lc3NhZ2U7IiwiLyoqXG4gKiBQcm90b2NvbC5cbiAqIEBtb2R1bGUgcHJvdG9cbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBEZWFsZXJCdXR0b25NZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIERlYWxlckJ1dHRvbk1lc3NhZ2Uoc2VhdEluZGV4LCBhbmltYXRlKSB7XG5cdHRoaXMuc2VhdEluZGV4ID0gc2VhdEluZGV4O1xuXHR0aGlzLmFuaW1hdGUgPSBhbmltYXRlO1xufVxuXG5EZWFsZXJCdXR0b25NZXNzYWdlLlRZUEUgPSBcImRlYWxlckJ1dHRvblwiO1xuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0U2VhdEluZGV4XG4gKi9cbkRlYWxlckJ1dHRvbk1lc3NhZ2UucHJvdG90eXBlLmdldFNlYXRJbmRleCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5zZWF0SW5kZXg7XG59XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRBbmltYXRlXG4gKi9cbkRlYWxlckJ1dHRvbk1lc3NhZ2UucHJvdG90eXBlLmdldEFuaW1hdGUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuYW5pbWF0ZTtcbn1cblxuLyoqXG4gKiBVbi1zZXJpYWxpemUuXG4gKiBAbWV0aG9kIHVuc2VyaWFsaXplXG4gKi9cbkRlYWxlckJ1dHRvbk1lc3NhZ2UucHJvdG90eXBlLnVuc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge1xuXHR0aGlzLnNlYXRJbmRleCA9IGRhdGEuc2VhdEluZGV4O1xuXHR0aGlzLmFuaW1hdGUgPSBkYXRhLmFuaW1hdGU7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIHNlcmlhbGl6ZVxuICovXG5EZWFsZXJCdXR0b25NZXNzYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHtcblx0XHRzZWF0SW5kZXg6IHRoaXMuc2VhdEluZGV4LFxuXHRcdGFuaW1hdGU6IHRoaXMuYW5pbWF0ZVxuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERlYWxlckJ1dHRvbk1lc3NhZ2U7IiwiLyoqXG4gKiBQcm90b2NvbC5cbiAqIEBtb2R1bGUgcHJvdG9cbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBEZWxheU1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gRGVsYXlNZXNzYWdlKGRlbGF5KSB7XG5cdHRoaXMuZGVsYXkgPSBkZWxheTtcbn1cblxuRGVsYXlNZXNzYWdlLlRZUEUgPSBcImRlbGF5XCI7XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXREZWxheVxuICovXG5EZWxheU1lc3NhZ2UucHJvdG90eXBlLmdldERlbGF5ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmRlbGF5O1xufVxuXG4vKipcbiAqIFVuLXNlcmlhbGl6ZS5cbiAqIEBtZXRob2QgdW5zZXJpYWxpemVcbiAqL1xuRGVsYXlNZXNzYWdlLnByb3RvdHlwZS51bnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0dGhpcy5kZWxheSA9IGRhdGEuZGVsYXk7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIHNlcmlhbGl6ZVxuICovXG5EZWxheU1lc3NhZ2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4ge1xuXHRcdGRlbGF5OiB0aGlzLmRlbGF5XG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGVsYXlNZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxuLyoqXG4gKiBSZWNlaXZlZCB0YWJsZSBzaG91bGQgZmFkZS5cbiAqIEBjbGFzcyBGYWRlVGFibGVNZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIEZhZGVUYWJsZU1lc3NhZ2UodmlzaWJsZSwgZGlyZWN0aW9uKSB7XG5cdHRoaXMudmlzaWJsZSA9IHZpc2libGU7XG5cdHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xufVxuXG5GYWRlVGFibGVNZXNzYWdlLlRZUEUgPSBcImZhZGVUYWJsZVwiO1xuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0VmlzaWJsZVxuICovXG5GYWRlVGFibGVNZXNzYWdlLnByb3RvdHlwZS5nZXRWaXNpYmxlID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnZpc2libGU7XG59XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXREaXJlY3Rpb25cbiAqL1xuRmFkZVRhYmxlTWVzc2FnZS5wcm90b3R5cGUuZ2V0RGlyZWN0aW9uID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmRpcmVjdGlvbjtcbn1cblxuLyoqXG4gKiBVbi1zZXJpYWxpemUuXG4gKiBAbWV0aG9kIHVuc2VyaWFsaXplXG4gKi9cbkZhZGVUYWJsZU1lc3NhZ2UucHJvdG90eXBlLnVuc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge1xuXHR0aGlzLnZpc2libGUgPSBkYXRhLnZpc2libGU7XG5cdHRoaXMuZGlyZWN0aW9uID0gZGF0YS5kaXJlY3Rpb247XG59XG5cbi8qKlxuICogU2VyaWFsaXplIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIHNlcmlhbGl6ZVxuICovXG5GYWRlVGFibGVNZXNzYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHtcblx0XHR2aXNpYmxlOiB0aGlzLnZpc2libGUsXG5cdFx0ZGlyZWN0aW9uOiB0aGlzLmRpcmVjdGlvblxuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZhZGVUYWJsZU1lc3NhZ2U7IiwiLyoqXG4gKiBQcm90b2NvbC5cbiAqIEBtb2R1bGUgcHJvdG9cbiAqL1xuXG4vKipcbiAqIFJlY2VpdmVkIHBsYXllciBoYXMgZm9sZGVkLlxuICogQGNsYXNzIEZvbGRDYXJkc01lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gRm9sZENhcmRzTWVzc2FnZShzZWF0SW5kZXgpIHtcblx0dGhpcy5zZWF0SW5kZXggPSBzZWF0SW5kZXg7XG59XG5cbkZvbGRDYXJkc01lc3NhZ2UuVFlQRSA9IFwiZm9sZENhcmRzXCI7XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRTZWF0SW5kZXhcbiAqL1xuRm9sZENhcmRzTWVzc2FnZS5wcm90b3R5cGUuZ2V0U2VhdEluZGV4ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnNlYXRJbmRleDtcbn1cblxuLyoqXG4gKiBVbi1zZXJpYWxpemUuXG4gKiBAbWV0aG9kIHVuc2VyaWFsaXplXG4gKi9cbkZvbGRDYXJkc01lc3NhZ2UucHJvdG90eXBlLnVuc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge1xuXHR0aGlzLnNlYXRJbmRleCA9IGRhdGEuc2VhdEluZGV4O1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZXJpYWxpemVcbiAqL1xuRm9sZENhcmRzTWVzc2FnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB7XG5cdFx0c2VhdEluZGV4OiB0aGlzLnNlYXRJbmRleFxuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZvbGRDYXJkc01lc3NhZ2U7IiwiLyoqXG4gKiBQcm90b2NvbC5cbiAqIEBtb2R1bGUgcHJvdG9cbiAqL1xuXG4vKipcbiAqIFJlY2VpdmVkIHdoZW4gPy5cbiAqIEBjbGFzcyBIYW5kSW5mb01lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gSGFuZEluZm9NZXNzYWdlKHRleHQsIGNvdW50ZG93bikge1xuXHR0aGlzLnRleHQgPSB0ZXh0O1xuXHR0aGlzLmNvdW50ZG93biA9IGNvdW50ZG93bjtcbn1cblxuSGFuZEluZm9NZXNzYWdlLlRZUEUgPSBcImhhbmRJbmZvXCI7XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRTZWF0SW5kZXhcbiAqL1xuSGFuZEluZm9NZXNzYWdlLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnRleHQ7XG59XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRWYWx1ZVxuICovXG5IYW5kSW5mb01lc3NhZ2UucHJvdG90eXBlLmdldENvdW50ZG93biA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5jb3VudGRvd247XG59XG5cbi8qKlxuICogVW4tc2VyaWFsaXplLlxuICogQG1ldGhvZCB1bnNlcmlhbGl6ZVxuICovXG5IYW5kSW5mb01lc3NhZ2UucHJvdG90eXBlLnVuc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge1xuXHR0aGlzLnRleHQgPSBkYXRhLnRleHQ7XG5cdHRoaXMuY291bnRkb3duID0gZGF0YS5jb3VudGRvd247XG59XG5cbi8qKlxuICogU2VyaWFsaXplIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIHNlcmlhbGl6ZVxuICovXG5IYW5kSW5mb01lc3NhZ2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4ge1xuXHRcdHRleHQ6IHRoaXMudGV4dCxcblx0XHRjb3VudGRvd246IHRoaXMuY291bnRkb3duXG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSGFuZEluZm9NZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgSW5pdE1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gSW5pdE1lc3NhZ2UodG9rZW4pIHtcblx0dGhpcy50b2tlbiA9IHRva2VuO1xuXHR0aGlzLnRhYmxlSWQgPSBudWxsO1xuXHR0aGlzLnZpZXdDYXNlID0gbnVsbDtcblx0dGhpcy50b3VybmFtZW50SWQgPSBudWxsO1xufVxuXG5Jbml0TWVzc2FnZS5UWVBFID0gXCJpbml0XCI7XG5cbi8qKlxuICogZ2V0IHRva2VuLlxuICogQG1ldGhvZCBnZXRUb2tlblxuICovXG5Jbml0TWVzc2FnZS5wcm90b3R5cGUuZ2V0VG9rZW4gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMudG9rZW47XG59XG5cbi8qKlxuICogU2V0IHRhYmxlIGlkLlxuICogQG1ldGhvZCBzZXRUYWJsZUlkXG4gKi9cbkluaXRNZXNzYWdlLnByb3RvdHlwZS5zZXRUYWJsZUlkID0gZnVuY3Rpb24oaWQpIHtcblx0dGhpcy50YWJsZUlkID0gaWQ7XG59XG5cbi8qKlxuICogR2V0IHRhYmxlIGlkLlxuICogQG1ldGhvZCBnZXRUYWJsZUlkXG4gKi9cbkluaXRNZXNzYWdlLnByb3RvdHlwZS5nZXRUYWJsZUlkID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnRhYmxlSWQ7XG59XG5cbi8qKlxuICogU2V0IHRhYmxlIGlkLlxuICogQG1ldGhvZCBzZXRUb3VybmFtZW50SWRcbiAqL1xuSW5pdE1lc3NhZ2UucHJvdG90eXBlLnNldFRvdXJuYW1lbnRJZCA9IGZ1bmN0aW9uKGlkKSB7XG5cdHRoaXMudG91cm5hbWVudElkID0gaWQ7XG59XG5cbi8qKlxuICogR2V0IHRhYmxlIGlkLlxuICogQG1ldGhvZCBnZXRUb3VybmFtZW50SWRcbiAqL1xuSW5pdE1lc3NhZ2UucHJvdG90eXBlLmdldFRvdXJuYW1lbnRJZCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy50b3VybmFtZW50SWQ7XG59XG5cbi8qKlxuICogU2V0IHZpZXcgY2FzZS5cbiAqIEBtZXRob2Qgc2V0VGFibGVJZFxuICovXG5Jbml0TWVzc2FnZS5wcm90b3R5cGUuc2V0Vmlld0Nhc2UgPSBmdW5jdGlvbih2aWV3Q2FzZSkge1xuXHR0aGlzLnZpZXdDYXNlID0gdmlld0Nhc2U7XG59XG5cbi8qKlxuICogR2V0IHZpZXcgY2FzZS5cbiAqIEBtZXRob2QgZ2V0VGFibGVJZFxuICovXG5Jbml0TWVzc2FnZS5wcm90b3R5cGUuZ2V0Vmlld0Nhc2UgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMudmlld0Nhc2U7XG59XG5cbi8qKlxuICogVW4tc2VyaWFsaXplLlxuICogQG1ldGhvZCB1bnNlcmlhbGl6ZS5cbiAqL1xuSW5pdE1lc3NhZ2UucHJvdG90eXBlLnVuc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge1xuXHR0aGlzLnRva2VuID0gZGF0YS50b2tlbjtcblx0dGhpcy50YWJsZUlkID0gZGF0YS50YWJsZUlkO1xuXHR0aGlzLnZpZXdDYXNlID0gZGF0YS52aWV3Q2FzZTtcblx0dGhpcy50b3VybmFtZW50SWQgPSBkYXRhLnRvdXJuYW1lbnRJZDtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgbWVzc2FnZS5cbiAqIEBtZXRob2Qgc2VyaWFsaXplXG4gKi9cbkluaXRNZXNzYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHtcblx0XHR0b2tlbjogdGhpcy50b2tlbixcblx0XHR0YWJsZUlkOiB0aGlzLnRhYmxlSWQsXG5cdFx0dmlld0Nhc2U6IHRoaXMudmlld0Nhc2UsXG5cdFx0dG91cm5hbWVudElkOiB0aGlzLnRvdXJuYW1lbnRJZFxuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEluaXRNZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxuLyoqXG4gKiBSZWNlaXZlZCB3aGVuIGludGVyZmFjZSBzdGF0ZSBoYXMgY2hhbmdlZC5cbiAqIEBjbGFzcyBJbnRlcmZhY2VTdGF0ZU1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gSW50ZXJmYWNlU3RhdGVNZXNzYWdlKHZpc2libGVCdXR0b25zKSB7XG5cdGlmICghdmlzaWJsZUJ1dHRvbnMpXG5cdFx0dmlzaWJsZUJ1dHRvbnMgPSBbXTtcblxuXHR0aGlzLnZpc2libGVCdXR0b25zID0gdmlzaWJsZUJ1dHRvbnM7XG59XG5cbkludGVyZmFjZVN0YXRlTWVzc2FnZS5UWVBFID0gXCJpbnRlcmZhY2VTdGF0ZVwiO1xuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0VmlzaWJsZUJ1dHRvbnNcbiAqL1xuSW50ZXJmYWNlU3RhdGVNZXNzYWdlLnByb3RvdHlwZS5nZXRWaXNpYmxlQnV0dG9ucyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy52aXNpYmxlQnV0dG9ucztcbn1cblxuLyoqXG4gKiBBZGQgYSBidXR0b24gdG8gYmUgc2hvd24uXG4gKiBAbWV0aG9kIGFkZFZpc2libGVCdXR0b25cbiAqL1xuSW50ZXJmYWNlU3RhdGVNZXNzYWdlLnByb3RvdHlwZS5hZGRWaXNpYmxlQnV0dG9uPWZ1bmN0aW9uKGJ1dHRvbklkKSB7XG5cdHRoaXMudmlzaWJsZUJ1dHRvbnMucHVzaChidXR0b25JZCk7XG59XG5cbi8qKlxuICogVW4tc2VyaWFsaXplLlxuICogQG1ldGhvZCB1bnNlcmlhbGl6ZVxuICovXG5JbnRlcmZhY2VTdGF0ZU1lc3NhZ2UucHJvdG90eXBlLnVuc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge1xuXHR0aGlzLnZpc2libGVCdXR0b25zID0gZGF0YS52aXNpYmxlQnV0dG9ucztcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgbWVzc2FnZS5cbiAqIEBtZXRob2Qgc2VyaWFsaXplXG4gKi9cbkludGVyZmFjZVN0YXRlTWVzc2FnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB7XG5cdFx0dmlzaWJsZUJ1dHRvbnM6IHRoaXMudmlzaWJsZUJ1dHRvbnNcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmZhY2VTdGF0ZU1lc3NhZ2U7IiwiLyoqXG4gKiBQcm90b2NvbC5cbiAqIEBtb2R1bGUgcHJvdG9cbiAqL1xuXG4vKipcbiAqIFJlY2VpdmVkIHdoZW4gcGxheWVyIGhhcyBwbGFjZWQgYSBiZXQuXG4gKiBAY2xhc3MgUGF5T3V0TWVzc2FnZVxuICovXG5mdW5jdGlvbiBQYXlPdXRNZXNzYWdlKCkge1xuXHR0aGlzLnZhbHVlcyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbn1cblxuUGF5T3V0TWVzc2FnZS5UWVBFID0gXCJwYXlPdXRcIjtcblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldFZhbHVlc1xuICovXG5QYXlPdXRNZXNzYWdlLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMudmFsdWVzO1xufVxuXG4vKipcbiAqIFNldCB2YWx1ZSBhdC5cbiAqIEBtZXRob2Qgc2V0VmFsdWVBdFxuICovXG5QYXlPdXRNZXNzYWdlLnByb3RvdHlwZS5zZXRWYWx1ZUF0ID0gZnVuY3Rpb24oc2VhdEluZGV4LCB2YWx1ZSkge1xuXHR0aGlzLnZhbHVlc1tzZWF0SW5kZXhdID0gdmFsdWU7XG59XG5cbi8qKlxuICogVW4tc2VyaWFsaXplLlxuICogQG1ldGhvZCB1bnNlcmlhbGl6ZVxuICovXG5QYXlPdXRNZXNzYWdlLnByb3RvdHlwZS51bnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLnZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHRcdHRoaXMudmFsdWVzW2ldID0gZGF0YS52YWx1ZXNbaV07XG5cdH1cbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgbWVzc2FnZS5cbiAqIEBtZXRob2Qgc2VyaWFsaXplXG4gKi9cblBheU91dE1lc3NhZ2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4ge1xuXHRcdHZhbHVlczogdGhpcy52YWx1ZXNcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYXlPdXRNZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxudmFyIENhcmREYXRhID0gcmVxdWlyZShcIi4uL2RhdGEvQ2FyZERhdGFcIik7XG5cbi8qKlxuICogU2hvdyBwb2NrZXQgY2FyZHMuXG4gKiBAY2xhc3MgUG9ja2V0Q2FyZHNNZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIFBvY2tldENhcmRzTWVzc2FnZShzZWF0SW5kZXgpIHtcblx0dGhpcy5hbmltYXRlID0gZmFsc2U7XG5cdHRoaXMuY2FyZHMgPSBbXTtcblx0dGhpcy5maXJzdEluZGV4ID0gMDtcblx0dGhpcy5zZWF0SW5kZXggPSBzZWF0SW5kZXg7XG59XG5cblBvY2tldENhcmRzTWVzc2FnZS5UWVBFID0gXCJwb2NrZXRDYXJkc1wiO1xuXG4vKipcbiAqIEFuaW1hdGlvbj9cbiAqIEBtZXRob2Qgc2V0QW5pbWF0ZVxuICovXG5Qb2NrZXRDYXJkc01lc3NhZ2UucHJvdG90eXBlLnNldEFuaW1hdGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHR0aGlzLmFuaW1hdGUgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBTZXQgZmlyc3QgaW5kZXguXG4gKiBAbWV0aG9kIHNldEZpcnN0SW5kZXhcbiAqL1xuUG9ja2V0Q2FyZHNNZXNzYWdlLnByb3RvdHlwZS5zZXRGaXJzdEluZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcblx0dGhpcy5maXJzdEluZGV4ID0gaW5kZXg7XG59XG5cbi8qKlxuICogR2V0IGFycmF5IG9mIENhcmREYXRhLlxuICogQG1ldGhvZCBnZXRDYXJkc1xuICovXG5Qb2NrZXRDYXJkc01lc3NhZ2UucHJvdG90eXBlLmdldENhcmRzID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmNhcmRzO1xufVxuXG4vKipcbiAqIEFkZCBhIGNhcmQuXG4gKiBAbWV0aG9kIGFkZENhcmRcbiAqL1xuUG9ja2V0Q2FyZHNNZXNzYWdlLnByb3RvdHlwZS5hZGRDYXJkID0gZnVuY3Rpb24oYykge1xuXHR0aGlzLmNhcmRzLnB1c2goYyk7XG59XG5cbi8qKlxuICogR2V0IGZpcnN0IGluZGV4LlxuICogQG1ldGhvZCBnZXRGaXJzdEluZGV4XG4gKi9cblBvY2tldENhcmRzTWVzc2FnZS5wcm90b3R5cGUuZ2V0Rmlyc3RJbmRleCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5maXJzdEluZGV4O1xufVxuXG4vKipcbiAqIEdldCBzZWF0IGluZGV4LlxuICogQG1ldGhvZCBnZXRTZWF0SW5kZXhcbiAqL1xuUG9ja2V0Q2FyZHNNZXNzYWdlLnByb3RvdHlwZS5nZXRTZWF0SW5kZXggPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuc2VhdEluZGV4O1xufVxuXG4vKipcbiAqIFVuLXNlcmlhbGl6ZS5cbiAqIEBtZXRob2QgdW5zZXJpYWxpemUuXG4gKi9cblBvY2tldENhcmRzTWVzc2FnZS5wcm90b3R5cGUudW5zZXJpYWxpemUgPSBmdW5jdGlvbihkYXRhKSB7XG5cdHZhciBpO1xuXG5cdHRoaXMuYW5pbWF0ZSA9IGRhdGEuYW5pbWF0ZTtcblx0dGhpcy5maXJzdEluZGV4ID0gcGFyc2VJbnQoZGF0YS5maXJzdEluZGV4KTtcblx0dGhpcy5jYXJkcyA9IFtdO1xuXHR0aGlzLnNlYXRJbmRleCA9IGRhdGEuc2VhdEluZGV4O1xuXG5cdGZvciAoaSA9IDA7IGkgPCBkYXRhLmNhcmRzLmxlbmd0aDsgaSsrKVxuXHRcdHRoaXMuY2FyZHMucHVzaChuZXcgQ2FyZERhdGEoZGF0YS5jYXJkc1tpXSkpO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZXJpYWxpemVcbiAqL1xuUG9ja2V0Q2FyZHNNZXNzYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0dmFyIGNhcmRzID0gW107XG5cblx0Zm9yIChpID0gMDsgaSA8IHRoaXMuY2FyZHMubGVuZ3RoOyBpKyspXG5cdFx0Y2FyZHMucHVzaCh0aGlzLmNhcmRzW2ldLmdldFZhbHVlKCkpO1xuXG5cdHJldHVybiB7XG5cdFx0YW5pbWF0ZTogdGhpcy5hbmltYXRlLFxuXHRcdGZpcnN0SW5kZXg6IHRoaXMuZmlyc3RJbmRleCxcblx0XHRjYXJkczogY2FyZHMsXG5cdFx0c2VhdEluZGV4OiB0aGlzLnNlYXRJbmRleFxuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvY2tldENhcmRzTWVzc2FnZTsiLCIvKipcbiAqIFByb3RvY29sLlxuICogQG1vZHVsZSBwcm90b1xuICovXG5cbi8qKlxuICogUmVjZWl2ZWQgd2hlbiBwbGF5ZXIgcG90IGhhcyBjaGFuZ2VkLlxuICogQGNsYXNzIFBvdE1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gUG90TWVzc2FnZSh2YWx1ZXMpIHtcblx0dGhpcy52YWx1ZXMgPSB2YWx1ZXMgPT0gbnVsbCA/IG5ldyBBcnJheSgpIDogdmFsdWVzO1xufVxuXG5Qb3RNZXNzYWdlLlRZUEUgPSBcInBvdFwiO1xuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0VmFsdWVzXG4gKi9cblBvdE1lc3NhZ2UucHJvdG90eXBlLmdldFZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy52YWx1ZXM7XG59XG5cbi8qKlxuICogVW4tc2VyaWFsaXplLlxuICogQG1ldGhvZCB1bnNlcmlhbGl6ZVxuICovXG5Qb3RNZXNzYWdlLnByb3RvdHlwZS51bnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0dGhpcy52YWx1ZXMgPSBkYXRhLnZhbHVlcztcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgbWVzc2FnZS5cbiAqIEBtZXRob2Qgc2VyaWFsaXplXG4gKi9cblBvdE1lc3NhZ2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4ge1xuXHRcdHZhbHVlczogdGhpcy52YWx1ZXNcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQb3RNZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxuLyoqXG4gKiBSZWNlaXZlZCB3aGVuIFByZSB0b3VybmFtZW50IGluZm8gbWVzc2FnZSBpcyBkaXNwYXRjaGVkLlxuICogQGNsYXNzIFByZVRvdXJuYW1lbnRJbmZvTWVzc2FnZVxuICovXG5mdW5jdGlvbiBQcmVUb3VybmFtZW50SW5mb01lc3NhZ2UodGV4dCwgY291bnRkb3duKSB7XG5cdHRoaXMudGV4dCA9IHRleHQ7XG5cdHRoaXMuY291bnRkb3duID0gY291bnRkb3duO1xufVxuXG5QcmVUb3VybmFtZW50SW5mb01lc3NhZ2UuVFlQRSA9IFwicHJlVG91cm5hbWVudEluZm9cIjtcblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldFRleHRcbiAqL1xuUHJlVG91cm5hbWVudEluZm9NZXNzYWdlLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnRleHQ7XG59XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRDb3VudGRvd25cbiAqL1xuUHJlVG91cm5hbWVudEluZm9NZXNzYWdlLnByb3RvdHlwZS5nZXRDb3VudGRvd24gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuY291bnRkb3duO1xufVxuXG4vKipcbiAqIFVuLXNlcmlhbGl6ZS5cbiAqIEBtZXRob2QgdW5zZXJpYWxpemVcbiAqL1xuUHJlVG91cm5hbWVudEluZm9NZXNzYWdlLnByb3RvdHlwZS51bnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0dGhpcy50ZXh0ID0gZGF0YS50ZXh0O1xuXHR0aGlzLmNvdW50ZG93biA9IGRhdGEuY291bnRkb3duO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZXJpYWxpemVcbiAqL1xuUHJlVG91cm5hbWVudEluZm9NZXNzYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuY291bnRkb3duIDwgMClcblx0XHR0aGlzLmNvdW50ZG93biA9IDA7XG5cblx0cmV0dXJuIHtcblx0XHR0ZXh0OiB0aGlzLnRleHQsXG5cdFx0Y291bnRkb3duOiB0aGlzLmNvdW50ZG93blxuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByZVRvdXJuYW1lbnRJbmZvTWVzc2FnZTsiLCIvKipcbiAqIFByb3RvY29sLlxuICogQG1vZHVsZSBwcm90b1xuICovXG5cbi8qKlxuICogUmVjZWl2ZWQgd2hlbiA/LlxuICogQGNsYXNzIFByZXNldEJ1dHRvbkNsaWNrTWVzc2FnZVxuICovXG5mdW5jdGlvbiBQcmVzZXRCdXR0b25DbGlja01lc3NhZ2UoYnV0dG9uLCB2YWx1ZSkge1xuXHRpZiAoIXZhbHVlKVxuXHRcdHZhbHVlID0gbnVsbDtcblxuXHR0aGlzLmJ1dHRvbiA9IGJ1dHRvbjtcblx0dGhpcy52YWx1ZSA9IHZhbHVlO1xufVxuXG5QcmVzZXRCdXR0b25DbGlja01lc3NhZ2UuVFlQRSA9IFwicHJlc2V0QnV0dG9uQ2xpY2tcIjtcblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldEJ1dHRvblxuICovXG5QcmVzZXRCdXR0b25DbGlja01lc3NhZ2UucHJvdG90eXBlLmdldEJ1dHRvbiA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5idXR0b247XG59XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRWYWx1ZVxuICovXG5QcmVzZXRCdXR0b25DbGlja01lc3NhZ2UucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnZhbHVlO1xufVxuXG4vKipcbiAqIFVuLXNlcmlhbGl6ZS5cbiAqIEBtZXRob2QgdW5zZXJpYWxpemVcbiAqL1xuUHJlc2V0QnV0dG9uQ2xpY2tNZXNzYWdlLnByb3RvdHlwZS51bnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0dGhpcy5idXR0b24gPSBkYXRhLmJ1dHRvbjtcblx0dGhpcy52YWx1ZSA9IGRhdGEudmFsdWU7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIHNlcmlhbGl6ZVxuICovXG5QcmVzZXRCdXR0b25DbGlja01lc3NhZ2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4ge1xuXHRcdGJ1dHRvbjogdGhpcy5idXR0b24sXG5cdFx0dmFsdWU6IHRoaXMudmFsdWVcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQcmVzZXRCdXR0b25DbGlja01lc3NhZ2U7IiwiLyoqXG4gKiBQcm90b2NvbC5cbiAqIEBtb2R1bGUgcHJvdG9cbiAqL1xuXG52YXIgQnV0dG9uRGF0YSA9IHJlcXVpcmUoXCIuLi9kYXRhL0J1dHRvbkRhdGFcIik7XG5cbi8qKlxuICogUmVjZWl2ZWQgd2hlbiA/LlxuICogQGNsYXNzIFByZXNldEJ1dHRvbnNNZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIFByZXNldEJ1dHRvbnNNZXNzYWdlKCkge1xuXHR0aGlzLmJ1dHRvbnMgPSBuZXcgQXJyYXkoNyk7XG5cdHRoaXMuY3VycmVudCA9IG51bGw7XG59XG5cblByZXNldEJ1dHRvbnNNZXNzYWdlLlRZUEUgPSBcInByZXNldEJ1dHRvbnNcIjtcblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldEJ1dHRvbnNcbiAqL1xuUHJlc2V0QnV0dG9uc01lc3NhZ2UucHJvdG90eXBlLmdldEJ1dHRvbnMgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuYnV0dG9ucztcbn1cblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldEN1cnJlbnRcbiAqL1xuUHJlc2V0QnV0dG9uc01lc3NhZ2UucHJvdG90eXBlLmdldEN1cnJlbnQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuY3VycmVudDtcbn1cblxuLyoqXG4gKiBTZXQgYnV0b24gZGF0YS5cbiAqIEBtZXRob2RcbiAqL1xuUHJlc2V0QnV0dG9uc01lc3NhZ2UucHJvdG90eXBlLnNldEJ1dHRvbkRhdGFBdCA9IGZ1bmN0aW9uKGluZGV4LCBidXR0b25EYXRhKSB7XG5cdHRoaXMuYnV0dG9uc1tpbmRleF0gPSBidXR0b25EYXRhO1xufVxuXG4vKipcbiAqIFVuLXNlcmlhbGl6ZS5cbiAqIEBtZXRob2QgdW5zZXJpYWxpemVcbiAqL1xuUHJlc2V0QnV0dG9uc01lc3NhZ2UucHJvdG90eXBlLnVuc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge1xuXHR0aGlzLmN1cnJlbnQgPSBkYXRhLmN1cnJlbnQ7XG5cblx0dGhpcy5idXR0b25zID0gbmV3IEFycmF5KCk7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmJ1dHRvbnMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgYnV0dG9uID0gZGF0YS5idXR0b25zW2ldO1xuXHRcdHZhciBidXR0b25EYXRhID0gbnVsbDtcblxuXHRcdGlmIChidXR0b24gIT0gbnVsbCkge1xuXHRcdFx0YnV0dG9uRGF0YSA9IG5ldyBCdXR0b25EYXRhKGJ1dHRvbi5idXR0b24sIGJ1dHRvbi52YWx1ZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5idXR0b25zLnB1c2goYnV0dG9uRGF0YSk7XG5cdH1cbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgbWVzc2FnZS5cbiAqIEBtZXRob2Qgc2VyaWFsaXplXG4gKi9cblByZXNldEJ1dHRvbnNNZXNzYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9iamVjdCA9IHtcblx0XHRidXR0b25zOiBbXSxcblx0XHRjdXJyZW50OiB0aGlzLmN1cnJlbnRcblx0fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYnV0dG9ucy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBidXR0b25EYXRhID0gdGhpcy5idXR0b25zW2ldO1xuXHRcdGlmIChidXR0b25EYXRhICE9IG51bGwpXG5cdFx0XHRvYmplY3QuYnV0dG9ucy5wdXNoKHtcblx0XHRcdFx0YnV0dG9uOiBidXR0b25EYXRhLmJ1dHRvbixcblx0XHRcdFx0dmFsdWU6IGJ1dHRvbkRhdGEudmFsdWVcblx0XHRcdH0pO1xuXG5cdFx0ZWxzZVxuXHRcdFx0b2JqZWN0LmJ1dHRvbnMucHVzaChudWxsKTtcblx0fVxuXG5cdHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHJlc2V0QnV0dG9uc01lc3NhZ2U7IiwiLyoqXG4gKiBQcm90b2NvbC5cbiAqIEBtb2R1bGUgcHJvdG9cbiAqL1xuXG4vKipcbiAqIE1lc3NhZ2UgaW5kaWNhdGluZyB0aGF0IHRoZSB1c2VyIGhhcyBjbGlja2VkIGEgc2VhdC5cbiAqIEBjbGFzcyBTZWF0Q2xpY2tNZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIFNlYXRDbGlja01lc3NhZ2Uoc2VhdEluZGV4KSB7XG5cdHRoaXMuc2VhdEluZGV4PXNlYXRJbmRleDtcbn1cblxuU2VhdENsaWNrTWVzc2FnZS5UWVBFID0gXCJzZWF0Q2xpY2tcIjtcblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldFNlYXRJbmRleFxuICovXG5TZWF0Q2xpY2tNZXNzYWdlLnByb3RvdHlwZS5nZXRTZWF0SW5kZXggPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuc2VhdEluZGV4O1xufVxuXG4vKipcbiAqIFVuLXNlcmlhbGl6ZS5cbiAqIEBtZXRob2QgdW5zZXJpYWxpemUuXG4gKi9cblNlYXRDbGlja01lc3NhZ2UucHJvdG90eXBlLnVuc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge1xuXHR0aGlzLnNlYXRJbmRleCA9IGRhdGEuc2VhdEluZGV4O1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZXJpYWxpemVcbiAqL1xuU2VhdENsaWNrTWVzc2FnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB7XG5cdFx0c2VhdEluZGV4OiB0aGlzLnNlYXRJbmRleCxcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZWF0Q2xpY2tNZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxuLyoqXG4gKiBTaG93IHVzZXJuYW1lIGFuZCBjaGlwcyBvbiBzZWF0LlxuICogQGNsYXNzIFNlYXRJbmZvTWVzc2FnZVxuICovXG5mdW5jdGlvbiBTZWF0SW5mb01lc3NhZ2Uoc2VhdEluZGV4KSB7XG5cdHRoaXMuc2VhdEluZGV4ID0gc2VhdEluZGV4O1xuXHR0aGlzLmFjdGl2ZSA9IHRydWU7XG5cdHRoaXMuc2l0b3V0ID0gZmFsc2U7XG5cdHRoaXMubmFtZSA9IFwiXCI7XG5cdHRoaXMuY2hpcHMgPSBcIlwiO1xufVxuXG5TZWF0SW5mb01lc3NhZ2UuVFlQRSA9IFwic2VhdEluZm9cIjtcblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldFNlYXRJbmRleFxuICovXG5TZWF0SW5mb01lc3NhZ2UucHJvdG90eXBlLmdldFNlYXRJbmRleCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5zZWF0SW5kZXg7XG59XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXROYW1lXG4gKi9cblNlYXRJbmZvTWVzc2FnZS5wcm90b3R5cGUuZ2V0TmFtZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5uYW1lO1xufVxuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0Q2hpcHNcbiAqL1xuU2VhdEluZm9NZXNzYWdlLnByb3RvdHlwZS5nZXRDaGlwcyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5jaGlwcztcbn1cblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGlzU2l0b3V0XG4gKi9cblNlYXRJbmZvTWVzc2FnZS5wcm90b3R5cGUuaXNTaXRvdXQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuc2l0b3V0O1xufVxuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgaXNBY3RpdmVcbiAqL1xuU2VhdEluZm9NZXNzYWdlLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5hY3RpdmU7XG59XG5cbi8qKlxuICogU2V0dGVyLlxuICogQG1ldGhvZCBzZXRBY3RpdmVcbiAqL1xuU2VhdEluZm9NZXNzYWdlLnByb3RvdHlwZS5zZXRBY3RpdmUgPSBmdW5jdGlvbih2KSB7XG5cdHRoaXMuYWN0aXZlID0gdjtcbn1cblxuLyoqXG4gKiBTZXQgc2l0b3V0LlxuICogQG1ldGhvZCBzZXRTaXRvdXRcbiAqL1xuU2VhdEluZm9NZXNzYWdlLnByb3RvdHlwZS5zZXRTaXRvdXQgPSBmdW5jdGlvbih2KSB7XG5cdHRoaXMuc2l0b3V0ID0gdjtcbn1cblxuLyoqXG4gKiBTZXR0ZXIuXG4gKiBAbWV0aG9kIHNldE5hbWVcbiAqL1xuU2VhdEluZm9NZXNzYWdlLnByb3RvdHlwZS5zZXROYW1lID0gZnVuY3Rpb24odikge1xuXHR0aGlzLm5hbWUgPSB2O1xufVxuXG4vKipcbiAqIFNldHRlci5cbiAqIEBtZXRob2Qgc2V0Q2hpcHNcbiAqL1xuU2VhdEluZm9NZXNzYWdlLnByb3RvdHlwZS5zZXRDaGlwcyA9IGZ1bmN0aW9uKHYpIHtcblx0dGhpcy5jaGlwcyA9IHY7XG59XG5cbi8qKlxuICogVW4tc2VyaWFsaXplLlxuICogQG1ldGhvZCB1bnNlcmlhbGl6ZVxuICovXG5TZWF0SW5mb01lc3NhZ2UucHJvdG90eXBlLnVuc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge1xuXHR0aGlzLnNlYXRJbmRleCA9IGRhdGEuc2VhdEluZGV4O1xuXHR0aGlzLm5hbWUgPSBkYXRhLm5hbWU7XG5cdHRoaXMuY2hpcHMgPSBkYXRhLmNoaXBzO1xuXHR0aGlzLnNpdG91dCA9IGRhdGEuc2l0b3V0O1xuXHR0aGlzLmFjdGl2ZSA9IGRhdGEuYWN0aXZlO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZXJpYWxpemVcbiAqL1xuU2VhdEluZm9NZXNzYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHtcblx0XHRzZWF0SW5kZXg6IHRoaXMuc2VhdEluZGV4LFxuXHRcdG5hbWU6IHRoaXMubmFtZSxcblx0XHRjaGlwczogdGhpcy5jaGlwcyxcblx0XHRzaXRvdXQ6IHRoaXMuc2l0b3V0LFxuXHRcdGFjdGl2ZTogdGhpcy5hY3RpdmVcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZWF0SW5mb01lc3NhZ2U7IiwiLyoqXG4gKiBQcm90b2NvbC5cbiAqIEBtb2R1bGUgcHJvdG9cbiAqL1xuXG4vKipcbiAqIFNob3cgZGlhbG9nLCBmb3IgZS5nLiBidXkgaW4uXG4gKiBAY2xhc3MgU2hvd0RpYWxvZ01lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gU2hvd0RpYWxvZ01lc3NhZ2UoKSB7XG5cdHRoaXMudGV4dCA9IFwiXCI7XG5cdHRoaXMuYnV0dG9ucyA9IFtdO1xuXHR0aGlzLmRlZmF1bHRWYWx1ZSA9IG51bGw7XG59XG5cblNob3dEaWFsb2dNZXNzYWdlLlRZUEUgPSBcInNob3dEaWFsb2dcIjtcblxuLyoqXG4gKiBBZGQgYSBidXR0b24gdG8gdGhlIGRpYWxvZy5cbiAqIEBtZXRob2QgYWRkQnV0dG9uXG4gKi9cblNob3dEaWFsb2dNZXNzYWdlLnByb3RvdHlwZS5hZGRCdXR0b24gPSBmdW5jdGlvbihidXR0b24pIHtcblx0dGhpcy5idXR0b25zLnB1c2goYnV0dG9uKTtcbn1cblxuLyoqXG4gKiBHZXQgdGV4dCBvZiB0aGUgZGlhbG9nLlxuICogQG1ldGhvZCBnZXRUZXh0XG4gKi9cblNob3dEaWFsb2dNZXNzYWdlLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnRleHQ7XG59XG5cbi8qKlxuICogR2V0IGFycmF5IG9mIEJ1dHRvbkRhdGEgdG8gYmUgc2hvd24gaW4gdGhlIGRpYWxvZy5cbiAqIEBtZXRob2QgZ2V0QnV0dG9uc1xuICovXG5TaG93RGlhbG9nTWVzc2FnZS5wcm90b3R5cGUuZ2V0QnV0dG9ucyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5idXR0b25zO1xufVxuXG4vKipcbiAqIEdldCBkZWZhdWx0IHZhbHVlLlxuICogQG1ldGhvZCBnZXRCdXR0b25zXG4gKi9cblNob3dEaWFsb2dNZXNzYWdlLnByb3RvdHlwZS5nZXREZWZhdWx0VmFsdWUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuZGVmYXVsdFZhbHVlO1xufVxuXG4vKipcbiAqIFNldCBkZWZhdWx0IHZhbHVlLlxuICogQG1ldGhvZCBzZXREZWZhdWx0VmFsdWVcbiAqL1xuU2hvd0RpYWxvZ01lc3NhZ2UucHJvdG90eXBlLnNldERlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uKHYpIHtcblx0dGhpcy5kZWZhdWx0VmFsdWU9djtcbn1cblxuLyoqXG4gKiBTZXQgdGV4dCBpbiB0aGUgZGlhbG9nLlxuICogQG1ldGhvZCBzZXRUZXh0XG4gKi9cblNob3dEaWFsb2dNZXNzYWdlLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuXHR0aGlzLnRleHQgPSB0ZXh0O1xufVxuXG4vKipcbiAqIFVuLXNlcmlhbGl6ZS5cbiAqIEBtZXRob2QgdW5zZXJpYWxpemUuXG4gKi9cblNob3dEaWFsb2dNZXNzYWdlLnByb3RvdHlwZS51bnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0dGhpcy50ZXh0ID0gZGF0YS50ZXh0O1xuXHR0aGlzLmJ1dHRvbnMgPSBkYXRhLmJ1dHRvbnM7XG5cdHRoaXMuZGVmYXVsdFZhbHVlID0gZGF0YS5kZWZhdWx0VmFsdWU7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIHNlcmlhbGl6ZVxuICovXG5TaG93RGlhbG9nTWVzc2FnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB7XG5cdFx0dGV4dDogdGhpcy50ZXh0LFxuXHRcdGJ1dHRvbnM6IHRoaXMuYnV0dG9ucyxcblx0XHRkZWZhdWx0VmFsdWU6IHRoaXMuZGVmYXVsdFZhbHVlXG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hvd0RpYWxvZ01lc3NhZ2U7IiwiLyoqXG4gKiBQcm90b2NvbC5cbiAqIEBtb2R1bGUgcHJvdG9cbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBTdGF0ZUNvbXBsZXRlTWVzc2FnZVxuICovXG5mdW5jdGlvbiBTdGF0ZUNvbXBsZXRlTWVzc2FnZSgpIHt9XG5cblN0YXRlQ29tcGxldGVNZXNzYWdlLlRZUEUgPSBcInN0YXRlQ29tcGxldGVcIjtcblxuLyoqXG4gKiBVbi1zZXJpYWxpemUuXG4gKiBAbWV0aG9kIHVuc2VyaWFsaXplLlxuICovXG5TdGF0ZUNvbXBsZXRlTWVzc2FnZS5wcm90b3R5cGUudW5zZXJpYWxpemUgPSBmdW5jdGlvbihkYXRhKSB7fVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZXJpYWxpemVcbiAqL1xuU3RhdGVDb21wbGV0ZU1lc3NhZ2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4ge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVDb21wbGV0ZU1lc3NhZ2U7IiwiLyoqXG4gKiBQcm90b2NvbC5cbiAqIEBtb2R1bGUgcHJvdG9cbiAqL1xuXG4vKipcbiAqIFJlY2VpdmVkIHdoZW4gdGFibGUgYnV0dG9uIGNsaWNrZWQuXG4gKiBAY2xhc3MgVGFibGVCdXR0b25DbGlja01lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gVGFibGVCdXR0b25DbGlja01lc3NhZ2UodGFibGVJbmRleCkge1xuXHR0aGlzLnRhYmxlSW5kZXggPSB0YWJsZUluZGV4O1xufVxuXG5UYWJsZUJ1dHRvbkNsaWNrTWVzc2FnZS5UWVBFID0gXCJ0YWJsZUJ1dHRvbkNsaWNrXCI7XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRUYWJsZUluZGV4XG4gKi9cblRhYmxlQnV0dG9uQ2xpY2tNZXNzYWdlLnByb3RvdHlwZS5nZXRUYWJsZUluZGV4ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnRhYmxlSW5kZXg7XG59XG5cbi8qKlxuICogVW4tc2VyaWFsaXplLlxuICogQG1ldGhvZCB1bnNlcmlhbGl6ZVxuICovXG5UYWJsZUJ1dHRvbkNsaWNrTWVzc2FnZS5wcm90b3R5cGUudW5zZXJpYWxpemUgPSBmdW5jdGlvbihkYXRhKSB7XG5cdHRoaXMudGFibGVJbmRleCA9IGRhdGEudGFibGVJbmRleDtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgbWVzc2FnZS5cbiAqIEBtZXRob2Qgc2VyaWFsaXplXG4gKi9cblRhYmxlQnV0dG9uQ2xpY2tNZXNzYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHtcblx0XHR0YWJsZUluZGV4OiB0aGlzLnRhYmxlSW5kZXhcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUYWJsZUJ1dHRvbkNsaWNrTWVzc2FnZTsiLCIvKipcbiAqIFByb3RvY29sLlxuICogQG1vZHVsZSBwcm90b1xuICovXG5cbi8qKlxuICogUmVjZWl2ZWQgd2hlbiA/LlxuICogQGNsYXNzIFRhYmxlQnV0dG9uc01lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gVGFibGVCdXR0b25zTWVzc2FnZSgpIHtcblx0dGhpcy5lbmFibGVkID0gbmV3IEFycmF5KCk7XG5cdHRoaXMuY3VycmVudEluZGV4ID0gLTE7XG5cdHRoaXMucGxheWVySW5kZXggPSAtMTtcblx0dGhpcy5pbmZvTGluayA9IFwiXCI7XG59XG5cblRhYmxlQnV0dG9uc01lc3NhZ2UuVFlQRSA9IFwidGFibGVCdXR0b25zXCI7XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRFbmFibGVkXG4gKi9cblRhYmxlQnV0dG9uc01lc3NhZ2UucHJvdG90eXBlLmdldEVuYWJsZWQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuZW5hYmxlZDtcbn1cblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldEN1cnJlbnRJbmRleFxuICovXG5UYWJsZUJ1dHRvbnNNZXNzYWdlLnByb3RvdHlwZS5nZXRDdXJyZW50SW5kZXggPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuY3VycmVudEluZGV4O1xufVxuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0UGxheWVySW5kZXhcbiAqL1xuVGFibGVCdXR0b25zTWVzc2FnZS5wcm90b3R5cGUuZ2V0UGxheWVySW5kZXggPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMucGxheWVySW5kZXg7XG59XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRJbmZvTGlua1xuICovXG5UYWJsZUJ1dHRvbnNNZXNzYWdlLnByb3RvdHlwZS5nZXRJbmZvTGluayA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5pbmZvTGluaztcbn1cblxuLyoqXG4gKiBVbi1zZXJpYWxpemUuXG4gKiBAbWV0aG9kIHVuc2VyaWFsaXplXG4gKi9cblRhYmxlQnV0dG9uc01lc3NhZ2UucHJvdG90eXBlLnVuc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge1xuXHR0aGlzLnBsYXllckluZGV4ID0gZGF0YS5wbGF5ZXJJbmRleDtcblx0dGhpcy5jdXJyZW50SW5kZXggPSBkYXRhLmN1cnJlbnRJbmRleDtcblx0dGhpcy5pbmZvTGluayA9IGRhdGEuaW5mb0xpbms7XG5cblx0dGhpcy5lbmFibGVkID0gbmV3IEFycmF5KCk7XG5cdGZvcih2YXIgaSA9IDA7IGkgPCBkYXRhLmVuYWJsZWQubGVuZ3RoOyBpKyspXG5cdFx0dGhpcy5lbmFibGVkLnB1c2goZGF0YS5lbmFibGVkW2ldKTtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgbWVzc2FnZS5cbiAqIEBtZXRob2Qgc2VyaWFsaXplXG4gKi9cblRhYmxlQnV0dG9uc01lc3NhZ2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb2JqZWN0ID0ge1xuXHRcdGN1cnJlbnRJbmRleDogdGhpcy5jdXJyZW50SW5kZXgsXG5cdFx0cGxheWVySW5kZXg6IHRoaXMucGxheWVySW5kZXgsXG5cdFx0ZW5hYmxlZDogW10sXG5cdFx0aW5mb0xpbms6IHRoaXMuaW5mb0xpbmtcblx0fTtcblxuXHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5lbmFibGVkLmxlbmd0aDsgaSsrKVxuXHRcdG9iamVjdC5lbmFibGVkLnB1c2godGhpcy5lbmFibGVkW2ldKTtcblxuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRhYmxlQnV0dG9uc01lc3NhZ2U7IiwiLyoqXG4gKiBQcm90b2NvbC5cbiAqIEBtb2R1bGUgcHJvdG9cbiAqL1xuXG4vKipcbiAqIFNldCB0aGUgYmlnIHRleHQgdGhhdCBjYWxscyBmb3IgdXNlciBhY3Rpb24sXG4gKiBzdWNoIGFzIFwiV2VsY29tZSwgcGxlYXNlIHRha2UgYSBzZWF0IVwiLlxuICogQGNsYXNzIFRhYmxlSW5mb01lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gVGFibGVJbmZvTWVzc2FnZSh0ZXh0LCBjb3VudGRvd24pIHtcblx0dGhpcy5jb3VudGRvd24gPSBjb3VudGRvd247XG5cdHRoaXMudGV4dCA9IHRleHQ7XG5cdHRoaXMuc2hvd0pvaW5CdXR0b24gPSBmYWxzZTtcblx0dGhpcy5zaG93TGVhdmVCdXR0b24gPSBmYWxzZTtcblx0dGhpcy5pbmZvTGluayA9IG51bGw7XG5cdHRoaXMuaW5mb0xpbmtUZXh0ID0gbnVsbDtcbn1cblxuVGFibGVJbmZvTWVzc2FnZS5UWVBFID0gXCJ0YWJsZUluZm9cIjtcblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldENvdW50ZG93blxuICovXG5UYWJsZUluZm9NZXNzYWdlLnByb3RvdHlwZS5nZXRDb3VudGRvd24gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuY291bnRkb3duO1xufVxuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0VGV4dFxuICovXG5UYWJsZUluZm9NZXNzYWdlLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnRleHQ7XG59XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRTaG93Sm9pbkJ1dHRvblxuICovXG5UYWJsZUluZm9NZXNzYWdlLnByb3RvdHlwZS5nZXRTaG93Sm9pbkJ1dHRvbiA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5zaG93Sm9pbkJ1dHRvbjtcbn1cblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldFNob3dMZWF2ZUJ1dHRvblxuICovXG5UYWJsZUluZm9NZXNzYWdlLnByb3RvdHlwZS5nZXRTaG93TGVhdmVCdXR0b24gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuc2hvd0xlYXZlQnV0dG9uO1xufVxuXG4vKipcbiAqIFNldHRlci5cbiAqIEBtZXRob2QgZ2V0U2hvd0pvaW5CdXR0b25cbiAqL1xuVGFibGVJbmZvTWVzc2FnZS5wcm90b3R5cGUuc2V0U2hvd0pvaW5CdXR0b24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHR0aGlzLnNob3dKb2luQnV0dG9uID0gdmFsdWU7XG59XG5cbi8qKlxuICogU2V0dGVyLlxuICogQG1ldGhvZCBnZXRTaG93TGVhdmVCdXR0b25cbiAqL1xuVGFibGVJbmZvTWVzc2FnZS5wcm90b3R5cGUuc2V0U2hvd0xlYXZlQnV0dG9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0dGhpcy5zaG93TGVhdmVCdXR0b24gPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldEluZm9MaW5rXG4gKi9cblRhYmxlSW5mb01lc3NhZ2UucHJvdG90eXBlLmdldEluZm9MaW5rID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmluZm9MaW5rO1xufVxuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0SW5mb0xpbmtUZXh0XG4gKi9cblRhYmxlSW5mb01lc3NhZ2UucHJvdG90eXBlLmdldEluZm9MaW5rVGV4dCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5pbmZvTGlua1RleHQ7XG59XG5cbi8qKlxuICogVW4tc2VyaWFsaXplLlxuICogQG1ldGhvZCB1bnNlcmlhbGl6ZVxuICovXG5UYWJsZUluZm9NZXNzYWdlLnByb3RvdHlwZS51bnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0aWYgKGRhdGEudGV4dCAhPSBudWxsKVxuXHRcdHRoaXMudGV4dCA9IGRhdGEudGV4dDtcblxuXHRpZiAoZGF0YS5jb3VudGRvd24gIT0gbnVsbClcblx0XHR0aGlzLmNvdW50ZG93biA9IGRhdGEuY291bnRkb3duO1xuXG5cdGlmIChkYXRhLnNob3dKb2luQnV0dG9uICE9IG51bGwpXG5cdFx0dGhpcy5zaG93Sm9pbkJ1dHRvbiA9IGRhdGEuc2hvd0pvaW5CdXR0b247XG5cblx0aWYgKGRhdGEuc2hvd0xlYXZlQnV0dG9uICE9IG51bGwpXG5cdFx0dGhpcy5zaG93TGVhdmVCdXR0b24gPSBkYXRhLnNob3dMZWF2ZUJ1dHRvbjtcblxuXHRpZiAoZGF0YS5pbmZvTGluayAhPSBudWxsKVxuXHRcdHRoaXMuaW5mb0xpbmsgPSBkYXRhLmluZm9MaW5rO1xuXG5cdGlmIChkYXRhLmluZm9MaW5rVGV4dCAhPSBudWxsKVxuXHRcdHRoaXMuaW5mb0xpbmtUZXh0ID0gZGF0YS5pbmZvTGlua1RleHQ7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIHNlcmlhbGl6ZVxuICovXG5UYWJsZUluZm9NZXNzYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHtcblx0XHR0ZXh0OiB0aGlzLnRleHQsXG5cdFx0Y291bnRkb3duOiB0aGlzLmNvdW50ZG93bixcblx0XHRzaG93Sm9pbkJ1dHRvbjogdGhpcy5zaG93Sm9pbkJ1dHRvbixcblx0XHRzaG93TGVhdmVCdXR0b246IHRoaXMuc2hvd0xlYXZlQnV0dG9uLFxuXHRcdGluZm9MaW5rOiB0aGlzLmluZm9MaW5rLFxuXHRcdGluZm9MaW5rVGV4dDogdGhpcy5pbmZvTGlua1RleHRcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUYWJsZUluZm9NZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxuLyoqXG4gKiBSZWNlaXZlZCB3aGVuID8uXG4gKiBAY2xhc3MgVGVzdENhc2VSZXF1ZXN0TWVzc2FnZVxuICovXG5mdW5jdGlvbiBUZXN0Q2FzZVJlcXVlc3RNZXNzYWdlKHRlc3RDYXNlKSB7XG5cdHRoaXMudGVzdENhc2UgPSB0ZXN0Q2FzZTtcbn1cblxuVGVzdENhc2VSZXF1ZXN0TWVzc2FnZS5UWVBFID0gXCJ0ZXN0Q2FzZVJlcXVlc3RcIjtcblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldFRlc3RDYXNlXG4gKi9cblRlc3RDYXNlUmVxdWVzdE1lc3NhZ2UucHJvdG90eXBlLmdldFRlc3RDYXNlID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnRlc3RDYXNlO1xufVxuXG4vKipcbiAqIFVuLXNlcmlhbGl6ZS5cbiAqIEBtZXRob2QgdW5zZXJpYWxpemVcbiAqL1xuVGVzdENhc2VSZXF1ZXN0TWVzc2FnZS5wcm90b3R5cGUudW5zZXJpYWxpemUgPSBmdW5jdGlvbihkYXRhKSB7XG5cdHRoaXMudGVzdENhc2UgPSBkYXRhLnRlc3RDYXNlO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZXJpYWxpemVcbiAqL1xuVGVzdENhc2VSZXF1ZXN0TWVzc2FnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB7XG5cdFx0dGVzdENhc2U6IHRoaXMudGVzdENhc2Vcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUZXN0Q2FzZVJlcXVlc3RNZXNzYWdlOyIsIi8qKlxuICogUHJvdG9jb2wuXG4gKiBAbW9kdWxlIHByb3RvXG4gKi9cblxuLyoqXG4gKiBSZWNlaXZlZCB3aGVuID8uXG4gKiBAY2xhc3MgVGltZXJNZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIFRpbWVyTWVzc2FnZSgpIHtcblx0dGhpcy5zZWF0SW5kZXggPSAtMTtcblx0dGhpcy50b3RhbFRpbWUgPSAtMTtcblx0dGhpcy50aW1lTGVmdCA9IC0xO1xufVxuXG5UaW1lck1lc3NhZ2UuVFlQRSA9IFwidGltZXJcIjtcblxuLyoqXG4gKiBHZXR0ZXIuXG4gKiBAbWV0aG9kIGdldFNlYXRJbmRleFxuICovXG5UaW1lck1lc3NhZ2UucHJvdG90eXBlLmdldFNlYXRJbmRleCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5zZWF0SW5kZXg7XG59XG5cbi8qKlxuICogR2V0dGVyLlxuICogQG1ldGhvZCBnZXRUb3RhbFRpbWVcbiAqL1xuVGltZXJNZXNzYWdlLnByb3RvdHlwZS5nZXRUb3RhbFRpbWUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMudG90YWxUaW1lO1xufVxuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0VGltZUxlZnRcbiAqL1xuVGltZXJNZXNzYWdlLnByb3RvdHlwZS5nZXRUaW1lTGVmdCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy50aW1lTGVmdDtcbn1cblxuLyoqXG4gKiBTZXR0ZXIuXG4gKiBAbWV0aG9kIHNldFNlYXRJbmRleFxuICovXG5UaW1lck1lc3NhZ2UucHJvdG90eXBlLnNldFNlYXRJbmRleCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdHRoaXMuc2VhdEluZGV4ID0gdmFsdWU7XG59XG5cbi8qKlxuICogU2V0dGVyLlxuICogQG1ldGhvZCBzZXRUb3RhbFRpbWVcbiAqL1xuVGltZXJNZXNzYWdlLnByb3RvdHlwZS5zZXRUb3RhbFRpbWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHR0aGlzLnRvdGFsVGltZSA9IHZhbHVlO1xufVxuXG4vKipcbiAqIFNldHRlci5cbiAqIEBtZXRob2Qgc2V0VGltZUxlZnRcbiAqL1xuVGltZXJNZXNzYWdlLnByb3RvdHlwZS5zZXRUaW1lTGVmdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdHRoaXMudGltZUxlZnQgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBVbi1zZXJpYWxpemUuXG4gKiBAbWV0aG9kIHVuc2VyaWFsaXplXG4gKi9cblRpbWVyTWVzc2FnZS5wcm90b3R5cGUudW5zZXJpYWxpemUgPSBmdW5jdGlvbihkYXRhKSB7XG5cdHRoaXMuc2VhdEluZGV4ID0gZGF0YS5zZWF0SW5kZXg7XG5cdHRoaXMudG90YWxUaW1lID0gZGF0YS50b3RhbFRpbWU7XG5cdHRoaXMudGltZUxlZnQgPSBkYXRhLnRpbWVMZWZ0O1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBtZXNzYWdlLlxuICogQG1ldGhvZCBzZXJpYWxpemVcbiAqL1xuVGltZXJNZXNzYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHtcblx0XHRzZWF0SW5kZXg6IHRoaXMuc2VhdEluZGV4LFxuXHRcdHRvdGFsVGltZTogdGhpcy50b3RhbFRpbWUsXG5cdFx0dGltZUxlZnQ6IHRoaXMudGltZUxlZnRcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lck1lc3NhZ2U7IiwiLyoqXG4gKiBQcm90b2NvbC5cbiAqIEBtb2R1bGUgcHJvdG9cbiAqL1xuXG4vKipcbiAqIFJlY2VpdmVkIHdoZW4gdG91cm5hbWVudCByZXN1bHQgbWVzc2FnZSBpcyBkaXNwYXRjaGVkLlxuICogQGNsYXNzIFRvdXJuYW1lbnRSZXN1bHRNZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIFRvdXJuYW1lbnRSZXN1bHRNZXNzYWdlKHRleHQsIHJpZ2h0Q29sdW1uVGV4dCkge1xuXHR0aGlzLnRleHQgPSB0ZXh0O1xuXHR0aGlzLnJpZ2h0Q29sdW1uVGV4dCA9IHJpZ2h0Q29sdW1uVGV4dDtcbn1cblxuVG91cm5hbWVudFJlc3VsdE1lc3NhZ2UuVFlQRSA9IFwidG91cm5hbWVudFJlc3VsdFwiO1xuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0VGV4dFxuICovXG5Ub3VybmFtZW50UmVzdWx0TWVzc2FnZS5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy50ZXh0O1xufVxuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0UmlnaHRDb2x1bW5UZXh0XG4gKi9cblRvdXJuYW1lbnRSZXN1bHRNZXNzYWdlLnByb3RvdHlwZS5nZXRSaWdodENvbHVtblRleHQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMucmlnaHRDb2x1bW5UZXh0O1xufVxuXG4vKipcbiAqIFVuLXNlcmlhbGl6ZS5cbiAqIEBtZXRob2QgdW5zZXJpYWxpemVcbiAqL1xuVG91cm5hbWVudFJlc3VsdE1lc3NhZ2UucHJvdG90eXBlLnVuc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge1xuXHR0aGlzLnRleHQgPSBkYXRhLnRleHQ7XG5cdHRoaXMucmlnaHRDb2x1bW5UZXh0ID0gZGF0YS5yaWdodENvbHVtblRleHQ7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIG1lc3NhZ2UuXG4gKiBAbWV0aG9kIHNlcmlhbGl6ZVxuICovXG5Ub3VybmFtZW50UmVzdWx0TWVzc2FnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB7XG5cdFx0dGV4dDogdGhpcy50ZXh0LFxuXHRcdHJpZ2h0Q29sdW1uVGV4dDogdGhpcy5yaWdodENvbHVtblRleHRcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUb3VybmFtZW50UmVzdWx0TWVzc2FnZTsiLCIvKipcbiAqIFV0aWxpdGllcy5cbiAqIEBtb2R1bGUgdXRpbHNcbiAqL1xuXG52YXIgUElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoXCJ5YWVkXCIpO1xudmFyIEJ1dHRvbiA9IHJlcXVpcmUoXCIuL0J1dHRvblwiKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCJpbmhlcml0c1wiKTtcblxuLyoqXG4gKiBDaGVja2JveC5cbiAqIEBjbGFzcyBDaGVja2JveFxuICovXG5mdW5jdGlvbiBDaGVja2JveChiYWNrZ3JvdW5kLCB0aWNrKSB7XG5cdFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKHRoaXMpO1xuXG5cdHRoaXMuYnV0dG9uID0gbmV3IEJ1dHRvbihiYWNrZ3JvdW5kKTtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLmJ1dHRvbik7XG5cblx0dGhpcy5jaGVjayA9IHRpY2s7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5jaGVjayk7XG5cblx0dGhpcy5idXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMub25CdXR0b25DbGljaywgdGhpcyk7XG5cblx0dGhpcy5zZXRDaGVja2VkKGZhbHNlKTtcbn1cblxuaW5oZXJpdHMoQ2hlY2tib3gsIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcik7XG5FdmVudERpc3BhdGNoZXIuaW5pdChDaGVja2JveCk7XG5cbi8qKlxuICogQnV0dG9uIGNsaWNrLlxuICogQG1ldGhvZCBvbkJ1dHRvbkNsaWNrXG4gKiBAcHJpdmF0ZVxuICovXG5DaGVja2JveC5wcm90b3R5cGUub25CdXR0b25DbGljayA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLmNoZWNrLnZpc2libGUgPSAhdGhpcy5jaGVjay52aXNpYmxlO1xuXG5cdHRoaXMuZGlzcGF0Y2hFdmVudChcImNoYW5nZVwiKTtcbn1cblxuLyoqXG4gKiBTZXR0ZXIuXG4gKiBAbWV0aG9kIHNldENoZWNrZWRcbiAqL1xuQ2hlY2tib3gucHJvdG90eXBlLnNldENoZWNrZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHR0aGlzLmNoZWNrLnZpc2libGUgPSB2YWx1ZTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEdldHRlci5cbiAqIEBtZXRob2QgZ2V0Q2hlY2tlZFxuICovXG5DaGVja2JveC5wcm90b3R5cGUuZ2V0Q2hlY2tlZCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5jaGVjay52aXNpYmxlO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gQ2hlY2tib3g7IiwiLyoqXG4gKiBVdGlsaXRpZXMuXG4gKiBAbW9kdWxlIHV0aWxzXG4gKi9cblxudmFyIFRoZW5hYmxlID0gcmVxdWlyZShcInRpbnBcIik7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiaW5oZXJpdHNcIik7XG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZShcInlhZWRcIik7XG52YXIgSHR0cFJlcXVlc3QgPSByZXF1aXJlKFwiLi4vdXRpbHMvSHR0cFJlcXVlc3RcIik7XG5cbi8qKlxuICogQSBcImNvbm5lY3Rpb25cIiB0aGF0IGxvYWRzIGl0cyBtZXNzYWdlcyBmcm9tIGEganNvbiBmaWxlIHJhdGhlciB0aGFuXG4gKiBhY3R1YWxseSBjb25uZWN0aW5nLlxuICogQGNsYXNzIE1lc3NhZ2VSZXF1ZXN0Q29ubmVjdGlvblxuICovXG5mdW5jdGlvbiBNZXNzYWdlUmVxdWVzdENvbm5lY3Rpb24oKSB7XG5cdEV2ZW50RGlzcGF0Y2hlci5jYWxsKHRoaXMpO1xuXHR0aGlzLnRlc3QgPSAxO1xufVxuXG5pbmhlcml0cyhNZXNzYWdlUmVxdWVzdENvbm5lY3Rpb24sIEV2ZW50RGlzcGF0Y2hlcik7XG5cbk1lc3NhZ2VSZXF1ZXN0Q29ubmVjdGlvbi5DT05ORUNUID0gXCJjb25uZWN0XCI7XG5NZXNzYWdlUmVxdWVzdENvbm5lY3Rpb24uTUVTU0FHRSA9IFwibWVzc2FnZVwiO1xuTWVzc2FnZVJlcXVlc3RDb25uZWN0aW9uLkNMT1NFID0gXCJjbG9zZVwiO1xuXG4vKipcbiAqIENvbm5lY3QuXG4gKiBAbWV0aG9kIGNvbm5lY3RcbiAqL1xuTWVzc2FnZVJlcXVlc3RDb25uZWN0aW9uLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24odXJsKSB7XG5cdHZhciByZXF1ZXN0ID0gbmV3IEh0dHBSZXF1ZXN0KHVybCk7XG5cblx0cmVxdWVzdC5zZW5kKCkudGhlbihcblx0XHR0aGlzLm9uUmVxdWVzdENvbXBsZXRlLmJpbmQodGhpcyksXG5cdFx0dGhpcy5vblJlcXVlc3RFcnJvci5iaW5kKHRoaXMpXG5cdCk7XG59XG5cbi8qKlxuICogQG1ldGhvZCBvblJlcXVlc3RDb21wbGV0ZVxuICrCoEBwcml2YXRlXG4gKi9cbk1lc3NhZ2VSZXF1ZXN0Q29ubmVjdGlvbi5wcm90b3R5cGUub25SZXF1ZXN0Q29tcGxldGUgPSBmdW5jdGlvbihib2R5KSB7XG5cdHRoaXMudHJpZ2dlcihNZXNzYWdlUmVxdWVzdENvbm5lY3Rpb24uQ09OTkVDVCk7XG5cblx0dmFyIGxpbmVzID0gYm9keS50b1N0cmluZygpLnNwbGl0KFwiXFxuXCIpO1xuXG5cdC8vY29uc29sZS5sb2coXCJNZXNzYWdlUmVxdWVzdENvbm5lY3Rpb246IGxpbmVzPVwiK2xpbmVzLmxlbmd0aCk7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBsaW5lID0gbGluZXNbaV07XG5cblx0XHQvL2NvbnNvbGUubG9nKFwibGluZTogXCIrbGluZSk7XG5cblx0XHRpZiAobGluZS5sZW5ndGggJiYgbGluZVswXSAhPSBcIi9cIikge1xuXHRcdFx0Y29uc29sZS5sb2coXCJ0cmlnZ2VyIG1lc3NhZ2U6IFwiICsgbGluZSk7XG5cdFx0XHR0aGlzLnRyaWdnZXIoe1xuXHRcdFx0XHR0eXBlOiBNZXNzYWdlUmVxdWVzdENvbm5lY3Rpb24uTUVTU0FHRSxcblx0XHRcdFx0bWVzc2FnZTogSlNPTi5wYXJzZShsaW5lKVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQG1ldGhvZCBvblJlcXVlc3RDb21wbGV0ZVxuICrCoEBwcml2YXRlXG4gKi9cbk1lc3NhZ2VSZXF1ZXN0Q29ubmVjdGlvbi5wcm90b3R5cGUub25SZXF1ZXN0RXJyb3IgPSBmdW5jdGlvbihlKSB7XG5cdGNvbnNvbGUubG9nKFwiZXJyb3IgaW4gcmVxdWVzdCBjb25uZWN0aW9uXCIpO1xuXHRjb25zb2xlLmxvZyhlKTtcblx0dGhpcy50cmlnZ2VyKE1lc3NhZ2VSZXF1ZXN0Q29ubmVjdGlvbi5DTE9TRSk7XG59XG5cbi8qKlxuICogU2VuZC5cbiAqIEBtZXRob2Qgc2VuZFxuICovXG5NZXNzYWdlUmVxdWVzdENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtKSB7XG5cdGNvbnNvbGUubG9nKCdpZ25vcmluZyBcInNlbmRcIiBmb3IgTWVzc2FnZVJlcXVlc3RDb25uZWN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZVJlcXVlc3RDb25uZWN0aW9uOyIsIi8qKlxuICogVXRpbGl0aWVzLlxuICogQG1vZHVsZSB1dGlsc1xuICovXG5cbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKFwieWFlZFwiKTtcbnZhciBUaGVuYWJsZSA9IHJlcXVpcmUoXCJ0aW5wXCIpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xuXG4vKipcbiAqIE1lc3NhZ2UgY29ubmVjdGlvbiBpbiBhIGJyb3dzZXIuXG4gKiBAY2xhc3MgTWVzc2FnZVdlYlNvY2tldENvbm5lY3Rpb25cbiAqL1xuZnVuY3Rpb24gTWVzc2FnZVdlYlNvY2tldENvbm5lY3Rpb24oKSB7XG5cdEV2ZW50RGlzcGF0Y2hlci5jYWxsKHRoaXMpO1xuXHR0aGlzLnRlc3QgPSAxO1xufVxuXG5pbmhlcml0cyhNZXNzYWdlV2ViU29ja2V0Q29ubmVjdGlvbiwgRXZlbnREaXNwYXRjaGVyKTtcblxuTWVzc2FnZVdlYlNvY2tldENvbm5lY3Rpb24uQ09OTkVDVCA9IFwiY29ubmVjdFwiO1xuTWVzc2FnZVdlYlNvY2tldENvbm5lY3Rpb24uTUVTU0FHRSA9IFwibWVzc2FnZVwiO1xuTWVzc2FnZVdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0UgPSBcImNsb3NlXCI7XG5cbi8qKlxuICogQ29ubmVjdC5cbiAqIEBtZXRob2QgY29ubmVjdFxuICovXG5NZXNzYWdlV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKHVybCkge1xuXHR0aGlzLndlYlNvY2tldCA9IG5ldyBXZWJTb2NrZXQodXJsKTtcblxuXHR0aGlzLndlYlNvY2tldC5vbm9wZW4gPSB0aGlzLm9uV2ViU29ja2V0T3Blbi5iaW5kKHRoaXMpO1xuXHR0aGlzLndlYlNvY2tldC5vbm1lc3NhZ2UgPSB0aGlzLm9uV2ViU29ja2V0TWVzc2FnZS5iaW5kKHRoaXMpO1xuXHR0aGlzLndlYlNvY2tldC5vbmNsb3NlID0gdGhpcy5vbldlYlNvY2tldENsb3NlLmJpbmQodGhpcyk7XG5cdHRoaXMud2ViU29ja2V0Lm9uZXJyb3IgPSB0aGlzLm9uV2ViU29ja2V0RXJyb3IuYmluZCh0aGlzKTtcbn1cblxuLyoqXG4gKiBTZW5kLlxuICogQG1ldGhvZCBzZW5kXG4gKi9cbk1lc3NhZ2VXZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obSkge1xuXHR0aGlzLndlYlNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KG0pKTtcbn1cblxuLyoqXG4gKiBXZWIgc29ja2V0IG9wZW4uXG4gKiBAbWV0aG9kIG9uV2ViU29ja2V0T3BlblxuICogQHByaXZhdGVcbiAqL1xuTWVzc2FnZVdlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLm9uV2ViU29ja2V0T3BlbiA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnRyaWdnZXIoTWVzc2FnZVdlYlNvY2tldENvbm5lY3Rpb24uQ09OTkVDVCk7XG59XG5cbi8qKlxuICogV2ViIHNvY2tldCBtZXNzYWdlLlxuICogQG1ldGhvZCBvbldlYlNvY2tldE1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbk1lc3NhZ2VXZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5vbldlYlNvY2tldE1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG5cdHZhciBtZXNzYWdlID0gSlNPTi5wYXJzZShlLmRhdGEpO1xuXG5cdHRoaXMudHJpZ2dlcih7XG5cdFx0dHlwZTogTWVzc2FnZVdlYlNvY2tldENvbm5lY3Rpb24uTUVTU0FHRSxcblx0XHRtZXNzYWdlOiBtZXNzYWdlXG5cdH0pO1xufVxuXG4vKipcbiAqIFdlYiBzb2NrZXQgY2xvc2UuXG4gKiBAbWV0aG9kIG9uV2ViU29ja2V0Q2xvc2VcbiAqIEBwcml2YXRlXG4gKi9cbk1lc3NhZ2VXZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5vbldlYlNvY2tldENsb3NlID0gZnVuY3Rpb24oKSB7XG5cdGNvbnNvbGUubG9nKFwid2ViIHNvY2tldCBjbG9zZSwgd3M9XCIgKyB0aGlzLndlYlNvY2tldCArIFwiIHRoaXM9XCIgKyB0aGlzLnRlc3QpO1xuXHR0aGlzLndlYlNvY2tldC5jbG9zZSgpO1xuXHR0aGlzLmNsZWFyV2ViU29ja2V0KCk7XG5cblx0dGhpcy50cmlnZ2VyKE1lc3NhZ2VXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFKTtcbn1cblxuLyoqXG4gKiBXZWIgc29ja2V0IGVycm9yLlxuICogQG1ldGhvZCBvbldlYlNvY2tldEVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5NZXNzYWdlV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUub25XZWJTb2NrZXRFcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRjb25zb2xlLmxvZyhcIndlYiBzb2NrZXQgZXJyb3IsIHdzPVwiICsgdGhpcy53ZWJTb2NrZXQgKyBcIiB0aGlzPVwiICsgdGhpcy50ZXN0KTtcblxuXHR0aGlzLndlYlNvY2tldC5jbG9zZSgpO1xuXHR0aGlzLmNsZWFyV2ViU29ja2V0KCk7XG5cblx0dGhpcy50cmlnZ2VyKE1lc3NhZ2VXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFKTtcbn1cblxuLyoqXG4gKiBDbGVhciB0aGUgY3VycmVudCB3ZWIgc29ja2V0LlxuICogQG1ldGhvZCBjbGVhcldlYlNvY2tldFxuICovXG5NZXNzYWdlV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuY2xlYXJXZWJTb2NrZXQgPSBmdW5jdGlvbigpIHtcblx0dGhpcy53ZWJTb2NrZXQub25vcGVuID0gbnVsbDtcblx0dGhpcy53ZWJTb2NrZXQub25tZXNzYWdlID0gbnVsbDtcblx0dGhpcy53ZWJTb2NrZXQub25jbG9zZSA9IG51bGw7XG5cdHRoaXMud2ViU29ja2V0Lm9uZXJyb3IgPSBudWxsO1xuXG5cdHRoaXMud2ViU29ja2V0ID0gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlV2ViU29ja2V0Q29ubmVjdGlvbjsiLCIvKipcbiAqIFV0aWxpdGllcy5cbiAqIEBtb2R1bGUgdXRpbHNcbiAqL1xuXG52YXIgUElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoXCJ5YWVkXCIpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xuXG4vKipcbiAqIE1vdXNlT3Zlckdyb3VwLiBUaGlzIGlzIHRoZSBjbGFzcyBmb3IgdGhlIE1vdXNlT3Zlckdyb3VwLlxuICogQGNsYXNzIE1vdXNlT3Zlckdyb3VwXG4gKi9cbmZ1bmN0aW9uIE1vdXNlT3Zlckdyb3VwKCkge1xuXHR0aGlzLm9iamVjdHMgPSBuZXcgQXJyYXkoKTtcblx0dGhpcy5jdXJyZW50bHlPdmVyID0gZmFsc2U7XG5cdHRoaXMubW91c2VEb3duID0gZmFsc2U7XG5cbn1cbmluaGVyaXRzKE1vdXNlT3Zlckdyb3VwLCBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIpO1xuRXZlbnREaXNwYXRjaGVyLmluaXQoTW91c2VPdmVyR3JvdXApO1xuXG5cbi8qKlxuICogQWRkIGRpc3BsYXlvYmplY3QgdG8gd2F0Y2hsaXN0LlxuICogQG1ldGhvZCBhZGREaXNwbGF5T2JqZWN0XG4gKi9cbk1vdXNlT3Zlckdyb3VwLnByb3RvdHlwZS5hZGREaXNwbGF5T2JqZWN0ID0gZnVuY3Rpb24oZGlzcGxheU9iamVjdCkge1xuXG5cdGRpc3BsYXlPYmplY3QuaW50ZXJhY3RpdmUgPSB0cnVlO1xuXHRkaXNwbGF5T2JqZWN0Lm1vdXNlb3ZlckVuYWJsZWQgPSB0cnVlO1xuXHRkaXNwbGF5T2JqZWN0Lm1vdXNlb3ZlciA9IHRoaXMub25PYmplY3RNb3VzZU92ZXIuYmluZCh0aGlzKTtcblx0ZGlzcGxheU9iamVjdC5tb3VzZW91dCA9IHRoaXMub25PYmplY3RNb3VzZU91dC5iaW5kKHRoaXMpO1xuXHRkaXNwbGF5T2JqZWN0Lm1vdXNlZG93biA9IHRoaXMub25PYmplY3RNb3VzZURvd24uYmluZCh0aGlzKTtcblx0dGhpcy5vYmplY3RzLnB1c2goZGlzcGxheU9iamVjdCk7XG5cbn1cblxuXG4vKipcbiAqIE1vdXNlIG92ZXIgb2JqZWN0LlxuICogQG1ldGhvZCBvbk9iamVjdE1vdXNlT3ZlclxuICovXG5Nb3VzZU92ZXJHcm91cC5wcm90b3R5cGUub25PYmplY3RNb3VzZU92ZXIgPSBmdW5jdGlvbihpbnRlcmFjdGlvbl9vYmplY3QpIHtcblx0aWYodGhpcy5jdXJyZW50bHlPdmVyKVxuXHRcdHJldHVybjtcblxuXHR0aGlzLmN1cnJlbnRseU92ZXIgPSB0cnVlO1xuXHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJtb3VzZW92ZXJcIik7XG59XG5cblxuLyoqXG4gKiBNb3VzZSBvdXQgb2JqZWN0LlxuICogQG1ldGhvZCBvbk9iamVjdE1vdXNlT3V0XG4gKi9cbk1vdXNlT3Zlckdyb3VwLnByb3RvdHlwZS5vbk9iamVjdE1vdXNlT3V0ID0gZnVuY3Rpb24oaW50ZXJhY3Rpb25fb2JqZWN0KSB7XG5cdGlmKCF0aGlzLmN1cnJlbnRseU92ZXIgfHwgdGhpcy5tb3VzZURvd24pXG5cdFx0cmV0dXJuO1xuXG5cdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLm9iamVjdHMubGVuZ3RoOyBpKyspXG5cdFx0aWYodGhpcy5oaXRUZXN0KHRoaXMub2JqZWN0c1tpXSwgaW50ZXJhY3Rpb25fb2JqZWN0KSlcblx0XHRcdHJldHVybjtcblxuXHR0aGlzLmN1cnJlbnRseU92ZXIgPSBmYWxzZTtcblx0dGhpcy5kaXNwYXRjaEV2ZW50KFwibW91c2VvdXRcIik7XG59XG5cblxuLyoqXG4gKiBIaXQgdGVzdC5cbiAqIEBtZXRob2QgaGl0VGVzdFxuICovXG5Nb3VzZU92ZXJHcm91cC5wcm90b3R5cGUuaGl0VGVzdCA9IGZ1bmN0aW9uKG9iamVjdCwgaW50ZXJhY3Rpb25fb2JqZWN0KSB7XG5cdGlmKChpbnRlcmFjdGlvbl9vYmplY3QuZ2xvYmFsLnggPiBvYmplY3QuZ2V0Qm91bmRzKCkueCApICYmIChpbnRlcmFjdGlvbl9vYmplY3QuZ2xvYmFsLnggPCAob2JqZWN0LmdldEJvdW5kcygpLnggKyBvYmplY3QuZ2V0Qm91bmRzKCkud2lkdGgpKSAmJlxuXHRcdChpbnRlcmFjdGlvbl9vYmplY3QuZ2xvYmFsLnkgPiBvYmplY3QuZ2V0Qm91bmRzKCkueSkgJiYgKGludGVyYWN0aW9uX29iamVjdC5nbG9iYWwueSA8IChvYmplY3QuZ2V0Qm91bmRzKCkueSArIG9iamVjdC5nZXRCb3VuZHMoKS5oZWlnaHQpKSkge1xuXHRcdHJldHVybiB0cnVlO1x0XHRcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBNb3VzZSBkb3duIG9iamVjdC5cbiAqIEBtZXRob2Qgb25PYmplY3RNb3VzZURvd25cbiAqL1xuTW91c2VPdmVyR3JvdXAucHJvdG90eXBlLm9uT2JqZWN0TW91c2VEb3duID0gZnVuY3Rpb24oaW50ZXJhY3Rpb25fb2JqZWN0KSB7XG5cdHRoaXMubW91c2VEb3duID0gdHJ1ZTtcblx0aW50ZXJhY3Rpb25fb2JqZWN0LnRhcmdldC5tb3VzZXVwID0gaW50ZXJhY3Rpb25fb2JqZWN0LnRhcmdldC5tb3VzZXVwb3V0c2lkZSA9IHRoaXMub25TdGFnZU1vdXNlVXAuYmluZCh0aGlzKTtcbn1cblxuXG4vKipcbiAqIE1vdXNlIHVwIHN0YWdlLlxuICogQG1ldGhvZCBvblN0YWdlTW91c2VVcFxuICovXG5Nb3VzZU92ZXJHcm91cC5wcm90b3R5cGUub25TdGFnZU1vdXNlVXAgPSBmdW5jdGlvbihpbnRlcmFjdGlvbl9vYmplY3QpIHtcblx0aW50ZXJhY3Rpb25fb2JqZWN0LnRhcmdldC5tb3VzZXVwID0gaW50ZXJhY3Rpb25fb2JqZWN0LnRhcmdldC5tb3VzZXVwb3V0c2lkZSA9IG51bGw7XG5cdHRoaXMubW91c2VEb3duID0gZmFsc2U7XG5cblx0aWYodGhpcy5jdXJyZW50bHlPdmVyKSB7XG5cdFx0dmFyIG92ZXIgPSBmYWxzZTtcblxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLm9iamVjdHMubGVuZ3RoOyBpKyspXG5cdFx0XHRpZih0aGlzLmhpdFRlc3QodGhpcy5vYmplY3RzW2ldLCBpbnRlcmFjdGlvbl9vYmplY3QpKVxuXHRcdFx0XHRvdmVyID0gdHJ1ZTtcblxuXHRcdGlmKCFvdmVyKSB7XG5cdFx0XHR0aGlzLmN1cnJlbnRseU92ZXIgPSBmYWxzZTtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcIm1vdXNlb3V0XCIpO1xuXHRcdH1cblx0fVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gTW91c2VPdmVyR3JvdXA7XG5cbiIsIi8qKlxuICogVXRpbGl0aWVzLlxuICogQG1vZHVsZSB1dGlsc1xuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHBvaW50LlxuICogQGNsYXNzIFBvaW50XG4gKiBAbW9kdWxlIHV0aWxzXG4gKi9cbmZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFBvaW50KSlcblx0XHRyZXR1cm4gbmV3IFBvaW50KHgsIHkpO1xuXG5cdHRoaXMueCA9IHg7XG5cdHRoaXMueSA9IHk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7IiwiLyoqXG4gKiBVdGlsaXRpZXMuXG4gKiBAbW9kdWxlIHV0aWxzXG4gKi9cblxudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoXCJ5YWVkXCIpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xuXG4vKipcbiAqIFBlcmZvcm0gdGFza3MgaW4gYSBzZXF1ZW5jZS5cbiAqIFRhc2tzLCB3aGljaCBzaG91bGQgYmUgZXZlbnQgZGlzcGF0Y2hlcnMsXG4gKiBhcmUgZXVxdWV1ZWQgd2l0aCB0aGUgZW5xdWV1ZSBmdW5jdGlvbixcbiAqIGEgU1RBUlQgZXZlbnQgaXMgZGlzcGF0Y2hlciB1cG9uIHRhc2tcbiAqIHN0YXJ0LCBhbmQgdGhlIHRhc2sgaXMgY29uc2lkZXJlZCBjb21wbGV0ZVxuICogYXMgaXQgZGlzcGF0Y2hlcyBhIENPTVBMRVRFIGV2ZW50LlxuICogQGNsYXNzIFNlcXVlbmNlclxuICovXG5mdW5jdGlvbiBTZXF1ZW5jZXIoKSB7XG5cdEV2ZW50RGlzcGF0Y2hlci5jYWxsKHRoaXMpO1xuXG5cdHRoaXMucXVldWUgPSBbXTtcblx0dGhpcy5jdXJyZW50VGFzayA9IG51bGw7XG5cdHRoaXMub25UYXNrQ29tcGxldGVDbG9zdXJlID0gdGhpcy5vblRhc2tDb21wbGV0ZS5iaW5kKHRoaXMpO1xufVxuXG5pbmhlcml0cyhTZXF1ZW5jZXIsIEV2ZW50RGlzcGF0Y2hlcik7XG5cblNlcXVlbmNlci5TVEFSVCA9IFwic3RhcnRcIjtcblNlcXVlbmNlci5DT01QTEVURSA9IFwiY29tcGxldGVcIjtcblxuLyoqXG4gKiBFbnF1ZXVlIGEgdGFzayB0byBiZSBwZXJmb3JtZWQuXG4gKiBAbWV0aG9kIGVucXVldWVcbiAqL1xuU2VxdWVuY2VyLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24odGFzaykge1xuXHRpZiAoIXRoaXMuY3VycmVudFRhc2spXG5cdFx0dGhpcy5zdGFydFRhc2sodGFzaylcblxuXHRlbHNlXG5cdFx0dGhpcy5xdWV1ZS5wdXNoKHRhc2spO1xufVxuXG4vKipcbiAqIFN0YXJ0IHRoZSB0YXNrLlxuICogQG1ldGhvZCBzdGFydFRhc2tcbiAqIEBwcml2YXRlXG4gKi9cblNlcXVlbmNlci5wcm90b3R5cGUuc3RhcnRUYXNrID0gZnVuY3Rpb24odGFzaykge1xuXHR0aGlzLmN1cnJlbnRUYXNrID0gdGFzaztcblxuXHR0aGlzLmN1cnJlbnRUYXNrLmFkZEV2ZW50TGlzdGVuZXIoU2VxdWVuY2VyLkNPTVBMRVRFLCB0aGlzLm9uVGFza0NvbXBsZXRlQ2xvc3VyZSk7XG5cdHRoaXMuY3VycmVudFRhc2suZGlzcGF0Y2hFdmVudCh7XG5cdFx0dHlwZTogU2VxdWVuY2VyLlNUQVJUXG5cdH0pO1xufVxuXG4vKipcbiAqIFRoZSBjdXJyZW50IHRhc2sgaXMgY29tcGxldGUuXG4gKiBAbWV0aG9kIG9uVGFza0NvbXBsZXRlXG4gKsKgQHByaXZhdGVcbiAqL1xuU2VxdWVuY2VyLnByb3RvdHlwZS5vblRhc2tDb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLmN1cnJlbnRUYXNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoU2VxdWVuY2VyLkNPTVBMRVRFLCB0aGlzLm9uVGFza0NvbXBsZXRlQ2xvc3VyZSk7XG5cdHRoaXMuY3VycmVudFRhc2sgPSBudWxsO1xuXG5cdGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDApXG5cdFx0dGhpcy5zdGFydFRhc2sodGhpcy5xdWV1ZS5zaGlmdCgpKTtcblxuXHRlbHNlXG5cdFx0dGhpcy50cmlnZ2VyKFNlcXVlbmNlci5DT01QTEVURSk7XG5cbn1cblxuLyoqXG4gKiBBYm9ydCB0aGUgc2VxdWVuY2UuXG4gKiBAbWV0aG9kIGFib3J0XG4gKi9cblNlcXVlbmNlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuY3VycmVudFRhc2spIHtcblx0XHR0aGlzLmN1cnJlbnRUYXNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoU2VxdWVuY2VyLkNPTVBMRVRFLCB0aGlzLm9uVGFza0NvbXBsZXRlQ2xvc3VyZSk7XG5cdFx0dGhpcy5jdXJyZW50VGFzayA9IG51bGw7XG5cdH1cblxuXHR0aGlzLnF1ZXVlID0gW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VxdWVuY2VyOyIsIi8qKlxuICogVXRpbGl0aWVzLlxuICogQG1vZHVsZSB1dGlsc1xuICovXG5cbnZhciBQSVhJID0gcmVxdWlyZShcInBpeGkuanNcIik7XG52YXIgVFdFRU4gPSByZXF1aXJlKFwidHdlZW4uanNcIik7XG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZShcInlhZWRcIik7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiaW5oZXJpdHNcIik7XG5cbi8qKlxuICogU2xpZGVyLiBUaGlzIGlzIHRoZSBjbGFzcyBmb3IgdGhlIHNsaWRlci5cbiAqIEBjbGFzcyBTbGlkZXJcbiAqL1xuZnVuY3Rpb24gU2xpZGVyKGJhY2tncm91bmQsIGtub2IpIHtcblx0UElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLmNhbGwodGhpcyk7XG5cblx0dGhpcy5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcblx0dGhpcy5rbm9iID0ga25vYjtcblxuXHR0aGlzLmFkZENoaWxkKHRoaXMuYmFja2dyb3VuZCk7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5rbm9iKTtcblxuXG5cdHRoaXMua25vYi5idXR0b25Nb2RlID0gdHJ1ZTtcblx0dGhpcy5rbm9iLmludGVyYWN0aXZlID0gdHJ1ZTtcblx0dGhpcy5rbm9iLm1vdXNlZG93biA9IHRoaXMub25Lbm9iTW91c2VEb3duLmJpbmQodGhpcyk7XG5cblx0dGhpcy5iYWNrZ3JvdW5kLmJ1dHRvbk1vZGUgPSB0cnVlO1xuXHR0aGlzLmJhY2tncm91bmQuaW50ZXJhY3RpdmUgPSB0cnVlO1xuXHR0aGlzLmJhY2tncm91bmQubW91c2Vkb3duID0gdGhpcy5vbkJhY2tncm91bmRNb3VzZURvd24uYmluZCh0aGlzKTtcblxuXHR0aGlzLmZhZGVUd2VlbiA9IG51bGw7XG5cdHRoaXMuYWxwaGEgPSAwO1xufVxuXG5pbmhlcml0cyhTbGlkZXIsIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcik7XG5FdmVudERpc3BhdGNoZXIuaW5pdChTbGlkZXIpO1xuXG5cbi8qKlxuICogTW91c2UgZG93biBvbiBrbm9iLlxuICogQG1ldGhvZCBvbktub2JNb3VzZURvd25cbiAqL1xuU2xpZGVyLnByb3RvdHlwZS5vbktub2JNb3VzZURvd24gPSBmdW5jdGlvbihpbnRlcmFjdGlvbl9vYmplY3QpIHtcblx0dGhpcy5kb3duUG9zID0gdGhpcy5rbm9iLnBvc2l0aW9uLng7XG5cdHRoaXMuZG93blggPSBpbnRlcmFjdGlvbl9vYmplY3QuZ2V0TG9jYWxQb3NpdGlvbih0aGlzKS54O1xuXG5cdHRoaXMuc3RhZ2UubW91c2V1cCA9IHRoaXMub25TdGFnZU1vdXNlVXAuYmluZCh0aGlzKTtcblx0dGhpcy5zdGFnZS5tb3VzZW1vdmUgPSB0aGlzLm9uU3RhZ2VNb3VzZU1vdmUuYmluZCh0aGlzKTtcbn1cblxuXG4vKipcbiAqIE1vdXNlIGRvd24gb24gYmFja2dyb3VuZC5cbiAqIEBtZXRob2Qgb25CYWNrZ3JvdW5kTW91c2VEb3duXG4gKi9cblNsaWRlci5wcm90b3R5cGUub25CYWNrZ3JvdW5kTW91c2VEb3duID0gZnVuY3Rpb24oaW50ZXJhY3Rpb25fb2JqZWN0KSB7XG5cdHRoaXMuZG93blggPSBpbnRlcmFjdGlvbl9vYmplY3QuZ2V0TG9jYWxQb3NpdGlvbih0aGlzKS54O1xuXHR0aGlzLmtub2IueCA9IGludGVyYWN0aW9uX29iamVjdC5nZXRMb2NhbFBvc2l0aW9uKHRoaXMpLnggLSB0aGlzLmtub2Iud2lkdGgqMC41O1xuXG5cdHRoaXMudmFsaWRhdGVWYWx1ZSgpO1xuXG5cdHRoaXMuZG93blBvcyA9IHRoaXMua25vYi5wb3NpdGlvbi54O1xuXG5cdHRoaXMuc3RhZ2UubW91c2V1cCA9IHRoaXMub25TdGFnZU1vdXNlVXAuYmluZCh0aGlzKTtcblx0dGhpcy5zdGFnZS5tb3VzZW1vdmUgPSB0aGlzLm9uU3RhZ2VNb3VzZU1vdmUuYmluZCh0aGlzKTtcblxuXHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJjaGFuZ2VcIik7XG59XG5cblxuLyoqXG4gKiBNb3VzZSB1cC5cbiAqIEBtZXRob2Qgb25TdGFnZU1vdXNlVXBcbiAqL1xuU2xpZGVyLnByb3RvdHlwZS5vblN0YWdlTW91c2VVcCA9IGZ1bmN0aW9uKGludGVyYWN0aW9uX29iamVjdCkge1xuXHR0aGlzLnN0YWdlLm1vdXNldXAgPSBudWxsO1xuXHR0aGlzLnN0YWdlLm1vdXNlbW92ZSA9IG51bGw7XG59XG5cblxuLyoqXG4gKiBNb3VzZSBtb3ZlLlxuICogQG1ldGhvZCBvblN0YWdlTW91c2VNb3ZlXG4gKi9cblNsaWRlci5wcm90b3R5cGUub25TdGFnZU1vdXNlTW92ZSA9IGZ1bmN0aW9uKGludGVyYWN0aW9uX29iamVjdCkge1xuXHR0aGlzLmtub2IueCA9IHRoaXMuZG93blBvcyArIChpbnRlcmFjdGlvbl9vYmplY3QuZ2V0TG9jYWxQb3NpdGlvbih0aGlzKS54IC0gdGhpcy5kb3duWCk7XG5cblx0dGhpcy52YWxpZGF0ZVZhbHVlKCk7XG5cblx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiY2hhbmdlXCIpO1xufVxuXG5cbi8qKlxuICogVmFsaWRhdGUgcG9zaXRpb24uXG4gKiBAbWV0aG9kIHZhbGlkYXRlVmFsdWVcbiAqL1xuU2xpZGVyLnByb3RvdHlwZS52YWxpZGF0ZVZhbHVlID0gZnVuY3Rpb24oKSB7XG5cblx0aWYodGhpcy5rbm9iLnggPCAwKVxuXHRcdHRoaXMua25vYi54ID0gMDtcblxuXHRpZih0aGlzLmtub2IueCA+ICh0aGlzLmJhY2tncm91bmQud2lkdGggLSB0aGlzLmtub2Iud2lkdGgpKVxuXHRcdHRoaXMua25vYi54ID0gdGhpcy5iYWNrZ3JvdW5kLndpZHRoIC0gdGhpcy5rbm9iLndpZHRoO1xufVxuXG5cbi8qKlxuICogR2V0IHZhbHVlLlxuICogQG1ldGhvZCBnZXRWYWx1ZVxuICovXG5TbGlkZXIucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFjdGlvbiA9IHRoaXMua25vYi5wb3NpdGlvbi54Lyh0aGlzLmJhY2tncm91bmQud2lkdGggLSB0aGlzLmtub2Iud2lkdGgpO1xuXG5cdHJldHVybiBmcmFjdGlvbjtcbn1cblxuXG4vKipcbiAqIEdldCB2YWx1ZS5cbiAqIEBtZXRob2QgZ2V0VmFsdWVcbiAqL1xuU2xpZGVyLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdHRoaXMua25vYi54ID0gdGhpcy5iYWNrZ3JvdW5kLnBvc2l0aW9uLnggKyB2YWx1ZSoodGhpcy5iYWNrZ3JvdW5kLndpZHRoIC0gdGhpcy5rbm9iLndpZHRoKTtcblxuXHR0aGlzLnZhbGlkYXRlVmFsdWUoKTtcblx0cmV0dXJuIHRoaXMuZ2V0VmFsdWUoKTtcbn1cblxuXG4vKipcbiAqIFNob3cuXG4gKiBAbWV0aG9kIHNob3dcbiAqL1xuU2xpZGVyLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cdGlmKHRoaXMuZmFkZVR3ZWVuICE9IG51bGwpXG5cdFx0dGhpcy5mYWRlVHdlZW4uc3RvcCgpO1xuXHR0aGlzLmZhZGVUd2VlbiA9IG5ldyBUV0VFTi5Ud2Vlbih0aGlzKVxuXHRcdFx0LnRvKHthbHBoYTogMX0sIDI1MClcblx0XHRcdC5zdGFydCgpO1xufVxuXG4vKipcbiAqIEhpZGUuXG4gKiBAbWV0aG9kIGhpZGVcbiAqL1xuU2xpZGVyLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG5cdGlmKHRoaXMuZmFkZVR3ZWVuICE9IG51bGwpXG5cdFx0dGhpcy5mYWRlVHdlZW4uc3RvcCgpO1xuXHR0aGlzLmZhZGVUd2VlbiA9IG5ldyBUV0VFTi5Ud2Vlbih0aGlzKVxuXHRcdFx0LnRvKHthbHBoYTogMH0sIDI1MClcblx0XHRcdC5vbkNvbXBsZXRlKHRoaXMub25IaWRkZW4uYmluZCh0aGlzKSlcblx0XHRcdC5zdGFydCgpO1xufVxuXG4vKipcbiAqIE9uIGhpZGRlbi5cbiAqIEBtZXRob2Qgb25IaWRkZW5cbiAqL1xuU2xpZGVyLnByb3RvdHlwZS5vbkhpZGRlbiA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnZpc2libGUgPSBmYWxzZTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNsaWRlcjtcbiIsInZhciB1cmwgPSByZXF1aXJlKFwidXJsXCIpO1xuXG4vKipcbiAqIFVSTCB1dGlsaXR5LlxuICogQGNsYXNzIFVybFV0aWxcbiAqL1xuZnVuY3Rpb24gVXJsVXRpbCgpIHtcblx0dGhyb3cgbmV3IEVycm9yKFwic3RhdGljXCIpO1xufVxuXG4vKipcbiAqIE1ha2UgYWJzb2x1dGUgdXJsLlxuICogQG1ldGhvZCBtYWtlQWJzb2x1dGVcbiAqL1xuVXJsVXRpbC5tYWtlQWJzb2x1dGUgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0dmFyIHBhcnNlZFVybCA9IHVybC5wYXJzZSh0YXJnZXQpO1xuXG5cdGlmIChwYXJzZWRVcmwucHJvdG9jb2wpXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHRpZiAodGFyZ2V0LmNoYXJBdCgwKSA9PSBcIi9cIikge1xuXHRcdHZhciB1ID0gdXJsLnBhcnNlKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuXHRcdHUucGF0aG5hbWUgPSB0YXJnZXQ7XG5cblx0XHRyZXR1cm4gdXJsLmZvcm1hdCh1KTtcblx0fSBlbHNlIHtcblx0XHR2YXIgcGF0aDtcblx0XHRwYXRoID0gd2luZG93LmxvY2F0aW9uLmhyZWYuc3Vic3RyaW5nKDAsIHdpbmRvdy5sb2NhdGlvbi5ocmVmLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpO1xuXHRcdHJldHVybiBwYXRoICsgdGFyZ2V0O1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVXJsVXRpbDsiLCIvKipcbiAqIFV0aWxpdGllcy5cbiAqIEBtb2R1bGUgdXRpbHNcbiAqL1xuXG52YXIgUElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoXCJ5YWVkXCIpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xuXG4vKipcbiAqIEJ1dHRvbi5cbiAqIEBjbGFzcyBCdXR0b25cbiAqL1xuZnVuY3Rpb24gQnV0dG9uKGNvbnRlbnQpIHtcblx0UElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLmNhbGwodGhpcyk7XG5cblx0aWYgKGNvbnRlbnQpXG5cdFx0dGhpcy5hZGRDaGlsZChjb250ZW50KTtcblxuXHR0aGlzLmludGVyYWN0aXZlID0gdHJ1ZTtcblx0dGhpcy5idXR0b25Nb2RlID0gdHJ1ZTtcblxuXHR0aGlzLm1vdXNlb3ZlciA9IHRoaXMub25Nb3VzZW92ZXIuYmluZCh0aGlzKTtcblx0dGhpcy5tb3VzZW91dCA9IHRoaXMudG91Y2hlbmQgPSB0aGlzLnRvdWNoZW5kb3V0c2lkZSA9IHRoaXMub25Nb3VzZW91dC5iaW5kKHRoaXMpO1xuXHR0aGlzLm1vdXNlZG93biA9IHRoaXMudG91Y2hzdGFydCA9IHRoaXMub25Nb3VzZWRvd24uYmluZCh0aGlzKTtcblx0dGhpcy5tb3VzZXVwID0gdGhpcy5vbk1vdXNldXAuYmluZCh0aGlzKTtcblx0dGhpcy5jbGljayA9IHRoaXMudGFwID0gdGhpcy5vbkNsaWNrLmJpbmQodGhpcyk7XG5cblx0dGhpcy5jb2xvck1hdHJpeEZpbHRlciA9IG5ldyBQSVhJLkNvbG9yTWF0cml4RmlsdGVyKCk7XG5cdHRoaXMuY29sb3JNYXRyaXhGaWx0ZXIubWF0cml4ID0gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xuXG5cdHRoaXMuZmlsdGVycyA9IFt0aGlzLmNvbG9yTWF0cml4RmlsdGVyXTtcbn1cblxuaW5oZXJpdHMoQnV0dG9uLCBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIpO1xuRXZlbnREaXNwYXRjaGVyLmluaXQoQnV0dG9uKTtcblxuQnV0dG9uLkxJR0hUX01BVFJJWCA9IFsxLjUsIDAsIDAsIDAsIDAsIDEuNSwgMCwgMCwgMCwgMCwgMS41LCAwLCAwLCAwLCAwLCAxXTtcbkJ1dHRvbi5EQVJLX01BVFJJWCA9IFsuNzUsIDAsIDAsIDAsIDAsIC43NSwgMCwgMCwgMCwgMCwgLjc1LCAwLCAwLCAwLCAwLCAxXTtcbkJ1dHRvbi5ERUZBVUxUX01BVFJJWCA9IFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcblxuQnV0dG9uLkNMSUNLID0gXCJjbGlja1wiO1xuXG4vKipcbiAqIE1vdXNlIG92ZXIuXG4gKiBAbWV0aG9kIG9uTW91c2VvdmVyXG4gKiBAcHJpdmF0ZVxuICovXG5CdXR0b24ucHJvdG90eXBlLm9uTW91c2VvdmVyID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuY29sb3JNYXRyaXhGaWx0ZXIubWF0cml4ID0gQnV0dG9uLkxJR0hUX01BVFJJWDtcbn1cblxuLyoqXG4gKiBNb3VzZSBvdXQuXG4gKiBAbWV0aG9kIG9uTW91c2VvdXRcbiAqIEBwcml2YXRlXG4gKi9cbkJ1dHRvbi5wcm90b3R5cGUub25Nb3VzZW91dCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLmNvbG9yTWF0cml4RmlsdGVyLm1hdHJpeCA9IEJ1dHRvbi5ERUZBVUxUX01BVFJJWDtcbn1cblxuLyoqXG4gKiBNb3VzZSBkb3duLlxuICogQG1ldGhvZCBvbk1vdXNlZG93blxuICogQHByaXZhdGVcbiAqL1xuQnV0dG9uLnByb3RvdHlwZS5vbk1vdXNlZG93biA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLmNvbG9yTWF0cml4RmlsdGVyLm1hdHJpeCA9IEJ1dHRvbi5EQVJLX01BVFJJWDtcbn1cblxuLyoqXG4gKiBNb3VzZSB1cC5cbiAqIEBtZXRob2Qgb25Nb3VzZXVwXG4gKiBAcHJpdmF0ZVxuICovXG5CdXR0b24ucHJvdG90eXBlLm9uTW91c2V1cCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLmNvbG9yTWF0cml4RmlsdGVyLm1hdHJpeCA9IEJ1dHRvbi5MSUdIVF9NQVRSSVg7XG59XG5cbi8qKlxuICogQ2xpY2suXG4gKiBAbWV0aG9kIG9uQ2xpY2tcbiAqIEBwcml2YXRlXG4gKi9cbkJ1dHRvbi5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnRyaWdnZXIoQnV0dG9uLkNMSUNLKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCdXR0b247IiwiLyoqXG4gKiBVdGlsaXRpZXMuXG4gKiBAbW9kdWxlIHV0aWxzXG4gKi9cblxudmFyIFBJWEkgPSByZXF1aXJlKFwicGl4aS5qc1wiKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBzcHJpdGUgd2l0aCBhIGdyYWRpZW50LlxuICogQGNsYXNzIEdyYWRpZW50XG4gKi9cbmZ1bmN0aW9uIEdyYWRpZW50KCkge1xuXHR0aGlzLndpZHRoID0gMTAwO1xuXHR0aGlzLmhlaWdodCA9IDEwMDtcblx0dGhpcy5zdG9wcyA9IFtdO1xufVxuXG4vKipcbiAqIFNldCBzaXplIG9mIHRoZSBncmFkaWVudC5cbiAqIEBtZXRob2Qgc2V0U2l6ZVxuICovXG5HcmFkaWVudC5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uKHcsIGgpIHtcblx0dGhpcy53aWR0aCA9IHc7XG5cdHRoaXMuaGVpZ2h0ID0gaDtcbn1cblxuLyoqXG4gKiBBZGQgY29sb3Igc3RvcC5cbiAqIEBtZXRob2QgYWRkQ29sb3JTdG9wXG4gKi9cbkdyYWRpZW50LnByb3RvdHlwZS5hZGRDb2xvclN0b3AgPSBmdW5jdGlvbih3ZWlnaHQsIGNvbG9yKSB7XG5cdHRoaXMuc3RvcHMucHVzaCh7XG5cdFx0d2VpZ2h0OiB3ZWlnaHQsXG5cdFx0Y29sb3I6IGNvbG9yXG5cdH0pO1xufVxuXG4vKipcbiAqIFJlbmRlciB0aGUgc3ByaXRlLlxuICogQG1ldGhvZCBjcmVhdGVTcHJpdGVcbiAqL1xuR3JhZGllbnQucHJvdG90eXBlLmNyZWF0ZVNwcml0ZSA9IGZ1bmN0aW9uKCkge1xuXHQvL2NvbnNvbGUubG9nKFwicmVuZGVyaW5nIGdyYWRpZW50Li4uXCIpO1xuXHR2YXIgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cdGMud2lkdGggPSB0aGlzLndpZHRoO1xuXHRjLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuXG5cdHZhciBjdHggPSBjLmdldENvbnRleHQoXCIyZFwiKTtcblx0dmFyIGdyZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCAwLCB0aGlzLmhlaWdodCk7XG5cdHZhciBpO1xuXG5cdGZvciAoaSA9IDA7IGkgPCB0aGlzLnN0b3BzLmxlbmd0aDsgaSsrKVxuXHRcdGdyZC5hZGRDb2xvclN0b3AodGhpcy5zdG9wc1tpXS53ZWlnaHQsIHRoaXMuc3RvcHNbaV0uY29sb3IpO1xuXG5cdGN0eC5maWxsU3R5bGUgPSBncmQ7XG5cdGN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cblx0cmV0dXJuIG5ldyBQSVhJLlNwcml0ZShQSVhJLlRleHR1cmUuZnJvbUNhbnZhcyhjKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR3JhZGllbnQ7IiwidmFyIFRoZW5hYmxlID0gcmVxdWlyZShcInRpbnBcIik7XG5cbi8qKlxuICogV3JhcHMgWE1MSHR0cFJlcXVlc3QuXG4gKiBAY2xhc3MgSHR0cFJlcXVlc3RcbiAqL1xuZnVuY3Rpb24gSHR0cFJlcXVlc3QodXJsKSB7XG5cdHRoaXMudXJsID0gdXJsO1xuXHR0aGlzLnRoZW5hYmxlID0gbnVsbDtcblx0dGhpcy5yZXN1bHRUeXBlID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTZXQgcmVzdWx0IHR5cGUuXG4gKiBAbWV0aG9kIHNldFJlc3VsdFR5cGVcbiAqL1xuSHR0cFJlcXVlc3QucHJvdG90eXBlLnNldFJlc3VsdFR5cGUgPSBmdW5jdGlvbih0eXBlKSB7XG5cdHRoaXMucmVzdWx0VHlwZSA9IHR5cGU7XG59XG5cbi8qKlxuICogU2V0IHVybC5cbiAqIEBtZXRob2Qgc2V0VXJsXG4gKi9cbkh0dHBSZXF1ZXN0LnByb3RvdHlwZS5zZXRVcmwgPSBmdW5jdGlvbih1cmwpIHtcblx0dGhpcy51cmwgPSB1cmw7XG59XG5cbi8qKlxuICogU2VuZC5cbiAqIEBtZXRob2Qgc2VuZFxuICovXG5IdHRwUmVxdWVzdC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKHVybCkge1xuXHRpZiAodGhpcy50aGVuYWJsZSlcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0IGFscmVhZHkgc2VudFwiKTtcblxuXHRpZiAodXJsKVxuXHRcdHRoaXMudXJsID0gdXJsO1xuXG5cdHRoaXMudGhlbmFibGUgPSBuZXcgVGhlbmFibGUoKTtcblxuXHR0aGlzLnJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0dGhpcy5yZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgdGhpcy51cmwsIHRydWUpO1xuXG5cdHRoaXMucmVxdWVzdC5vbmxvYWQgPSB0aGlzLm9uUmVxdWVzdExvYWQuYmluZCh0aGlzKTtcblx0dGhpcy5yZXF1ZXN0Lm9uZXJyb3IgPSB0aGlzLm9uUmVxdWVzdEVycm9yLmJpbmQodGhpcyk7XG5cblx0dGhpcy5yZXF1ZXN0LnNlbmQoKTtcblxuXHRyZXR1cm4gdGhpcy50aGVuYWJsZTtcbn1cblxuLyoqXG4gKiBAbWV0aG9kIG9uUmVxdWVzdExvYWRcbiAqIEBwcml2YXRlXG4gKi9cbkh0dHBSZXF1ZXN0LnByb3RvdHlwZS5vblJlcXVlc3RMb2FkID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLnJlcXVlc3Quc3RhdHVzICE9IDIwMCkge1xuXHRcdHRoaXMudGhlbmFibGUucmVqZWN0KHRoaXMucmVxdWVzdC5zdGF0dXMpO1xuXHRcdHRoaXMudGhlbmFibGUgPSBudWxsO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciByZXN1bHQgPSB0aGlzLnJlcXVlc3QucmVzcG9uc2VUZXh0O1xuXG5cdHN3aXRjaCAodGhpcy5yZXN1bHRUeXBlKSB7XG5cdFx0Y2FzZSBcImpzb25cIjpcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJlc3VsdCA9IEpTT04ucGFyc2UodGhpcy5yZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHRoaXMudGhlbmFibGUucmVqZWN0KFwiSlNPTi5wYXJzZTogXCIrZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXHR9XG5cblx0dGhpcy50aGVuYWJsZS5yZXNvbHZlKHJlc3VsdCk7XG59XG5cbi8qKlxuICogQG1ldGhvZCBvblJlcXVlc3RFcnJvclxuICogQHByaXZhdGVcbiAqL1xuSHR0cFJlcXVlc3QucHJvdG90eXBlLm9uUmVxdWVzdEVycm9yID0gZnVuY3Rpb24oZSkge1xuXHR0aGlzLnJlcXVlc3QgPSBudWxsO1xuXG5cdHRoaXMudGhlbmFibGUucmVqZWN0KGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEh0dHBSZXF1ZXN0OyIsIi8qKlxuICogQ2xpZW50LlxuICogQG1vZHVsZSBjbGllbnRcbiAqL1xuXG52YXIgUElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xudmFyIFBpeGlBcHAgPSByZXF1aXJlKFwicGl4aWFwcFwiKTtcbnZhciBOZXRQb2tlckNsaWVudFZpZXcgPSByZXF1aXJlKFwiLi4vdmlldy9OZXRQb2tlckNsaWVudFZpZXdcIik7XG52YXIgTmV0UG9rZXJDbGllbnRDb250cm9sbGVyID0gcmVxdWlyZShcIi4uL2NvbnRyb2xsZXIvTmV0UG9rZXJDbGllbnRDb250cm9sbGVyXCIpO1xudmFyIE1lc3NhZ2VXZWJTb2NrZXRDb25uZWN0aW9uID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL01lc3NhZ2VXZWJTb2NrZXRDb25uZWN0aW9uXCIpO1xudmFyIE1lc3NhZ2VSZXF1ZXN0Q29ubmVjdGlvbiA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9NZXNzYWdlUmVxdWVzdENvbm5lY3Rpb25cIik7XG52YXIgUHJvdG9Db25uZWN0aW9uID0gcmVxdWlyZShcIi4uLy4uL3Byb3RvL1Byb3RvQ29ubmVjdGlvblwiKTtcbnZhciBMb2FkaW5nU2NyZWVuID0gcmVxdWlyZShcIi4uL3ZpZXcvTG9hZGluZ1NjcmVlblwiKTtcbnZhciBTdGF0ZUNvbXBsZXRlTWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9TdGF0ZUNvbXBsZXRlTWVzc2FnZVwiKTtcbnZhciBJbml0TWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm90by9tZXNzYWdlcy9Jbml0TWVzc2FnZVwiKTtcbnZhciBSZXNvdXJjZXMgPSByZXF1aXJlKFwiLi4vcmVzb3VyY2VzL1Jlc291cmNlc1wiKTtcbnZhciBWaWV3Q29uZmlnID0gcmVxdWlyZShcIi4uL3Jlc291cmNlcy9WaWV3Q29uZmlnXCIpO1xudmFyIHVybCA9IHJlcXVpcmUoXCJ1cmxcIik7XG52YXIgVFdFRU4gPSByZXF1aXJlKFwidHdlZW4uanNcIik7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiaW5oZXJpdHNcIik7XG52YXIgVXJsVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9VcmxVdGlsXCIpO1xudmFyIERlZmF1bHRTa2luID0gcmVxdWlyZShcIi4uL3Jlc291cmNlcy9EZWZhdWx0U2tpblwiKTtcblxuLyoqXG4gKiBNYWluIGVudHJ5IHBvaW50IGZvciBjbGllbnQuXG4gKiBAY2xhc3MgTmV0UG9rZXJDbGllbnRcbiAqL1xuZnVuY3Rpb24gTmV0UG9rZXJDbGllbnQoKSB7XG5cdFBpeGlBcHAuY2FsbCh0aGlzLCA5NjAsIDcyMCk7XG5cblx0dGhpcy52ZXJ0aWNhbEFsaWduID0gUGl4aUFwcC5UT1A7XG5cblx0dGhpcy5yZXNvdXJjZXMgPSBuZXcgUmVzb3VyY2VzKCk7XG5cdHRoaXMucmVzb3VyY2VzLmFkZFNraW5Tb3VyY2UoRGVmYXVsdFNraW4pO1xuXHR0aGlzLnJlc291cmNlcy5hZGRTcHJpdGVTaGVldChcIm5ldHBva2VyY2xpZW50LnNwcml0ZXNoZWV0Lmpzb25cIik7XG5cblx0dGhpcy5sb2FkaW5nU2NyZWVuID0gbmV3IExvYWRpbmdTY3JlZW4oKTtcblx0dGhpcy5hZGRDaGlsZCh0aGlzLmxvYWRpbmdTY3JlZW4pO1xuXHR0aGlzLmVudGVyQXBwU3RhdGUoXCJMT0FESU5HXCIsIDApO1xuXHR0aGlzLmxvYWRpbmdTY3JlZW4uc2hvdyhcIkxPQURJTkdcIik7XG5cblx0dGhpcy51cmwgPSBudWxsO1xuXHR0aGlzLnRhYmxlSWQgPSBudWxsO1xuXHR0aGlzLnRvdXJuYW1lbnRJZCA9IG51bGw7XG5cdHRoaXMudmlld0NvbmZpZyA9IG5ldyBWaWV3Q29uZmlnKCk7XG5cblx0dGhpcy5vbihcImZyYW1lXCIsIFRXRUVOLnVwZGF0ZSk7XG59XG5cbmluaGVyaXRzKE5ldFBva2VyQ2xpZW50LCBQaXhpQXBwKTtcblxuLyoqXG4gKiBTZXQgdXJsLlxuICogQG1ldGhvZCBzZXRVcmxcbiAqL1xuTmV0UG9rZXJDbGllbnQucHJvdG90eXBlLnNldFVybCA9IGZ1bmN0aW9uKHVybCkge1xuXHR0aGlzLnVybCA9IHVybDtcbn1cblxuLyoqXG4gKiBTZXQgdGFibGUgaWQuXG4gKiBAbWV0aG9kIHNldFRhYmxlSWRcbiAqL1xuTmV0UG9rZXJDbGllbnQucHJvdG90eXBlLnNldFRhYmxlSWQgPSBmdW5jdGlvbih0YWJsZUlkKSB7XG5cdHRoaXMudGFibGVJZCA9IHRhYmxlSWQ7XG59XG5cbi8qKlxuICogU2V0IHRvdXJuYW1lbnQgaWQuXG4gKiBAbWV0aG9kIHNldFRvdXJuYW1lbnRJZFxuICovXG5OZXRQb2tlckNsaWVudC5wcm90b3R5cGUuc2V0VG91cm5hbWVudElkID0gZnVuY3Rpb24odG91cm5hbWVudElkKSB7XG5cdHRoaXMudG91cm5hbWVudElkID0gdG91cm5hbWVudElkO1xufVxuXG4vKipcbiAqIFNldCB2aWV3IGNhc2UuXG4gKiBAbWV0aG9kIHNldFZpZXdDYXNlXG4gKi9cbk5ldFBva2VyQ2xpZW50LnByb3RvdHlwZS5zZXRWaWV3Q2FzZSA9IGZ1bmN0aW9uKHZpZXdDYXNlKSB7XG5cdGNvbnNvbGUubG9nKFwiKioqKioqIHJ1bm5pbmcgdmlldyBjYXNlOiBcIiArIHZpZXdDYXNlKTtcblx0dGhpcy52aWV3Q2FzZSA9IHZpZXdDYXNlO1xufVxuXG4vKipcbiAqIFNldCB0b2tlbi5cbiAqIEBtZXRob2Qgc2V0VG9rZW5cbiAqL1xuTmV0UG9rZXJDbGllbnQucHJvdG90eXBlLnNldFRva2VuID0gZnVuY3Rpb24odG9rZW4pIHtcblx0dGhpcy50b2tlbiA9IHRva2VuO1xufVxuXG4vKipcbiAqIEFkZCBza2luIHNvdXJjZS5cbiAqIEBtZXRob2QgYWRkU2tpblNvdXJjZVxuICovXG5OZXRQb2tlckNsaWVudC5wcm90b3R5cGUuYWRkU2tpblNvdXJjZSA9IGZ1bmN0aW9uKHNraW4pIHtcblx0dGhpcy5yZXNvdXJjZXMuYWRkU2tpblNvdXJjZShza2luKTtcbn1cblxuLyoqXG4gKiBBZGQgc3ByaXRlIHNoZWV0LlxuICogQG1ldGhvZCBhZGRTcHJpdGVTaGVldFxuICovXG5OZXRQb2tlckNsaWVudC5wcm90b3R5cGUuYWRkU3ByaXRlU2hlZXQgPSBmdW5jdGlvbihzcHJpdGVTaGVldCkge1xuXHR0aGlzLnJlc291cmNlcy5hZGRTcHJpdGVTaGVldChzcHJpdGVTaGVldCk7XG59XG5cbi8qKlxuICogU2V0IHNwcml0ZSBzaGVldC5cbiAqIEBtZXRob2Qgc2V0U3ByaXRlU2hlZXRcbiAqL1xuTmV0UG9rZXJDbGllbnQucHJvdG90eXBlLnNldFNwcml0ZVNoZWV0ID0gZnVuY3Rpb24oc3ByaXRlU2hlZXQpIHtcblx0dGhpcy5yZXNvdXJjZXMuc2V0U3ByaXRlU2hlZXQoc3ByaXRlU2hlZXQpO1xufVxuXG4vKipcbiAqIFJ1bi5cbiAqIEBtZXRob2QgcnVuXG4gKi9cbk5ldFBva2VyQ2xpZW50LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpIHtcblx0Ly9jb25zb2xlLmxvZyhcImxvYWRpbmcgcmVzb3VyY2VzLi4uLi5cIik7XG5cdHRoaXMuZW50ZXJBcHBTdGF0ZShcIkxPQURJTkcgUkVTT1VSQ0VTXCIsIDUwKTtcblxuXHR0aGlzLnJlc291cmNlcy5sb2FkKCkudGhlbihcblx0XHR0aGlzLm9uUmVzb3VyY2VzTG9hZGVkLmJpbmQodGhpcyksXG5cdFx0dGhpcy5vblJlc291cmNlc0Vycm9yLmJpbmQodGhpcylcblx0KTtcbn1cblxuLyoqXG4gKiBFcnJvciB3aGlsZSBsb2FkaW5nIHJlc291cmNlcy5cbiAqIEBtZXRob2Qgb25SZXNvdXJjZXNFcnJvclxuICovXG5OZXRQb2tlckNsaWVudC5wcm90b3R5cGUub25SZXNvdXJjZXNFcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRjb25zb2xlLmxvZyhcInJlc291cmNlIGVycm9yXCIpO1xuXG5cdHRoaXMuZW50ZXJBcHBTdGF0ZShcIkVSUk9SIExPQURJTkcgUkVTT1VSQ0VTXCIpO1xufVxuXG4vKipcbiAqIEFzc2V0cyBsb2FkZWQsIGNvbm5lY3QuXG4gKiBAbWV0aG9kIG9uQXNzZXRMb2FkZXJDb21wbGV0ZVxuICogQHByaXZhdGVcbiAqL1xuTmV0UG9rZXJDbGllbnQucHJvdG90eXBlLm9uUmVzb3VyY2VzTG9hZGVkID0gZnVuY3Rpb24oKSB7XG5cdC8vY29uc29sZS5sb2coXCJyZXNvdXJjZXMgbG9hZGVkIGNvbXBsZXRlLi4uXCIpO1xuXG5cdHRoaXMubmV0UG9rZXJDbGllbnRWaWV3ID0gbmV3IE5ldFBva2VyQ2xpZW50Vmlldyh0aGlzLnZpZXdDb25maWcsIHRoaXMucmVzb3VyY2VzKTtcblx0dGhpcy5hZGRDaGlsZEF0KHRoaXMubmV0UG9rZXJDbGllbnRWaWV3LCAwKTtcblxuXHR0aGlzLm5ldFBva2VyQ2xpZW50Q29udHJvbGxlciA9IG5ldyBOZXRQb2tlckNsaWVudENvbnRyb2xsZXIodGhpcy5uZXRQb2tlckNsaWVudFZpZXcpO1xuXHR0aGlzLmNvbm5lY3QoKTtcbn1cblxuLyoqXG4gKiBDb25uZWN0LlxuICogQG1ldGhvZCBjb25uZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5OZXRQb2tlckNsaWVudC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIXRoaXMudXJsKSB7XG5cdFx0dGhpcy5lbnRlckFwcFN0YXRlKFwiTkVFRCBVUkxcIik7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIHBhcnNlZFVybCA9IHVybC5wYXJzZSh0aGlzLnVybCk7XG5cblx0Y29uc29sZS5sb2cocGFyc2VkVXJsKTtcblxuXHRpZiAoIXBhcnNlZFVybC5wcm90b2NvbCB8fCBwYXJzZWRVcmwucHJvdG9jb2wgPT0gXCJodHRwOlwiIHx8IHBhcnNlZFVybC5wcm90b2NvbCA9PSBcImh0dHBzOlwiKSB7XG5cdFx0dGhpcy51cmwgPSBVcmxVdGlsLm1ha2VBYnNvbHV0ZSh0aGlzLnVybCk7XG5cdFx0dGhpcy5jb25uZWN0aW9uID0gbmV3IE1lc3NhZ2VSZXF1ZXN0Q29ubmVjdGlvbigpO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuY29ubmVjdGlvbiA9IG5ldyBNZXNzYWdlV2ViU29ja2V0Q29ubmVjdGlvbigpO1xuXHR9XG5cblx0dGhpcy5jb25uZWN0aW9uLm9uKE1lc3NhZ2VXZWJTb2NrZXRDb25uZWN0aW9uLkNPTk5FQ1QsIHRoaXMub25Db25uZWN0aW9uQ29ubmVjdCwgdGhpcyk7XG5cdHRoaXMuY29ubmVjdGlvbi5vbihNZXNzYWdlV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRSwgdGhpcy5vbkNvbm5lY3Rpb25DbG9zZSwgdGhpcyk7XG5cblx0Y29uc29sZS5sb2coXCJDb25uZWN0aW5nIHRvOiBcIiArIHRoaXMudXJsKTtcblxuXHR0aGlzLmVudGVyQXBwU3RhdGUoXCJDT05ORUNUSU5HXCIsIDY1KTtcblx0dGhpcy5jb25uZWN0aW9uLmNvbm5lY3QodGhpcy51cmwpO1xufVxuXG4vKipcbiAqIENvbm5lY3Rpb24gY29tcGxldGUuXG4gKiBAbWV0aG9kIG9uQ29ubmVjdGlvbkNvbm5lY3RcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFBva2VyQ2xpZW50LnByb3RvdHlwZS5vbkNvbm5lY3Rpb25Db25uZWN0ID0gZnVuY3Rpb24oKSB7XG5cdGNvbnNvbGUubG9nKFwiKioqKiBjb25uZWN0ZWRcIik7XG5cdHRoaXMucHJvdG9Db25uZWN0aW9uID0gbmV3IFByb3RvQ29ubmVjdGlvbih0aGlzLmNvbm5lY3Rpb24pO1xuXHR0aGlzLnByb3RvQ29ubmVjdGlvbi5hZGRNZXNzYWdlSGFuZGxlcihTdGF0ZUNvbXBsZXRlTWVzc2FnZSwgdGhpcy5vblN0YXRlQ29tcGxldGVNZXNzYWdlLCB0aGlzKTtcblx0dGhpcy5uZXRQb2tlckNsaWVudENvbnRyb2xsZXIuc2V0UHJvdG9Db25uZWN0aW9uKHRoaXMucHJvdG9Db25uZWN0aW9uKTtcblx0dGhpcy5lbnRlckFwcFN0YXRlKFwiSU5JVElBTElaSU5HXCIsIDgwKTtcblxuXHR2YXIgaW5pdE1lc3NhZ2UgPSBuZXcgSW5pdE1lc3NhZ2UodGhpcy50b2tlbik7XG5cblx0aWYgKHRoaXMudGFibGVJZClcblx0XHRpbml0TWVzc2FnZS5zZXRUYWJsZUlkKHRoaXMudGFibGVJZCk7XG5cblx0aWYgKHRoaXMudG91cm5hbWVudElkKVxuXHRcdGluaXRNZXNzYWdlLnNldFRvdXJuYW1lbnRJZCh0aGlzLnRvdXJuYW1lbnRJZCk7XG5cblx0aWYgKHRoaXMudmlld0Nhc2UpXG5cdFx0aW5pdE1lc3NhZ2Uuc2V0Vmlld0Nhc2UodGhpcy52aWV3Q2FzZSk7XG5cblx0dGhpcy5wcm90b0Nvbm5lY3Rpb24uc2VuZChpbml0TWVzc2FnZSk7XG59XG5cbi8qKlxuICogU3RhdGUgY29tcGxldGUuXG4gKiBAbWV0aG9kIG9uU3RhdGVDb21wbGV0ZU1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFBva2VyQ2xpZW50LnByb3RvdHlwZS5vblN0YXRlQ29tcGxldGVNZXNzYWdlID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuZW50ZXJBcHBTdGF0ZShudWxsKTtcbn1cblxuLyoqXG4gKiBDb25uZWN0aW9uIGNsb3NlZC5cbiAqIEBtZXRob2Qgb25Db25uZWN0aW9uQ2xvc2VcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFBva2VyQ2xpZW50LnByb3RvdHlwZS5vbkNvbm5lY3Rpb25DbG9zZSA9IGZ1bmN0aW9uKCkge1xuXHRjb25zb2xlLmxvZyhcIioqKiogY29ubmVjdGlvbiBjbG9zZWRcIik7XG5cdGlmICh0aGlzLnByb3RvQ29ubmVjdGlvbilcblx0XHR0aGlzLnByb3RvQ29ubmVjdGlvbi5yZW1vdmVNZXNzYWdlSGFuZGxlcihTdGF0ZUNvbXBsZXRlTWVzc2FnZSwgdGhpcy5vblN0YXRlQ29tcGxldGVNZXNzYWdlLCB0aGlzKTtcblxuXHR0aGlzLnByb3RvQ29ubmVjdGlvbiA9IG51bGw7XG5cdHRoaXMubmV0UG9rZXJDbGllbnRDb250cm9sbGVyLnNldFByb3RvQ29ubmVjdGlvbihudWxsKTtcblx0dGhpcy5lbnRlckFwcFN0YXRlKFwiQ09OTkVDVElPTiBFUlJPUlwiKTtcblx0c2V0VGltZW91dCh0aGlzLmNvbm5lY3QuYmluZCh0aGlzKSwgMzAwMCk7XG59XG5cbi8qKlxuICogRW50ZXIgYXBwIHN0YXRlLlxuICogQG1ldGhvZCBlbnRlckFwcFN0YXRlXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRQb2tlckNsaWVudC5wcm90b3R5cGUuZW50ZXJBcHBTdGF0ZSA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHByb2dyZXNzKSB7XG5cdGlmIChtZXNzYWdlKVxuXHRcdHRoaXMubG9hZGluZ1NjcmVlbi5zaG93KG1lc3NhZ2UpO1xuXG5cdGVsc2Vcblx0XHR0aGlzLmxvYWRpbmdTY3JlZW4uaGlkZSgpO1xuXG5cdHRoaXMudHJpZ2dlcih7XG5cdFx0dHlwZTogXCJhcHBTdGF0ZUNoYW5nZVwiLFxuXHRcdG1lc3NhZ2U6IG1lc3NhZ2UsXG5cdFx0cHJvZ3Jlc3M6IHByb2dyZXNzXG5cdH0pO1xufVxuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZ2V0IGFsbCBxdWVyeSBzdHJpbmcgcGFyYW1zLlxuICogQG1ldGhvZCBnZXRRdWVyeVN0cmluZ1BhcmFtc1xuICogQHN0YXRpY1xuICovXG5OZXRQb2tlckNsaWVudC5nZXRRdWVyeVN0cmluZ1BhcmFtcyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgcGFyYW1zID0ge307XG5cdChmdW5jdGlvbigpIHtcblxuXHRcdHZhciBtYXRjaCxcblx0XHRcdHBsID0gL1xcKy9nLCAvLyBSZWdleCBmb3IgcmVwbGFjaW5nIGFkZGl0aW9uIHN5bWJvbCB3aXRoIGEgc3BhY2Vcblx0XHRcdHNlYXJjaCA9IC8oW14mPV0rKT0/KFteJl0qKS9nLFxuXHRcdFx0ZGVjb2RlID0gZnVuY3Rpb24ocykge1xuXHRcdFx0XHRyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHMucmVwbGFjZShwbCwgXCIgXCIpKTtcblx0XHRcdH0sXG5cdFx0XHRxdWVyeSA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpLnJlcGxhY2UoL2FtcDsvZywgXCJcIik7XG5cblx0XHR3aGlsZSAobWF0Y2ggPSBzZWFyY2guZXhlYyhxdWVyeSkpXG5cdFx0XHRwYXJhbXNbZGVjb2RlKG1hdGNoWzFdKV0gPSBkZWNvZGUobWF0Y2hbMl0pO1xuXHR9KSgpO1xuXG5cdHJldHVybiBwYXJhbXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTmV0UG9rZXJDbGllbnQ7IiwiLyoqXG4gKiBVdGlsaXRpZXMuXG4gKiBAbW9kdWxlIHV0aWxzXG4gKi9cblxudmFyIFBJWEkgPSByZXF1aXJlKFwicGl4aS5qc1wiKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCJpbmhlcml0c1wiKTtcblxuLyoqXG4gKiBOaW5lIHNsaWNlLiBUaGlzIGlzIGEgc3ByaXRlIHRoYXQgaXMgYSBncmlkLCBhbmQgb25seSB0aGVcbiAqIG1pZGRsZSBwYXJ0IHN0cmV0Y2hlcyB3aGVuIHNjYWxpbmcuXG4gKiBAY2xhc3MgTmluZVNsaWNlXG4gKi9cbmZ1bmN0aW9uIE5pbmVTbGljZSh0ZXh0dXJlLCBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pIHtcblx0UElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLmNhbGwodGhpcyk7XG5cblx0dGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcblxuXHRpZiAoIXRvcClcblx0XHR0b3AgPSBsZWZ0O1xuXG5cdGlmICghcmlnaHQpXG5cdFx0cmlnaHQgPSBsZWZ0O1xuXG5cdGlmICghYm90dG9tKVxuXHRcdGJvdHRvbSA9IHRvcDtcblxuXHR0aGlzLmxlZnQgPSBsZWZ0O1xuXHR0aGlzLnRvcCA9IHRvcDtcblx0dGhpcy5yaWdodCA9IHJpZ2h0O1xuXHR0aGlzLmJvdHRvbSA9IGJvdHRvbTtcblxuXHR0aGlzLmxvY2FsV2lkdGggPSB0ZXh0dXJlLndpZHRoO1xuXHR0aGlzLmxvY2FsSGVpZ2h0ID0gdGV4dHVyZS5oZWlnaHQ7XG5cblx0dGhpcy5idWlsZFBhcnRzKCk7XG5cdHRoaXMudXBkYXRlU2l6ZXMoKTtcbn1cblxuaW5oZXJpdHMoTmluZVNsaWNlLCBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIpO1xuXG4vKipcbiAqIEJ1aWxkIHRoZSBwYXJ0cyBmb3IgdGhlIHNsaWNlcy5cbiAqIEBtZXRob2QgYnVpbGRQYXJ0c1xuICogQHByaXZhdGVcbiAqL1xuTmluZVNsaWNlLnByb3RvdHlwZS5idWlsZFBhcnRzID0gZnVuY3Rpb24oKSB7XG5cdHZhciB4cCA9IFswLCB0aGlzLmxlZnQsIHRoaXMudGV4dHVyZS53aWR0aCAtIHRoaXMucmlnaHQsIHRoaXMudGV4dHVyZS53aWR0aF07XG5cdHZhciB5cCA9IFswLCB0aGlzLnRvcCwgdGhpcy50ZXh0dXJlLmhlaWdodCAtIHRoaXMuYm90dG9tLCB0aGlzLnRleHR1cmUuaGVpZ2h0XTtcblx0dmFyIGhpLCB2aTtcblxuXHR0aGlzLnBhcnRzID0gW107XG5cblx0Zm9yICh2aSA9IDA7IHZpIDwgMzsgdmkrKykge1xuXHRcdGZvciAoaGkgPSAwOyBoaSA8IDM7IGhpKyspIHtcblx0XHRcdHZhciB3ID0geHBbaGkgKyAxXSAtIHhwW2hpXTtcblx0XHRcdHZhciBoID0geXBbdmkgKyAxXSAtIHlwW3ZpXTtcblxuXHRcdFx0aWYgKHcgIT0gMCAmJiBoICE9IDApIHtcblx0XHRcdFx0dmFyIHRleHR1cmVQYXJ0ID0gdGhpcy5jcmVhdGVUZXh0dXJlUGFydCh4cFtoaV0sIHlwW3ZpXSwgdywgaCk7XG5cdFx0XHRcdHZhciBzID0gbmV3IFBJWEkuU3ByaXRlKHRleHR1cmVQYXJ0KTtcblx0XHRcdFx0dGhpcy5hZGRDaGlsZChzKTtcblxuXHRcdFx0XHR0aGlzLnBhcnRzLnB1c2gocyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnBhcnRzLnB1c2gobnVsbCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogVXBkYXRlIHNpemVzLlxuICogQG1ldGhvZCB1cGRhdGVTaXplc1xuICogQHByaXZhdGVcbiAqL1xuTmluZVNsaWNlLnByb3RvdHlwZS51cGRhdGVTaXplcyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgeHAgPSBbMCwgdGhpcy5sZWZ0LCB0aGlzLmxvY2FsV2lkdGggLSB0aGlzLnJpZ2h0LCB0aGlzLmxvY2FsV2lkdGhdO1xuXHR2YXIgeXAgPSBbMCwgdGhpcy50b3AsIHRoaXMubG9jYWxIZWlnaHQgLSB0aGlzLmJvdHRvbSwgdGhpcy5sb2NhbEhlaWdodF07XG5cdHZhciBoaSwgdmksIGkgPSAwO1xuXG5cdGZvciAodmkgPSAwOyB2aSA8IDM7IHZpKyspIHtcblx0XHRmb3IgKGhpID0gMDsgaGkgPCAzOyBoaSsrKSB7XG5cdFx0XHRpZiAodGhpcy5wYXJ0c1tpXSkge1xuXHRcdFx0XHR2YXIgcGFydCA9IHRoaXMucGFydHNbaV07XG5cblx0XHRcdFx0cGFydC5wb3NpdGlvbi54ID0geHBbaGldO1xuXHRcdFx0XHRwYXJ0LnBvc2l0aW9uLnkgPSB5cFt2aV07XG5cdFx0XHRcdHBhcnQud2lkdGggPSB4cFtoaSArIDFdIC0geHBbaGldO1xuXHRcdFx0XHRwYXJ0LmhlaWdodCA9IHlwW3ZpICsgMV0gLSB5cFt2aV07XG5cdFx0XHR9XG5cblx0XHRcdGkrKztcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBTZXQgbG9jYWwgc2l6ZS5cbiAqIEBtZXRob2Qgc2V0TG9jYWxTaXplXG4gKi9cbk5pbmVTbGljZS5wcm90b3R5cGUuc2V0TG9jYWxTaXplID0gZnVuY3Rpb24odywgaCkge1xuXHR0aGlzLmxvY2FsV2lkdGggPSB3O1xuXHR0aGlzLmxvY2FsSGVpZ2h0ID0gaDtcblx0dGhpcy51cGRhdGVTaXplcygpO1xufVxuXG4vKipcbiAqIENyZWF0ZSB0ZXh0dXJlIHBhcnQuXG4gKiBAbWV0aG9kIGNyZWF0ZVRleHR1cmVQYXJ0XG4gKiBAcHJpdmF0ZVxuICovXG5OaW5lU2xpY2UucHJvdG90eXBlLmNyZWF0ZVRleHR1cmVQYXJ0ID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHR2YXIgZnJhbWUgPSB7XG5cdFx0eDogdGhpcy50ZXh0dXJlLmZyYW1lLnggKyB4LFxuXHRcdHk6IHRoaXMudGV4dHVyZS5mcmFtZS55ICsgeSxcblx0XHR3aWR0aDogd2lkdGgsXG5cdFx0aGVpZ2h0OiBoZWlnaHRcblx0fTtcblxuXHRyZXR1cm4gbmV3IFBJWEkuVGV4dHVyZSh0aGlzLnRleHR1cmUsIGZyYW1lKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBOaW5lU2xpY2U7IiwidmFyIFRoZW5hYmxlID0gcmVxdWlyZShcInRpbnBcIik7XG52YXIgUElYSSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xudmFyIFVybFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvVXJsVXRpbFwiKTtcbnZhciBIdHRwUmVxdWVzdCA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9IdHRwUmVxdWVzdFwiKTtcblxuLyoqXG4gKiBSZXNvdXJjZXNcbiAqIEBjbGFzcyBSZXNvdXJjZXNcbiAqL1xuZnVuY3Rpb24gUmVzb3VyY2VzKCkge1xuXHR0aGlzLnNwcml0ZVNoZWV0cyA9IFtdO1xuXHR0aGlzLnNraW5Tb3VyY2VzID0gW107XG5cdHRoaXMuZGF0YSA9IFtdO1xuXHR0aGlzLmxvYWRUaGVuYWJsZSA9IG51bGw7XG5cdHRoaXMuc2tpblNvdXJjZUluZGV4ID0gMDtcbn1cblxuLyoqXG4gKiBTZXQgc3ByaXRlIHNoZWV0LlxuICogQG1ldGhvZCBzZXRTcHJpdGVTaGVldFxuICovXG5SZXNvdXJjZXMucHJvdG90eXBlLnNldFNwcml0ZVNoZWV0ID0gZnVuY3Rpb24oc3ByaXRlU2hlZXQpIHtcblx0dGhpcy5zcHJpdGVTaGVldHMgPSBbc3ByaXRlU2hlZXRdO1xufVxuXG4vKipcbiAqIEFkZCBhIHNwcml0ZSBzaGVldC5cbiAqIEBtZXRob2QgYWRkU3ByaXRlU2hlZXRcbiAqL1xuUmVzb3VyY2VzLnByb3RvdHlwZS5hZGRTcHJpdGVTaGVldCA9IGZ1bmN0aW9uKHNwcml0ZVNoZWV0KSB7XG5cdHRoaXMuc3ByaXRlU2hlZXRzLnB1c2goc3ByaXRlU2hlZXQpO1xufVxuXG4vKipcbiAqIEFkZCBhIGNhc2NhZGluZyBza2luIHNvdXJjZS5cbiAqIE9iamVjdCBvciB1cmwuXG4gKiBAbWV0aG9kIHNvdXJjZVxuICovXG5SZXNvdXJjZXMucHJvdG90eXBlLmFkZFNraW5Tb3VyY2UgPSBmdW5jdGlvbihzb3VyY2UpIHtcblx0dGhpcy5za2luU291cmNlcy5wdXNoKHNvdXJjZSk7XG59XG5cbi8qKlxuICogR2V0IGEgUG9pbnQgcmVzb3VyY2UuXG4gKiBAbWV0aG9kIGdldFBvaW50XG4gKi9cblJlc291cmNlcy5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbihpZCkge1xuXHR0aGlzLmFzc2VydEtleUV4aXN0cyhpZCk7XG5cblx0cmV0dXJuIG5ldyBQSVhJLlBvaW50KHRoaXMuZGF0YVtpZF1bMF0sIHRoaXMuZGF0YVtpZF1bMV0pO1xufVxuXG4vKipcbiAqIEdldCBhIHN0cmluZyByZXNvdXJjZS5cbiAqIEBtZXRob2QgZ2V0U3RyaW5nXG4gKi9cblJlc291cmNlcy5wcm90b3R5cGUuZ2V0U3RyaW5nID0gZnVuY3Rpb24oaWQpIHtcblx0dGhpcy5hc3NlcnRLZXlFeGlzdHMoaWQpO1xuXG5cdHJldHVybiB0aGlzLmRhdGFbaWRdLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogR2V0IHZhbHVlLlxuICogQG1ldGhvZCBnZXRWYWx1ZVxuICovXG5SZXNvdXJjZXMucHJvdG90eXBlLmdldFZhbHVlID0gUmVzb3VyY2VzLnByb3RvdHlwZS5nZXRTdHJpbmc7XG5cbi8qKlxuICogR2V0IGNvbG9yLlxuICogQG1ldGhvZCBnZXRWYWx1ZVxuICovXG5SZXNvdXJjZXMucHJvdG90eXBlLmdldENvbG9yID0gUmVzb3VyY2VzLnByb3RvdHlwZS5nZXRTdHJpbmc7XG5cbi8qKlxuICogR2V0IFRleHR1cmUuXG4gKiBAbWV0aG9kIGdldFRleHR1cmVcbiAqL1xuUmVzb3VyY2VzLnByb3RvdHlwZS5nZXRUZXh0dXJlID0gZnVuY3Rpb24oaWQpIHtcblx0dmFyIHRleHR1cmUgPSBQSVhJLlRleHR1cmUuZnJvbUZyYW1lKHRoaXMuZ2V0U3RyaW5nKGlkKSk7XG5cblx0cmV0dXJuIHRleHR1cmU7XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGtleSBleGlzdHMuXG4gKiBAbWV0aG9kIGFzc2VydEtleUV4aXN0c1xuICogQHByaXZhdGVcbiAqL1xuUmVzb3VyY2VzLnByb3RvdHlwZS5hc3NlcnRLZXlFeGlzdHMgPSBmdW5jdGlvbihpZCkge1xuXHRpZiAoIXRoaXMuZGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkpXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiTm8gc3VjaCByZXNvdXJjZTogXCIgKyBpZCk7XG59XG5cbi8qKlxuICogRG9lcyB0aGlzIGtleSBleGlzdD9cbiAqIEBtZXRob2Qga2V5RXhpc3RzXG4gKi9cblJlc291cmNlcy5wcm90b3R5cGUua2V5RXhpc3RzID0gZnVuY3Rpb24oaWQpIHtcblx0cmV0dXJuIHRoaXMuZGF0YS5oYXNPd25Qcm9wZXJ0eShpZCk7XG59XG5cbi8qKlxuICogTG9hZCByZXNvdXJjZXMuXG4gKiBAbWV0aG9kIGxvYWRcbiAqL1xuUmVzb3VyY2VzLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLmxvYWRUaGVuYWJsZSlcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IGxvYWRpbmdcIik7XG5cblx0dGhpcy5sb2FkVGhlbmFibGUgPSBuZXcgVGhlbmFibGUoKTtcblx0dGhpcy5za2luU291cmNlSW5kZXggPSAwO1xuXG5cdGlmICh0aGlzLnNwcml0ZVNoZWV0cy5sZW5ndGgpIHtcblx0XHR0aGlzLmFzc2V0TG9hZGVyID0gbmV3IFBJWEkuQXNzZXRMb2FkZXIodGhpcy5zcHJpdGVTaGVldHMpO1xuXHRcdHRoaXMuYXNzZXRMb2FkZXIub24oXCJvbkNvbXBsZXRlXCIsIHRoaXMub25Bc3NldExvYWRlckNvbXBsZXRlLmJpbmQodGhpcykpO1xuXHRcdHRoaXMuYXNzZXRMb2FkZXIub24oXCJvblByb2dyZXNzXCIsIHRoaXMub25Bc3NldExvYWRlclByb2dyZXNzLmJpbmQodGhpcykpO1xuXHRcdC8vY29uc29sZS5sb2coXCJsb2FkaW5nIGFzc2V0czogXCIrdGhpcy5zcHJpdGVTaGVldHMpO1xuXHRcdHRoaXMuYXNzZXRMb2FkZXIubG9hZCgpO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMubG9hZE5leHRTa2luU291cmNlKCk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5sb2FkVGhlbmFibGU7XG59XG5cbi8qKlxuICogQXNzZXQgbG9hZGVyIHByb2dyZXNzLlxuICogQG1ldGhvZCBvbkFzc2V0TG9hZGVyUHJvZ3Jlc3NcbiAqL1xuUmVzb3VyY2VzLnByb3RvdHlwZS5vbkFzc2V0TG9hZGVyUHJvZ3Jlc3MgPSBmdW5jdGlvbihldikge1xuXHRjb25zb2xlLmxvZyhcImFzc2V0IGxvYWRlciBwcm9ncmVzc1wiKTtcblx0LypcdGNvbnNvbGUubG9nKGV2KTtcblxuXHRcdGV2LmxvYWRlci5hamF4UmVxdWVzdC5vbnByb2dyZXNzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcInJlcXVlc3QgcHJvZ3Jlcy4uLlwiKTtcblx0XHR9O1xuXG5cdFx0ZXYubG9hZGVyLmFqYXhSZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdGNvbnNvbGUubG9nKFwicHJvZ3Jlc3MuLi5cIik7XG5cdFx0fSk7Ki9cbn1cblxuLyoqXG4gKiBBc3NldCBsb2FkZXIgY29tcGxldGUuXG4gKiBAbWV0aG9kIG9uQXNzZXRMb2FkZXJDb21wbGV0ZVxuICovXG5SZXNvdXJjZXMucHJvdG90eXBlLm9uQXNzZXRMb2FkZXJDb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHQvL2NvbnNvbGUubG9nKFwiYXNzZXQgbG9hZGVyIGNvbXBsZXRlLCBsb2FkaW5nIHNraW5cIik7XG5cdHRoaXMubG9hZE5leHRTa2luU291cmNlKCk7XG59XG5cbi8qKlxuICogUHJvY2VzcyBuZXh0IHNraW4gc291cmNlIGluIHNlcXVlbmNlLlxuICogQG1ldGhvZCBsb2FkTmV4dFNraW5Tb3VyY2VcbiAqIEBwcml2YXRlXG4gKi9cblJlc291cmNlcy5wcm90b3R5cGUubG9hZE5leHRTa2luU291cmNlID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLnNraW5Tb3VyY2VJbmRleCA+PSB0aGlzLnNraW5Tb3VyY2VzLmxlbmd0aCkge1xuXHRcdC8vY29uc29sZS5sb2coXCJyZXNvbHZpbmcgdGhlbmFibGUuLi5cIik7XG5cdFx0dGhpcy5sb2FkVGhlbmFibGUucmVzb2x2ZSgpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBvID0gdGhpcy5za2luU291cmNlc1t0aGlzLnNraW5Tb3VyY2VJbmRleF07XG5cblx0aWYgKHR5cGVvZiBvID09IFwib2JqZWN0XCIpIHtcblx0XHR0aGlzLnByb2Nlc3NTa2luRGF0YShvKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgcmVxdWVzdCA9IG5ldyBIdHRwUmVxdWVzdChVcmxVdGlsLm1ha2VBYnNvbHV0ZShvKSk7XG5cdHJlcXVlc3Quc2V0UmVzdWx0VHlwZShcImpzb25cIik7XG5cblx0cmVxdWVzdC5zZW5kKCkudGhlbihcblx0XHR0aGlzLm9uU2tpblNvdXJjZUxvYWRlZC5iaW5kKHRoaXMpLFxuXHRcdHRoaXMub25Ta2luU291cmNlTG9hZEVycm9yLmJpbmQodGhpcylcblx0KTtcbn1cblxuLyoqXG4gKiBTa2luIHNvdXJjZSBsb2FkZWQuXG4gKiBAbWV0aG9kIG9uU2tpblNvdXJjZUxvYWRlZFxuICovXG5SZXNvdXJjZXMucHJvdG90eXBlLm9uU2tpblNvdXJjZUxvYWRlZCA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0dGhpcy5wcm9jZXNzU2tpbkRhdGEoZGF0YSk7XG59XG5cbi8qKlxuICogU2tpbiBzb3VyY2UgbG9hZCBlcnJvci5cbiAqIEBtZXRob2Qgb25Ta2luU291cmNlTG9hZEVycm9yXG4gKi9cblJlc291cmNlcy5wcm90b3R5cGUub25Ta2luU291cmNlTG9hZEVycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcblx0dGhpcy5sb2FkVGhlbmFibGUucmVqZWN0KGVycm9yKTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIHNraW4gZGF0YS5cbiAqIEBtZXRob2QgcHJvY2Vzc1NraW5EYXRhXG4gKi9cblJlc291cmNlcy5wcm90b3R5cGUucHJvY2Vzc1NraW5EYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuXHRmb3IgKGkgaW4gZGF0YSlcblx0XHR0aGlzLmRhdGFbaV0gPSBkYXRhW2ldO1xuXG5cdHRoaXMuc2tpblNvdXJjZUluZGV4Kys7XG5cdHRoaXMubG9hZE5leHRTa2luU291cmNlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVzb3VyY2VzOyIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIHBpeGkuanMgLSB2MS42LjBcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBNYXQgR3JvdmVzXG4gKiBodHRwOi8vZ29vZGJveWRpZ2l0YWwuY29tL1xuICpcbiAqIENvbXBpbGVkOiAyMDE0LTA3LTE4XG4gKlxuICogcGl4aS5qcyBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICovXG4vKipcclxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgdmFyIHJvb3QgPSB0aGlzO1xyXG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKiBAbW9kdWxlIFBJWElcbiAqL1xudmFyIFBJWEkgPSBQSVhJIHx8IHt9O1xuXG4vKiBcbiogXG4qIFRoaXMgZmlsZSBjb250YWlucyBhIGxvdCBvZiBwaXhpIGNvbnN0cyB3aGljaCBhcmUgdXNlZCBhY3Jvc3MgdGhlIHJlbmRlcmluZyBlbmdpbmVcbiogQGNsYXNzIENvbnN0c1xuKi9cblBJWEkuV0VCR0xfUkVOREVSRVIgPSAwO1xuUElYSS5DQU5WQVNfUkVOREVSRVIgPSAxO1xuXG4vLyB1c2VmdWwgZm9yIHRlc3RpbmcgYWdhaW5zdCBpZiB5b3VyIGxpYiBpcyB1c2luZyBwaXhpLlxuUElYSS5WRVJTSU9OID0gXCJ2MS42LjFcIjtcblxuXG4vLyB0aGUgdmFyaW91cyBibGVuZCBtb2RlcyBzdXBwb3J0ZWQgYnkgcGl4aVxuUElYSS5ibGVuZE1vZGVzID0ge1xuICAgIE5PUk1BTDowLFxuICAgIEFERDoxLFxuICAgIE1VTFRJUExZOjIsXG4gICAgU0NSRUVOOjMsXG4gICAgT1ZFUkxBWTo0LFxuICAgIERBUktFTjo1LFxuICAgIExJR0hURU46NixcbiAgICBDT0xPUl9ET0RHRTo3LFxuICAgIENPTE9SX0JVUk46OCxcbiAgICBIQVJEX0xJR0hUOjksXG4gICAgU09GVF9MSUdIVDoxMCxcbiAgICBESUZGRVJFTkNFOjExLFxuICAgIEVYQ0xVU0lPTjoxMixcbiAgICBIVUU6MTMsXG4gICAgU0FUVVJBVElPTjoxNCxcbiAgICBDT0xPUjoxNSxcbiAgICBMVU1JTk9TSVRZOjE2XG59O1xuXG4vLyB0aGUgc2NhbGUgbW9kZXNcblBJWEkuc2NhbGVNb2RlcyA9IHtcbiAgICBERUZBVUxUOjAsXG4gICAgTElORUFSOjAsXG4gICAgTkVBUkVTVDoxXG59O1xuXG4vLyB1c2VkIHRvIGNyZWF0ZSB1aWRzIGZvciB2YXJpb3VzIHBpeGkgb2JqZWN0cy4uXG5QSVhJLl9VSUQgPSAwO1xuXG5pZih0eXBlb2YoRmxvYXQzMkFycmF5KSAhPSAndW5kZWZpbmVkJylcbntcbiAgICBQSVhJLkZsb2F0MzJBcnJheSA9IEZsb2F0MzJBcnJheTtcbiAgICBQSVhJLlVpbnQxNkFycmF5ID0gVWludDE2QXJyYXk7XG59XG5lbHNlXG57XG4gICAgUElYSS5GbG9hdDMyQXJyYXkgPSBBcnJheTtcbiAgICBQSVhJLlVpbnQxNkFycmF5ID0gQXJyYXk7XG59XG5cbi8vIGludGVyYWN0aW9uIGZyZXF1ZW5jeSBcblBJWEkuSU5URVJBQ1RJT05fRlJFUVVFTkNZID0gMzA7XG5QSVhJLkFVVE9fUFJFVkVOVF9ERUZBVUxUID0gdHJ1ZTtcblxuUElYSS5SQURfVE9fREVHID0gMTgwIC8gTWF0aC5QSTtcblBJWEkuREVHX1RPX1JBRCA9IE1hdGguUEkgLyAxODA7XG5cblxuUElYSS5kb250U2F5SGVsbG8gPSBmYWxzZTtcblxuUElYSS5zYXlIZWxsbyA9IGZ1bmN0aW9uICh0eXBlKSBcbntcbiAgICBpZihQSVhJLmRvbnRTYXlIZWxsbylyZXR1cm47XG5cbiAgICBpZiAoIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdjaHJvbWUnKSA+IC0xIClcbiAgICB7XG4gICAgICAgIHZhciBhcmdzID0gW1xuICAgICAgICAgICAgJyVjICVjICVjIFBpeGkuanMgJyArIFBJWEkuVkVSU0lPTiArICcgLSAnICsgdHlwZSArICcgICVjICcgKyAnICVjICcgKyAnIGh0dHA6Ly93d3cucGl4aWpzLmNvbS8gICVjICVjIOKZpSVj4pmlJWPimaUgJyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kOiAjZmY2NmE1JyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kOiAjZmY2NmE1JyxcbiAgICAgICAgICAgICdjb2xvcjogI2ZmNjZhNTsgYmFja2dyb3VuZDogIzAzMDMwNzsnLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQ6ICNmZjY2YTUnLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQ6ICNmZmMzZGMnLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQ6ICNmZjY2YTUnLFxuICAgICAgICAgICAgJ2NvbG9yOiAjZmYyNDI0OyBiYWNrZ3JvdW5kOiAjZmZmJyxcbiAgICAgICAgICAgICdjb2xvcjogI2ZmMjQyNDsgYmFja2dyb3VuZDogI2ZmZicsXG4gICAgICAgICAgICAnY29sb3I6ICNmZjI0MjQ7IGJhY2tncm91bmQ6ICNmZmYnXG4gICAgICAgIF07XG5cbiAgICAgICBcblxuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAod2luZG93Wydjb25zb2xlJ10pXG4gICAge1xuICAgICAgICBjb25zb2xlLmxvZygnUGl4aS5qcyAnICsgUElYSS5WRVJTSU9OICsgJyAtIGh0dHA6Ly93d3cucGl4aWpzLmNvbS8nKTtcbiAgICB9XG5cbiAgICBQSVhJLmRvbnRTYXlIZWxsbyA9IHRydWU7XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogVGhlIFBvaW50IG9iamVjdCByZXByZXNlbnRzIGEgbG9jYXRpb24gaW4gYSB0d28tZGltZW5zaW9uYWwgY29vcmRpbmF0ZSBzeXN0ZW0sIHdoZXJlIHggcmVwcmVzZW50cyB0aGUgaG9yaXpvbnRhbCBheGlzIGFuZCB5IHJlcHJlc2VudHMgdGhlIHZlcnRpY2FsIGF4aXMuXG4gKlxuICogQGNsYXNzIFBvaW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB4IHtOdW1iZXJ9IHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeCBheGlzXG4gKiBAcGFyYW0geSB7TnVtYmVyfSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHkgYXhpc1xuICovXG5QSVhJLlBvaW50ID0gZnVuY3Rpb24oeCwgeSlcbntcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgeFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnggPSB4IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgeVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnkgPSB5IHx8IDA7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHBvaW50XG4gKlxuICogQG1ldGhvZCBjbG9uZVxuICogQHJldHVybiB7UG9pbnR9IGEgY29weSBvZiB0aGUgcG9pbnRcbiAqL1xuUElYSS5Qb2ludC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpXG57XG4gICAgcmV0dXJuIG5ldyBQSVhJLlBvaW50KHRoaXMueCwgdGhpcy55KTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcG9pbnQgdG8gYSBuZXcgeCBhbmQgeSBwb3NpdGlvbi5cbiAqIElmIHkgaXMgb21taXRlZCwgYm90aCB4IGFuZCB5IHdpbGwgYmUgc2V0IHRvIHguXG4gKiBcbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0gW3g9MF0ge051bWJlcn0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB4IGF4aXNcbiAqIEBwYXJhbSBbeT0wXSB7TnVtYmVyfSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHkgYXhpc1xuICovXG5QSVhJLlBvaW50LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbih4LCB5KVxue1xuICAgIHRoaXMueCA9IHggfHwgMDtcbiAgICB0aGlzLnkgPSB5IHx8ICggKHkgIT09IDApID8gdGhpcy54IDogMCApIDtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLlBvaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuUG9pbnQ7XG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS9cbiAqL1xuXG4vKipcbiAqIHRoZSBSZWN0YW5nbGUgb2JqZWN0IGlzIGFuIGFyZWEgZGVmaW5lZCBieSBpdHMgcG9zaXRpb24sIGFzIGluZGljYXRlZCBieSBpdHMgdG9wLWxlZnQgY29ybmVyIHBvaW50ICh4LCB5KSBhbmQgYnkgaXRzIHdpZHRoIGFuZCBpdHMgaGVpZ2h0LlxuICpcbiAqIEBjbGFzcyBSZWN0YW5nbGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHgge051bWJlcn0gVGhlIFggY29vcmQgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAqIEBwYXJhbSB5IHtOdW1iZXJ9IFRoZSBZIGNvb3JkIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gd2lkdGgge051bWJlcn0gVGhlIG92ZXJhbGwgd2lkdGggb2YgdGhpcyByZWN0YW5nbGVcbiAqIEBwYXJhbSBoZWlnaHQge051bWJlcn0gVGhlIG92ZXJhbGwgaGVpZ2h0IG9mIHRoaXMgcmVjdGFuZ2xlXG4gKi9cblBJWEkuUmVjdGFuZ2xlID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodClcbntcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgeFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnggPSB4IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgeVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnkgPSB5IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgd2lkdGhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaGVpZ2h0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDA7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIFJlY3RhbmdsZVxuICpcbiAqIEBtZXRob2QgY2xvbmVcbiAqIEByZXR1cm4ge1JlY3RhbmdsZX0gYSBjb3B5IG9mIHRoZSByZWN0YW5nbGVcbiAqL1xuUElYSS5SZWN0YW5nbGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKVxue1xuICAgIHJldHVybiBuZXcgUElYSS5SZWN0YW5nbGUodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBSZWN0YW5nbGVcbiAqXG4gKiBAbWV0aG9kIGNvbnRhaW5zXG4gKiBAcGFyYW0geCB7TnVtYmVyfSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gKiBAcGFyYW0geSB7TnVtYmVyfSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRzIGFyZSB3aXRoaW4gdGhpcyBSZWN0YW5nbGVcbiAqL1xuUElYSS5SZWN0YW5nbGUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oeCwgeSlcbntcbiAgICBpZih0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIHgxID0gdGhpcy54O1xuICAgIGlmKHggPj0geDEgJiYgeCA8PSB4MSArIHRoaXMud2lkdGgpXG4gICAge1xuICAgICAgICB2YXIgeTEgPSB0aGlzLnk7XG5cbiAgICAgICAgaWYoeSA+PSB5MSAmJiB5IDw9IHkxICsgdGhpcy5oZWlnaHQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuUmVjdGFuZ2xlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuUmVjdGFuZ2xlO1xuXG5QSVhJLkVtcHR5UmVjdGFuZ2xlID0gbmV3IFBJWEkuUmVjdGFuZ2xlKDAsMCwwLDApO1xuLyoqXG4gKiBAYXV0aG9yIEFkcmllbiBCcmF1bHQgPGFkcmllbi5icmF1bHRAZ21haWwuY29tPlxuICovXG5cbi8qKlxuICogQGNsYXNzIFBvbHlnb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHBvaW50cyoge0FycmF5PFBvaW50PnxBcnJheTxOdW1iZXI+fFBvaW50Li4ufE51bWJlci4uLn0gVGhpcyBjYW4gYmUgYW4gYXJyYXkgb2YgUG9pbnRzIHRoYXQgZm9ybSB0aGUgcG9seWdvbixcbiAqICAgICAgYSBmbGF0IGFycmF5IG9mIG51bWJlcnMgdGhhdCB3aWxsIGJlIGludGVycHJldGVkIGFzIFt4LHksIHgseSwgLi4uXSwgb3IgdGhlIGFyZ3VtZW50cyBwYXNzZWQgY2FuIGJlXG4gKiAgICAgIGFsbCB0aGUgcG9pbnRzIG9mIHRoZSBwb2x5Z29uIGUuZy4gYG5ldyBQSVhJLlBvbHlnb24obmV3IFBJWEkuUG9pbnQoKSwgbmV3IFBJWEkuUG9pbnQoKSwgLi4uKWAsIG9yIHRoZVxuICogICAgICBhcmd1bWVudHMgcGFzc2VkIGNhbiBiZSBmbGF0IHgseSB2YWx1ZXMgZS5nLiBgbmV3IFBJWEkuUG9seWdvbih4LHksIHgseSwgeCx5LCAuLi4pYCB3aGVyZSBgeGAgYW5kIGB5YCBhcmVcbiAqICAgICAgTnVtYmVycy5cbiAqL1xuUElYSS5Qb2x5Z29uID0gZnVuY3Rpb24ocG9pbnRzKVxue1xuICAgIC8vaWYgcG9pbnRzIGlzbid0IGFuIGFycmF5LCB1c2UgYXJndW1lbnRzIGFzIHRoZSBhcnJheVxuICAgIGlmKCEocG9pbnRzIGluc3RhbmNlb2YgQXJyYXkpKVxuICAgICAgICBwb2ludHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgLy9pZiB0aGlzIGlzIGEgZmxhdCBhcnJheSBvZiBudW1iZXJzLCBjb252ZXJ0IGl0IHRvIHBvaW50c1xuICAgIGlmKHR5cGVvZiBwb2ludHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBwID0gW107XG4gICAgICAgIGZvcih2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpKz0yKSB7XG4gICAgICAgICAgICBwLnB1c2goXG4gICAgICAgICAgICAgICAgbmV3IFBJWEkuUG9pbnQocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvaW50cyA9IHA7XG4gICAgfVxuXG4gICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHBvbHlnb25cbiAqXG4gKiBAbWV0aG9kIGNsb25lXG4gKiBAcmV0dXJuIHtQb2x5Z29ufSBhIGNvcHkgb2YgdGhlIHBvbHlnb25cbiAqL1xuUElYSS5Qb2x5Z29uLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgcG9pbnRzID0gW107XG4gICAgZm9yICh2YXIgaT0wOyBpPHRoaXMucG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKHRoaXMucG9pbnRzW2ldLmNsb25lKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUElYSS5Qb2x5Z29uKHBvaW50cyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgcG9seWdvblxuICpcbiAqIEBtZXRob2QgY29udGFpbnNcbiAqIEBwYXJhbSB4IHtOdW1iZXJ9IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAqIEBwYXJhbSB5IHtOdW1iZXJ9IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgcG9seWdvblxuICovXG5QSVhJLlBvbHlnb24ucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oeCwgeSlcbntcbiAgICB2YXIgaW5zaWRlID0gZmFsc2U7XG5cbiAgICAvLyB1c2Ugc29tZSByYXljYXN0aW5nIHRvIHRlc3QgaGl0c1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9wb2ludC1pbi1wb2x5Z29uL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gICAgZm9yKHZhciBpID0gMCwgaiA9IHRoaXMucG9pbnRzLmxlbmd0aCAtIDE7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGogPSBpKyspIHtcbiAgICAgICAgdmFyIHhpID0gdGhpcy5wb2ludHNbaV0ueCwgeWkgPSB0aGlzLnBvaW50c1tpXS55LFxuICAgICAgICAgICAgeGogPSB0aGlzLnBvaW50c1tqXS54LCB5aiA9IHRoaXMucG9pbnRzW2pdLnksXG4gICAgICAgICAgICBpbnRlcnNlY3QgPSAoKHlpID4geSkgIT09ICh5aiA+IHkpKSAmJiAoeCA8ICh4aiAtIHhpKSAqICh5IC0geWkpIC8gKHlqIC0geWkpICsgeGkpO1xuXG4gICAgICAgIGlmKGludGVyc2VjdCkgaW5zaWRlID0gIWluc2lkZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zaWRlO1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuUG9seWdvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLlBvbHlnb247XG5cbi8qKlxuICogQGF1dGhvciBDaGFkIEVuZ2xlciA8Y2hhZEBwYW50aGVyZGV2LmNvbT5cbiAqL1xuXG4vKipcbiAqIFRoZSBDaXJjbGUgb2JqZWN0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgYSBoaXQgYXJlYSBmb3IgZGlzcGxheU9iamVjdHNcbiAqXG4gKiBAY2xhc3MgQ2lyY2xlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB4IHtOdW1iZXJ9IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGlzIGNpcmNsZVxuICogQHBhcmFtIHkge051bWJlcn0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoaXMgY2lyY2xlXG4gKiBAcGFyYW0gcmFkaXVzIHtOdW1iZXJ9IFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICovXG5QSVhJLkNpcmNsZSA9IGZ1bmN0aW9uKHgsIHksIHJhZGl1cylcbntcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgeFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnggPSB4IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgeVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnkgPSB5IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgcmFkaXVzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMucmFkaXVzID0gcmFkaXVzIHx8IDA7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIENpcmNsZSBpbnN0YW5jZVxuICpcbiAqIEBtZXRob2QgY2xvbmVcbiAqIEByZXR1cm4ge0NpcmNsZX0gYSBjb3B5IG9mIHRoZSBwb2x5Z29uXG4gKi9cblBJWEkuQ2lyY2xlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKClcbntcbiAgICByZXR1cm4gbmV3IFBJWEkuQ2lyY2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLnJhZGl1cyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSB4LCBhbmQgeSBjb29yZGluYXRlcyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIGNpcmNsZVxuICpcbiAqIEBtZXRob2QgY29udGFpbnNcbiAqIEBwYXJhbSB4IHtOdW1iZXJ9IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAqIEBwYXJhbSB5IHtOdW1iZXJ9IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgcG9seWdvblxuICovXG5QSVhJLkNpcmNsZS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbih4LCB5KVxue1xuICAgIGlmKHRoaXMucmFkaXVzIDw9IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBkeCA9ICh0aGlzLnggLSB4KSxcbiAgICAgICAgZHkgPSAodGhpcy55IC0geSksXG4gICAgICAgIHIyID0gdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cztcblxuICAgIGR4ICo9IGR4O1xuICAgIGR5ICo9IGR5O1xuXG4gICAgcmV0dXJuIChkeCArIGR5IDw9IHIyKTtcbn07XG5cbi8qKlxuKiBSZXR1cm5zIHRoZSBmcmFtaW5nIHJlY3RhbmdsZSBvZiB0aGUgY2lyY2xlIGFzIGEgUElYSS5SZWN0YW5nbGUgb2JqZWN0XG4qXG4qIEBtZXRob2QgZ2V0Qm91bmRzXG4qIEByZXR1cm4ge1JlY3RhbmdsZX0gdGhlIGZyYW1pbmcgcmVjdGFuZ2xlXG4qL1xuUElYSS5DaXJjbGUucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uKClcbntcbiAgICByZXR1cm4gbmV3IFBJWEkuUmVjdGFuZ2xlKHRoaXMueCAtIHRoaXMucmFkaXVzLCB0aGlzLnkgLSB0aGlzLnJhZGl1cywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuQ2lyY2xlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuQ2lyY2xlO1xuXG5cbi8qKlxuICogQGF1dGhvciBDaGFkIEVuZ2xlciA8Y2hhZEBwYW50aGVyZGV2LmNvbT5cbiAqL1xuXG4vKipcbiAqIFRoZSBFbGxpcHNlIG9iamVjdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGEgaGl0IGFyZWEgZm9yIGRpc3BsYXlPYmplY3RzXG4gKlxuICogQGNsYXNzIEVsbGlwc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHgge051bWJlcn0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlXG4gKiBAcGFyYW0geSB7TnVtYmVyfSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2VcbiAqIEBwYXJhbSB3aWR0aCB7TnVtYmVyfSBUaGUgaGFsZiB3aWR0aCBvZiB0aGlzIGVsbGlwc2VcbiAqIEBwYXJhbSBoZWlnaHQge051bWJlcn0gVGhlIGhhbGYgaGVpZ2h0IG9mIHRoaXMgZWxsaXBzZVxuICovXG5QSVhJLkVsbGlwc2UgPSBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KVxue1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB4XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMueCA9IHggfHwgMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB5XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMueSA9IHkgfHwgMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB3aWR0aFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLndpZHRoID0gd2lkdGggfHwgMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBoZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgMDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgRWxsaXBzZSBpbnN0YW5jZVxuICpcbiAqIEBtZXRob2QgY2xvbmVcbiAqIEByZXR1cm4ge0VsbGlwc2V9IGEgY29weSBvZiB0aGUgZWxsaXBzZVxuICovXG5QSVhJLkVsbGlwc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKVxue1xuICAgIHJldHVybiBuZXcgUElYSS5FbGxpcHNlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG59O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgZWxsaXBzZVxuICpcbiAqIEBtZXRob2QgY29udGFpbnNcbiAqIEBwYXJhbSB4IHtOdW1iZXJ9IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAqIEBwYXJhbSB5IHtOdW1iZXJ9IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHgveSBjb29yZHMgYXJlIHdpdGhpbiB0aGlzIGVsbGlwc2VcbiAqL1xuUElYSS5FbGxpcHNlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKHgsIHkpXG57XG4gICAgaWYodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIC8vbm9ybWFsaXplIHRoZSBjb29yZHMgdG8gYW4gZWxsaXBzZSB3aXRoIGNlbnRlciAwLDBcbiAgICB2YXIgbm9ybXggPSAoKHggLSB0aGlzLngpIC8gdGhpcy53aWR0aCksXG4gICAgICAgIG5vcm15ID0gKCh5IC0gdGhpcy55KSAvIHRoaXMuaGVpZ2h0KTtcblxuICAgIG5vcm14ICo9IG5vcm14O1xuICAgIG5vcm15ICo9IG5vcm15O1xuXG4gICAgcmV0dXJuIChub3JteCArIG5vcm15IDw9IDEpO1xufTtcblxuLyoqXG4qIFJldHVybnMgdGhlIGZyYW1pbmcgcmVjdGFuZ2xlIG9mIHRoZSBlbGxpcHNlIGFzIGEgUElYSS5SZWN0YW5nbGUgb2JqZWN0XG4qXG4qIEBtZXRob2QgZ2V0Qm91bmRzXG4qIEByZXR1cm4ge1JlY3RhbmdsZX0gdGhlIGZyYW1pbmcgcmVjdGFuZ2xlXG4qL1xuUElYSS5FbGxpcHNlLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbigpXG57XG4gICAgcmV0dXJuIG5ldyBQSVhJLlJlY3RhbmdsZSh0aGlzLnggLSB0aGlzLndpZHRoLCB0aGlzLnkgLSB0aGlzLmhlaWdodCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuRWxsaXBzZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkVsbGlwc2U7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKiBUaGUgTWF0cml4IGNsYXNzIGlzIG5vdyBhbiBvYmplY3QsIHdoaWNoIG1ha2VzIGl0IGEgbG90IGZhc3RlciwgXG4gKiBoZXJlIGlzIGEgcmVwcmVzZW50YXRpb24gb2YgaXQgOiBcbiAqIHwgYSB8IGIgfCB0eHxcbiAqIHwgYyB8IGQgfCB0eXxcbiAqIHwgMCB8IDAgfCAxIHxcbiAqXG4gKiBAY2xhc3MgTWF0cml4XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuUElYSS5NYXRyaXggPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5hID0gMTtcbiAgICB0aGlzLmIgPSAwO1xuICAgIHRoaXMuYyA9IDA7XG4gICAgdGhpcy5kID0gMTtcbiAgICB0aGlzLnR4ID0gMDtcbiAgICB0aGlzLnR5ID0gMDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHBpeGkgbWF0cml4IG9iamVjdCBiYXNlZCBvbiB0aGUgYXJyYXkgZ2l2ZW4gYXMgYSBwYXJhbWV0ZXJcbiAqXG4gKiBAbWV0aG9kIGZyb21BcnJheVxuICogQHBhcmFtIGFycmF5IHtBcnJheX0gVGhlIGFycmF5IHRoYXQgdGhlIG1hdHJpeCB3aWxsIGJlIGZpbGxlZCB3aXRoXG4gKi9cblBJWEkuTWF0cml4LnByb3RvdHlwZS5mcm9tQXJyYXkgPSBmdW5jdGlvbihhcnJheSlcbntcbiAgICB0aGlzLmEgPSBhcnJheVswXTtcbiAgICB0aGlzLmIgPSBhcnJheVsxXTtcbiAgICB0aGlzLmMgPSBhcnJheVszXTtcbiAgICB0aGlzLmQgPSBhcnJheVs0XTtcbiAgICB0aGlzLnR4ID0gYXJyYXlbMl07XG4gICAgdGhpcy50eSA9IGFycmF5WzVdO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGZyb20gdGhlIGN1cnJlbnQgTWF0cml4IG9iamVjdFxuICpcbiAqIEBtZXRob2QgdG9BcnJheVxuICogQHBhcmFtIHRyYW5zcG9zZSB7Qm9vbGVhbn0gV2hldGhlciB3ZSBuZWVkIHRvIHRyYW5zcG9zZSB0aGUgbWF0cml4IG9yIG5vdFxuICogQHJldHVybiB7QXJyYXl9IHRoZSBuZXdseSBjcmVhdGVkIGFycmF5IHdoaWNoIGNvbnRhaW5zIHRoZSBtYXRyaXhcbiAqL1xuUElYSS5NYXRyaXgucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbih0cmFuc3Bvc2UpXG57XG4gICAgaWYoIXRoaXMuYXJyYXkpIHRoaXMuYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDkpO1xuICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG5cbiAgICBpZih0cmFuc3Bvc2UpXG4gICAge1xuICAgICAgICBhcnJheVswXSA9IHRoaXMuYTtcbiAgICAgICAgYXJyYXlbMV0gPSB0aGlzLmM7XG4gICAgICAgIGFycmF5WzJdID0gMDtcbiAgICAgICAgYXJyYXlbM10gPSB0aGlzLmI7XG4gICAgICAgIGFycmF5WzRdID0gdGhpcy5kO1xuICAgICAgICBhcnJheVs1XSA9IDA7XG4gICAgICAgIGFycmF5WzZdID0gdGhpcy50eDtcbiAgICAgICAgYXJyYXlbN10gPSB0aGlzLnR5O1xuICAgICAgICBhcnJheVs4XSA9IDE7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGFycmF5WzBdID0gdGhpcy5hO1xuICAgICAgICBhcnJheVsxXSA9IHRoaXMuYjtcbiAgICAgICAgYXJyYXlbMl0gPSB0aGlzLnR4O1xuICAgICAgICBhcnJheVszXSA9IHRoaXMuYztcbiAgICAgICAgYXJyYXlbNF0gPSB0aGlzLmQ7XG4gICAgICAgIGFycmF5WzVdID0gdGhpcy50eTtcbiAgICAgICAgYXJyYXlbNl0gPSAwO1xuICAgICAgICBhcnJheVs3XSA9IDA7XG4gICAgICAgIGFycmF5WzhdID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG59O1xuXG5QSVhJLmlkZW50aXR5TWF0cml4ID0gbmV3IFBJWEkuTWF0cml4KCk7XG5cblBJWEkuZGV0ZXJtaW5lTWF0cml4QXJyYXlUeXBlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSAndW5kZWZpbmVkJykgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbn07XG5cbi8qKlxuICogVGhlIE1hdHJpeDIgY2xhc3Mgd2lsbCBjaG9vc2UgdGhlIGJlc3QgdHlwZSBvZiBhcnJheSB0byB1c2UgYmV0d2VlblxuICogYSByZWd1bGFyIGphdmFzY3JpcHQgQXJyYXkgYW5kIGEgRmxvYXQzMkFycmF5IGlmIHRoZSBsYXR0ZXIgaXMgYXZhaWxhYmxlXG4gKlxuICogQGNsYXNzIE1hdHJpeDJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5QSVhJLk1hdHJpeDIgPSBQSVhJLmRldGVybWluZU1hdHJpeEFycmF5VHlwZSgpO1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogVGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBvYmplY3RzIHRoYXQgYXJlIHJlbmRlcmVkIG9uIHRoZSBzY3JlZW4uIFxuICogVGhpcyBpcyBhbiBhYnN0cmFjdCBjbGFzcyBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIG9uIGl0cyBvd24gcmF0aGVyIGl0IHNob3VsZCBiZSBleHRlbmRlZC5cbiAqXG4gKiBAY2xhc3MgRGlzcGxheU9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cblBJWEkuRGlzcGxheU9iamVjdCA9IGZ1bmN0aW9uKClcbntcbiAgICAvKipcbiAgICAgKiBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0IHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBvc2l0aW9uXG4gICAgICogQHR5cGUgUG9pbnRcbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IFBJWEkuUG9pbnQoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY2FsZSBmYWN0b3Igb2YgdGhlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBzY2FsZVxuICAgICAqIEB0eXBlIFBvaW50XG4gICAgICovXG4gICAgdGhpcy5zY2FsZSA9IG5ldyBQSVhJLlBvaW50KDEsMSk7Ly97eDoxLCB5OjF9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBpdm90IHBvaW50IG9mIHRoZSBkaXNwbGF5T2JqZWN0IHRoYXQgaXQgcm90YXRlcyBhcm91bmRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwaXZvdFxuICAgICAqIEB0eXBlIFBvaW50XG4gICAgICovXG4gICAgdGhpcy5waXZvdCA9IG5ldyBQSVhJLlBvaW50KDAsMCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIG9iamVjdCBpbiByYWRpYW5zLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJvdGF0aW9uXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3BhY2l0eSBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGFscGhhXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5hbHBoYSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmlzaWJpbGl0eSBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGRlZmluZWQgYXJlYSB0aGF0IHdpbGwgcGljayB1cCBtb3VzZSAvIHRvdWNoIGV2ZW50cy4gSXQgaXMgbnVsbCBieSBkZWZhdWx0LlxuICAgICAqIFNldHRpbmcgaXQgaXMgYSBuZWF0IHdheSBvZiBvcHRpbWlzaW5nIHRoZSBoaXRUZXN0IGZ1bmN0aW9uIHRoYXQgdGhlIGludGVyYWN0aW9uTWFuYWdlciB3aWxsIHVzZSAoYXMgaXQgd2lsbCBub3QgbmVlZCB0byBoaXQgdGVzdCBhbGwgdGhlIGNoaWxkcmVuKVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGhpdEFyZWFcbiAgICAgKiBAdHlwZSBSZWN0YW5nbGV8Q2lyY2xlfEVsbGlwc2V8UG9seWdvblxuICAgICAqL1xuICAgIHRoaXMuaGl0QXJlYSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHVzZWQgdG8gaW5kaWNhdGUgaWYgdGhlIGRpc3BsYXlPYmplY3Qgc2hvdWxkIGRpc3BsYXkgYSBtb3VzZSBoYW5kIGN1cnNvciBvbiByb2xsb3ZlclxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJ1dHRvbk1vZGVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5idXR0b25Nb2RlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDYW4gdGhpcyBvYmplY3QgYmUgcmVuZGVyZWRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXJhYmxlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyYWJsZSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogW3JlYWQtb25seV0gVGhlIGRpc3BsYXkgb2JqZWN0IGNvbnRhaW5lciB0aGF0IGNvbnRhaW5zIHRoaXMgZGlzcGxheSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcGFyZW50XG4gICAgICogQHR5cGUgRGlzcGxheU9iamVjdENvbnRhaW5lclxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFtyZWFkLW9ubHldIFRoZSBzdGFnZSB0aGUgZGlzcGxheSBvYmplY3QgaXMgY29ubmVjdGVkIHRvLCBvciB1bmRlZmluZWQgaWYgaXQgaXMgbm90IGNvbm5lY3RlZCB0byB0aGUgc3RhZ2UuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgc3RhZ2VcbiAgICAgKiBAdHlwZSBTdGFnZVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMuc3RhZ2UgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogW3JlYWQtb25seV0gVGhlIG11bHRpcGxpZWQgYWxwaGEgb2YgdGhlIGRpc3BsYXlPYmplY3RcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB3b3JsZEFscGhhXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy53b3JsZEFscGhhID0gMTtcblxuICAgIC8qKlxuICAgICAqIFtyZWFkLW9ubHldIFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgaW50ZXJhY3RpdmUsIGRvIG5vdCB0b2dnbGUgZGlyZWN0bHkhIHVzZSB0aGUgYGludGVyYWN0aXZlYCBwcm9wZXJ0eVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IF9pbnRlcmFjdGl2ZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ludGVyYWN0aXZlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBjdXJzb3IgdGhhdCB3aWxsIGJlIHVzZWQgd2hlbiB0aGUgbW91c2UgaXMgb3ZlciB0aGlzIG9iamVjdC4gVG8gZW5hYmxlIHRoaXMgdGhlIGVsZW1lbnQgbXVzdCBoYXZlIGludGVyYWN0aW9uID0gdHJ1ZSBhbmQgYnV0dG9uTW9kZSA9IHRydWVcbiAgICAgKiBcbiAgICAgKiBAcHJvcGVydHkgZGVmYXVsdEN1cnNvclxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqXG4gICAgKi9cbiAgICB0aGlzLmRlZmF1bHRDdXJzb3IgPSAncG9pbnRlcic7XG5cbiAgICAvKipcbiAgICAgKiBbcmVhZC1vbmx5XSBDdXJyZW50IHRyYW5zZm9ybSBvZiB0aGUgb2JqZWN0IGJhc2VkIG9uIHdvcmxkIChwYXJlbnQpIGZhY3RvcnNcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB3b3JsZFRyYW5zZm9ybVxuICAgICAqIEB0eXBlIE1hdDNcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBuZXcgUElYSS5NYXRyaXgoKTtcblxuICAgIC8qKlxuICAgICAqIFtOWUldIFVua25vd25cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjb2xvclxuICAgICAqIEB0eXBlIEFycmF5PD5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY29sb3IgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFtOWUldIEhvbGRzIHdoZXRoZXIgb3Igbm90IHRoaXMgb2JqZWN0IGlzIGR5bmFtaWMsIGZvciByZW5kZXJpbmcgb3B0aW1pemF0aW9uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZHluYW1pY1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZHluYW1pYyA9IHRydWU7XG5cbiAgICAvLyBjYWNoZWQgc2luIHJvdGF0aW9uIGFuZCBjb3Mgcm90YXRpb25cbiAgICB0aGlzLl9zciA9IDA7XG4gICAgdGhpcy5fY3IgPSAxO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFyZWEgdGhlIGZpbHRlciBpcyBhcHBsaWVkIHRvIGxpa2UgdGhlIGhpdEFyZWEgdGhpcyBpcyB1c2VkIGFzIG1vcmUgb2YgYW4gb3B0aW1pc2F0aW9uXG4gICAgICogcmF0aGVyIHRoYW4gZmlndXJpbmcgb3V0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSBkaXNwbGF5T2JqZWN0IGVhY2ggZnJhbWUgeW91IGNhbiBzZXQgdGhpcyByZWN0YW5nbGVcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBmaWx0ZXJBcmVhXG4gICAgICogQHR5cGUgUmVjdGFuZ2xlXG4gICAgICovXG4gICAgdGhpcy5maWx0ZXJBcmVhID0gbnVsbDsvL25ldyBQSVhJLlJlY3RhbmdsZSgwLDAsMSwxKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcmlnaW5hbCwgY2FjaGVkIGJvdW5kcyBvZiB0aGUgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgX2JvdW5kc1xuICAgICAqIEB0eXBlIFJlY3RhbmdsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYm91bmRzID0gbmV3IFBJWEkuUmVjdGFuZ2xlKDAsIDAsIDEsIDEpO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb3N0IHVwLXRvLWRhdGUgYm91bmRzIG9mIHRoZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBfY3VycmVudEJvdW5kc1xuICAgICAqIEB0eXBlIFJlY3RhbmdsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fY3VycmVudEJvdW5kcyA9IG51bGw7XG4gICAgLyoqXG4gICAgICogVGhlIG9yaWdpbmFsLCBjYWNoZWQgbWFzayBvZiB0aGUgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgX2N1cnJlbnRCb3VuZHNcbiAgICAgKiBAdHlwZSBSZWN0YW5nbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX21hc2sgPSBudWxsO1xuXG4gICAgdGhpcy5fY2FjaGVBc0JpdG1hcCA9IGZhbHNlO1xuICAgIHRoaXMuX2NhY2hlSXNEaXJ0eSA9IGZhbHNlO1xuXG5cbiAgICAvKlxuICAgICAqIE1PVVNFIENhbGxiYWNrc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBjYWxsYmFjayB0aGF0IGlzIHVzZWQgd2hlbiB0aGUgdXNlcnMgY2xpY2tzIG9uIHRoZSBkaXNwbGF5T2JqZWN0IHdpdGggdGhlaXIgbW91c2VcbiAgICAgKiBAbWV0aG9kIGNsaWNrXG4gICAgICogQHBhcmFtIGludGVyYWN0aW9uRGF0YSB7SW50ZXJhY3Rpb25EYXRhfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBjYWxsYmFjayB0aGF0IGlzIHVzZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIG1vdXNlIGRvd24gb3ZlciB0aGUgc3ByaXRlXG4gICAgICogQG1ldGhvZCBtb3VzZWRvd25cbiAgICAgKiBAcGFyYW0gaW50ZXJhY3Rpb25EYXRhIHtJbnRlcmFjdGlvbkRhdGF9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGNhbGxiYWNrIHRoYXQgaXMgdXNlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSBtb3VzZSB0aGF0IHdhcyBvdmVyIHRoZSBkaXNwbGF5T2JqZWN0XG4gICAgICogZm9yIHRoaXMgY2FsbGJhY2sgdG8gYmUgZmlyZWQgdGhlIG1vdXNlIG11c3QgaGF2ZSBiZWVuIHByZXNzZWQgZG93biBvdmVyIHRoZSBkaXNwbGF5T2JqZWN0XG4gICAgICogQG1ldGhvZCBtb3VzZXVwXG4gICAgICogQHBhcmFtIGludGVyYWN0aW9uRGF0YSB7SW50ZXJhY3Rpb25EYXRhfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBjYWxsYmFjayB0aGF0IGlzIHVzZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyB0aGUgbW91c2UgdGhhdCB3YXMgb3ZlciB0aGUgZGlzcGxheU9iamVjdCBidXQgaXMgbm8gbG9uZ2VyIG92ZXIgdGhlIGRpc3BsYXlPYmplY3RcbiAgICAgKiBmb3IgdGhpcyBjYWxsYmFjayB0byBiZSBmaXJlZCwgVGhlIHRvdWNoIG11c3QgaGF2ZSBzdGFydGVkIG92ZXIgdGhlIGRpc3BsYXlPYmplY3RcbiAgICAgKiBAbWV0aG9kIG1vdXNldXBvdXRzaWRlXG4gICAgICogQHBhcmFtIGludGVyYWN0aW9uRGF0YSB7SW50ZXJhY3Rpb25EYXRhfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBjYWxsYmFjayB0aGF0IGlzIHVzZWQgd2hlbiB0aGUgdXNlcnMgbW91c2Ugcm9sbHMgb3ZlciB0aGUgZGlzcGxheU9iamVjdFxuICAgICAqIEBtZXRob2QgbW91c2VvdmVyXG4gICAgICogQHBhcmFtIGludGVyYWN0aW9uRGF0YSB7SW50ZXJhY3Rpb25EYXRhfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBjYWxsYmFjayB0aGF0IGlzIHVzZWQgd2hlbiB0aGUgdXNlcnMgbW91c2UgbGVhdmVzIHRoZSBkaXNwbGF5T2JqZWN0XG4gICAgICogQG1ldGhvZCBtb3VzZW91dFxuICAgICAqIEBwYXJhbSBpbnRlcmFjdGlvbkRhdGEge0ludGVyYWN0aW9uRGF0YX1cbiAgICAgKi9cblxuXG4gICAgLypcbiAgICAgKiBUT1VDSCBDYWxsYmFja3NcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgY2FsbGJhY2sgdGhhdCBpcyB1c2VkIHdoZW4gdGhlIHVzZXJzIHRhcHMgb24gdGhlIHNwcml0ZSB3aXRoIHRoZWlyIGZpbmdlclxuICAgICAqIGJhc2ljYWxseSBhIHRvdWNoIHZlcnNpb24gb2YgY2xpY2tcbiAgICAgKiBAbWV0aG9kIHRhcFxuICAgICAqIEBwYXJhbSBpbnRlcmFjdGlvbkRhdGEge0ludGVyYWN0aW9uRGF0YX1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgY2FsbGJhY2sgdGhhdCBpcyB1c2VkIHdoZW4gdGhlIHVzZXIgdG91Y2hlcyBvdmVyIHRoZSBkaXNwbGF5T2JqZWN0XG4gICAgICogQG1ldGhvZCB0b3VjaHN0YXJ0XG4gICAgICogQHBhcmFtIGludGVyYWN0aW9uRGF0YSB7SW50ZXJhY3Rpb25EYXRhfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBjYWxsYmFjayB0aGF0IGlzIHVzZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyBhIHRvdWNoIG92ZXIgdGhlIGRpc3BsYXlPYmplY3RcbiAgICAgKiBAbWV0aG9kIHRvdWNoZW5kXG4gICAgICogQHBhcmFtIGludGVyYWN0aW9uRGF0YSB7SW50ZXJhY3Rpb25EYXRhfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBjYWxsYmFjayB0aGF0IGlzIHVzZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyB0aGUgdG91Y2ggdGhhdCB3YXMgb3ZlciB0aGUgZGlzcGxheU9iamVjdFxuICAgICAqIGZvciB0aGlzIGNhbGxiYWNrIHRvIGJlIGZpcmVkLCBUaGUgdG91Y2ggbXVzdCBoYXZlIHN0YXJ0ZWQgb3ZlciB0aGUgc3ByaXRlXG4gICAgICogQG1ldGhvZCB0b3VjaGVuZG91dHNpZGVcbiAgICAgKiBAcGFyYW0gaW50ZXJhY3Rpb25EYXRhIHtJbnRlcmFjdGlvbkRhdGF9XG4gICAgICovXG59O1xuXG4vLyBjb25zdHJ1Y3RvclxuUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuRGlzcGxheU9iamVjdDtcblxuLyoqXG4gKiBbRGVwcmVjYXRlZF0gSW5kaWNhdGVzIGlmIHRoZSBzcHJpdGUgd2lsbCBoYXZlIHRvdWNoIGFuZCBtb3VzZSBpbnRlcmFjdGl2aXR5LiBJdCBpcyBmYWxzZSBieSBkZWZhdWx0XG4gKiBJbnN0ZWFkIG9mIHVzaW5nIHRoaXMgZnVuY3Rpb24geW91IGNhbiBub3cgc2ltcGx5IHNldCB0aGUgaW50ZXJhY3RpdmUgcHJvcGVydHkgdG8gdHJ1ZSBvciBmYWxzZVxuICpcbiAqIEBtZXRob2Qgc2V0SW50ZXJhY3RpdmVcbiAqIEBwYXJhbSBpbnRlcmFjdGl2ZSB7Qm9vbGVhbn1cbiAqIEBkZXByZWNhdGVkIFNpbXBseSBzZXQgdGhlIGBpbnRlcmFjdGl2ZWAgcHJvcGVydHkgZGlyZWN0bHlcbiAqL1xuUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5zZXRJbnRlcmFjdGl2ZSA9IGZ1bmN0aW9uKGludGVyYWN0aXZlKVxue1xuICAgIHRoaXMuaW50ZXJhY3RpdmUgPSBpbnRlcmFjdGl2ZTtcbn07XG5cbi8qKlxuICogSW5kaWNhdGVzIGlmIHRoZSBzcHJpdGUgd2lsbCBoYXZlIHRvdWNoIGFuZCBtb3VzZSBpbnRlcmFjdGl2aXR5LiBJdCBpcyBmYWxzZSBieSBkZWZhdWx0XG4gKlxuICogQHByb3BlcnR5IGludGVyYWN0aXZlXG4gKiBAdHlwZSBCb29sZWFuXG4gKiBAZGVmYXVsdCBmYWxzZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZSwgJ2ludGVyYWN0aXZlJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcmFjdGl2ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5faW50ZXJhY3RpdmUgPSB2YWx1ZTtcblxuICAgICAgICAvLyBUT0RPIG1vcmUgdG8gYmUgZG9uZSBoZXJlLi5cbiAgICAgICAgLy8gbmVlZCB0byBzb3J0IG91dCBhIHJlLWNyYXdsIVxuICAgICAgICBpZih0aGlzLnN0YWdlKXRoaXMuc3RhZ2UuZGlydHkgPSB0cnVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFtyZWFkLW9ubHldIEluZGljYXRlcyBpZiB0aGUgc3ByaXRlIGlzIGdsb2JhbHkgdmlzaWJsZS5cbiAqXG4gKiBAcHJvcGVydHkgd29ybGRWaXNpYmxlXG4gKiBAdHlwZSBCb29sZWFuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLCAnd29ybGRWaXNpYmxlJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcztcblxuICAgICAgICBkb1xuICAgICAgICB7XG4gICAgICAgICAgICBpZighaXRlbS52aXNpYmxlKXJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZShpdGVtKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBTZXRzIGEgbWFzayBmb3IgdGhlIGRpc3BsYXlPYmplY3QuIEEgbWFzayBpcyBhbiBvYmplY3QgdGhhdCBsaW1pdHMgdGhlIHZpc2liaWxpdHkgb2YgYW4gb2JqZWN0IHRvIHRoZSBzaGFwZSBvZiB0aGUgbWFzayBhcHBsaWVkIHRvIGl0LlxuICogSW4gUElYSSBhIHJlZ3VsYXIgbWFzayBtdXN0IGJlIGEgUElYSS5HcmFwaGljcyBvYmplY3QuIFRoaXMgYWxsb3dzIGZvciBtdWNoIGZhc3RlciBtYXNraW5nIGluIGNhbnZhcyBhcyBpdCB1dGlsaXNlcyBzaGFwZSBjbGlwcGluZy5cbiAqIFRvIHJlbW92ZSBhIG1hc2ssIHNldCB0aGlzIHByb3BlcnR5IHRvIG51bGwuXG4gKlxuICogQHByb3BlcnR5IG1hc2tcbiAqIEB0eXBlIEdyYXBoaWNzXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLCAnbWFzaycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFzaztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcblxuICAgICAgICBpZih0aGlzLl9tYXNrKXRoaXMuX21hc2suaXNNYXNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX21hc2sgPSB2YWx1ZTtcbiAgICAgICAgaWYodGhpcy5fbWFzayl0aGlzLl9tYXNrLmlzTWFzayA9IHRydWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogU2V0cyB0aGUgZmlsdGVycyBmb3IgdGhlIGRpc3BsYXlPYmplY3QuXG4gKiAqIElNUE9SVEFOVDogVGhpcyBpcyBhIHdlYkdMIG9ubHkgZmVhdHVyZSBhbmQgd2lsbCBiZSBpZ25vcmVkIGJ5IHRoZSBjYW52YXMgcmVuZGVyZXIuXG4gKiBUbyByZW1vdmUgZmlsdGVycyBzaW1wbHkgc2V0IHRoaXMgcHJvcGVydHkgdG8gJ251bGwnXG4gKiBAcHJvcGVydHkgZmlsdGVyc1xuICogQHR5cGUgQXJyYXkgQW4gYXJyYXkgb2YgZmlsdGVyc1xuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZSwgJ2ZpbHRlcnMnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcnM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cbiAgICAgICAgaWYodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIG5vdyBwdXQgYWxsIHRoZSBwYXNzZXMgaW4gb25lIHBsYWNlLi5cbiAgICAgICAgICAgIHZhciBwYXNzZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlclBhc3NlcyA9IHZhbHVlW2ldLnBhc3NlcztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpbHRlclBhc3Nlcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBhc3Nlcy5wdXNoKGZpbHRlclBhc3Nlc1tqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUT0RPIGNoYW5nZSB0aGlzIGFzIGl0IGlzIGxlZ2FjeVxuICAgICAgICAgICAgdGhpcy5fZmlsdGVyQmxvY2sgPSB7dGFyZ2V0OnRoaXMsIGZpbHRlclBhc3NlczpwYXNzZXN9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZmlsdGVycyA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFNldCB3ZWF0aGVyIG9yIG5vdCBhIHRoZSBkaXNwbGF5IG9iamVjdHMgaXMgY2FjaGVkIGFzIGEgYml0bWFwLlxuICogVGhpcyBiYXNpY2FsbHkgdGFrZXMgYSBzbmFwIHNob3Qgb2YgdGhlIGRpc3BsYXkgb2JqZWN0IGFzIGl0IGlzIGF0IHRoYXQgbW9tZW50LiBJdCBjYW4gcHJvdmlkZSBhIHBlcmZvcm1hbmNlIGJlbmVmaXQgZm9yIGNvbXBsZXggc3RhdGljIGRpc3BsYXlPYmplY3RzXG4gKiBUbyByZW1vdmUgZmlsdGVycyBzaW1wbHkgc2V0IHRoaXMgcHJvcGVydHkgdG8gJ251bGwnXG4gKiBAcHJvcGVydHkgY2FjaGVBc0JpdG1hcFxuICogQHR5cGUgQm9vbGVhblxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZSwgJ2NhY2hlQXNCaXRtYXAnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICB0aGlzLl9jYWNoZUFzQml0bWFwO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXG4gICAgICAgIGlmKHRoaXMuX2NhY2hlQXNCaXRtYXAgPT09IHZhbHVlKXJldHVybjtcblxuICAgICAgICBpZih2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy90aGlzLl9jYWNoZUlzRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdGVDYWNoZWRTcHJpdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lDYWNoZWRTcHJpdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NhY2hlQXNCaXRtYXAgPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuLypcbiAqIFVwZGF0ZXMgdGhlIG9iamVjdCB0cmFuc2Zvcm0gZm9yIHJlbmRlcmluZ1xuICpcbiAqIEBtZXRob2QgdXBkYXRlVHJhbnNmb3JtXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uKClcbntcbiAgICAvLyBUT0RPIE9QVElNSVpFIFRISVMhISB3aXRoIGRpcnR5XG4gICAgaWYodGhpcy5yb3RhdGlvbiAhPT0gdGhpcy5yb3RhdGlvbkNhY2hlKVxuICAgIHtcblxuICAgICAgICB0aGlzLnJvdGF0aW9uQ2FjaGUgPSB0aGlzLnJvdGF0aW9uO1xuICAgICAgICB0aGlzLl9zciA9ICBNYXRoLnNpbih0aGlzLnJvdGF0aW9uKTtcbiAgICAgICAgdGhpcy5fY3IgPSAgTWF0aC5jb3ModGhpcy5yb3RhdGlvbik7XG4gICAgfVxuXG4gICAvLyB2YXIgbG9jYWxUcmFuc2Zvcm0gPSB0aGlzLmxvY2FsVHJhbnNmb3JtLy8udG9BcnJheSgpO1xuICAgIHZhciBwYXJlbnRUcmFuc2Zvcm0gPSB0aGlzLnBhcmVudC53b3JsZFRyYW5zZm9ybTsvLy50b0FycmF5KCk7XG4gICAgdmFyIHdvcmxkVHJhbnNmb3JtID0gdGhpcy53b3JsZFRyYW5zZm9ybTsvLy50b0FycmF5KCk7XG5cbiAgICB2YXIgcHggPSB0aGlzLnBpdm90Lng7XG4gICAgdmFyIHB5ID0gdGhpcy5waXZvdC55O1xuXG4gICAgdmFyIGEwMCA9IHRoaXMuX2NyICogdGhpcy5zY2FsZS54LFxuICAgICAgICBhMDEgPSAtdGhpcy5fc3IgKiB0aGlzLnNjYWxlLnksXG4gICAgICAgIGExMCA9IHRoaXMuX3NyICogdGhpcy5zY2FsZS54LFxuICAgICAgICBhMTEgPSB0aGlzLl9jciAqIHRoaXMuc2NhbGUueSxcbiAgICAgICAgYTAyID0gdGhpcy5wb3NpdGlvbi54IC0gYTAwICogcHggLSBweSAqIGEwMSxcbiAgICAgICAgYTEyID0gdGhpcy5wb3NpdGlvbi55IC0gYTExICogcHkgLSBweCAqIGExMCxcbiAgICAgICAgYjAwID0gcGFyZW50VHJhbnNmb3JtLmEsIGIwMSA9IHBhcmVudFRyYW5zZm9ybS5iLFxuICAgICAgICBiMTAgPSBwYXJlbnRUcmFuc2Zvcm0uYywgYjExID0gcGFyZW50VHJhbnNmb3JtLmQ7XG5cbiAgICB3b3JsZFRyYW5zZm9ybS5hID0gYjAwICogYTAwICsgYjAxICogYTEwO1xuICAgIHdvcmxkVHJhbnNmb3JtLmIgPSBiMDAgKiBhMDEgKyBiMDEgKiBhMTE7XG4gICAgd29ybGRUcmFuc2Zvcm0udHggPSBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBwYXJlbnRUcmFuc2Zvcm0udHg7XG5cbiAgICB3b3JsZFRyYW5zZm9ybS5jID0gYjEwICogYTAwICsgYjExICogYTEwO1xuICAgIHdvcmxkVHJhbnNmb3JtLmQgPSBiMTAgKiBhMDEgKyBiMTEgKiBhMTE7XG4gICAgd29ybGRUcmFuc2Zvcm0udHkgPSBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBwYXJlbnRUcmFuc2Zvcm0udHk7XG5cbiAgICB0aGlzLndvcmxkQWxwaGEgPSB0aGlzLmFscGhhICogdGhpcy5wYXJlbnQud29ybGRBbHBoYTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBib3VuZHMgb2YgdGhlIGRpc3BsYXlPYmplY3QgYXMgYSByZWN0YW5nbGUgb2JqZWN0XG4gKlxuICogQG1ldGhvZCBnZXRCb3VuZHNcbiAqIEByZXR1cm4ge1JlY3RhbmdsZX0gdGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGFyZWFcbiAqL1xuUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiggbWF0cml4IClcbntcbiAgICBtYXRyaXggPSBtYXRyaXg7Ly9qdXN0IHRvIGdldCBwYXNzZWQganMgaGludGluZyAoYW5kIHByZXNlcnZlIGluaGVyaXRhbmNlKVxuICAgIHJldHVybiBQSVhJLkVtcHR5UmVjdGFuZ2xlO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGxvY2FsIGJvdW5kcyBvZiB0aGUgZGlzcGxheU9iamVjdCBhcyBhIHJlY3RhbmdsZSBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIGdldExvY2FsQm91bmRzXG4gKiBAcmV0dXJuIHtSZWN0YW5nbGV9IHRoZSByZWN0YW5ndWxhciBib3VuZGluZyBhcmVhXG4gKi9cblBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuZ2V0TG9jYWxCb3VuZHMgPSBmdW5jdGlvbigpXG57XG4gICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRzKFBJWEkuaWRlbnRpdHlNYXRyaXgpOy8vL1BJWEkuRW1wdHlSZWN0YW5nbGUoKTtcbn07XG5cblxuLyoqXG4gKiBTZXRzIHRoZSBvYmplY3QncyBzdGFnZSByZWZlcmVuY2UsIHRoZSBzdGFnZSB0aGlzIG9iamVjdCBpcyBjb25uZWN0ZWQgdG9cbiAqXG4gKiBAbWV0aG9kIHNldFN0YWdlUmVmZXJlbmNlXG4gKiBAcGFyYW0gc3RhZ2Uge1N0YWdlfSB0aGUgc3RhZ2UgdGhhdCB0aGUgb2JqZWN0IHdpbGwgaGF2ZSBhcyBpdHMgY3VycmVudCBzdGFnZSByZWZlcmVuY2VcbiAqL1xuUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5zZXRTdGFnZVJlZmVyZW5jZSA9IGZ1bmN0aW9uKHN0YWdlKVxue1xuICAgIHRoaXMuc3RhZ2UgPSBzdGFnZTtcbiAgICBpZih0aGlzLl9pbnRlcmFjdGl2ZSl0aGlzLnN0YWdlLmRpcnR5ID0gdHJ1ZTtcbn07XG5cblBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuZ2VuZXJhdGVUZXh0dXJlID0gZnVuY3Rpb24ocmVuZGVyZXIpXG57XG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKTtcblxuICAgIHZhciByZW5kZXJUZXh0dXJlID0gbmV3IFBJWEkuUmVuZGVyVGV4dHVyZShib3VuZHMud2lkdGggfCAwLCBib3VuZHMuaGVpZ2h0IHwgMCwgcmVuZGVyZXIpO1xuICAgIHJlbmRlclRleHR1cmUucmVuZGVyKHRoaXMsIG5ldyBQSVhJLlBvaW50KC1ib3VuZHMueCwgLWJvdW5kcy55KSApO1xuXG4gICAgcmV0dXJuIHJlbmRlclRleHR1cmU7XG59O1xuXG5QSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLnVwZGF0ZUNhY2hlID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuX2dlbmVyYXRlQ2FjaGVkU3ByaXRlKCk7XG59O1xuXG5QSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9yZW5kZXJDYWNoZWRTcHJpdGUgPSBmdW5jdGlvbihyZW5kZXJTZXNzaW9uKVxue1xuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS53b3JsZEFscGhhID0gdGhpcy53b3JsZEFscGhhO1xuICAgXG4gICAgaWYocmVuZGVyU2Vzc2lvbi5nbClcbiAgICB7XG4gICAgICAgIFBJWEkuU3ByaXRlLnByb3RvdHlwZS5fcmVuZGVyV2ViR0wuY2FsbCh0aGlzLl9jYWNoZWRTcHJpdGUsIHJlbmRlclNlc3Npb24pO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBQSVhJLlNwcml0ZS5wcm90b3R5cGUuX3JlbmRlckNhbnZhcy5jYWxsKHRoaXMuX2NhY2hlZFNwcml0ZSwgcmVuZGVyU2Vzc2lvbik7XG4gICAgfVxufTtcblxuUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fZ2VuZXJhdGVDYWNoZWRTcHJpdGUgPSBmdW5jdGlvbigpLy9yZW5kZXJTZXNzaW9uKVxue1xuICAgIHRoaXMuX2NhY2hlQXNCaXRtYXAgPSBmYWxzZTtcbiAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpO1xuICAgXG4gICAgaWYoIXRoaXMuX2NhY2hlZFNwcml0ZSlcbiAgICB7XG4gICAgICAgIHZhciByZW5kZXJUZXh0dXJlID0gbmV3IFBJWEkuUmVuZGVyVGV4dHVyZShib3VuZHMud2lkdGggfCAwLCBib3VuZHMuaGVpZ2h0IHwgMCk7Ly8sIHJlbmRlclNlc3Npb24ucmVuZGVyZXIpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5fY2FjaGVkU3ByaXRlID0gbmV3IFBJWEkuU3ByaXRlKHJlbmRlclRleHR1cmUpO1xuICAgICAgICB0aGlzLl9jYWNoZWRTcHJpdGUud29ybGRUcmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLl9jYWNoZWRTcHJpdGUudGV4dHVyZS5yZXNpemUoYm91bmRzLndpZHRoIHwgMCwgYm91bmRzLmhlaWdodCB8IDApO1xuICAgIH1cblxuICAgIC8vUkVNT1ZFIGZpbHRlciFcbiAgICB2YXIgdGVtcEZpbHRlcnMgPSB0aGlzLl9maWx0ZXJzO1xuICAgIHRoaXMuX2ZpbHRlcnMgPSBudWxsO1xuXG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLmZpbHRlcnMgPSB0ZW1wRmlsdGVycztcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUudGV4dHVyZS5yZW5kZXIodGhpcywgbmV3IFBJWEkuUG9pbnQoLWJvdW5kcy54LCAtYm91bmRzLnkpICk7XG5cbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUuYW5jaG9yLnggPSAtKCBib3VuZHMueCAvIGJvdW5kcy53aWR0aCApO1xuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5hbmNob3IueSA9IC0oIGJvdW5kcy55IC8gYm91bmRzLmhlaWdodCApO1xuXG4gICAgdGhpcy5fZmlsdGVycyA9IHRlbXBGaWx0ZXJzO1xuXG4gICAgdGhpcy5fY2FjaGVBc0JpdG1hcCA9IHRydWU7XG59O1xuXG4vKipcbiogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuKlxuKiBAbWV0aG9kIF9yZW5kZXJXZWJHTFxuKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7UmVuZGVyU2Vzc2lvbn0gXG4qIEBwcml2YXRlXG4qL1xuUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fZGVzdHJveUNhY2hlZFNwcml0ZSA9IGZ1bmN0aW9uKClcbntcbiAgICBpZighdGhpcy5fY2FjaGVkU3ByaXRlKXJldHVybjtcblxuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS50ZXh0dXJlLmRlc3Ryb3kodHJ1ZSk7XG4gIC8vICBjb25zb2xlLmxvZyhcIkRFU1RST1lcIilcbiAgICAvLyBsZXQgdGhlIGdjIGNvbGxlY3QgdGhlIHVudXNlZCBzcHJpdGVcbiAgICAvLyBUT0RPIGNvdWxkIGJlIG9iamVjdCBwb29sZWQhXG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlID0gbnVsbDtcbn07XG5cblxuUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fcmVuZGVyV2ViR0wgPSBmdW5jdGlvbihyZW5kZXJTZXNzaW9uKVxue1xuICAgIC8vIE9WRVJXUklURTtcbiAgICAvLyB0aGlzIGxpbmUgaXMganVzdCBoZXJlIHRvIHBhc3MganNoaW50aW5nIDopXG4gICAgcmVuZGVyU2Vzc2lvbiA9IHJlbmRlclNlc3Npb247XG59O1xuXG4vKipcbiogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbipcbiogQG1ldGhvZCBfcmVuZGVyQ2FudmFzXG4qIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtSZW5kZXJTZXNzaW9ufSBcbiogQHByaXZhdGVcbiovXG5QSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9yZW5kZXJDYW52YXMgPSBmdW5jdGlvbihyZW5kZXJTZXNzaW9uKVxue1xuICAgIC8vIE9WRVJXUklURTtcbiAgICAvLyB0aGlzIGxpbmUgaXMganVzdCBoZXJlIHRvIHBhc3MganNoaW50aW5nIDopXG4gICAgcmVuZGVyU2Vzc2lvbiA9IHJlbmRlclNlc3Npb247XG59O1xuXG4vKipcbiAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheU9iamVjdCBvbiB0aGUgeCBheGlzIHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxuICpcbiAqIEBwcm9wZXJ0eSB4XG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUsICd4Jywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAgdGhpcy5wb3NpdGlvbi54O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uLnggPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBUaGUgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXlPYmplY3Qgb24gdGhlIHkgYXhpcyByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cbiAqXG4gKiBAcHJvcGVydHkgeVxuICogQHR5cGUgTnVtYmVyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLCAneScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIHRoaXMucG9zaXRpb24ueTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55ID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuXG4vKipcbiAqIEEgRGlzcGxheU9iamVjdENvbnRhaW5lciByZXByZXNlbnRzIGEgY29sbGVjdGlvbiBvZiBkaXNwbGF5IG9iamVjdHMuXG4gKiBJdCBpcyB0aGUgYmFzZSBjbGFzcyBvZiBhbGwgZGlzcGxheSBvYmplY3RzIHRoYXQgYWN0IGFzIGEgY29udGFpbmVyIGZvciBvdGhlciBvYmplY3RzLlxuICpcbiAqIEBjbGFzcyBEaXNwbGF5T2JqZWN0Q29udGFpbmVyXG4gKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyID0gZnVuY3Rpb24oKVxue1xuICAgIFBJWEkuRGlzcGxheU9iamVjdC5jYWxsKCB0aGlzICk7XG5cbiAgICAvKipcbiAgICAgKiBbcmVhZC1vbmx5XSBUaGUgYXJyYXkgb2YgY2hpbGRyZW4gb2YgdGhpcyBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY2hpbGRyZW5cbiAgICAgKiBAdHlwZSBBcnJheTxEaXNwbGF5T2JqZWN0PlxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZSApO1xuUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcjtcblxuLyoqXG4gKiBUaGUgd2lkdGggb2YgdGhlIGRpc3BsYXlPYmplY3RDb250YWluZXIsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gKlxuICogQHByb3BlcnR5IHdpZHRoXG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuXG4gXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZSwgJ3dpZHRoJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlLnggKiB0aGlzLmdldExvY2FsQm91bmRzKCkud2lkdGg7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIFxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldExvY2FsQm91bmRzKCkud2lkdGg7XG5cbiAgICAgICAgaWYod2lkdGggIT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGUueCA9IHZhbHVlIC8gKCB3aWR0aC90aGlzLnNjYWxlLnggKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGUueCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBcbiAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuXG4vKipcbiAqIFRoZSBoZWlnaHQgb2YgdGhlIGRpc3BsYXlPYmplY3RDb250YWluZXIsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gKlxuICogQHByb3BlcnR5IGhlaWdodFxuICogQHR5cGUgTnVtYmVyXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUsICdoZWlnaHQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICB0aGlzLnNjYWxlLnkgKiB0aGlzLmdldExvY2FsQm91bmRzKCkuaGVpZ2h0O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldExvY2FsQm91bmRzKCkuaGVpZ2h0O1xuXG4gICAgICAgIGlmKGhlaWdodCAhPT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zY2FsZS55ID0gdmFsdWUgLyAoIGhlaWdodC90aGlzLnNjYWxlLnkgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGUueSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuXG4vKipcbiAqIEFkZHMgYSBjaGlsZCB0byB0aGUgY29udGFpbmVyLlxuICpcbiAqIEBtZXRob2QgYWRkQ2hpbGRcbiAqIEBwYXJhbSBjaGlsZCB7RGlzcGxheU9iamVjdH0gVGhlIERpc3BsYXlPYmplY3QgdG8gYWRkIHRvIHRoZSBjb250YWluZXJcbiAqL1xuUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkKVxue1xuICAgIHJldHVybiB0aGlzLmFkZENoaWxkQXQoY2hpbGQsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoKTtcbn07XG5cbi8qKlxuICogQWRkcyBhIGNoaWxkIHRvIHRoZSBjb250YWluZXIgYXQgYSBzcGVjaWZpZWQgaW5kZXguIElmIHRoZSBpbmRleCBpcyBvdXQgb2YgYm91bmRzIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gKlxuICogQG1ldGhvZCBhZGRDaGlsZEF0XG4gKiBAcGFyYW0gY2hpbGQge0Rpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCB0byBhZGRcbiAqIEBwYXJhbSBpbmRleCB7TnVtYmVyfSBUaGUgaW5kZXggdG8gcGxhY2UgdGhlIGNoaWxkIGluXG4gKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUuYWRkQ2hpbGRBdCA9IGZ1bmN0aW9uKGNoaWxkLCBpbmRleClcbntcbiAgICBpZihpbmRleCA+PSAwICYmIGluZGV4IDw9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxuICAgIHtcbiAgICAgICAgaWYoY2hpbGQucGFyZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcblxuICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xuXG4gICAgICAgIGlmKHRoaXMuc3RhZ2UpY2hpbGQuc2V0U3RhZ2VSZWZlcmVuY2UodGhpcy5zdGFnZSk7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY2hpbGQgKyAnIFRoZSBpbmRleCAnKyBpbmRleCArJyBzdXBwbGllZCBpcyBvdXQgb2YgYm91bmRzICcgKyB0aGlzLmNoaWxkcmVuLmxlbmd0aCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBbTllJXSBTd2FwcyB0aGUgZGVwdGggb2YgMiBkaXNwbGF5T2JqZWN0c1xuICpcbiAqIEBtZXRob2Qgc3dhcENoaWxkcmVuXG4gKiBAcGFyYW0gY2hpbGQge0Rpc3BsYXlPYmplY3R9XG4gKiBAcGFyYW0gY2hpbGQyIHtEaXNwbGF5T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZS5zd2FwQ2hpbGRyZW4gPSBmdW5jdGlvbihjaGlsZCwgY2hpbGQyKVxue1xuICAgIGlmKGNoaWxkID09PSBjaGlsZDIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbmRleDEgPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuICAgIHZhciBpbmRleDIgPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQyKTtcblxuICAgIGlmKGluZGV4MSA8IDAgfHwgaW5kZXgyIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N3YXBDaGlsZHJlbjogQm90aCB0aGUgc3VwcGxpZWQgRGlzcGxheU9iamVjdHMgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBjYWxsZXIuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5jaGlsZHJlbltpbmRleDFdID0gY2hpbGQyO1xuICAgIHRoaXMuY2hpbGRyZW5baW5kZXgyXSA9IGNoaWxkO1xuICAgIFxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjaGlsZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gKlxuICogQG1ldGhvZCBnZXRDaGlsZEF0XG4gKiBAcGFyYW0gaW5kZXgge051bWJlcn0gVGhlIGluZGV4IHRvIGdldCB0aGUgY2hpbGQgZnJvbVxuICovXG5QSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLmdldENoaWxkQXQgPSBmdW5jdGlvbihpbmRleClcbntcbiAgICBpZihpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5jaGlsZHJlbi5sZW5ndGgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpbmRleF07XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQgaW5kZXggZG9lcyBub3QgZXhpc3QgaW4gdGhlIGNoaWxkIGxpc3QsIG9yIHRoZSBzdXBwbGllZCBEaXNwbGF5T2JqZWN0IG11c3QgYmUgYSBjaGlsZCBvZiB0aGUgY2FsbGVyJyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgY2hpbGQgZnJvbSB0aGUgY29udGFpbmVyLlxuICpcbiAqIEBtZXRob2QgcmVtb3ZlQ2hpbGRcbiAqIEBwYXJhbSBjaGlsZCB7RGlzcGxheU9iamVjdH0gVGhlIERpc3BsYXlPYmplY3QgdG8gcmVtb3ZlXG4gKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbihjaGlsZClcbntcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVDaGlsZEF0KCB0aGlzLmNoaWxkcmVuLmluZGV4T2YoIGNoaWxkICkgKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIGNoaWxkIGZyb20gdGhlIHNwZWNpZmllZCBpbmRleCBwb3NpdGlvbiBpbiB0aGUgY2hpbGQgbGlzdCBvZiB0aGUgY29udGFpbmVyLlxuICpcbiAqIEBtZXRob2QgcmVtb3ZlQ2hpbGRBdFxuICogQHBhcmFtIGluZGV4IHtOdW1iZXJ9IFRoZSBpbmRleCB0byBnZXQgdGhlIGNoaWxkIGZyb21cbiAqL1xuUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZS5yZW1vdmVDaGlsZEF0ID0gZnVuY3Rpb24oaW5kZXgpXG57XG4gICAgdmFyIGNoaWxkID0gdGhpcy5nZXRDaGlsZEF0KCBpbmRleCApO1xuICAgIGlmKHRoaXMuc3RhZ2UpXG4gICAgICAgIGNoaWxkLnJlbW92ZVN0YWdlUmVmZXJlbmNlKCk7XG5cbiAgICBjaGlsZC5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoIGluZGV4LCAxICk7XG4gICAgcmV0dXJuIGNoaWxkO1xufTtcblxuLyoqXG4qIFJlbW92ZXMgYWxsIGNoaWxkIGluc3RhbmNlcyBmcm9tIHRoZSBjaGlsZCBsaXN0IG9mIHRoZSBjb250YWluZXIuXG4qXG4qIEBtZXRob2QgcmVtb3ZlQ2hpbGRyZW5cbiogQHBhcmFtIGJlZ2luSW5kZXgge051bWJlcn0gVGhlIGJlZ2lubmluZyBwb3NpdGlvbi4gUHJlZGVmaW5lZCB2YWx1ZSBpcyAwLlxuKiBAcGFyYW0gZW5kSW5kZXgge051bWJlcn0gVGhlIGVuZGluZyBwb3NpdGlvbi4gUHJlZGVmaW5lZCB2YWx1ZSBpcyBjaGlsZHJlbidzIGFycmF5IGxlbmd0aC5cbiovXG5QSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLnJlbW92ZUNoaWxkcmVuID0gZnVuY3Rpb24oYmVnaW5JbmRleCwgZW5kSW5kZXgpXG57XG4gICAgdmFyIGJlZ2luID0gYmVnaW5JbmRleCB8fCAwO1xuICAgIHZhciBlbmQgPSB0eXBlb2YgZW5kSW5kZXggPT09ICdudW1iZXInID8gZW5kSW5kZXggOiB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICB2YXIgcmFuZ2UgPSBlbmQgLSBiZWdpbjtcblxuICAgIGlmIChyYW5nZSA+IDAgJiYgcmFuZ2UgPD0gZW5kKVxuICAgIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSB0aGlzLmNoaWxkcmVuLnNwbGljZShiZWdpbiwgcmFuZ2UpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW92ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHJlbW92ZWRbaV07XG4gICAgICAgICAgICBpZih0aGlzLnN0YWdlKVxuICAgICAgICAgICAgICAgIGNoaWxkLnJlbW92ZVN0YWdlUmVmZXJlbmNlKCk7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvciggJ1JhbmdlIEVycm9yLCBudW1lcmljIHZhbHVlcyBhcmUgb3V0c2lkZSB0aGUgYWNjZXB0YWJsZSByYW5nZScgKTtcbiAgICB9XG59O1xuXG4vKlxuICogVXBkYXRlcyB0aGUgY29udGFpbmVyJ3MgY2hpbGRyZW5zIHRyYW5zZm9ybSBmb3IgcmVuZGVyaW5nXG4gKlxuICogQG1ldGhvZCB1cGRhdGVUcmFuc2Zvcm1cbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24oKVxue1xuICAgIC8vdGhpcy5fY3VycmVudEJvdW5kcyA9IG51bGw7XG5cbiAgICBpZighdGhpcy52aXNpYmxlKXJldHVybjtcblxuICAgIFBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtLmNhbGwoIHRoaXMgKTtcblxuICAgIGlmKHRoaXMuX2NhY2hlQXNCaXRtYXApcmV0dXJuO1xuXG4gICAgZm9yKHZhciBpPTAsaj10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxqOyBpKyspXG4gICAge1xuICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBib3VuZHMgb2YgdGhlIGRpc3BsYXlPYmplY3RDb250YWluZXIgYXMgYSByZWN0YW5nbGUgb2JqZWN0XG4gKlxuICogQG1ldGhvZCBnZXRCb3VuZHNcbiAqIEByZXR1cm4ge1JlY3RhbmdsZX0gdGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGFyZWFcbiAqL1xuUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbihtYXRyaXgpXG57XG4gICAgaWYodGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApcmV0dXJuIFBJWEkuRW1wdHlSZWN0YW5nbGU7XG5cbiAgICAvLyBUT0RPIHRoZSBib3VuZHMgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsY3VsYXRlZCB0aGlzIHJlbmRlciBzZXNzaW9uIHNvIHJldHVybiB3aGF0IHdlIGhhdmVcbiAgICBpZihtYXRyaXgpXG4gICAge1xuICAgICAgICB2YXIgbWF0cml4Q2FjaGUgPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtID0gbWF0cml4O1xuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtID0gbWF0cml4Q2FjaGU7XG4gICAgfVxuXG4gICAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgICB2YXIgbWluWSA9IEluZmluaXR5O1xuXG4gICAgdmFyIG1heFggPSAtSW5maW5pdHk7XG4gICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICB2YXIgY2hpbGRCb3VuZHM7XG4gICAgdmFyIGNoaWxkTWF4WDtcbiAgICB2YXIgY2hpbGRNYXhZO1xuXG4gICAgdmFyIGNoaWxkVmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgZm9yKHZhciBpPTAsaj10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxqOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICBcbiAgICAgICAgaWYoIWNoaWxkLnZpc2libGUpY29udGludWU7XG5cbiAgICAgICAgY2hpbGRWaXNpYmxlID0gdHJ1ZTtcblxuICAgICAgICBjaGlsZEJvdW5kcyA9IHRoaXMuY2hpbGRyZW5baV0uZ2V0Qm91bmRzKCBtYXRyaXggKTtcbiAgICAgXG4gICAgICAgIG1pblggPSBtaW5YIDwgY2hpbGRCb3VuZHMueCA/IG1pblggOiBjaGlsZEJvdW5kcy54O1xuICAgICAgICBtaW5ZID0gbWluWSA8IGNoaWxkQm91bmRzLnkgPyBtaW5ZIDogY2hpbGRCb3VuZHMueTtcblxuICAgICAgICBjaGlsZE1heFggPSBjaGlsZEJvdW5kcy53aWR0aCArIGNoaWxkQm91bmRzLng7XG4gICAgICAgIGNoaWxkTWF4WSA9IGNoaWxkQm91bmRzLmhlaWdodCArIGNoaWxkQm91bmRzLnk7XG5cbiAgICAgICAgbWF4WCA9IG1heFggPiBjaGlsZE1heFggPyBtYXhYIDogY2hpbGRNYXhYO1xuICAgICAgICBtYXhZID0gbWF4WSA+IGNoaWxkTWF4WSA/IG1heFkgOiBjaGlsZE1heFk7XG4gICAgfVxuXG4gICAgaWYoIWNoaWxkVmlzaWJsZSlcbiAgICAgICAgcmV0dXJuIFBJWEkuRW1wdHlSZWN0YW5nbGU7XG5cbiAgICB2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzO1xuXG4gICAgYm91bmRzLnggPSBtaW5YO1xuICAgIGJvdW5kcy55ID0gbWluWTtcbiAgICBib3VuZHMud2lkdGggPSBtYXhYIC0gbWluWDtcbiAgICBib3VuZHMuaGVpZ2h0ID0gbWF4WSAtIG1pblk7XG5cbiAgICAvLyBUT0RPOiBzdG9yZSBhIHJlZmVyZW5jZSBzbyB0aGF0IGlmIHRoaXMgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgYWdhaW4gaW4gdGhlIHJlbmRlciBjeWNsZSB3ZSBkbyBub3QgaGF2ZSB0byByZWNhbGN1bGF0ZVxuICAgIC8vdGhpcy5fY3VycmVudEJvdW5kcyA9IGJvdW5kcztcbiAgIFxuICAgIHJldHVybiBib3VuZHM7XG59O1xuXG5QSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLmdldExvY2FsQm91bmRzID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBtYXRyaXhDYWNoZSA9IHRoaXMud29ybGRUcmFuc2Zvcm07XG5cbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtID0gUElYSS5pZGVudGl0eU1hdHJpeDtcblxuICAgIGZvcih2YXIgaT0wLGo9dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGk8ajsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICB9XG5cbiAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcblxuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBtYXRyaXhDYWNoZTtcblxuICAgIHJldHVybiBib3VuZHM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbnRhaW5lcidzIHN0YWdlIHJlZmVyZW5jZSwgdGhlIHN0YWdlIHRoaXMgb2JqZWN0IGlzIGNvbm5lY3RlZCB0b1xuICpcbiAqIEBtZXRob2Qgc2V0U3RhZ2VSZWZlcmVuY2VcbiAqIEBwYXJhbSBzdGFnZSB7U3RhZ2V9IHRoZSBzdGFnZSB0aGF0IHRoZSBjb250YWluZXIgd2lsbCBoYXZlIGFzIGl0cyBjdXJyZW50IHN0YWdlIHJlZmVyZW5jZVxuICovXG5QSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLnNldFN0YWdlUmVmZXJlbmNlID0gZnVuY3Rpb24oc3RhZ2UpXG57XG4gICAgdGhpcy5zdGFnZSA9IHN0YWdlO1xuICAgIGlmKHRoaXMuX2ludGVyYWN0aXZlKXRoaXMuc3RhZ2UuZGlydHkgPSB0cnVlO1xuXG4gICAgZm9yKHZhciBpPTAsaj10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxqOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICBjaGlsZC5zZXRTdGFnZVJlZmVyZW5jZShzdGFnZSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiByZW1vdmVzIHRoZSBjdXJyZW50IHN0YWdlIHJlZmVyZW5jZSBvZiB0aGUgY29udGFpbmVyXG4gKlxuICogQG1ldGhvZCByZW1vdmVTdGFnZVJlZmVyZW5jZVxuICovXG5QSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLnJlbW92ZVN0YWdlUmVmZXJlbmNlID0gZnVuY3Rpb24oKVxue1xuXG4gICAgZm9yKHZhciBpPTAsaj10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxqOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICBjaGlsZC5yZW1vdmVTdGFnZVJlZmVyZW5jZSgpO1xuICAgIH1cblxuICAgIGlmKHRoaXMuX2ludGVyYWN0aXZlKXRoaXMuc3RhZ2UuZGlydHkgPSB0cnVlO1xuICAgIFxuICAgIHRoaXMuc3RhZ2UgPSBudWxsO1xufTtcblxuLyoqXG4qIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbipcbiogQG1ldGhvZCBfcmVuZGVyV2ViR0xcbiogQHBhcmFtIHJlbmRlclNlc3Npb24ge1JlbmRlclNlc3Npb259IFxuKiBAcHJpdmF0ZVxuKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUuX3JlbmRlcldlYkdMID0gZnVuY3Rpb24ocmVuZGVyU2Vzc2lvbilcbntcbiAgICBpZighdGhpcy52aXNpYmxlIHx8IHRoaXMuYWxwaGEgPD0gMClyZXR1cm47XG4gICAgXG4gICAgaWYodGhpcy5fY2FjaGVBc0JpdG1hcClcbiAgICB7XG4gICAgICAgIHRoaXMuX3JlbmRlckNhY2hlZFNwcml0ZShyZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB2YXIgaSxqO1xuXG4gICAgaWYodGhpcy5fbWFzayB8fCB0aGlzLl9maWx0ZXJzKVxuICAgIHtcbiAgICAgICAgXG4gICAgICAgIC8vIHB1c2ggZmlsdGVyIGZpcnN0IGFzIHdlIG5lZWQgdG8gZW5zdXJlIHRoZSBzdGVuY2lsIGJ1ZmZlciBpcyBjb3JyZWN0IGZvciBhbnkgbWFza2luZ1xuICAgICAgICBpZih0aGlzLl9maWx0ZXJzKVxuICAgICAgICB7XG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLmZsdXNoKCk7XG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLmZpbHRlck1hbmFnZXIucHVzaEZpbHRlcih0aGlzLl9maWx0ZXJCbG9jayk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLl9tYXNrKVxuICAgICAgICB7XG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLnN0b3AoKTtcbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24ubWFza01hbmFnZXIucHVzaE1hc2sodGhpcy5tYXNrLCByZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2guc3RhcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNpbXBsZSByZW5kZXIgY2hpbGRyZW4hXG4gICAgICAgIGZvcihpPTAsaj10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxqOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uX3JlbmRlcldlYkdMKHJlbmRlclNlc3Npb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaC5zdG9wKCk7XG5cbiAgICAgICAgaWYodGhpcy5fbWFzaylyZW5kZXJTZXNzaW9uLm1hc2tNYW5hZ2VyLnBvcE1hc2sodGhpcy5fbWFzaywgcmVuZGVyU2Vzc2lvbik7XG4gICAgICAgIGlmKHRoaXMuX2ZpbHRlcnMpcmVuZGVyU2Vzc2lvbi5maWx0ZXJNYW5hZ2VyLnBvcEZpbHRlcigpO1xuICAgICAgICBcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaC5zdGFydCgpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICAvLyBzaW1wbGUgcmVuZGVyIGNoaWxkcmVuIVxuICAgICAgICBmb3IoaT0wLGo9dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGk8ajsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLl9yZW5kZXJXZWJHTChyZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIENhbnZhcyByZW5kZXJlclxuKlxuKiBAbWV0aG9kIF9yZW5kZXJDYW52YXNcbiogQHBhcmFtIHJlbmRlclNlc3Npb24ge1JlbmRlclNlc3Npb259IFxuKiBAcHJpdmF0ZVxuKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUuX3JlbmRlckNhbnZhcyA9IGZ1bmN0aW9uKHJlbmRlclNlc3Npb24pXG57XG4gICAgaWYodGhpcy52aXNpYmxlID09PSBmYWxzZSB8fCB0aGlzLmFscGhhID09PSAwKXJldHVybjtcblxuICAgIGlmKHRoaXMuX2NhY2hlQXNCaXRtYXApXG4gICAge1xuXG4gICAgICAgIHRoaXMuX3JlbmRlckNhY2hlZFNwcml0ZShyZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKHRoaXMuX21hc2spXG4gICAge1xuICAgICAgICByZW5kZXJTZXNzaW9uLm1hc2tNYW5hZ2VyLnB1c2hNYXNrKHRoaXMuX21hc2ssIHJlbmRlclNlc3Npb24uY29udGV4dCk7XG4gICAgfVxuXG4gICAgZm9yKHZhciBpPTAsaj10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxqOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICBjaGlsZC5fcmVuZGVyQ2FudmFzKHJlbmRlclNlc3Npb24pO1xuICAgIH1cblxuICAgIGlmKHRoaXMuX21hc2spXG4gICAge1xuICAgICAgICByZW5kZXJTZXNzaW9uLm1hc2tNYW5hZ2VyLnBvcE1hc2socmVuZGVyU2Vzc2lvbi5jb250ZXh0KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogVGhlIFNwcml0ZSBvYmplY3QgaXMgdGhlIGJhc2UgZm9yIGFsbCB0ZXh0dXJlZCBvYmplY3RzIHRoYXQgYXJlIHJlbmRlcmVkIHRvIHRoZSBzY3JlZW5cbiAqXG4gKiBAY2xhc3MgU3ByaXRlXG4gKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0Q29udGFpbmVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfSBUaGUgdGV4dHVyZSBmb3IgdGhpcyBzcHJpdGVcbiAqIFxuICogQSBzcHJpdGUgY2FuIGJlIGNyZWF0ZWQgZGlyZWN0bHkgZnJvbSBhbiBpbWFnZSBsaWtlIHRoaXMgOiBcbiAqIHZhciBzcHJpdGUgPSBuZXcgUElYSS5TcHJpdGUuZnJvbUltYWdlKCdhc3NldHMvaW1hZ2UucG5nJyk7XG4gKiB5b3VyU3RhZ2UuYWRkQ2hpbGQoc3ByaXRlKTtcbiAqIHRoZW4gb2J2aW91c2x5IGRvbid0IGZvcmdldCB0byBhZGQgaXQgdG8gdGhlIHN0YWdlIHlvdSBoYXZlIGFscmVhZHkgY3JlYXRlZFxuICovXG5QSVhJLlNwcml0ZSA9IGZ1bmN0aW9uKHRleHR1cmUpXG57XG4gICAgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLmNhbGwoIHRoaXMgKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbmNob3Igc2V0cyB0aGUgb3JpZ2luIHBvaW50IG9mIHRoZSB0ZXh0dXJlLlxuICAgICAqIFRoZSBkZWZhdWx0IGlzIDAsMCB0aGlzIG1lYW5zIHRoZSB0ZXh0dXJlJ3Mgb3JpZ2luIGlzIHRoZSB0b3AgbGVmdFxuICAgICAqIFNldHRpbmcgdGhhbiBhbmNob3IgdG8gMC41LDAuNSBtZWFucyB0aGUgdGV4dHVyZXMgb3JpZ2luIGlzIGNlbnRyZWRcbiAgICAgKiBTZXR0aW5nIHRoZSBhbmNob3IgdG8gMSwxIHdvdWxkIG1lYW4gdGhlIHRleHR1cmVzIG9yaWdpbiBwb2ludHMgd2lsbCBiZSB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lclxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGFuY2hvclxuICAgICAqIEB0eXBlIFBvaW50XG4gICAgICovXG4gICAgdGhpcy5hbmNob3IgPSBuZXcgUElYSS5Qb2ludCgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRleHR1cmUgdGhhdCB0aGUgc3ByaXRlIGlzIHVzaW5nXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdGV4dHVyZVxuICAgICAqIEB0eXBlIFRleHR1cmVcbiAgICAgKi9cbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBzcHJpdGUgKHRoaXMgaXMgaW5pdGlhbGx5IHNldCBieSB0aGUgdGV4dHVyZSlcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBfd2lkdGhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3dpZHRoID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHNwcml0ZSAodGhpcyBpcyBpbml0aWFsbHkgc2V0IGJ5IHRoZSB0ZXh0dXJlKVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IF9oZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2hlaWdodCA9IDA7XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSB0aW50IGFwcGxpZWQgdG8gdGhlIHNwcml0ZS4gVGhpcyBpcyBhIGhleCB2YWx1ZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRpbnRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAweEZGRkZGRlxuICAgICAqL1xuICAgIHRoaXMudGludCA9IDB4RkZGRkZGOy8vICogTWF0aC5yYW5kb20oKTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBUaGUgYmxlbmQgbW9kZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBzcHJpdGVcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBibGVuZE1vZGVcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCBQSVhJLmJsZW5kTW9kZXMuTk9STUFMO1xuICAgICAqL1xuICAgIHRoaXMuYmxlbmRNb2RlID0gUElYSS5ibGVuZE1vZGVzLk5PUk1BTDtcblxuICAgIGlmKHRleHR1cmUuYmFzZVRleHR1cmUuaGFzTG9hZGVkKVxuICAgIHtcbiAgICAgICAgdGhpcy5vblRleHR1cmVVcGRhdGUoKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5vblRleHR1cmVVcGRhdGVCaW5kID0gdGhpcy5vblRleHR1cmVVcGRhdGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICd1cGRhdGUnLCB0aGlzLm9uVGV4dHVyZVVwZGF0ZUJpbmQgKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmFibGUgPSB0cnVlO1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuU3ByaXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUgKTtcblBJWEkuU3ByaXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuU3ByaXRlO1xuXG4vKipcbiAqIFRoZSB3aWR0aCBvZiB0aGUgc3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxuICpcbiAqIEBwcm9wZXJ0eSB3aWR0aFxuICogQHR5cGUgTnVtYmVyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLlNwcml0ZS5wcm90b3R5cGUsICd3aWR0aCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZS54ICogdGhpcy50ZXh0dXJlLmZyYW1lLndpZHRoO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnNjYWxlLnggPSB2YWx1ZSAvIHRoaXMudGV4dHVyZS5mcmFtZS53aWR0aDtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBUaGUgaGVpZ2h0IG9mIHRoZSBzcHJpdGUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gKlxuICogQHByb3BlcnR5IGhlaWdodFxuICogQHR5cGUgTnVtYmVyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLlNwcml0ZS5wcm90b3R5cGUsICdoZWlnaHQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICB0aGlzLnNjYWxlLnkgKiB0aGlzLnRleHR1cmUuZnJhbWUuaGVpZ2h0O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnNjYWxlLnkgPSB2YWx1ZSAvIHRoaXMudGV4dHVyZS5mcmFtZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFNldHMgdGhlIHRleHR1cmUgb2YgdGhlIHNwcml0ZVxuICpcbiAqIEBtZXRob2Qgc2V0VGV4dHVyZVxuICogQHBhcmFtIHRleHR1cmUge1RleHR1cmV9IFRoZSBQSVhJIHRleHR1cmUgdGhhdCBpcyBkaXNwbGF5ZWQgYnkgdGhlIHNwcml0ZVxuICovXG5QSVhJLlNwcml0ZS5wcm90b3R5cGUuc2V0VGV4dHVyZSA9IGZ1bmN0aW9uKHRleHR1cmUpXG57XG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICB0aGlzLmNhY2hlZFRpbnQgPSAweEZGRkZGRjtcbn07XG5cbi8qKlxuICogV2hlbiB0aGUgdGV4dHVyZSBpcyB1cGRhdGVkLCB0aGlzIGV2ZW50IHdpbGwgZmlyZSB0byB1cGRhdGUgdGhlIHNjYWxlIGFuZCBmcmFtZVxuICpcbiAqIEBtZXRob2Qgb25UZXh0dXJlVXBkYXRlXG4gKiBAcGFyYW0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuU3ByaXRlLnByb3RvdHlwZS5vblRleHR1cmVVcGRhdGUgPSBmdW5jdGlvbigpXG57XG4gICAgLy8gc28gaWYgX3dpZHRoIGlzIDAgdGhlbiB3aWR0aCB3YXMgbm90IHNldC4uXG4gICAgaWYodGhpcy5fd2lkdGgpdGhpcy5zY2FsZS54ID0gdGhpcy5fd2lkdGggLyB0aGlzLnRleHR1cmUuZnJhbWUud2lkdGg7XG4gICAgaWYodGhpcy5faGVpZ2h0KXRoaXMuc2NhbGUueSA9IHRoaXMuX2hlaWdodCAvIHRoaXMudGV4dHVyZS5mcmFtZS5oZWlnaHQ7XG5cblxuICAgIC8vdGhpcy51cGRhdGVGcmFtZSA9IHRydWU7XG59O1xuXG4vKipcbiogUmV0dXJucyB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhlIHNwcml0ZSBhcyBhIFBJWEkuUmVjdGFuZ2xlIG9iamVjdFxuKlxuKiBAbWV0aG9kIGdldEJvdW5kc1xuKiBAcGFyYW0gbWF0cml4IHtNYXRyaXh9IHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgdGhlIHNwcml0ZVxuKiBAcmV0dXJuIHtSZWN0YW5nbGV9IHRoZSBmcmFtaW5nIHJlY3RhbmdsZVxuKi9cblBJWEkuU3ByaXRlLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbihtYXRyaXgpXG57XG5cbiAgICB2YXIgd2lkdGggPSB0aGlzLnRleHR1cmUuZnJhbWUud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMudGV4dHVyZS5mcmFtZS5oZWlnaHQ7XG5cbiAgICB2YXIgdzAgPSB3aWR0aCAqICgxLXRoaXMuYW5jaG9yLngpO1xuICAgIHZhciB3MSA9IHdpZHRoICogLXRoaXMuYW5jaG9yLng7XG5cbiAgICB2YXIgaDAgPSBoZWlnaHQgKiAoMS10aGlzLmFuY2hvci55KTtcbiAgICB2YXIgaDEgPSBoZWlnaHQgKiAtdGhpcy5hbmNob3IueTtcblxuICAgIHZhciB3b3JsZFRyYW5zZm9ybSA9IG1hdHJpeCB8fCB0aGlzLndvcmxkVHJhbnNmb3JtIDtcblxuICAgIHZhciBhID0gd29ybGRUcmFuc2Zvcm0uYTtcbiAgICB2YXIgYiA9IHdvcmxkVHJhbnNmb3JtLmM7XG4gICAgdmFyIGMgPSB3b3JsZFRyYW5zZm9ybS5iO1xuICAgIHZhciBkID0gd29ybGRUcmFuc2Zvcm0uZDtcbiAgICB2YXIgdHggPSB3b3JsZFRyYW5zZm9ybS50eDtcbiAgICB2YXIgdHkgPSB3b3JsZFRyYW5zZm9ybS50eTtcblxuICAgIHZhciB4MSA9IGEgKiB3MSArIGMgKiBoMSArIHR4O1xuICAgIHZhciB5MSA9IGQgKiBoMSArIGIgKiB3MSArIHR5O1xuXG4gICAgdmFyIHgyID0gYSAqIHcwICsgYyAqIGgxICsgdHg7XG4gICAgdmFyIHkyID0gZCAqIGgxICsgYiAqIHcwICsgdHk7XG5cbiAgICB2YXIgeDMgPSBhICogdzAgKyBjICogaDAgKyB0eDtcbiAgICB2YXIgeTMgPSBkICogaDAgKyBiICogdzAgKyB0eTtcblxuICAgIHZhciB4NCA9ICBhICogdzEgKyBjICogaDAgKyB0eDtcbiAgICB2YXIgeTQgPSAgZCAqIGgwICsgYiAqIHcxICsgdHk7XG5cbiAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcblxuICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgdmFyIG1pblkgPSBJbmZpbml0eTtcblxuICAgIG1pblggPSB4MSA8IG1pblggPyB4MSA6IG1pblg7XG4gICAgbWluWCA9IHgyIDwgbWluWCA/IHgyIDogbWluWDtcbiAgICBtaW5YID0geDMgPCBtaW5YID8geDMgOiBtaW5YO1xuICAgIG1pblggPSB4NCA8IG1pblggPyB4NCA6IG1pblg7XG5cbiAgICBtaW5ZID0geTEgPCBtaW5ZID8geTEgOiBtaW5ZO1xuICAgIG1pblkgPSB5MiA8IG1pblkgPyB5MiA6IG1pblk7XG4gICAgbWluWSA9IHkzIDwgbWluWSA/IHkzIDogbWluWTtcbiAgICBtaW5ZID0geTQgPCBtaW5ZID8geTQgOiBtaW5ZO1xuXG4gICAgbWF4WCA9IHgxID4gbWF4WCA/IHgxIDogbWF4WDtcbiAgICBtYXhYID0geDIgPiBtYXhYID8geDIgOiBtYXhYO1xuICAgIG1heFggPSB4MyA+IG1heFggPyB4MyA6IG1heFg7XG4gICAgbWF4WCA9IHg0ID4gbWF4WCA/IHg0IDogbWF4WDtcblxuICAgIG1heFkgPSB5MSA+IG1heFkgPyB5MSA6IG1heFk7XG4gICAgbWF4WSA9IHkyID4gbWF4WSA/IHkyIDogbWF4WTtcbiAgICBtYXhZID0geTMgPiBtYXhZID8geTMgOiBtYXhZO1xuICAgIG1heFkgPSB5NCA+IG1heFkgPyB5NCA6IG1heFk7XG5cbiAgICB2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzO1xuXG4gICAgYm91bmRzLnggPSBtaW5YO1xuICAgIGJvdW5kcy53aWR0aCA9IG1heFggLSBtaW5YO1xuXG4gICAgYm91bmRzLnkgPSBtaW5ZO1xuICAgIGJvdW5kcy5oZWlnaHQgPSBtYXhZIC0gbWluWTtcblxuICAgIC8vIHN0b3JlIGEgcmVmZXJlbmNlIHNvIHRoYXQgaWYgdGhpcyBmdW5jdGlvbiBnZXRzIGNhbGxlZCBhZ2FpbiBpbiB0aGUgcmVuZGVyIGN5Y2xlIHdlIGRvIG5vdCBoYXZlIHRvIHJlY2FsY3VsYXRlXG4gICAgdGhpcy5fY3VycmVudEJvdW5kcyA9IGJvdW5kcztcblxuICAgIHJldHVybiBib3VuZHM7XG59O1xuXG4vKipcbiogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuKlxuKiBAbWV0aG9kIF9yZW5kZXJXZWJHTFxuKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7UmVuZGVyU2Vzc2lvbn0gXG4qIEBwcml2YXRlXG4qL1xuUElYSS5TcHJpdGUucHJvdG90eXBlLl9yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uKHJlbmRlclNlc3Npb24pXG57XG4gICAgLy8gaWYgdGhlIHNwcml0ZSBpcyBub3QgdmlzaWJsZSBvciB0aGUgYWxwaGEgaXMgMCB0aGVuIG5vIG5lZWQgdG8gcmVuZGVyIHRoaXMgZWxlbWVudFxuICAgIGlmKCF0aGlzLnZpc2libGUgfHwgdGhpcy5hbHBoYSA8PSAwKXJldHVybjtcbiAgICBcbiAgICB2YXIgaSxqO1xuXG4gICAgLy8gZG8gYSBxdWljayBjaGVjayB0byBzZWUgaWYgdGhpcyBlbGVtZW50IGhhcyBhIG1hc2sgb3IgYSBmaWx0ZXIuXG4gICAgaWYodGhpcy5fbWFzayB8fCB0aGlzLl9maWx0ZXJzKVxuICAgIHtcbiAgICAgICAgdmFyIHNwcml0ZUJhdGNoID0gIHJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2g7XG5cbiAgICAgICAgLy8gcHVzaCBmaWx0ZXIgZmlyc3QgYXMgd2UgbmVlZCB0byBlbnN1cmUgdGhlIHN0ZW5jaWwgYnVmZmVyIGlzIGNvcnJlY3QgZm9yIGFueSBtYXNraW5nXG4gICAgICAgIGlmKHRoaXMuX2ZpbHRlcnMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNwcml0ZUJhdGNoLmZsdXNoKCk7XG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLmZpbHRlck1hbmFnZXIucHVzaEZpbHRlcih0aGlzLl9maWx0ZXJCbG9jayk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLl9tYXNrKVxuICAgICAgICB7XG4gICAgICAgICAgICBzcHJpdGVCYXRjaC5zdG9wKCk7XG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLm1hc2tNYW5hZ2VyLnB1c2hNYXNrKHRoaXMubWFzaywgcmVuZGVyU2Vzc2lvbik7XG4gICAgICAgICAgICBzcHJpdGVCYXRjaC5zdGFydCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRoaXMgc3ByaXRlIHRvIHRoZSBiYXRjaFxuICAgICAgICBzcHJpdGVCYXRjaC5yZW5kZXIodGhpcyk7XG5cbiAgICAgICAgLy8gbm93IGxvb3AgdGhyb3VnaCB0aGUgY2hpbGRyZW4gYW5kIG1ha2Ugc3VyZSB0aGV5IGdldCByZW5kZXJlZFxuICAgICAgICBmb3IoaT0wLGo9dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGk8ajsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLl9yZW5kZXJXZWJHTChyZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRpbWUgdG8gc3RvcCB0aGUgc3ByaXRlIGJhdGNoIGFzIGVpdGhlciBhIG1hc2sgZWxlbWVudCBvciBhIGZpbHRlciBkcmF3IHdpbGwgaGFwcGVuIG5leHRcbiAgICAgICAgc3ByaXRlQmF0Y2guc3RvcCgpO1xuXG4gICAgICAgIGlmKHRoaXMuX21hc2spcmVuZGVyU2Vzc2lvbi5tYXNrTWFuYWdlci5wb3BNYXNrKHRoaXMuX21hc2ssIHJlbmRlclNlc3Npb24pO1xuICAgICAgICBpZih0aGlzLl9maWx0ZXJzKXJlbmRlclNlc3Npb24uZmlsdGVyTWFuYWdlci5wb3BGaWx0ZXIoKTtcbiAgICAgICAgXG4gICAgICAgIHNwcml0ZUJhdGNoLnN0YXJ0KCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2gucmVuZGVyKHRoaXMpO1xuXG4gICAgICAgIC8vIHNpbXBsZSByZW5kZXIgY2hpbGRyZW4hXG4gICAgICAgIGZvcihpPTAsaj10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxqOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uX3JlbmRlcldlYkdMKHJlbmRlclNlc3Npb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICBcbiAgICAvL1RPRE8gY2hlY2sgY3VsbGluZyAgXG59O1xuXG4vKipcbiogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbipcbiogQG1ldGhvZCBfcmVuZGVyQ2FudmFzXG4qIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtSZW5kZXJTZXNzaW9ufSBcbiogQHByaXZhdGVcbiovXG5QSVhJLlNwcml0ZS5wcm90b3R5cGUuX3JlbmRlckNhbnZhcyA9IGZ1bmN0aW9uKHJlbmRlclNlc3Npb24pXG57XG4gICAgLy8gSWYgdGhlIHNwcml0ZSBpcyBub3QgdmlzaWJsZSBvciB0aGUgYWxwaGEgaXMgMCB0aGVuIG5vIG5lZWQgdG8gcmVuZGVyIHRoaXMgZWxlbWVudFxuICAgIGlmICh0aGlzLnZpc2libGUgPT09IGZhbHNlIHx8IHRoaXMuYWxwaGEgPT09IDApIHJldHVybjtcbiAgICBcbiAgICBpZiAodGhpcy5ibGVuZE1vZGUgIT09IHJlbmRlclNlc3Npb24uY3VycmVudEJsZW5kTW9kZSlcbiAgICB7XG4gICAgICAgIHJlbmRlclNlc3Npb24uY3VycmVudEJsZW5kTW9kZSA9IHRoaXMuYmxlbmRNb2RlO1xuICAgICAgICByZW5kZXJTZXNzaW9uLmNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gUElYSS5ibGVuZE1vZGVzQ2FudmFzW3JlbmRlclNlc3Npb24uY3VycmVudEJsZW5kTW9kZV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX21hc2spXG4gICAge1xuICAgICAgICByZW5kZXJTZXNzaW9uLm1hc2tNYW5hZ2VyLnB1c2hNYXNrKHRoaXMuX21hc2ssIHJlbmRlclNlc3Npb24uY29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gIElnbm9yZSBudWxsIHNvdXJjZXNcbiAgICBpZiAodGhpcy50ZXh0dXJlLnZhbGlkKVxuICAgIHtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5jb250ZXh0Lmdsb2JhbEFscGhhID0gdGhpcy53b3JsZEFscGhhO1xuXG4gICAgICAgIC8vICBBbGxvdyBmb3IgcGl4ZWwgcm91bmRpbmdcbiAgICAgICAgaWYgKHJlbmRlclNlc3Npb24ucm91bmRQaXhlbHMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24uY29udGV4dC5zZXRUcmFuc2Zvcm0oXG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZFRyYW5zZm9ybS5hLFxuICAgICAgICAgICAgICAgIHRoaXMud29ybGRUcmFuc2Zvcm0uYyxcbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmIsXG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZFRyYW5zZm9ybS5kLFxuICAgICAgICAgICAgICAgIHRoaXMud29ybGRUcmFuc2Zvcm0udHggfCAwLFxuICAgICAgICAgICAgICAgIHRoaXMud29ybGRUcmFuc2Zvcm0udHkgfCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24uY29udGV4dC5zZXRUcmFuc2Zvcm0oXG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZFRyYW5zZm9ybS5hLFxuICAgICAgICAgICAgICAgIHRoaXMud29ybGRUcmFuc2Zvcm0uYyxcbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmIsXG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZFRyYW5zZm9ybS5kLFxuICAgICAgICAgICAgICAgIHRoaXMud29ybGRUcmFuc2Zvcm0udHgsXG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZFRyYW5zZm9ybS50eSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAgSWYgc21vb3RoaW5nRW5hYmxlZCBpcyBzdXBwb3J0ZWQgYW5kIHdlIG5lZWQgdG8gY2hhbmdlIHRoZSBzbW9vdGhpbmcgcHJvcGVydHkgZm9yIHRoaXMgdGV4dHVyZVxuICAgICAgICBpZiAocmVuZGVyU2Vzc2lvbi5zbW9vdGhQcm9wZXJ0eSAmJiByZW5kZXJTZXNzaW9uLnNjYWxlTW9kZSAhPT0gdGhpcy50ZXh0dXJlLmJhc2VUZXh0dXJlLnNjYWxlTW9kZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmVuZGVyU2Vzc2lvbi5zY2FsZU1vZGUgPSB0aGlzLnRleHR1cmUuYmFzZVRleHR1cmUuc2NhbGVNb2RlO1xuICAgICAgICAgICAgcmVuZGVyU2Vzc2lvbi5jb250ZXh0W3JlbmRlclNlc3Npb24uc21vb3RoUHJvcGVydHldID0gKHJlbmRlclNlc3Npb24uc2NhbGVNb2RlID09PSBQSVhJLnNjYWxlTW9kZXMuTElORUFSKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICBJZiB0aGUgdGV4dHVyZSBpcyB0cmltbWVkIHdlIG9mZnNldCBieSB0aGUgdHJpbSB4L3ksIG90aGVyd2lzZSB3ZSB1c2UgdGhlIGZyYW1lIGRpbWVuc2lvbnNcbiAgICAgICAgdmFyIGR4ID0gKHRoaXMudGV4dHVyZS50cmltKSA/IHRoaXMudGV4dHVyZS50cmltLnggLSB0aGlzLmFuY2hvci54ICogdGhpcy50ZXh0dXJlLnRyaW0ud2lkdGggOiB0aGlzLmFuY2hvci54ICogLXRoaXMudGV4dHVyZS5mcmFtZS53aWR0aDtcbiAgICAgICAgdmFyIGR5ID0gKHRoaXMudGV4dHVyZS50cmltKSA/IHRoaXMudGV4dHVyZS50cmltLnkgLSB0aGlzLmFuY2hvci55ICogdGhpcy50ZXh0dXJlLnRyaW0uaGVpZ2h0IDogdGhpcy5hbmNob3IueSAqIC10aGlzLnRleHR1cmUuZnJhbWUuaGVpZ2h0O1xuXG4gICAgICAgIGlmICh0aGlzLnRpbnQgIT09IDB4RkZGRkZGKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYWNoZWRUaW50ICE9PSB0aGlzLnRpbnQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRUaW50ID0gdGhpcy50aW50O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vICBUT0RPIGNsZWFuIHVwIGNhY2hpbmcgLSBob3cgdG8gY2xlYW4gdXAgdGhlIGNhY2hlcz9cbiAgICAgICAgICAgICAgICB0aGlzLnRpbnRlZFRleHR1cmUgPSBQSVhJLkNhbnZhc1RpbnRlci5nZXRUaW50ZWRUZXh0dXJlKHRoaXMsIHRoaXMudGludCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24uY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGludGVkVGV4dHVyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlLmNyb3Aud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZS5jcm9wLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUuY3JvcC53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlLmNyb3AuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24uY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZS5jcm9wLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZS5jcm9wLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZS5jcm9wLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUuY3JvcC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlLmNyb3Aud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZS5jcm9wLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPVkVSV1JJVEVcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5fcmVuZGVyQ2FudmFzKHJlbmRlclNlc3Npb24pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9tYXNrKVxuICAgIHtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5tYXNrTWFuYWdlci5wb3BNYXNrKHJlbmRlclNlc3Npb24uY29udGV4dCk7XG4gICAgfVxufTtcblxuLy8gc29tZSBoZWxwZXIgZnVuY3Rpb25zLi5cblxuLyoqXG4gKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIHNwcml0ZSB0aGF0IHdpbGwgY29udGFpbiBhIHRleHR1cmUgZnJvbSB0aGUgVGV4dHVyZUNhY2hlIGJhc2VkIG9uIHRoZSBmcmFtZUlkXG4gKiBUaGUgZnJhbWUgaWRzIGFyZSBjcmVhdGVkIHdoZW4gYSBUZXh0dXJlIHBhY2tlciBmaWxlIGhhcyBiZWVuIGxvYWRlZFxuICpcbiAqIEBtZXRob2QgZnJvbUZyYW1lXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gZnJhbWVJZCB7U3RyaW5nfSBUaGUgZnJhbWUgSWQgb2YgdGhlIHRleHR1cmUgaW4gdGhlIGNhY2hlXG4gKiBAcmV0dXJuIHtTcHJpdGV9IEEgbmV3IFNwcml0ZSB1c2luZyBhIHRleHR1cmUgZnJvbSB0aGUgdGV4dHVyZSBjYWNoZSBtYXRjaGluZyB0aGUgZnJhbWVJZFxuICovXG5QSVhJLlNwcml0ZS5mcm9tRnJhbWUgPSBmdW5jdGlvbihmcmFtZUlkKVxue1xuICAgIHZhciB0ZXh0dXJlID0gUElYSS5UZXh0dXJlQ2FjaGVbZnJhbWVJZF07XG4gICAgaWYoIXRleHR1cmUpIHRocm93IG5ldyBFcnJvcignVGhlIGZyYW1lSWQgXCInICsgZnJhbWVJZCArICdcIiBkb2VzIG5vdCBleGlzdCBpbiB0aGUgdGV4dHVyZSBjYWNoZScgKyB0aGlzKTtcbiAgICByZXR1cm4gbmV3IFBJWEkuU3ByaXRlKHRleHR1cmUpO1xufTtcblxuLyoqXG4gKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIHNwcml0ZSB0aGF0IHdpbGwgY29udGFpbiBhIHRleHR1cmUgYmFzZWQgb24gYW4gaW1hZ2UgdXJsXG4gKiBJZiB0aGUgaW1hZ2UgaXMgbm90IGluIHRoZSB0ZXh0dXJlIGNhY2hlIGl0IHdpbGwgYmUgbG9hZGVkXG4gKlxuICogQG1ldGhvZCBmcm9tSW1hZ2VcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSBpbWFnZUlkIHtTdHJpbmd9IFRoZSBpbWFnZSB1cmwgb2YgdGhlIHRleHR1cmVcbiAqIEByZXR1cm4ge1Nwcml0ZX0gQSBuZXcgU3ByaXRlIHVzaW5nIGEgdGV4dHVyZSBmcm9tIHRoZSB0ZXh0dXJlIGNhY2hlIG1hdGNoaW5nIHRoZSBpbWFnZSBpZFxuICovXG5QSVhJLlNwcml0ZS5mcm9tSW1hZ2UgPSBmdW5jdGlvbihpbWFnZUlkLCBjcm9zc29yaWdpbiwgc2NhbGVNb2RlKVxue1xuICAgIHZhciB0ZXh0dXJlID0gUElYSS5UZXh0dXJlLmZyb21JbWFnZShpbWFnZUlkLCBjcm9zc29yaWdpbiwgc2NhbGVNb2RlKTtcbiAgICByZXR1cm4gbmV3IFBJWEkuU3ByaXRlKHRleHR1cmUpO1xufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vXG4gKi9cblxuLyoqXG4gKiBUaGUgU3ByaXRlQmF0Y2ggY2xhc3MgaXMgYSByZWFsbHkgZmFzdCB2ZXJzaW9uIG9mIHRoZSBEaXNwbGF5T2JqZWN0Q29udGFpbmVyIFxuICogYnVpbHQgc29sZWx5IGZvciBzcGVlZCwgc28gdXNlIHdoZW4geW91IG5lZWQgYSBsb3Qgb2Ygc3ByaXRlcyBvciBwYXJ0aWNsZXMuXG4gKiBBbmQgaXQncyBleHRyZW1lbHkgZWFzeSB0byB1c2UgOiBcblxuICAgIHZhciBjb250YWluZXIgPSBuZXcgUElYSS5TcHJpdGVCYXRjaCgpO1xuIFxuICAgIHN0YWdlLmFkZENoaWxkKGNvbnRhaW5lcik7XG4gXG4gICAgZm9yKHZhciBpICA9IDA7IGkgPCAxMDA7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBzcHJpdGUgPSBuZXcgUElYSS5TcHJpdGUuZnJvbUltYWdlKFwibXlJbWFnZS5wbmdcIik7XG4gICAgICAgIGNvbnRhaW5lci5hZGRDaGlsZChzcHJpdGUpO1xuICAgIH1cbiAqIEFuZCBoZXJlIHlvdSBoYXZlIGEgaHVuZHJlZCBzcHJpdGVzIHRoYXQgd2lsbCBiZSByZW5kZXJlciBhdCB0aGUgc3BlZWQgb2YgbGlnaHRcbiAqXG4gKiBAY2xhc3MgU3ByaXRlQmF0Y2hcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHRleHR1cmUge1RleHR1cmV9XG4gKi9cblBJWEkuU3ByaXRlQmF0Y2ggPSBmdW5jdGlvbih0ZXh0dXJlKVxue1xuICAgIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKCB0aGlzKTtcblxuICAgIHRoaXMudGV4dHVyZVRoaW5nID0gdGV4dHVyZTtcblxuICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcbn07XG5cblBJWEkuU3ByaXRlQmF0Y2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlKTtcblBJWEkuU3ByaXRlQmF0Y2guY29uc3RydWN0b3IgPSBQSVhJLlNwcml0ZUJhdGNoO1xuXG4vKlxuICogSW5pdGlhbGlzZXMgdGhlIHNwcml0ZUJhdGNoXG4gKlxuICogQG1ldGhvZCBpbml0V2ViR0xcbiAqIEBwYXJhbSBnbCB7V2ViR0xDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiAqL1xuUElYSS5TcHJpdGVCYXRjaC5wcm90b3R5cGUuaW5pdFdlYkdMID0gZnVuY3Rpb24oZ2wpXG57XG4gICAgLy8gVE9ETyBvbmx5IG9uZSBuZWVkZWQgZm9yIHRoZSB3aG9sZSBlbmdpbmUgcmVhbGx5P1xuICAgIHRoaXMuZmFzdFNwcml0ZUJhdGNoID0gbmV3IFBJWEkuV2ViR0xGYXN0U3ByaXRlQmF0Y2goZ2wpO1xuXG4gICAgdGhpcy5yZWFkeSA9IHRydWU7XG59O1xuXG4vKlxuICogVXBkYXRlcyB0aGUgb2JqZWN0IHRyYW5zZm9ybSBmb3IgcmVuZGVyaW5nXG4gKlxuICogQG1ldGhvZCB1cGRhdGVUcmFuc2Zvcm1cbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuU3ByaXRlQmF0Y2gucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uKClcbntcbiAgIC8vIFRPRE8gZG9udCBuZWVkIHRvIVxuICAgIFBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtLmNhbGwoIHRoaXMgKTtcbiAgLy8gIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtLmNhbGwoIHRoaXMgKTtcbn07XG5cbi8qKlxuKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyXG4qXG4qIEBtZXRob2QgX3JlbmRlcldlYkdMXG4qIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtSZW5kZXJTZXNzaW9ufSBcbiogQHByaXZhdGVcbiovXG5QSVhJLlNwcml0ZUJhdGNoLnByb3RvdHlwZS5fcmVuZGVyV2ViR0wgPSBmdW5jdGlvbihyZW5kZXJTZXNzaW9uKVxue1xuICAgIGlmKCF0aGlzLnZpc2libGUgfHwgdGhpcy5hbHBoYSA8PSAwIHx8ICF0aGlzLmNoaWxkcmVuLmxlbmd0aClyZXR1cm47XG5cbiAgICBpZighdGhpcy5yZWFkeSl0aGlzLmluaXRXZWJHTCggcmVuZGVyU2Vzc2lvbi5nbCApO1xuICAgIFxuICAgIHJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2guc3RvcCgpO1xuICAgIFxuICAgIHJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlci5zZXRTaGFkZXIocmVuZGVyU2Vzc2lvbi5zaGFkZXJNYW5hZ2VyLmZhc3RTaGFkZXIpO1xuICAgIFxuICAgIHRoaXMuZmFzdFNwcml0ZUJhdGNoLmJlZ2luKHRoaXMsIHJlbmRlclNlc3Npb24pO1xuICAgIHRoaXMuZmFzdFNwcml0ZUJhdGNoLnJlbmRlcih0aGlzKTtcblxuICAgIHJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2guc3RhcnQoKTtcbiBcbn07XG5cbi8qKlxuKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIENhbnZhcyByZW5kZXJlclxuKlxuKiBAbWV0aG9kIF9yZW5kZXJDYW52YXNcbiogQHBhcmFtIHJlbmRlclNlc3Npb24ge1JlbmRlclNlc3Npb259IFxuKiBAcHJpdmF0ZVxuKi9cblBJWEkuU3ByaXRlQmF0Y2gucHJvdG90eXBlLl9yZW5kZXJDYW52YXMgPSBmdW5jdGlvbihyZW5kZXJTZXNzaW9uKVxue1xuICAgIHZhciBjb250ZXh0ID0gcmVuZGVyU2Vzc2lvbi5jb250ZXh0O1xuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XG5cbiAgICBQSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybS5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMud29ybGRUcmFuc2Zvcm07XG4gICAgLy8gYWxvdyBmb3IgdHJpbW1pbmdcbiAgICAgICBcbiAgICB2YXIgaXNSb3RhdGVkID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgIFxuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuXG4gICAgICAgIGlmKCFjaGlsZC52aXNpYmxlKWNvbnRpbnVlO1xuXG4gICAgICAgIHZhciB0ZXh0dXJlID0gY2hpbGQudGV4dHVyZTtcbiAgICAgICAgdmFyIGZyYW1lID0gdGV4dHVyZS5mcmFtZTtcblxuICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gdGhpcy53b3JsZEFscGhhICogY2hpbGQuYWxwaGE7XG5cbiAgICAgICAgaWYoY2hpbGQucm90YXRpb24gJSAoTWF0aC5QSSAqIDIpID09PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZihpc1JvdGF0ZWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0odHJhbnNmb3JtLmEsIHRyYW5zZm9ybS5jLCB0cmFuc2Zvcm0uYiwgdHJhbnNmb3JtLmQsIHRyYW5zZm9ybS50eCwgdHJhbnNmb3JtLnR5KTtcbiAgICAgICAgICAgICAgICBpc1JvdGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgZmFzdGVzdCAgd2F5IHRvIG9wdGltaXNlISAtIGlmIHJvdGF0aW9uIGlzIDAgdGhlbiB3ZSBjYW4gYXZvaWQgYW55IGtpbmQgb2Ygc2V0VHJhbnNmb3JtIGNhbGxcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHRleHR1cmUuYmFzZVRleHR1cmUuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoY2hpbGQuYW5jaG9yLngpICogKC1mcmFtZS53aWR0aCAqIGNoaWxkLnNjYWxlLngpICsgY2hpbGQucG9zaXRpb24ueCAgKyAwLjUpIHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoY2hpbGQuYW5jaG9yLnkpICogKC1mcmFtZS5oZWlnaHQgKiBjaGlsZC5zY2FsZS55KSArIGNoaWxkLnBvc2l0aW9uLnkgICsgMC41KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS53aWR0aCAqIGNoaWxkLnNjYWxlLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5oZWlnaHQgKiBjaGlsZC5zY2FsZS55KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmKCFpc1JvdGF0ZWQpaXNSb3RhdGVkID0gdHJ1ZTtcbiAgICBcbiAgICAgICAgICAgIFBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtLmNhbGwoY2hpbGQpO1xuICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBjaGlsZFRyYW5zZm9ybSA9IGNoaWxkLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgICAgICAgICAvLyBhbGxvdyBmb3IgdHJpbW1pbmdcbiAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocmVuZGVyU2Vzc2lvbi5yb3VuZFBpeGVscylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybShjaGlsZFRyYW5zZm9ybS5hLCBjaGlsZFRyYW5zZm9ybS5jLCBjaGlsZFRyYW5zZm9ybS5iLCBjaGlsZFRyYW5zZm9ybS5kLCBjaGlsZFRyYW5zZm9ybS50eCB8IDAsIGNoaWxkVHJhbnNmb3JtLnR5IHwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oY2hpbGRUcmFuc2Zvcm0uYSwgY2hpbGRUcmFuc2Zvcm0uYywgY2hpbGRUcmFuc2Zvcm0uYiwgY2hpbGRUcmFuc2Zvcm0uZCwgY2hpbGRUcmFuc2Zvcm0udHgsIGNoaWxkVHJhbnNmb3JtLnR5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UodGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChjaGlsZC5hbmNob3IueCkgKiAoLWZyYW1lLndpZHRoKSArIDAuNSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChjaGlsZC5hbmNob3IueSkgKiAoLWZyYW1lLmhlaWdodCkgKyAwLjUpIHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUuaGVpZ2h0KTtcbiAgICAgICAgICAgXG5cbiAgICAgICAgfVxuXG4gICAgICAgLy8gY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfVxuXG4vLyAgICBjb250ZXh0LnJlc3RvcmUoKTtcbn07XG5cblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqIEEgTW92aWVDbGlwIGlzIGEgc2ltcGxlIHdheSB0byBkaXNwbGF5IGFuIGFuaW1hdGlvbiBkZXBpY3RlZCBieSBhIGxpc3Qgb2YgdGV4dHVyZXMuXG4gKlxuICogQGNsYXNzIE1vdmllQ2xpcFxuICogQGV4dGVuZHMgU3ByaXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB0ZXh0dXJlcyB7QXJyYXk8VGV4dHVyZT59IGFuIGFycmF5IG9mIHtUZXh0dXJlfSBvYmplY3RzIHRoYXQgbWFrZSB1cCB0aGUgYW5pbWF0aW9uXG4gKi9cblBJWEkuTW92aWVDbGlwID0gZnVuY3Rpb24odGV4dHVyZXMpXG57XG4gICAgUElYSS5TcHJpdGUuY2FsbCh0aGlzLCB0ZXh0dXJlc1swXSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXJyYXkgb2YgdGV4dHVyZXMgdGhhdCBtYWtlIHVwIHRoZSBhbmltYXRpb25cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0ZXh0dXJlc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgdGhpcy50ZXh0dXJlcyA9IHRleHR1cmVzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNwZWVkIHRoYXQgdGhlIE1vdmllQ2xpcCB3aWxsIHBsYXkgYXQuIEhpZ2hlciBpcyBmYXN0ZXIsIGxvd2VyIGlzIHNsb3dlclxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGFuaW1hdGlvblNwZWVkXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIHRoaXMuYW5pbWF0aW9uU3BlZWQgPSAxO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdGhlIG1vdmllIGNsaXAgcmVwZWF0cyBhZnRlciBwbGF5aW5nLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGxvb3BcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMubG9vcCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBjYWxsIHdoZW4gYSBNb3ZpZUNsaXAgZmluaXNoZXMgcGxheWluZ1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9uQ29tcGxldGVcbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqL1xuICAgIHRoaXMub25Db21wbGV0ZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBbcmVhZC1vbmx5XSBUaGUgTW92aWVDbGlwcyBjdXJyZW50IGZyYW1lIGluZGV4ICh0aGlzIG1heSBub3QgaGF2ZSB0byBiZSBhIHdob2xlIG51bWJlcilcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjdXJyZW50RnJhbWVcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogW3JlYWQtb25seV0gSW5kaWNhdGVzIGlmIHRoZSBNb3ZpZUNsaXAgaXMgY3VycmVudGx5IHBsYXlpbmdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwbGF5aW5nXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMucGxheWluZyA9IGZhbHNlO1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuTW92aWVDbGlwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBJWEkuU3ByaXRlLnByb3RvdHlwZSApO1xuUElYSS5Nb3ZpZUNsaXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5Nb3ZpZUNsaXA7XG5cbi8qKlxuKiBbcmVhZC1vbmx5XSB0b3RhbEZyYW1lcyBpcyB0aGUgdG90YWwgbnVtYmVyIG9mIGZyYW1lcyBpbiB0aGUgTW92aWVDbGlwLiBUaGlzIGlzIHRoZSBzYW1lIGFzIG51bWJlciBvZiB0ZXh0dXJlc1xuKiBhc3NpZ25lZCB0byB0aGUgTW92aWVDbGlwLlxuKlxuKiBAcHJvcGVydHkgdG90YWxGcmFtZXNcbiogQHR5cGUgTnVtYmVyXG4qIEBkZWZhdWx0IDBcbiogQHJlYWRPbmx5XG4qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KCBQSVhJLk1vdmllQ2xpcC5wcm90b3R5cGUsICd0b3RhbEZyYW1lcycsIHtcblx0Z2V0OiBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiB0aGlzLnRleHR1cmVzLmxlbmd0aDtcblx0fVxufSk7XG5cblxuLyoqXG4gKiBTdG9wcyB0aGUgTW92aWVDbGlwXG4gKlxuICogQG1ldGhvZCBzdG9wXG4gKi9cblBJWEkuTW92aWVDbGlwLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMucGxheWluZyA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBQbGF5cyB0aGUgTW92aWVDbGlwXG4gKlxuICogQG1ldGhvZCBwbGF5XG4gKi9cblBJWEkuTW92aWVDbGlwLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMucGxheWluZyA9IHRydWU7XG59O1xuXG4vKipcbiAqIFN0b3BzIHRoZSBNb3ZpZUNsaXAgYW5kIGdvZXMgdG8gYSBzcGVjaWZpYyBmcmFtZVxuICpcbiAqIEBtZXRob2QgZ290b0FuZFN0b3BcbiAqIEBwYXJhbSBmcmFtZU51bWJlciB7TnVtYmVyfSBmcmFtZSBpbmRleCB0byBzdG9wIGF0XG4gKi9cblBJWEkuTW92aWVDbGlwLnByb3RvdHlwZS5nb3RvQW5kU3RvcCA9IGZ1bmN0aW9uKGZyYW1lTnVtYmVyKVxue1xuICAgIHRoaXMucGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudEZyYW1lID0gZnJhbWVOdW1iZXI7XG4gICAgdmFyIHJvdW5kID0gKHRoaXMuY3VycmVudEZyYW1lICsgMC41KSB8IDA7XG4gICAgdGhpcy5zZXRUZXh0dXJlKHRoaXMudGV4dHVyZXNbcm91bmQgJSB0aGlzLnRleHR1cmVzLmxlbmd0aF0pO1xufTtcblxuLyoqXG4gKiBHb2VzIHRvIGEgc3BlY2lmaWMgZnJhbWUgYW5kIGJlZ2lucyBwbGF5aW5nIHRoZSBNb3ZpZUNsaXBcbiAqXG4gKiBAbWV0aG9kIGdvdG9BbmRQbGF5XG4gKiBAcGFyYW0gZnJhbWVOdW1iZXIge051bWJlcn0gZnJhbWUgaW5kZXggdG8gc3RhcnQgYXRcbiAqL1xuUElYSS5Nb3ZpZUNsaXAucHJvdG90eXBlLmdvdG9BbmRQbGF5ID0gZnVuY3Rpb24oZnJhbWVOdW1iZXIpXG57XG4gICAgdGhpcy5jdXJyZW50RnJhbWUgPSBmcmFtZU51bWJlcjtcbiAgICB0aGlzLnBsYXlpbmcgPSB0cnVlO1xufTtcblxuLypcbiAqIFVwZGF0ZXMgdGhlIG9iamVjdCB0cmFuc2Zvcm0gZm9yIHJlbmRlcmluZ1xuICpcbiAqIEBtZXRob2QgdXBkYXRlVHJhbnNmb3JtXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLk1vdmllQ2xpcC5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24oKVxue1xuICAgIFBJWEkuU3ByaXRlLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0uY2FsbCh0aGlzKTtcblxuICAgIGlmKCF0aGlzLnBsYXlpbmcpcmV0dXJuO1xuXG4gICAgdGhpcy5jdXJyZW50RnJhbWUgKz0gdGhpcy5hbmltYXRpb25TcGVlZDtcblxuICAgIHZhciByb3VuZCA9ICh0aGlzLmN1cnJlbnRGcmFtZSArIDAuNSkgfCAwO1xuXG4gICAgdGhpcy5jdXJyZW50RnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZSAlIHRoaXMudGV4dHVyZXMubGVuZ3RoO1xuXG4gICAgaWYodGhpcy5sb29wIHx8IHJvdW5kIDwgdGhpcy50ZXh0dXJlcy5sZW5ndGgpXG4gICAge1xuICAgICAgICB0aGlzLnNldFRleHR1cmUodGhpcy50ZXh0dXJlc1tyb3VuZCAlIHRoaXMudGV4dHVyZXMubGVuZ3RoXSk7XG4gICAgfVxuICAgIGVsc2UgaWYocm91bmQgPj0gdGhpcy50ZXh0dXJlcy5sZW5ndGgpXG4gICAge1xuICAgICAgICB0aGlzLmdvdG9BbmRTdG9wKHRoaXMudGV4dHVyZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgIGlmKHRoaXMub25Db21wbGV0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5vbkNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEEgc2hvcnQgaGFuZCB3YXkgb2YgY3JlYXRpbmcgYSBtb3ZpZWNsaXAgZnJvbSBhbiBhcnJheSBvZiBmcmFtZSBpZHNcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGZyb21GcmFtZXNcbiAqIEBwYXJhbSBmcmFtZXMge0FycmF5fSB0aGUgYXJyYXkgb2YgZnJhbWVzIGlkcyB0aGUgbW92aWVjbGlwIHdpbGwgdXNlIGFzIGl0cyB0ZXh0dXJlIGZyYW1lc1xuICovXG5QSVhJLk1vdmllQ2xpcC5mcm9tRnJhbWVzID0gZnVuY3Rpb24oZnJhbWVzKVxue1xuICAgIHZhciB0ZXh0dXJlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB0ZXh0dXJlcy5wdXNoKG5ldyBQSVhJLlRleHR1cmUuZnJvbUZyYW1lKGZyYW1lc1tpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUElYSS5Nb3ZpZUNsaXAodGV4dHVyZXMpO1xufTtcblxuLyoqXG4gKiBBIHNob3J0IGhhbmQgd2F5IG9mIGNyZWF0aW5nIGEgbW92aWVjbGlwIGZyb20gYW4gYXJyYXkgb2YgaW1hZ2UgaWRzXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBmcm9tRnJhbWVzXG4gKiBAcGFyYW0gZnJhbWVzIHtBcnJheX0gdGhlIGFycmF5IG9mIGltYWdlIGlkcyB0aGUgbW92aWVjbGlwIHdpbGwgdXNlIGFzIGl0cyB0ZXh0dXJlIGZyYW1lc1xuICovXG5QSVhJLk1vdmllQ2xpcC5mcm9tSW1hZ2VzID0gZnVuY3Rpb24oaW1hZ2VzKVxue1xuICAgIHZhciB0ZXh0dXJlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbWFnZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB0ZXh0dXJlcy5wdXNoKG5ldyBQSVhJLlRleHR1cmUuZnJvbUltYWdlKGltYWdlc1tpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUElYSS5Nb3ZpZUNsaXAodGV4dHVyZXMpO1xufTtcbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuXG5QSVhJLkZpbHRlckJsb2NrID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5yZW5kZXJhYmxlID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKiAtIE1vZGlmaWVkIGJ5IFRvbSBTbGV6YWtvd3NraSBodHRwOi8vd3d3LnRvbXNsZXpha293c2tpLmNvbSBAVG9tU2xlemFrb3dza2kgKDI0LzAzLzIwMTQpIC0gQWRkZWQgZHJvcFNoYWRvd0NvbG9yLlxuICovXG5cbi8qKlxuICogQSBUZXh0IE9iamVjdCB3aWxsIGNyZWF0ZSBhIGxpbmUocykgb2YgdGV4dC4gVG8gc3BsaXQgYSBsaW5lIHlvdSBjYW4gdXNlICdcXG4nIFxuICogb3IgYWRkIGEgd29yZFdyYXAgcHJvcGVydHkgc2V0IHRvIHRydWUgYW5kIGFuZCB3b3JkV3JhcFdpZHRoIHByb3BlcnR5IHdpdGggYSB2YWx1ZVxuICogaW4gdGhlIHN0eWxlIG9iamVjdFxuICpcbiAqIEBjbGFzcyBUZXh0XG4gKiBAZXh0ZW5kcyBTcHJpdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHRleHQge1N0cmluZ30gVGhlIGNvcHkgdGhhdCB5b3Ugd291bGQgbGlrZSB0aGUgdGV4dCB0byBkaXNwbGF5XG4gKiBAcGFyYW0gW3N0eWxlXSB7T2JqZWN0fSBUaGUgc3R5bGUgcGFyYW1ldGVyc1xuICogQHBhcmFtIFtzdHlsZS5mb250XSB7U3RyaW5nfSBkZWZhdWx0ICdib2xkIDIwcHggQXJpYWwnIFRoZSBzdHlsZSBhbmQgc2l6ZSBvZiB0aGUgZm9udFxuICogQHBhcmFtIFtzdHlsZS5maWxsPSdibGFjayddIHtTdHJpbmd8TnVtYmVyfSBBIGNhbnZhcyBmaWxsc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgb24gdGhlIHRleHQgZS5nICdyZWQnLCAnIzAwRkYwMCdcbiAqIEBwYXJhbSBbc3R5bGUuYWxpZ249J2xlZnQnXSB7U3RyaW5nfSBBbGlnbm1lbnQgZm9yIG11bHRpbGluZSB0ZXh0ICgnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCcpLCBkb2VzIG5vdCBhZmZlY3Qgc2luZ2xlIGxpbmUgdGV4dFxuICogQHBhcmFtIFtzdHlsZS5zdHJva2VdIHtTdHJpbmd8TnVtYmVyfSBBIGNhbnZhcyBmaWxsc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgb24gdGhlIHRleHQgc3Ryb2tlIGUuZyAnYmx1ZScsICcjRkNGRjAwJ1xuICogQHBhcmFtIFtzdHlsZS5zdHJva2VUaGlja25lc3M9MF0ge051bWJlcn0gQSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSB0aGlja25lc3Mgb2YgdGhlIHN0cm9rZS4gRGVmYXVsdCBpcyAwIChubyBzdHJva2UpXG4gKiBAcGFyYW0gW3N0eWxlLndvcmRXcmFwPWZhbHNlXSB7Qm9vbGVhbn0gSW5kaWNhdGVzIGlmIHdvcmQgd3JhcCBzaG91bGQgYmUgdXNlZFxuICogQHBhcmFtIFtzdHlsZS53b3JkV3JhcFdpZHRoPTEwMF0ge051bWJlcn0gVGhlIHdpZHRoIGF0IHdoaWNoIHRleHQgd2lsbCB3cmFwLCBpdCBuZWVkcyB3b3JkV3JhcCB0byBiZSBzZXQgdG8gdHJ1ZVxuICogQHBhcmFtIFtzdHlsZS5kcm9wU2hhZG93PWZhbHNlXSB7Qm9vbGVhbn0gU2V0IGEgZHJvcCBzaGFkb3cgZm9yIHRoZSB0ZXh0XG4gKiBAcGFyYW0gW3N0eWxlLmRyb3BTaGFkb3dDb2xvcj0nIzAwMDAwMCddIHtTdHJpbmd9IEEgZmlsbCBzdHlsZSB0byBiZSB1c2VkIG9uIHRoZSBkcm9wc2hhZG93IGUuZyAncmVkJywgJyMwMEZGMDAnXG4gKiBAcGFyYW0gW3N0eWxlLmRyb3BTaGFkb3dBbmdsZT1NYXRoLlBJLzRdIHtOdW1iZXJ9IFNldCBhIGFuZ2xlIG9mIHRoZSBkcm9wIHNoYWRvd1xuICogQHBhcmFtIFtzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U9NV0ge051bWJlcn0gU2V0IGEgZGlzdGFuY2Ugb2YgdGhlIGRyb3Agc2hhZG93XG4gKi9cblBJWEkuVGV4dCA9IGZ1bmN0aW9uKHRleHQsIHN0eWxlKVxue1xuICAgIC8qKlxuICAgICAqIFRoZSBjYW52YXMgZWxlbWVudCB0aGF0IGV2ZXJ5dGhpbmcgaXMgZHJhd24gdG9cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjYW52YXNcbiAgICAgKiBAdHlwZSBIVE1MQ2FudmFzRWxlbWVudFxuICAgICAqL1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FudmFzIDJkIGNvbnRleHQgdGhhdCBldmVyeXRoaW5nIGlzIGRyYXduIHdpdGhcbiAgICAgKiBAcHJvcGVydHkgY29udGV4dFxuICAgICAqIEB0eXBlIEhUTUxDYW52YXNFbGVtZW50IDJkIENvbnRleHRcbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgUElYSS5TcHJpdGUuY2FsbCh0aGlzLCBQSVhJLlRleHR1cmUuZnJvbUNhbnZhcyh0aGlzLmNhbnZhcykpO1xuXG4gICAgdGhpcy5zZXRUZXh0KHRleHQpO1xuICAgIHRoaXMuc2V0U3R5bGUoc3R5bGUpO1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuVGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBJWEkuU3ByaXRlLnByb3RvdHlwZSk7XG5QSVhJLlRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5UZXh0O1xuXG5cbi8qKlxuICogVGhlIHdpZHRoIG9mIHRoZSBzcHJpdGUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gKlxuICogQHByb3BlcnR5IHdpZHRoXG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuVGV4dC5wcm90b3R5cGUsICd3aWR0aCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmKHRoaXMuZGlydHkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGV4dCgpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZS54ICogdGhpcy50ZXh0dXJlLmZyYW1lLndpZHRoO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnNjYWxlLnggPSB2YWx1ZSAvIHRoaXMudGV4dHVyZS5mcmFtZS53aWR0aDtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBUaGUgaGVpZ2h0IG9mIHRoZSBUZXh0LCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxuICpcbiAqIEBwcm9wZXJ0eSBoZWlnaHRcbiAqIEB0eXBlIE51bWJlclxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5UZXh0LnByb3RvdHlwZSwgJ2hlaWdodCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmKHRoaXMuZGlydHkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGV4dCgpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gIHRoaXMuc2NhbGUueSAqIHRoaXMudGV4dHVyZS5mcmFtZS5oZWlnaHQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2NhbGUueSA9IHZhbHVlIC8gdGhpcy50ZXh0dXJlLmZyYW1lLmhlaWdodDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gICAgfVxufSk7XG5cblxuLyoqXG4gKiBTZXQgdGhlIHN0eWxlIG9mIHRoZSB0ZXh0XG4gKlxuICogQG1ldGhvZCBzZXRTdHlsZVxuICogQHBhcmFtIFtzdHlsZV0ge09iamVjdH0gVGhlIHN0eWxlIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSBbc3R5bGUuZm9udD0nYm9sZCAyMHB0IEFyaWFsJ10ge1N0cmluZ30gVGhlIHN0eWxlIGFuZCBzaXplIG9mIHRoZSBmb250XG4gKiBAcGFyYW0gW3N0eWxlLmZpbGw9J2JsYWNrJ10ge09iamVjdH0gQSBjYW52YXMgZmlsbHN0eWxlIHRoYXQgd2lsbCBiZSB1c2VkIG9uIHRoZSB0ZXh0IGVnICdyZWQnLCAnIzAwRkYwMCdcbiAqIEBwYXJhbSBbc3R5bGUuYWxpZ249J2xlZnQnXSB7U3RyaW5nfSBBbGlnbm1lbnQgZm9yIG11bHRpbGluZSB0ZXh0ICgnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCcpLCBkb2VzIG5vdCBhZmZlY3Qgc2luZ2xlIGxpbmUgdGV4dFxuICogQHBhcmFtIFtzdHlsZS5zdHJva2U9J2JsYWNrJ10ge1N0cmluZ30gQSBjYW52YXMgZmlsbHN0eWxlIHRoYXQgd2lsbCBiZSB1c2VkIG9uIHRoZSB0ZXh0IHN0cm9rZSBlZyAnYmx1ZScsICcjRkNGRjAwJ1xuICogQHBhcmFtIFtzdHlsZS5zdHJva2VUaGlja25lc3M9MF0ge051bWJlcn0gQSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSB0aGlja25lc3Mgb2YgdGhlIHN0cm9rZS4gRGVmYXVsdCBpcyAwIChubyBzdHJva2UpXG4gKiBAcGFyYW0gW3N0eWxlLndvcmRXcmFwPWZhbHNlXSB7Qm9vbGVhbn0gSW5kaWNhdGVzIGlmIHdvcmQgd3JhcCBzaG91bGQgYmUgdXNlZFxuICogQHBhcmFtIFtzdHlsZS53b3JkV3JhcFdpZHRoPTEwMF0ge051bWJlcn0gVGhlIHdpZHRoIGF0IHdoaWNoIHRleHQgd2lsbCB3cmFwXG4gKiBAcGFyYW0gW3N0eWxlLmRyb3BTaGFkb3c9ZmFsc2VdIHtCb29sZWFufSBTZXQgYSBkcm9wIHNoYWRvdyBmb3IgdGhlIHRleHRcbiAqIEBwYXJhbSBbc3R5bGUuZHJvcFNoYWRvd0NvbG9yPScjMDAwMDAwJ10ge1N0cmluZ30gQSBmaWxsIHN0eWxlIHRvIGJlIHVzZWQgb24gdGhlIGRyb3BzaGFkb3cgZS5nICdyZWQnLCAnIzAwRkYwMCdcbiAqIEBwYXJhbSBbc3R5bGUuZHJvcFNoYWRvd0FuZ2xlPU1hdGguUEkvNF0ge051bWJlcn0gU2V0IGEgYW5nbGUgb2YgdGhlIGRyb3Agc2hhZG93XG4gKiBAcGFyYW0gW3N0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZT01XSB7TnVtYmVyfSBTZXQgYSBkaXN0YW5jZSBvZiB0aGUgZHJvcCBzaGFkb3dcbiAqL1xuUElYSS5UZXh0LnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uKHN0eWxlKVxue1xuICAgIHN0eWxlID0gc3R5bGUgfHwge307XG4gICAgc3R5bGUuZm9udCA9IHN0eWxlLmZvbnQgfHwgJ2JvbGQgMjBwdCBBcmlhbCc7XG4gICAgc3R5bGUuZmlsbCA9IHN0eWxlLmZpbGwgfHwgJ2JsYWNrJztcbiAgICBzdHlsZS5hbGlnbiA9IHN0eWxlLmFsaWduIHx8ICdsZWZ0JztcbiAgICBzdHlsZS5zdHJva2UgPSBzdHlsZS5zdHJva2UgfHwgJ2JsYWNrJzsgLy9wcm92aWRlIGEgZGVmYXVsdCwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vR29vZEJveURpZ2l0YWwvcGl4aS5qcy9pc3N1ZXMvMTM2XG4gICAgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzID0gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIHx8IDA7XG4gICAgc3R5bGUud29yZFdyYXAgPSBzdHlsZS53b3JkV3JhcCB8fCBmYWxzZTtcbiAgICBzdHlsZS53b3JkV3JhcFdpZHRoID0gc3R5bGUud29yZFdyYXBXaWR0aCB8fCAxMDA7XG4gICAgc3R5bGUud29yZFdyYXBXaWR0aCA9IHN0eWxlLndvcmRXcmFwV2lkdGggfHwgMTAwO1xuICAgIFxuICAgIHN0eWxlLmRyb3BTaGFkb3cgPSBzdHlsZS5kcm9wU2hhZG93IHx8IGZhbHNlO1xuICAgIHN0eWxlLmRyb3BTaGFkb3dBbmdsZSA9IHN0eWxlLmRyb3BTaGFkb3dBbmdsZSB8fCBNYXRoLlBJIC8gNjtcbiAgICBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2UgPSBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2UgfHwgNDtcbiAgICBzdHlsZS5kcm9wU2hhZG93Q29sb3IgPSBzdHlsZS5kcm9wU2hhZG93Q29sb3IgfHwgJ2JsYWNrJztcblxuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb3B5IGZvciB0aGUgdGV4dCBvYmplY3QuIFRvIHNwbGl0IGEgbGluZSB5b3UgY2FuIHVzZSAnXFxuJ1xuICpcbiAqIEBtZXRob2Qgc2V0VGV4dFxuICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIGNvcHkgdGhhdCB5b3Ugd291bGQgbGlrZSB0aGUgdGV4dCB0byBkaXNwbGF5XG4gKi9cblBJWEkuVGV4dC5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uKHRleHQpXG57XG4gICAgdGhpcy50ZXh0ID0gdGV4dC50b1N0cmluZygpIHx8ICcgJztcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxufTtcblxuLyoqXG4gKiBSZW5kZXJzIHRleHQgYW5kIHVwZGF0ZXMgaXQgd2hlbiBuZWVkZWRcbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVRleHRcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuVGV4dC5wcm90b3R5cGUudXBkYXRlVGV4dCA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmNvbnRleHQuZm9udCA9IHRoaXMuc3R5bGUuZm9udDtcblxuICAgIHZhciBvdXRwdXRUZXh0ID0gdGhpcy50ZXh0O1xuXG4gICAgLy8gd29yZCB3cmFwXG4gICAgLy8gcHJlc2VydmUgb3JpZ2luYWwgdGV4dFxuICAgIGlmKHRoaXMuc3R5bGUud29yZFdyYXApb3V0cHV0VGV4dCA9IHRoaXMud29yZFdyYXAodGhpcy50ZXh0KTtcblxuICAgIC8vc3BsaXQgdGV4dCBpbnRvIGxpbmVzXG4gICAgdmFyIGxpbmVzID0gb3V0cHV0VGV4dC5zcGxpdCgvKD86XFxyXFxufFxccnxcXG4pLyk7XG5cbiAgICAvL2NhbGN1bGF0ZSB0ZXh0IHdpZHRoXG4gICAgdmFyIGxpbmVXaWR0aHMgPSBbXTtcbiAgICB2YXIgbWF4TGluZVdpZHRoID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHRoaXMuY29udGV4dC5tZWFzdXJlVGV4dChsaW5lc1tpXSkud2lkdGg7XG4gICAgICAgIGxpbmVXaWR0aHNbaV0gPSBsaW5lV2lkdGg7XG4gICAgICAgIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgbGluZVdpZHRoKTtcbiAgICB9XG5cbiAgICB2YXIgd2lkdGggPSBtYXhMaW5lV2lkdGggKyB0aGlzLnN0eWxlLnN0cm9rZVRoaWNrbmVzcztcbiAgICBpZih0aGlzLnN0eWxlLmRyb3BTaGFkb3cpd2lkdGggKz0gdGhpcy5zdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U7XG5cbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHdpZHRoICsgdGhpcy5jb250ZXh0LmxpbmVXaWR0aDtcbiAgICAvL2NhbGN1bGF0ZSB0ZXh0IGhlaWdodFxuICAgIHZhciBsaW5lSGVpZ2h0ID0gdGhpcy5kZXRlcm1pbmVGb250SGVpZ2h0KCdmb250OiAnICsgdGhpcy5zdHlsZS5mb250ICArICc7JykgKyB0aGlzLnN0eWxlLnN0cm9rZVRoaWNrbmVzcztcbiAgICBcbiAgICB2YXIgaGVpZ2h0ID0gbGluZUhlaWdodCAqIGxpbmVzLmxlbmd0aDtcbiAgICBpZih0aGlzLnN0eWxlLmRyb3BTaGFkb3cpaGVpZ2h0ICs9IHRoaXMuc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlO1xuXG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgaWYobmF2aWdhdG9yLmlzQ29jb29uSlMpIHRoaXMuY29udGV4dC5jbGVhclJlY3QoMCwwLHRoaXMuY2FudmFzLndpZHRoLHRoaXMuY2FudmFzLmhlaWdodCk7XG4gICAgXG4gICAgdGhpcy5jb250ZXh0LmZvbnQgPSB0aGlzLnN0eWxlLmZvbnQ7XG4gICAgdGhpcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gdGhpcy5zdHlsZS5zdHJva2U7XG4gICAgdGhpcy5jb250ZXh0LmxpbmVXaWR0aCA9IHRoaXMuc3R5bGUuc3Ryb2tlVGhpY2tuZXNzO1xuICAgIHRoaXMuY29udGV4dC50ZXh0QmFzZWxpbmUgPSAndG9wJztcblxuICAgIHZhciBsaW5lUG9zaXRpb25YO1xuICAgIHZhciBsaW5lUG9zaXRpb25ZO1xuXG4gICAgaWYodGhpcy5zdHlsZS5kcm9wU2hhZG93KVxuICAgIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuc3R5bGUuZHJvcFNoYWRvd0NvbG9yO1xuXG4gICAgICAgIHZhciB4U2hhZG93T2Zmc2V0ID0gTWF0aC5zaW4odGhpcy5zdHlsZS5kcm9wU2hhZG93QW5nbGUpICogdGhpcy5zdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgICAgIHZhciB5U2hhZG93T2Zmc2V0ID0gTWF0aC5jb3ModGhpcy5zdHlsZS5kcm9wU2hhZG93QW5nbGUpICogdGhpcy5zdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBsaW5lUG9zaXRpb25YID0gdGhpcy5zdHlsZS5zdHJva2VUaGlja25lc3MgLyAyO1xuICAgICAgICAgICAgbGluZVBvc2l0aW9uWSA9IHRoaXMuc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMiArIGkgKiBsaW5lSGVpZ2h0O1xuXG4gICAgICAgICAgICBpZih0aGlzLnN0eWxlLmFsaWduID09PSAncmlnaHQnKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5zdHlsZS5hbGlnbiA9PT0gJ2NlbnRlcicpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGluZVBvc2l0aW9uWCArPSAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXSkgLyAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih0aGlzLnN0eWxlLmZpbGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxUZXh0KGxpbmVzW2ldLCBsaW5lUG9zaXRpb25YICsgeFNoYWRvd09mZnNldCwgbGluZVBvc2l0aW9uWSArIHlTaGFkb3dPZmZzZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gIGlmKGRyb3BTaGFkb3cpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL3NldCBjYW52YXMgdGV4dCBzdHlsZXNcbiAgICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5zdHlsZS5maWxsO1xuICAgIFxuICAgIC8vZHJhdyBsaW5lcyBsaW5lIGJ5IGxpbmVcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBsaW5lUG9zaXRpb25YID0gdGhpcy5zdHlsZS5zdHJva2VUaGlja25lc3MgLyAyO1xuICAgICAgICBsaW5lUG9zaXRpb25ZID0gdGhpcy5zdHlsZS5zdHJva2VUaGlja25lc3MgLyAyICsgaSAqIGxpbmVIZWlnaHQ7XG5cbiAgICAgICAgaWYodGhpcy5zdHlsZS5hbGlnbiA9PT0gJ3JpZ2h0JylcbiAgICAgICAge1xuICAgICAgICAgICAgbGluZVBvc2l0aW9uWCArPSBtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodGhpcy5zdHlsZS5hbGlnbiA9PT0gJ2NlbnRlcicpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaV0pIC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuc3R5bGUuc3Ryb2tlICYmIHRoaXMuc3R5bGUuc3Ryb2tlVGhpY2tuZXNzKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuc3Ryb2tlVGV4dChsaW5lc1tpXSwgbGluZVBvc2l0aW9uWCwgbGluZVBvc2l0aW9uWSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLnN0eWxlLmZpbGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsVGV4dChsaW5lc1tpXSwgbGluZVBvc2l0aW9uWCwgbGluZVBvc2l0aW9uWSk7XG4gICAgICAgIH1cblxuICAgICAgLy8gIGlmKGRyb3BTaGFkb3cpXG4gICAgfVxuXG5cbiAgICB0aGlzLnVwZGF0ZVRleHR1cmUoKTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0ZXh0dXJlIHNpemUgYmFzZWQgb24gY2FudmFzIHNpemVcbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVRleHR1cmVcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuVGV4dC5wcm90b3R5cGUudXBkYXRlVGV4dHVyZSA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLnRleHR1cmUuYmFzZVRleHR1cmUud2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aDtcbiAgICB0aGlzLnRleHR1cmUuYmFzZVRleHR1cmUuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuICAgIHRoaXMudGV4dHVyZS5jcm9wLndpZHRoID0gdGhpcy50ZXh0dXJlLmZyYW1lLndpZHRoID0gdGhpcy5jYW52YXMud2lkdGg7XG4gICAgdGhpcy50ZXh0dXJlLmNyb3AuaGVpZ2h0ID0gdGhpcy50ZXh0dXJlLmZyYW1lLmhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodDtcblxuICAgIHRoaXMuX3dpZHRoID0gdGhpcy5jYW52YXMud2lkdGg7XG4gICAgdGhpcy5faGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuXG4gICAgdGhpcy5yZXF1aXJlc1VwZGF0ZSA9ICB0cnVlO1xufTtcblxuLyoqXG4qIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbipcbiogQG1ldGhvZCBfcmVuZGVyV2ViR0xcbiogQHBhcmFtIHJlbmRlclNlc3Npb24ge1JlbmRlclNlc3Npb259IFxuKiBAcHJpdmF0ZVxuKi9cblBJWEkuVGV4dC5wcm90b3R5cGUuX3JlbmRlcldlYkdMID0gZnVuY3Rpb24ocmVuZGVyU2Vzc2lvbilcbntcbiAgICBpZih0aGlzLnJlcXVpcmVzVXBkYXRlKVxuICAgIHtcbiAgICAgICAgdGhpcy5yZXF1aXJlc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICBQSVhJLnVwZGF0ZVdlYkdMVGV4dHVyZSh0aGlzLnRleHR1cmUuYmFzZVRleHR1cmUsIHJlbmRlclNlc3Npb24uZ2wpO1xuICAgIH1cblxuICAgIFBJWEkuU3ByaXRlLnByb3RvdHlwZS5fcmVuZGVyV2ViR0wuY2FsbCh0aGlzLCByZW5kZXJTZXNzaW9uKTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgdHJhbnNmb3JtIG9mIHRoaXMgb2JqZWN0XG4gKlxuICogQG1ldGhvZCB1cGRhdGVUcmFuc2Zvcm1cbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuVGV4dC5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24oKVxue1xuICAgIGlmKHRoaXMuZGlydHkpXG4gICAge1xuICAgICAgICB0aGlzLnVwZGF0ZVRleHQoKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIFBJWEkuU3ByaXRlLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0uY2FsbCh0aGlzKTtcbn07XG5cbi8qXG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vdXNlcnMvMzQ0NDEvZWxsaXNiYmVuXG4gKiBncmVhdCBzb2x1dGlvbiB0byB0aGUgcHJvYmxlbSFcbiAqIHJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgZ2l2ZW4gZm9udFxuICpcbiAqIEBtZXRob2QgZGV0ZXJtaW5lRm9udEhlaWdodFxuICogQHBhcmFtIGZvbnRTdHlsZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuUElYSS5UZXh0LnByb3RvdHlwZS5kZXRlcm1pbmVGb250SGVpZ2h0ID0gZnVuY3Rpb24oZm9udFN0eWxlKVxue1xuICAgIC8vIGJ1aWxkIGEgbGl0dGxlIHJlZmVyZW5jZSBkaWN0aW9uYXJ5IHNvIGlmIHRoZSBmb250IHN0eWxlIGhhcyBiZWVuIHVzZWQgcmV0dXJuIGFcbiAgICAvLyBjYWNoZWQgdmVyc2lvbi4uLlxuICAgIHZhciByZXN1bHQgPSBQSVhJLlRleHQuaGVpZ2h0Q2FjaGVbZm9udFN0eWxlXTtcblxuICAgIGlmKCFyZXN1bHQpXG4gICAge1xuICAgICAgICB2YXIgYm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF07XG4gICAgICAgIHZhciBkdW1teSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB2YXIgZHVtbXlUZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ00nKTtcbiAgICAgICAgZHVtbXkuYXBwZW5kQ2hpbGQoZHVtbXlUZXh0KTtcbiAgICAgICAgZHVtbXkuc2V0QXR0cmlidXRlKCdzdHlsZScsIGZvbnRTdHlsZSArICc7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowJyk7XG4gICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoZHVtbXkpO1xuXG4gICAgICAgIHJlc3VsdCA9IGR1bW15Lm9mZnNldEhlaWdodDtcbiAgICAgICAgUElYSS5UZXh0LmhlaWdodENhY2hlW2ZvbnRTdHlsZV0gPSByZXN1bHQ7XG5cbiAgICAgICAgYm9keS5yZW1vdmVDaGlsZChkdW1teSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQXBwbGllcyBuZXdsaW5lcyB0byBhIHN0cmluZyB0byBoYXZlIGl0IG9wdGltYWxseSBmaXQgaW50byB0aGUgaG9yaXpvbnRhbFxuICogYm91bmRzIHNldCBieSB0aGUgVGV4dCBvYmplY3QncyB3b3JkV3JhcFdpZHRoIHByb3BlcnR5LlxuICpcbiAqIEBtZXRob2Qgd29yZFdyYXBcbiAqIEBwYXJhbSB0ZXh0IHtTdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlRleHQucHJvdG90eXBlLndvcmRXcmFwID0gZnVuY3Rpb24odGV4dClcbntcbiAgICAvLyBHcmVlZHkgd3JhcHBpbmcgYWxnb3JpdGhtIHRoYXQgd2lsbCB3cmFwIHdvcmRzIGFzIHRoZSBsaW5lIGdyb3dzIGxvbmdlclxuICAgIC8vIHRoYW4gaXRzIGhvcml6b250YWwgYm91bmRzLlxuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIHNwYWNlTGVmdCA9IHRoaXMuc3R5bGUud29yZFdyYXBXaWR0aDtcbiAgICAgICAgdmFyIHdvcmRzID0gbGluZXNbaV0uc3BsaXQoJyAnKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB3b3Jkcy5sZW5ndGg7IGorKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHdvcmRXaWR0aCA9IHRoaXMuY29udGV4dC5tZWFzdXJlVGV4dCh3b3Jkc1tqXSkud2lkdGg7XG4gICAgICAgICAgICB2YXIgd29yZFdpZHRoV2l0aFNwYWNlID0gd29yZFdpZHRoICsgdGhpcy5jb250ZXh0Lm1lYXN1cmVUZXh0KCcgJykud2lkdGg7XG4gICAgICAgICAgICBpZihqID09PSAwIHx8IHdvcmRXaWR0aFdpdGhTcGFjZSA+IHNwYWNlTGVmdClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHByaW50aW5nIHRoZSBuZXdsaW5lIGlmIGl0J3MgdGhlIGZpcnN0IHdvcmQgb2YgdGhlIGxpbmUgdGhhdCBpc1xuICAgICAgICAgICAgICAgIC8vIGdyZWF0ZXIgdGhhbiB0aGUgd29yZCB3cmFwIHdpZHRoLlxuICAgICAgICAgICAgICAgIGlmKGogPiAwKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd29yZHNbal07XG4gICAgICAgICAgICAgICAgc3BhY2VMZWZ0ID0gdGhpcy5zdHlsZS53b3JkV3JhcFdpZHRoIC0gd29yZFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNwYWNlTGVmdCAtPSB3b3JkV2lkdGhXaXRoU3BhY2U7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcgJyArIHdvcmRzW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPCBsaW5lcy5sZW5ndGgtMSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoaXMgdGV4dCBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIGRlc3Ryb3lcbiAqIEBwYXJhbSBkZXN0cm95QmFzZVRleHR1cmUge0Jvb2xlYW59IHdoZXRoZXIgdG8gZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIGFzIHdlbGxcbiAqL1xuUElYSS5UZXh0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oZGVzdHJveUJhc2VUZXh0dXJlKVxue1xuICAgIC8vIG1ha2Ugc3VyZSB0byByZXNldCB0aGUgdGhlIGNvbnRleHQgYW5kIGNhbnZhcy4uIGRvbnQgd2FudCB0aGlzIGhhbmdpbmcgYXJvdW5kIGluIG1lbW9yeSFcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuY2FudmFzID0gbnVsbDtcblxuICAgIHRoaXMudGV4dHVyZS5kZXN0cm95KGRlc3Ryb3lCYXNlVGV4dHVyZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGRlc3Ryb3lCYXNlVGV4dHVyZSk7XG59O1xuXG5QSVhJLlRleHQuaGVpZ2h0Q2FjaGUgPSB7fTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqIEEgVGV4dCBPYmplY3Qgd2lsbCBjcmVhdGUgYSBsaW5lKHMpIG9mIHRleHQgdXNpbmcgYml0bWFwIGZvbnQuIFRvIHNwbGl0IGEgbGluZSB5b3UgY2FuIHVzZSAnXFxuJywgJ1xccicgb3IgJ1xcclxcbidcbiAqIFlvdSBjYW4gZ2VuZXJhdGUgdGhlIGZudCBmaWxlcyB1c2luZ1xuICogaHR0cDovL3d3dy5hbmdlbGNvZGUuY29tL3Byb2R1Y3RzL2JtZm9udC8gZm9yIHdpbmRvd3Mgb3JcbiAqIGh0dHA6Ly93d3cuYm1nbHlwaC5jb20vIGZvciBtYWMuXG4gKlxuICogQGNsYXNzIEJpdG1hcFRleHRcbiAqIEBleHRlbmRzIERpc3BsYXlPYmplY3RDb250YWluZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHRleHQge1N0cmluZ30gVGhlIGNvcHkgdGhhdCB5b3Ugd291bGQgbGlrZSB0aGUgdGV4dCB0byBkaXNwbGF5XG4gKiBAcGFyYW0gc3R5bGUge09iamVjdH0gVGhlIHN0eWxlIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSBzdHlsZS5mb250IHtTdHJpbmd9IFRoZSBzaXplIChvcHRpb25hbCkgYW5kIGJpdG1hcCBmb250IGlkIChyZXF1aXJlZCkgZXEgJ0FyaWFsJyBvciAnMjBweCBBcmlhbCcgKG11c3QgaGF2ZSBsb2FkZWQgcHJldmlvdXNseSlcbiAqIEBwYXJhbSBbc3R5bGUuYWxpZ249J2xlZnQnXSB7U3RyaW5nfSBBbGlnbm1lbnQgZm9yIG11bHRpbGluZSB0ZXh0ICgnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCcpLCBkb2VzIG5vdCBhZmZlY3Qgc2luZ2xlIGxpbmUgdGV4dFxuICovXG5QSVhJLkJpdG1hcFRleHQgPSBmdW5jdGlvbih0ZXh0LCBzdHlsZSlcbntcbiAgICBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuX3Bvb2wgPSBbXTtcblxuICAgIHRoaXMuc2V0VGV4dCh0ZXh0KTtcbiAgICB0aGlzLnNldFN0eWxlKHN0eWxlKTtcbiAgICB0aGlzLnVwZGF0ZVRleHQoKTtcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vLyBjb25zdHJ1Y3RvclxuUElYSS5CaXRtYXBUZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZSk7XG5QSVhJLkJpdG1hcFRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5CaXRtYXBUZXh0O1xuXG4vKipcbiAqIFNldCB0aGUgY29weSBmb3IgdGhlIHRleHQgb2JqZWN0XG4gKlxuICogQG1ldGhvZCBzZXRUZXh0XG4gKiBAcGFyYW0gdGV4dCB7U3RyaW5nfSBUaGUgY29weSB0aGF0IHlvdSB3b3VsZCBsaWtlIHRoZSB0ZXh0IHRvIGRpc3BsYXlcbiAqL1xuUElYSS5CaXRtYXBUZXh0LnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24odGV4dClcbntcbiAgICB0aGlzLnRleHQgPSB0ZXh0IHx8ICcgJztcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzdHlsZSBvZiB0aGUgdGV4dFxuICogc3R5bGUuZm9udCB7U3RyaW5nfSBUaGUgc2l6ZSAob3B0aW9uYWwpIGFuZCBiaXRtYXAgZm9udCBpZCAocmVxdWlyZWQpIGVxICdBcmlhbCcgb3IgJzIwcHggQXJpYWwnIChtdXN0IGhhdmUgbG9hZGVkIHByZXZpb3VzbHkpXG4gKiBbc3R5bGUuYWxpZ249J2xlZnQnXSB7U3RyaW5nfSBBbGlnbm1lbnQgZm9yIG11bHRpbGluZSB0ZXh0ICgnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCcpLCBkb2VzIG5vdCBhZmZlY3Qgc2luZ2xlIGxpbmUgdGV4dFxuICpcbiAqIEBtZXRob2Qgc2V0U3R5bGVcbiAqIEBwYXJhbSBzdHlsZSB7T2JqZWN0fSBUaGUgc3R5bGUgcGFyYW1ldGVycywgY29udGFpbmVkIGFzIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0XG4gKi9cblBJWEkuQml0bWFwVGV4dC5wcm90b3R5cGUuc2V0U3R5bGUgPSBmdW5jdGlvbihzdHlsZSlcbntcbiAgICBzdHlsZSA9IHN0eWxlIHx8IHt9O1xuICAgIHN0eWxlLmFsaWduID0gc3R5bGUuYWxpZ24gfHwgJ2xlZnQnO1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcblxuICAgIHZhciBmb250ID0gc3R5bGUuZm9udC5zcGxpdCgnICcpO1xuICAgIHRoaXMuZm9udE5hbWUgPSBmb250W2ZvbnQubGVuZ3RoIC0gMV07XG4gICAgdGhpcy5mb250U2l6ZSA9IGZvbnQubGVuZ3RoID49IDIgPyBwYXJzZUludChmb250W2ZvbnQubGVuZ3RoIC0gMl0sIDEwKSA6IFBJWEkuQml0bWFwVGV4dC5mb250c1t0aGlzLmZvbnROYW1lXS5zaXplO1xuXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy50aW50ID0gc3R5bGUudGludDtcbn07XG5cbi8qKlxuICogUmVuZGVycyB0ZXh0IGFuZCB1cGRhdGVzIGl0IHdoZW4gbmVlZGVkXG4gKlxuICogQG1ldGhvZCB1cGRhdGVUZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkJpdG1hcFRleHQucHJvdG90eXBlLnVwZGF0ZVRleHQgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGRhdGEgPSBQSVhJLkJpdG1hcFRleHQuZm9udHNbdGhpcy5mb250TmFtZV07XG4gICAgdmFyIHBvcyA9IG5ldyBQSVhJLlBvaW50KCk7XG4gICAgdmFyIHByZXZDaGFyQ29kZSA9IG51bGw7XG4gICAgdmFyIGNoYXJzID0gW107XG4gICAgdmFyIG1heExpbmVXaWR0aCA9IDA7XG4gICAgdmFyIGxpbmVXaWR0aHMgPSBbXTtcbiAgICB2YXIgbGluZSA9IDA7XG4gICAgdmFyIHNjYWxlID0gdGhpcy5mb250U2l6ZSAvIGRhdGEuc2l6ZTtcbiAgICBcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnRleHQubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgY2hhckNvZGUgPSB0aGlzLnRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYoLyg/OlxcclxcbnxcXHJ8XFxuKS8udGVzdCh0aGlzLnRleHQuY2hhckF0KGkpKSlcbiAgICAgICAge1xuICAgICAgICAgICAgbGluZVdpZHRocy5wdXNoKHBvcy54KTtcbiAgICAgICAgICAgIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgcG9zLngpO1xuICAgICAgICAgICAgbGluZSsrO1xuXG4gICAgICAgICAgICBwb3MueCA9IDA7XG4gICAgICAgICAgICBwb3MueSArPSBkYXRhLmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBwcmV2Q2hhckNvZGUgPSBudWxsO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hhckRhdGEgPSBkYXRhLmNoYXJzW2NoYXJDb2RlXTtcbiAgICAgICAgaWYoIWNoYXJEYXRhKSBjb250aW51ZTtcblxuICAgICAgICBpZihwcmV2Q2hhckNvZGUgJiYgY2hhckRhdGFbcHJldkNoYXJDb2RlXSlcbiAgICAgICAge1xuICAgICAgICAgICAgcG9zLnggKz0gY2hhckRhdGEua2VybmluZ1twcmV2Q2hhckNvZGVdO1xuICAgICAgICB9XG4gICAgICAgIGNoYXJzLnB1c2goe3RleHR1cmU6Y2hhckRhdGEudGV4dHVyZSwgbGluZTogbGluZSwgY2hhckNvZGU6IGNoYXJDb2RlLCBwb3NpdGlvbjogbmV3IFBJWEkuUG9pbnQocG9zLnggKyBjaGFyRGF0YS54T2Zmc2V0LCBwb3MueSArIGNoYXJEYXRhLnlPZmZzZXQpfSk7XG4gICAgICAgIHBvcy54ICs9IGNoYXJEYXRhLnhBZHZhbmNlO1xuXG4gICAgICAgIHByZXZDaGFyQ29kZSA9IGNoYXJDb2RlO1xuICAgIH1cblxuICAgIGxpbmVXaWR0aHMucHVzaChwb3MueCk7XG4gICAgbWF4TGluZVdpZHRoID0gTWF0aC5tYXgobWF4TGluZVdpZHRoLCBwb3MueCk7XG5cbiAgICB2YXIgbGluZUFsaWduT2Zmc2V0cyA9IFtdO1xuICAgIGZvcihpID0gMDsgaSA8PSBsaW5lOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgYWxpZ25PZmZzZXQgPSAwO1xuICAgICAgICBpZih0aGlzLnN0eWxlLmFsaWduID09PSAncmlnaHQnKVxuICAgICAgICB7XG4gICAgICAgICAgICBhbGlnbk9mZnNldCA9IG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZih0aGlzLnN0eWxlLmFsaWduID09PSAnY2VudGVyJylcbiAgICAgICAge1xuICAgICAgICAgICAgYWxpZ25PZmZzZXQgPSAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXSkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVBbGlnbk9mZnNldHMucHVzaChhbGlnbk9mZnNldCk7XG4gICAgfVxuXG4gICAgdmFyIGxlbkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgdmFyIGxlbkNoYXJzID0gY2hhcnMubGVuZ3RoO1xuICAgIHZhciB0aW50ID0gdGhpcy50aW50IHx8IDB4RkZGRkZGO1xuICAgIGZvcihpID0gMDsgaSA8IGxlbkNoYXJzOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgYyA9IGkgPCBsZW5DaGlsZHJlbiA/IHRoaXMuY2hpbGRyZW5baV0gOiB0aGlzLl9wb29sLnBvcCgpOyAvLyBnZXQgb2xkIGNoaWxkIGlmIGhhdmUuIGlmIG5vdCAtIHRha2UgZnJvbSBwb29sLlxuXG4gICAgICAgIGlmIChjKSBjLnNldFRleHR1cmUoY2hhcnNbaV0udGV4dHVyZSk7IC8vIGNoZWNrIGlmIGdvdCBvbmUgYmVmb3JlLlxuICAgICAgICBlbHNlIGMgPSBuZXcgUElYSS5TcHJpdGUoY2hhcnNbaV0udGV4dHVyZSk7IC8vIGlmIG5vIGNyZWF0ZSBuZXcgb25lLlxuXG4gICAgICAgIGMucG9zaXRpb24ueCA9IChjaGFyc1tpXS5wb3NpdGlvbi54ICsgbGluZUFsaWduT2Zmc2V0c1tjaGFyc1tpXS5saW5lXSkgKiBzY2FsZTtcbiAgICAgICAgYy5wb3NpdGlvbi55ID0gY2hhcnNbaV0ucG9zaXRpb24ueSAqIHNjYWxlO1xuICAgICAgICBjLnNjYWxlLnggPSBjLnNjYWxlLnkgPSBzY2FsZTtcbiAgICAgICAgYy50aW50ID0gdGludDtcbiAgICAgICAgaWYgKCFjLnBhcmVudCkgdGhpcy5hZGRDaGlsZChjKTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgdW5uZWNlc3NhcnkgY2hpbGRyZW4uXG4gICAgLy8gYW5kIHB1dCB0aGVpciBpbnRvIHRoZSBwb29sLlxuICAgIHdoaWxlKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gbGVuQ2hhcnMpXG4gICAge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmdldENoaWxkQXQodGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgICAgdGhpcy5fcG9vbC5wdXNoKGNoaWxkKTtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBbcmVhZC1vbmx5XSBUaGUgd2lkdGggb2YgdGhlIG92ZXJhbGwgdGV4dCwgZGlmZmVyZW50IGZyb20gZm9udFNpemUsXG4gICAgICogd2hpY2ggaXMgZGVmaW5lZCBpbiB0aGUgc3R5bGUgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdGV4dFdpZHRoXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy50ZXh0V2lkdGggPSBtYXhMaW5lV2lkdGggKiBzY2FsZTtcblxuICAgIC8qKlxuICAgICAqIFtyZWFkLW9ubHldIFRoZSBoZWlnaHQgb2YgdGhlIG92ZXJhbGwgdGV4dCwgZGlmZmVyZW50IGZyb20gZm9udFNpemUsXG4gICAgICogd2hpY2ggaXMgZGVmaW5lZCBpbiB0aGUgc3R5bGUgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdGV4dEhlaWdodFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMudGV4dEhlaWdodCA9IChwb3MueSArIGRhdGEubGluZUhlaWdodCkgKiBzY2FsZTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgdHJhbnNmb3JtIG9mIHRoaXMgb2JqZWN0XG4gKlxuICogQG1ldGhvZCB1cGRhdGVUcmFuc2Zvcm1cbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuQml0bWFwVGV4dC5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24oKVxue1xuICAgIGlmKHRoaXMuZGlydHkpXG4gICAge1xuICAgICAgICB0aGlzLnVwZGF0ZVRleHQoKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtLmNhbGwodGhpcyk7XG59O1xuXG5QSVhJLkJpdG1hcFRleHQuZm9udHMgPSB7fTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuIFxuLyoqXG4gKiBIb2xkcyBhbGwgaW5mb3JtYXRpb24gcmVsYXRlZCB0byBhbiBJbnRlcmFjdGlvbiBldmVudFxuICpcbiAqIEBjbGFzcyBJbnRlcmFjdGlvbkRhdGFcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5QSVhJLkludGVyYWN0aW9uRGF0YSA9IGZ1bmN0aW9uKClcbntcbiAgICAvKipcbiAgICAgKiBUaGlzIHBvaW50IHN0b3JlcyB0aGUgZ2xvYmFsIGNvb3JkcyBvZiB3aGVyZSB0aGUgdG91Y2gvbW91c2UgZXZlbnQgaGFwcGVuZWRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBnbG9iYWxcbiAgICAgKiBAdHlwZSBQb2ludFxuICAgICAqL1xuICAgIHRoaXMuZ2xvYmFsID0gbmV3IFBJWEkuUG9pbnQoKTtcblxuICAgXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBTcHJpdGUgdGhhdCB3YXMgaW50ZXJhY3RlZCB3aXRoXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdGFyZ2V0XG4gICAgICogQHR5cGUgU3ByaXRlXG4gICAgICovXG4gICAgdGhpcy50YXJnZXQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBwYXNzZWQgdG8gYW4gZXZlbnQgaGFuZGxlciwgdGhpcyB3aWxsIGJlIHRoZSBvcmlnaW5hbCBET00gRXZlbnQgdGhhdCB3YXMgY2FwdHVyZWRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcmlnaW5hbEV2ZW50XG4gICAgICogQHR5cGUgRXZlbnRcbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBudWxsO1xufTtcblxuLyoqXG4gKiBUaGlzIHdpbGwgcmV0dXJuIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgc3BlY2lmaWVkIGRpc3BsYXlPYmplY3QgZm9yIHRoaXMgSW50ZXJhY3Rpb25EYXRhXG4gKlxuICogQG1ldGhvZCBnZXRMb2NhbFBvc2l0aW9uXG4gKiBAcGFyYW0gZGlzcGxheU9iamVjdCB7RGlzcGxheU9iamVjdH0gVGhlIERpc3BsYXlPYmplY3QgdGhhdCB5b3Ugd291bGQgbGlrZSB0aGUgbG9jYWwgY29vcmRzIG9mZlxuICogQHJldHVybiB7UG9pbnR9IEEgcG9pbnQgY29udGFpbmluZyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIEludGVyYWN0aW9uRGF0YSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgRGlzcGxheU9iamVjdFxuICovXG5QSVhJLkludGVyYWN0aW9uRGF0YS5wcm90b3R5cGUuZ2V0TG9jYWxQb3NpdGlvbiA9IGZ1bmN0aW9uKGRpc3BsYXlPYmplY3QpXG57XG4gICAgdmFyIHdvcmxkVHJhbnNmb3JtID0gZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybTtcbiAgICB2YXIgZ2xvYmFsID0gdGhpcy5nbG9iYWw7XG5cbiAgICAvLyBkbyBhIGNoZWVreSB0cmFuc2Zvcm0gdG8gZ2V0IHRoZSBtb3VzZSBjb29yZHM7XG4gICAgdmFyIGEwMCA9IHdvcmxkVHJhbnNmb3JtLmEsIGEwMSA9IHdvcmxkVHJhbnNmb3JtLmIsIGEwMiA9IHdvcmxkVHJhbnNmb3JtLnR4LFxuICAgICAgICBhMTAgPSB3b3JsZFRyYW5zZm9ybS5jLCBhMTEgPSB3b3JsZFRyYW5zZm9ybS5kLCBhMTIgPSB3b3JsZFRyYW5zZm9ybS50eSxcbiAgICAgICAgaWQgPSAxIC8gKGEwMCAqIGExMSArIGEwMSAqIC1hMTApO1xuICAgIC8vIHNldCB0aGUgbW91c2UgY29vcmRzLi4uXG4gICAgcmV0dXJuIG5ldyBQSVhJLlBvaW50KGExMSAqIGlkICogZ2xvYmFsLnggKyAtYTAxICogaWQgKiBnbG9iYWwueSArIChhMTIgKiBhMDEgLSBhMDIgKiBhMTEpICogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYTAwICogaWQgKiBnbG9iYWwueSArIC1hMTAgKiBpZCAqIGdsb2JhbC54ICsgKC1hMTIgKiBhMDAgKyBhMDIgKiBhMTApICogaWQpO1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuSW50ZXJhY3Rpb25EYXRhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuSW50ZXJhY3Rpb25EYXRhO1xuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4gLyoqXG4gKiBUaGUgaW50ZXJhY3Rpb24gbWFuYWdlciBkZWFscyB3aXRoIG1vdXNlIGFuZCB0b3VjaCBldmVudHMuIEFueSBEaXNwbGF5T2JqZWN0IGNhbiBiZSBpbnRlcmFjdGl2ZVxuICogaWYgaXRzIGludGVyYWN0aXZlIHBhcmFtZXRlciBpcyBzZXQgdG8gdHJ1ZVxuICogVGhpcyBtYW5hZ2VyIGFsc28gc3VwcG9ydHMgbXVsdGl0b3VjaC5cbiAqXG4gKiBAY2xhc3MgSW50ZXJhY3Rpb25NYW5hZ2VyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSBzdGFnZSB7U3RhZ2V9IFRoZSBzdGFnZSB0byBoYW5kbGUgaW50ZXJhY3Rpb25zXG4gKi9cblBJWEkuSW50ZXJhY3Rpb25NYW5hZ2VyID0gZnVuY3Rpb24oc3RhZ2UpXG57XG4gICAgLyoqXG4gICAgICogYSByZWZlcmVuY2UgdG8gdGhlIHN0YWdlXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgc3RhZ2VcbiAgICAgKiBAdHlwZSBTdGFnZVxuICAgICAqL1xuICAgIHRoaXMuc3RhZ2UgPSBzdGFnZTtcblxuICAgIC8qKlxuICAgICAqIHRoZSBtb3VzZSBkYXRhXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbW91c2VcbiAgICAgKiBAdHlwZSBJbnRlcmFjdGlvbkRhdGFcbiAgICAgKi9cbiAgICB0aGlzLm1vdXNlID0gbmV3IFBJWEkuSW50ZXJhY3Rpb25EYXRhKCk7XG5cbiAgICAvKipcbiAgICAgKiBhbiBvYmplY3QgdGhhdCBzdG9yZXMgY3VycmVudCB0b3VjaGVzIChJbnRlcmFjdGlvbkRhdGEpIGJ5IGlkIHJlZmVyZW5jZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRvdWNoc1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIHRoaXMudG91Y2hzID0ge307XG5cbiAgICAvLyBoZWxwZXJzXG4gICAgdGhpcy50ZW1wUG9pbnQgPSBuZXcgUElYSS5Qb2ludCgpO1xuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHByb3BlcnR5IG1vdXNlb3ZlckVuYWJsZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0aGlzLm1vdXNlb3ZlckVuYWJsZWQgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogdGlueSBsaXR0bGUgaW50ZXJhY3RpdmVEYXRhIHBvb2wgIVxuICAgICAqIFxuICAgICAqIEBwcm9wZXJ0eSBwb29sXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICB0aGlzLnBvb2wgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHRoZSBpdGVyYXRpdmUgaXRlbXMgZnJvbSB0aGUgb3VyIGludGVyYWN0aXZlIHRyZWVcbiAgICAgKiBAcHJvcGVydHkgaW50ZXJhY3RpdmVJdGVtc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJhY3RpdmVJdGVtcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogT3VyIGNhbnZhc1xuICAgICAqIEBwcm9wZXJ0eSBpbnRlcmFjdGlvbkRPTUVsZW1lbnRcbiAgICAgKiBAdHlwZSBIVE1MQ2FudmFzRWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQgPSBudWxsO1xuXG4gICAgLy90aGlzIHdpbGwgbWFrZSBpdCBzbyB0aGF0IHlvdSBkb250IGhhdmUgdG8gY2FsbCBiaW5kIGFsbCB0aGUgdGltZVxuICAgIHRoaXMub25Nb3VzZU1vdmUgPSB0aGlzLm9uTW91c2VNb3ZlLmJpbmQoIHRoaXMgKTtcbiAgICB0aGlzLm9uTW91c2VEb3duID0gdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25Nb3VzZU91dCA9IHRoaXMub25Nb3VzZU91dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25Nb3VzZVVwID0gdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKTtcblxuICAgIHRoaXMub25Ub3VjaFN0YXJ0ID0gdGhpcy5vblRvdWNoU3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uVG91Y2hFbmQgPSB0aGlzLm9uVG91Y2hFbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uVG91Y2hNb3ZlID0gdGhpcy5vblRvdWNoTW92ZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5sYXN0ID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjc3Mgc3R5bGUgb2YgdGhlIGN1cnNvciB0aGF0IGlzIGJlaW5nIHVzZWRcbiAgICAgKiBAcHJvcGVydHkgY3VycmVudEN1cnNvclN0eWxlXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICpcbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRDdXJzb3JTdHlsZSA9ICdpbmhlcml0JztcblxuICAgIC8qKlxuICAgICAqIElzIHNldCB0byB0cnVlIHdoZW4gdGhlIG1vdXNlIGlzIG1vdmVkIG91dCBvZiB0aGUgY2FudmFzXG4gICAgICogQHByb3BlcnR5IG1vdXNlT3V0XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqXG4gICAgICovXG4gICAgdGhpcy5tb3VzZU91dCA9IGZhbHNlO1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuSW50ZXJhY3Rpb25NYW5hZ2VyO1xuXG4vKipcbiAqIENvbGxlY3RzIGFuIGludGVyYWN0aXZlIHNwcml0ZSByZWN1cnNpdmVseSB0byBoYXZlIHRoZWlyIGludGVyYWN0aW9ucyBtYW5hZ2VkXG4gKlxuICogQG1ldGhvZCBjb2xsZWN0SW50ZXJhY3RpdmVTcHJpdGVcbiAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IHtEaXNwbGF5T2JqZWN0fSB0aGUgZGlzcGxheU9iamVjdCB0byBjb2xsZWN0XG4gKiBAcGFyYW0gaVBhcmVudCB7RGlzcGxheU9iamVjdH0gdGhlIGRpc3BsYXkgb2JqZWN0J3MgcGFyZW50XG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY29sbGVjdEludGVyYWN0aXZlU3ByaXRlID0gZnVuY3Rpb24oZGlzcGxheU9iamVjdCwgaVBhcmVudClcbntcbiAgICB2YXIgY2hpbGRyZW4gPSBkaXNwbGF5T2JqZWN0LmNoaWxkcmVuO1xuICAgIHZhciBsZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG5cbiAgICAvLyBtYWtlIGFuIGludGVyYWN0aW9uIHRyZWUuLi4ge2l0ZW0uX19pbnRlcmFjdGl2ZVBhcmVudH1cbiAgICBmb3IgKHZhciBpID0gbGVuZ3RoLTE7IGkgPj0gMDsgaS0tKVxuICAgIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgICAgLy8gcHVzaCBhbGwgaW50ZXJhY3RpdmUgYml0c1xuICAgICAgICBpZihjaGlsZC5faW50ZXJhY3RpdmUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlQYXJlbnQuaW50ZXJhY3RpdmVDaGlsZHJlbiA9IHRydWU7XG4gICAgICAgICAgICAvL2NoaWxkLl9faVBhcmVudCA9IGlQYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aXZlSXRlbXMucHVzaChjaGlsZCk7XG5cbiAgICAgICAgICAgIGlmKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCA+IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsZWN0SW50ZXJhY3RpdmVTcHJpdGUoY2hpbGQsIGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNoaWxkLl9faVBhcmVudCA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCA+IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsZWN0SW50ZXJhY3RpdmVTcHJpdGUoY2hpbGQsIGlQYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHRhcmdldCBmb3IgZXZlbnQgZGVsZWdhdGlvblxuICpcbiAqIEBtZXRob2Qgc2V0VGFyZ2V0XG4gKiBAcGFyYW0gdGFyZ2V0IHtXZWJHTFJlbmRlcmVyfENhbnZhc1JlbmRlcmVyfSB0aGUgcmVuZGVyZXIgdG8gYmluZCBldmVudHMgdG9cbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZXRUYXJnZXQgPSBmdW5jdGlvbih0YXJnZXQpXG57XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAvL2NoZWNrIGlmIHRoZSBkb20gZWxlbWVudCBoYXMgYmVlbiBzZXQuIElmIGl0IGhhcyBkb24ndCBkbyBhbnl0aGluZ1xuICAgIGlmKCB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudCA9PT0gbnVsbCApIHtcblxuICAgICAgICB0aGlzLnNldFRhcmdldERvbUVsZW1lbnQoIHRhcmdldC52aWV3ICk7XG4gICAgfVxuXG4gICAgXG59O1xuXG5cbi8qKlxuICogU2V0cyB0aGUgRE9NIGVsZW1lbnQgd2hpY2ggd2lsbCByZWNlaXZlIG1vdXNlL3RvdWNoIGV2ZW50cy4gVGhpcyBpcyB1c2VmdWwgZm9yIHdoZW4geW91IGhhdmUgb3RoZXIgRE9NXG4gKiBlbGVtZW50cyBvbiB0b3Agb2YgdGhlIHJlbmRlcmVycyBDYW52YXMgZWxlbWVudC4gV2l0aCB0aGlzIHlvdSdsbCBiZSBhYmxlIHRvIGRlbGVnYXRlIGFub3RoZXIgRE9NIGVsZW1lbnRcbiAqIHRvIHJlY2VpdmUgdGhvc2UgZXZlbnRzXG4gKlxuICogQG1ldGhvZCBzZXRUYXJnZXREb21FbGVtZW50XG4gKiBAcGFyYW0gZG9tRWxlbWVudCB7RE9NRWxlbWVudH0gdGhlIERPTSBlbGVtZW50IHdoaWNoIHdpbGwgcmVjZWl2ZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0VGFyZ2V0RG9tRWxlbWVudCA9IGZ1bmN0aW9uKGRvbUVsZW1lbnQpXG57XG5cbiAgICB0aGlzLnJlbW92ZUV2ZW50cygpO1xuXG5cbiAgICBpZiAod2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKVxuICAgIHtcbiAgICAgICAgLy8gdGltZSB0byByZW1vdmUgc29tZSBvZiB0aGF0IHpvb20gaW4gamEuLlxuICAgICAgICBkb21FbGVtZW50LnN0eWxlWyctbXMtY29udGVudC16b29taW5nJ10gPSAnbm9uZSc7XG4gICAgICAgIGRvbUVsZW1lbnQuc3R5bGVbJy1tcy10b3VjaC1hY3Rpb24nXSA9ICdub25lJztcblxuICAgICAgICAvLyBETyBzb21lIHdpbmRvdyBzcGVjaWZpYyB0b3VjaCFcbiAgICB9XG5cbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudCA9IGRvbUVsZW1lbnQ7XG5cbiAgICBkb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsICB0aGlzLm9uTW91c2VNb3ZlLCB0cnVlKTtcbiAgICBkb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsICB0aGlzLm9uTW91c2VEb3duLCB0cnVlKTtcbiAgICBkb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgICB0aGlzLm9uTW91c2VPdXQsIHRydWUpO1xuXG4gICAgLy8gYWludCBubyBtdWx0aSB0b3VjaCBqdXN0IHlldCFcbiAgICBkb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uVG91Y2hTdGFydCwgdHJ1ZSk7XG4gICAgZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMub25Ub3VjaEVuZCwgdHJ1ZSk7XG4gICAgZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlLCB0cnVlKTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgIHRoaXMub25Nb3VzZVVwLCB0cnVlKTtcbn07XG5cblxuUElYSS5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50cyA9IGZ1bmN0aW9uKClcbntcbiAgICBpZighdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQpcmV0dXJuO1xuXG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuc3R5bGVbJy1tcy1jb250ZW50LXpvb21pbmcnXSA9ICcnO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlWyctbXMtdG91Y2gtYWN0aW9uJ10gPSAnJztcblxuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsICB0aGlzLm9uTW91c2VNb3ZlLCB0cnVlKTtcbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAgdGhpcy5vbk1vdXNlRG93biwgdHJ1ZSk7XG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCAgIHRoaXMub25Nb3VzZU91dCwgdHJ1ZSk7XG5cbiAgICAvLyBhaW50IG5vIG11bHRpIHRvdWNoIGp1c3QgeWV0IVxuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uVG91Y2hTdGFydCwgdHJ1ZSk7XG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmQsIHRydWUpO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Ub3VjaE1vdmUsIHRydWUpO1xuXG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQgPSBudWxsO1xuXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAgdGhpcy5vbk1vdXNlVXAsIHRydWUpO1xufTtcblxuLyoqXG4gKiB1cGRhdGVzIHRoZSBzdGF0ZSBvZiBpbnRlcmFjdGl2ZSBvYmplY3RzXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpXG57XG4gICAgaWYoIXRoaXMudGFyZ2V0KXJldHVybjtcblxuICAgIC8vIGZyZXF1ZW5jeSBvZiAzMGZwcz8/XG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgdmFyIGRpZmYgPSBub3cgLSB0aGlzLmxhc3Q7XG4gICAgZGlmZiA9IChkaWZmICogUElYSS5JTlRFUkFDVElPTl9GUkVRVUVOQ1kgKSAvIDEwMDA7XG4gICAgaWYoZGlmZiA8IDEpcmV0dXJuO1xuICAgIHRoaXMubGFzdCA9IG5vdztcblxuICAgIHZhciBpID0gMDtcblxuICAgIC8vIG9rLi4gc28gbW91c2UgZXZlbnRzPz9cbiAgICAvLyB5ZXMgZm9yIG5vdyA6KVxuICAgIC8vIE9QVElNSVNFIC0gaG93IG9mdGVuIHRvIGNoZWNrPz9cbiAgICBpZih0aGlzLmRpcnR5KVxuICAgIHtcbiAgICAgICAgdGhpcy5yZWJ1aWxkSW50ZXJhY3RpdmVHcmFwaCgpO1xuICAgIH1cblxuICAgIC8vIGxvb3AgdGhyb3VnaCBpbnRlcmFjdGl2ZSBvYmplY3RzIVxuICAgIHZhciBsZW5ndGggPSB0aGlzLmludGVyYWN0aXZlSXRlbXMubGVuZ3RoO1xuICAgIHZhciBjdXJzb3IgPSAnaW5oZXJpdCc7XG4gICAgdmFyIG92ZXIgPSBmYWxzZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5pbnRlcmFjdGl2ZUl0ZW1zW2ldO1xuXG4gICAgICAgIC8vIE9QVElNSVNBVElPTiAtIG9ubHkgY2FsY3VsYXRlIGV2ZXJ5IHRpbWUgaWYgdGhlIG1vdXNlbW92ZSBmdW5jdGlvbiBleGlzdHMuLlxuICAgICAgICAvLyBPSyBzby4uIGRvZXMgdGhlIG9iamVjdCBoYXZlIGFueSBvdGhlciBpbnRlcmFjdGl2ZSBmdW5jdGlvbnM/XG4gICAgICAgIC8vIGhpdC10ZXN0IHRoZSBjbGlwIVxuICAgICAgIC8vIGlmKGl0ZW0ubW91c2VvdmVyIHx8IGl0ZW0ubW91c2VvdXQgfHwgaXRlbS5idXR0b25Nb2RlKVxuICAgICAgIC8vIHtcbiAgICAgICAgLy8gb2sgc28gdGhlcmUgYXJlIHNvbWUgZnVuY3Rpb25zIHNvIGxldHMgaGl0IHRlc3QgaXQuLlxuICAgICAgICBpdGVtLl9faGl0ID0gdGhpcy5oaXRUZXN0KGl0ZW0sIHRoaXMubW91c2UpO1xuICAgICAgICB0aGlzLm1vdXNlLnRhcmdldCA9IGl0ZW07XG4gICAgICAgIC8vIG9rIHNvIGRlYWwgd2l0aCBpbnRlcmFjdGlvbnMuLlxuICAgICAgICAvLyBsb29rcyBsaWtlIHRoZXJlIHdhcyBhIGhpdCFcbiAgICAgICAgaWYoaXRlbS5fX2hpdCAmJiAhb3ZlcilcbiAgICAgICAge1xuICAgICAgICAgICAgaWYoaXRlbS5idXR0b25Nb2RlKSBjdXJzb3IgPSBpdGVtLmRlZmF1bHRDdXJzb3I7XG5cbiAgICAgICAgICAgIGlmKCFpdGVtLmludGVyYWN0aXZlQ2hpbGRyZW4pb3ZlciA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmKCFpdGVtLl9faXNPdmVyKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmKGl0ZW0ubW91c2VvdmVyKWl0ZW0ubW91c2VvdmVyKHRoaXMubW91c2UpO1xuICAgICAgICAgICAgICAgIGl0ZW0uX19pc092ZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgaWYoaXRlbS5fX2lzT3ZlcilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyByb2xsIG91dCFcbiAgICAgICAgICAgICAgICBpZihpdGVtLm1vdXNlb3V0KWl0ZW0ubW91c2VvdXQodGhpcy5tb3VzZSk7XG4gICAgICAgICAgICAgICAgaXRlbS5fX2lzT3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoIHRoaXMuY3VycmVudEN1cnNvclN0eWxlICE9PSBjdXJzb3IgKVxuICAgIHtcbiAgICAgICAgdGhpcy5jdXJyZW50Q3Vyc29yU3R5bGUgPSBjdXJzb3I7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlLmN1cnNvciA9IGN1cnNvcjtcbiAgICB9XG59O1xuXG5QSVhJLkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVidWlsZEludGVyYWN0aXZlR3JhcGggPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuXG4gICAgdmFyIGxlbiA9IHRoaXMuaW50ZXJhY3RpdmVJdGVtcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuaW50ZXJhY3RpdmVJdGVtc1tpXS5pbnRlcmFjdGl2ZUNoaWxkcmVuID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5pbnRlcmFjdGl2ZUl0ZW1zID0gW107XG5cbiAgICBpZih0aGlzLnN0YWdlLmludGVyYWN0aXZlKXRoaXMuaW50ZXJhY3RpdmVJdGVtcy5wdXNoKHRoaXMuc3RhZ2UpO1xuICAgIC8vIGdvIHRocm91Z2ggYW5kIGNvbGxlY3QgYWxsIHRoZSBvYmplY3RzIHRoYXQgYXJlIGludGVyYWN0aXZlLi5cbiAgICB0aGlzLmNvbGxlY3RJbnRlcmFjdGl2ZVNwcml0ZSh0aGlzLnN0YWdlLCB0aGlzLnN0YWdlKTtcbn07XG5cbi8qKlxuICogSXMgY2FsbGVkIHdoZW4gdGhlIG1vdXNlIG1vdmVzIGFjcm9zcyB0aGUgcmVuZGVyZXIgZWxlbWVudFxuICpcbiAqIEBtZXRob2Qgb25Nb3VzZU1vdmVcbiAqIEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBET00gZXZlbnQgb2YgdGhlIG1vdXNlIG1vdmluZ1xuICogQHByaXZhdGVcbiAqL1xuUElYSS5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uTW91c2VNb3ZlID0gZnVuY3Rpb24oZXZlbnQpXG57XG4gICAgaWYodGhpcy5kaXJ0eSlcbiAgICB7XG4gICAgICAgIHRoaXMucmVidWlsZEludGVyYWN0aXZlR3JhcGgoKTtcbiAgICB9XG5cbiAgICB0aGlzLm1vdXNlLm9yaWdpbmFsRXZlbnQgPSBldmVudCB8fCB3aW5kb3cuZXZlbnQ7IC8vSUUgdXNlcyB3aW5kb3cuZXZlbnRcbiAgICAvLyBUT0RPIG9wdGltaXplIGJ5IG5vdCBjaGVjayBFVkVSWSBUSU1FISBtYXliZSBoYWxmIGFzIG9mdGVuPyAvL1xuICAgIHZhciByZWN0ID0gdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICB0aGlzLm1vdXNlLmdsb2JhbC54ID0gKGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQpICogKHRoaXMudGFyZ2V0LndpZHRoIC8gcmVjdC53aWR0aCk7XG4gICAgdGhpcy5tb3VzZS5nbG9iYWwueSA9IChldmVudC5jbGllbnRZIC0gcmVjdC50b3ApICogKCB0aGlzLnRhcmdldC5oZWlnaHQgLyByZWN0LmhlaWdodCk7XG5cbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5pbnRlcmFjdGl2ZUl0ZW1zLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuaW50ZXJhY3RpdmVJdGVtc1tpXTtcblxuICAgICAgICBpZihpdGVtLm1vdXNlbW92ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy9jYWxsIHRoZSBmdW5jdGlvbiFcbiAgICAgICAgICAgIGl0ZW0ubW91c2Vtb3ZlKHRoaXMubW91c2UpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBJcyBjYWxsZWQgd2hlbiB0aGUgbW91c2UgYnV0dG9uIGlzIHByZXNzZWQgZG93biBvbiB0aGUgcmVuZGVyZXIgZWxlbWVudFxuICpcbiAqIEBtZXRob2Qgb25Nb3VzZURvd25cbiAqIEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBET00gZXZlbnQgb2YgYSBtb3VzZSBidXR0b24gYmVpbmcgcHJlc3NlZCBkb3duXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25Nb3VzZURvd24gPSBmdW5jdGlvbihldmVudClcbntcbiAgICBpZih0aGlzLmRpcnR5KVxuICAgIHtcbiAgICAgICAgdGhpcy5yZWJ1aWxkSW50ZXJhY3RpdmVHcmFwaCgpO1xuICAgIH1cblxuICAgIHRoaXMubW91c2Uub3JpZ2luYWxFdmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDsgLy9JRSB1c2VzIHdpbmRvdy5ldmVudFxuXG4gICAgaWYoUElYSS5BVVRPX1BSRVZFTlRfREVGQVVMVCl0aGlzLm1vdXNlLm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIC8vIGxvb3AgdGhyb3VnaCBpbnRlcmFjdGlvbiB0cmVlLi4uXG4gICAgLy8gaGl0IHRlc3QgZWFjaCBpdGVtISAtPlxuICAgIC8vIGdldCBpbnRlcmFjdGl2ZSBpdGVtcyB1bmRlciBwb2ludD8/XG4gICAgLy9zdGFnZS5fX2lcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5pbnRlcmFjdGl2ZUl0ZW1zLmxlbmd0aDtcblxuICAgIC8vIHdoaWxlXG4gICAgLy8gaGl0IHRlc3RcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmludGVyYWN0aXZlSXRlbXNbaV07XG5cbiAgICAgICAgaWYoaXRlbS5tb3VzZWRvd24gfHwgaXRlbS5jbGljaylcbiAgICAgICAge1xuICAgICAgICAgICAgaXRlbS5fX21vdXNlSXNEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIGl0ZW0uX19oaXQgPSB0aGlzLmhpdFRlc3QoaXRlbSwgdGhpcy5tb3VzZSk7XG5cbiAgICAgICAgICAgIGlmKGl0ZW0uX19oaXQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy9jYWxsIHRoZSBmdW5jdGlvbiFcbiAgICAgICAgICAgICAgICBpZihpdGVtLm1vdXNlZG93bilpdGVtLm1vdXNlZG93bih0aGlzLm1vdXNlKTtcbiAgICAgICAgICAgICAgICBpdGVtLl9faXNEb3duID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIGp1c3QgdGhlIG9uZSFcbiAgICAgICAgICAgICAgICBpZighaXRlbS5pbnRlcmFjdGl2ZUNoaWxkcmVuKWJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBJcyBjYWxsZWQgd2hlbiB0aGUgbW91c2UgYnV0dG9uIGlzIG1vdmVkIG91dCBvZiB0aGUgcmVuZGVyZXIgZWxlbWVudFxuICpcbiAqIEBtZXRob2Qgb25Nb3VzZU91dFxuICogQHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIERPTSBldmVudCBvZiBhIG1vdXNlIGJ1dHRvbiBiZWluZyBtb3ZlZCBvdXRcbiAqIEBwcml2YXRlIFxuICovXG5QSVhJLkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25Nb3VzZU91dCA9IGZ1bmN0aW9uKClcbntcbiAgICBpZih0aGlzLmRpcnR5KVxuICAgIHtcbiAgICAgICAgdGhpcy5yZWJ1aWxkSW50ZXJhY3RpdmVHcmFwaCgpO1xuICAgIH1cblxuICAgIHZhciBsZW5ndGggPSB0aGlzLmludGVyYWN0aXZlSXRlbXMubGVuZ3RoO1xuXG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuc3R5bGUuY3Vyc29yID0gJ2luaGVyaXQnO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5pbnRlcmFjdGl2ZUl0ZW1zW2ldO1xuICAgICAgICBpZihpdGVtLl9faXNPdmVyKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm1vdXNlLnRhcmdldCA9IGl0ZW07XG4gICAgICAgICAgICBpZihpdGVtLm1vdXNlb3V0KWl0ZW0ubW91c2VvdXQodGhpcy5tb3VzZSk7XG4gICAgICAgICAgICBpdGVtLl9faXNPdmVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm1vdXNlT3V0ID0gdHJ1ZTtcblxuICAgIC8vIG1vdmUgdGhlIG1vdXNlIHRvIGFuIGltcG9zc2libGUgcG9zaXRpb25cbiAgICB0aGlzLm1vdXNlLmdsb2JhbC54ID0gLTEwMDAwO1xuICAgIHRoaXMubW91c2UuZ2xvYmFsLnkgPSAtMTAwMDA7XG59O1xuXG4vKipcbiAqIElzIGNhbGxlZCB3aGVuIHRoZSBtb3VzZSBidXR0b24gaXMgcmVsZWFzZWQgb24gdGhlIHJlbmRlcmVyIGVsZW1lbnRcbiAqXG4gKiBAbWV0aG9kIG9uTW91c2VVcFxuICogQHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIERPTSBldmVudCBvZiBhIG1vdXNlIGJ1dHRvbiBiZWluZyByZWxlYXNlZFxuICogQHByaXZhdGVcbiAqL1xuUElYSS5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uTW91c2VVcCA9IGZ1bmN0aW9uKGV2ZW50KVxue1xuICAgIGlmKHRoaXMuZGlydHkpXG4gICAge1xuICAgICAgICB0aGlzLnJlYnVpbGRJbnRlcmFjdGl2ZUdyYXBoKCk7XG4gICAgfVxuXG4gICAgdGhpcy5tb3VzZS5vcmlnaW5hbEV2ZW50ID0gZXZlbnQgfHwgd2luZG93LmV2ZW50OyAvL0lFIHVzZXMgd2luZG93LmV2ZW50XG5cbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5pbnRlcmFjdGl2ZUl0ZW1zLmxlbmd0aDtcbiAgICB2YXIgdXAgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuaW50ZXJhY3RpdmVJdGVtc1tpXTtcblxuICAgICAgICBpdGVtLl9faGl0ID0gdGhpcy5oaXRUZXN0KGl0ZW0sIHRoaXMubW91c2UpO1xuXG4gICAgICAgIGlmKGl0ZW0uX19oaXQgJiYgIXVwKVxuICAgICAgICB7XG4gICAgICAgICAgICAvL2NhbGwgdGhlIGZ1bmN0aW9uIVxuICAgICAgICAgICAgaWYoaXRlbS5tb3VzZXVwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGl0ZW0ubW91c2V1cCh0aGlzLm1vdXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGl0ZW0uX19pc0Rvd24pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYoaXRlbS5jbGljaylpdGVtLmNsaWNrKHRoaXMubW91c2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZighaXRlbS5pbnRlcmFjdGl2ZUNoaWxkcmVuKXVwID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmKGl0ZW0uX19pc0Rvd24pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYoaXRlbS5tb3VzZXVwb3V0c2lkZSlpdGVtLm1vdXNldXBvdXRzaWRlKHRoaXMubW91c2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaXRlbS5fX2lzRG93biA9IGZhbHNlO1xuICAgICAgICAvL31cbiAgICB9XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBjdXJyZW50IG1vdXNlIGNvb3JkaW5hdGVzIGhpdCBhIHNwcml0ZVxuICpcbiAqIEBtZXRob2QgaGl0VGVzdFxuICogQHBhcmFtIGl0ZW0ge0Rpc3BsYXlPYmplY3R9IFRoZSBkaXNwbGF5T2JqZWN0IHRvIHRlc3QgZm9yIGEgaGl0XG4gKiBAcGFyYW0gaW50ZXJhY3Rpb25EYXRhIHtJbnRlcmFjdGlvbkRhdGF9IFRoZSBpbnRlcmFjdGlvbkRhdGEgb2JqZWN0IHRvIHVwZGF0ZSBpbiB0aGUgY2FzZSB0aGVyZSBpcyBhIGhpdFxuICogQHByaXZhdGVcbiAqL1xuUElYSS5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLmhpdFRlc3QgPSBmdW5jdGlvbihpdGVtLCBpbnRlcmFjdGlvbkRhdGEpXG57XG4gICAgdmFyIGdsb2JhbCA9IGludGVyYWN0aW9uRGF0YS5nbG9iYWw7XG5cbiAgICBpZiggIWl0ZW0ud29ybGRWaXNpYmxlIClyZXR1cm4gZmFsc2U7XG5cbiAgICAvLyB0ZW1wIGZpeCBmb3IgaWYgdGhlIGVsZW1lbnQgaXMgaW4gYSBub24gdmlzaWJsZVxuICAgXG4gICAgdmFyIGlzU3ByaXRlID0gKGl0ZW0gaW5zdGFuY2VvZiBQSVhJLlNwcml0ZSksXG4gICAgICAgIHdvcmxkVHJhbnNmb3JtID0gaXRlbS53b3JsZFRyYW5zZm9ybSxcbiAgICAgICAgYTAwID0gd29ybGRUcmFuc2Zvcm0uYSwgYTAxID0gd29ybGRUcmFuc2Zvcm0uYiwgYTAyID0gd29ybGRUcmFuc2Zvcm0udHgsXG4gICAgICAgIGExMCA9IHdvcmxkVHJhbnNmb3JtLmMsIGExMSA9IHdvcmxkVHJhbnNmb3JtLmQsIGExMiA9IHdvcmxkVHJhbnNmb3JtLnR5LFxuICAgICAgICBpZCA9IDEgLyAoYTAwICogYTExICsgYTAxICogLWExMCksXG4gICAgICAgIHggPSBhMTEgKiBpZCAqIGdsb2JhbC54ICsgLWEwMSAqIGlkICogZ2xvYmFsLnkgKyAoYTEyICogYTAxIC0gYTAyICogYTExKSAqIGlkLFxuICAgICAgICB5ID0gYTAwICogaWQgKiBnbG9iYWwueSArIC1hMTAgKiBpZCAqIGdsb2JhbC54ICsgKC1hMTIgKiBhMDAgKyBhMDIgKiBhMTApICogaWQ7XG5cbiAgICBpbnRlcmFjdGlvbkRhdGEudGFyZ2V0ID0gaXRlbTtcblxuICAgIC8vYSBzcHJpdGUgb3IgZGlzcGxheSBvYmplY3Qgd2l0aCBhIGhpdCBhcmVhIGRlZmluZWRcbiAgICBpZihpdGVtLmhpdEFyZWEgJiYgaXRlbS5oaXRBcmVhLmNvbnRhaW5zKSB7XG4gICAgICAgIGlmKGl0ZW0uaGl0QXJlYS5jb250YWlucyh4LCB5KSkge1xuICAgICAgICAgICAgLy9pZihpc1Nwcml0ZSlcbiAgICAgICAgICAgIGludGVyYWN0aW9uRGF0YS50YXJnZXQgPSBpdGVtO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gYSBzcHJpdGUgd2l0aCBubyBoaXRhcmVhIGRlZmluZWRcbiAgICBlbHNlIGlmKGlzU3ByaXRlKVxuICAgIHtcbiAgICAgICAgdmFyIHdpZHRoID0gaXRlbS50ZXh0dXJlLmZyYW1lLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gaXRlbS50ZXh0dXJlLmZyYW1lLmhlaWdodCxcbiAgICAgICAgICAgIHgxID0gLXdpZHRoICogaXRlbS5hbmNob3IueCxcbiAgICAgICAgICAgIHkxO1xuXG4gICAgICAgIGlmKHggPiB4MSAmJiB4IDwgeDEgKyB3aWR0aClcbiAgICAgICAge1xuICAgICAgICAgICAgeTEgPSAtaGVpZ2h0ICogaXRlbS5hbmNob3IueTtcblxuICAgICAgICAgICAgaWYoeSA+IHkxICYmIHkgPCB5MSArIGhlaWdodClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIHRhcmdldCBwcm9wZXJ0eSBpZiBhIGhpdCBpcyB0cnVlIVxuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uRGF0YS50YXJnZXQgPSBpdGVtO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IGl0ZW0uY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciB0ZW1wSXRlbSA9IGl0ZW0uY2hpbGRyZW5baV07XG4gICAgICAgIHZhciBoaXQgPSB0aGlzLmhpdFRlc3QodGVtcEl0ZW0sIGludGVyYWN0aW9uRGF0YSk7XG4gICAgICAgIGlmKGhpdClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gaG1tLi4gVE9ETyBTRVQgQ09SUkVDVCBUQVJHRVQ/XG4gICAgICAgICAgICBpbnRlcmFjdGlvbkRhdGEudGFyZ2V0ID0gaXRlbTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBJcyBjYWxsZWQgd2hlbiBhIHRvdWNoIGlzIG1vdmVkIGFjcm9zcyB0aGUgcmVuZGVyZXIgZWxlbWVudFxuICpcbiAqIEBtZXRob2Qgb25Ub3VjaE1vdmVcbiAqIEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBET00gZXZlbnQgb2YgYSB0b3VjaCBtb3ZpbmcgYWNyb3NzIHRoZSByZW5kZXJlciB2aWV3XG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25Ub3VjaE1vdmUgPSBmdW5jdGlvbihldmVudClcbntcbiAgICBpZih0aGlzLmRpcnR5KVxuICAgIHtcbiAgICAgICAgdGhpcy5yZWJ1aWxkSW50ZXJhY3RpdmVHcmFwaCgpO1xuICAgIH1cblxuICAgIHZhciByZWN0ID0gdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIGNoYW5nZWRUb3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG4gICAgdmFyIHRvdWNoRGF0YTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgdG91Y2hFdmVudCA9IGNoYW5nZWRUb3VjaGVzW2ldO1xuICAgICAgICB0b3VjaERhdGEgPSB0aGlzLnRvdWNoc1t0b3VjaEV2ZW50LmlkZW50aWZpZXJdO1xuICAgICAgICB0b3VjaERhdGEub3JpZ2luYWxFdmVudCA9ICBldmVudCB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB0b3VjaCBwb3NpdGlvblxuICAgICAgICB0b3VjaERhdGEuZ2xvYmFsLnggPSAodG91Y2hFdmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0KSAqICh0aGlzLnRhcmdldC53aWR0aCAvIHJlY3Qud2lkdGgpO1xuICAgICAgICB0b3VjaERhdGEuZ2xvYmFsLnkgPSAodG91Y2hFdmVudC5jbGllbnRZIC0gcmVjdC50b3ApICAqICh0aGlzLnRhcmdldC5oZWlnaHQgLyByZWN0LmhlaWdodCk7XG4gICAgICAgIGlmKG5hdmlnYXRvci5pc0NvY29vbkpTKSB7XG4gICAgICAgICAgICB0b3VjaERhdGEuZ2xvYmFsLnggPSB0b3VjaEV2ZW50LmNsaWVudFg7XG4gICAgICAgICAgICB0b3VjaERhdGEuZ2xvYmFsLnkgPSB0b3VjaEV2ZW50LmNsaWVudFk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuaW50ZXJhY3RpdmVJdGVtcy5sZW5ndGg7IGorKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmludGVyYWN0aXZlSXRlbXNbal07XG4gICAgICAgICAgICBpZihpdGVtLnRvdWNobW92ZSAmJiBpdGVtLl9fdG91Y2hEYXRhICYmIGl0ZW0uX190b3VjaERhdGFbdG91Y2hFdmVudC5pZGVudGlmaWVyXSkgaXRlbS50b3VjaG1vdmUodG91Y2hEYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogSXMgY2FsbGVkIHdoZW4gYSB0b3VjaCBpcyBzdGFydGVkIG9uIHRoZSByZW5kZXJlciBlbGVtZW50XG4gKlxuICogQG1ldGhvZCBvblRvdWNoU3RhcnRcbiAqIEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBET00gZXZlbnQgb2YgYSB0b3VjaCBzdGFydGluZyBvbiB0aGUgcmVuZGVyZXIgdmlld1xuICogQHByaXZhdGVcbiAqL1xuUElYSS5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uVG91Y2hTdGFydCA9IGZ1bmN0aW9uKGV2ZW50KVxue1xuICAgIGlmKHRoaXMuZGlydHkpXG4gICAge1xuICAgICAgICB0aGlzLnJlYnVpbGRJbnRlcmFjdGl2ZUdyYXBoKCk7XG4gICAgfVxuXG4gICAgdmFyIHJlY3QgPSB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIGlmKFBJWEkuQVVUT19QUkVWRU5UX0RFRkFVTFQpZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBcbiAgICB2YXIgY2hhbmdlZFRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcztcbiAgICBmb3IgKHZhciBpPTA7IGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciB0b3VjaEV2ZW50ID0gY2hhbmdlZFRvdWNoZXNbaV07XG5cbiAgICAgICAgdmFyIHRvdWNoRGF0YSA9IHRoaXMucG9vbC5wb3AoKTtcbiAgICAgICAgaWYoIXRvdWNoRGF0YSl0b3VjaERhdGEgPSBuZXcgUElYSS5JbnRlcmFjdGlvbkRhdGEoKTtcblxuICAgICAgICB0b3VjaERhdGEub3JpZ2luYWxFdmVudCA9ICBldmVudCB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgICAgICAgdGhpcy50b3VjaHNbdG91Y2hFdmVudC5pZGVudGlmaWVyXSA9IHRvdWNoRGF0YTtcbiAgICAgICAgdG91Y2hEYXRhLmdsb2JhbC54ID0gKHRvdWNoRXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCkgKiAodGhpcy50YXJnZXQud2lkdGggLyByZWN0LndpZHRoKTtcbiAgICAgICAgdG91Y2hEYXRhLmdsb2JhbC55ID0gKHRvdWNoRXZlbnQuY2xpZW50WSAtIHJlY3QudG9wKSAgKiAodGhpcy50YXJnZXQuaGVpZ2h0IC8gcmVjdC5oZWlnaHQpO1xuICAgICAgICBpZihuYXZpZ2F0b3IuaXNDb2Nvb25KUykge1xuICAgICAgICAgICAgdG91Y2hEYXRhLmdsb2JhbC54ID0gdG91Y2hFdmVudC5jbGllbnRYO1xuICAgICAgICAgICAgdG91Y2hEYXRhLmdsb2JhbC55ID0gdG91Y2hFdmVudC5jbGllbnRZO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuaW50ZXJhY3RpdmVJdGVtcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGorKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmludGVyYWN0aXZlSXRlbXNbal07XG5cbiAgICAgICAgICAgIGlmKGl0ZW0udG91Y2hzdGFydCB8fCBpdGVtLnRhcClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpdGVtLl9faGl0ID0gdGhpcy5oaXRUZXN0KGl0ZW0sIHRvdWNoRGF0YSk7XG5cbiAgICAgICAgICAgICAgICBpZihpdGVtLl9faGl0KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jYWxsIHRoZSBmdW5jdGlvbiFcbiAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS50b3VjaHN0YXJ0KWl0ZW0udG91Y2hzdGFydCh0b3VjaERhdGEpO1xuICAgICAgICAgICAgICAgICAgICBpdGVtLl9faXNEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5fX3RvdWNoRGF0YSA9IGl0ZW0uX190b3VjaERhdGEgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uX190b3VjaERhdGFbdG91Y2hFdmVudC5pZGVudGlmaWVyXSA9IHRvdWNoRGF0YTtcblxuICAgICAgICAgICAgICAgICAgICBpZighaXRlbS5pbnRlcmFjdGl2ZUNoaWxkcmVuKWJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogSXMgY2FsbGVkIHdoZW4gYSB0b3VjaCBpcyBlbmRlZCBvbiB0aGUgcmVuZGVyZXIgZWxlbWVudFxuICpcbiAqIEBtZXRob2Qgb25Ub3VjaEVuZFxuICogQHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIERPTSBldmVudCBvZiBhIHRvdWNoIGVuZGluZyBvbiB0aGUgcmVuZGVyZXIgdmlld1xuICogQHByaXZhdGVcbiAqL1xuUElYSS5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uVG91Y2hFbmQgPSBmdW5jdGlvbihldmVudClcbntcbiAgICBpZih0aGlzLmRpcnR5KVxuICAgIHtcbiAgICAgICAgdGhpcy5yZWJ1aWxkSW50ZXJhY3RpdmVHcmFwaCgpO1xuICAgIH1cbiAgICBcbiAgICAvL3RoaXMubW91c2Uub3JpZ2luYWxFdmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDsgLy9JRSB1c2VzIHdpbmRvdy5ldmVudFxuICAgIHZhciByZWN0ID0gdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIGNoYW5nZWRUb3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG5cbiAgICBmb3IgKHZhciBpPTA7IGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciB0b3VjaEV2ZW50ID0gY2hhbmdlZFRvdWNoZXNbaV07XG4gICAgICAgIHZhciB0b3VjaERhdGEgPSB0aGlzLnRvdWNoc1t0b3VjaEV2ZW50LmlkZW50aWZpZXJdO1xuICAgICAgICB2YXIgdXAgPSBmYWxzZTtcbiAgICAgICAgdG91Y2hEYXRhLmdsb2JhbC54ID0gKHRvdWNoRXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCkgKiAodGhpcy50YXJnZXQud2lkdGggLyByZWN0LndpZHRoKTtcbiAgICAgICAgdG91Y2hEYXRhLmdsb2JhbC55ID0gKHRvdWNoRXZlbnQuY2xpZW50WSAtIHJlY3QudG9wKSAgKiAodGhpcy50YXJnZXQuaGVpZ2h0IC8gcmVjdC5oZWlnaHQpO1xuICAgICAgICBpZihuYXZpZ2F0b3IuaXNDb2Nvb25KUykge1xuICAgICAgICAgICAgdG91Y2hEYXRhLmdsb2JhbC54ID0gdG91Y2hFdmVudC5jbGllbnRYO1xuICAgICAgICAgICAgdG91Y2hEYXRhLmdsb2JhbC55ID0gdG91Y2hFdmVudC5jbGllbnRZO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuaW50ZXJhY3RpdmVJdGVtcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5pbnRlcmFjdGl2ZUl0ZW1zW2pdO1xuXG4gICAgICAgICAgICBpZihpdGVtLl9fdG91Y2hEYXRhICYmIGl0ZW0uX190b3VjaERhdGFbdG91Y2hFdmVudC5pZGVudGlmaWVyXSkge1xuXG4gICAgICAgICAgICAgICAgaXRlbS5fX2hpdCA9IHRoaXMuaGl0VGVzdChpdGVtLCBpdGVtLl9fdG91Y2hEYXRhW3RvdWNoRXZlbnQuaWRlbnRpZmllcl0pO1xuXG4gICAgICAgICAgICAgICAgLy8gc28gdGhpcyBvbmUgV0FTIGRvd24uLi5cbiAgICAgICAgICAgICAgICB0b3VjaERhdGEub3JpZ2luYWxFdmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcbiAgICAgICAgICAgICAgICAvLyBoaXRUZXN0Pz9cblxuICAgICAgICAgICAgICAgIGlmKGl0ZW0udG91Y2hlbmQgfHwgaXRlbS50YXApXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZihpdGVtLl9faGl0ICYmICF1cClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS50b3VjaGVuZClpdGVtLnRvdWNoZW5kKHRvdWNoRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihpdGVtLl9faXNEb3duKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0udGFwKWl0ZW0udGFwKHRvdWNoRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFpdGVtLmludGVyYWN0aXZlQ2hpbGRyZW4pdXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS5fX2lzRG93bilcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpdGVtLnRvdWNoZW5kb3V0c2lkZSlpdGVtLnRvdWNoZW5kb3V0c2lkZSh0b3VjaERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaXRlbS5fX2lzRG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW0uX190b3VjaERhdGFbdG91Y2hFdmVudC5pZGVudGlmaWVyXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIHRoZSB0b3VjaC4uXG4gICAgICAgIHRoaXMucG9vbC5wdXNoKHRvdWNoRGF0YSk7XG4gICAgICAgIHRoaXMudG91Y2hzW3RvdWNoRXZlbnQuaWRlbnRpZmllcl0gPSBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKiBBIFN0YWdlIHJlcHJlc2VudHMgdGhlIHJvb3Qgb2YgdGhlIGRpc3BsYXkgdHJlZS4gRXZlcnl0aGluZyBjb25uZWN0ZWQgdG8gdGhlIHN0YWdlIGlzIHJlbmRlcmVkXG4gKlxuICogQGNsYXNzIFN0YWdlXG4gKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0Q29udGFpbmVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSBiYWNrZ3JvdW5kQ29sb3Ige051bWJlcn0gdGhlIGJhY2tncm91bmQgY29sb3Igb2YgdGhlIHN0YWdlLCB5b3UgaGF2ZSB0byBwYXNzIHRoaXMgaW4gaXMgaW4gaGV4IGZvcm1hdFxuICogICAgICBsaWtlOiAweEZGRkZGRiBmb3Igd2hpdGVcbiAqIFxuICogQ3JlYXRpbmcgYSBzdGFnZSBpcyBhIG1hbmRhdG9yeSBwcm9jZXNzIHdoZW4geW91IHVzZSBQaXhpLCB3aGljaCBpcyBhcyBzaW1wbGUgYXMgdGhpcyA6IFxuICogdmFyIHN0YWdlID0gbmV3IFBJWEkuU3RhZ2UoMHhGRkZGRkYpO1xuICogd2hlcmUgdGhlIHBhcmFtZXRlciBnaXZlbiBpcyB0aGUgYmFja2dyb3VuZCBjb2xvdXIgb2YgdGhlIHN0YWdlLCBpbiBoZXhcbiAqIHlvdSB3aWxsIHVzZSB0aGlzIHN0YWdlIGluc3RhbmNlIHRvIGFkZCB5b3VyIHNwcml0ZXMgdG8gaXQgYW5kIHRoZXJlZm9yZSB0byB0aGUgcmVuZGVyZXJcbiAqIEhlcmUgaXMgaG93IHRvIGFkZCBhIHNwcml0ZSB0byB0aGUgc3RhZ2UgOiBcbiAqIHN0YWdlLmFkZENoaWxkKHNwcml0ZSk7XG4gKi9cblBJWEkuU3RhZ2UgPSBmdW5jdGlvbihiYWNrZ3JvdW5kQ29sb3IpXG57XG4gICAgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLmNhbGwoIHRoaXMgKTtcblxuICAgIC8qKlxuICAgICAqIFtyZWFkLW9ubHldIEN1cnJlbnQgdHJhbnNmb3JtIG9mIHRoZSBvYmplY3QgYmFzZWQgb24gd29ybGQgKHBhcmVudCkgZmFjdG9yc1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IHdvcmxkVHJhbnNmb3JtXG4gICAgICogQHR5cGUgTWF0M1xuICAgICAqIEByZWFkT25seVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy53b3JsZFRyYW5zZm9ybSA9IG5ldyBQSVhJLk1hdHJpeCgpO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdGhlIHN0YWdlIGlzIGludGVyYWN0aXZlXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgaW50ZXJhY3RpdmVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5pbnRlcmFjdGl2ZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZXJhY3Rpb24gbWFuYWdlIGZvciB0aGlzIHN0YWdlLCBtYW5hZ2VzIGFsbCBpbnRlcmFjdGl2ZSBhY3Rpdml0eSBvbiB0aGUgc3RhZ2VcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBpbnRlcmFjdGlvbk1hbmFnZXJcbiAgICAgKiBAdHlwZSBJbnRlcmFjdGlvbk1hbmFnZXJcbiAgICAgKi9cbiAgICB0aGlzLmludGVyYWN0aW9uTWFuYWdlciA9IG5ldyBQSVhJLkludGVyYWN0aW9uTWFuYWdlcih0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHN0YWdlIGlzIGRpcnR5IGFuZCBuZWVkcyB0byBoYXZlIGludGVyYWN0aW9ucyB1cGRhdGVkXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZGlydHlcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIC8vdGhlIHN0YWdlIGlzIGl0cyBvd24gc3RhZ2VcbiAgICB0aGlzLnN0YWdlID0gdGhpcztcblxuICAgIC8vb3B0aW1pemUgaGl0IGRldGVjdGlvbiBhIGJpdFxuICAgIHRoaXMuc3RhZ2UuaGl0QXJlYSA9IG5ldyBQSVhJLlJlY3RhbmdsZSgwLDAsMTAwMDAwLCAxMDAwMDApO1xuXG4gICAgdGhpcy5zZXRCYWNrZ3JvdW5kQ29sb3IoYmFja2dyb3VuZENvbG9yKTtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLlN0YWdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUgKTtcblBJWEkuU3RhZ2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5TdGFnZTtcblxuLyoqXG4gKiBTZXRzIGFub3RoZXIgRE9NIGVsZW1lbnQgd2hpY2ggY2FuIHJlY2VpdmUgbW91c2UvdG91Y2ggaW50ZXJhY3Rpb25zIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgQ2FudmFzIGVsZW1lbnQuXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3Igd2hlbiB5b3UgaGF2ZSBvdGhlciBET00gZWxlbWVudHMgb24gdG9wIG9mIHRoZSBDYW52YXMgZWxlbWVudC5cbiAqXG4gKiBAbWV0aG9kIHNldEludGVyYWN0aW9uRGVsZWdhdGVcbiAqIEBwYXJhbSBkb21FbGVtZW50IHtET01FbGVtZW50fSBUaGlzIG5ldyBkb21FbGVtZW50IHdoaWNoIHdpbGwgcmVjZWl2ZSBtb3VzZS90b3VjaCBldmVudHNcbiAqL1xuUElYSS5TdGFnZS5wcm90b3R5cGUuc2V0SW50ZXJhY3Rpb25EZWxlZ2F0ZSA9IGZ1bmN0aW9uKGRvbUVsZW1lbnQpXG57XG4gICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIuc2V0VGFyZ2V0RG9tRWxlbWVudCggZG9tRWxlbWVudCApO1xufTtcblxuLypcbiAqIFVwZGF0ZXMgdGhlIG9iamVjdCB0cmFuc2Zvcm0gZm9yIHJlbmRlcmluZ1xuICpcbiAqIEBtZXRob2QgdXBkYXRlVHJhbnNmb3JtXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlN0YWdlLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy53b3JsZEFscGhhID0gMTtcblxuICAgIGZvcih2YXIgaT0wLGo9dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGk8ajsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICB9XG5cbiAgICBpZih0aGlzLmRpcnR5KVxuICAgIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAvLyB1cGRhdGUgaW50ZXJhY3RpdmUhXG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZih0aGlzLmludGVyYWN0aXZlKXRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyLnVwZGF0ZSgpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGZvciB0aGUgc3RhZ2VcbiAqXG4gKiBAbWV0aG9kIHNldEJhY2tncm91bmRDb2xvclxuICogQHBhcmFtIGJhY2tncm91bmRDb2xvciB7TnVtYmVyfSB0aGUgY29sb3Igb2YgdGhlIGJhY2tncm91bmQsIGVhc2llc3Qgd2F5IHRvIHBhc3MgdGhpcyBpbiBpcyBpbiBoZXggZm9ybWF0XG4gKiAgICAgIGxpa2U6IDB4RkZGRkZGIGZvciB3aGl0ZVxuICovXG5QSVhJLlN0YWdlLnByb3RvdHlwZS5zZXRCYWNrZ3JvdW5kQ29sb3IgPSBmdW5jdGlvbihiYWNrZ3JvdW5kQ29sb3IpXG57XG4gICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBiYWNrZ3JvdW5kQ29sb3IgfHwgMHgwMDAwMDA7XG4gICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3JTcGxpdCA9IFBJWEkuaGV4MnJnYih0aGlzLmJhY2tncm91bmRDb2xvcik7XG4gICAgdmFyIGhleCA9IHRoaXMuYmFja2dyb3VuZENvbG9yLnRvU3RyaW5nKDE2KTtcbiAgICBoZXggPSAnMDAwMDAwJy5zdWJzdHIoMCwgNiAtIGhleC5sZW5ndGgpICsgaGV4O1xuICAgIHRoaXMuYmFja2dyb3VuZENvbG9yU3RyaW5nID0gJyMnICsgaGV4O1xufTtcblxuLyoqXG4gKiBUaGlzIHdpbGwgcmV0dXJuIHRoZSBwb2ludCBjb250YWluaW5nIGdsb2JhbCBjb29yZHMgb2YgdGhlIG1vdXNlLlxuICpcbiAqIEBtZXRob2QgZ2V0TW91c2VQb3NpdGlvblxuICogQHJldHVybiB7UG9pbnR9IFRoZSBwb2ludCBjb250YWluaW5nIHRoZSBjb29yZHMgb2YgdGhlIGdsb2JhbCBJbnRlcmFjdGlvbkRhdGEgcG9zaXRpb24uXG4gKi9cblBJWEkuU3RhZ2UucHJvdG90eXBlLmdldE1vdXNlUG9zaXRpb24gPSBmdW5jdGlvbigpXG57XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyLm1vdXNlLmdsb2JhbDtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cbiBcbi8vIGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXG4vLyBodHRwOi8vbXkub3BlcmEuY29tL2Vtb2xsZXIvYmxvZy8yMDExLzEyLzIwL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtZXItYW5pbWF0aW5nXG5cbi8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbCBieSBFcmlrIE3DtmxsZXIuIGZpeGVzIGZyb20gUGF1bCBJcmlzaCBhbmQgVGlubyBaaWpkZWxcblxuLy8gTUlUIGxpY2Vuc2VcblxuLyoqXG4gKiBBIHBvbHlmaWxsIGZvciByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAqIFlvdSBjYW4gYWN0dWFsbHkgdXNlIGJvdGggcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGFuZCByZXF1ZXN0QW5pbUZyYW1lLCBcbiAqIHlvdSB3aWxsIHN0aWxsIGJlbmVmaXQgZnJvbSB0aGUgcG9seWZpbGxcbiAqXG4gKiBAbWV0aG9kIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICovXG4vKipcbiAqIEEgcG9seWZpbGwgZm9yIGNhbmNlbEFuaW1hdGlvbkZyYW1lXG4gKlxuICogQG1ldGhvZCBjYW5jZWxBbmltYXRpb25GcmFtZVxuICovXG52YXIgbGFzdFRpbWUgPSAwO1xudmFyIHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddO1xuZm9yKHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbeF0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fFxuICAgICAgICB3aW5kb3dbdmVuZG9yc1t4XSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbn1cblxuaWYgKCF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcbiAgICAgICAgdmFyIGlkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7IH0sXG4gICAgICAgICAgdGltZVRvQ2FsbCk7XG4gICAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfTtcbn1cblxuaWYgKCF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgIH07XG59XG5cbndpbmRvdy5yZXF1ZXN0QW5pbUZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGhleCBjb2xvciBudW1iZXIgdG8gYW4gW1IsIEcsIEJdIGFycmF5XG4gKlxuICogQG1ldGhvZCBoZXgycmdiXG4gKiBAcGFyYW0gaGV4IHtOdW1iZXJ9XG4gKi9cblBJWEkuaGV4MnJnYiA9IGZ1bmN0aW9uKGhleCkge1xuICAgIHJldHVybiBbKGhleCA+PiAxNiAmIDB4RkYpIC8gMjU1LCAoIGhleCA+PiA4ICYgMHhGRikgLyAyNTUsIChoZXggJiAweEZGKS8gMjU1XTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBjb2xvciBhcyBhbiBbUiwgRywgQl0gYXJyYXkgdG8gYSBoZXggbnVtYmVyXG4gKlxuICogQG1ldGhvZCByZ2IyaGV4XG4gKiBAcGFyYW0gcmdiIHtBcnJheX1cbiAqL1xuUElYSS5yZ2IyaGV4ID0gZnVuY3Rpb24ocmdiKSB7XG4gICAgcmV0dXJuICgocmdiWzBdKjI1NSA8PCAxNikgKyAocmdiWzFdKjI1NSA8PCA4KSArIHJnYlsyXSoyNTUpO1xufTtcblxuLyoqXG4gKiBBIHBvbHlmaWxsIGZvciBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICpcbiAqIEBtZXRob2QgYmluZFxuICovXG5pZiAodHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGhpc0FyZykge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMsIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBib3VuZEFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFwcGx5KHRoaXMgaW5zdGFuY2VvZiBib3VuZCA/IHRoaXMgOiB0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYm91bmQucHJvdG90eXBlID0gKGZ1bmN0aW9uIEYocHJvdG8pIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvdG8pIEYucHJvdG90eXBlID0gcHJvdG87XG4gICAgICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEYpKSByZXR1cm4gbmV3IEYoKTtcbiAgICAgICAgICAgIH0pKHRhcmdldC5wcm90b3R5cGUpO1xuXG4gICAgICAgICAgICByZXR1cm4gYm91bmQ7XG4gICAgICAgIH07XG4gICAgfSkoKTtcbn1cblxuLyoqXG4gKiBBIHdyYXBwZXIgZm9yIGFqYXggcmVxdWVzdHMgdG8gYmUgaGFuZGxlZCBjcm9zcyBicm93c2VyXG4gKlxuICogQGNsYXNzIEFqYXhSZXF1ZXN0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuUElYSS5BamF4UmVxdWVzdCA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgYWN0aXZleG1vZGVzID0gWydNc3htbDIuWE1MSFRUUC42LjAnLCAnTXN4bWwyLlhNTEhUVFAuMy4wJywgJ01pY3Jvc29mdC5YTUxIVFRQJ107IC8vYWN0aXZlWCB2ZXJzaW9ucyB0byBjaGVjayBmb3IgaW4gSUVcblxuICAgIGlmICh3aW5kb3cuQWN0aXZlWE9iamVjdClcbiAgICB7IC8vVGVzdCBmb3Igc3VwcG9ydCBmb3IgQWN0aXZlWE9iamVjdCBpbiBJRSBmaXJzdCAoYXMgWE1MSHR0cFJlcXVlc3QgaW4gSUU3IGlzIGJyb2tlbilcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPGFjdGl2ZXhtb2Rlcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LkFjdGl2ZVhPYmplY3QoYWN0aXZleG1vZGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAvL3N1cHByZXNzIGVycm9yXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KSAvLyBpZiBNb3ppbGxhLCBTYWZhcmkgZXRjXG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbi8qXG5QSVhJLnBhY2tDb2xvclJHQkEgPSBmdW5jdGlvbihyLCBnLCBiLCBhKS8vciwgZywgYiwgYSlcbntcbiAgLy8gIGNvbnNvbGUubG9nKHIsIGIsIGMsIGQpXG4gIHJldHVybiAoTWF0aC5mbG9vcigocikqNjMpIDw8IDE4KSB8IChNYXRoLmZsb29yKChnKSo2MykgPDwgMTIpIHwgKE1hdGguZmxvb3IoKGIpKjYzKSA8PCA2KTsvLyB8IChNYXRoLmZsb29yKChhKSo2MykpXG4gIC8vICBpID0gaSB8IChNYXRoLmZsb29yKChhKSo2MykpO1xuICAgLy8gcmV0dXJuIGk7XG4gICAvLyB2YXIgciA9IChpIC8gMjYyMTQ0LjAgKSAvIDY0O1xuICAgLy8gdmFyIGcgPSAoaSAvIDQwOTYuMCklNjQgLyA2NDtcbiAgLy8gIHZhciBiID0gKGkgLyA2NC4wKSU2NCAvIDY0O1xuICAvLyAgdmFyIGEgPSAoaSklNjQgLyA2NDtcbiAgICAgXG4gIC8vICBjb25zb2xlLmxvZyhyLCBnLCBiLCBhKTtcbiAgLy8gIHJldHVybiBpO1xuXG59O1xuKi9cbi8qXG5QSVhJLnBhY2tDb2xvclJHQiA9IGZ1bmN0aW9uKHIsIGcsIGIpLy9yLCBnLCBiLCBhKVxue1xuICAgIHJldHVybiAoTWF0aC5mbG9vcigocikqMjU1KSA8PCAxNikgfCAoTWF0aC5mbG9vcigoZykqMjU1KSA8PCA4KSB8IChNYXRoLmZsb29yKChiKSoyNTUpKTtcbn07XG5cblBJWEkudW5wYWNrQ29sb3JSR0IgPSBmdW5jdGlvbihyLCBnLCBiKS8vciwgZywgYiwgYSlcbntcbiAgICByZXR1cm4gKE1hdGguZmxvb3IoKHIpKjI1NSkgPDwgMTYpIHwgKE1hdGguZmxvb3IoKGcpKjI1NSkgPDwgOCkgfCAoTWF0aC5mbG9vcigoYikqMjU1KSk7XG59O1xuKi9cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgQ2FudmFzIEJsZW5kTW9kZXMgYXJlIHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCBicm93c2VyXG4gKlxuICogQG1ldGhvZCBjYW5Vc2VOZXdDYW52YXNCbGVuZE1vZGVzXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIHRoZXkgYXJlIHN1cHBvcnRlZFxuICovXG5QSVhJLmNhblVzZU5ld0NhbnZhc0JsZW5kTW9kZXMgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy53aWR0aCA9IDE7XG4gICAgY2FudmFzLmhlaWdodCA9IDE7XG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjMDAwJztcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsMCwxLDEpO1xuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ211bHRpcGx5JztcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjZmZmJztcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsMCwxLDEpO1xuICAgIHJldHVybiBjb250ZXh0LmdldEltYWdlRGF0YSgwLDAsMSwxKS5kYXRhWzBdID09PSAwO1xufTtcblxuLyoqXG4gKiBHaXZlbiBhIG51bWJlciwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBjbG9zZXN0IG51bWJlciB0aGF0IGlzIGEgcG93ZXIgb2YgdHdvXG4gKiB0aGlzIGZ1bmN0aW9uIGlzIHRha2VuIGZyb20gU3RhcmxpbmcgRnJhbWV3b3JrIGFzIGl0cyBwcmV0dHkgbmVhdCA7KVxuICpcbiAqIEBtZXRob2QgZ2V0TmV4dFBvd2VyT2ZUd29cbiAqIEBwYXJhbSBudW1iZXIge051bWJlcn1cbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIGNsb3Nlc3QgbnVtYmVyIHRoYXQgaXMgYSBwb3dlciBvZiB0d29cbiAqL1xuUElYSS5nZXROZXh0UG93ZXJPZlR3byA9IGZ1bmN0aW9uKG51bWJlcilcbntcbiAgICBpZiAobnVtYmVyID4gMCAmJiAobnVtYmVyICYgKG51bWJlciAtIDEpKSA9PT0gMCkgLy8gc2VlOiBodHRwOi8vZ29vLmdsL0Q5a1BqXG4gICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IDE7XG4gICAgICAgIHdoaWxlIChyZXN1bHQgPCBudW1iZXIpIHJlc3VsdCA8PD0gMTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG4gXG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvZXZlbnR0YXJnZXQuanMvXG4gKiBUSGFua1MgbXIgRE9vYiFcbiAqL1xuXG4vKipcbiAqIEFkZHMgZXZlbnQgZW1pdHRlciBmdW5jdGlvbmFsaXR5IHRvIGEgY2xhc3NcbiAqXG4gKiBAY2xhc3MgRXZlbnRUYXJnZXRcbiAqIEBleGFtcGxlXG4gKiAgICAgIGZ1bmN0aW9uIE15RW1pdHRlcigpIHtcbiAqICAgICAgICAgIFBJWEkuRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTsgLy9taXhlcyBpbiBldmVudCB0YXJnZXQgc3R1ZmZcbiAqICAgICAgfVxuICpcbiAqICAgICAgdmFyIGVtID0gbmV3IE15RW1pdHRlcigpO1xuICogICAgICBlbS5lbWl0KHsgdHlwZTogJ2V2ZW50TmFtZScsIGRhdGE6ICdzb21lIGRhdGEnIH0pO1xuICovXG5QSVhJLkV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqXG4gICAgICogSG9sZHMgYWxsIHRoZSBsaXN0ZW5lcnNcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBsaXN0ZW5lcnNcbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICB2YXIgbGlzdGVuZXJzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgZm9yIGEgc3BlY2lmaWMgZXZlbnRcbiAgICAgKlxuICAgICAqIEBtZXRob2QgYWRkRXZlbnRMaXN0ZW5lclxuICAgICAqIEBwYXJhbSB0eXBlIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byBsaXN0ZW4gZm9yLlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciB7ZnVuY3Rpb259IFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiB0aGUgZXZlbnQgb2NjdXJzXG4gICAgICovXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyID0gdGhpcy5vbiA9IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblxuICAgICAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIGxpc3RlbmVyc1sgdHlwZSBdID0gW107XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSA9PT0gLSAxICkge1xuXG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXS51bnNoaWZ0KCBsaXN0ZW5lciApO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmlyZXMgdGhlIGV2ZW50LCBpZSBwcmV0ZW5kcyB0aGF0IHRoZSBldmVudCBoYXMgaGFwcGVuZWRcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGlzcGF0Y2hFdmVudFxuICAgICAqIEBwYXJhbSBldmVudCB7RXZlbnR9IHRoZSBldmVudCBvYmplY3RcbiAgICAgKi9cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQgPSB0aGlzLmVtaXQgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG4gICAgICAgIGlmICggIWxpc3RlbmVyc1sgZXZlbnQudHlwZSBdIHx8ICFsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXS5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG5cblxuICAgICAgICBmb3IodmFyIGkgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXS5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbi8vICAgICAgICBmb3IodmFyIGkgPSAwLCBsPWxpc3RlbmVyc1sgZXZlbnQudHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXG5cbiAgICAgICAgICAgIGxpc3RlbmVyc1sgZXZlbnQudHlwZSBdWyBpIF0oIGV2ZW50ICk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBsaXN0ZW5lciB0aGF0IHdhcyBhc3NpZ25lZCB0byB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICAgICAqIEBwYXJhbSB0eXBlIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB3aGljaCB3aWxsIGhhdmUgaXRzIGxpc3RlbmVyIHJlbW92ZWRcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIge2Z1bmN0aW9ufSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3YXMgYmUgZmlyZWQgd2hlbiB0aGUgZXZlbnQgb2NjdXJlZFxuICAgICAqL1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHRoaXMub2ZmID0gZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuICAgICAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGluZGV4ID0gbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKTtcblxuICAgICAgICBpZiAoIGluZGV4ICE9PSAtIDEgKSB7XG5cbiAgICAgICAgICAgIGxpc3RlbmVyc1sgdHlwZSBdLnNwbGljZSggaW5kZXgsIDEgKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdGhlIGxpc3RlbmVycyB0aGF0IHdlcmUgYWN0aXZlIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnNcbiAgICAgKiBAcGFyYW0gdHlwZSB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgd2hpY2ggd2lsbCBoYXZlIGFsbCBpdHMgbGlzdGVuZXJzIHJlbW92ZWRcbiAgICAgKi9cblx0dGhpcy5yZW1vdmVBbGxFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHZhciBhID0gbGlzdGVuZXJzW3R5cGVdO1xuXHRcdGlmIChhKVxuXHRcdFx0YS5sZW5ndGggPSAwO1xuXHR9O1xufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqIFRoaXMgaGVscGVyIGZ1bmN0aW9uIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3Qgd2hpY2ggcmVuZGVyZXIgeW91IHNob3VsZCBiZSB1c2luZy5cbiAqIFdlYkdMIGlzIHRoZSBwcmVmZXJyZWQgcmVuZGVyZXIgYXMgaXQgaXMgYSBsb3QgZmFzdGVyLiBJZiB3ZWJHTCBpcyBub3Qgc3VwcG9ydGVkIGJ5XG4gKiB0aGUgYnJvd3NlciB0aGVuIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gYSBjYW52YXMgcmVuZGVyZXJcbiAqIEBjbGFzcyBhdXRvRGV0ZWN0UmVuZGVyZXJcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB3aWR0aD04MDAge051bWJlcn0gdGhlIHdpZHRoIG9mIHRoZSByZW5kZXJlcnMgdmlld1xuICogQHBhcmFtIGhlaWdodD02MDAge051bWJlcn0gdGhlIGhlaWdodCBvZiB0aGUgcmVuZGVyZXJzIHZpZXdcbiAqIEBwYXJhbSBbdmlld10ge0NhbnZhc30gdGhlIGNhbnZhcyB0byB1c2UgYXMgYSB2aWV3LCBvcHRpb25hbCBcbiAqIEBwYXJhbSBbdHJhbnNwYXJlbnQ9ZmFsc2VdIHtCb29sZWFufSB0aGUgdHJhbnNwYXJlbmN5IG9mIHRoZSByZW5kZXIgdmlldywgZGVmYXVsdCBmYWxzZVxuICogQHBhcmFtIFthbnRpYWxpYXM9ZmFsc2VdIHtCb29sZWFufSBzZXRzIGFudGlhbGlhcyAob25seSBhcHBsaWNhYmxlIGluIHdlYkdMIGNocm9tZSBhdCB0aGUgbW9tZW50KVxuICpcbiAqL1xuUElYSS5hdXRvRGV0ZWN0UmVuZGVyZXIgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCB2aWV3LCB0cmFuc3BhcmVudCwgYW50aWFsaWFzKVxue1xuICAgIGlmKCF3aWR0aCl3aWR0aCA9IDgwMDtcbiAgICBpZighaGVpZ2h0KWhlaWdodCA9IDYwMDtcblxuICAgIC8vIEJPUlJPV0VEIGZyb20gTXIgRG9vYiAobXJkb29iLmNvbSlcbiAgICB2YXIgd2ViZ2wgPSAoIGZ1bmN0aW9uICgpIHsgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhIHdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQgJiYgKCBjYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJyApIHx8IGNhbnZhcy5nZXRDb250ZXh0KCAnZXhwZXJpbWVudGFsLXdlYmdsJyApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goIGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICkoKTtcblxuICAgIGlmKCB3ZWJnbCApXG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IFBJWEkuV2ViR0xSZW5kZXJlcih3aWR0aCwgaGVpZ2h0LCB2aWV3LCB0cmFuc3BhcmVudCwgYW50aWFsaWFzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gIG5ldyBQSVhJLkNhbnZhc1JlbmRlcmVyKHdpZHRoLCBoZWlnaHQsIHZpZXcsIHRyYW5zcGFyZW50KTtcbn07XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgZnVuY3Rpb24gd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVjdCB3aGljaCByZW5kZXJlciB5b3Ugc2hvdWxkIGJlIHVzaW5nLlxuICogVGhpcyBmdW5jdGlvbiBpcyB2ZXJ5IHNpbWlsYXIgdG8gdGhlIGF1dG9EZXRlY3RSZW5kZXJlciBmdW5jdGlvbiBleGNlcHQgdGhhdCBpcyB3aWxsIHJldHVybiBhIGNhbnZhcyByZW5kZXJlciBmb3IgYW5kcm9pZC5cbiAqIEV2ZW4gdGhvdWdodCBib3RoIGFuZHJvaWQgY2hyb21lIHN1cG9ydHMgd2ViR0wgdGhlIGNhbnZhcyBpbXBsZW1lbnRhdGlvbiBwZXJmb3JtIGJldHRlciBhdCB0aGUgdGltZSBvZiB3cml0aW5nLiBcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBsaWtlbHkgY2hhbmdlIGFuZCB1cGRhdGUgYXMgd2ViR0wgcGVyZm9ybWFuY2UgaW1wb3JvdmVzIG9uIHRoZWFzZSBkZXZpY2VzLlxuICogQGNsYXNzIGdldFJlY29tbWVuZGVkUmVuZGVyZXJcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB3aWR0aD04MDAge051bWJlcn0gdGhlIHdpZHRoIG9mIHRoZSByZW5kZXJlcnMgdmlld1xuICogQHBhcmFtIGhlaWdodD02MDAge051bWJlcn0gdGhlIGhlaWdodCBvZiB0aGUgcmVuZGVyZXJzIHZpZXdcbiAqIEBwYXJhbSBbdmlld10ge0NhbnZhc30gdGhlIGNhbnZhcyB0byB1c2UgYXMgYSB2aWV3LCBvcHRpb25hbCBcbiAqIEBwYXJhbSBbdHJhbnNwYXJlbnQ9ZmFsc2VdIHtCb29sZWFufSB0aGUgdHJhbnNwYXJlbmN5IG9mIHRoZSByZW5kZXIgdmlldywgZGVmYXVsdCBmYWxzZVxuICogQHBhcmFtIFthbnRpYWxpYXM9ZmFsc2VdIHtCb29sZWFufSBzZXRzIGFudGlhbGlhcyAob25seSBhcHBsaWNhYmxlIGluIHdlYkdMIGNocm9tZSBhdCB0aGUgbW9tZW50KVxuICpcbiAqL1xuUElYSS5hdXRvRGV0ZWN0UmVjb21tZW5kZWRSZW5kZXJlciA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHZpZXcsIHRyYW5zcGFyZW50LCBhbnRpYWxpYXMpXG57XG4gICAgaWYoIXdpZHRoKXdpZHRoID0gODAwO1xuICAgIGlmKCFoZWlnaHQpaGVpZ2h0ID0gNjAwO1xuXG4gICAgLy8gQk9SUk9XRUQgZnJvbSBNciBEb29iIChtcmRvb2IuY29tKVxuICAgIHZhciB3ZWJnbCA9ICggZnVuY3Rpb24gKCkgeyB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISEgd2luZG93LldlYkdMUmVuZGVyaW5nQ29udGV4dCAmJiAoIGNhbnZhcy5nZXRDb250ZXh0KCAnd2ViZ2wnICkgfHwgY2FudmFzLmdldENvbnRleHQoICdleHBlcmltZW50YWwtd2ViZ2wnICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCggZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKSgpO1xuXG4gICAgdmFyIGlzQW5kcm9pZCA9IC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuICAgIGlmKCB3ZWJnbCAmJiAhaXNBbmRyb2lkKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQSVhJLldlYkdMUmVuZGVyZXIod2lkdGgsIGhlaWdodCwgdmlldywgdHJhbnNwYXJlbnQsIGFudGlhbGlhcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICBuZXcgUElYSS5DYW52YXNSZW5kZXJlcih3aWR0aCwgaGVpZ2h0LCB2aWV3LCB0cmFuc3BhcmVudCk7XG59O1xuXG4vKlxuICAgIFBvbHlLIGxpYnJhcnlcbiAgICB1cmw6IGh0dHA6Ly9wb2x5ay5pdmFuay5uZXRcbiAgICBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5jZS5cblxuICAgIENvcHlyaWdodCAoYykgMjAxMiBJdmFuIEt1Y2tpclxuXG4gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICAgIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICAgIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICAgIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gICAgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAgICBjb25kaXRpb25zOlxuXG4gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gICAgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICAgIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICAgIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICAgIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAgICBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiAgICBUaGlzIGlzIGFuIGFtYXppbmcgbGliIVxuXG4gICAgc2xpZ2h0bHkgbW9kaWZpZWQgYnkgTWF0IEdyb3ZlcyAobWF0Z3JvdmVzLmNvbSk7XG4qL1xuXG4vKipcbiAqIEJhc2VkIG9uIHRoZSBQb2x5ayBsaWJyYXJ5IGh0dHA6Ly9wb2x5ay5pdmFuay5uZXQgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2VuY2UuXG4gKiBUaGlzIGlzIGFuIGFtYXppbmcgbGliIVxuICogc2xpZ2h0bHkgbW9kaWZpZWQgYnkgTWF0IEdyb3ZlcyAobWF0Z3JvdmVzLmNvbSk7XG4gKiBAY2xhc3MgUG9seUtcbiAqXG4gKi9cblBJWEkuUG9seUsgPSB7fTtcblxuLyoqXG4gKiBUcmlhbmd1bGF0ZXMgc2hhcGVzIGZvciB3ZWJHTCBncmFwaGljIGZpbGxzXG4gKlxuICogQG1ldGhvZCBUcmlhbmd1bGF0ZVxuICogXG4gKi9cblBJWEkuUG9seUsuVHJpYW5ndWxhdGUgPSBmdW5jdGlvbihwKVxue1xuICAgIHZhciBzaWduID0gdHJ1ZTtcblxuICAgIHZhciBuID0gcC5sZW5ndGggPj4gMTtcbiAgICBpZihuIDwgMykgcmV0dXJuIFtdO1xuXG4gICAgdmFyIHRncyA9IFtdO1xuICAgIHZhciBhdmwgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSBhdmwucHVzaChpKTtcblxuICAgIGkgPSAwO1xuICAgIHZhciBhbCA9IG47XG4gICAgd2hpbGUoYWwgPiAzKVxuICAgIHtcbiAgICAgICAgdmFyIGkwID0gYXZsWyhpKzApJWFsXTtcbiAgICAgICAgdmFyIGkxID0gYXZsWyhpKzEpJWFsXTtcbiAgICAgICAgdmFyIGkyID0gYXZsWyhpKzIpJWFsXTtcblxuICAgICAgICB2YXIgYXggPSBwWzIqaTBdLCAgYXkgPSBwWzIqaTArMV07XG4gICAgICAgIHZhciBieCA9IHBbMippMV0sICBieSA9IHBbMippMSsxXTtcbiAgICAgICAgdmFyIGN4ID0gcFsyKmkyXSwgIGN5ID0gcFsyKmkyKzFdO1xuXG4gICAgICAgIHZhciBlYXJGb3VuZCA9IGZhbHNlO1xuICAgICAgICBpZihQSVhJLlBvbHlLLl9jb252ZXgoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgc2lnbikpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGVhckZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBhbDsgaisrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciB2aSA9IGF2bFtqXTtcbiAgICAgICAgICAgICAgICBpZih2aSA9PT0gaTAgfHwgdmkgPT09IGkxIHx8IHZpID09PSBpMikgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBpZihQSVhJLlBvbHlLLl9Qb2ludEluVHJpYW5nbGUocFsyKnZpXSwgcFsyKnZpKzFdLCBheCwgYXksIGJ4LCBieSwgY3gsIGN5KSkge1xuICAgICAgICAgICAgICAgICAgICBlYXJGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihlYXJGb3VuZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGdzLnB1c2goaTAsIGkxLCBpMik7XG4gICAgICAgICAgICBhdmwuc3BsaWNlKChpKzEpJWFsLCAxKTtcbiAgICAgICAgICAgIGFsLS07XG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGkrKyA+IDMqYWwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gZmxpcCBmbGlwIHJldmVyc2UgaXQhXG4gICAgICAgICAgICAvLyByZXNldCFcbiAgICAgICAgICAgIGlmKHNpZ24pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGdzID0gW107XG4gICAgICAgICAgICAgICAgYXZsID0gW107XG4gICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbjsgaSsrKSBhdmwucHVzaChpKTtcblxuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIGFsID0gbjtcblxuICAgICAgICAgICAgICAgIHNpZ24gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coXCJQSVhJIFdhcm5pbmc6IHNoYXBlIHRvbyBjb21wbGV4IHRvIGZpbGxcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGdzLnB1c2goYXZsWzBdLCBhdmxbMV0sIGF2bFsyXSk7XG4gICAgcmV0dXJuIHRncztcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBwb2ludCBpcyB3aXRoaW4gYSB0cmlhbmdsZVxuICpcbiAqIEBtZXRob2QgX1BvaW50SW5UcmlhbmdsZVxuICogQHBhcmFtIHB4IHtOdW1iZXJ9IHggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICogQHBhcmFtIHB5IHtOdW1iZXJ9IHkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICogQHBhcmFtIGF4IHtOdW1iZXJ9IHggY29vcmRpbmF0ZSBvZiB0aGUgYSBwb2ludCBvZiB0aGUgdHJpYW5nbGVcbiAqIEBwYXJhbSBheSB7TnVtYmVyfSB5IGNvb3JkaW5hdGUgb2YgdGhlIGEgcG9pbnQgb2YgdGhlIHRyaWFuZ2xlXG4gKiBAcGFyYW0gYngge051bWJlcn0geCBjb29yZGluYXRlIG9mIHRoZSBiIHBvaW50IG9mIHRoZSB0cmlhbmdsZVxuICogQHBhcmFtIGJ5IHtOdW1iZXJ9IHkgY29vcmRpbmF0ZSBvZiB0aGUgYiBwb2ludCBvZiB0aGUgdHJpYW5nbGVcbiAqIEBwYXJhbSBjeCB7TnVtYmVyfSB4IGNvb3JkaW5hdGUgb2YgdGhlIGMgcG9pbnQgb2YgdGhlIHRyaWFuZ2xlXG4gKiBAcGFyYW0gY3kge051bWJlcn0geSBjb29yZGluYXRlIG9mIHRoZSBjIHBvaW50IG9mIHRoZSB0cmlhbmdsZVxuICogQHByaXZhdGVcbiAqL1xuUElYSS5Qb2x5Sy5fUG9pbnRJblRyaWFuZ2xlID0gZnVuY3Rpb24ocHgsIHB5LCBheCwgYXksIGJ4LCBieSwgY3gsIGN5KVxue1xuICAgIHZhciB2MHggPSBjeC1heDtcbiAgICB2YXIgdjB5ID0gY3ktYXk7XG4gICAgdmFyIHYxeCA9IGJ4LWF4O1xuICAgIHZhciB2MXkgPSBieS1heTtcbiAgICB2YXIgdjJ4ID0gcHgtYXg7XG4gICAgdmFyIHYyeSA9IHB5LWF5O1xuXG4gICAgdmFyIGRvdDAwID0gdjB4KnYweCt2MHkqdjB5O1xuICAgIHZhciBkb3QwMSA9IHYweCp2MXgrdjB5KnYxeTtcbiAgICB2YXIgZG90MDIgPSB2MHgqdjJ4K3YweSp2Mnk7XG4gICAgdmFyIGRvdDExID0gdjF4KnYxeCt2MXkqdjF5O1xuICAgIHZhciBkb3QxMiA9IHYxeCp2MngrdjF5KnYyeTtcblxuICAgIHZhciBpbnZEZW5vbSA9IDEgLyAoZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEpO1xuICAgIHZhciB1ID0gKGRvdDExICogZG90MDIgLSBkb3QwMSAqIGRvdDEyKSAqIGludkRlbm9tO1xuICAgIHZhciB2ID0gKGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyKSAqIGludkRlbm9tO1xuXG4gICAgLy8gQ2hlY2sgaWYgcG9pbnQgaXMgaW4gdHJpYW5nbGVcbiAgICByZXR1cm4gKHUgPj0gMCkgJiYgKHYgPj0gMCkgJiYgKHUgKyB2IDwgMSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgc2hhcGUgaXMgY29udmV4XG4gKlxuICogQG1ldGhvZCBfY29udmV4XG4gKiBcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuUG9seUsuX2NvbnZleCA9IGZ1bmN0aW9uKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHNpZ24pXG57XG4gICAgcmV0dXJuICgoYXktYnkpKihjeC1ieCkgKyAoYngtYXgpKihjeS1ieSkgPj0gMCkgPT09IHNpZ247XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8vIFRPRE8gQWx2aW4gYW5kIE1hdFxuLy8gU2hvdWxkIHdlIGV2ZW50dWFsbHkgY3JlYXRlIGEgVXRpbHMgY2xhc3MgPyBcbi8vIE9yIGp1c3QgbW92ZSB0aGlzIGZpbGUgdG8gdGhlIHBpeGkuanMgZmlsZSA/XG5QSVhJLmluaXREZWZhdWx0U2hhZGVycyA9IGZ1bmN0aW9uKClcbntcbiAgIFxuICAvLyAgUElYSS5zdHJpcFNoYWRlciA9IG5ldyBQSVhJLlN0cmlwU2hhZGVyKCk7XG4vLyAgICBQSVhJLnN0cmlwU2hhZGVyLmluaXQoKTtcblxufTtcblxuUElYSS5Db21waWxlVmVydGV4U2hhZGVyID0gZnVuY3Rpb24oZ2wsIHNoYWRlclNyYylcbntcbiAgICByZXR1cm4gUElYSS5fQ29tcGlsZVNoYWRlcihnbCwgc2hhZGVyU3JjLCBnbC5WRVJURVhfU0hBREVSKTtcbn07XG5cblBJWEkuQ29tcGlsZUZyYWdtZW50U2hhZGVyID0gZnVuY3Rpb24oZ2wsIHNoYWRlclNyYylcbntcbiAgICByZXR1cm4gUElYSS5fQ29tcGlsZVNoYWRlcihnbCwgc2hhZGVyU3JjLCBnbC5GUkFHTUVOVF9TSEFERVIpO1xufTtcblxuUElYSS5fQ29tcGlsZVNoYWRlciA9IGZ1bmN0aW9uKGdsLCBzaGFkZXJTcmMsIHNoYWRlclR5cGUpXG57XG4gICAgdmFyIHNyYyA9IHNoYWRlclNyYy5qb2luKFwiXFxuXCIpO1xuICAgIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoc2hhZGVyVHlwZSk7XG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc3JjKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG5cbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYWRlcjtcbn07XG5cblBJWEkuY29tcGlsZVByb2dyYW0gPSBmdW5jdGlvbihnbCwgdmVydGV4U3JjLCBmcmFnbWVudFNyYylcbntcbiAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBQSVhJLkNvbXBpbGVGcmFnbWVudFNoYWRlcihnbCwgZnJhZ21lbnRTcmMpO1xuICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBQSVhJLkNvbXBpbGVWZXJ0ZXhTaGFkZXIoZ2wsIHZlcnRleFNyYyk7XG5cbiAgICB2YXIgc2hhZGVyUHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblxuICAgIGdsLmF0dGFjaFNoYWRlcihzaGFkZXJQcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihzaGFkZXJQcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gICAgZ2wubGlua1Byb2dyYW0oc2hhZGVyUHJvZ3JhbSk7XG5cbiAgICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIoc2hhZGVyUHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhcIkNvdWxkIG5vdCBpbml0aWFsaXNlIHNoYWRlcnNcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYWRlclByb2dyYW07XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICogQGF1dGhvciBSaWNoYXJkIERhdmV5IGh0dHA6Ly93d3cucGhvdG9uc3Rvcm0uY29tIEBwaG90b25zdG9ybVxuICovXG5cbi8qKlxuKiBAY2xhc3MgUGl4aVNoYWRlclxuKiBAY29uc3RydWN0b3JcbiovXG5QSVhJLlBpeGlTaGFkZXIgPSBmdW5jdGlvbihnbClcbntcbiAgICB0aGlzLl9VSUQgPSBQSVhJLl9VSUQrKztcbiAgICBcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZ2xcbiAgICAgKiBAdHlwZSBXZWJHTENvbnRleHRcbiAgICAgKi9cbiAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7YW55fSBwcm9ncmFtIC0gVGhlIFdlYkdMIHByb2dyYW0uXG4gICAgKi9cbiAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2FycmF5fSBmcmFnbWVudFNyYyAtIFRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAgKi9cbiAgICB0aGlzLmZyYWdtZW50U3JjID0gW1xuICAgICAgICAncHJlY2lzaW9uIGxvd3AgZmxvYXQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLFxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSAqIHZDb2xvciA7JyxcbiAgICAgICAgJ30nXG4gICAgXTtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRleHR1cmVDb3VudCAtIEEgbG9jYWwgdGV4dHVyZSBjb3VudGVyIGZvciBtdWx0aS10ZXh0dXJlIHNoYWRlcnMuXG4gICAgKi9cbiAgICB0aGlzLnRleHR1cmVDb3VudCA9IDA7XG5cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcblxuICAgIHRoaXMuaW5pdCgpO1xufTtcblxuLyoqXG4qIEluaXRpYWxpc2VzIHRoZSBzaGFkZXJcbiogQG1ldGhvZCBpbml0XG4qXG4qL1xuUElYSS5QaXhpU2hhZGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICB2YXIgcHJvZ3JhbSA9IFBJWEkuY29tcGlsZVByb2dyYW0oZ2wsIHRoaXMudmVydGV4U3JjIHx8IFBJWEkuUGl4aVNoYWRlci5kZWZhdWx0VmVydGV4U3JjLCB0aGlzLmZyYWdtZW50U3JjKTtcbiAgICBcbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgLy8gZ2V0IGFuZCBzdG9yZSB0aGUgdW5pZm9ybXMgZm9yIHRoZSBzaGFkZXJcbiAgICB0aGlzLnVTYW1wbGVyID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U2FtcGxlcicpO1xuICAgIHRoaXMucHJvamVjdGlvblZlY3RvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAncHJvamVjdGlvblZlY3RvcicpO1xuICAgIHRoaXMub2Zmc2V0VmVjdG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdvZmZzZXRWZWN0b3InKTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ2RpbWVuc2lvbnMnKTtcblxuICAgIC8vIGdldCBhbmQgc3RvcmUgdGhlIGF0dHJpYnV0ZXNcbiAgICB0aGlzLmFWZXJ0ZXhQb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhVmVydGV4UG9zaXRpb24nKTtcbiAgICB0aGlzLmFUZXh0dXJlQ29vcmQgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVRleHR1cmVDb29yZCcpO1xuICAgIHRoaXMuY29sb3JBdHRyaWJ1dGUgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYUNvbG9yJyk7XG5cblxuICAgIC8vIEJlZ2luIHdvcnN0IGhhY2sgZXZhIC8vXG5cbiAgICAvLyBXSFk/Pz8gT05MWSBvbiBteSBjaHJvbWUgcGl4ZWwgdGhlIGxpbmUgYWJvdmUgcmV0dXJucyAtMSB3aGVuIHVzaW5nIGZpbHRlcnM/XG4gICAgLy8gbWF5YmUgaXRzIHNvbWV0aGluZyB0byBkbyB3aXRoIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBnbCBjb250ZXh0LlxuICAgIC8vIEltIGNvbnZpbmNlZCB0aGlzIGlzIGEgYnVnIGluIHRoZSBjaHJvbWUgYnJvd3NlciBhcyB0aGVyZSBpcyBOTyByZWFzb24gd2h5IHRoaXMgc2hvdWxkIGJlIHJldHVybmluZyAtMSBlc3BlY2lhbGx5IGFzIGl0IG9ubHkgbWFuaWZlc3RzIG9uIG15IGNocm9tZSBwaXhlbFxuICAgIC8vIElmIHRoZXJlcyBhbnkgd2ViR0wgcGVvcGxlIHRoYXQga25vdyB3aHkgY291bGQgaGFwcGVuIHBsZWFzZSBoZWxwIDopXG4gICAgaWYodGhpcy5jb2xvckF0dHJpYnV0ZSA9PT0gLTEpXG4gICAge1xuICAgICAgICB0aGlzLmNvbG9yQXR0cmlidXRlID0gMjtcbiAgICB9XG5cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbdGhpcy5hVmVydGV4UG9zaXRpb24sIHRoaXMuYVRleHR1cmVDb29yZCwgdGhpcy5jb2xvckF0dHJpYnV0ZV07XG5cbiAgICAvLyBFbmQgd29yc3QgaGFjayBldmEgLy9cblxuICAgIC8vIGFkZCB0aG9zZSBjdXN0b20gc2hhZGVycyFcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy51bmlmb3JtcylcbiAgICB7XG4gICAgICAgIC8vIGdldCB0aGUgdW5pZm9ybSBsb2NhdGlvbnMuLlxuICAgICAgICB0aGlzLnVuaWZvcm1zW2tleV0udW5pZm9ybUxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIGtleSk7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0VW5pZm9ybXMoKTtcblxuICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG59O1xuXG4vKipcbiogSW5pdGlhbGlzZXMgdGhlIHNoYWRlciB1bmlmb3JtIHZhbHVlcy5cbiogVW5pZm9ybXMgYXJlIHNwZWNpZmllZCBpbiB0aGUgR0xTTF9FUyBTcGVjaWZpY2F0aW9uOiBodHRwOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L3dlYmdsL3NwZWNzL2xhdGVzdC8xLjAvXG4qIGh0dHA6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvZ2xlcy9zcGVjcy8yLjAvR0xTTF9FU19TcGVjaWZpY2F0aW9uXzEuMC4xNy5wZGZcbipcbiogQG1ldGhvZCBpbml0VW5pZm9ybXNcbiovXG5QSVhJLlBpeGlTaGFkZXIucHJvdG90eXBlLmluaXRVbmlmb3JtcyA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLnRleHR1cmVDb3VudCA9IDE7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICB2YXIgdW5pZm9ybTtcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnVuaWZvcm1zKVxuICAgIHtcbiAgICAgICAgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXNba2V5XTtcblxuICAgICAgICB2YXIgdHlwZSA9IHVuaWZvcm0udHlwZTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ3NhbXBsZXIyRCcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHVuaWZvcm0uX2luaXQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHVuaWZvcm0udmFsdWUgIT09IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0U2FtcGxlcjJEKHVuaWZvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdtYXQyJyB8fCB0eXBlID09PSAnbWF0MycgfHwgdHlwZSA9PT0gJ21hdDQnKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgVGhlc2UgcmVxdWlyZSBzcGVjaWFsIGhhbmRsaW5nXG4gICAgICAgICAgICB1bmlmb3JtLmdsTWF0cml4ID0gdHJ1ZTtcbiAgICAgICAgICAgIHVuaWZvcm0uZ2xWYWx1ZUxlbmd0aCA9IDE7XG5cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnbWF0MicpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS5nbEZ1bmMgPSBnbC51bmlmb3JtTWF0cml4MmZ2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ21hdDMnKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHVuaWZvcm0uZ2xGdW5jID0gZ2wudW5pZm9ybU1hdHJpeDNmdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdtYXQ0JylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1bmlmb3JtLmdsRnVuYyA9IGdsLnVuaWZvcm1NYXRyaXg0ZnY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgR0wgZnVuY3Rpb24gcmVmZXJlbmNlXG4gICAgICAgICAgICB1bmlmb3JtLmdsRnVuYyA9IGdsWyd1bmlmb3JtJyArIHR5cGVdO1xuXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJzJmJyB8fCB0eXBlID09PSAnMmknKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHVuaWZvcm0uZ2xWYWx1ZUxlbmd0aCA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnM2YnIHx8IHR5cGUgPT09ICczaScpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS5nbFZhbHVlTGVuZ3RoID0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICc0ZicgfHwgdHlwZSA9PT0gJzRpJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1bmlmb3JtLmdsVmFsdWVMZW5ndGggPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHVuaWZvcm0uZ2xWYWx1ZUxlbmd0aCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbi8qKlxuKiBJbml0aWFsaXNlcyBhIFNhbXBsZXIyRCB1bmlmb3JtICh3aGljaCBtYXkgb25seSBiZSBhdmFpbGFibGUgbGF0ZXIgb24gYWZ0ZXIgaW5pdFVuaWZvcm1zIG9uY2UgdGhlIHRleHR1cmUgaGFzIGxvYWRlZClcbipcbiogQG1ldGhvZCBpbml0U2FtcGxlcjJEXG4qL1xuUElYSS5QaXhpU2hhZGVyLnByb3RvdHlwZS5pbml0U2FtcGxlcjJEID0gZnVuY3Rpb24odW5pZm9ybSlcbntcbiAgICBpZiAoIXVuaWZvcm0udmFsdWUgfHwgIXVuaWZvcm0udmFsdWUuYmFzZVRleHR1cmUgfHwgIXVuaWZvcm0udmFsdWUuYmFzZVRleHR1cmUuaGFzTG9hZGVkKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsWydURVhUVVJFJyArIHRoaXMudGV4dHVyZUNvdW50XSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdW5pZm9ybS52YWx1ZS5iYXNlVGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0pO1xuXG4gICAgLy8gIEV4dGVuZGVkIHRleHR1cmUgZGF0YVxuICAgIGlmICh1bmlmb3JtLnRleHR1cmVEYXRhKVxuICAgIHtcbiAgICAgICAgdmFyIGRhdGEgPSB1bmlmb3JtLnRleHR1cmVEYXRhO1xuXG4gICAgICAgIC8vIEdMVGV4dHVyZSA9IG1hZyBsaW5lYXIsIG1pbiBsaW5lYXJfbWlwbWFwX2xpbmVhciwgd3JhcCByZXBlYXQgKyBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcbiAgICAgICAgLy8gR0xUZXh0dXJlTGluZWFyID0gbWFnL21pbiBsaW5lYXIsIHdyYXAgY2xhbXBcbiAgICAgICAgLy8gR0xUZXh0dXJlTmVhcmVzdFJlcGVhdCA9IG1hZy9taW4gTkVBUkVTVCwgd3JhcCByZXBlYXRcbiAgICAgICAgLy8gR0xUZXh0dXJlTmVhcmVzdCA9IG1hZy9taW4gbmVhcmVzdCwgd3JhcCBjbGFtcFxuICAgICAgICAvLyBBdWRpb1RleHR1cmUgPSB3aGF0ZXZlciArIGx1bWluYW5jZSArIHdpZHRoIDUxMiwgaGVpZ2h0IDIsIGJvcmRlciAwXG4gICAgICAgIC8vIEtleVRleHR1cmUgPSB3aGF0ZXZlciArIGx1bWluYW5jZSArIHdpZHRoIDI1NiwgaGVpZ2h0IDIsIGJvcmRlciAwXG5cbiAgICAgICAgLy8gIG1hZ0ZpbHRlciBjYW4gYmU6IGdsLkxJTkVBUiwgZ2wuTElORUFSX01JUE1BUF9MSU5FQVIgb3IgZ2wuTkVBUkVTVFxuICAgICAgICAvLyAgd3JhcFMvVCBjYW4gYmU6IGdsLkNMQU1QX1RPX0VER0Ugb3IgZ2wuUkVQRUFUXG5cbiAgICAgICAgdmFyIG1hZ0ZpbHRlciA9IChkYXRhLm1hZ0ZpbHRlcikgPyBkYXRhLm1hZ0ZpbHRlciA6IGdsLkxJTkVBUjtcbiAgICAgICAgdmFyIG1pbkZpbHRlciA9IChkYXRhLm1pbkZpbHRlcikgPyBkYXRhLm1pbkZpbHRlciA6IGdsLkxJTkVBUjtcbiAgICAgICAgdmFyIHdyYXBTID0gKGRhdGEud3JhcFMpID8gZGF0YS53cmFwUyA6IGdsLkNMQU1QX1RPX0VER0U7XG4gICAgICAgIHZhciB3cmFwVCA9IChkYXRhLndyYXBUKSA/IGRhdGEud3JhcFQgOiBnbC5DTEFNUF9UT19FREdFO1xuICAgICAgICB2YXIgZm9ybWF0ID0gKGRhdGEubHVtaW5hbmNlKSA/IGdsLkxVTUlOQU5DRSA6IGdsLlJHQkE7XG5cbiAgICAgICAgaWYgKGRhdGEucmVwZWF0KVxuICAgICAgICB7XG4gICAgICAgICAgICB3cmFwUyA9IGdsLlJFUEVBVDtcbiAgICAgICAgICAgIHdyYXBUID0gZ2wuUkVQRUFUO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgISFkYXRhLmZsaXBZKTtcblxuICAgICAgICBpZiAoZGF0YS53aWR0aClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gKGRhdGEud2lkdGgpID8gZGF0YS53aWR0aCA6IDUxMjtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSAoZGF0YS5oZWlnaHQpID8gZGF0YS5oZWlnaHQgOiAyO1xuICAgICAgICAgICAgdmFyIGJvcmRlciA9IChkYXRhLmJvcmRlcikgPyBkYXRhLmJvcmRlciA6IDA7XG5cbiAgICAgICAgICAgIC8vIHZvaWQgdGV4SW1hZ2UyRChHTGVudW0gdGFyZ2V0LCBHTGludCBsZXZlbCwgR0xlbnVtIGludGVybmFsZm9ybWF0LCBHTHNpemVpIHdpZHRoLCBHTHNpemVpIGhlaWdodCwgR0xpbnQgYm9yZGVyLCBHTGVudW0gZm9ybWF0LCBHTGVudW0gdHlwZSwgQXJyYXlCdWZmZXJWaWV3PyBwaXhlbHMpO1xuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIGJvcmRlciwgZm9ybWF0LCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICB2b2lkIHRleEltYWdlMkQoR0xlbnVtIHRhcmdldCwgR0xpbnQgbGV2ZWwsIEdMZW51bSBpbnRlcm5hbGZvcm1hdCwgR0xlbnVtIGZvcm1hdCwgR0xlbnVtIHR5cGUsIEltYWdlRGF0YT8gcGl4ZWxzKTtcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZm9ybWF0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB1bmlmb3JtLnZhbHVlLmJhc2VUZXh0dXJlLnNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgbWFnRmlsdGVyKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIG1pbkZpbHRlcik7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIHdyYXBTKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgd3JhcFQpO1xuICAgIH1cblxuICAgIGdsLnVuaWZvcm0xaSh1bmlmb3JtLnVuaWZvcm1Mb2NhdGlvbiwgdGhpcy50ZXh0dXJlQ291bnQpO1xuXG4gICAgdW5pZm9ybS5faW5pdCA9IHRydWU7XG5cbiAgICB0aGlzLnRleHR1cmVDb3VudCsrO1xuXG59O1xuXG4vKipcbiogVXBkYXRlcyB0aGUgc2hhZGVyIHVuaWZvcm0gdmFsdWVzLlxuKlxuKiBAbWV0aG9kIHN5bmNVbmlmb3Jtc1xuKi9cblBJWEkuUGl4aVNoYWRlci5wcm90b3R5cGUuc3luY1VuaWZvcm1zID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMudGV4dHVyZUNvdW50ID0gMTtcbiAgICB2YXIgdW5pZm9ybTtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgLy8gIFRoaXMgd291bGQgcHJvYmFibHkgYmUgZmFzdGVyIGluIGFuIGFycmF5IGFuZCBpdCB3b3VsZCBndWFyYW50ZWUga2V5IG9yZGVyXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMudW5pZm9ybXMpXG4gICAge1xuICAgICAgICB1bmlmb3JtID0gdGhpcy51bmlmb3Jtc1trZXldO1xuXG4gICAgICAgIGlmICh1bmlmb3JtLmdsVmFsdWVMZW5ndGggPT09IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh1bmlmb3JtLmdsTWF0cml4ID09PSB0cnVlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHVuaWZvcm0uZ2xGdW5jLmNhbGwoZ2wsIHVuaWZvcm0udW5pZm9ybUxvY2F0aW9uLCB1bmlmb3JtLnRyYW5zcG9zZSwgdW5pZm9ybS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS5nbEZ1bmMuY2FsbChnbCwgdW5pZm9ybS51bmlmb3JtTG9jYXRpb24sIHVuaWZvcm0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVuaWZvcm0uZ2xWYWx1ZUxlbmd0aCA9PT0gMilcbiAgICAgICAge1xuICAgICAgICAgICAgdW5pZm9ybS5nbEZ1bmMuY2FsbChnbCwgdW5pZm9ybS51bmlmb3JtTG9jYXRpb24sIHVuaWZvcm0udmFsdWUueCwgdW5pZm9ybS52YWx1ZS55KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1bmlmb3JtLmdsVmFsdWVMZW5ndGggPT09IDMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHVuaWZvcm0uZ2xGdW5jLmNhbGwoZ2wsIHVuaWZvcm0udW5pZm9ybUxvY2F0aW9uLCB1bmlmb3JtLnZhbHVlLngsIHVuaWZvcm0udmFsdWUueSwgdW5pZm9ybS52YWx1ZS56KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1bmlmb3JtLmdsVmFsdWVMZW5ndGggPT09IDQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHVuaWZvcm0uZ2xGdW5jLmNhbGwoZ2wsIHVuaWZvcm0udW5pZm9ybUxvY2F0aW9uLCB1bmlmb3JtLnZhbHVlLngsIHVuaWZvcm0udmFsdWUueSwgdW5pZm9ybS52YWx1ZS56LCB1bmlmb3JtLnZhbHVlLncpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVuaWZvcm0udHlwZSA9PT0gJ3NhbXBsZXIyRCcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh1bmlmb3JtLl9pbml0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2xbJ1RFWFRVUkUnICsgdGhpcy50ZXh0dXJlQ291bnRdKTtcbiAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB1bmlmb3JtLnZhbHVlLmJhc2VUZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSB8fCBQSVhJLmNyZWF0ZVdlYkdMVGV4dHVyZSggdW5pZm9ybS52YWx1ZS5iYXNlVGV4dHVyZSwgZ2wpKTtcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkodW5pZm9ybS51bmlmb3JtTG9jYXRpb24sIHRoaXMudGV4dHVyZUNvdW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmVDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFNhbXBsZXIyRCh1bmlmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufTtcblxuLyoqXG4qIERlc3Ryb3lzIHRoZSBzaGFkZXJcbiogQG1ldGhvZCBkZXN0cm95XG4qL1xuUElYSS5QaXhpU2hhZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbSggdGhpcy5wcm9ncmFtICk7XG4gICAgdGhpcy51bmlmb3JtcyA9IG51bGw7XG4gICAgdGhpcy5nbCA9IG51bGw7XG5cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBudWxsO1xufTtcblxuLyoqXG4qIFRoZSBEZWZhdWx0IFZlcnRleCBzaGFkZXIgc291cmNlXG4qIEBwcm9wZXJ0eSBkZWZhdWx0VmVydGV4U3JjXG4qIEB0eXBlIFN0cmluZ1xuKi9cblBJWEkuUGl4aVNoYWRlci5kZWZhdWx0VmVydGV4U3JjID0gW1xuICAgICdhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247JyxcbiAgICAnYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDsnLFxuICAgICdhdHRyaWJ1dGUgdmVjMiBhQ29sb3I7JyxcblxuICAgICd1bmlmb3JtIHZlYzIgcHJvamVjdGlvblZlY3RvcjsnLFxuICAgICd1bmlmb3JtIHZlYzIgb2Zmc2V0VmVjdG9yOycsXG5cbiAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxuXG4gICAgJ2NvbnN0IHZlYzIgY2VudGVyID0gdmVjMigtMS4wLCAxLjApOycsXG5cbiAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICcgICBnbF9Qb3NpdGlvbiA9IHZlYzQoICgoYVZlcnRleFBvc2l0aW9uICsgb2Zmc2V0VmVjdG9yKSAvIHByb2plY3Rpb25WZWN0b3IpICsgY2VudGVyICwgMC4wLCAxLjApOycsXG4gICAgJyAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkOycsXG4gICAgJyAgIHZlYzMgY29sb3IgPSBtb2QodmVjMyhhQ29sb3IueS82NTUzNi4wLCBhQ29sb3IueS8yNTYuMCwgYUNvbG9yLnkpLCAyNTYuMCkgLyAyNTYuMDsnLFxuICAgICcgICB2Q29sb3IgPSB2ZWM0KGNvbG9yICogYUNvbG9yLngsIGFDb2xvci54KTsnLFxuICAgICd9J1xuXTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqIEBhdXRob3IgUmljaGFyZCBEYXZleSBodHRwOi8vd3d3LnBob3RvbnN0b3JtLmNvbSBAcGhvdG9uc3Rvcm1cbiAqL1xuXG4vKipcbiogQGNsYXNzIFBpeGlGYXN0U2hhZGVyXG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0gZ2wge1dlYkdMQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4qL1xuUElYSS5QaXhpRmFzdFNoYWRlciA9IGZ1bmN0aW9uKGdsKVxue1xuICAgIHRoaXMuX1VJRCA9IFBJWEkuX1VJRCsrO1xuICAgIFxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBnbFxuICAgICAqIEB0eXBlIFdlYkdMQ29udGV4dFxuICAgICAqL1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBwcm9ncmFtIC0gVGhlIFdlYkdMIHByb2dyYW0uXG4gICAgICovXG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IGZyYWdtZW50U3JjIC0gVGhlIGZyYWdtZW50IHNoYWRlci5cbiAgICAgKi9cbiAgICB0aGlzLmZyYWdtZW50U3JjID0gW1xuICAgICAgICAncHJlY2lzaW9uIGxvd3AgZmxvYXQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgICAgICd2YXJ5aW5nIGZsb2F0IHZDb2xvcjsnLFxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3IgOycsXG4gICAgICAgICd9J1xuICAgIF07XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IHZlcnRleFNyYyAtIFRoZSB2ZXJ0ZXggc2hhZGVyXG4gICAgKi9cbiAgICB0aGlzLnZlcnRleFNyYyA9IFtcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjsnLFxuICAgICAgICAnYXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uQ29vcmQ7JyxcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFTY2FsZTsnLFxuICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFSb3RhdGlvbjsnLFxuICAgICAgICAnYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDsnLFxuICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFDb2xvcjsnLFxuXG4gICAgICAgICd1bmlmb3JtIHZlYzIgcHJvamVjdGlvblZlY3RvcjsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMyIG9mZnNldFZlY3RvcjsnLFxuICAgICAgICAndW5pZm9ybSBtYXQzIHVNYXRyaXg7JyxcblxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgdkNvbG9yOycsXG5cbiAgICAgICAgJ2NvbnN0IHZlYzIgY2VudGVyID0gdmVjMigtMS4wLCAxLjApOycsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIHZlYzIgdjsnLFxuICAgICAgICAnICAgdmVjMiBzdiA9IGFWZXJ0ZXhQb3NpdGlvbiAqIGFTY2FsZTsnLFxuICAgICAgICAnICAgdi54ID0gKHN2LngpICogY29zKGFSb3RhdGlvbikgLSAoc3YueSkgKiBzaW4oYVJvdGF0aW9uKTsnLFxuICAgICAgICAnICAgdi55ID0gKHN2LngpICogc2luKGFSb3RhdGlvbikgKyAoc3YueSkgKiBjb3MoYVJvdGF0aW9uKTsnLFxuICAgICAgICAnICAgdiA9ICggdU1hdHJpeCAqIHZlYzModiArIGFQb3NpdGlvbkNvb3JkICwgMS4wKSApLnh5IDsnLFxuICAgICAgICAnICAgZ2xfUG9zaXRpb24gPSB2ZWM0KCAoIHYgLyBwcm9qZWN0aW9uVmVjdG9yKSArIGNlbnRlciAsIDAuMCwgMS4wKTsnLFxuICAgICAgICAnICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7JyxcbiAgICAgIC8vICAnICAgdmVjMyBjb2xvciA9IG1vZCh2ZWMzKGFDb2xvci55LzY1NTM2LjAsIGFDb2xvci55LzI1Ni4wLCBhQ29sb3IueSksIDI1Ni4wKSAvIDI1Ni4wOycsXG4gICAgICAgICcgICB2Q29sb3IgPSBhQ29sb3I7JyxcbiAgICAgICAgJ30nXG4gICAgXTtcblxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gdGV4dHVyZUNvdW50IC0gQSBsb2NhbCB0ZXh0dXJlIGNvdW50ZXIgZm9yIG11bHRpLXRleHR1cmUgc2hhZGVycy5cbiAgICAqL1xuICAgIHRoaXMudGV4dHVyZUNvdW50ID0gMDtcblxuICAgIFxuICAgIHRoaXMuaW5pdCgpO1xufTtcblxuLyoqXG4qIEluaXRpYWxpc2VzIHRoZSBzaGFkZXJcbiogQG1ldGhvZCBpbml0XG4qXG4qL1xuUElYSS5QaXhpRmFzdFNoYWRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKClcbntcblxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICB2YXIgcHJvZ3JhbSA9IFBJWEkuY29tcGlsZVByb2dyYW0oZ2wsIHRoaXMudmVydGV4U3JjLCB0aGlzLmZyYWdtZW50U3JjKTtcbiAgICBcbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgLy8gZ2V0IGFuZCBzdG9yZSB0aGUgdW5pZm9ybXMgZm9yIHRoZSBzaGFkZXJcbiAgICB0aGlzLnVTYW1wbGVyID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U2FtcGxlcicpO1xuXG4gICAgdGhpcy5wcm9qZWN0aW9uVmVjdG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdwcm9qZWN0aW9uVmVjdG9yJyk7XG4gICAgdGhpcy5vZmZzZXRWZWN0b3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ29mZnNldFZlY3RvcicpO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnZGltZW5zaW9ucycpO1xuICAgIHRoaXMudU1hdHJpeCA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndU1hdHJpeCcpO1xuXG4gICAgLy8gZ2V0IGFuZCBzdG9yZSB0aGUgYXR0cmlidXRlc1xuICAgIHRoaXMuYVZlcnRleFBvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FWZXJ0ZXhQb3NpdGlvbicpO1xuICAgIHRoaXMuYVBvc2l0aW9uQ29vcmQgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVBvc2l0aW9uQ29vcmQnKTtcblxuICAgIHRoaXMuYVNjYWxlID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FTY2FsZScpO1xuICAgIHRoaXMuYVJvdGF0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FSb3RhdGlvbicpO1xuXG4gICAgdGhpcy5hVGV4dHVyZUNvb3JkID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FUZXh0dXJlQ29vcmQnKTtcbiAgICB0aGlzLmNvbG9yQXR0cmlidXRlID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FDb2xvcicpO1xuICAgXG5cbiAgIFxuICAgIC8vIEJlZ2luIHdvcnN0IGhhY2sgZXZhIC8vXG5cbiAgICAvLyBXSFk/Pz8gT05MWSBvbiBteSBjaHJvbWUgcGl4ZWwgdGhlIGxpbmUgYWJvdmUgcmV0dXJucyAtMSB3aGVuIHVzaW5nIGZpbHRlcnM/XG4gICAgLy8gbWF5YmUgaXRzIHNvbXRoaW5nIHRvIGRvIHdpdGggdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGdsIGNvbnRleHQuXG4gICAgLy8gSW0gY29udmluY2VkIHRoaXMgaXMgYSBidWcgaW4gdGhlIGNocm9tZSBicm93c2VyIGFzIHRoZXJlIGlzIE5PIHJlYXNvbiB3aHkgdGhpcyBzaG91bGQgYmUgcmV0dXJuaW5nIC0xIGVzcGVjaWFsbHkgYXMgaXQgb25seSBtYW5pZmVzdHMgb24gbXkgY2hyb21lIHBpeGVsXG4gICAgLy8gSWYgdGhlcmVzIGFueSB3ZWJHTCBwZW9wbGUgdGhhdCBrbm93IHdoeSBjb3VsZCBoYXBwZW4gcGxlYXNlIGhlbHAgOilcbiAgICBpZih0aGlzLmNvbG9yQXR0cmlidXRlID09PSAtMSlcbiAgICB7XG4gICAgICAgIHRoaXMuY29sb3JBdHRyaWJ1dGUgPSAyO1xuICAgIH1cblxuICAgIHRoaXMuYXR0cmlidXRlcyA9IFt0aGlzLmFWZXJ0ZXhQb3NpdGlvbiwgdGhpcy5hUG9zaXRpb25Db29yZCwgIHRoaXMuYVNjYWxlLCB0aGlzLmFSb3RhdGlvbiwgdGhpcy5hVGV4dHVyZUNvb3JkLCB0aGlzLmNvbG9yQXR0cmlidXRlXTtcbiAgICBcbiAgICAvLyBFbmQgd29yc3QgaGFjayBldmEgLy9cblxuXG4gICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbn07XG5cbi8qKlxuKiBEZXN0cm95cyB0aGUgc2hhZGVyXG4qIEBtZXRob2QgZGVzdHJveVxuKlxuKi9cblBJWEkuUGl4aUZhc3RTaGFkZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5nbC5kZWxldGVQcm9ncmFtKCB0aGlzLnByb2dyYW0gKTtcbiAgICB0aGlzLnVuaWZvcm1zID0gbnVsbDtcbiAgICB0aGlzLmdsID0gbnVsbDtcblxuICAgIHRoaXMuYXR0cmlidXRlcyA9IG51bGw7XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cblxuUElYSS5TdHJpcFNoYWRlciA9IGZ1bmN0aW9uKGdsKVxue1xuICAgIHRoaXMuX1VJRCA9IFBJWEkuX1VJRCsrO1xuICAgIFxuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHthbnl9IHByb2dyYW0gLSBUaGUgV2ViR0wgcHJvZ3JhbS5cbiAgICAqL1xuICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSBmcmFnbWVudFNyYyAtIFRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAgICovXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICAvLyAgICd2YXJ5aW5nIGZsb2F0IHZDb2xvcjsnLFxuICAgICAgICAndW5pZm9ybSBmbG9hdCBhbHBoYTsnLFxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCwgdlRleHR1cmVDb29yZC55KSk7JyxcbiAgICAgIC8vICAnICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjAsIDAuMCwgMC4wLCAxLjApOycsLy9nbF9GcmFnQ29sb3IgKiBhbHBoYTsnLFxuICAgICAgICAnfSdcbiAgICBdO1xuXG4gICAgIC8qKlxuICAgICogQHByb3BlcnR5IHthcnJheX0gZnJhZ21lbnRTcmMgLSBUaGUgZnJhZ21lbnQgc2hhZGVyLlxuICAgICovXG4gICAgdGhpcy52ZXJ0ZXhTcmMgID0gW1xuICAgICAgICAnYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uOycsXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkOycsXG4gICAgICAgICd1bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiBwcm9qZWN0aW9uVmVjdG9yOycsXG4gICAgICAgICd1bmlmb3JtIHZlYzIgb2Zmc2V0VmVjdG9yOycsXG4gICAgICAvLyAgJ3VuaWZvcm0gZmxvYXQgYWxwaGE7JyxcbiAgICAgICAvLyAndW5pZm9ybSB2ZWMzIHRpbnQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgICAvLyAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgdmVjMyB2ID0gdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiAsIDEuMCk7JyxcbiAgICAgICAgJyAgIHYgLT0gb2Zmc2V0VmVjdG9yLnh5eDsnLFxuICAgICAgICAnICAgZ2xfUG9zaXRpb24gPSB2ZWM0KCB2LnggLyBwcm9qZWN0aW9uVmVjdG9yLnggLTEuMCwgdi55IC8gLXByb2plY3Rpb25WZWN0b3IueSArIDEuMCAsIDAuMCwgMS4wKTsnLFxuICAgICAgICAnICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAvLyAnICAgdkNvbG9yID0gYUNvbG9yICogdmVjNCh0aW50ICogYWxwaGEsIGFscGhhKTsnLFxuICAgICAgICAnfSdcbiAgICBdO1xuXG4gICAgdGhpcy5pbml0KCk7XG59O1xuXG4vKipcbiogSW5pdGlhbGlzZXMgdGhlIHNoYWRlclxuKiBAbWV0aG9kIGluaXRcbipcbiovXG5QSVhJLlN0cmlwU2hhZGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICB2YXIgcHJvZ3JhbSA9IFBJWEkuY29tcGlsZVByb2dyYW0oZ2wsIHRoaXMudmVydGV4U3JjLCB0aGlzLmZyYWdtZW50U3JjKTtcbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgLy8gZ2V0IGFuZCBzdG9yZSB0aGUgdW5pZm9ybXMgZm9yIHRoZSBzaGFkZXJcbiAgICB0aGlzLnVTYW1wbGVyID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U2FtcGxlcicpO1xuICAgIHRoaXMucHJvamVjdGlvblZlY3RvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAncHJvamVjdGlvblZlY3RvcicpO1xuICAgIHRoaXMub2Zmc2V0VmVjdG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdvZmZzZXRWZWN0b3InKTtcbiAgICB0aGlzLmNvbG9yQXR0cmlidXRlID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FDb2xvcicpO1xuICAgIC8vdGhpcy5kaW1lbnNpb25zID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ2RpbWVuc2lvbnMnKTtcblxuICAgIC8vIGdldCBhbmQgc3RvcmUgdGhlIGF0dHJpYnV0ZXNcbiAgICB0aGlzLmFWZXJ0ZXhQb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhVmVydGV4UG9zaXRpb24nKTtcbiAgICB0aGlzLmFUZXh0dXJlQ29vcmQgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVRleHR1cmVDb29yZCcpO1xuXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gW3RoaXMuYVZlcnRleFBvc2l0aW9uLCB0aGlzLmFUZXh0dXJlQ29vcmRdO1xuXG4gICAgdGhpcy50cmFuc2xhdGlvbk1hdHJpeCA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndHJhbnNsYXRpb25NYXRyaXgnKTtcbiAgICB0aGlzLmFscGhhID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdhbHBoYScpO1xuXG4gICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4qIEBjbGFzcyBQcmltaXRpdmVTaGFkZXJcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSBnbCB7V2ViR0xDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiovXG5QSVhJLlByaW1pdGl2ZVNoYWRlciA9IGZ1bmN0aW9uKGdsKVxue1xuICAgIHRoaXMuX1VJRCA9IFBJWEkuX1VJRCsrO1xuIFxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBnbFxuICAgICAqIEB0eXBlIFdlYkdMQ29udGV4dFxuICAgICAqL1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHthbnl9IHByb2dyYW0gLSBUaGUgV2ViR0wgcHJvZ3JhbS5cbiAgICAqL1xuICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZnJhZ21lbnRTcmNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBbXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuICAgICAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxuXG4gICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSB2Q29sb3I7JyxcbiAgICAgICAgJ30nXG4gICAgXTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB2ZXJ0ZXhTcmNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHRoaXMudmVydGV4U3JjICA9IFtcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjsnLFxuICAgICAgICAnYXR0cmlidXRlIHZlYzQgYUNvbG9yOycsXG4gICAgICAgICd1bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiBwcm9qZWN0aW9uVmVjdG9yOycsXG4gICAgICAgICd1bmlmb3JtIHZlYzIgb2Zmc2V0VmVjdG9yOycsXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IGFscGhhOycsXG4gICAgICAgICd1bmlmb3JtIHZlYzMgdGludDsnLFxuICAgICAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxuXG4gICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICcgICB2ZWMzIHYgPSB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uICwgMS4wKTsnLFxuICAgICAgICAnICAgdiAtPSBvZmZzZXRWZWN0b3IueHl4OycsXG4gICAgICAgICcgICBnbF9Qb3NpdGlvbiA9IHZlYzQoIHYueCAvIHByb2plY3Rpb25WZWN0b3IueCAtMS4wLCB2LnkgLyAtcHJvamVjdGlvblZlY3Rvci55ICsgMS4wICwgMC4wLCAxLjApOycsXG4gICAgICAgICcgICB2Q29sb3IgPSBhQ29sb3IgKiB2ZWM0KHRpbnQgKiBhbHBoYSwgYWxwaGEpOycsXG4gICAgICAgICd9J1xuICAgIF07XG5cbiAgICB0aGlzLmluaXQoKTtcbn07XG5cbi8qKlxuKiBJbml0aWFsaXNlcyB0aGUgc2hhZGVyXG4qIEBtZXRob2QgaW5pdFxuKlxuKi9cblBJWEkuUHJpbWl0aXZlU2hhZGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKVxue1xuXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIHZhciBwcm9ncmFtID0gUElYSS5jb21waWxlUHJvZ3JhbShnbCwgdGhpcy52ZXJ0ZXhTcmMsIHRoaXMuZnJhZ21lbnRTcmMpO1xuICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAvLyBnZXQgYW5kIHN0b3JlIHRoZSB1bmlmb3JtcyBmb3IgdGhlIHNoYWRlclxuICAgIHRoaXMucHJvamVjdGlvblZlY3RvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAncHJvamVjdGlvblZlY3RvcicpO1xuICAgIHRoaXMub2Zmc2V0VmVjdG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdvZmZzZXRWZWN0b3InKTtcbiAgICB0aGlzLnRpbnRDb2xvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndGludCcpO1xuXG5cbiAgICAvLyBnZXQgYW5kIHN0b3JlIHRoZSBhdHRyaWJ1dGVzXG4gICAgdGhpcy5hVmVydGV4UG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVZlcnRleFBvc2l0aW9uJyk7XG4gICAgdGhpcy5jb2xvckF0dHJpYnV0ZSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhQ29sb3InKTtcblxuICAgIHRoaXMuYXR0cmlidXRlcyA9IFt0aGlzLmFWZXJ0ZXhQb3NpdGlvbiwgdGhpcy5jb2xvckF0dHJpYnV0ZV07XG5cbiAgICB0aGlzLnRyYW5zbGF0aW9uTWF0cml4ID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd0cmFuc2xhdGlvbk1hdHJpeCcpO1xuICAgIHRoaXMuYWxwaGEgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ2FscGhhJyk7XG5cbiAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xufTtcblxuLyoqXG4qIERlc3Ryb3lzIHRoZSBzaGFkZXJcbiogQG1ldGhvZCBkZXN0cm95XG4qXG4qL1xuUElYSS5QcmltaXRpdmVTaGFkZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5nbC5kZWxldGVQcm9ncmFtKCB0aGlzLnByb2dyYW0gKTtcbiAgICB0aGlzLnVuaWZvcm1zID0gbnVsbDtcbiAgICB0aGlzLmdsID0gbnVsbDtcblxuICAgIHRoaXMuYXR0cmlidXRlID0gbnVsbDtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4qIEBjbGFzcyBDb21wbGV4UHJpbWl0aXZlU2hhZGVyXG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0gZ2wge1dlYkdMQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4qL1xuUElYSS5Db21wbGV4UHJpbWl0aXZlU2hhZGVyID0gZnVuY3Rpb24oZ2wpXG57XG4gICAgdGhpcy5fVUlEID0gUElYSS5fVUlEKys7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGdsXG4gICAgICogQHR5cGUgV2ViR0xDb250ZXh0XG4gICAgICovXG4gICAgdGhpcy5nbCA9IGdsO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2FueX0gcHJvZ3JhbSAtIFRoZSBXZWJHTCBwcm9ncmFtLlxuICAgICovXG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBmcmFnbWVudFNyY1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4gICAgICAgIFxuXG5cbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gdkNvbG9yOycsXG4gICAgICAgICd9J1xuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgdmVydGV4U3JjXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICB0aGlzLnZlcnRleFNyYyAgPSBbXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247JyxcbiAgICAgICAgLy8nYXR0cmlidXRlIHZlYzQgYUNvbG9yOycsXG4gICAgICAgICd1bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiBwcm9qZWN0aW9uVmVjdG9yOycsXG4gICAgICAgICd1bmlmb3JtIHZlYzIgb2Zmc2V0VmVjdG9yOycsXG4gICAgICAgIFxuICAgICAgICAndW5pZm9ybSB2ZWMzIHRpbnQ7JyxcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgYWxwaGE7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMyBjb2xvcjsnLFxuXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIHZlYzMgdiA9IHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24gLCAxLjApOycsXG4gICAgICAgICcgICB2IC09IG9mZnNldFZlY3Rvci54eXg7JyxcbiAgICAgICAgJyAgIGdsX1Bvc2l0aW9uID0gdmVjNCggdi54IC8gcHJvamVjdGlvblZlY3Rvci54IC0xLjAsIHYueSAvIC1wcm9qZWN0aW9uVmVjdG9yLnkgKyAxLjAgLCAwLjAsIDEuMCk7JyxcbiAgICAgICAgJyAgIHZDb2xvciA9IHZlYzQoY29sb3IgKiBhbHBoYSAqIHRpbnQsIGFscGhhKTsnLC8vXCIgKiB2ZWM0KHRpbnQgKiBhbHBoYSwgYWxwaGEpOycsXG4gICAgICAgICd9J1xuICAgIF07XG5cbiAgICB0aGlzLmluaXQoKTtcbn07XG5cbi8qKlxuKiBJbml0aWFsaXNlcyB0aGUgc2hhZGVyXG4qIEBtZXRob2QgaW5pdFxuKlxuKi9cblBJWEkuQ29tcGxleFByaW1pdGl2ZVNoYWRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKClcbntcblxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICB2YXIgcHJvZ3JhbSA9IFBJWEkuY29tcGlsZVByb2dyYW0oZ2wsIHRoaXMudmVydGV4U3JjLCB0aGlzLmZyYWdtZW50U3JjKTtcbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgLy8gZ2V0IGFuZCBzdG9yZSB0aGUgdW5pZm9ybXMgZm9yIHRoZSBzaGFkZXJcbiAgICB0aGlzLnByb2plY3Rpb25WZWN0b3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Byb2plY3Rpb25WZWN0b3InKTtcbiAgICB0aGlzLm9mZnNldFZlY3RvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnb2Zmc2V0VmVjdG9yJyk7XG4gICAgdGhpcy50aW50Q29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3RpbnQnKTtcbiAgICB0aGlzLmNvbG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdjb2xvcicpO1xuXG5cbiAgICAvLyBnZXQgYW5kIHN0b3JlIHRoZSBhdHRyaWJ1dGVzXG4gICAgdGhpcy5hVmVydGV4UG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVZlcnRleFBvc2l0aW9uJyk7XG4gICAvLyB0aGlzLmNvbG9yQXR0cmlidXRlID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FDb2xvcicpO1xuXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gW3RoaXMuYVZlcnRleFBvc2l0aW9uLCB0aGlzLmNvbG9yQXR0cmlidXRlXTtcblxuICAgIHRoaXMudHJhbnNsYXRpb25NYXRyaXggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3RyYW5zbGF0aW9uTWF0cml4Jyk7XG4gICAgdGhpcy5hbHBoYSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnYWxwaGEnKTtcblxuICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG59O1xuXG4vKipcbiogRGVzdHJveXMgdGhlIHNoYWRlclxuKiBAbWV0aG9kIGRlc3Ryb3lcbipcbiovXG5QSVhJLkNvbXBsZXhQcmltaXRpdmVTaGFkZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5nbC5kZWxldGVQcm9ncmFtKCB0aGlzLnByb2dyYW0gKTtcbiAgICB0aGlzLnVuaWZvcm1zID0gbnVsbDtcbiAgICB0aGlzLmdsID0gbnVsbDtcblxuICAgIHRoaXMuYXR0cmlidXRlID0gbnVsbDtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKiBBIHNldCBvZiBmdW5jdGlvbnMgdXNlZCBieSB0aGUgd2ViR0wgcmVuZGVyZXIgdG8gZHJhdyB0aGUgcHJpbWl0aXZlIGdyYXBoaWNzIGRhdGFcbiAqXG4gKiBAY2xhc3MgV2ViR0xHcmFwaGljc1xuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqL1xuUElYSS5XZWJHTEdyYXBoaWNzID0gZnVuY3Rpb24oKVxue1xuXG59O1xuXG4vKipcbiAqIFJlbmRlcnMgdGhlIGdyYXBoaWNzIG9iamVjdFxuICpcbiAqIEBzdGF0aWNcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIHJlbmRlckdyYXBoaWNzXG4gKiBAcGFyYW0gZ3JhcGhpY3Mge0dyYXBoaWNzfVxuICogQHBhcmFtIHJlbmRlclNlc3Npb24ge09iamVjdH1cbiAqL1xuUElYSS5XZWJHTEdyYXBoaWNzLnJlbmRlckdyYXBoaWNzID0gZnVuY3Rpb24oZ3JhcGhpY3MsIHJlbmRlclNlc3Npb24pLy9wcm9qZWN0aW9uLCBvZmZzZXQpXG57XG4gICAgdmFyIGdsID0gcmVuZGVyU2Vzc2lvbi5nbDtcbiAgICB2YXIgcHJvamVjdGlvbiA9IHJlbmRlclNlc3Npb24ucHJvamVjdGlvbixcbiAgICAgICAgb2Zmc2V0ID0gcmVuZGVyU2Vzc2lvbi5vZmZzZXQsXG4gICAgICAgIHNoYWRlciA9IHJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlci5wcmltaXRpdmVTaGFkZXIsXG4gICAgICAgIHdlYkdMRGF0YTtcblxuICAgIGlmKGdyYXBoaWNzLmRpcnR5KVxuICAgIHtcbiAgICAgICAgUElYSS5XZWJHTEdyYXBoaWNzLnVwZGF0ZUdyYXBoaWNzKGdyYXBoaWNzLCBnbCk7XG4gICAgfVxuXG4gICAgdmFyIHdlYkdMID0gZ3JhcGhpY3MuX3dlYkdMW2dsLmlkXTtcblxuICAgIC8vIFRoaXMgIGNvdWxkIGJlIHNwZWVkZWQgdXAgZm9yIHN1cmUhXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdlYkdMLmRhdGEubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpZih3ZWJHTC5kYXRhW2ldLm1vZGUgPT09IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHdlYkdMRGF0YSA9IHdlYkdMLmRhdGFbaV07XG5cbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24uc3RlbmNpbE1hbmFnZXIucHVzaFN0ZW5jaWwoZ3JhcGhpY3MsIHdlYkdMRGF0YSwgcmVuZGVyU2Vzc2lvbik7XG5cbiAgICAgICAgICAgIC8vIHJlbmRlciBxdWFkLi5cbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRV9GQU4sIDQsIGdsLlVOU0lHTkVEX1NIT1JULCAoIHdlYkdMRGF0YS5pbmRpY2VzLmxlbmd0aCAtIDQgKSAqIDIgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmVuZGVyU2Vzc2lvbi5zdGVuY2lsTWFuYWdlci5wb3BTdGVuY2lsKGdyYXBoaWNzLCB3ZWJHTERhdGEsIHJlbmRlclNlc3Npb24pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmxhc3QgPSB3ZWJHTERhdGEubW9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHdlYkdMRGF0YSA9IHdlYkdMLmRhdGFbaV07XG4gICAgICAgICAgIFxuXG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIuc2V0U2hhZGVyKCBzaGFkZXIgKTsvL2FjdGl2YXRlUHJpbWl0aXZlU2hhZGVyKCk7XG4gICAgICAgICAgICBzaGFkZXIgPSByZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIucHJpbWl0aXZlU2hhZGVyO1xuICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihzaGFkZXIudHJhbnNsYXRpb25NYXRyaXgsIGZhbHNlLCBncmFwaGljcy53b3JsZFRyYW5zZm9ybS50b0FycmF5KHRydWUpKTtcblxuICAgICAgICAgICAgZ2wudW5pZm9ybTJmKHNoYWRlci5wcm9qZWN0aW9uVmVjdG9yLCBwcm9qZWN0aW9uLngsIC1wcm9qZWN0aW9uLnkpO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTJmKHNoYWRlci5vZmZzZXRWZWN0b3IsIC1vZmZzZXQueCwgLW9mZnNldC55KTtcblxuICAgICAgICAgICAgZ2wudW5pZm9ybTNmdihzaGFkZXIudGludENvbG9yLCBQSVhJLmhleDJyZ2IoZ3JhcGhpY3MudGludCkpO1xuXG4gICAgICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLmFscGhhLCBncmFwaGljcy53b3JsZEFscGhhKTtcbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgd2ViR0xEYXRhLmJ1ZmZlcik7XG5cbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFWZXJ0ZXhQb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCA0ICogNiwgMCk7XG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5jb2xvckF0dHJpYnV0ZSwgNCwgZ2wuRkxPQVQsIGZhbHNlLDQgKiA2LCAyICogNCk7XG5cbiAgICAgICAgICAgIC8vIHNldCB0aGUgaW5kZXggYnVmZmVyIVxuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgd2ViR0xEYXRhLmluZGV4QnVmZmVyKTtcbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRV9TVFJJUCwgIHdlYkdMRGF0YS5pbmRpY2VzLmxlbmd0aCwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgZ3JhcGhpY3Mgb2JqZWN0XG4gKlxuICogQHN0YXRpY1xuICogQHByaXZhdGVcbiAqIEBtZXRob2QgdXBkYXRlR3JhcGhpY3NcbiAqIEBwYXJhbSBncmFwaGljc0RhdGEge0dyYXBoaWNzfSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IHRvIHVwZGF0ZVxuICogQHBhcmFtIGdsIHtXZWJHTENvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuICovXG5QSVhJLldlYkdMR3JhcGhpY3MudXBkYXRlR3JhcGhpY3MgPSBmdW5jdGlvbihncmFwaGljcywgZ2wpXG57XG4gICAgLy8gZ2V0IHRoZSBjb250ZXh0cyBncmFwaGljcyBvYmplY3RcbiAgICB2YXIgd2ViR0wgPSBncmFwaGljcy5fd2ViR0xbZ2wuaWRdO1xuICAgIC8vIGlmIHRoZSBncmFwaGljcyBvYmplY3QgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHdlYkdMIGNvbnRleHQgdGltZSB0byBjcmVhdGUgaXQhXG4gICAgaWYoIXdlYkdMKXdlYkdMID0gZ3JhcGhpY3MuX3dlYkdMW2dsLmlkXSA9IHtsYXN0SW5kZXg6MCwgZGF0YTpbXSwgZ2w6Z2x9O1xuXG4gICAgLy8gZmxhZyB0aGUgZ3JhcGhpY3MgYXMgbm90IGRpcnR5IGFzIHdlIGFyZSBhYm91dCB0byB1cGRhdGUgaXQuLi5cbiAgICBncmFwaGljcy5kaXJ0eSA9IGZhbHNlO1xuXG4gICAgdmFyIGk7XG5cbiAgICAvLyBpZiB0aGUgdXNlciBjbGVhcmVkIHRoZSBncmFwaGljcyBvYmplY3Qgd2Ugd2lsbCBuZWVkIHRvIGNsZWFyIGV2ZXJ5IG9iamVjdFxuICAgIGlmKGdyYXBoaWNzLmNsZWFyRGlydHkpXG4gICAge1xuICAgICAgICBncmFwaGljcy5jbGVhckRpcnR5ID0gZmFsc2U7XG5cbiAgICAgICAgLy8gbG9wIHRocm91Z2ggYW5kIHJldHVybiBhbGwgdGhlIHdlYkdMRGF0YXMgdG8gdGhlIG9iamVjdCBwb29sIHNvIHRoYW4gY2FuIGJlIHJldXNlZCBsYXRlciBvblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgd2ViR0wuZGF0YS5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGdyYXBoaWNzRGF0YSA9IHdlYkdMLmRhdGFbaV07XG4gICAgICAgICAgICBncmFwaGljc0RhdGEucmVzZXQoKTtcbiAgICAgICAgICAgIFBJWEkuV2ViR0xHcmFwaGljcy5ncmFwaGljc0RhdGFQb29sLnB1c2goIGdyYXBoaWNzRGF0YSApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIGFycmF5IGFuZCByZXNldCB0aGUgaW5kZXguLiBcbiAgICAgICAgd2ViR0wuZGF0YSA9IFtdO1xuICAgICAgICB3ZWJHTC5sYXN0SW5kZXggPSAwO1xuICAgIH1cblxuICAgIFxuICAgIHZhciB3ZWJHTERhdGE7XG4gICAgXG4gICAgLy8gbG9vcCB0aHJvdWdoIHRoZSBncmFwaGljcyBkYXRhcyBhbmQgY29uc3RydWN0IGVhY2ggb25lLi5cbiAgICAvLyBpZiB0aGUgb2JqZWN0IGlzIGEgY29tcGxleCBmaWxsIHRoZW4gdGhlIG5ldyBzdGVuY2lsIGJ1ZmZlciB0ZWNobmlxdWUgd2lsbCBiZSB1c2VkXG4gICAgLy8gb3RoZXIgd2lzZSBncmFwaGljcyBvYmplY3RzIHdpbGwgYmUgcHVzaGVkIGludG8gYSBiYXRjaC4uXG4gICAgZm9yIChpID0gd2ViR0wubGFzdEluZGV4OyBpIDwgZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGRhdGEgPSBncmFwaGljcy5ncmFwaGljc0RhdGFbaV07XG5cbiAgICAgICAgaWYoZGF0YS50eXBlID09PSBQSVhJLkdyYXBoaWNzLlBPTFkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIE1BS0UgU1VSRSBXRSBIQVZFIFRIRSBDT1JSRUNUIFRZUEUuLlxuICAgICAgICAgICAgaWYoZGF0YS5maWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmKGRhdGEucG9pbnRzLmxlbmd0aCA+IDYpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZihkYXRhLnBvaW50cy5sZW5ndGggPiA1ICogMilcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2ViR0xEYXRhID0gUElYSS5XZWJHTEdyYXBoaWNzLnN3aXRjaE1vZGUod2ViR0wsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgUElYSS5XZWJHTEdyYXBoaWNzLmJ1aWxkQ29tcGxleFBvbHkoZGF0YSwgd2ViR0xEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlYkdMRGF0YSA9IFBJWEkuV2ViR0xHcmFwaGljcy5zd2l0Y2hNb2RlKHdlYkdMLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFBJWEkuV2ViR0xHcmFwaGljcy5idWlsZFBvbHkoZGF0YSwgd2ViR0xEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZGF0YS5saW5lV2lkdGggPiAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHdlYkdMRGF0YSA9IFBJWEkuV2ViR0xHcmFwaGljcy5zd2l0Y2hNb2RlKHdlYkdMLCAwKTtcbiAgICAgICAgICAgICAgICBQSVhJLldlYkdMR3JhcGhpY3MuYnVpbGRMaW5lKGRhdGEsIHdlYkdMRGF0YSk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHdlYkdMRGF0YSA9IFBJWEkuV2ViR0xHcmFwaGljcy5zd2l0Y2hNb2RlKHdlYkdMLCAwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoZGF0YS50eXBlID09PSBQSVhJLkdyYXBoaWNzLlJFQ1QpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgUElYSS5XZWJHTEdyYXBoaWNzLmJ1aWxkUmVjdGFuZ2xlKGRhdGEsIHdlYkdMRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGRhdGEudHlwZSA9PT0gUElYSS5HcmFwaGljcy5DSVJDIHx8IGRhdGEudHlwZSA9PT0gUElYSS5HcmFwaGljcy5FTElQKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFBJWEkuV2ViR0xHcmFwaGljcy5idWlsZENpcmNsZShkYXRhLCB3ZWJHTERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihkYXRhLnR5cGUgPT09IFBJWEkuR3JhcGhpY3MuUlJFQylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBQSVhJLldlYkdMR3JhcGhpY3MuYnVpbGRSb3VuZGVkUmVjdGFuZ2xlKGRhdGEsIHdlYkdMRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIHdlYkdMLmxhc3RJbmRleCsrO1xuICAgIH1cblxuICAgIC8vIHVwbG9hZCBhbGwgdGhlIGRpcnR5IGRhdGEuLi5cbiAgICBmb3IgKGkgPSAwOyBpIDwgd2ViR0wuZGF0YS5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHdlYkdMRGF0YSA9IHdlYkdMLmRhdGFbaV07XG4gICAgICAgIGlmKHdlYkdMRGF0YS5kaXJ0eSl3ZWJHTERhdGEudXBsb2FkKCk7XG4gICAgfVxufTtcblxuXG5QSVhJLldlYkdMR3JhcGhpY3Muc3dpdGNoTW9kZSA9IGZ1bmN0aW9uKHdlYkdMLCB0eXBlKVxue1xuICAgIHZhciB3ZWJHTERhdGE7XG5cbiAgICBpZighd2ViR0wuZGF0YS5sZW5ndGgpXG4gICAge1xuICAgICAgICB3ZWJHTERhdGEgPSBQSVhJLldlYkdMR3JhcGhpY3MuZ3JhcGhpY3NEYXRhUG9vbC5wb3AoKSB8fCBuZXcgUElYSS5XZWJHTEdyYXBoaWNzRGF0YSh3ZWJHTC5nbCk7XG4gICAgICAgIHdlYkdMRGF0YS5tb2RlID0gdHlwZTtcbiAgICAgICAgd2ViR0wuZGF0YS5wdXNoKHdlYkdMRGF0YSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHdlYkdMRGF0YSA9IHdlYkdMLmRhdGFbd2ViR0wuZGF0YS5sZW5ndGgtMV07XG5cbiAgICAgICAgaWYod2ViR0xEYXRhLm1vZGUgIT09IHR5cGUgfHwgdHlwZSA9PT0gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgd2ViR0xEYXRhID0gUElYSS5XZWJHTEdyYXBoaWNzLmdyYXBoaWNzRGF0YVBvb2wucG9wKCkgfHwgbmV3IFBJWEkuV2ViR0xHcmFwaGljc0RhdGEod2ViR0wuZ2wpO1xuICAgICAgICAgICAgd2ViR0xEYXRhLm1vZGUgPSB0eXBlO1xuICAgICAgICAgICAgd2ViR0wuZGF0YS5wdXNoKHdlYkdMRGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB3ZWJHTERhdGEuZGlydHkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHdlYkdMRGF0YTtcbn07XG5cbi8qKlxuICogQnVpbGRzIGEgcmVjdGFuZ2xlIHRvIGRyYXdcbiAqXG4gKiBAc3RhdGljXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBidWlsZFJlY3RhbmdsZVxuICogQHBhcmFtIGdyYXBoaWNzRGF0YSB7R3JhcGhpY3N9IFRoZSBncmFwaGljcyBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gd2ViR0xEYXRhIHtPYmplY3R9XG4gKi9cblBJWEkuV2ViR0xHcmFwaGljcy5idWlsZFJlY3RhbmdsZSA9IGZ1bmN0aW9uKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKVxue1xuICAgIC8vIC0tLSAvL1xuICAgIC8vIG5lZWQgdG8gY29udmVydCBwb2ludHMgdG8gYSBuaWNlIHJlZ3VsYXIgZGF0YVxuICAgIC8vXG4gICAgdmFyIHJlY3REYXRhID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcbiAgICB2YXIgeCA9IHJlY3REYXRhWzBdO1xuICAgIHZhciB5ID0gcmVjdERhdGFbMV07XG4gICAgdmFyIHdpZHRoID0gcmVjdERhdGFbMl07XG4gICAgdmFyIGhlaWdodCA9IHJlY3REYXRhWzNdO1xuXG5cbiAgICBpZihncmFwaGljc0RhdGEuZmlsbClcbiAgICB7XG4gICAgICAgIHZhciBjb2xvciA9IFBJWEkuaGV4MnJnYihncmFwaGljc0RhdGEuZmlsbENvbG9yKTtcbiAgICAgICAgdmFyIGFscGhhID0gZ3JhcGhpY3NEYXRhLmZpbGxBbHBoYTtcblxuICAgICAgICB2YXIgciA9IGNvbG9yWzBdICogYWxwaGE7XG4gICAgICAgIHZhciBnID0gY29sb3JbMV0gKiBhbHBoYTtcbiAgICAgICAgdmFyIGIgPSBjb2xvclsyXSAqIGFscGhhO1xuXG4gICAgICAgIHZhciB2ZXJ0cyA9IHdlYkdMRGF0YS5wb2ludHM7XG4gICAgICAgIHZhciBpbmRpY2VzID0gd2ViR0xEYXRhLmluZGljZXM7XG5cbiAgICAgICAgdmFyIHZlcnRQb3MgPSB2ZXJ0cy5sZW5ndGgvNjtcblxuICAgICAgICAvLyBzdGFydFxuICAgICAgICB2ZXJ0cy5wdXNoKHgsIHkpO1xuICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICB2ZXJ0cy5wdXNoKHggKyB3aWR0aCwgeSk7XG4gICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgIHZlcnRzLnB1c2goeCAsIHkgKyBoZWlnaHQpO1xuICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICB2ZXJ0cy5wdXNoKHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgIC8vIGluc2VydCAyIGRlYWQgdHJpYW5nbGVzLi5cbiAgICAgICAgaW5kaWNlcy5wdXNoKHZlcnRQb3MsIHZlcnRQb3MsIHZlcnRQb3MrMSwgdmVydFBvcysyLCB2ZXJ0UG9zKzMsIHZlcnRQb3MrMyk7XG4gICAgfVxuXG4gICAgaWYoZ3JhcGhpY3NEYXRhLmxpbmVXaWR0aClcbiAgICB7XG4gICAgICAgIHZhciB0ZW1wUG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcblxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gW3gsIHksXG4gICAgICAgICAgICAgICAgICB4ICsgd2lkdGgsIHksXG4gICAgICAgICAgICAgICAgICB4ICsgd2lkdGgsIHkgKyBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICB4LCB5ICsgaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgeCwgeV07XG5cblxuICAgICAgICBQSVhJLldlYkdMR3JhcGhpY3MuYnVpbGRMaW5lKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKTtcblxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gdGVtcFBvaW50cztcbiAgICB9XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIHJvdW5kZWQgcmVjdGFuZ2xlIHRvIGRyYXdcbiAqXG4gKiBAc3RhdGljXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBidWlsZFJvdW5kZWRSZWN0YW5nbGVcbiAqIEBwYXJhbSBncmFwaGljc0RhdGEge0dyYXBoaWNzfSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xuICogQHBhcmFtIHdlYkdMRGF0YSB7T2JqZWN0fVxuICovXG5QSVhJLldlYkdMR3JhcGhpY3MuYnVpbGRSb3VuZGVkUmVjdGFuZ2xlID0gZnVuY3Rpb24oZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpXG57XG5cbiAgICB2YXIgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcbiAgICB2YXIgeCA9IHBvaW50c1swXTtcbiAgICB2YXIgeSA9IHBvaW50c1sxXTtcbiAgICB2YXIgd2lkdGggPSBwb2ludHNbMl07XG4gICAgdmFyIGhlaWdodCA9IHBvaW50c1szXTtcbiAgICB2YXIgcmFkaXVzID0gcG9pbnRzWzRdO1xuXG5cbiAgICB2YXIgcmVjUG9pbnRzID0gW107XG4gICAgcmVjUG9pbnRzLnB1c2goeCwgeSArIHJhZGl1cyk7XG4gICAgcmVjUG9pbnRzID0gcmVjUG9pbnRzLmNvbmNhdChQSVhJLldlYkdMR3JhcGhpY3MucXVhZHJhdGljQmV6aWVyQ3VydmUoeCwgeSArIGhlaWdodCAtIHJhZGl1cywgeCwgeSArIGhlaWdodCwgeCArIHJhZGl1cywgeSArIGhlaWdodCkpO1xuICAgIHJlY1BvaW50cyA9IHJlY1BvaW50cy5jb25jYXQoUElYSS5XZWJHTEdyYXBoaWNzLnF1YWRyYXRpY0JlemllckN1cnZlKHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMpKTtcbiAgICByZWNQb2ludHMgPSByZWNQb2ludHMuY29uY2F0KFBJWEkuV2ViR0xHcmFwaGljcy5xdWFkcmF0aWNCZXppZXJDdXJ2ZSh4ICsgd2lkdGgsIHkgKyByYWRpdXMsIHggKyB3aWR0aCwgeSwgeCArIHdpZHRoIC0gcmFkaXVzLCB5KSk7XG4gICAgcmVjUG9pbnRzID0gcmVjUG9pbnRzLmNvbmNhdChQSVhJLldlYkdMR3JhcGhpY3MucXVhZHJhdGljQmV6aWVyQ3VydmUoeCArIHJhZGl1cywgeSwgeCwgeSwgeCwgeSArIHJhZGl1cykpO1xuXG5cbiAgICBpZiAoZ3JhcGhpY3NEYXRhLmZpbGwpIHtcbiAgICAgICAgdmFyIGNvbG9yID0gUElYSS5oZXgycmdiKGdyYXBoaWNzRGF0YS5maWxsQ29sb3IpO1xuICAgICAgICB2YXIgYWxwaGEgPSBncmFwaGljc0RhdGEuZmlsbEFscGhhO1xuXG4gICAgICAgIHZhciByID0gY29sb3JbMF0gKiBhbHBoYTtcbiAgICAgICAgdmFyIGcgPSBjb2xvclsxXSAqIGFscGhhO1xuICAgICAgICB2YXIgYiA9IGNvbG9yWzJdICogYWxwaGE7XG5cbiAgICAgICAgdmFyIHZlcnRzID0gd2ViR0xEYXRhLnBvaW50cztcbiAgICAgICAgdmFyIGluZGljZXMgPSB3ZWJHTERhdGEuaW5kaWNlcztcblxuICAgICAgICB2YXIgdmVjUG9zID0gdmVydHMubGVuZ3RoLzY7XG5cbiAgICAgICAgdmFyIHRyaWFuZ2xlcyA9IFBJWEkuUG9seUsuVHJpYW5ndWxhdGUocmVjUG9pbnRzKTtcblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpKz0zKVxuICAgICAgICB7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2ldICsgdmVjUG9zKTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaV0gKyB2ZWNQb3MpO1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpKzFdICsgdmVjUG9zKTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSsyXSArIHZlY1Bvcyk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2krMl0gKyB2ZWNQb3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlY1BvaW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmVydHMucHVzaChyZWNQb2ludHNbaV0sIHJlY1BvaW50c1srK2ldLCByLCBnLCBiLCBhbHBoYSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ3JhcGhpY3NEYXRhLmxpbmVXaWR0aCkge1xuICAgICAgICB2YXIgdGVtcFBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG5cbiAgICAgICAgZ3JhcGhpY3NEYXRhLnBvaW50cyA9IHJlY1BvaW50cztcblxuICAgICAgICBQSVhJLldlYkdMR3JhcGhpY3MuYnVpbGRMaW5lKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKTtcblxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gdGVtcFBvaW50cztcbiAgICB9XG59O1xuXG4vKipcbiAqIENhbGN1bCB0aGUgcG9pbnRzIGZvciBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUuIChoZWxwZXIgZnVuY3Rpb24uLilcbiAqIEJhc2VkIG9uIDogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzg1MDk3L2hvdy1kby1pLWltcGxlbWVudC1hLWJlemllci1jdXJ2ZS1pbi1jXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSAgIGZyb21YIE9yaWdpbiBwb2ludCB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICAgZnJvbVkgT3JpZ2luIHBvaW50IHhcbiAqIEBwYXJhbSAge251bWJlcn0gICBjcFggICBDb250cm9sIHBvaW50IHhcbiAqIEBwYXJhbSAge251bWJlcn0gICBjcFkgICBDb250cm9sIHBvaW50IHlcbiAqIEBwYXJhbSAge251bWJlcn0gICB0b1ggICBEZXN0aW5hdGlvbiBwb2ludCB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICAgdG9ZICAgRGVzdGluYXRpb24gcG9pbnQgeVxuICogQHJldHVybiB7bnVtYmVyW119XG4gKi9cblBJWEkuV2ViR0xHcmFwaGljcy5xdWFkcmF0aWNCZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uKGZyb21YLCBmcm9tWSwgY3BYLCBjcFksIHRvWCwgdG9ZKSB7XG4gICAgdmFyIHhhLFxuICAgICAgICB5YSxcbiAgICAgICAgeGIsXG4gICAgICAgIHliLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBuID0gMjAsXG4gICAgICAgIHBvaW50cyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gZ2V0UHQobjEgLCBuMiwgcGVyYykge1xuICAgICAgICB2YXIgZGlmZiA9IG4yIC0gbjE7XG5cbiAgICAgICAgcmV0dXJuIG4xICsgKCBkaWZmICogcGVyYyApO1xuICAgIH1cblxuICAgIHZhciBqID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBuOyBpKysgKVxuICAgIHtcbiAgICAgICAgaiA9IGkgLyBuO1xuXG4gICAgICAgIC8vIFRoZSBHcmVlbiBMaW5lXG4gICAgICAgIHhhID0gZ2V0UHQoIGZyb21YICwgY3BYICwgaiApO1xuICAgICAgICB5YSA9IGdldFB0KCBmcm9tWSAsIGNwWSAsIGogKTtcbiAgICAgICAgeGIgPSBnZXRQdCggY3BYICwgdG9YICwgaiApO1xuICAgICAgICB5YiA9IGdldFB0KCBjcFkgLCB0b1kgLCBqICk7XG5cbiAgICAgICAgLy8gVGhlIEJsYWNrIERvdFxuICAgICAgICB4ID0gZ2V0UHQoIHhhICwgeGIgLCBqICk7XG4gICAgICAgIHkgPSBnZXRQdCggeWEgLCB5YiAsIGogKTtcblxuICAgICAgICBwb2ludHMucHVzaCh4LCB5KTtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50cztcbn07XG5cbi8qKlxuICogQnVpbGRzIGEgY2lyY2xlIHRvIGRyYXdcbiAqXG4gKiBAc3RhdGljXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBidWlsZENpcmNsZVxuICogQHBhcmFtIGdyYXBoaWNzRGF0YSB7R3JhcGhpY3N9IFRoZSBncmFwaGljcyBvYmplY3QgdG8gZHJhd1xuICogQHBhcmFtIHdlYkdMRGF0YSB7T2JqZWN0fVxuICovXG5QSVhJLldlYkdMR3JhcGhpY3MuYnVpbGRDaXJjbGUgPSBmdW5jdGlvbihncmFwaGljc0RhdGEsIHdlYkdMRGF0YSlcbntcbiAgICBcbiAgICAvLyBuZWVkIHRvIGNvbnZlcnQgcG9pbnRzIHRvIGEgbmljZSByZWd1bGFyIGRhdGFcbiAgICB2YXIgcmVjdERhdGEgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuICAgIHZhciB4ID0gcmVjdERhdGFbMF07XG4gICAgdmFyIHkgPSByZWN0RGF0YVsxXTtcbiAgICB2YXIgd2lkdGggPSByZWN0RGF0YVsyXTtcbiAgICB2YXIgaGVpZ2h0ID0gcmVjdERhdGFbM107XG5cbiAgICB2YXIgdG90YWxTZWdzID0gNDA7XG4gICAgdmFyIHNlZyA9IChNYXRoLlBJICogMikgLyB0b3RhbFNlZ3MgO1xuXG4gICAgdmFyIGkgPSAwO1xuXG4gICAgaWYoZ3JhcGhpY3NEYXRhLmZpbGwpXG4gICAge1xuICAgICAgICB2YXIgY29sb3IgPSBQSVhJLmhleDJyZ2IoZ3JhcGhpY3NEYXRhLmZpbGxDb2xvcik7XG4gICAgICAgIHZhciBhbHBoYSA9IGdyYXBoaWNzRGF0YS5maWxsQWxwaGE7XG5cbiAgICAgICAgdmFyIHIgPSBjb2xvclswXSAqIGFscGhhO1xuICAgICAgICB2YXIgZyA9IGNvbG9yWzFdICogYWxwaGE7XG4gICAgICAgIHZhciBiID0gY29sb3JbMl0gKiBhbHBoYTtcblxuICAgICAgICB2YXIgdmVydHMgPSB3ZWJHTERhdGEucG9pbnRzO1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHdlYkdMRGF0YS5pbmRpY2VzO1xuXG4gICAgICAgIHZhciB2ZWNQb3MgPSB2ZXJ0cy5sZW5ndGgvNjtcblxuICAgICAgICBpbmRpY2VzLnB1c2godmVjUG9zKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxTZWdzICsgMSA7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmVydHMucHVzaCh4LHksIHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAgICAgdmVydHMucHVzaCh4ICsgTWF0aC5zaW4oc2VnICogaSkgKiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgeSArIE1hdGguY29zKHNlZyAqIGkpICogaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICByLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgICAgIGluZGljZXMucHVzaCh2ZWNQb3MrKywgdmVjUG9zKyspO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kaWNlcy5wdXNoKHZlY1Bvcy0xKTtcbiAgICB9XG5cbiAgICBpZihncmFwaGljc0RhdGEubGluZVdpZHRoKVxuICAgIHtcbiAgICAgICAgdmFyIHRlbXBQb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuXG4gICAgICAgIGdyYXBoaWNzRGF0YS5wb2ludHMgPSBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxTZWdzICsgMTsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzLnB1c2goeCArIE1hdGguc2luKHNlZyAqIGkpICogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSArIE1hdGguY29zKHNlZyAqIGkpICogaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIFBJWEkuV2ViR0xHcmFwaGljcy5idWlsZExpbmUoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpO1xuXG4gICAgICAgIGdyYXBoaWNzRGF0YS5wb2ludHMgPSB0ZW1wUG9pbnRzO1xuICAgIH1cbn07XG5cbi8qKlxuICogQnVpbGRzIGEgbGluZSB0byBkcmF3XG4gKlxuICogQHN0YXRpY1xuICogQHByaXZhdGVcbiAqIEBtZXRob2QgYnVpbGRMaW5lXG4gKiBAcGFyYW0gZ3JhcGhpY3NEYXRhIHtHcmFwaGljc30gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcbiAqIEBwYXJhbSB3ZWJHTERhdGEge09iamVjdH1cbiAqL1xuUElYSS5XZWJHTEdyYXBoaWNzLmJ1aWxkTGluZSA9IGZ1bmN0aW9uKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKVxue1xuICAgIC8vIFRPRE8gT1BUSU1JU0UhXG4gICAgdmFyIGkgPSAwO1xuXG4gICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG4gICAgaWYocG9pbnRzLmxlbmd0aCA9PT0gMClyZXR1cm47XG5cbiAgICAvLyBpZiB0aGUgbGluZSB3aWR0aCBpcyBhbiBvZGQgbnVtYmVyIGFkZCAwLjUgdG8gYWxpZ24gdG8gYSB3aG9sZSBwaXhlbFxuICAgIGlmKGdyYXBoaWNzRGF0YS5saW5lV2lkdGglMilcbiAgICB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBvaW50c1tpXSArPSAwLjU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBnZXQgZmlyc3QgYW5kIGxhc3QgcG9pbnQuLiBmaWd1cmUgb3V0IHRoZSBtaWRkbGUhXG4gICAgdmFyIGZpcnN0UG9pbnQgPSBuZXcgUElYSS5Qb2ludCggcG9pbnRzWzBdLCBwb2ludHNbMV0gKTtcbiAgICB2YXIgbGFzdFBvaW50ID0gbmV3IFBJWEkuUG9pbnQoIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0sIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0gKTtcblxuICAgIC8vIGlmIHRoZSBmaXJzdCBwb2ludCBpcyB0aGUgbGFzdCBwb2ludCAtIGdvbm5hIGhhdmUgaXNzdWVzIDopXG4gICAgaWYoZmlyc3RQb2ludC54ID09PSBsYXN0UG9pbnQueCAmJiBmaXJzdFBvaW50LnkgPT09IGxhc3RQb2ludC55KVxuICAgIHtcbiAgICAgICAgLy8gbmVlZCB0byBjbG9uZSBhcyB3ZSBhcmUgZ29pbmcgdG8gc2xpZ2h0bHkgbW9kaWZ5IHRoZSBzaGFwZS4uXG4gICAgICAgIHBvaW50cyA9IHBvaW50cy5zbGljZSgpO1xuXG4gICAgICAgIHBvaW50cy5wb3AoKTtcbiAgICAgICAgcG9pbnRzLnBvcCgpO1xuXG4gICAgICAgIGxhc3RQb2ludCA9IG5ldyBQSVhJLlBvaW50KCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdLCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdICk7XG5cbiAgICAgICAgdmFyIG1pZFBvaW50WCA9IGxhc3RQb2ludC54ICsgKGZpcnN0UG9pbnQueCAtIGxhc3RQb2ludC54KSAqMC41O1xuICAgICAgICB2YXIgbWlkUG9pbnRZID0gbGFzdFBvaW50LnkgKyAoZmlyc3RQb2ludC55IC0gbGFzdFBvaW50LnkpICowLjU7XG5cbiAgICAgICAgcG9pbnRzLnVuc2hpZnQobWlkUG9pbnRYLCBtaWRQb2ludFkpO1xuICAgICAgICBwb2ludHMucHVzaChtaWRQb2ludFgsIG1pZFBvaW50WSk7XG4gICAgfVxuXG4gICAgdmFyIHZlcnRzID0gd2ViR0xEYXRhLnBvaW50cztcbiAgICB2YXIgaW5kaWNlcyA9IHdlYkdMRGF0YS5pbmRpY2VzO1xuICAgIHZhciBsZW5ndGggPSBwb2ludHMubGVuZ3RoIC8gMjtcbiAgICB2YXIgaW5kZXhDb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgdmFyIGluZGV4U3RhcnQgPSB2ZXJ0cy5sZW5ndGgvNjtcblxuICAgIC8vIERSQVcgdGhlIExpbmVcbiAgICB2YXIgd2lkdGggPSBncmFwaGljc0RhdGEubGluZVdpZHRoIC8gMjtcblxuICAgIC8vIHNvcnQgY29sb3JcbiAgICB2YXIgY29sb3IgPSBQSVhJLmhleDJyZ2IoZ3JhcGhpY3NEYXRhLmxpbmVDb2xvcik7XG4gICAgdmFyIGFscGhhID0gZ3JhcGhpY3NEYXRhLmxpbmVBbHBoYTtcbiAgICB2YXIgciA9IGNvbG9yWzBdICogYWxwaGE7XG4gICAgdmFyIGcgPSBjb2xvclsxXSAqIGFscGhhO1xuICAgIHZhciBiID0gY29sb3JbMl0gKiBhbHBoYTtcblxuICAgIHZhciBweCwgcHksIHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3k7XG4gICAgdmFyIHBlcnB4LCBwZXJweSwgcGVycDJ4LCBwZXJwMnksIHBlcnAzeCwgcGVycDN5O1xuICAgIHZhciBhMSwgYjEsIGMxLCBhMiwgYjIsIGMyO1xuICAgIHZhciBkZW5vbSwgcGRpc3QsIGRpc3Q7XG5cbiAgICBwMXggPSBwb2ludHNbMF07XG4gICAgcDF5ID0gcG9pbnRzWzFdO1xuXG4gICAgcDJ4ID0gcG9pbnRzWzJdO1xuICAgIHAyeSA9IHBvaW50c1szXTtcblxuICAgIHBlcnB4ID0gLShwMXkgLSBwMnkpO1xuICAgIHBlcnB5ID0gIHAxeCAtIHAyeDtcblxuICAgIGRpc3QgPSBNYXRoLnNxcnQocGVycHgqcGVycHggKyBwZXJweSpwZXJweSk7XG5cbiAgICBwZXJweCAvPSBkaXN0O1xuICAgIHBlcnB5IC89IGRpc3Q7XG4gICAgcGVycHggKj0gd2lkdGg7XG4gICAgcGVycHkgKj0gd2lkdGg7XG5cbiAgICAvLyBzdGFydFxuICAgIHZlcnRzLnB1c2gocDF4IC0gcGVycHggLCBwMXkgLSBwZXJweSxcbiAgICAgICAgICAgICAgICByLCBnLCBiLCBhbHBoYSk7XG5cbiAgICB2ZXJ0cy5wdXNoKHAxeCArIHBlcnB4ICwgcDF5ICsgcGVycHksXG4gICAgICAgICAgICAgICAgciwgZywgYiwgYWxwaGEpO1xuXG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aC0xOyBpKyspXG4gICAge1xuICAgICAgICBwMXggPSBwb2ludHNbKGktMSkqMl07XG4gICAgICAgIHAxeSA9IHBvaW50c1soaS0xKSoyICsgMV07XG5cbiAgICAgICAgcDJ4ID0gcG9pbnRzWyhpKSoyXTtcbiAgICAgICAgcDJ5ID0gcG9pbnRzWyhpKSoyICsgMV07XG5cbiAgICAgICAgcDN4ID0gcG9pbnRzWyhpKzEpKjJdO1xuICAgICAgICBwM3kgPSBwb2ludHNbKGkrMSkqMiArIDFdO1xuXG4gICAgICAgIHBlcnB4ID0gLShwMXkgLSBwMnkpO1xuICAgICAgICBwZXJweSA9IHAxeCAtIHAyeDtcblxuICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KHBlcnB4KnBlcnB4ICsgcGVycHkqcGVycHkpO1xuICAgICAgICBwZXJweCAvPSBkaXN0O1xuICAgICAgICBwZXJweSAvPSBkaXN0O1xuICAgICAgICBwZXJweCAqPSB3aWR0aDtcbiAgICAgICAgcGVycHkgKj0gd2lkdGg7XG5cbiAgICAgICAgcGVycDJ4ID0gLShwMnkgLSBwM3kpO1xuICAgICAgICBwZXJwMnkgPSBwMnggLSBwM3g7XG5cbiAgICAgICAgZGlzdCA9IE1hdGguc3FydChwZXJwMngqcGVycDJ4ICsgcGVycDJ5KnBlcnAyeSk7XG4gICAgICAgIHBlcnAyeCAvPSBkaXN0O1xuICAgICAgICBwZXJwMnkgLz0gZGlzdDtcbiAgICAgICAgcGVycDJ4ICo9IHdpZHRoO1xuICAgICAgICBwZXJwMnkgKj0gd2lkdGg7XG5cbiAgICAgICAgYTEgPSAoLXBlcnB5ICsgcDF5KSAtICgtcGVycHkgKyBwMnkpO1xuICAgICAgICBiMSA9ICgtcGVycHggKyBwMngpIC0gKC1wZXJweCArIHAxeCk7XG4gICAgICAgIGMxID0gKC1wZXJweCArIHAxeCkgKiAoLXBlcnB5ICsgcDJ5KSAtICgtcGVycHggKyBwMngpICogKC1wZXJweSArIHAxeSk7XG4gICAgICAgIGEyID0gKC1wZXJwMnkgKyBwM3kpIC0gKC1wZXJwMnkgKyBwMnkpO1xuICAgICAgICBiMiA9ICgtcGVycDJ4ICsgcDJ4KSAtICgtcGVycDJ4ICsgcDN4KTtcbiAgICAgICAgYzIgPSAoLXBlcnAyeCArIHAzeCkgKiAoLXBlcnAyeSArIHAyeSkgLSAoLXBlcnAyeCArIHAyeCkgKiAoLXBlcnAyeSArIHAzeSk7XG5cbiAgICAgICAgZGVub20gPSBhMSpiMiAtIGEyKmIxO1xuXG4gICAgICAgIGlmKE1hdGguYWJzKGRlbm9tKSA8IDAuMSApXG4gICAgICAgIHtcblxuICAgICAgICAgICAgZGVub20rPTEwLjE7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIHBlcnB4ICwgcDJ5IC0gcGVycHksXG4gICAgICAgICAgICAgICAgciwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCArIHBlcnB4ICwgcDJ5ICsgcGVycHksXG4gICAgICAgICAgICAgICAgciwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHB4ID0gKGIxKmMyIC0gYjIqYzEpL2Rlbm9tO1xuICAgICAgICBweSA9IChhMipjMSAtIGExKmMyKS9kZW5vbTtcblxuXG4gICAgICAgIHBkaXN0ID0gKHB4IC1wMngpICogKHB4IC1wMngpICsgKHB5IC1wMnkpICsgKHB5IC1wMnkpO1xuXG5cbiAgICAgICAgaWYocGRpc3QgPiAxNDAgKiAxNDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBlcnAzeCA9IHBlcnB4IC0gcGVycDJ4O1xuICAgICAgICAgICAgcGVycDN5ID0gcGVycHkgLSBwZXJwMnk7XG5cbiAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQocGVycDN4KnBlcnAzeCArIHBlcnAzeSpwZXJwM3kpO1xuICAgICAgICAgICAgcGVycDN4IC89IGRpc3Q7XG4gICAgICAgICAgICBwZXJwM3kgLz0gZGlzdDtcbiAgICAgICAgICAgIHBlcnAzeCAqPSB3aWR0aDtcbiAgICAgICAgICAgIHBlcnAzeSAqPSB3aWR0aDtcblxuICAgICAgICAgICAgdmVydHMucHVzaChwMnggLSBwZXJwM3gsIHAyeSAtcGVycDN5KTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCArIHBlcnAzeCwgcDJ5ICtwZXJwM3kpO1xuICAgICAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4IC0gcGVycDN4LCBwMnkgLXBlcnAzeSk7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAgICAgaW5kZXhDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHB4ICwgcHkpO1xuICAgICAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4IC0gKHB4LXAyeCksIHAyeSAtIChweSAtIHAyeSkpO1xuICAgICAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwMXggPSBwb2ludHNbKGxlbmd0aC0yKSoyXTtcbiAgICBwMXkgPSBwb2ludHNbKGxlbmd0aC0yKSoyICsgMV07XG5cbiAgICBwMnggPSBwb2ludHNbKGxlbmd0aC0xKSoyXTtcbiAgICBwMnkgPSBwb2ludHNbKGxlbmd0aC0xKSoyICsgMV07XG5cbiAgICBwZXJweCA9IC0ocDF5IC0gcDJ5KTtcbiAgICBwZXJweSA9IHAxeCAtIHAyeDtcblxuICAgIGRpc3QgPSBNYXRoLnNxcnQocGVycHgqcGVycHggKyBwZXJweSpwZXJweSk7XG4gICAgcGVycHggLz0gZGlzdDtcbiAgICBwZXJweSAvPSBkaXN0O1xuICAgIHBlcnB4ICo9IHdpZHRoO1xuICAgIHBlcnB5ICo9IHdpZHRoO1xuXG4gICAgdmVydHMucHVzaChwMnggLSBwZXJweCAsIHAyeSAtIHBlcnB5KTtcbiAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgIHZlcnRzLnB1c2gocDJ4ICsgcGVycHggLCBwMnkgKyBwZXJweSk7XG4gICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICBpbmRpY2VzLnB1c2goaW5kZXhTdGFydCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaW5kZXhDb3VudDsgaSsrKVxuICAgIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKGluZGV4U3RhcnQrKyk7XG4gICAgfVxuXG4gICAgaW5kaWNlcy5wdXNoKGluZGV4U3RhcnQtMSk7XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIGNvbXBsZXggcG9seWdvbiB0byBkcmF3XG4gKlxuICogQHN0YXRpY1xuICogQHByaXZhdGVcbiAqIEBtZXRob2QgYnVpbGRQb2x5XG4gKiBAcGFyYW0gZ3JhcGhpY3NEYXRhIHtHcmFwaGljc30gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcbiAqIEBwYXJhbSB3ZWJHTERhdGEge09iamVjdH1cbiAqL1xuUElYSS5XZWJHTEdyYXBoaWNzLmJ1aWxkQ29tcGxleFBvbHkgPSBmdW5jdGlvbihncmFwaGljc0RhdGEsIHdlYkdMRGF0YSlcbntcblxuICAgIC8vVE9ETyAtIG5vIG5lZWQgdG8gY29weSB0aGlzIGFzIGl0IGdldHMgdHVybmVkIGludG8gYSBGTG9hdDMyQXJyYXkgYW55d2F5cy4uXG4gICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHMuc2xpY2UoKTtcbiAgICBpZihwb2ludHMubGVuZ3RoIDwgNilyZXR1cm47XG5cbiAgICAvLyBnZXQgZmlyc3QgYW5kIGxhc3QgcG9pbnQuLiBmaWd1cmUgb3V0IHRoZSBtaWRkbGUhXG4gICAgdmFyIGluZGljZXMgPSB3ZWJHTERhdGEuaW5kaWNlcztcbiAgICB3ZWJHTERhdGEucG9pbnRzID0gcG9pbnRzO1xuICAgIHdlYkdMRGF0YS5hbHBoYSA9IGdyYXBoaWNzRGF0YS5maWxsQWxwaGE7XG4gICAgd2ViR0xEYXRhLmNvbG9yID0gUElYSS5oZXgycmdiKGdyYXBoaWNzRGF0YS5maWxsQ29sb3IpO1xuXG4gICAgLypcbiAgICAgICAgY2FsY2xhdGUgdGhlIGJvdW5kcy4uXG4gICAgKi9cbiAgICB2YXIgbWluWCA9IEluZmluaXR5O1xuICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xuXG4gICAgdmFyIG1pblkgPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcblxuICAgIHZhciB4LHk7XG5cbiAgICAvLyBnZXQgc2l6ZS4uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKz0yKVxuICAgIHtcbiAgICAgICAgeCA9IHBvaW50c1tpXTtcbiAgICAgICAgeSA9IHBvaW50c1tpKzFdO1xuXG4gICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcblxuICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGEgcXVhZCB0byB0aGUgZW5kIGNvcyB0aGVyZSBpcyBubyBwb2ludCBtYWtpbmcgYW5vdGhlciBidWZmZXIhXG4gICAgcG9pbnRzLnB1c2gobWluWCwgbWluWSxcbiAgICAgICAgICAgICAgICBtYXhYLCBtaW5ZLFxuICAgICAgICAgICAgICAgIG1heFgsIG1heFksXG4gICAgICAgICAgICAgICAgbWluWCwgbWF4WSk7XG5cbiAgICAvLyBwdXNoIGEgcXVhZCBvbnRvIHRoZSBlbmQuLiBcbiAgICBcbiAgICAvL1RPRE8gLSB0aGlzIGFpbnQgbmVlZGVkIVxuICAgIHZhciBsZW5ndGggPSBwb2ludHMubGVuZ3RoIC8gMjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpbmRpY2VzLnB1c2goIGkgKTtcbiAgICB9XG5cbn07XG5cblBJWEkuV2ViR0xHcmFwaGljcy5idWlsZFBvbHkgPSBmdW5jdGlvbihncmFwaGljc0RhdGEsIHdlYkdMRGF0YSlcbntcbiAgICB2YXIgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcbiAgICBpZihwb2ludHMubGVuZ3RoIDwgNilyZXR1cm47XG5cbiAgICAvLyBnZXQgZmlyc3QgYW5kIGxhc3QgcG9pbnQuLiBmaWd1cmUgb3V0IHRoZSBtaWRkbGUhXG4gICAgdmFyIHZlcnRzID0gd2ViR0xEYXRhLnBvaW50cztcbiAgICB2YXIgaW5kaWNlcyA9IHdlYkdMRGF0YS5pbmRpY2VzO1xuXG4gICAgdmFyIGxlbmd0aCA9IHBvaW50cy5sZW5ndGggLyAyO1xuXG4gICAgLy8gc29ydCBjb2xvclxuICAgIHZhciBjb2xvciA9IFBJWEkuaGV4MnJnYihncmFwaGljc0RhdGEuZmlsbENvbG9yKTtcbiAgICB2YXIgYWxwaGEgPSBncmFwaGljc0RhdGEuZmlsbEFscGhhO1xuICAgIHZhciByID0gY29sb3JbMF0gKiBhbHBoYTtcbiAgICB2YXIgZyA9IGNvbG9yWzFdICogYWxwaGE7XG4gICAgdmFyIGIgPSBjb2xvclsyXSAqIGFscGhhO1xuXG4gICAgdmFyIHRyaWFuZ2xlcyA9IFBJWEkuUG9seUsuVHJpYW5ndWxhdGUocG9pbnRzKTtcbiAgICB2YXIgdmVydFBvcyA9IHZlcnRzLmxlbmd0aCAvIDY7XG5cbiAgICB2YXIgaSA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSs9MylcbiAgICB7XG4gICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaV0gKyB2ZXJ0UG9zKTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpXSArIHZlcnRQb3MpO1xuICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2krMV0gKyB2ZXJ0UG9zKTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpKzJdICt2ZXJ0UG9zKTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpKzJdICsgdmVydFBvcyk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmVydHMucHVzaChwb2ludHNbaSAqIDJdLCBwb2ludHNbaSAqIDIgKyAxXSxcbiAgICAgICAgICAgICAgICAgICByLCBnLCBiLCBhbHBoYSk7XG4gICAgfVxuXG59O1xuXG5QSVhJLldlYkdMR3JhcGhpY3MuZ3JhcGhpY3NEYXRhUG9vbCA9IFtdO1xuXG5QSVhJLldlYkdMR3JhcGhpY3NEYXRhID0gZnVuY3Rpb24oZ2wpXG57XG4gICAgdGhpcy5nbCA9IGdsO1xuXG4gICAgLy9UT0RPIGRvZXMgdGhpcyBuZWVkIHRvIGJlIHNwbGl0IGJlZm9yZSB1cGxvZGluZz8/XG4gICAgdGhpcy5jb2xvciA9IFswLDAsMF07IC8vIGNvbG9yIHNwbGl0IVxuICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgdGhpcy5pbmRpY2VzID0gW107XG4gICAgdGhpcy5sYXN0SW5kZXggPSAwO1xuICAgIHRoaXMuYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMubW9kZSA9IDE7XG4gICAgdGhpcy5hbHBoYSA9IDE7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG59O1xuXG5QSVhJLldlYkdMR3JhcGhpY3NEYXRhLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgIHRoaXMuaW5kaWNlcyA9IFtdO1xuICAgIHRoaXMubGFzdEluZGV4ID0gMDtcbn07XG5cblBJWEkuV2ViR0xHcmFwaGljc0RhdGEucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4vLyAgICB0aGlzLmxhc3RJbmRleCA9IGdyYXBoaWNzLmdyYXBoaWNzRGF0YS5sZW5ndGg7XG4gICAgdGhpcy5nbFBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5wb2ludHMpO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5nbFBvaW50cywgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgdGhpcy5nbEluZGljaWVzID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuaW5kaWNlcyk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmdsSW5kaWNpZXMsIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuUElYSS5nbENvbnRleHRzID0gW107IC8vIHRoaXMgaXMgd2hlcmUgd2Ugc3RvcmUgdGhlIHdlYkdMIGNvbnRleHRzIGZvciBlYXN5IGFjY2Vzcy5cblxuLyoqXG4gKiB0aGUgV2ViR0xSZW5kZXJlciBkcmF3cyB0aGUgc3RhZ2UgYW5kIGFsbCBpdHMgY29udGVudCBvbnRvIGEgd2ViR0wgZW5hYmxlZCBjYW52YXMuIFRoaXMgcmVuZGVyZXJcbiAqIHNob3VsZCBiZSB1c2VkIGZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgd2ViR0wuIFRoaXMgUmVuZGVyIHdvcmtzIGJ5IGF1dG9tYXRpY2FsbHkgbWFuYWdpbmcgd2ViR0xCYXRjaCdzLlxuICogU28gbm8gbmVlZCBmb3IgU3ByaXRlIEJhdGNoJ3Mgb3IgU3ByaXRlIENsb3VkJ3NcbiAqIERvbnQgZm9yZ2V0IHRvIGFkZCB0aGUgdmlldyB0byB5b3VyIERPTSBvciB5b3Ugd2lsbCBub3Qgc2VlIGFueXRoaW5nIDopXG4gKlxuICogQGNsYXNzIFdlYkdMUmVuZGVyZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHdpZHRoPTAge051bWJlcn0gdGhlIHdpZHRoIG9mIHRoZSBjYW52YXMgdmlld1xuICogQHBhcmFtIGhlaWdodD0wIHtOdW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIGNhbnZhcyB2aWV3XG4gKiBAcGFyYW0gdmlldyB7SFRNTENhbnZhc0VsZW1lbnR9IHRoZSBjYW52YXMgdG8gdXNlIGFzIGEgdmlldywgb3B0aW9uYWxcbiAqIEBwYXJhbSB0cmFuc3BhcmVudD1mYWxzZSB7Qm9vbGVhbn0gSWYgdGhlIHJlbmRlciB2aWV3IGlzIHRyYW5zcGFyZW50LCBkZWZhdWx0IGZhbHNlXG4gKiBAcGFyYW0gYW50aWFsaWFzPWZhbHNlIHtCb29sZWFufSBzZXRzIGFudGlhbGlhcyAob25seSBhcHBsaWNhYmxlIGluIGNocm9tZSBhdCB0aGUgbW9tZW50KVxuICogQHBhcmFtIHByZXNlcnZlRHJhd2luZ0J1ZmZlcj1mYWxzZSB7Qm9vbGVhbn0gZW5hYmxlcyBkcmF3aW5nIGJ1ZmZlciBwcmVzZXJ2YXRpb24sIGVuYWJsZSB0aGlzIGlmIHlvdSBuZWVkIHRvIGNhbGwgdG9EYXRhVXJsIG9uIHRoZSB3ZWJnbCBjb250ZXh0XG4gKlxuICovXG5QSVhJLldlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCB2aWV3LCB0cmFuc3BhcmVudCwgYW50aWFsaWFzLCBwcmVzZXJ2ZURyYXdpbmdCdWZmZXIpXG57XG4gICAgaWYoIVBJWEkuZGVmYXVsdFJlbmRlcmVyKVxuICAgIHtcbiAgICAgICAgUElYSS5zYXlIZWxsbygnd2ViR0wnKTtcbiAgICAgICAgUElYSS5kZWZhdWx0UmVuZGVyZXIgPSB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMudHlwZSA9IFBJWEkuV0VCR0xfUkVOREVSRVI7XG5cbiAgICAvLyBkbyBhIGNhdGNoLi4gb25seSAxIHdlYkdMIHJlbmRlcmVyLi5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSByZW5kZXIgdmlldyBpcyB0cmFuc3BhcmVudFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRyYW5zcGFyZW50XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMudHJhbnNwYXJlbnQgPSAhIXRyYW5zcGFyZW50O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIG9mIHRoZSBwcmVzZXJ2ZURyYXdpbmdCdWZmZXIgZmxhZyBhZmZlY3RzIHdoZXRoZXIgb3Igbm90IHRoZSBjb250ZW50cyBvZiB0aGUgc3RlbmNpbCBidWZmZXIgaXMgcmV0YWluZWQgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHByZXNlcnZlRHJhd2luZ0J1ZmZlclxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IHByZXNlcnZlRHJhd2luZ0J1ZmZlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIHZpZXdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB3aWR0aFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDgwMFxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCA4MDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBjYW52YXMgdmlld1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IGhlaWdodFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDYwMFxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDYwMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjYW52YXMgZWxlbWVudCB0aGF0IGV2ZXJ5dGhpbmcgaXMgZHJhd24gdG9cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB2aWV3XG4gICAgICogQHR5cGUgSFRNTENhbnZhc0VsZW1lbnRcbiAgICAgKi9cbiAgICB0aGlzLnZpZXcgPSB2aWV3IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG4gICAgdGhpcy52aWV3LndpZHRoID0gdGhpcy53aWR0aDtcbiAgICB0aGlzLnZpZXcuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cbiAgICAvLyBkZWFsIHdpdGggbG9zaW5nIGNvbnRleHQuLlxuICAgIHRoaXMuY29udGV4dExvc3QgPSB0aGlzLmhhbmRsZUNvbnRleHRMb3N0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5jb250ZXh0UmVzdG9yZWRMb3N0ID0gdGhpcy5oYW5kbGVDb250ZXh0UmVzdG9yZWQuYmluZCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLnZpZXcuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIHRoaXMuY29udGV4dExvc3QsIGZhbHNlKTtcbiAgICB0aGlzLnZpZXcuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCB0aGlzLmNvbnRleHRSZXN0b3JlZExvc3QsIGZhbHNlKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgYWxwaGE6IHRoaXMudHJhbnNwYXJlbnQsXG4gICAgICAgIGFudGlhbGlhczohIWFudGlhbGlhcywgLy8gU1BFRUQgVVA/P1xuICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6ISF0cmFuc3BhcmVudCxcbiAgICAgICAgc3RlbmNpbDp0cnVlLFxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHByZXNlcnZlRHJhd2luZ0J1ZmZlclxuICAgIH07XG5cbiAgICB2YXIgZ2wgPSBudWxsO1xuXG4gICAgWydleHBlcmltZW50YWwtd2ViZ2wnLCAnd2ViZ2wnXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGdsID0gZ2wgfHwgdGhpcy52aWV3LmdldENvbnRleHQobmFtZSwgIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH0gY2F0Y2goZSkge31cbiAgICB9LCB0aGlzKTtcblxuICAgIGlmICghZ2wpIHtcbiAgICAgICAgLy8gZmFpbCwgbm90IGFibGUgdG8gZ2V0IGEgY29udGV4dFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHdlYkdMLiBUcnkgdXNpbmcgdGhlIGNhbnZhcyByZW5kZXJlcicgKyB0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy5nbENvbnRleHRJZCA9IGdsLmlkID0gUElYSS5XZWJHTFJlbmRlcmVyLmdsQ29udGV4dElkICsrO1xuXG4gICAgUElYSS5nbENvbnRleHRzW3RoaXMuZ2xDb250ZXh0SWRdID0gZ2w7XG5cbiAgICBpZighUElYSS5ibGVuZE1vZGVzV2ViR0wpXG4gICAge1xuICAgICAgICBQSVhJLmJsZW5kTW9kZXNXZWJHTCA9IFtdO1xuXG4gICAgICAgIFBJWEkuYmxlbmRNb2Rlc1dlYkdMW1BJWEkuYmxlbmRNb2Rlcy5OT1JNQUxdICAgICAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBQSVhJLmJsZW5kTW9kZXNXZWJHTFtQSVhJLmJsZW5kTW9kZXMuQUREXSAgICAgICAgICAgPSBbZ2wuU1JDX0FMUEhBLCBnbC5EU1RfQUxQSEFdO1xuICAgICAgICBQSVhJLmJsZW5kTW9kZXNXZWJHTFtQSVhJLmJsZW5kTW9kZXMuTVVMVElQTFldICAgICAgPSBbZ2wuRFNUX0NPTE9SLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgUElYSS5ibGVuZE1vZGVzV2ViR0xbUElYSS5ibGVuZE1vZGVzLlNDUkVFTl0gICAgICAgID0gW2dsLlNSQ19BTFBIQSwgZ2wuT05FXTtcbiAgICAgICAgUElYSS5ibGVuZE1vZGVzV2ViR0xbUElYSS5ibGVuZE1vZGVzLk9WRVJMQVldICAgICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIFBJWEkuYmxlbmRNb2Rlc1dlYkdMW1BJWEkuYmxlbmRNb2Rlcy5EQVJLRU5dICAgICAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBQSVhJLmJsZW5kTW9kZXNXZWJHTFtQSVhJLmJsZW5kTW9kZXMuTElHSFRFTl0gICAgICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgUElYSS5ibGVuZE1vZGVzV2ViR0xbUElYSS5ibGVuZE1vZGVzLkNPTE9SX0RPREdFXSAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIFBJWEkuYmxlbmRNb2Rlc1dlYkdMW1BJWEkuYmxlbmRNb2Rlcy5DT0xPUl9CVVJOXSAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBQSVhJLmJsZW5kTW9kZXNXZWJHTFtQSVhJLmJsZW5kTW9kZXMuSEFSRF9MSUdIVF0gICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgUElYSS5ibGVuZE1vZGVzV2ViR0xbUElYSS5ibGVuZE1vZGVzLlNPRlRfTElHSFRdICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIFBJWEkuYmxlbmRNb2Rlc1dlYkdMW1BJWEkuYmxlbmRNb2Rlcy5ESUZGRVJFTkNFXSAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBQSVhJLmJsZW5kTW9kZXNXZWJHTFtQSVhJLmJsZW5kTW9kZXMuRVhDTFVTSU9OXSAgICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgUElYSS5ibGVuZE1vZGVzV2ViR0xbUElYSS5ibGVuZE1vZGVzLkhVRV0gICAgICAgICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIFBJWEkuYmxlbmRNb2Rlc1dlYkdMW1BJWEkuYmxlbmRNb2Rlcy5TQVRVUkFUSU9OXSAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBQSVhJLmJsZW5kTW9kZXNXZWJHTFtQSVhJLmJsZW5kTW9kZXMuQ09MT1JdICAgICAgICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgUElYSS5ibGVuZE1vZGVzV2ViR0xbUElYSS5ibGVuZE1vZGVzLkxVTUlOT1NJVFldICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgfVxuXG5cblxuXG4gICAgdGhpcy5wcm9qZWN0aW9uID0gbmV3IFBJWEkuUG9pbnQoKTtcbiAgICB0aGlzLnByb2plY3Rpb24ueCA9ICB0aGlzLndpZHRoLzI7XG4gICAgdGhpcy5wcm9qZWN0aW9uLnkgPSAgLXRoaXMuaGVpZ2h0LzI7XG5cbiAgICB0aGlzLm9mZnNldCA9IG5ldyBQSVhJLlBvaW50KDAsIDApO1xuXG4gICAgdGhpcy5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIHRoaXMuY29udGV4dExvc3QgPSBmYWxzZTtcblxuICAgIC8vIHRpbWUgdG8gY3JlYXRlIHRoZSByZW5kZXIgbWFuYWdlcnMhIGVhY2ggb25lIGZvY3VzZXMgb24gbWFuYWdpbmUgYSBzdGF0ZSBpbiB3ZWJHTFxuICAgIHRoaXMuc2hhZGVyTWFuYWdlciA9IG5ldyBQSVhJLldlYkdMU2hhZGVyTWFuYWdlcihnbCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlYWxzIHdpdGggbWFuYWdpbmcgdGhlIHNoYWRlciBwcm9ncmFtcyBhbmQgdGhlaXIgYXR0cmlic1xuICAgIHRoaXMuc3ByaXRlQmF0Y2ggPSBuZXcgUElYSS5XZWJHTFNwcml0ZUJhdGNoKGdsKTsgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hbmFnZXMgdGhlIHJlbmRlcmluZyBvZiBzcHJpdGVzXG4gICAgLy90aGlzLnByaW1pdGl2ZUJhdGNoID0gbmV3IFBJWEkuV2ViR0xQcmltaXRpdmVCYXRjaChnbCk7ICAgICAgICAgICAgICAgLy8gcHJpbWl0aXZlIGJhdGNoIHJlbmRlcmVyXG4gICAgdGhpcy5tYXNrTWFuYWdlciA9IG5ldyBQSVhJLldlYkdMTWFza01hbmFnZXIoZ2wpOyAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFuYWdlcyB0aGUgbWFza3MgdXNpbmcgdGhlIHN0ZW5jaWwgYnVmZmVyXG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gbmV3IFBJWEkuV2ViR0xGaWx0ZXJNYW5hZ2VyKGdsLCB0aGlzLnRyYW5zcGFyZW50KTsgLy8gbWFuYWdlcyB0aGUgZmlsdGVyc1xuICAgIHRoaXMuc3RlbmNpbE1hbmFnZXIgPSBuZXcgUElYSS5XZWJHTFN0ZW5jaWxNYW5hZ2VyKGdsKTtcbiAgICB0aGlzLmJsZW5kTW9kZU1hbmFnZXIgPSBuZXcgUElYSS5XZWJHTEJsZW5kTW9kZU1hbmFnZXIoZ2wpO1xuXG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uID0ge307XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLmdsID0gdGhpcy5nbDtcbiAgICB0aGlzLnJlbmRlclNlc3Npb24uZHJhd0NvdW50ID0gMDtcbiAgICB0aGlzLnJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlciA9IHRoaXMuc2hhZGVyTWFuYWdlcjtcbiAgICB0aGlzLnJlbmRlclNlc3Npb24ubWFza01hbmFnZXIgPSB0aGlzLm1hc2tNYW5hZ2VyO1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5maWx0ZXJNYW5hZ2VyID0gdGhpcy5maWx0ZXJNYW5hZ2VyO1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5ibGVuZE1vZGVNYW5hZ2VyID0gdGhpcy5ibGVuZE1vZGVNYW5hZ2VyO1xuICAgLy8gdGhpcy5yZW5kZXJTZXNzaW9uLnByaW1pdGl2ZUJhdGNoID0gdGhpcy5wcmltaXRpdmVCYXRjaDtcbiAgICB0aGlzLnJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2ggPSB0aGlzLnNwcml0ZUJhdGNoO1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5zdGVuY2lsTWFuYWdlciA9IHRoaXMuc3RlbmNpbE1hbmFnZXI7XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLnJlbmRlcmVyID0gdGhpcztcblxuICAgIGdsLnVzZVByb2dyYW0odGhpcy5zaGFkZXJNYW5hZ2VyLmRlZmF1bHRTaGFkZXIucHJvZ3JhbSk7XG5cbiAgICBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgIGdsLmRpc2FibGUoZ2wuQ1VMTF9GQUNFKTtcblxuICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRoaXMudHJhbnNwYXJlbnQpO1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLldlYkdMUmVuZGVyZXI7XG5cbi8qKlxuICogUmVuZGVycyB0aGUgc3RhZ2UgdG8gaXRzIHdlYkdMIHZpZXdcbiAqXG4gKiBAbWV0aG9kIHJlbmRlclxuICogQHBhcmFtIHN0YWdlIHtTdGFnZX0gdGhlIFN0YWdlIGVsZW1lbnQgdG8gYmUgcmVuZGVyZWRcbiAqL1xuUElYSS5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihzdGFnZSlcbntcbiAgICBpZih0aGlzLmNvbnRleHRMb3N0KXJldHVybjtcblxuXG4gICAgLy8gaWYgcmVuZGVyaW5nIGEgbmV3IHN0YWdlIGNsZWFyIHRoZSBiYXRjaGVzLi5cbiAgICBpZih0aGlzLl9fc3RhZ2UgIT09IHN0YWdlKVxuICAgIHtcbiAgICAgICAgaWYoc3RhZ2UuaW50ZXJhY3RpdmUpc3RhZ2UuaW50ZXJhY3Rpb25NYW5hZ2VyLnJlbW92ZUV2ZW50cygpO1xuXG4gICAgICAgIC8vIFRPRE8gbWFrZSB0aGlzIHdvcmtcbiAgICAgICAgLy8gZG9udCB0aGluayB0aGlzIGlzIG5lZWRlZCBhbnkgbW9yZT9cbiAgICAgICAgdGhpcy5fX3N0YWdlID0gc3RhZ2U7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGFueSB0ZXh0dXJlcyB0aGlzIGluY2x1ZGVzIHV2cyBhbmQgdXBsb2FkaW5nIHRoZW0gdG8gdGhlIGdwdVxuICAgIFBJWEkuV2ViR0xSZW5kZXJlci51cGRhdGVUZXh0dXJlcygpO1xuXG4gICAgLy8gdXBkYXRlIHRoZSBzY2VuZSBncmFwaFxuICAgIHN0YWdlLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXG5cbiAgICAvLyBpbnRlcmFjdGlvblxuICAgIGlmKHN0YWdlLl9pbnRlcmFjdGl2ZSlcbiAgICB7XG4gICAgICAgIC8vbmVlZCB0byBhZGQgc29tZSBldmVudHMhXG4gICAgICAgIGlmKCFzdGFnZS5faW50ZXJhY3RpdmVFdmVudHNBZGRlZClcbiAgICAgICAge1xuICAgICAgICAgICAgc3RhZ2UuX2ludGVyYWN0aXZlRXZlbnRzQWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgc3RhZ2UuaW50ZXJhY3Rpb25NYW5hZ2VyLnNldFRhcmdldCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgLy8gLS0gRG9lcyB0aGlzIG5lZWQgdG8gYmUgc2V0IGV2ZXJ5IGZyYW1lPyAtLSAvL1xuICAgIC8vZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRoaXMudHJhbnNwYXJlbnQpO1xuICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgIC8vIG1ha2Ugc3VyZSB3ZSBhcmUgYm91bmQgdG8gdGhlIG1haW4gZnJhbWUgYnVmZmVyXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblxuICAgIGlmKHRoaXMudHJhbnNwYXJlbnQpXG4gICAge1xuICAgICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBnbC5jbGVhckNvbG9yKHN0YWdlLmJhY2tncm91bmRDb2xvclNwbGl0WzBdLHN0YWdlLmJhY2tncm91bmRDb2xvclNwbGl0WzFdLHN0YWdlLmJhY2tncm91bmRDb2xvclNwbGl0WzJdLCAxKTtcbiAgICB9XG5cblxuICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuXG4gICAgdGhpcy5yZW5kZXJEaXNwbGF5T2JqZWN0KCBzdGFnZSwgdGhpcy5wcm9qZWN0aW9uICk7XG5cbiAgICAvLyBpbnRlcmFjdGlvblxuICAgIGlmKHN0YWdlLmludGVyYWN0aXZlKVxuICAgIHtcbiAgICAgICAgLy9uZWVkIHRvIGFkZCBzb21lIGV2ZW50cyFcbiAgICAgICAgaWYoIXN0YWdlLl9pbnRlcmFjdGl2ZUV2ZW50c0FkZGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBzdGFnZS5faW50ZXJhY3RpdmVFdmVudHNBZGRlZCA9IHRydWU7XG4gICAgICAgICAgICBzdGFnZS5pbnRlcmFjdGlvbk1hbmFnZXIuc2V0VGFyZ2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGlmKHN0YWdlLl9pbnRlcmFjdGl2ZUV2ZW50c0FkZGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBzdGFnZS5faW50ZXJhY3RpdmVFdmVudHNBZGRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc3RhZ2UuaW50ZXJhY3Rpb25NYW5hZ2VyLnNldFRhcmdldCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgLy9jYW4gc2ltdWxhdGUgY29udGV4dCBsb3NzIGluIENocm9tZSBsaWtlIHNvOlxuICAgICB0aGlzLnZpZXcub25tb3VzZWRvd24gPSBmdW5jdGlvbihldikge1xuICAgICBjb25zb2xlLmRpcih0aGlzLmdsLmdldFN1cHBvcnRlZEV4dGVuc2lvbnMoKSk7XG4gICAgICAgIHZhciBleHQgPSAoXG4gICAgICAgICAgICBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9zY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcIilcbiAgICAgICAvLyBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1wiKSB8fFxuICAgICAgIC8vIGdsLmdldEV4dGVuc2lvbihcIk1PWl9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1wiKSB8fFxuICAgICAgIC8vIGdsLmdldEV4dGVuc2lvbihcIldFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1wiKVxuICAgICApO1xuICAgICBjb25zb2xlLmRpcihleHQpO1xuICAgICB2YXIgbG9zZUN0eCA9IHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfbG9zZV9jb250ZXh0XCIpO1xuICAgICAgY29uc29sZS5sb2coXCJraWxsaW5nIGNvbnRleHRcIik7XG4gICAgICBsb3NlQ3R4Lmxvc2VDb250ZXh0KCk7XG4gICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJyZXN0b3JpbmcgY29udGV4dC4uLlwiKTtcbiAgICAgICAgICBsb3NlQ3R4LnJlc3RvcmVDb250ZXh0KCk7XG4gICAgICB9LmJpbmQodGhpcyksIDEwMDApO1xuICAgICB9LmJpbmQodGhpcyk7XG4gICAgICovXG59O1xuXG4vKipcbiAqIFJlbmRlcnMgYSBkaXNwbGF5IE9iamVjdFxuICpcbiAqIEBtZXRob2QgcmVuZGVyRElzcGxheU9iamVjdFxuICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge0Rpc3BsYXlPYmplY3R9IFRoZSBEaXNwbGF5T2JqZWN0IHRvIHJlbmRlclxuICogQHBhcmFtIHByb2plY3Rpb24ge1BvaW50fSBUaGUgcHJvamVjdGlvblxuICogQHBhcmFtIGJ1ZmZlciB7QXJyYXl9IGEgc3RhbmRhcmQgV2ViR0wgYnVmZmVyIFxuICovXG5QSVhJLldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckRpc3BsYXlPYmplY3QgPSBmdW5jdGlvbihkaXNwbGF5T2JqZWN0LCBwcm9qZWN0aW9uLCBidWZmZXIpXG57XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLmJsZW5kTW9kZU1hbmFnZXIuc2V0QmxlbmRNb2RlKFBJWEkuYmxlbmRNb2Rlcy5OT1JNQUwpO1xuICAgIC8vIHJlc2V0IHRoZSByZW5kZXIgc2Vzc2lvbiBkYXRhLi5cbiAgICB0aGlzLnJlbmRlclNlc3Npb24uZHJhd0NvdW50ID0gMDtcbiAgICB0aGlzLnJlbmRlclNlc3Npb24uY3VycmVudEJsZW5kTW9kZSA9IDk5OTk7XG5cbiAgICB0aGlzLnJlbmRlclNlc3Npb24ucHJvamVjdGlvbiA9IHByb2plY3Rpb247XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLm9mZnNldCA9IHRoaXMub2Zmc2V0O1xuXG4gICAgLy8gc3RhcnQgdGhlIHNwcml0ZSBiYXRjaFxuICAgIHRoaXMuc3ByaXRlQmF0Y2guYmVnaW4odGhpcy5yZW5kZXJTZXNzaW9uKTtcblxuLy8gICAgdGhpcy5wcmltaXRpdmVCYXRjaC5iZWdpbih0aGlzLnJlbmRlclNlc3Npb24pO1xuXG4gICAgLy8gc3RhcnQgdGhlIGZpbHRlciBtYW5hZ2VyXG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyLmJlZ2luKHRoaXMucmVuZGVyU2Vzc2lvbiwgYnVmZmVyKTtcblxuICAgIC8vIHJlbmRlciB0aGUgc2NlbmUhXG4gICAgZGlzcGxheU9iamVjdC5fcmVuZGVyV2ViR0wodGhpcy5yZW5kZXJTZXNzaW9uKTtcblxuICAgIC8vIGZpbmlzaCB0aGUgc3ByaXRlIGJhdGNoXG4gICAgdGhpcy5zcHJpdGVCYXRjaC5lbmQoKTtcblxuLy8gICAgdGhpcy5wcmltaXRpdmVCYXRjaC5lbmQoKTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgdGV4dHVyZXMgbG9hZGVkIGludG8gdGhpcyB3ZWJnbCByZW5kZXJlclxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgdXBkYXRlVGV4dHVyZXNcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuV2ViR0xSZW5kZXJlci51cGRhdGVUZXh0dXJlcyA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgaSA9IDA7XG5cbiAgICAvL1RPRE8gYnJlYWsgdGhpcyBvdXQgaW50byBhIHRleHR1cmUgbWFuYWdlci4uLlxuICAvLyAgZm9yIChpID0gMDsgaSA8IFBJWEkudGV4dHVyZXNUb1VwZGF0ZS5sZW5ndGg7IGkrKylcbiAgLy8gICAgICBQSVhJLi51cGRhdGVXZWJHTFRleHR1cmUoUElYSS50ZXh0dXJlc1RvVXBkYXRlW2ldLCB0aGlzLmdsKTtcblxuXG4gICAgZm9yIChpPTA7IGkgPCBQSVhJLlRleHR1cmUuZnJhbWVVcGRhdGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICBQSVhJLldlYkdMUmVuZGVyZXIudXBkYXRlVGV4dHVyZUZyYW1lKFBJWEkuVGV4dHVyZS5mcmFtZVVwZGF0ZXNbaV0pO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IFBJWEkudGV4dHVyZXNUb0Rlc3Ryb3kubGVuZ3RoOyBpKyspXG4gICAgICAgIFBJWEkuV2ViR0xSZW5kZXJlci5kZXN0cm95VGV4dHVyZShQSVhJLnRleHR1cmVzVG9EZXN0cm95W2ldKTtcblxuICAgIFBJWEkudGV4dHVyZXNUb1VwZGF0ZS5sZW5ndGggPSAwO1xuICAgIFBJWEkudGV4dHVyZXNUb0Rlc3Ryb3kubGVuZ3RoID0gMDtcbiAgICBQSVhJLlRleHR1cmUuZnJhbWVVcGRhdGVzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIGEgbG9hZGVkIHdlYmdsIHRleHR1cmVcbiAqXG4gKiBAbWV0aG9kIGRlc3Ryb3lUZXh0dXJlXG4gKiBAcGFyYW0gdGV4dHVyZSB7VGV4dHVyZX0gVGhlIHRleHR1cmUgdG8gdXBkYXRlXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLldlYkdMUmVuZGVyZXIuZGVzdHJveVRleHR1cmUgPSBmdW5jdGlvbih0ZXh0dXJlKVxue1xuICAgIC8vVE9ETyBicmVhayB0aGlzIG91dCBpbnRvIGEgdGV4dHVyZSBtYW5hZ2VyLi4uXG5cbiAgICBmb3IgKHZhciBpID0gdGV4dHVyZS5fZ2xUZXh0dXJlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICB7XG4gICAgICAgIHZhciBnbFRleHR1cmUgPSB0ZXh0dXJlLl9nbFRleHR1cmVzW2ldO1xuICAgICAgICB2YXIgZ2wgPSBQSVhJLmdsQ29udGV4dHNbaV07XG5cbiAgICAgICAgaWYoZ2wgJiYgZ2xUZXh0dXJlKVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5kZWxldGVUZXh0dXJlKGdsVGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0ZXh0dXJlLl9nbFRleHR1cmVzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVRleHR1cmVGcmFtZVxuICogQHBhcmFtIHRleHR1cmUge1RleHR1cmV9IFRoZSB0ZXh0dXJlIHRvIHVwZGF0ZSB0aGUgZnJhbWUgZnJvbVxuICogQHByaXZhdGVcbiAqL1xuUElYSS5XZWJHTFJlbmRlcmVyLnVwZGF0ZVRleHR1cmVGcmFtZSA9IGZ1bmN0aW9uKHRleHR1cmUpXG57XG4gICAgLy90ZXh0dXJlLnVwZGF0ZUZyYW1lID0gZmFsc2U7XG5cbiAgICAvLyBub3cgc2V0IHRoZSB1dnMuIEZpZ3VyZWQgdGhhdCB0aGUgdXYgZGF0YSBzaXRzIHdpdGggYSB0ZXh0dXJlIHJhdGhlciB0aGFuIGEgc3ByaXRlLlxuICAgIC8vIHNvIHV2IGRhdGEgaXMgc3RvcmVkIG9uIHRoZSB0ZXh0dXJlIGl0c2VsZlxuICAgIHRleHR1cmUuX3VwZGF0ZVdlYkdMdXZzKCk7XG59O1xuXG4vKipcbiAqIHJlc2l6ZXMgdGhlIHdlYkdMIHZpZXcgdG8gdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0XG4gKlxuICogQG1ldGhvZCByZXNpemVcbiAqIEBwYXJhbSB3aWR0aCB7TnVtYmVyfSB0aGUgbmV3IHdpZHRoIG9mIHRoZSB3ZWJHTCB2aWV3XG4gKiBAcGFyYW0gaGVpZ2h0IHtOdW1iZXJ9IHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSB3ZWJHTCB2aWV3XG4gKi9cblBJWEkuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodClcbntcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICB0aGlzLnZpZXcud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLnZpZXcuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgdGhpcy5nbC52aWV3cG9ydCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cbiAgICB0aGlzLnByb2plY3Rpb24ueCA9ICB0aGlzLndpZHRoLzI7XG4gICAgdGhpcy5wcm9qZWN0aW9uLnkgPSAgLXRoaXMuaGVpZ2h0LzI7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBXZWJHTCB0ZXh0dXJlXG4gKlxuICogQG1ldGhvZCBjcmVhdGVXZWJHTFRleHR1cmVcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfSB0aGUgdGV4dHVyZSB0byByZW5kZXJcbiAqIEBwYXJhbSBnbCB7d2ViZ2xDb250ZXh0fSB0aGUgV2ViR0wgY29udGV4dFxuICogQHN0YXRpY1xuICovXG5QSVhJLmNyZWF0ZVdlYkdMVGV4dHVyZSA9IGZ1bmN0aW9uKHRleHR1cmUsIGdsKVxue1xuXG5cbiAgICBpZih0ZXh0dXJlLmhhc0xvYWRlZClcbiAgICB7XG4gICAgICAgIHRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKTtcbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0ZXh0dXJlLnByZW11bHRpcGxpZWRBbHBoYSk7XG5cbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0ZXh0dXJlLnNvdXJjZSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0ZXh0dXJlLnNjYWxlTW9kZSA9PT0gUElYSS5zY2FsZU1vZGVzLkxJTkVBUiA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1QpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGV4dHVyZS5zY2FsZU1vZGUgPT09IFBJWEkuc2NhbGVNb2Rlcy5MSU5FQVIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcblxuICAgICAgICAvLyByZWd1bGVyLi4uXG5cbiAgICAgICAgaWYoIXRleHR1cmUuX3Bvd2VyT2YyKVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuUkVQRUFUKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLlJFUEVBVCk7XG4gICAgICAgIH1cblxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblxuICAgICAgICB0ZXh0dXJlLl9kaXJ0eVtnbC5pZF0gPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gIHRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIGEgV2ViR0wgdGV4dHVyZVxuICpcbiAqIEBtZXRob2QgdXBkYXRlV2ViR0xUZXh0dXJlXG4gKiBAcGFyYW0gdGV4dHVyZSB7VGV4dHVyZX0gdGhlIHRleHR1cmUgdG8gdXBkYXRlXG4gKiBAcGFyYW0gZ2wge3dlYmdsQ29udGV4dH0gdGhlIFdlYkdMIGNvbnRleHRcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkudXBkYXRlV2ViR0xUZXh0dXJlID0gZnVuY3Rpb24odGV4dHVyZSwgZ2wpXG57XG4gICAgaWYoIHRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdIClcbiAgICB7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKTtcbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0ZXh0dXJlLnByZW11bHRpcGxpZWRBbHBoYSk7XG5cbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0ZXh0dXJlLnNvdXJjZSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0ZXh0dXJlLnNjYWxlTW9kZSA9PT0gUElYSS5zY2FsZU1vZGVzLkxJTkVBUiA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1QpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGV4dHVyZS5zY2FsZU1vZGUgPT09IFBJWEkuc2NhbGVNb2Rlcy5MSU5FQVIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcblxuICAgICAgICAvLyByZWd1bGVyLi4uXG5cbiAgICAgICAgaWYoIXRleHR1cmUuX3Bvd2VyT2YyKVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuUkVQRUFUKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLlJFUEVBVCk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0dXJlLl9kaXJ0eVtnbC5pZF0gPSBmYWxzZTtcbiAgICB9XG4gICAgXG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYSBsb3N0IHdlYmdsIGNvbnRleHRcbiAqXG4gKiBAbWV0aG9kIGhhbmRsZUNvbnRleHRMb3N0XG4gKiBAcGFyYW0gZXZlbnQge0V2ZW50fVxuICogQHByaXZhdGVcbiAqL1xuUElYSS5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5oYW5kbGVDb250ZXh0TG9zdCA9IGZ1bmN0aW9uKGV2ZW50KVxue1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5jb250ZXh0TG9zdCA9IHRydWU7XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYSByZXN0b3JlZCB3ZWJnbCBjb250ZXh0XG4gKlxuICogQG1ldGhvZCBoYW5kbGVDb250ZXh0UmVzdG9yZWRcbiAqIEBwYXJhbSBldmVudCB7RXZlbnR9XG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLldlYkdMUmVuZGVyZXIucHJvdG90eXBlLmhhbmRsZUNvbnRleHRSZXN0b3JlZCA9IGZ1bmN0aW9uKClcbntcblxuICAgIC8vdHJ5ICdleHBlcmltZW50YWwtd2ViZ2wnXG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5nbCA9IHRoaXMudmlldy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCAgdGhpcy5vcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vdHJ5ICd3ZWJnbCdcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZ2wgPSB0aGlzLnZpZXcuZ2V0Q29udGV4dCgnd2ViZ2wnLCAgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgIC8vIGZhaWwsIG5vdCBhYmxlIHRvIGdldCBhIGNvbnRleHRcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignIFRoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHdlYkdMLiBUcnkgdXNpbmcgdGhlIGNhbnZhcyByZW5kZXJlcicgKyB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuaWQgPSBQSVhJLldlYkdMUmVuZGVyZXIuZ2xDb250ZXh0SWQgKys7XG5cblxuXG4gICAgLy8gbmVlZCB0byBzZXQgdGhlIGNvbnRleHQuLi5cbiAgICB0aGlzLnNoYWRlck1hbmFnZXIuc2V0Q29udGV4dChnbCk7XG4gICAgdGhpcy5zcHJpdGVCYXRjaC5zZXRDb250ZXh0KGdsKTtcbiAgICB0aGlzLnByaW1pdGl2ZUJhdGNoLnNldENvbnRleHQoZ2wpO1xuICAgIHRoaXMubWFza01hbmFnZXIuc2V0Q29udGV4dChnbCk7XG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyLnNldENvbnRleHQoZ2wpO1xuXG5cbiAgICB0aGlzLnJlbmRlclNlc3Npb24uZ2wgPSB0aGlzLmdsO1xuXG4gICAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICBnbC5kaXNhYmxlKGdsLkNVTExfRkFDRSk7XG5cbiAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0aGlzLnRyYW5zcGFyZW50KTtcblxuICAgIHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgZm9yKHZhciBrZXkgaW4gUElYSS5UZXh0dXJlQ2FjaGUpXG4gICAge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IFBJWEkuVGV4dHVyZUNhY2hlW2tleV0uYmFzZVRleHR1cmU7XG4gICAgICAgIHRleHR1cmUuX2dsVGV4dHVyZXMgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjb250ZXh0IHdhcyBsb3N0IFxuICAgICAqIEBwcm9wZXJ0eSBjb250ZXh0TG9zdFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHRMb3N0ID0gZmFsc2U7XG5cbn07XG5cbi8qKlxuICogUmVtb3ZlcyBldmVyeXRoaW5nIGZyb20gdGhlIHJlbmRlcmVyIChldmVudCBsaXN0ZW5lcnMsIHNwcml0ZWJhdGNoLCBldGMuLi4pXG4gKlxuICogQG1ldGhvZCBkZXN0cm95XG4gKi9cblBJWEkuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcblxuICAgIC8vIGRlYWwgd2l0aCBsb3NpbmcgY29udGV4dC4uXG4gICAgXG4gICAgLy8gcmVtb3ZlIGxpc3RlbmVyc1xuICAgIHRoaXMudmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgdGhpcy5jb250ZXh0TG9zdCk7XG4gICAgdGhpcy52aWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgdGhpcy5jb250ZXh0UmVzdG9yZWRMb3N0KTtcblxuICAgIFBJWEkuZ2xDb250ZXh0c1t0aGlzLmdsQ29udGV4dElkXSA9IG51bGw7XG5cbiAgICB0aGlzLnByb2plY3Rpb24gPSBudWxsO1xuICAgIHRoaXMub2Zmc2V0ID0gbnVsbDtcblxuICAgIC8vIHRpbWUgdG8gY3JlYXRlIHRoZSByZW5kZXIgbWFuYWdlcnMhIGVhY2ggb25lIGZvY3VzZXMgb24gbWFuYWdpbmUgYSBzdGF0ZSBpbiB3ZWJHTFxuICAgIHRoaXMuc2hhZGVyTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5zcHJpdGVCYXRjaC5kZXN0cm95KCk7XG4gICAgdGhpcy5wcmltaXRpdmVCYXRjaC5kZXN0cm95KCk7XG4gICAgdGhpcy5tYXNrTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyLmRlc3Ryb3koKTtcblxuICAgIHRoaXMuc2hhZGVyTWFuYWdlciA9IG51bGw7XG4gICAgdGhpcy5zcHJpdGVCYXRjaCA9IG51bGw7XG4gICAgdGhpcy5tYXNrTWFuYWdlciA9IG51bGw7XG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gbnVsbDtcbiAgICBcbiAgICB0aGlzLmdsID0gbnVsbDtcbiAgICAvL1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbiA9IG51bGw7XG59O1xuXG5cblBJWEkuV2ViR0xSZW5kZXJlci5nbENvbnRleHRJZCA9IDA7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4qIEBjbGFzcyBXZWJHTE1hc2tNYW5hZ2VyXG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0gZ2wge1dlYkdMQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4qIEBwcml2YXRlXG4qL1xuUElYSS5XZWJHTEJsZW5kTW9kZU1hbmFnZXIgPSBmdW5jdGlvbihnbClcbntcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy5jdXJyZW50QmxlbmRNb2RlID0gOTk5OTk7XG59O1xuXG4vKipcbiogU2V0cy11cCB0aGUgZ2l2ZW4gYmxlbmRNb2RlIGZyb20gV2ViR0wncyBwb2ludCBvZiB2aWV3XG4qIEBtZXRob2Qgc2V0QmxlbmRNb2RlIFxuKlxuKiBAcGFyYW0gYmxlbmRNb2RlIHtOdW1iZXJ9IHRoZSBibGVuZE1vZGUsIHNob3VsZCBiZSBhIFBpeGkgY29uc3QsIHN1Y2ggYXMgUElYSS5CbGVuZE1vZGVzLkFERFxuKi9cblBJWEkuV2ViR0xCbGVuZE1vZGVNYW5hZ2VyLnByb3RvdHlwZS5zZXRCbGVuZE1vZGUgPSBmdW5jdGlvbihibGVuZE1vZGUpXG57XG4gICAgaWYodGhpcy5jdXJyZW50QmxlbmRNb2RlID09PSBibGVuZE1vZGUpcmV0dXJuIGZhbHNlO1xuIC8vICAgY29uc29sZS5sb2coXCJTV0FQIVwiKVxuICAgIHRoaXMuY3VycmVudEJsZW5kTW9kZSA9IGJsZW5kTW9kZTtcbiAgICBcbiAgICB2YXIgYmxlbmRNb2RlV2ViR0wgPSBQSVhJLmJsZW5kTW9kZXNXZWJHTFt0aGlzLmN1cnJlbnRCbGVuZE1vZGVdO1xuICAgIHRoaXMuZ2wuYmxlbmRGdW5jKGJsZW5kTW9kZVdlYkdMWzBdLCBibGVuZE1vZGVXZWJHTFsxXSk7XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5QSVhJLldlYkdMQmxlbmRNb2RlTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmdsID0gbnVsbDtcbn07XG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuKiBAY2xhc3MgV2ViR0xNYXNrTWFuYWdlclxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIGdsIHtXZWJHTENvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuKiBAcHJpdmF0ZVxuKi9cblBJWEkuV2ViR0xNYXNrTWFuYWdlciA9IGZ1bmN0aW9uKGdsKVxue1xuICAgIHRoaXMubWFza1N0YWNrID0gW107XG4gICAgdGhpcy5tYXNrUG9zaXRpb24gPSAwO1xuXG4gICAgdGhpcy5zZXRDb250ZXh0KGdsKTtcblxuICAgIHRoaXMucmV2ZXJzZSA9IGZhbHNlO1xuICAgIHRoaXMuY291bnQgPSAwO1xufTtcblxuLyoqXG4qIFNldHMgdGhlIGRyYXdpbmcgY29udGV4dCB0byB0aGUgb25lIGdpdmVuIGluIHBhcmFtZXRlclxuKiBAbWV0aG9kIHNldENvbnRleHQgXG4qIEBwYXJhbSBnbCB7V2ViR0xDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiovXG5QSVhJLldlYkdMTWFza01hbmFnZXIucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbihnbClcbntcbiAgICB0aGlzLmdsID0gZ2w7XG59O1xuXG4vKipcbiogQXBwbGllcyB0aGUgTWFzayBhbmQgYWRkcyBpdCB0byB0aGUgY3VycmVudCBmaWx0ZXIgc3RhY2tcbiogQG1ldGhvZCBwdXNoTWFza1xuKiBAcGFyYW0gbWFza0RhdGEge0FycmF5fVxuKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7UmVuZGVyU2Vzc2lvbn1cbiovXG5QSVhJLldlYkdMTWFza01hbmFnZXIucHJvdG90eXBlLnB1c2hNYXNrID0gZnVuY3Rpb24obWFza0RhdGEsIHJlbmRlclNlc3Npb24pXG57XG4gICAgdmFyIGdsID0gcmVuZGVyU2Vzc2lvbi5nbDtcblxuICAgIGlmKG1hc2tEYXRhLmRpcnR5KVxuICAgIHtcbiAgICAgICAgUElYSS5XZWJHTEdyYXBoaWNzLnVwZGF0ZUdyYXBoaWNzKG1hc2tEYXRhLCBnbCk7XG4gICAgfVxuXG4gICAgaWYoIW1hc2tEYXRhLl93ZWJHTFtnbC5pZF0uZGF0YS5sZW5ndGgpcmV0dXJuO1xuXG4gICAgcmVuZGVyU2Vzc2lvbi5zdGVuY2lsTWFuYWdlci5wdXNoU3RlbmNpbChtYXNrRGF0YSwgbWFza0RhdGEuX3dlYkdMW2dsLmlkXS5kYXRhWzBdLCByZW5kZXJTZXNzaW9uKTtcbn07XG5cbi8qKlxuKiBSZW1vdmVzIHRoZSBsYXN0IGZpbHRlciBmcm9tIHRoZSBmaWx0ZXIgc3RhY2sgYW5kIGRvZXNuJ3QgcmV0dXJuIGl0XG4qIEBtZXRob2QgcG9wTWFza1xuKlxuKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7UmVuZGVyU2Vzc2lvbn0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSB1c2VmdWwgcGFyYW1ldGVyc1xuKi9cblBJWEkuV2ViR0xNYXNrTWFuYWdlci5wcm90b3R5cGUucG9wTWFzayA9IGZ1bmN0aW9uKG1hc2tEYXRhLCByZW5kZXJTZXNzaW9uKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgcmVuZGVyU2Vzc2lvbi5zdGVuY2lsTWFuYWdlci5wb3BTdGVuY2lsKG1hc2tEYXRhLCBtYXNrRGF0YS5fd2ViR0xbZ2wuaWRdLmRhdGFbMF0sIHJlbmRlclNlc3Npb24pO1xufTtcblxuXG4vKipcbiogRGVzdHJveXMgdGhlIG1hc2sgc3RhY2tcbiogQG1ldGhvZCBkZXN0cm95XG4qL1xuUElYSS5XZWJHTE1hc2tNYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMubWFza1N0YWNrID0gbnVsbDtcbiAgICB0aGlzLmdsID0gbnVsbDtcbn07XG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG4gXG4vL0JBMDI4NVxuLy9JbnRlcmNvbnRpbmVudGFsIEhvdGVsLCA4ODggSG93YXJkIFN0cmVldFxuLy9TYW4gRnJhbmNpc2NvXG5cbi8qKlxuKiBAY2xhc3MgV2ViR0xTdGVuY2lsTWFuYWdlclxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIGdsIHtXZWJHTENvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuKiBAcHJpdmF0ZVxuKi9cblBJWEkuV2ViR0xTdGVuY2lsTWFuYWdlciA9IGZ1bmN0aW9uKGdsKVxue1xuICAgXG4gICAgdGhpcy5zdGVuY2lsU3RhY2sgPSBbXTtcbiAgICB0aGlzLnNldENvbnRleHQoZ2wpO1xuICAgIHRoaXMucmV2ZXJzZSA9IHRydWU7XG4gICAgdGhpcy5jb3VudCA9IDA7XG5cbn07XG5cbi8qKlxuKiBTZXRzIHRoZSBkcmF3aW5nIGNvbnRleHQgdG8gdGhlIG9uZSBnaXZlbiBpbiBwYXJhbWV0ZXJcbiogQG1ldGhvZCBzZXRDb250ZXh0IFxuKiBAcGFyYW0gZ2wge1dlYkdMQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4qL1xuUElYSS5XZWJHTFN0ZW5jaWxNYW5hZ2VyLnByb3RvdHlwZS5zZXRDb250ZXh0ID0gZnVuY3Rpb24oZ2wpXG57XG4gICAgdGhpcy5nbCA9IGdsO1xufTtcblxuLyoqXG4qIEFwcGxpZXMgdGhlIE1hc2sgYW5kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgZmlsdGVyIHN0YWNrXG4qIEBtZXRob2QgcHVzaE1hc2tcbiogQHBhcmFtIG1hc2tEYXRhIHtBcnJheX1cbiogQHBhcmFtIHJlbmRlclNlc3Npb24ge1JlbmRlclNlc3Npb259XG4qL1xuUElYSS5XZWJHTFN0ZW5jaWxNYW5hZ2VyLnByb3RvdHlwZS5wdXNoU3RlbmNpbCA9IGZ1bmN0aW9uKGdyYXBoaWNzLCB3ZWJHTERhdGEsIHJlbmRlclNlc3Npb24pXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICB0aGlzLmJpbmRHcmFwaGljcyhncmFwaGljcywgd2ViR0xEYXRhLCByZW5kZXJTZXNzaW9uKTtcblxuICAgIGlmKHRoaXMuc3RlbmNpbFN0YWNrLmxlbmd0aCA9PT0gMClcbiAgICB7XG4gICAgICAgIGdsLmVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuICAgICAgICBnbC5jbGVhcihnbC5TVEVOQ0lMX0JVRkZFUl9CSVQpO1xuICAgICAgICB0aGlzLnJldmVyc2UgPSB0cnVlO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB9XG5cbiAgICB0aGlzLnN0ZW5jaWxTdGFjay5wdXNoKHdlYkdMRGF0YSk7XG5cbiAgICB2YXIgbGV2ZWwgPSB0aGlzLmNvdW50O1xuXG4gICAgZ2wuY29sb3JNYXNrKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcblxuICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkFMV0FZUywwLDB4RkYpO1xuICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuSU5WRVJUKTtcblxuICAgIC8vIGRyYXcgdGhlIHRyaWFuZ2xlIHN0cmlwIVxuXG4gICAgaWYod2ViR0xEYXRhLm1vZGUgPT09IDEpXG4gICAge1xuXG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRV9GQU4sICB3ZWJHTERhdGEuaW5kaWNlcy5sZW5ndGggLSA0LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuICAgICAgIFxuICAgICAgICBpZih0aGlzLnJldmVyc2UpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCAweEZGIC0gbGV2ZWwsIDB4RkYpO1xuICAgICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsZ2wuS0VFUCxnbC5ERUNSKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLGxldmVsLCAweEZGKTtcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuSU5DUik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkcmF3IGEgcXVhZCB0byBpbmNyZW1lbnQuLlxuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVfRkFOLCA0LCBnbC5VTlNJR05FRF9TSE9SVCwgKCB3ZWJHTERhdGEuaW5kaWNlcy5sZW5ndGggLSA0ICkgKiAyICk7XG4gICAgICAgICAgICAgICBcbiAgICAgICAgaWYodGhpcy5yZXZlcnNlKVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwweEZGLShsZXZlbCsxKSwgMHhGRik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCxsZXZlbCsxLCAweEZGKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmV2ZXJzZSA9ICF0aGlzLnJldmVyc2U7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGlmKCF0aGlzLnJldmVyc2UpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCAweEZGIC0gbGV2ZWwsIDB4RkYpO1xuICAgICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsZ2wuS0VFUCxnbC5ERUNSKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLGxldmVsLCAweEZGKTtcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuSU5DUik7XG4gICAgICAgIH1cblxuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVfU1RSSVAsICB3ZWJHTERhdGEuaW5kaWNlcy5sZW5ndGgsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cbiAgICAgICAgaWYoIXRoaXMucmV2ZXJzZSlcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsMHhGRi0obGV2ZWwrMSksIDB4RkYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsbGV2ZWwrMSwgMHhGRik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnbC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsZ2wuS0VFUCxnbC5LRUVQKTtcblxuICAgIHRoaXMuY291bnQrKztcbn07XG5cbi8vVE9ETyB0aGlzIGRvZXMgbm90IGJlbG9uZyBoZXJlIVxuUElYSS5XZWJHTFN0ZW5jaWxNYW5hZ2VyLnByb3RvdHlwZS5iaW5kR3JhcGhpY3MgPSBmdW5jdGlvbihncmFwaGljcywgd2ViR0xEYXRhLCByZW5kZXJTZXNzaW9uKVxue1xuICAgIC8vaWYodGhpcy5fY3VycmVudEdyYXBoaWNzID09PSBncmFwaGljcylyZXR1cm47XG4gICAgdGhpcy5fY3VycmVudEdyYXBoaWNzID0gZ3JhcGhpY3M7XG5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgIC8vIGJpbmQgdGhlIGdyYXBoaWNzIG9iamVjdC4uXG4gICAgdmFyIHByb2plY3Rpb24gPSByZW5kZXJTZXNzaW9uLnByb2plY3Rpb24sXG4gICAgICAgIG9mZnNldCA9IHJlbmRlclNlc3Npb24ub2Zmc2V0LFxuICAgICAgICBzaGFkZXI7Ly8gPSByZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIucHJpbWl0aXZlU2hhZGVyO1xuXG4gICAgaWYod2ViR0xEYXRhLm1vZGUgPT09IDEpXG4gICAge1xuICAgICAgICBzaGFkZXIgPSByZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIuY29tcGxleFByaW1hdGl2ZVNoYWRlcjtcblxuICAgICAgICByZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIuc2V0U2hhZGVyKCBzaGFkZXIgKTtcblxuICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHNoYWRlci50cmFuc2xhdGlvbk1hdHJpeCwgZmFsc2UsIGdyYXBoaWNzLndvcmxkVHJhbnNmb3JtLnRvQXJyYXkodHJ1ZSkpO1xuXG4gICAgICAgIGdsLnVuaWZvcm0yZihzaGFkZXIucHJvamVjdGlvblZlY3RvciwgcHJvamVjdGlvbi54LCAtcHJvamVjdGlvbi55KTtcbiAgICAgICAgZ2wudW5pZm9ybTJmKHNoYWRlci5vZmZzZXRWZWN0b3IsIC1vZmZzZXQueCwgLW9mZnNldC55KTtcblxuICAgICAgICBnbC51bmlmb3JtM2Z2KHNoYWRlci50aW50Q29sb3IsIFBJWEkuaGV4MnJnYihncmFwaGljcy50aW50KSk7XG4gICAgICAgIGdsLnVuaWZvcm0zZnYoc2hhZGVyLmNvbG9yLCB3ZWJHTERhdGEuY29sb3IpO1xuXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIuYWxwaGEsIGdyYXBoaWNzLndvcmxkQWxwaGEgKiB3ZWJHTERhdGEuYWxwaGEpO1xuXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB3ZWJHTERhdGEuYnVmZmVyKTtcblxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hVmVydGV4UG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgNCAqIDIsIDApO1xuXG5cbiAgICAgICAgLy8gbm93IGRvIHRoZSByZXN0Li5cbiAgICAgICAgLy8gc2V0IHRoZSBpbmRleCBidWZmZXIhXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHdlYkdMRGF0YS5pbmRleEJ1ZmZlcik7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIC8vcmVuZGVyU2Vzc2lvbi5zaGFkZXJNYW5hZ2VyLmFjdGl2YXRlUHJpbWl0aXZlU2hhZGVyKCk7XG4gICAgICAgIHNoYWRlciA9IHJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlci5wcmltaXRpdmVTaGFkZXI7XG4gICAgICAgIHJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlci5zZXRTaGFkZXIoIHNoYWRlciApO1xuXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoc2hhZGVyLnRyYW5zbGF0aW9uTWF0cml4LCBmYWxzZSwgZ3JhcGhpY3Mud29ybGRUcmFuc2Zvcm0udG9BcnJheSh0cnVlKSk7XG5cbiAgICAgICAgZ2wudW5pZm9ybTJmKHNoYWRlci5wcm9qZWN0aW9uVmVjdG9yLCBwcm9qZWN0aW9uLngsIC1wcm9qZWN0aW9uLnkpO1xuICAgICAgICBnbC51bmlmb3JtMmYoc2hhZGVyLm9mZnNldFZlY3RvciwgLW9mZnNldC54LCAtb2Zmc2V0LnkpO1xuXG4gICAgICAgIGdsLnVuaWZvcm0zZnYoc2hhZGVyLnRpbnRDb2xvciwgUElYSS5oZXgycmdiKGdyYXBoaWNzLnRpbnQpKTtcblxuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLmFscGhhLCBncmFwaGljcy53b3JsZEFscGhhKTtcbiAgICAgICAgXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB3ZWJHTERhdGEuYnVmZmVyKTtcblxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hVmVydGV4UG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgNCAqIDYsIDApO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5jb2xvckF0dHJpYnV0ZSwgNCwgZ2wuRkxPQVQsIGZhbHNlLDQgKiA2LCAyICogNCk7XG5cbiAgICAgICAgLy8gc2V0IHRoZSBpbmRleCBidWZmZXIhXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHdlYkdMRGF0YS5pbmRleEJ1ZmZlcik7XG4gICAgfVxufTtcblxuUElYSS5XZWJHTFN0ZW5jaWxNYW5hZ2VyLnByb3RvdHlwZS5wb3BTdGVuY2lsID0gZnVuY3Rpb24oZ3JhcGhpY3MsIHdlYkdMRGF0YSwgcmVuZGVyU2Vzc2lvbilcbntcblx0dmFyIGdsID0gdGhpcy5nbDtcbiAgICB0aGlzLnN0ZW5jaWxTdGFjay5wb3AoKTtcbiAgIFxuICAgIHRoaXMuY291bnQtLTtcblxuICAgIGlmKHRoaXMuc3RlbmNpbFN0YWNrLmxlbmd0aCA9PT0gMClcbiAgICB7XG4gICAgICAgIC8vIHRoZSBzdGFjayBpcyBlbXB0eSFcbiAgICAgICAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuXG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG5cbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy5jb3VudDtcblxuICAgICAgICB0aGlzLmJpbmRHcmFwaGljcyhncmFwaGljcywgd2ViR0xEYXRhLCByZW5kZXJTZXNzaW9uKTtcblxuICAgICAgICBnbC5jb2xvck1hc2soZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICAgIFxuICAgICAgICBpZih3ZWJHTERhdGEubW9kZSA9PT0gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5yZXZlcnNlID0gIXRoaXMucmV2ZXJzZTtcblxuICAgICAgICAgICAgaWYodGhpcy5yZXZlcnNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCAweEZGIC0gKGxldmVsKzEpLCAweEZGKTtcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLklOQ1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLGxldmVsKzEsIDB4RkYpO1xuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuREVDUik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRyYXcgYSBxdWFkIHRvIGluY3JlbWVudC4uXG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVfRkFOLCA0LCBnbC5VTlNJR05FRF9TSE9SVCwgKCB3ZWJHTERhdGEuaW5kaWNlcy5sZW5ndGggLSA0ICkgKiAyICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkFMV0FZUywwLDB4RkYpO1xuICAgICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsZ2wuS0VFUCxnbC5JTlZFUlQpO1xuXG4gICAgICAgICAgICAvLyBkcmF3IHRoZSB0cmlhbmdsZSBzdHJpcCFcbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRV9GQU4sICB3ZWJHTERhdGEuaW5kaWNlcy5sZW5ndGggLSA0LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCF0aGlzLnJldmVyc2UpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsMHhGRi0obGV2ZWwpLCAweEZGKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCxsZXZlbCwgMHhGRik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAvLyAgY29uc29sZS5sb2coXCI8PD4+XCIpXG4gICAgICAgICAgICBpZighdGhpcy5yZXZlcnNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCAweEZGIC0gKGxldmVsKzEpLCAweEZGKTtcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLklOQ1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLGxldmVsKzEsIDB4RkYpO1xuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuREVDUik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRV9TVFJJUCwgIHdlYkdMRGF0YS5pbmRpY2VzLmxlbmd0aCwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuICAgICAgICAgICAgaWYoIXRoaXMucmV2ZXJzZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwweEZGLShsZXZlbCksIDB4RkYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLGxldmVsLCAweEZGKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsZ2wuS0VFUCxnbC5LRUVQKTtcblxuXG4gICAgfVxuXG4gICAgLy9yZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIuZGVhY3RpdmF0ZVByaW1pdGl2ZVNoYWRlcigpO1xufTtcblxuLyoqXG4qIERlc3Ryb3lzIHRoZSBtYXNrIHN0YWNrXG4qIEBtZXRob2QgZGVzdHJveVxuKi9cblBJWEkuV2ViR0xTdGVuY2lsTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLm1hc2tTdGFjayA9IG51bGw7XG4gICAgdGhpcy5nbCA9IG51bGw7XG59O1xuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiogQGNsYXNzIFdlYkdMU2hhZGVyTWFuYWdlclxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIGdsIHtXZWJHTENvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuKiBAcHJpdmF0ZVxuKi9cblBJWEkuV2ViR0xTaGFkZXJNYW5hZ2VyID0gZnVuY3Rpb24oZ2wpXG57XG5cbiAgICB0aGlzLm1heEF0dGlicyA9IDEwO1xuICAgIHRoaXMuYXR0cmliU3RhdGUgPSBbXTtcbiAgICB0aGlzLnRlbXBBdHRyaWJTdGF0ZSA9IFtdO1xuICAgIHRoaXMuc2hhZGVyTWFwID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWF4QXR0aWJzOyBpKyspIHtcbiAgICAgICAgdGhpcy5hdHRyaWJTdGF0ZVtpXSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuc2V0Q29udGV4dChnbCk7XG4gICAgLy8gdGhlIGZpbmFsIG9uZSBpcyB1c2VkIGZvciB0aGUgcmVuZGVyaW5nIHN0cmlwc1xufTtcblxuXG4vKipcbiogSW5pdGlhbGlzZXMgdGhlIGNvbnRleHQgYW5kIHRoZSBwcm9wZXJ0aWVzXG4qIEBtZXRob2Qgc2V0Q29udGV4dCBcbiogQHBhcmFtIGdsIHtXZWJHTENvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuKiBAcGFyYW0gdHJhbnNwYXJlbnQge0Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBkcmF3aW5nIGNvbnRleHQgc2hvdWxkIGJlIHRyYW5zcGFyZW50XG4qL1xuUElYSS5XZWJHTFNoYWRlck1hbmFnZXIucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbihnbClcbntcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgXG4gICAgLy8gdGhlIG5leHQgb25lIGlzIHVzZWQgZm9yIHJlbmRlcmluZyBwcmltYXRpdmVzXG4gICAgdGhpcy5wcmltaXRpdmVTaGFkZXIgPSBuZXcgUElYSS5QcmltaXRpdmVTaGFkZXIoZ2wpO1xuXG4gICAgLy8gdGhlIG5leHQgb25lIGlzIHVzZWQgZm9yIHJlbmRlcmluZyB0cmlhbmdsZSBzdHJpcHNcbiAgICB0aGlzLmNvbXBsZXhQcmltYXRpdmVTaGFkZXIgPSBuZXcgUElYSS5Db21wbGV4UHJpbWl0aXZlU2hhZGVyKGdsKTtcblxuICAgIC8vIHRoaXMgc2hhZGVyIGlzIHVzZWQgZm9yIHRoZSBkZWZhdWx0IHNwcml0ZSByZW5kZXJpbmdcbiAgICB0aGlzLmRlZmF1bHRTaGFkZXIgPSBuZXcgUElYSS5QaXhpU2hhZGVyKGdsKTtcblxuICAgIC8vIHRoaXMgc2hhZGVyIGlzIHVzZWQgZm9yIHRoZSBmYXN0IHNwcml0ZSByZW5kZXJpbmdcbiAgICB0aGlzLmZhc3RTaGFkZXIgPSBuZXcgUElYSS5QaXhpRmFzdFNoYWRlcihnbCk7XG5cbiAgICAvLyB0aGUgbmV4dCBvbmUgaXMgdXNlZCBmb3IgcmVuZGVyaW5nIHRyaWFuZ2xlIHN0cmlwc1xuICAgIHRoaXMuc3RyaXBTaGFkZXIgPSBuZXcgUElYSS5TdHJpcFNoYWRlcihnbCk7XG4gICAgdGhpcy5zZXRTaGFkZXIodGhpcy5kZWZhdWx0U2hhZGVyKTtcbn07XG5cblxuLyoqXG4qIFRha2VzIHRoZSBhdHRyaWJ1dGVzIGdpdmVuIGluIHBhcmFtZXRlcnMgXG4qIEBtZXRob2Qgc2V0QXR0cmlic1xuKiBAcGFyYW0gYXR0cmlicyB7QXJyYXl9IGF0dHJpYnMgXG4qL1xuUElYSS5XZWJHTFNoYWRlck1hbmFnZXIucHJvdG90eXBlLnNldEF0dHJpYnMgPSBmdW5jdGlvbihhdHRyaWJzKVxue1xuICAgIC8vIHJlc2V0IHRlbXAgc3RhdGVcblxuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMudGVtcEF0dHJpYlN0YXRlLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy50ZW1wQXR0cmliU3RhdGVbaV0gPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBzZXQgdGhlIG5ldyBhdHRyaWJzXG4gICAgZm9yIChpID0gMDsgaSA8IGF0dHJpYnMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgYXR0cmliSWQgPSBhdHRyaWJzW2ldO1xuICAgICAgICB0aGlzLnRlbXBBdHRyaWJTdGF0ZVthdHRyaWJJZF0gPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5hdHRyaWJTdGF0ZS5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGlmKHRoaXMuYXR0cmliU3RhdGVbaV0gIT09IHRoaXMudGVtcEF0dHJpYlN0YXRlW2ldKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYlN0YXRlW2ldID0gdGhpcy50ZW1wQXR0cmliU3RhdGVbaV07XG5cbiAgICAgICAgICAgIGlmKHRoaXMudGVtcEF0dHJpYlN0YXRlW2ldKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblBJWEkuV2ViR0xTaGFkZXJNYW5hZ2VyLnByb3RvdHlwZS5zZXRTaGFkZXIgPSBmdW5jdGlvbihzaGFkZXIpXG57XG4gICAgaWYodGhpcy5fY3VycmVudElkID09PSBzaGFkZXIuX1VJRClyZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgdGhpcy5fY3VycmVudElkID0gc2hhZGVyLl9VSUQ7XG5cbiAgICB0aGlzLmN1cnJlbnRTaGFkZXIgPSBzaGFkZXI7XG5cbiAgICB0aGlzLmdsLnVzZVByb2dyYW0oc2hhZGVyLnByb2dyYW0pO1xuICAgIHRoaXMuc2V0QXR0cmlicyhzaGFkZXIuYXR0cmlidXRlcyk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuKiBEZXN0cm95c1xuKiBAbWV0aG9kIGRlc3Ryb3lcbiovXG5QSVhJLldlYkdMU2hhZGVyTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmF0dHJpYlN0YXRlID0gbnVsbDtcblxuICAgIHRoaXMudGVtcEF0dHJpYlN0YXRlID0gbnVsbDtcblxuICAgIHRoaXMucHJpbWl0aXZlU2hhZGVyLmRlc3Ryb3koKTtcblxuICAgIHRoaXMuZGVmYXVsdFNoYWRlci5kZXN0cm95KCk7XG5cbiAgICB0aGlzLmZhc3RTaGFkZXIuZGVzdHJveSgpO1xuXG4gICAgdGhpcy5zdHJpcFNoYWRlci5kZXN0cm95KCk7XG5cbiAgICB0aGlzLmdsID0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXNcbiAqIFxuICogQmlnIHRoYW5rcyB0byB0aGUgdmVyeSBjbGV2ZXIgTWF0dCBEZXNMYXVyaWVycyA8bWF0dGRlc2w+IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbC9cbiAqIGZvciBjcmVhdGluZyB0aGUgb3JpZ2luYWwgcGl4aSB2ZXJzaW9uIVxuICpcbiAqIEhlYXZpbHkgaW5zcGlyZWQgYnkgTGliR0RYJ3MgV2ViR0xTcHJpdGVCYXRjaDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9saWJnZHgvbGliZ2R4L2Jsb2IvbWFzdGVyL2dkeC9zcmMvY29tL2JhZGxvZ2ljL2dkeC9ncmFwaGljcy9nMmQvV2ViR0xTcHJpdGVCYXRjaC5qYXZhXG4gKi9cblxuIC8qKlxuICpcbiAqIEBjbGFzcyBXZWJHTFNwcml0ZUJhdGNoXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZ2wge1dlYkdMQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4gKlxuICovXG5QSVhJLldlYkdMU3ByaXRlQmF0Y2ggPSBmdW5jdGlvbihnbClcbntcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHZlcnRTaXplXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy52ZXJ0U2l6ZSA9IDY7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGltYWdlcyBpbiB0aGUgU3ByaXRlQmF0Y2ggYmVmb3JlIGl0IGZsdXNoZXNcbiAgICAgKiBAcHJvcGVydHkgc2l6ZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuc2l6ZSA9IDIwMDA7Ly9NYXRoLnBvdygyLCAxNikgLyAgdGhpcy52ZXJ0U2l6ZTtcblxuICAgIC8vdGhlIHRvdGFsIG51bWJlciBvZiBmbG9hdHMgaW4gb3VyIGJhdGNoXG4gICAgdmFyIG51bVZlcnRzID0gdGhpcy5zaXplICogNCAqICB0aGlzLnZlcnRTaXplO1xuICAgIC8vdGhlIHRvdGFsIG51bWJlciBvZiBpbmRpY2VzIGluIG91ciBiYXRjaFxuICAgIHZhciBudW1JbmRpY2VzID0gdGhpcy5zaXplICogNjtcblxuICAgIC8vdmVydGV4IGRhdGFcblxuICAgIC8qKlxuICAgICogSG9sZHMgdGhlIHZlcnRpY2VzXG4gICAgKlxuICAgICogQHByb3BlcnR5IHZlcnRpY2VzXG4gICAgKiBAdHlwZSBGbG9hdDMyQXJyYXlcbiAgICAqL1xuICAgIHRoaXMudmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KG51bVZlcnRzKTtcblxuICAgIC8vaW5kZXggZGF0YVxuICAgIC8qKlxuICAgICAqIEhvbGRzIHRoZSBpbmRpY2VzXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgaW5kaWNlc1xuICAgICAqIEB0eXBlIFVpbnQxNkFycmF5XG4gICAgICovXG4gICAgdGhpcy5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KG51bUluZGljZXMpO1xuICAgIFxuICAgIHRoaXMubGFzdEluZGV4Q291bnQgPSAwO1xuXG4gICAgZm9yICh2YXIgaT0wLCBqPTA7IGkgPCBudW1JbmRpY2VzOyBpICs9IDYsIGogKz0gNClcbiAgICB7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgMF0gPSBqICsgMDtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyAxXSA9IGogKyAxO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDJdID0gaiArIDI7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgM10gPSBqICsgMDtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyA0XSA9IGogKyAyO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDVdID0gaiArIDM7XG4gICAgfVxuXG5cbiAgICB0aGlzLmRyYXdpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRCYXRjaFNpemUgPSAwO1xuICAgIHRoaXMuY3VycmVudEJhc2VUZXh0dXJlID0gbnVsbDtcbiAgICBcbiAgICB0aGlzLnNldENvbnRleHQoZ2wpO1xuXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICB0aGlzLnRleHR1cmVzID0gW107XG4gICAgdGhpcy5ibGVuZE1vZGVzID0gW107XG59O1xuXG4vKipcbiogXG4qIEBtZXRob2Qgc2V0Q29udGV4dFxuKlxuKiBAcGFyYW0gZ2wge1dlYkdMQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4qL1xuUElYSS5XZWJHTFNwcml0ZUJhdGNoLnByb3RvdHlwZS5zZXRDb250ZXh0ID0gZnVuY3Rpb24oZ2wpXG57XG4gICAgdGhpcy5nbCA9IGdsO1xuXG4gICAgLy8gY3JlYXRlIGEgY291cGxlIG9mIGJ1ZmZlcnNcbiAgICB0aGlzLnZlcnRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgIC8vIDY1NTM1IGlzIG1heCBpbmRleCwgc28gNjU1MzUgLyA2ID0gMTA5MjIuXG5cblxuICAgIC8vdXBsb2FkIHRoZSBpbmRleCBkYXRhXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRleEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRpY2VzLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0ZXhCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRpY2VzLCBnbC5EWU5BTUlDX0RSQVcpO1xuXG4gICAgdGhpcy5jdXJyZW50QmxlbmRNb2RlID0gOTk5OTk7XG59O1xuXG4vKipcbiogXG4qIEBtZXRob2QgYmVnaW5cbipcbiogQHBhcmFtIHJlbmRlclNlc3Npb24ge1JlbmRlclNlc3Npb259IHRoZSBSZW5kZXJTZXNzaW9uXG4qL1xuUElYSS5XZWJHTFNwcml0ZUJhdGNoLnByb3RvdHlwZS5iZWdpbiA9IGZ1bmN0aW9uKHJlbmRlclNlc3Npb24pXG57XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uID0gcmVuZGVyU2Vzc2lvbjtcbiAgICB0aGlzLnNoYWRlciA9IHRoaXMucmVuZGVyU2Vzc2lvbi5zaGFkZXJNYW5hZ2VyLmRlZmF1bHRTaGFkZXI7XG5cbiAgICB0aGlzLnN0YXJ0KCk7XG59O1xuXG4vKipcbiogXG4qIEBtZXRob2QgZW5kXG4qXG4qL1xuUElYSS5XZWJHTFNwcml0ZUJhdGNoLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5mbHVzaCgpO1xufTtcblxuLyoqXG4qIFxuKiBAbWV0aG9kIHJlbmRlclxuKiBcbiogQHBhcmFtIHNwcml0ZSB7U3ByaXRlfSB0aGUgc3ByaXRlIHRvIHJlbmRlciB3aGVuIHVzaW5nIHRoaXMgc3ByaXRlYmF0Y2hcbiovXG5QSVhJLldlYkdMU3ByaXRlQmF0Y2gucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHNwcml0ZSlcbntcbiAgICB2YXIgdGV4dHVyZSA9IHNwcml0ZS50ZXh0dXJlO1xuICAgIFxuICAgLy9UT0RPIHNldCBibGVuZCBtb2Rlcy4uIFxuICAgIC8vIGNoZWNrIHRleHR1cmUuLlxuICAgIGlmKHRoaXMuY3VycmVudEJhdGNoU2l6ZSA+PSB0aGlzLnNpemUpXG4gICAge1xuICAgICAgICAvL3JldHVybjtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRCYXNlVGV4dHVyZSA9IHRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSB1dnMgZm9yIHRoZSB0ZXh0dXJlXG4gICAgdmFyIHV2cyA9IHRleHR1cmUuX3V2cztcbiAgICAvLyBpZiB0aGUgdXZzIGhhdmUgbm90IHVwZGF0ZWQgdGhlbiBubyBwb2ludCByZW5kZXJpbmcganVzdCB5ZXQhXG4gICAgaWYoIXV2cylyZXR1cm47XG5cbiAgICAvLyBnZXQgdGhlIHNwcml0ZXMgY3VycmVudCBhbHBoYVxuICAgIHZhciBhbHBoYSA9IHNwcml0ZS53b3JsZEFscGhhO1xuICAgIHZhciB0aW50ID0gc3ByaXRlLnRpbnQ7XG5cbiAgICB2YXIgdmVydGljaWVzID0gdGhpcy52ZXJ0aWNlcztcblxuXG4gICAgLy8gVE9ETyB0cmltPz9cbiAgICB2YXIgYVggPSBzcHJpdGUuYW5jaG9yLng7XG4gICAgdmFyIGFZID0gc3ByaXRlLmFuY2hvci55O1xuXG4gICAgdmFyIHcwLCB3MSwgaDAsIGgxO1xuICAgICAgICBcbiAgICBpZiAodGV4dHVyZS50cmltKVxuICAgIHtcbiAgICAgICAgLy8gaWYgdGhlIHNwcml0ZSBpcyB0cmltbWVkIHRoZW4gd2UgbmVlZCB0byBhZGQgdGhlIGV4dHJhIHNwYWNlIGJlZm9yZSB0cmFuc2Zvcm1pbmcgdGhlIHNwcml0ZSBjb29yZHMuLlxuICAgICAgICB2YXIgdHJpbSA9IHRleHR1cmUudHJpbTtcblxuICAgICAgICB3MSA9IHRyaW0ueCAtIGFYICogdHJpbS53aWR0aDtcbiAgICAgICAgdzAgPSB3MSArIHRleHR1cmUuY3JvcC53aWR0aDtcblxuICAgICAgICBoMSA9IHRyaW0ueSAtIGFZICogdHJpbS5oZWlnaHQ7XG4gICAgICAgIGgwID0gaDEgKyB0ZXh0dXJlLmNyb3AuaGVpZ2h0O1xuXG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHcwID0gKHRleHR1cmUuZnJhbWUud2lkdGggKSAqICgxLWFYKTtcbiAgICAgICAgdzEgPSAodGV4dHVyZS5mcmFtZS53aWR0aCApICogLWFYO1xuXG4gICAgICAgIGgwID0gdGV4dHVyZS5mcmFtZS5oZWlnaHQgKiAoMS1hWSk7XG4gICAgICAgIGgxID0gdGV4dHVyZS5mcmFtZS5oZWlnaHQgKiAtYVk7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5jdXJyZW50QmF0Y2hTaXplICogNCAqIHRoaXMudmVydFNpemU7XG5cbiAgICB2YXIgd29ybGRUcmFuc2Zvcm0gPSBzcHJpdGUud29ybGRUcmFuc2Zvcm07XG5cbiAgICB2YXIgYSA9IHdvcmxkVHJhbnNmb3JtLmE7Ly9bMF07XG4gICAgdmFyIGIgPSB3b3JsZFRyYW5zZm9ybS5jOy8vWzNdO1xuICAgIHZhciBjID0gd29ybGRUcmFuc2Zvcm0uYjsvL1sxXTtcbiAgICB2YXIgZCA9IHdvcmxkVHJhbnNmb3JtLmQ7Ly9bNF07XG4gICAgdmFyIHR4ID0gd29ybGRUcmFuc2Zvcm0udHg7Ly9bMl07XG4gICAgdmFyIHR5ID0gd29ybGRUcmFuc2Zvcm0udHk7Ly8vWzVdO1xuXG4gICAgLy8geHlcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhICogdzEgKyBjICogaDEgKyB0eDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBkICogaDEgKyBiICogdzEgKyB0eTtcbiAgICAvLyB1dlxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy54MDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueTA7XG4gICAgLy8gY29sb3JcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhbHBoYTtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB0aW50O1xuXG4gICAgLy8geHlcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhICogdzAgKyBjICogaDEgKyB0eDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBkICogaDEgKyBiICogdzAgKyB0eTtcbiAgICAvLyB1dlxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy54MTtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueTE7XG4gICAgLy8gY29sb3JcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhbHBoYTtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB0aW50O1xuXG4gICAgLy8geHlcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhICogdzAgKyBjICogaDAgKyB0eDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBkICogaDAgKyBiICogdzAgKyB0eTtcbiAgICAvLyB1dlxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy54MjtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueTI7XG4gICAgLy8gY29sb3JcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhbHBoYTtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB0aW50O1xuXG4gICAgLy8geHlcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhICogdzEgKyBjICogaDAgKyB0eDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBkICogaDAgKyBiICogdzEgKyB0eTtcbiAgICAvLyB1dlxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy54MztcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueTM7XG4gICAgLy8gY29sb3JcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhbHBoYTtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB0aW50O1xuICAgIFxuICAgIC8vIGluY3JlbWVudCB0aGUgYmF0Y2hzaXplXG4gICAgdGhpcy50ZXh0dXJlc1t0aGlzLmN1cnJlbnRCYXRjaFNpemVdID0gc3ByaXRlLnRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgdGhpcy5ibGVuZE1vZGVzW3RoaXMuY3VycmVudEJhdGNoU2l6ZV0gPSBzcHJpdGUuYmxlbmRNb2RlO1xuXG4gICAgdGhpcy5jdXJyZW50QmF0Y2hTaXplKys7XG5cbn07XG5cbi8qKlxuKiBSZW5kZXJzIGEgdGlsaW5nU3ByaXRlIHVzaW5nIHRoZSBzcHJpdGVCYXRjaFxuKiBAbWV0aG9kIHJlbmRlclRpbGluZ1Nwcml0ZVxuKiBcbiogQHBhcmFtIHNwcml0ZSB7VGlsaW5nU3ByaXRlfSB0aGUgdGlsaW5nU3ByaXRlIHRvIHJlbmRlclxuKi9cblBJWEkuV2ViR0xTcHJpdGVCYXRjaC5wcm90b3R5cGUucmVuZGVyVGlsaW5nU3ByaXRlID0gZnVuY3Rpb24odGlsaW5nU3ByaXRlKVxue1xuICAgIHZhciB0ZXh0dXJlID0gdGlsaW5nU3ByaXRlLnRpbGluZ1RleHR1cmU7XG5cbiAgICBcbiAgICAvLyBjaGVjayB0ZXh0dXJlLi5cbiAgICBpZih0aGlzLmN1cnJlbnRCYXRjaFNpemUgPj0gdGhpcy5zaXplKVxuICAgIHtcbiAgICAgICAgLy9yZXR1cm47XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgdGhpcy5jdXJyZW50QmFzZVRleHR1cmUgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgIH1cblxuICAgICAvLyBzZXQgdGhlIHRleHR1cmVzIHV2cyB0ZW1wb3JhcmlseVxuICAgIC8vIFRPRE8gY3JlYXRlIGEgc2VwYXJhdGUgdGV4dHVyZSBzbyB0aGF0IHdlIGNhbiB0aWxlIHBhcnQgb2YgYSB0ZXh0dXJlXG5cbiAgICBpZighdGlsaW5nU3ByaXRlLl91dnMpdGlsaW5nU3ByaXRlLl91dnMgPSBuZXcgUElYSS5UZXh0dXJlVXZzKCk7XG5cbiAgICB2YXIgdXZzID0gdGlsaW5nU3ByaXRlLl91dnM7XG5cbiAgICB0aWxpbmdTcHJpdGUudGlsZVBvc2l0aW9uLnggJT0gdGV4dHVyZS5iYXNlVGV4dHVyZS53aWR0aCAqIHRpbGluZ1Nwcml0ZS50aWxlU2NhbGVPZmZzZXQueDtcbiAgICB0aWxpbmdTcHJpdGUudGlsZVBvc2l0aW9uLnkgJT0gdGV4dHVyZS5iYXNlVGV4dHVyZS5oZWlnaHQgKiB0aWxpbmdTcHJpdGUudGlsZVNjYWxlT2Zmc2V0Lnk7XG5cbiAgICB2YXIgb2Zmc2V0WCA9ICB0aWxpbmdTcHJpdGUudGlsZVBvc2l0aW9uLngvKHRleHR1cmUuYmFzZVRleHR1cmUud2lkdGgqdGlsaW5nU3ByaXRlLnRpbGVTY2FsZU9mZnNldC54KTtcbiAgICB2YXIgb2Zmc2V0WSA9ICB0aWxpbmdTcHJpdGUudGlsZVBvc2l0aW9uLnkvKHRleHR1cmUuYmFzZVRleHR1cmUuaGVpZ2h0KnRpbGluZ1Nwcml0ZS50aWxlU2NhbGVPZmZzZXQueSk7XG5cbiAgICB2YXIgc2NhbGVYID0gICh0aWxpbmdTcHJpdGUud2lkdGggLyB0ZXh0dXJlLmJhc2VUZXh0dXJlLndpZHRoKSAgLyAodGlsaW5nU3ByaXRlLnRpbGVTY2FsZS54ICogdGlsaW5nU3ByaXRlLnRpbGVTY2FsZU9mZnNldC54KTtcbiAgICB2YXIgc2NhbGVZID0gICh0aWxpbmdTcHJpdGUuaGVpZ2h0IC8gdGV4dHVyZS5iYXNlVGV4dHVyZS5oZWlnaHQpIC8gKHRpbGluZ1Nwcml0ZS50aWxlU2NhbGUueSAqIHRpbGluZ1Nwcml0ZS50aWxlU2NhbGVPZmZzZXQueSk7XG5cbiAgICB1dnMueDAgPSAwIC0gb2Zmc2V0WDtcbiAgICB1dnMueTAgPSAwIC0gb2Zmc2V0WTtcblxuICAgIHV2cy54MSA9ICgxICogc2NhbGVYKSAtIG9mZnNldFg7XG4gICAgdXZzLnkxID0gMCAtIG9mZnNldFk7XG5cbiAgICB1dnMueDIgPSAoMSAqIHNjYWxlWCkgLSBvZmZzZXRYO1xuICAgIHV2cy55MiA9ICgxICogc2NhbGVZKSAtIG9mZnNldFk7XG5cbiAgICB1dnMueDMgPSAwIC0gb2Zmc2V0WDtcbiAgICB1dnMueTMgPSAoMSAqc2NhbGVZKSAtIG9mZnNldFk7XG5cbiAgICAvLyBnZXQgdGhlIHRpbGluZ1Nwcml0ZXMgY3VycmVudCBhbHBoYVxuICAgIHZhciBhbHBoYSA9IHRpbGluZ1Nwcml0ZS53b3JsZEFscGhhO1xuICAgIHZhciB0aW50ID0gdGlsaW5nU3ByaXRlLnRpbnQ7XG5cbiAgICB2YXIgIHZlcnRpY2llcyA9IHRoaXMudmVydGljZXM7XG5cbiAgICB2YXIgd2lkdGggPSB0aWxpbmdTcHJpdGUud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHRpbGluZ1Nwcml0ZS5oZWlnaHQ7XG5cbiAgICAvLyBUT0RPIHRyaW0/P1xuICAgIHZhciBhWCA9IHRpbGluZ1Nwcml0ZS5hbmNob3IueDtcbiAgICB2YXIgYVkgPSB0aWxpbmdTcHJpdGUuYW5jaG9yLnk7XG4gICAgdmFyIHcwID0gd2lkdGggKiAoMS1hWCk7XG4gICAgdmFyIHcxID0gd2lkdGggKiAtYVg7XG5cbiAgICB2YXIgaDAgPSBoZWlnaHQgKiAoMS1hWSk7XG4gICAgdmFyIGgxID0gaGVpZ2h0ICogLWFZO1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5jdXJyZW50QmF0Y2hTaXplICogNCAqIHRoaXMudmVydFNpemU7XG5cbiAgICB2YXIgd29ybGRUcmFuc2Zvcm0gPSB0aWxpbmdTcHJpdGUud29ybGRUcmFuc2Zvcm07XG5cbiAgICB2YXIgYSA9IHdvcmxkVHJhbnNmb3JtLmE7Ly9bMF07XG4gICAgdmFyIGIgPSB3b3JsZFRyYW5zZm9ybS5jOy8vWzNdO1xuICAgIHZhciBjID0gd29ybGRUcmFuc2Zvcm0uYjsvL1sxXTtcbiAgICB2YXIgZCA9IHdvcmxkVHJhbnNmb3JtLmQ7Ly9bNF07XG4gICAgdmFyIHR4ID0gd29ybGRUcmFuc2Zvcm0udHg7Ly9bMl07XG4gICAgdmFyIHR5ID0gd29ybGRUcmFuc2Zvcm0udHk7Ly8vWzVdO1xuXG4gICAgLy8geHlcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhICogdzEgKyBjICogaDEgKyB0eDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBkICogaDEgKyBiICogdzEgKyB0eTtcbiAgICAvLyB1dlxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy54MDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueTA7XG4gICAgLy8gY29sb3JcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhbHBoYTtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB0aW50O1xuXG4gICAgLy8geHlcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSAoYSAqIHcwICsgYyAqIGgxICsgdHgpO1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IGQgKiBoMSArIGIgKiB3MCArIHR5O1xuICAgIC8vIHV2XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdXZzLngxO1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy55MTtcbiAgICAvLyBjb2xvclxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IGFscGhhO1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHRpbnQ7XG4gICAgXG4gICAgLy8geHlcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhICogdzAgKyBjICogaDAgKyB0eDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBkICogaDAgKyBiICogdzAgKyB0eTtcbiAgICAvLyB1dlxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy54MjtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueTI7XG4gICAgLy8gY29sb3JcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhbHBoYTtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB0aW50O1xuXG4gICAgLy8geHlcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhICogdzEgKyBjICogaDAgKyB0eDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBkICogaDAgKyBiICogdzEgKyB0eTtcbiAgICAvLyB1dlxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy54MztcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueTM7XG4gICAgLy8gY29sb3JcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhbHBoYTtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB0aW50O1xuXG4gICAgLy8gaW5jcmVtZW50IHRoZSBiYXRjaHNcbiAgICB0aGlzLnRleHR1cmVzW3RoaXMuY3VycmVudEJhdGNoU2l6ZV0gPSB0ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgIHRoaXMuYmxlbmRNb2Rlc1t0aGlzLmN1cnJlbnRCYXRjaFNpemVdID0gdGlsaW5nU3ByaXRlLmJsZW5kTW9kZTtcbiAgICB0aGlzLmN1cnJlbnRCYXRjaFNpemUrKztcbn07XG5cblxuLyoqXG4qIFJlbmRlcnMgdGhlIGNvbnRlbnQgYW5kIGVtcHRpZXMgdGhlIGN1cnJlbnQgYmF0Y2hcbipcbiogQG1ldGhvZCBmbHVzaFxuKiBcbiovXG5QSVhJLldlYkdMU3ByaXRlQmF0Y2gucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oKVxue1xuICAgIC8vIElmIHRoZSBiYXRjaCBpcyBsZW5ndGggMCB0aGVuIHJldHVybiBhcyB0aGVyZSBpcyBub3RoaW5nIHRvIGRyYXdcbiAgICBpZiAodGhpcy5jdXJyZW50QmF0Y2hTaXplPT09MClyZXR1cm47XG5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIuc2V0U2hhZGVyKHRoaXMucmVuZGVyU2Vzc2lvbi5zaGFkZXJNYW5hZ2VyLmRlZmF1bHRTaGFkZXIpO1xuXG4gICAgaWYodGhpcy5kaXJ0eSlcbiAgICB7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgLy8gYmluZCB0aGUgbWFpbiB0ZXh0dXJlXG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuXG4gICAgICAgIC8vIGJpbmQgdGhlIGJ1ZmZlcnNcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGV4QnVmZmVyKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRleEJ1ZmZlcik7XG5cbiAgICAgICAgLy8gc2V0IHRoZSBwcm9qZWN0aW9uXG4gICAgICAgIHZhciBwcm9qZWN0aW9uID0gdGhpcy5yZW5kZXJTZXNzaW9uLnByb2plY3Rpb247XG4gICAgICAgIGdsLnVuaWZvcm0yZih0aGlzLnNoYWRlci5wcm9qZWN0aW9uVmVjdG9yLCBwcm9qZWN0aW9uLngsIHByb2plY3Rpb24ueSk7XG5cbiAgICAgICAgLy8gc2V0IHRoZSBwb2ludGVyc1xuICAgICAgICB2YXIgc3RyaWRlID0gIHRoaXMudmVydFNpemUgKiA0O1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuc2hhZGVyLmFWZXJ0ZXhQb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBzdHJpZGUsIDApO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuc2hhZGVyLmFUZXh0dXJlQ29vcmQsIDIsIGdsLkZMT0FULCBmYWxzZSwgc3RyaWRlLCAyICogNCk7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5zaGFkZXIuY29sb3JBdHRyaWJ1dGUsIDIsIGdsLkZMT0FULCBmYWxzZSwgc3RyaWRlLCA0ICogNCk7XG5cbiAgICB9XG5cbiAgICAvLyB1cGxvYWQgdGhlIHZlcnRzIHRvIHRoZSBidWZmZXIgIFxuICAgIGlmKHRoaXMuY3VycmVudEJhdGNoU2l6ZSA+ICggdGhpcy5zaXplICogMC41ICkgKVxuICAgIHtcbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHRoaXMudmVydGljZXMpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmVydGljZXMuc3ViYXJyYXkoMCwgdGhpcy5jdXJyZW50QmF0Y2hTaXplICogNCAqIHRoaXMudmVydFNpemUpO1xuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdmlldyk7XG4gICAgfVxuXG4gICAgdmFyIG5leHRUZXh0dXJlLCBuZXh0QmxlbmRNb2RlO1xuICAgIHZhciBiYXRjaFNpemUgPSAwO1xuICAgIHZhciBzdGFydCA9IDA7XG5cbiAgICB2YXIgY3VycmVudEJhc2VUZXh0dXJlID0gbnVsbDtcbiAgICB2YXIgY3VycmVudEJsZW5kTW9kZSA9IHRoaXMucmVuZGVyU2Vzc2lvbi5ibGVuZE1vZGVNYW5hZ2VyLmN1cnJlbnRCbGVuZE1vZGU7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuY3VycmVudEJhdGNoU2l6ZTsgaSA8IGo7IGkrKykge1xuICAgICAgICBcbiAgICAgICAgbmV4dFRleHR1cmUgPSB0aGlzLnRleHR1cmVzW2ldO1xuICAgICAgICBuZXh0QmxlbmRNb2RlID0gdGhpcy5ibGVuZE1vZGVzW2ldO1xuXG4gICAgICAgIGlmKGN1cnJlbnRCYXNlVGV4dHVyZSAhPT0gbmV4dFRleHR1cmUgfHwgY3VycmVudEJsZW5kTW9kZSAhPT0gbmV4dEJsZW5kTW9kZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJCYXRjaChjdXJyZW50QmFzZVRleHR1cmUsIGJhdGNoU2l6ZSwgc3RhcnQpO1xuXG4gICAgICAgICAgICBzdGFydCA9IGk7XG4gICAgICAgICAgICBiYXRjaFNpemUgPSAwO1xuICAgICAgICAgICAgY3VycmVudEJhc2VUZXh0dXJlID0gbmV4dFRleHR1cmU7XG4gICAgICAgICAgICBjdXJyZW50QmxlbmRNb2RlID0gbmV4dEJsZW5kTW9kZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTZXNzaW9uLmJsZW5kTW9kZU1hbmFnZXIuc2V0QmxlbmRNb2RlKCBjdXJyZW50QmxlbmRNb2RlICk7XG4gICAgICAgIH1cblxuICAgICAgICBiYXRjaFNpemUrKztcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlckJhdGNoKGN1cnJlbnRCYXNlVGV4dHVyZSwgYmF0Y2hTaXplLCBzdGFydCk7XG5cbiAgICAvLyB0aGVuIHJlc2V0IHRoZSBiYXRjaCFcbiAgICB0aGlzLmN1cnJlbnRCYXRjaFNpemUgPSAwO1xufTtcblxuUElYSS5XZWJHTFNwcml0ZUJhdGNoLnByb3RvdHlwZS5yZW5kZXJCYXRjaCA9IGZ1bmN0aW9uKHRleHR1cmUsIHNpemUsIHN0YXJ0SW5kZXgpXG57XG4gICAgaWYoc2l6ZSA9PT0gMClyZXR1cm47XG5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIC8vIGJpbmQgdGhlIGN1cnJlbnQgdGV4dHVyZVxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdIHx8IFBJWEkuY3JlYXRlV2ViR0xUZXh0dXJlKHRleHR1cmUsIGdsKSk7XG5cbiAgICAvLyBjaGVjayBpZiBhIHRleHR1cmUgaXMgZGlydHkuLlxuICAgIGlmKHRleHR1cmUuX2RpcnR5W2dsLmlkXSlcbiAgICB7XG4gICAgICAgIFBJWEkudXBkYXRlV2ViR0xUZXh0dXJlKHRoaXMuY3VycmVudEJhc2VUZXh0dXJlLCBnbCk7XG4gICAgfVxuXG4gICAgLy8gbm93IGRyYXcgdGhvc2Ugc3Vja2FzIVxuICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIHNpemUgKiA2LCBnbC5VTlNJR05FRF9TSE9SVCwgc3RhcnRJbmRleCAqIDYgKiAyKTtcbiAgICBcbiAgICAvLyBpbmNyZW1lbnQgdGhlIGRyYXcgY291bnRcbiAgICB0aGlzLnJlbmRlclNlc3Npb24uZHJhd0NvdW50Kys7XG59O1xuXG4vKipcbiogXG4qIEBtZXRob2Qgc3RvcFxuKlxuKi9cblBJWEkuV2ViR0xTcHJpdGVCYXRjaC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmZsdXNoKCk7XG59O1xuXG4vKipcbiogXG4qIEBtZXRob2Qgc3RhcnRcbipcbiovXG5QSVhJLldlYkdMU3ByaXRlQmF0Y2gucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xufTtcblxuLyoqXG4qIERlc3Ryb3lzIHRoZSBTcHJpdGVCYXRjaFxuKiBAbWV0aG9kIGRlc3Ryb3lcbiovXG5QSVhJLldlYkdMU3ByaXRlQmF0Y2gucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXG57XG5cbiAgICB0aGlzLnZlcnRpY2VzID0gbnVsbDtcbiAgICB0aGlzLmluZGljZXMgPSBudWxsO1xuICAgIFxuICAgIHRoaXMuZ2wuZGVsZXRlQnVmZmVyKCB0aGlzLnZlcnRleEJ1ZmZlciApO1xuICAgIHRoaXMuZ2wuZGVsZXRlQnVmZmVyKCB0aGlzLmluZGV4QnVmZmVyICk7XG4gICAgXG4gICAgdGhpcy5jdXJyZW50QmFzZVRleHR1cmUgPSBudWxsO1xuICAgIFxuICAgIHRoaXMuZ2wgPSBudWxsO1xufTtcblxuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3Zlc1xuICogXG4gKiBCaWcgdGhhbmtzIHRvIHRoZSB2ZXJ5IGNsZXZlciBNYXR0IERlc0xhdXJpZXJzIDxtYXR0ZGVzbD4gaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL1xuICogZm9yIGNyZWF0aW5nIHRoZSBvcmlnaW5hbCBwaXhpIHZlcnNpb24hXG4gKlxuICogSGVhdmlseSBpbnNwaXJlZCBieSBMaWJHRFgncyBXZWJHTFNwcml0ZUJhdGNoOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2xpYmdkeC9saWJnZHgvYmxvYi9tYXN0ZXIvZ2R4L3NyYy9jb20vYmFkbG9naWMvZ2R4L2dyYXBoaWNzL2cyZC9XZWJHTFNwcml0ZUJhdGNoLmphdmFcbiAqL1xuXG5QSVhJLldlYkdMRmFzdFNwcml0ZUJhdGNoID0gZnVuY3Rpb24oZ2wpXG57XG4gICBcblxuICAgIHRoaXMudmVydFNpemUgPSAxMDtcbiAgICB0aGlzLm1heFNpemUgPSA2MDAwOy8vTWF0aC5wb3coMiwgMTYpIC8gIHRoaXMudmVydFNpemU7XG4gICAgdGhpcy5zaXplID0gdGhpcy5tYXhTaXplO1xuXG4gICAgLy90aGUgdG90YWwgbnVtYmVyIG9mIGZsb2F0cyBpbiBvdXIgYmF0Y2hcbiAgICB2YXIgbnVtVmVydHMgPSB0aGlzLnNpemUgKiA0ICogIHRoaXMudmVydFNpemU7XG4gICAgLy90aGUgdG90YWwgbnVtYmVyIG9mIGluZGljZXMgaW4gb3VyIGJhdGNoXG4gICAgdmFyIG51bUluZGljZXMgPSB0aGlzLm1heFNpemUgKiA2O1xuXG4gICAgIC8vdmVydGV4IGRhdGFcbiAgICB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShudW1WZXJ0cyk7XG4gICAgLy9pbmRleCBkYXRhXG4gICAgdGhpcy5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KG51bUluZGljZXMpO1xuICAgIFxuICAgIHRoaXMudmVydGV4QnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gbnVsbDtcblxuICAgIHRoaXMubGFzdEluZGV4Q291bnQgPSAwO1xuXG4gICAgZm9yICh2YXIgaT0wLCBqPTA7IGkgPCBudW1JbmRpY2VzOyBpICs9IDYsIGogKz0gNClcbiAgICB7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgMF0gPSBqICsgMDtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyAxXSA9IGogKyAxO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDJdID0gaiArIDI7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgM10gPSBqICsgMDtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyA0XSA9IGogKyAyO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDVdID0gaiArIDM7XG4gICAgfVxuXG4gICAgdGhpcy5kcmF3aW5nID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50QmF0Y2hTaXplID0gMDtcbiAgICB0aGlzLmN1cnJlbnRCYXNlVGV4dHVyZSA9IG51bGw7XG4gICBcbiAgICB0aGlzLmN1cnJlbnRCbGVuZE1vZGUgPSAwO1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbiA9IG51bGw7XG4gICAgXG5cbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XG5cbiAgICB0aGlzLm1hdHJpeCA9IG51bGw7XG5cbiAgICB0aGlzLnNldENvbnRleHQoZ2wpO1xufTtcblxuUElYSS5XZWJHTEZhc3RTcHJpdGVCYXRjaC5wcm90b3R5cGUuc2V0Q29udGV4dCA9IGZ1bmN0aW9uKGdsKVxue1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIC8vIGNyZWF0ZSBhIGNvdXBsZSBvZiBidWZmZXJzXG4gICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICAvLyA2NTUzNSBpcyBtYXggaW5kZXgsIHNvIDY1NTM1IC8gNiA9IDEwOTIyLlxuXG5cbiAgICAvL3VwbG9hZCB0aGUgaW5kZXggZGF0YVxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kaWNlcywgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGV4QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0aWNlcywgZ2wuRFlOQU1JQ19EUkFXKTtcbn07XG5cblBJWEkuV2ViR0xGYXN0U3ByaXRlQmF0Y2gucHJvdG90eXBlLmJlZ2luID0gZnVuY3Rpb24oc3ByaXRlQmF0Y2gsIHJlbmRlclNlc3Npb24pXG57XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uID0gcmVuZGVyU2Vzc2lvbjtcbiAgICB0aGlzLnNoYWRlciA9IHRoaXMucmVuZGVyU2Vzc2lvbi5zaGFkZXJNYW5hZ2VyLmZhc3RTaGFkZXI7XG5cbiAgICB0aGlzLm1hdHJpeCA9IHNwcml0ZUJhdGNoLndvcmxkVHJhbnNmb3JtLnRvQXJyYXkodHJ1ZSk7XG5cbiAgICB0aGlzLnN0YXJ0KCk7XG59O1xuXG5QSVhJLldlYkdMRmFzdFNwcml0ZUJhdGNoLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5mbHVzaCgpO1xufTtcblxuXG5QSVhJLldlYkdMRmFzdFNwcml0ZUJhdGNoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihzcHJpdGVCYXRjaClcbntcblxuICAgIHZhciBjaGlsZHJlbiA9IHNwcml0ZUJhdGNoLmNoaWxkcmVuO1xuICAgIHZhciBzcHJpdGUgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoZSB1dnMgaGF2ZSBub3QgdXBkYXRlZCB0aGVuIG5vIHBvaW50IHJlbmRlcmluZyBqdXN0IHlldCFcbiAgICBcbiAgICAvLyBjaGVjayB0ZXh0dXJlLlxuICAgIGlmKCFzcHJpdGUudGV4dHVyZS5fdXZzKXJldHVybjtcbiAgIFxuICAgIHRoaXMuY3VycmVudEJhc2VUZXh0dXJlID0gc3ByaXRlLnRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgXG4gICAgLy8gY2hlY2sgYmxlbmQgbW9kZVxuICAgIGlmKHNwcml0ZS5ibGVuZE1vZGUgIT09IHRoaXMucmVuZGVyU2Vzc2lvbi5ibGVuZE1vZGVNYW5hZ2VyLmN1cnJlbnRCbGVuZE1vZGUpXG4gICAge1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5ibGVuZE1vZGVNYW5hZ2VyLnNldEJsZW5kTW9kZShzcHJpdGUuYmxlbmRNb2RlKTtcbiAgICB9XG4gICAgXG4gICAgZm9yKHZhciBpPTAsaj0gY2hpbGRyZW4ubGVuZ3RoOyBpPGo7IGkrKylcbiAgICB7XG4gICAgICAgIHRoaXMucmVuZGVyU3ByaXRlKGNoaWxkcmVuW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLmZsdXNoKCk7XG59O1xuXG5QSVhJLldlYkdMRmFzdFNwcml0ZUJhdGNoLnByb3RvdHlwZS5yZW5kZXJTcHJpdGUgPSBmdW5jdGlvbihzcHJpdGUpXG57XG4gICAgLy9zcHJpdGUgPSBjaGlsZHJlbltpXTtcbiAgICBpZighc3ByaXRlLnZpc2libGUpcmV0dXJuO1xuICAgIFxuICAgIC8vIFRPRE8gdHJpbT8/XG4gICAgaWYoc3ByaXRlLnRleHR1cmUuYmFzZVRleHR1cmUgIT09IHRoaXMuY3VycmVudEJhc2VUZXh0dXJlKVxuICAgIHtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRCYXNlVGV4dHVyZSA9IHNwcml0ZS50ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgICAgICBcbiAgICAgICAgaWYoIXNwcml0ZS50ZXh0dXJlLl91dnMpcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB1dnMsIHZlcnRpY2llcyA9IHRoaXMudmVydGljZXMsIHdpZHRoLCBoZWlnaHQsIHcwLCB3MSwgaDAsIGgxLCBpbmRleDtcblxuICAgIHV2cyA9IHNwcml0ZS50ZXh0dXJlLl91dnM7XG5cblxuICAgIHdpZHRoID0gc3ByaXRlLnRleHR1cmUuZnJhbWUud2lkdGg7XG4gICAgaGVpZ2h0ID0gc3ByaXRlLnRleHR1cmUuZnJhbWUuaGVpZ2h0O1xuXG4gICAgaWYgKHNwcml0ZS50ZXh0dXJlLnRyaW0pXG4gICAge1xuICAgICAgICAvLyBpZiB0aGUgc3ByaXRlIGlzIHRyaW1tZWQgdGhlbiB3ZSBuZWVkIHRvIGFkZCB0aGUgZXh0cmEgc3BhY2UgYmVmb3JlIHRyYW5zZm9ybWluZyB0aGUgc3ByaXRlIGNvb3Jkcy4uXG4gICAgICAgIHZhciB0cmltID0gc3ByaXRlLnRleHR1cmUudHJpbTtcblxuICAgICAgICB3MSA9IHRyaW0ueCAtIHNwcml0ZS5hbmNob3IueCAqIHRyaW0ud2lkdGg7XG4gICAgICAgIHcwID0gdzEgKyBzcHJpdGUudGV4dHVyZS5jcm9wLndpZHRoO1xuXG4gICAgICAgIGgxID0gdHJpbS55IC0gc3ByaXRlLmFuY2hvci55ICogdHJpbS5oZWlnaHQ7XG4gICAgICAgIGgwID0gaDEgKyBzcHJpdGUudGV4dHVyZS5jcm9wLmhlaWdodDtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdzAgPSAoc3ByaXRlLnRleHR1cmUuZnJhbWUud2lkdGggKSAqICgxLXNwcml0ZS5hbmNob3IueCk7XG4gICAgICAgIHcxID0gKHNwcml0ZS50ZXh0dXJlLmZyYW1lLndpZHRoICkgKiAtc3ByaXRlLmFuY2hvci54O1xuXG4gICAgICAgIGgwID0gc3ByaXRlLnRleHR1cmUuZnJhbWUuaGVpZ2h0ICogKDEtc3ByaXRlLmFuY2hvci55KTtcbiAgICAgICAgaDEgPSBzcHJpdGUudGV4dHVyZS5mcmFtZS5oZWlnaHQgKiAtc3ByaXRlLmFuY2hvci55O1xuICAgIH1cblxuICAgIGluZGV4ID0gdGhpcy5jdXJyZW50QmF0Y2hTaXplICogNCAqIHRoaXMudmVydFNpemU7XG5cbiAgICAvLyB4eVxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHcxO1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IGgxO1xuXG4gICAgdmVydGljaWVzW2luZGV4KytdID0gc3ByaXRlLnBvc2l0aW9uLng7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gc3ByaXRlLnBvc2l0aW9uLnk7XG5cbiAgICAvL3NjYWxlXG4gICAgdmVydGljaWVzW2luZGV4KytdID0gc3ByaXRlLnNjYWxlLng7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gc3ByaXRlLnNjYWxlLnk7XG5cbiAgICAvL3JvdGF0aW9uXG4gICAgdmVydGljaWVzW2luZGV4KytdID0gc3ByaXRlLnJvdGF0aW9uO1xuXG4gICAgLy8gdXZcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueDA7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdXZzLnkxO1xuICAgIC8vIGNvbG9yXG4gICAgdmVydGljaWVzW2luZGV4KytdID0gc3ByaXRlLmFscGhhO1xuIFxuXG4gICAgLy8geHlcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB3MDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBoMTtcblxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5wb3NpdGlvbi54O1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5wb3NpdGlvbi55O1xuXG4gICAgLy9zY2FsZVxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5zY2FsZS54O1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5zY2FsZS55O1xuXG4gICAgIC8vcm90YXRpb25cbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUucm90YXRpb247XG5cbiAgICAvLyB1dlxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy54MTtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueTE7XG4gICAgLy8gY29sb3JcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUuYWxwaGE7XG4gIFxuXG4gICAgLy8geHlcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB3MDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBoMDtcblxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5wb3NpdGlvbi54O1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5wb3NpdGlvbi55O1xuXG4gICAgLy9zY2FsZVxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5zY2FsZS54O1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5zY2FsZS55O1xuXG4gICAgIC8vcm90YXRpb25cbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUucm90YXRpb247XG5cbiAgICAvLyB1dlxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy54MjtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueTI7XG4gICAgLy8gY29sb3JcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUuYWxwaGE7XG4gXG5cblxuXG4gICAgLy8geHlcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB3MTtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBoMDtcblxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5wb3NpdGlvbi54O1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5wb3NpdGlvbi55O1xuXG4gICAgLy9zY2FsZVxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5zY2FsZS54O1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5zY2FsZS55O1xuXG4gICAgIC8vcm90YXRpb25cbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUucm90YXRpb247XG5cbiAgICAvLyB1dlxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy54MztcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueTM7XG4gICAgLy8gY29sb3JcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUuYWxwaGE7XG5cbiAgICAvLyBpbmNyZW1lbnQgdGhlIGJhdGNoc1xuICAgIHRoaXMuY3VycmVudEJhdGNoU2l6ZSsrO1xuXG4gICAgaWYodGhpcy5jdXJyZW50QmF0Y2hTaXplID49IHRoaXMuc2l6ZSlcbiAgICB7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG59O1xuXG5QSVhJLldlYkdMRmFzdFNwcml0ZUJhdGNoLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKClcbntcblxuICAgIC8vIElmIHRoZSBiYXRjaCBpcyBsZW5ndGggMCB0aGVuIHJldHVybiBhcyB0aGVyZSBpcyBub3RoaW5nIHRvIGRyYXdcbiAgICBpZiAodGhpcy5jdXJyZW50QmF0Y2hTaXplPT09MClyZXR1cm47XG5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIFxuICAgIC8vIGJpbmQgdGhlIGN1cnJlbnQgdGV4dHVyZVxuXG4gICAgaWYoIXRoaXMuY3VycmVudEJhc2VUZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSlQSVhJLmNyZWF0ZVdlYkdMVGV4dHVyZSh0aGlzLmN1cnJlbnRCYXNlVGV4dHVyZSwgZ2wpO1xuXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5jdXJyZW50QmFzZVRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKTtcblxuICAgIC8vIHVwbG9hZCB0aGUgdmVydHMgdG8gdGhlIGJ1ZmZlclxuXG4gICBcbiAgICBpZih0aGlzLmN1cnJlbnRCYXRjaFNpemUgPiAoIHRoaXMuc2l6ZSAqIDAuNSApIClcbiAgICB7XG4gICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB0aGlzLnZlcnRpY2VzKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZlcnRpY2VzLnN1YmFycmF5KDAsIHRoaXMuY3VycmVudEJhdGNoU2l6ZSAqIDQgKiB0aGlzLnZlcnRTaXplKTtcblxuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdmlldyk7XG4gICAgfVxuICAgIFxuICAgIFxuICAgIC8vIG5vdyBkcmF3IHRob3NlIHN1Y2thcyFcbiAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCB0aGlzLmN1cnJlbnRCYXRjaFNpemUgKiA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG4gICBcbiAgICAvLyB0aGVuIHJlc2V0IHRoZSBiYXRjaCFcbiAgICB0aGlzLmN1cnJlbnRCYXRjaFNpemUgPSAwO1xuXG4gICAgLy8gaW5jcmVtZW50IHRoZSBkcmF3IGNvdW50XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLmRyYXdDb3VudCsrO1xufTtcblxuXG5QSVhJLldlYkdMRmFzdFNwcml0ZUJhdGNoLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuZmx1c2goKTtcbn07XG5cblBJWEkuV2ViR0xGYXN0U3ByaXRlQmF0Y2gucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICAvLyBiaW5kIHRoZSBtYWluIHRleHR1cmVcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcblxuICAgIC8vIGJpbmQgdGhlIGJ1ZmZlcnNcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0ZXhCdWZmZXIpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXIpO1xuXG4gICAgLy8gc2V0IHRoZSBwcm9qZWN0aW9uXG4gICAgdmFyIHByb2plY3Rpb24gPSB0aGlzLnJlbmRlclNlc3Npb24ucHJvamVjdGlvbjtcbiAgICBnbC51bmlmb3JtMmYodGhpcy5zaGFkZXIucHJvamVjdGlvblZlY3RvciwgcHJvamVjdGlvbi54LCBwcm9qZWN0aW9uLnkpO1xuXG4gICAgLy8gc2V0IHRoZSBtYXRyaXhcbiAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHRoaXMuc2hhZGVyLnVNYXRyaXgsIGZhbHNlLCB0aGlzLm1hdHJpeCk7XG5cbiAgICAvLyBzZXQgdGhlIHBvaW50ZXJzXG4gICAgdmFyIHN0cmlkZSA9ICB0aGlzLnZlcnRTaXplICogNDtcblxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5zaGFkZXIuYVZlcnRleFBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIHN0cmlkZSwgMCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnNoYWRlci5hUG9zaXRpb25Db29yZCwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBzdHJpZGUsIDIgKiA0KTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuc2hhZGVyLmFTY2FsZSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBzdHJpZGUsIDQgKiA0KTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuc2hhZGVyLmFSb3RhdGlvbiwgMSwgZ2wuRkxPQVQsIGZhbHNlLCBzdHJpZGUsIDYgKiA0KTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuc2hhZGVyLmFUZXh0dXJlQ29vcmQsIDIsIGdsLkZMT0FULCBmYWxzZSwgc3RyaWRlLCA3ICogNCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnNoYWRlci5jb2xvckF0dHJpYnV0ZSwgMSwgZ2wuRkxPQVQsIGZhbHNlLCBzdHJpZGUsIDkgKiA0KTtcblxuICAgIFxufTtcblxuXG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4qIEBjbGFzcyBXZWJHTEZpbHRlck1hbmFnZXJcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSBnbCB7V2ViR0xDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiogQHBhcmFtIHRyYW5zcGFyZW50IHtCb29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgZHJhd2luZyBjb250ZXh0IHNob3VsZCBiZSB0cmFuc3BhcmVudFxuKiBAcHJpdmF0ZVxuKi9cblBJWEkuV2ViR0xGaWx0ZXJNYW5hZ2VyID0gZnVuY3Rpb24oZ2wsIHRyYW5zcGFyZW50KVxue1xuICAgIHRoaXMudHJhbnNwYXJlbnQgPSB0cmFuc3BhcmVudDtcblxuICAgIHRoaXMuZmlsdGVyU3RhY2sgPSBbXTtcbiAgICBcbiAgICB0aGlzLm9mZnNldFggPSAwO1xuICAgIHRoaXMub2Zmc2V0WSA9IDA7XG5cbiAgICB0aGlzLnNldENvbnRleHQoZ2wpO1xufTtcblxuLy8gQVBJXG4vKipcbiogSW5pdGlhbGlzZXMgdGhlIGNvbnRleHQgYW5kIHRoZSBwcm9wZXJ0aWVzXG4qIEBtZXRob2Qgc2V0Q29udGV4dCBcbiogQHBhcmFtIGdsIHtXZWJHTENvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuKi9cblBJWEkuV2ViR0xGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5zZXRDb250ZXh0ID0gZnVuY3Rpb24oZ2wpXG57XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMudGV4dHVyZVBvb2wgPSBbXTtcblxuICAgIHRoaXMuaW5pdFNoYWRlckJ1ZmZlcnMoKTtcbn07XG5cbi8qKlxuKiBcbiogQG1ldGhvZCBiZWdpblxuKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7UmVuZGVyU2Vzc2lvbn0gXG4qIEBwYXJhbSBidWZmZXIge0FycmF5QnVmZmVyfSBcbiovXG5QSVhJLldlYkdMRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuYmVnaW4gPSBmdW5jdGlvbihyZW5kZXJTZXNzaW9uLCBidWZmZXIpXG57XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uID0gcmVuZGVyU2Vzc2lvbjtcbiAgICB0aGlzLmRlZmF1bHRTaGFkZXIgPSByZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIuZGVmYXVsdFNoYWRlcjtcblxuICAgIHZhciBwcm9qZWN0aW9uID0gdGhpcy5yZW5kZXJTZXNzaW9uLnByb2plY3Rpb247XG4gICAvLyBjb25zb2xlLmxvZyh0aGlzLndpZHRoKVxuICAgIHRoaXMud2lkdGggPSBwcm9qZWN0aW9uLnggKiAyO1xuICAgIHRoaXMuaGVpZ2h0ID0gLXByb2plY3Rpb24ueSAqIDI7XG4gICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG59O1xuXG4vKipcbiogQXBwbGllcyB0aGUgZmlsdGVyIGFuZCBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IGZpbHRlciBzdGFja1xuKiBAbWV0aG9kIHB1c2hGaWx0ZXJcbiogQHBhcmFtIGZpbHRlckJsb2NrIHtPYmplY3R9IHRoZSBmaWx0ZXIgdGhhdCB3aWxsIGJlIHB1c2hlZCB0byB0aGUgY3VycmVudCBmaWx0ZXIgc3RhY2tcbiovXG5QSVhJLldlYkdMRmlsdGVyTWFuYWdlci5wcm90b3R5cGUucHVzaEZpbHRlciA9IGZ1bmN0aW9uKGZpbHRlckJsb2NrKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICB2YXIgcHJvamVjdGlvbiA9IHRoaXMucmVuZGVyU2Vzc2lvbi5wcm9qZWN0aW9uO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLnJlbmRlclNlc3Npb24ub2Zmc2V0O1xuXG4gICAgZmlsdGVyQmxvY2suX2ZpbHRlckFyZWEgPSBmaWx0ZXJCbG9jay50YXJnZXQuZmlsdGVyQXJlYSB8fCBmaWx0ZXJCbG9jay50YXJnZXQuZ2V0Qm91bmRzKCk7XG5cblxuICAgIC8vIGZpbHRlciBwcm9ncmFtXG4gICAgLy8gT1BUSU1JU0FUSU9OIC0gdGhlIGZpcnN0IGZpbHRlciBpcyBmcmVlIGlmIGl0cyBhIHNpbXBsZSBjb2xvciBjaGFuZ2U/XG4gICAgdGhpcy5maWx0ZXJTdGFjay5wdXNoKGZpbHRlckJsb2NrKTtcblxuICAgIHZhciBmaWx0ZXIgPSBmaWx0ZXJCbG9jay5maWx0ZXJQYXNzZXNbMF07XG5cbiAgICB0aGlzLm9mZnNldFggKz0gZmlsdGVyQmxvY2suX2ZpbHRlckFyZWEueDtcbiAgICB0aGlzLm9mZnNldFkgKz0gZmlsdGVyQmxvY2suX2ZpbHRlckFyZWEueTtcblxuICAgIHZhciB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlUG9vbC5wb3AoKTtcbiAgICBpZighdGV4dHVyZSlcbiAgICB7XG4gICAgICAgIHRleHR1cmUgPSBuZXcgUElYSS5GaWx0ZXJUZXh0dXJlKHRoaXMuZ2wsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGV4dHVyZS5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cblxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsICB0ZXh0dXJlLnRleHR1cmUpO1xuXG4gICAgdmFyIGZpbHRlckFyZWEgPSBmaWx0ZXJCbG9jay5fZmlsdGVyQXJlYTsvLyBmaWx0ZXJCbG9jay50YXJnZXQuZ2V0Qm91bmRzKCk7Ly8vZmlsdGVyQmxvY2sudGFyZ2V0LmZpbHRlckFyZWE7XG5cbiAgICB2YXIgcGFkZGluZyA9IGZpbHRlci5wYWRkaW5nO1xuICAgIGZpbHRlckFyZWEueCAtPSBwYWRkaW5nO1xuICAgIGZpbHRlckFyZWEueSAtPSBwYWRkaW5nO1xuICAgIGZpbHRlckFyZWEud2lkdGggKz0gcGFkZGluZyAqIDI7XG4gICAgZmlsdGVyQXJlYS5oZWlnaHQgKz0gcGFkZGluZyAqIDI7XG5cbiAgICAvLyBjYXAgZmlsdGVyIHRvIHNjcmVlbiBzaXplLi5cbiAgICBpZihmaWx0ZXJBcmVhLnggPCAwKWZpbHRlckFyZWEueCA9IDA7XG4gICAgaWYoZmlsdGVyQXJlYS53aWR0aCA+IHRoaXMud2lkdGgpZmlsdGVyQXJlYS53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgaWYoZmlsdGVyQXJlYS55IDwgMClmaWx0ZXJBcmVhLnkgPSAwO1xuICAgIGlmKGZpbHRlckFyZWEuaGVpZ2h0ID4gdGhpcy5oZWlnaHQpZmlsdGVyQXJlYS5oZWlnaHQgPSB0aGlzLmhlaWdodDtcblxuICAgIC8vZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCAgZmlsdGVyQXJlYS53aWR0aCwgZmlsdGVyQXJlYS5oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGV4dHVyZS5mcmFtZUJ1ZmZlcik7XG5cbiAgICAvLyBzZXQgdmlldyBwb3J0XG4gICAgZ2wudmlld3BvcnQoMCwgMCwgZmlsdGVyQXJlYS53aWR0aCwgZmlsdGVyQXJlYS5oZWlnaHQpO1xuXG4gICAgcHJvamVjdGlvbi54ID0gZmlsdGVyQXJlYS53aWR0aC8yO1xuICAgIHByb2plY3Rpb24ueSA9IC1maWx0ZXJBcmVhLmhlaWdodC8yO1xuXG4gICAgb2Zmc2V0LnggPSAtZmlsdGVyQXJlYS54O1xuICAgIG9mZnNldC55ID0gLWZpbHRlckFyZWEueTtcblxuICAgIC8vIHVwZGF0ZSBwcm9qZWN0aW9uXG4gICAgLy8gbm93IHJlc3RvcmUgdGhlIHJlZ3VsYXIgc2hhZGVyLi5cbiAgICB0aGlzLnJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlci5zZXRTaGFkZXIodGhpcy5kZWZhdWx0U2hhZGVyKTtcbiAgICBnbC51bmlmb3JtMmYodGhpcy5kZWZhdWx0U2hhZGVyLnByb2plY3Rpb25WZWN0b3IsIGZpbHRlckFyZWEud2lkdGgvMiwgLWZpbHRlckFyZWEuaGVpZ2h0LzIpO1xuICAgIGdsLnVuaWZvcm0yZih0aGlzLmRlZmF1bHRTaGFkZXIub2Zmc2V0VmVjdG9yLCAtZmlsdGVyQXJlYS54LCAtZmlsdGVyQXJlYS55KTtcblxuICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICBnbC5jbGVhckNvbG9yKDAsMCwwLCAwKTtcbiAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcblxuICAgIGZpbHRlckJsb2NrLl9nbEZpbHRlclRleHR1cmUgPSB0ZXh0dXJlO1xuXG59O1xuXG5cbi8qKlxuKiBSZW1vdmVzIHRoZSBsYXN0IGZpbHRlciBmcm9tIHRoZSBmaWx0ZXIgc3RhY2sgYW5kIGRvZXNuJ3QgcmV0dXJuIGl0XG4qIEBtZXRob2QgcG9wRmlsdGVyXG4qL1xuUElYSS5XZWJHTEZpbHRlck1hbmFnZXIucHJvdG90eXBlLnBvcEZpbHRlciA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIHZhciBmaWx0ZXJCbG9jayA9IHRoaXMuZmlsdGVyU3RhY2sucG9wKCk7XG4gICAgdmFyIGZpbHRlckFyZWEgPSBmaWx0ZXJCbG9jay5fZmlsdGVyQXJlYTtcbiAgICB2YXIgdGV4dHVyZSA9IGZpbHRlckJsb2NrLl9nbEZpbHRlclRleHR1cmU7XG4gICAgdmFyIHByb2plY3Rpb24gPSB0aGlzLnJlbmRlclNlc3Npb24ucHJvamVjdGlvbjtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5yZW5kZXJTZXNzaW9uLm9mZnNldDtcblxuICAgIGlmKGZpbHRlckJsb2NrLmZpbHRlclBhc3Nlcy5sZW5ndGggPiAxKVxuICAgIHtcbiAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgZmlsdGVyQXJlYS53aWR0aCwgZmlsdGVyQXJlYS5oZWlnaHQpO1xuXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRleEJ1ZmZlcik7XG5cbiAgICAgICAgdGhpcy52ZXJ0ZXhBcnJheVswXSA9IDA7XG4gICAgICAgIHRoaXMudmVydGV4QXJyYXlbMV0gPSBmaWx0ZXJBcmVhLmhlaWdodDtcblxuICAgICAgICB0aGlzLnZlcnRleEFycmF5WzJdID0gZmlsdGVyQXJlYS53aWR0aDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhBcnJheVszXSA9IGZpbHRlckFyZWEuaGVpZ2h0O1xuXG4gICAgICAgIHRoaXMudmVydGV4QXJyYXlbNF0gPSAwO1xuICAgICAgICB0aGlzLnZlcnRleEFycmF5WzVdID0gMDtcblxuICAgICAgICB0aGlzLnZlcnRleEFycmF5WzZdID0gZmlsdGVyQXJlYS53aWR0aDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhBcnJheVs3XSA9IDA7XG5cbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHRoaXMudmVydGV4QXJyYXkpO1xuXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnV2QnVmZmVyKTtcbiAgICAgICAgLy8gbm93IHNldCB0aGUgdXZzLi5cbiAgICAgICAgdGhpcy51dkFycmF5WzJdID0gZmlsdGVyQXJlYS53aWR0aC90aGlzLndpZHRoO1xuICAgICAgICB0aGlzLnV2QXJyYXlbNV0gPSBmaWx0ZXJBcmVhLmhlaWdodC90aGlzLmhlaWdodDtcbiAgICAgICAgdGhpcy51dkFycmF5WzZdID0gZmlsdGVyQXJlYS53aWR0aC90aGlzLndpZHRoO1xuICAgICAgICB0aGlzLnV2QXJyYXlbN10gPSBmaWx0ZXJBcmVhLmhlaWdodC90aGlzLmhlaWdodDtcblxuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdGhpcy51dkFycmF5KTtcblxuICAgICAgICB2YXIgaW5wdXRUZXh0dXJlID0gdGV4dHVyZTtcbiAgICAgICAgdmFyIG91dHB1dFRleHR1cmUgPSB0aGlzLnRleHR1cmVQb29sLnBvcCgpO1xuICAgICAgICBpZighb3V0cHV0VGV4dHVyZSlvdXRwdXRUZXh0dXJlID0gbmV3IFBJWEkuRmlsdGVyVGV4dHVyZSh0aGlzLmdsLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIG91dHB1dFRleHR1cmUucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgICAgICAvLyBuZWVkIHRvIGNsZWFyIHRoaXMgRkJPIGFzIGl0IG1heSBoYXZlIHNvbWUgbGVmdCBvdmVyIGVsZW1lbnRzIGZyb20gYSBwcmV2aW91cyBmaWx0ZXIuXG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgb3V0cHV0VGV4dHVyZS5mcmFtZUJ1ZmZlciApO1xuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcblxuICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbHRlckJsb2NrLmZpbHRlclBhc3Nlcy5sZW5ndGgtMTsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyUGFzcyA9IGZpbHRlckJsb2NrLmZpbHRlclBhc3Nlc1tpXTtcblxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBvdXRwdXRUZXh0dXJlLmZyYW1lQnVmZmVyICk7XG5cbiAgICAgICAgICAgIC8vIHNldCB0ZXh0dXJlXG4gICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGlucHV0VGV4dHVyZS50ZXh0dXJlKTtcblxuICAgICAgICAgICAgLy8gZHJhdyB0ZXh0dXJlLi5cbiAgICAgICAgICAgIC8vZmlsdGVyUGFzcy5hcHBseUZpbHRlclBhc3MoZmlsdGVyQXJlYS53aWR0aCwgZmlsdGVyQXJlYS5oZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5hcHBseUZpbHRlclBhc3MoZmlsdGVyUGFzcywgZmlsdGVyQXJlYSwgZmlsdGVyQXJlYS53aWR0aCwgZmlsdGVyQXJlYS5oZWlnaHQpO1xuXG4gICAgICAgICAgICAvLyBzd2FwIHRoZSB0ZXh0dXJlcy4uXG4gICAgICAgICAgICB2YXIgdGVtcCA9IGlucHV0VGV4dHVyZTtcbiAgICAgICAgICAgIGlucHV0VGV4dHVyZSA9IG91dHB1dFRleHR1cmU7XG4gICAgICAgICAgICBvdXRwdXRUZXh0dXJlID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG5cbiAgICAgICAgdGV4dHVyZSA9IGlucHV0VGV4dHVyZTtcbiAgICAgICAgdGhpcy50ZXh0dXJlUG9vbC5wdXNoKG91dHB1dFRleHR1cmUpO1xuICAgIH1cblxuICAgIHZhciBmaWx0ZXIgPSBmaWx0ZXJCbG9jay5maWx0ZXJQYXNzZXNbZmlsdGVyQmxvY2suZmlsdGVyUGFzc2VzLmxlbmd0aC0xXTtcblxuICAgIHRoaXMub2Zmc2V0WCAtPSBmaWx0ZXJBcmVhLng7XG4gICAgdGhpcy5vZmZzZXRZIC09IGZpbHRlckFyZWEueTtcblxuXG4gICAgdmFyIHNpemVYID0gdGhpcy53aWR0aDtcbiAgICB2YXIgc2l6ZVkgPSB0aGlzLmhlaWdodDtcblxuICAgIHZhciBvZmZzZXRYID0gMDtcbiAgICB2YXIgb2Zmc2V0WSA9IDA7XG5cbiAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG5cbiAgICAvLyB0aW1lIHRvIHJlbmRlciB0aGUgZmlsdGVycyB0ZXh0dXJlIHRvIHRoZSBwcmV2aW91cyBzY2VuZVxuICAgIGlmKHRoaXMuZmlsdGVyU3RhY2subGVuZ3RoID09PSAwKVxuICAgIHtcbiAgICAgICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpOy8vdGhpcy50cmFuc3BhcmVudCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHZhciBjdXJyZW50RmlsdGVyID0gdGhpcy5maWx0ZXJTdGFja1t0aGlzLmZpbHRlclN0YWNrLmxlbmd0aC0xXTtcbiAgICAgICAgZmlsdGVyQXJlYSA9IGN1cnJlbnRGaWx0ZXIuX2ZpbHRlckFyZWE7XG5cbiAgICAgICAgc2l6ZVggPSBmaWx0ZXJBcmVhLndpZHRoO1xuICAgICAgICBzaXplWSA9IGZpbHRlckFyZWEuaGVpZ2h0O1xuXG4gICAgICAgIG9mZnNldFggPSBmaWx0ZXJBcmVhLng7XG4gICAgICAgIG9mZnNldFkgPSBmaWx0ZXJBcmVhLnk7XG5cbiAgICAgICAgYnVmZmVyID0gIGN1cnJlbnRGaWx0ZXIuX2dsRmlsdGVyVGV4dHVyZS5mcmFtZUJ1ZmZlcjtcbiAgICB9XG5cblxuXG4gICAgLy8gVE9ETyBuZWVkIHRvcmVtb3ZlIHRoZWFzZSBnbG9iYWwgZWxlbWVudHMuLlxuICAgIHByb2plY3Rpb24ueCA9IHNpemVYLzI7XG4gICAgcHJvamVjdGlvbi55ID0gLXNpemVZLzI7XG5cbiAgICBvZmZzZXQueCA9IG9mZnNldFg7XG4gICAgb2Zmc2V0LnkgPSBvZmZzZXRZO1xuXG4gICAgZmlsdGVyQXJlYSA9IGZpbHRlckJsb2NrLl9maWx0ZXJBcmVhO1xuXG4gICAgdmFyIHggPSBmaWx0ZXJBcmVhLngtb2Zmc2V0WDtcbiAgICB2YXIgeSA9IGZpbHRlckFyZWEueS1vZmZzZXRZO1xuXG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXJzLi5cbiAgICAvLyBtYWtlIHN1cmUgdG8gZmxpcCB0aGUgeSFcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0ZXhCdWZmZXIpO1xuXG4gICAgdGhpcy52ZXJ0ZXhBcnJheVswXSA9IHg7XG4gICAgdGhpcy52ZXJ0ZXhBcnJheVsxXSA9IHkgKyBmaWx0ZXJBcmVhLmhlaWdodDtcblxuICAgIHRoaXMudmVydGV4QXJyYXlbMl0gPSB4ICsgZmlsdGVyQXJlYS53aWR0aDtcbiAgICB0aGlzLnZlcnRleEFycmF5WzNdID0geSArIGZpbHRlckFyZWEuaGVpZ2h0O1xuXG4gICAgdGhpcy52ZXJ0ZXhBcnJheVs0XSA9IHg7XG4gICAgdGhpcy52ZXJ0ZXhBcnJheVs1XSA9IHk7XG5cbiAgICB0aGlzLnZlcnRleEFycmF5WzZdID0geCArIGZpbHRlckFyZWEud2lkdGg7XG4gICAgdGhpcy52ZXJ0ZXhBcnJheVs3XSA9IHk7XG5cbiAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdGhpcy52ZXJ0ZXhBcnJheSk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy51dkJ1ZmZlcik7XG5cbiAgICB0aGlzLnV2QXJyYXlbMl0gPSBmaWx0ZXJBcmVhLndpZHRoL3RoaXMud2lkdGg7XG4gICAgdGhpcy51dkFycmF5WzVdID0gZmlsdGVyQXJlYS5oZWlnaHQvdGhpcy5oZWlnaHQ7XG4gICAgdGhpcy51dkFycmF5WzZdID0gZmlsdGVyQXJlYS53aWR0aC90aGlzLndpZHRoO1xuICAgIHRoaXMudXZBcnJheVs3XSA9IGZpbHRlckFyZWEuaGVpZ2h0L3RoaXMuaGVpZ2h0O1xuXG4gICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHRoaXMudXZBcnJheSk7XG5cbiAgIC8vY29uc29sZS5sb2codGhpcy52ZXJ0ZXhBcnJheSlcbiAgIC8vY29uc29sZS5sb2codGhpcy51dkFycmF5KVxuICAgIC8vY29uc29sZS5sb2coc2l6ZVggKyBcIiA6IFwiICsgc2l6ZVkpXG5cbiAgICBnbC52aWV3cG9ydCgwLCAwLCBzaXplWCwgc2l6ZVkpO1xuXG4gICAgLy8gYmluZCB0aGUgYnVmZmVyXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBidWZmZXIgKTtcblxuICAgIC8vIHNldCB0aGUgYmxlbmQgbW9kZSEgXG4gICAgLy9nbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKVxuXG4gICAgLy8gc2V0IHRleHR1cmVcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlLnRleHR1cmUpO1xuXG4gICAgLy8gYXBwbHkhXG4gICAgdGhpcy5hcHBseUZpbHRlclBhc3MoZmlsdGVyLCBmaWx0ZXJBcmVhLCBzaXplWCwgc2l6ZVkpO1xuXG4gICAgLy8gbm93IHJlc3RvcmUgdGhlIHJlZ3VsYXIgc2hhZGVyLi5cbiAgICB0aGlzLnJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlci5zZXRTaGFkZXIodGhpcy5kZWZhdWx0U2hhZGVyKTtcbiAgICBnbC51bmlmb3JtMmYodGhpcy5kZWZhdWx0U2hhZGVyLnByb2plY3Rpb25WZWN0b3IsIHNpemVYLzIsIC1zaXplWS8yKTtcbiAgICBnbC51bmlmb3JtMmYodGhpcy5kZWZhdWx0U2hhZGVyLm9mZnNldFZlY3RvciwgLW9mZnNldFgsIC1vZmZzZXRZKTtcblxuICAgIC8vIHJldHVybiB0aGUgdGV4dHVyZSB0byB0aGUgcG9vbFxuICAgIHRoaXMudGV4dHVyZVBvb2wucHVzaCh0ZXh0dXJlKTtcbiAgICBmaWx0ZXJCbG9jay5fZ2xGaWx0ZXJUZXh0dXJlID0gbnVsbDtcbn07XG5cblxuLyoqXG4qIEFwcGxpZXMgdGhlIGZpbHRlciB0byB0aGUgc3BlY2lmaWVkIGFyZWFcbiogQG1ldGhvZCBhcHBseUZpbHRlclBhc3NcbiogQHBhcmFtIGZpbHRlciB7QWJzdHJhY3RGaWx0ZXJ9IHRoZSBmaWx0ZXIgdGhhdCBuZWVkcyB0byBiZSBhcHBsaWVkXG4qIEBwYXJhbSBmaWx0ZXJBcmVhIHt0ZXh0dXJlfSBUT0RPIC0gbWlnaHQgbmVlZCBhbiB1cGRhdGVcbiogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IHRoZSBob3Jpem9udGFsIHJhbmdlIG9mIHRoZSBmaWx0ZXJcbiogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSB0aGUgdmVydGljYWwgcmFuZ2Ugb2YgdGhlIGZpbHRlclxuKi9cblBJWEkuV2ViR0xGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5hcHBseUZpbHRlclBhc3MgPSBmdW5jdGlvbihmaWx0ZXIsIGZpbHRlckFyZWEsIHdpZHRoLCBoZWlnaHQpXG57XG4gICAgLy8gdXNlIHByb2dyYW1cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIHZhciBzaGFkZXIgPSBmaWx0ZXIuc2hhZGVyc1tnbC5pZF07XG5cbiAgICBpZighc2hhZGVyKVxuICAgIHtcbiAgICAgICAgc2hhZGVyID0gbmV3IFBJWEkuUGl4aVNoYWRlcihnbCk7XG5cbiAgICAgICAgc2hhZGVyLmZyYWdtZW50U3JjID0gZmlsdGVyLmZyYWdtZW50U3JjO1xuICAgICAgICBzaGFkZXIudW5pZm9ybXMgPSBmaWx0ZXIudW5pZm9ybXM7XG4gICAgICAgIHNoYWRlci5pbml0KCk7XG5cbiAgICAgICAgZmlsdGVyLnNoYWRlcnNbZ2wuaWRdID0gc2hhZGVyO1xuICAgIH1cblxuICAgIC8vIHNldCB0aGUgc2hhZGVyXG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIuc2V0U2hhZGVyKHNoYWRlcik7XG5cbi8vICAgIGdsLnVzZVByb2dyYW0oc2hhZGVyLnByb2dyYW0pO1xuXG4gICAgZ2wudW5pZm9ybTJmKHNoYWRlci5wcm9qZWN0aW9uVmVjdG9yLCB3aWR0aC8yLCAtaGVpZ2h0LzIpO1xuICAgIGdsLnVuaWZvcm0yZihzaGFkZXIub2Zmc2V0VmVjdG9yLCAwLDApO1xuXG4gICAgaWYoZmlsdGVyLnVuaWZvcm1zLmRpbWVuc2lvbnMpXG4gICAge1xuICAgICAgICBmaWx0ZXIudW5pZm9ybXMuZGltZW5zaW9ucy52YWx1ZVswXSA9IHRoaXMud2lkdGg7Ly93aWR0aDtcbiAgICAgICAgZmlsdGVyLnVuaWZvcm1zLmRpbWVuc2lvbnMudmFsdWVbMV0gPSB0aGlzLmhlaWdodDsvL2hlaWdodDtcbiAgICAgICAgZmlsdGVyLnVuaWZvcm1zLmRpbWVuc2lvbnMudmFsdWVbMl0gPSB0aGlzLnZlcnRleEFycmF5WzBdO1xuICAgICAgICBmaWx0ZXIudW5pZm9ybXMuZGltZW5zaW9ucy52YWx1ZVszXSA9IHRoaXMudmVydGV4QXJyYXlbNV07Ly9maWx0ZXJBcmVhLmhlaWdodDtcbiAgICB9XG5cbiAgLy8gIGNvbnNvbGUubG9nKHRoaXMudXZBcnJheSApXG4gICAgc2hhZGVyLnN5bmNVbmlmb3JtcygpO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGV4QnVmZmVyKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hVmVydGV4UG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy51dkJ1ZmZlcik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYVRleHR1cmVDb29yZCwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmNvbG9yQnVmZmVyKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5jb2xvckF0dHJpYnV0ZSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXIpO1xuXG4gICAgLy8gZHJhdyB0aGUgZmlsdGVyLi4uXG4gICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5kcmF3Q291bnQrKztcbn07XG5cbi8qKlxuKiBJbml0aWFsaXNlcyB0aGUgc2hhZGVyIGJ1ZmZlcnNcbiogQG1ldGhvZCBpbml0U2hhZGVyQnVmZmVyc1xuKi9cblBJWEkuV2ViR0xGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5pbml0U2hhZGVyQnVmZmVycyA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgLy8gY3JlYXRlIHNvbWUgYnVmZmVyc1xuICAgIHRoaXMudmVydGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy51dkJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMuY29sb3JCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cblxuICAgIC8vIGJpbmQgYW5kIHVwbG9hZCB0aGUgdmVydGV4cy4uXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgdmVydGV4RmxvYXREYXRhLi5cbiAgICB0aGlzLnZlcnRleEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShbMC4wLCAwLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEuMCwgMC4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjAsIDEuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMS4wLCAxLjBdKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRleEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShcbiAgICBnbC5BUlJBWV9CVUZGRVIsXG4gICAgdGhpcy52ZXJ0ZXhBcnJheSxcbiAgICBnbC5TVEFUSUNfRFJBVyk7XG5cblxuICAgIC8vIGJpbmQgYW5kIHVwbG9hZCB0aGUgdXYgYnVmZmVyXG4gICAgdGhpcy51dkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShbMC4wLCAwLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMS4wLCAwLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMC4wLCAxLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMS4wLCAxLjBdKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnV2QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKFxuICAgIGdsLkFSUkFZX0JVRkZFUixcbiAgICB0aGlzLnV2QXJyYXksXG4gICAgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgdGhpcy5jb2xvckFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShbMS4wLCAweEZGRkZGRixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLjAsIDB4RkZGRkZGLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEuMCwgMHhGRkZGRkYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMS4wLCAweEZGRkZGRl0pO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuY29sb3JCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoXG4gICAgZ2wuQVJSQVlfQlVGRkVSLFxuICAgIHRoaXMuY29sb3JBcnJheSxcbiAgICBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAvLyBiaW5kIGFuZCB1cGxvYWQgdGhlIGluZGV4XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRleEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShcbiAgICBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUixcbiAgICBuZXcgVWludDE2QXJyYXkoWzAsIDEsIDIsIDEsIDMsIDJdKSxcbiAgICBnbC5TVEFUSUNfRFJBVyk7XG59O1xuXG4vKipcbiogRGVzdHJveXMgdGhlIGZpbHRlciBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBmaWx0ZXIgc3RhY2tcbiogQG1ldGhvZCBkZXN0cm95XG4qL1xuUElYSS5XZWJHTEZpbHRlck1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIHRoaXMuZmlsdGVyU3RhY2sgPSBudWxsO1xuICAgIFxuICAgIHRoaXMub2Zmc2V0WCA9IDA7XG4gICAgdGhpcy5vZmZzZXRZID0gMDtcblxuICAgIC8vIGRlc3Ryb3kgdGV4dHVyZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGV4dHVyZVBvb2wubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlUG9vbFtpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMudGV4dHVyZVBvb2wgPSBudWxsO1xuXG4gICAgLy9kZXN0cm95IGJ1ZmZlcnMuLlxuICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLnZlcnRleEJ1ZmZlcik7XG4gICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMudXZCdWZmZXIpO1xuICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmNvbG9yQnVmZmVyKTtcbiAgICBnbC5kZWxldGVCdWZmZXIodGhpcy5pbmRleEJ1ZmZlcik7XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuKiBAY2xhc3MgRmlsdGVyVGV4dHVyZVxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIGdsIHtXZWJHTENvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuKiBAcGFyYW0gd2lkdGgge051bWJlcn0gdGhlIGhvcml6b250YWwgcmFuZ2Ugb2YgdGhlIGZpbHRlclxuKiBAcGFyYW0gaGVpZ2h0IHtOdW1iZXJ9IHRoZSB2ZXJ0aWNhbCByYW5nZSBvZiB0aGUgZmlsdGVyXG4qIEBwYXJhbSBzY2FsZU1vZGUge051bWJlcn0gU2hvdWxkIGJlIG9uZSBvZiB0aGUgUElYSS5zY2FsZU1vZGUgY29uc3RzXG4qIEBwcml2YXRlXG4qL1xuUElYSS5GaWx0ZXJUZXh0dXJlID0gZnVuY3Rpb24oZ2wsIHdpZHRoLCBoZWlnaHQsIHNjYWxlTW9kZSlcbntcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZ2xcbiAgICAgKiBAdHlwZSBXZWJHTENvbnRleHRcbiAgICAgKi9cbiAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAvLyBuZXh0IHRpbWUgdG8gY3JlYXRlIGEgZnJhbWUgYnVmZmVyIGFuZCB0ZXh0dXJlXG4gICAgdGhpcy5mcmFtZUJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgdGhpcy50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG4gICAgc2NhbGVNb2RlID0gc2NhbGVNb2RlIHx8IFBJWEkuc2NhbGVNb2Rlcy5ERUZBVUxUO1xuXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIHNjYWxlTW9kZSA9PT0gUElYSS5zY2FsZU1vZGVzLkxJTkVBUiA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1QpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBzY2FsZU1vZGUgPT09IFBJWEkuc2NhbGVNb2Rlcy5MSU5FQVIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIgKTtcblxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZUJ1ZmZlciApO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlLCAwKTtcblxuICAgIC8vIHJlcXVpcmVkIGZvciBtYXNraW5nIGEgbWFzaz8/XG4gICAgdGhpcy5yZW5kZXJCdWZmZXIgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5yZW5kZXJCdWZmZXIpO1xuICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5yZW5kZXJCdWZmZXIpO1xuICBcbiAgICB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbn07XG5cblxuLyoqXG4qIENsZWFycyB0aGUgZmlsdGVyIHRleHR1cmVcbiogQG1ldGhvZCBjbGVhclxuKi9cblBJWEkuRmlsdGVyVGV4dHVyZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBcbiAgICBnbC5jbGVhckNvbG9yKDAsMCwwLCAwKTtcbiAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbn07XG5cbi8qKlxuICogUmVzaXplcyB0aGUgdGV4dHVyZSB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHRcbiAqXG4gKiBAbWV0aG9kIHJlc2l6ZVxuICogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IHRoZSBuZXcgd2lkdGggb2YgdGhlIHRleHR1cmVcbiAqIEBwYXJhbSBoZWlnaHQge051bWJlcn0gdGhlIG5ldyBoZWlnaHQgb2YgdGhlIHRleHR1cmVcbiAqL1xuUElYSS5GaWx0ZXJUZXh0dXJlLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KVxue1xuICAgIGlmKHRoaXMud2lkdGggPT09IHdpZHRoICYmIHRoaXMuaGVpZ2h0ID09PSBoZWlnaHQpIHJldHVybjtcblxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCAgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsICB3aWR0aCwgaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgc3RlbmNpbCBidWZmZXIgd2lkdGggYW5kIGhlaWdodFxuICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlcik7XG4gICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX1NURU5DSUwsIHdpZHRoLCBoZWlnaHQpO1xufTtcblxuLyoqXG4qIERlc3Ryb3lzIHRoZSBmaWx0ZXIgdGV4dHVyZVxuKiBAbWV0aG9kIGRlc3Ryb3lcbiovXG5QSVhJLkZpbHRlclRleHR1cmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlciggdGhpcy5mcmFtZUJ1ZmZlciApO1xuICAgIGdsLmRlbGV0ZVRleHR1cmUoIHRoaXMudGV4dHVyZSApO1xuXG4gICAgdGhpcy5mcmFtZUJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzXG4gKiBcbiAqIFxuICovXG4vKipcbiAqIEEgc2V0IG9mIGZ1bmN0aW9ucyB1c2VkIHRvIGhhbmRsZSBtYXNraW5nXG4gKlxuICogQGNsYXNzIENhbnZhc01hc2tNYW5hZ2VyXG4gKi9cblBJWEkuQ2FudmFzTWFza01hbmFnZXIgPSBmdW5jdGlvbigpXG57XG4gICAgXG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgc3RhY2sgb2YgbWFza3NcbiAqXG4gKiBAbWV0aG9kIHB1c2hNYXNrXG4gKiBAcGFyYW0gbWFza0RhdGEgdGhlIG1hc2tEYXRhIHRoYXQgd2lsbCBiZSBwdXNoZWRcbiAqIEBwYXJhbSBjb250ZXh0IHtDb250ZXh0MkR9IHRoZSAyZCBkcmF3aW5nIG1ldGhvZCBvZiB0aGUgY2FudmFzXG4gKi9cblBJWEkuQ2FudmFzTWFza01hbmFnZXIucHJvdG90eXBlLnB1c2hNYXNrID0gZnVuY3Rpb24obWFza0RhdGEsIGNvbnRleHQpXG57XG4gICAgY29udGV4dC5zYXZlKCk7XG4gICAgXG4gICAgdmFyIGNhY2hlQWxwaGEgPSBtYXNrRGF0YS5hbHBoYTtcbiAgICB2YXIgdHJhbnNmb3JtID0gbWFza0RhdGEud29ybGRUcmFuc2Zvcm07XG5cbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybSh0cmFuc2Zvcm0uYSwgdHJhbnNmb3JtLmMsIHRyYW5zZm9ybS5iLCB0cmFuc2Zvcm0uZCwgdHJhbnNmb3JtLnR4LCB0cmFuc2Zvcm0udHkpO1xuXG4gICAgUElYSS5DYW52YXNHcmFwaGljcy5yZW5kZXJHcmFwaGljc01hc2sobWFza0RhdGEsIGNvbnRleHQpO1xuXG4gICAgY29udGV4dC5jbGlwKCk7XG5cbiAgICBtYXNrRGF0YS53b3JsZEFscGhhID0gY2FjaGVBbHBoYTtcbn07XG5cbi8qKlxuICogUmVzdG9yZXMgdGhlIGN1cnJlbnQgZHJhd2luZyBjb250ZXh0IHRvIHRoZSBzdGF0ZSBpdCB3YXMgYmVmb3JlIHRoZSBtYXNrIHdhcyBhcHBsaWVkXG4gKlxuICogQG1ldGhvZCBwb3BNYXNrXG4gKiBAcGFyYW0gY29udGV4dCB7Q29udGV4dDJEfSB0aGUgMmQgZHJhd2luZyBtZXRob2Qgb2YgdGhlIGNhbnZhc1xuICovXG5QSVhJLkNhbnZhc01hc2tNYW5hZ2VyLnByb3RvdHlwZS5wb3BNYXNrID0gZnVuY3Rpb24oY29udGV4dClcbntcbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzXG4gKiBcbiAqIFxuICovXG5cbi8qKlxuICogQGNsYXNzIENhbnZhc1RpbnRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAc3RhdGljXG4gKi9cblBJWEkuQ2FudmFzVGludGVyID0gZnVuY3Rpb24oKVxue1xuICAgIC8vLyB0aGlzLnRleHR1cmVDYWNoXG59O1xuXG4vL1BJWEkuQ2FudmFzVGludGVyLmNhY2hUaW50ID0gdHJ1ZTtcbiAgICBcblxuLyoqXG4gKiBCYXNpY2FsbHkgdGhpcyBtZXRob2QganVzdCBuZWVkcyBhIHNwcml0ZSBhbmQgYSBjb2xvciBhbmQgdGludHMgdGhlIHNwcml0ZSBcbiAqIHdpdGggdGhlIGdpdmVuIGNvbG9yXG4gKiBcbiAqIEBtZXRob2QgZ2V0VGludGVkVGV4dHVyZSBcbiAqIEBwYXJhbSBzcHJpdGUge1Nwcml0ZX0gdGhlIHNwcml0ZSB0byB0aW50XG4gKiBAcGFyYW0gY29sb3Ige051bWJlcn0gdGhlIGNvbG9yIHRvIHVzZSB0byB0aW50IHRoZSBzcHJpdGUgd2l0aFxuICovXG5QSVhJLkNhbnZhc1RpbnRlci5nZXRUaW50ZWRUZXh0dXJlID0gZnVuY3Rpb24oc3ByaXRlLCBjb2xvcilcbntcblxuICAgIHZhciB0ZXh0dXJlID0gc3ByaXRlLnRleHR1cmU7XG5cbiAgICBjb2xvciA9IFBJWEkuQ2FudmFzVGludGVyLnJvdW5kQ29sb3IoY29sb3IpO1xuXG4gICAgdmFyIHN0cmluZ0NvbG9yID0gXCIjXCIgKyAoXCIwMDAwMFwiICsgKCBjb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgIFxuICAgIHRleHR1cmUudGludENhY2hlID0gdGV4dHVyZS50aW50Q2FjaGUgfHwge307XG5cbiAgICBpZih0ZXh0dXJlLnRpbnRDYWNoZVtzdHJpbmdDb2xvcl0pIHJldHVybiB0ZXh0dXJlLnRpbnRDYWNoZVtzdHJpbmdDb2xvcl07XG5cbiAgICAgLy8gY2xvbmUgdGV4dHVyZS4uXG4gICAgdmFyIGNhbnZhcyA9IFBJWEkuQ2FudmFzVGludGVyLmNhbnZhcyB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIFxuICAgIC8vUElYSS5DYW52YXNUaW50ZXIudGludFdpdGhQZXJQaXhlbCh0ZXh0dXJlLCBzdHJpbmdDb2xvciwgY2FudmFzKTtcblxuICAgIFxuICAgIFBJWEkuQ2FudmFzVGludGVyLnRpbnRNZXRob2QodGV4dHVyZSwgY29sb3IsIGNhbnZhcyk7XG5cbiAgICBpZihQSVhJLkNhbnZhc1RpbnRlci5jb252ZXJ0VGludFRvSW1hZ2UpXG4gICAge1xuICAgICAgICAvLyBpcyB0aGlzIGJldHRlcj9cbiAgICAgICAgdmFyIHRpbnRJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICB0aW50SW1hZ2Uuc3JjID0gY2FudmFzLnRvRGF0YVVSTCgpO1xuXG4gICAgICAgIHRleHR1cmUudGludENhY2hlW3N0cmluZ0NvbG9yXSA9IHRpbnRJbWFnZTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgIFxuICAgICAgICB0ZXh0dXJlLnRpbnRDYWNoZVtzdHJpbmdDb2xvcl0gPSBjYW52YXM7XG4gICAgICAgIC8vIGlmIHdlIGFyZSBub3QgY29udmVydGluZyB0aGUgdGV4dHVyZSB0byBhbiBpbWFnZSB0aGVuIHdlIG5lZWQgdG8gbG9zZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSBjYW52YXNcbiAgICAgICAgUElYSS5DYW52YXNUaW50ZXIuY2FudmFzID0gbnVsbDtcblxuICAgIH1cblxuICAgIHJldHVybiBjYW52YXM7XG59O1xuXG4vKipcbiAqIFRpbnQgYSB0ZXh0dXJlIHVzaW5nIHRoZSBcIm11bHRpcGx5XCIgb3BlcmF0aW9uXG4gKiBAbWV0aG9kIHRpbnRXaXRoTXVsdGlwbHlcbiAqIEBwYXJhbSB0ZXh0dXJlIHt0ZXh0dXJlfSB0aGUgdGV4dHVyZSB0byB0aW50XG4gKiBAcGFyYW0gY29sb3Ige051bWJlcn0gdGhlIGNvbG9yIHRvIHVzZSB0byB0aW50IHRoZSBzcHJpdGUgd2l0aFxuICogQHBhcmFtIGNhbnZhcyB7SFRNTENhbnZhc0VsZW1lbnR9IHRoZSBjdXJyZW50IGNhbnZhc1xuICovXG5QSVhJLkNhbnZhc1RpbnRlci50aW50V2l0aE11bHRpcGx5ID0gZnVuY3Rpb24odGV4dHVyZSwgY29sb3IsIGNhbnZhcylcbntcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCBcIjJkXCIgKTtcblxuICAgIHZhciBmcmFtZSA9IHRleHR1cmUuZnJhbWU7XG5cbiAgICBjYW52YXMud2lkdGggPSBmcmFtZS53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gZnJhbWUuaGVpZ2h0O1xuXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBcIiNcIiArIChcIjAwMDAwXCIgKyAoIGNvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuICAgIFxuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgZnJhbWUud2lkdGgsIGZyYW1lLmhlaWdodCk7XG4gICAgXG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcIm11bHRpcGx5XCI7XG5cbiAgICBjb250ZXh0LmRyYXdJbWFnZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUuaGVpZ2h0KTtcblxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1hdG9wXCI7XG4gICAgXG4gICAgY29udGV4dC5kcmF3SW1hZ2UodGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLmhlaWdodCk7XG59O1xuXG4vKipcbiAqIFRpbnQgYSB0ZXh0dXJlIHVzaW5nIHRoZSBcIm92ZXJsYXlcIiBvcGVyYXRpb25cbiAqIEBtZXRob2QgdGludFdpdGhPdmVybGF5XG4gKiBAcGFyYW0gdGV4dHVyZSB7dGV4dHVyZX0gdGhlIHRleHR1cmUgdG8gdGludFxuICogQHBhcmFtIGNvbG9yIHtOdW1iZXJ9IHRoZSBjb2xvciB0byB1c2UgdG8gdGludCB0aGUgc3ByaXRlIHdpdGhcbiAqIEBwYXJhbSBjYW52YXMge0hUTUxDYW52YXNFbGVtZW50fSB0aGUgY3VycmVudCBjYW52YXNcbiAqL1xuUElYSS5DYW52YXNUaW50ZXIudGludFdpdGhPdmVybGF5ID0gZnVuY3Rpb24odGV4dHVyZSwgY29sb3IsIGNhbnZhcylcbntcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCBcIjJkXCIgKTtcblxuICAgIHZhciBmcmFtZSA9IHRleHR1cmUuZnJhbWU7XG5cbiAgICBjYW52YXMud2lkdGggPSBmcmFtZS53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gZnJhbWUuaGVpZ2h0O1xuXG4gICAgXG4gICAgXG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImNvcHlcIjtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwiI1wiICsgKFwiMDAwMDBcIiArICggY29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBmcmFtZS53aWR0aCwgZnJhbWUuaGVpZ2h0KTtcblxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1hdG9wXCI7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UodGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLmhlaWdodCk7XG5cbiAgICBcbiAgICAvL2NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJjb3B5XCI7XG5cbn07XG5cbi8qKlxuICogVGludCBhIHRleHR1cmUgcGl4ZWwgcGVyIHBpeGVsXG4gKiBAbWV0aG9kIHRpbnRQZXJQaXhlbFxuICogQHBhcmFtIHRleHR1cmUge3RleHR1cmV9IHRoZSB0ZXh0dXJlIHRvIHRpbnRcbiAqIEBwYXJhbSBjb2xvciB7TnVtYmVyfSB0aGUgY29sb3IgdG8gdXNlIHRvIHRpbnQgdGhlIHNwcml0ZSB3aXRoXG4gKiBAcGFyYW0gY2FudmFzIHtIVE1MQ2FudmFzRWxlbWVudH0gdGhlIGN1cnJlbnQgY2FudmFzXG4gKi9cblBJWEkuQ2FudmFzVGludGVyLnRpbnRXaXRoUGVyUGl4ZWwgPSBmdW5jdGlvbih0ZXh0dXJlLCBjb2xvciwgY2FudmFzKVxue1xuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoIFwiMmRcIiApO1xuXG4gICAgdmFyIGZyYW1lID0gdGV4dHVyZS5mcmFtZTtcblxuICAgIGNhbnZhcy53aWR0aCA9IGZyYW1lLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBmcmFtZS5oZWlnaHQ7XG4gIFxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJjb3B5XCI7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UodGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLmhlaWdodCk7XG5cbiAgICB2YXIgcmdiVmFsdWVzID0gUElYSS5oZXgycmdiKGNvbG9yKTtcbiAgICB2YXIgciA9IHJnYlZhbHVlc1swXSwgZyA9IHJnYlZhbHVlc1sxXSwgYiA9IHJnYlZhbHVlc1syXTtcblxuICAgIHZhciBwaXhlbERhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBmcmFtZS53aWR0aCwgZnJhbWUuaGVpZ2h0KTtcblxuICAgIHZhciBwaXhlbHMgPSBwaXhlbERhdGEuZGF0YTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGl4ZWxzLmxlbmd0aDsgaSArPSA0KVxuICAgIHtcbiAgICAgICAgcGl4ZWxzW2krMF0gKj0gcjtcbiAgICAgICAgcGl4ZWxzW2krMV0gKj0gZztcbiAgICAgICAgcGl4ZWxzW2krMl0gKj0gYjtcbiAgICB9XG5cbiAgICBjb250ZXh0LnB1dEltYWdlRGF0YShwaXhlbERhdGEsIDAsIDApO1xufTtcblxuLyoqXG4gKiBSb3VuZHMgdGhlIHNwZWNpZmllZCBjb2xvciBhY2NvcmRpbmcgdG8gdGhlIFBJWEkuQ2FudmFzVGludGVyLmNhY2hlU3RlcHNQZXJDb2xvckNoYW5uZWxcbiAqIEBtZXRob2Qgcm91bmRDb2xvclxuICogQHBhcmFtIGNvbG9yIHtudW1iZXJ9IHRoZSBjb2xvciB0byByb3VuZCwgc2hvdWxkIGJlIGEgaGV4IGNvbG9yXG4gKi9cblBJWEkuQ2FudmFzVGludGVyLnJvdW5kQ29sb3IgPSBmdW5jdGlvbihjb2xvcilcbntcbiAgICB2YXIgc3RlcCA9IFBJWEkuQ2FudmFzVGludGVyLmNhY2hlU3RlcHNQZXJDb2xvckNoYW5uZWw7XG5cbiAgICB2YXIgcmdiVmFsdWVzID0gUElYSS5oZXgycmdiKGNvbG9yKTtcblxuICAgIHJnYlZhbHVlc1swXSA9IE1hdGgubWluKDI1NSwgKHJnYlZhbHVlc1swXSAvIHN0ZXApICogc3RlcCk7XG4gICAgcmdiVmFsdWVzWzFdID0gTWF0aC5taW4oMjU1LCAocmdiVmFsdWVzWzFdIC8gc3RlcCkgKiBzdGVwKTtcbiAgICByZ2JWYWx1ZXNbMl0gPSBNYXRoLm1pbigyNTUsIChyZ2JWYWx1ZXNbMl0gLyBzdGVwKSAqIHN0ZXApO1xuXG4gICAgcmV0dXJuIFBJWEkucmdiMmhleChyZ2JWYWx1ZXMpO1xufTtcblxuLyoqXG4gKiBcbiAqIE51bWJlciBvZiBzdGVwcyB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYSBjYXAgd2hlbiByb3VuZGluZyBjb2xvcnNcbiAqXG4gKiBAcHJvcGVydHkgY2FjaGVTdGVwc1BlckNvbG9yQ2hhbm5lbFxuICogQHR5cGUgTnVtYmVyXG4gKi9cblBJWEkuQ2FudmFzVGludGVyLmNhY2hlU3RlcHNQZXJDb2xvckNoYW5uZWwgPSA4O1xuLyoqXG4gKiBcbiAqIE51bWJlciBvZiBzdGVwcyB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYSBjYXAgd2hlbiByb3VuZGluZyBjb2xvcnNcbiAqXG4gKiBAcHJvcGVydHkgY29udmVydFRpbnRUb0ltYWdlXG4gKiBAdHlwZSBCb29sZWFuXG4gKi9cblBJWEkuQ2FudmFzVGludGVyLmNvbnZlcnRUaW50VG9JbWFnZSA9IGZhbHNlO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBDYW52YXMgQmxlbmRNb2RlcyBhcmUgc3VwcG9ydGVkLCBjb25zZXF1ZW50bHkgdGhlIGFiaWxpdHkgdG8gdGludCB1c2luZyB0aGUgbXVsdGlwbHkgbWV0aG9kXG4gKlxuICogQHByb3BlcnR5IGNhblVzZU11bHRpcGx5XG4gKiBAdHlwZSBCb29sZWFuXG4gKi9cblBJWEkuQ2FudmFzVGludGVyLmNhblVzZU11bHRpcGx5ID0gUElYSS5jYW5Vc2VOZXdDYW52YXNCbGVuZE1vZGVzKCk7XG5cblBJWEkuQ2FudmFzVGludGVyLnRpbnRNZXRob2QgPSBQSVhJLkNhbnZhc1RpbnRlci5jYW5Vc2VNdWx0aXBseSA/IFBJWEkuQ2FudmFzVGludGVyLnRpbnRXaXRoTXVsdGlwbHkgOiAgUElYSS5DYW52YXNUaW50ZXIudGludFdpdGhQZXJQaXhlbDtcblxuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogdGhlIENhbnZhc1JlbmRlcmVyIGRyYXdzIHRoZSBzdGFnZSBhbmQgYWxsIGl0cyBjb250ZW50IG9udG8gYSAyZCBjYW52YXMuIFRoaXMgcmVuZGVyZXIgc2hvdWxkIGJlIHVzZWQgZm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgd2ViR0wuXG4gKiBEb250IGZvcmdldCB0byBhZGQgdGhlIHZpZXcgdG8geW91ciBET00gb3IgeW91IHdpbGwgbm90IHNlZSBhbnl0aGluZyA6KVxuICpcbiAqIEBjbGFzcyBDYW52YXNSZW5kZXJlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gd2lkdGg9ODAwIHtOdW1iZXJ9IHRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIHZpZXdcbiAqIEBwYXJhbSBoZWlnaHQ9NjAwIHtOdW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIGNhbnZhcyB2aWV3XG4gKiBAcGFyYW0gW3ZpZXddIHtIVE1MQ2FudmFzRWxlbWVudH0gdGhlIGNhbnZhcyB0byB1c2UgYXMgYSB2aWV3LCBvcHRpb25hbFxuICogQHBhcmFtIFt0cmFuc3BhcmVudD1mYWxzZV0ge0Jvb2xlYW59IHRoZSB0cmFuc3BhcmVuY3kgb2YgdGhlIHJlbmRlciB2aWV3LCBkZWZhdWx0IGZhbHNlXG4gKi9cblBJWEkuQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCB2aWV3LCB0cmFuc3BhcmVudClcbntcbiAgICBpZighUElYSS5kZWZhdWx0UmVuZGVyZXIpXG4gICAge1xuICAgICAgICBQSVhJLnNheUhlbGxvKFwiQ2FudmFzXCIpO1xuICAgICAgICBQSVhJLmRlZmF1bHRSZW5kZXJlciA9IHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gUElYSS5DQU5WQVNfUkVOREVSRVI7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHNldHMgaWYgdGhlIENhbnZhc1JlbmRlcmVyIHdpbGwgY2xlYXIgdGhlIGNhbnZhcyBvciBub3QgYmVmb3JlIHRoZSBuZXcgcmVuZGVyIHBhc3MuXG4gICAgICogSWYgdGhlIFN0YWdlIGlzIE5PVCB0cmFuc3BhcmVudCBQaXhpIHdpbGwgdXNlIGEgY2FudmFzIHNpemVkIGZpbGxSZWN0IG9wZXJhdGlvbiBldmVyeSBmcmFtZSB0byBzZXQgdGhlIGNhbnZhcyBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgICAqIElmIHRoZSBTdGFnZSBpcyB0cmFuc3BhcmVudCBQaXhpIHdpbGwgdXNlIGNsZWFyUmVjdCB0byBjbGVhciB0aGUgY2FudmFzIGV2ZXJ5IGZyYW1lLlxuICAgICAqIERpc2FibGUgdGhpcyBieSBzZXR0aW5nIHRoaXMgdG8gZmFsc2UuIEZvciBleGFtcGxlIGlmIHlvdXIgZ2FtZSBoYXMgYSBjYW52YXMgZmlsbGluZyBiYWNrZ3JvdW5kIGltYWdlIHlvdSBvZnRlbiBkb24ndCBuZWVkIHRoaXMgc2V0LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNsZWFyQmVmb3JlUmVuZGVyXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdGhpcy5jbGVhckJlZm9yZVJlbmRlciA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSByZW5kZXIgdmlldyBpcyB0cmFuc3BhcmVudFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRyYW5zcGFyZW50XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMudHJhbnNwYXJlbnQgPSAhIXRyYW5zcGFyZW50O1xuXG4gICAgaWYoIVBJWEkuYmxlbmRNb2Rlc0NhbnZhcylcbiAgICB7XG4gICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhcyA9IFtdO1xuXG4gICAgICAgIGlmKFBJWEkuY2FuVXNlTmV3Q2FudmFzQmxlbmRNb2RlcygpKVxuICAgICAgICB7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLk5PUk1BTF0gICA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuQUREXSAgICAgID0gXCJsaWdodGVyXCI7IC8vSVMgVEhJUyBPSz8/P1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5NVUxUSVBMWV0gPSBcIm11bHRpcGx5XCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLlNDUkVFTl0gICA9IFwic2NyZWVuXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLk9WRVJMQVldICA9IFwib3ZlcmxheVwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5EQVJLRU5dICAgPSBcImRhcmtlblwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5MSUdIVEVOXSAgPSBcImxpZ2h0ZW5cIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuQ09MT1JfRE9ER0VdID0gXCJjb2xvci1kb2RnZVwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5DT0xPUl9CVVJOXSA9IFwiY29sb3ItYnVyblwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5IQVJEX0xJR0hUXSA9IFwiaGFyZC1saWdodFwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5TT0ZUX0xJR0hUXSA9IFwic29mdC1saWdodFwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5ESUZGRVJFTkNFXSA9IFwiZGlmZmVyZW5jZVwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5FWENMVVNJT05dID0gXCJleGNsdXNpb25cIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuSFVFXSAgICAgICA9IFwiaHVlXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLlNBVFVSQVRJT05dID0gXCJzYXR1cmF0aW9uXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLkNPTE9SXSAgICAgID0gXCJjb2xvclwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5MVU1JTk9TSVRZXSA9IFwibHVtaW5vc2l0eVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdGhlIGNvb2wgbmV3IGJsZW5kIG1vZGVzIGluIGNhbnZhcyBcImNvdWdoXCIgaWUgXCJjb3VnaFwiXG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLk5PUk1BTF0gICA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuQUREXSAgICAgID0gXCJsaWdodGVyXCI7IC8vSVMgVEhJUyBPSz8/P1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5NVUxUSVBMWV0gPSBcInNvdXJjZS1vdmVyXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLlNDUkVFTl0gICA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuT1ZFUkxBWV0gID0gXCJzb3VyY2Utb3ZlclwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5EQVJLRU5dICAgPSBcInNvdXJjZS1vdmVyXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLkxJR0hURU5dICA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuQ09MT1JfRE9ER0VdID0gXCJzb3VyY2Utb3ZlclwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5DT0xPUl9CVVJOXSA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuSEFSRF9MSUdIVF0gPSBcInNvdXJjZS1vdmVyXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLlNPRlRfTElHSFRdID0gXCJzb3VyY2Utb3ZlclwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5ESUZGRVJFTkNFXSA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuRVhDTFVTSU9OXSA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuSFVFXSAgICAgICA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuU0FUVVJBVElPTl0gPSBcInNvdXJjZS1vdmVyXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLkNPTE9SXSAgICAgID0gXCJzb3VyY2Utb3ZlclwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5MVU1JTk9TSVRZXSA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIHZpZXdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB3aWR0aFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDgwMFxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCA4MDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBjYW52YXMgdmlld1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IGhlaWdodFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDYwMFxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDYwMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjYW52YXMgZWxlbWVudCB0aGF0IGV2ZXJ5dGhpbmcgaXMgZHJhd24gdG9cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB2aWV3XG4gICAgICogQHR5cGUgSFRNTENhbnZhc0VsZW1lbnRcbiAgICAgKi9cbiAgICB0aGlzLnZpZXcgPSB2aWV3IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiY2FudmFzXCIgKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjYW52YXMgMmQgY29udGV4dCB0aGF0IGV2ZXJ5dGhpbmcgaXMgZHJhd24gd2l0aFxuICAgICAqIEBwcm9wZXJ0eSBjb250ZXh0XG4gICAgICogQHR5cGUgSFRNTENhbnZhc0VsZW1lbnQgMmQgQ29udGV4dFxuICAgICAqL1xuICAgIHRoaXMuY29udGV4dCA9IHRoaXMudmlldy5nZXRDb250ZXh0KCBcIjJkXCIsIHsgYWxwaGE6IHRoaXMudHJhbnNwYXJlbnQgfSApO1xuXG4gICAgdGhpcy5yZWZyZXNoID0gdHJ1ZTtcbiAgICAvLyBoYWNrIHRvIGVuYWJsZSBzb21lIGhhcmR3YXJlIGFjY2VsZXJhdGlvbiFcbiAgICAvL3RoaXMudmlldy5zdHlsZVtcInRyYW5zZm9ybVwiXSA9IFwidHJhbnNsYXRleigwKVwiO1xuXG4gICAgdGhpcy52aWV3LndpZHRoID0gdGhpcy53aWR0aDtcbiAgICB0aGlzLnZpZXcuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgdGhpcy5jb3VudCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBJbnN0YW5jZSBvZiBhIFBJWEkuQ2FudmFzTWFza01hbmFnZXIsIGhhbmRsZXMgbWFza2luZyB3aGVuIHVzaW5nIHRoZSBjYW52YXMgcmVuZGVyZXJcbiAgICAgKiBAcHJvcGVydHkgQ2FudmFzTWFza01hbmFnZXJcbiAgICAgKiBAdHlwZSBDYW52YXNNYXNrTWFuYWdlclxuICAgICAqL1xuICAgIHRoaXMubWFza01hbmFnZXIgPSBuZXcgUElYSS5DYW52YXNNYXNrTWFuYWdlcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlbmRlciBzZXNzaW9uIGlzIGp1c3QgYSBidW5jaCBvZiBwYXJhbWV0ZXIgdXNlZCBmb3IgcmVuZGVyaW5nXG4gICAgICogQHByb3BlcnR5IHJlbmRlclNlc3Npb25cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlclNlc3Npb24gPSB7XG4gICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgICAgbWFza01hbmFnZXI6IHRoaXMubWFza01hbmFnZXIsXG4gICAgICAgIHNjYWxlTW9kZTogbnVsbCxcbiAgICAgICAgc21vb3RoUHJvcGVydHk6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUgUGl4aSB3aWxsIE1hdGguZmxvb3IoKSB4L3kgdmFsdWVzIHdoZW4gcmVuZGVyaW5nLCBzdG9wcGluZyBwaXhlbCBpbnRlcnBvbGF0aW9uLlxuICAgICAgICAgKiBIYW5keSBmb3IgY3Jpc3AgcGl4ZWwgYXJ0IGFuZCBzcGVlZCBvbiBsZWdhY3kgZGV2aWNlcy5cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHJvdW5kUGl4ZWxzOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZihcImltYWdlU21vb3RoaW5nRW5hYmxlZFwiIGluIHRoaXMuY29udGV4dClcbiAgICAgICAgdGhpcy5yZW5kZXJTZXNzaW9uLnNtb290aFByb3BlcnR5ID0gXCJpbWFnZVNtb290aGluZ0VuYWJsZWRcIjtcbiAgICBlbHNlIGlmKFwid2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkXCIgaW4gdGhpcy5jb250ZXh0KVxuICAgICAgICB0aGlzLnJlbmRlclNlc3Npb24uc21vb3RoUHJvcGVydHkgPSBcIndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZFwiO1xuICAgIGVsc2UgaWYoXCJtb3pJbWFnZVNtb290aGluZ0VuYWJsZWRcIiBpbiB0aGlzLmNvbnRleHQpXG4gICAgICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5zbW9vdGhQcm9wZXJ0eSA9IFwibW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkXCI7XG4gICAgZWxzZSBpZihcIm9JbWFnZVNtb290aGluZ0VuYWJsZWRcIiBpbiB0aGlzLmNvbnRleHQpXG4gICAgICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5zbW9vdGhQcm9wZXJ0eSA9IFwib0ltYWdlU21vb3RoaW5nRW5hYmxlZFwiO1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5DYW52YXNSZW5kZXJlcjtcblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBzdGFnZSB0byBpdHMgY2FudmFzIHZpZXdcbiAqXG4gKiBAbWV0aG9kIHJlbmRlclxuICogQHBhcmFtIHN0YWdlIHtTdGFnZX0gdGhlIFN0YWdlIGVsZW1lbnQgdG8gYmUgcmVuZGVyZWRcbiAqL1xuUElYSS5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oc3RhZ2UpXG57XG4gICAgLy8gdXBkYXRlIHRleHR1cmVzIGlmIG5lZWQgYmVcbiAgICBQSVhJLnRleHR1cmVzVG9VcGRhdGUubGVuZ3RoID0gMDtcbiAgICBQSVhJLnRleHR1cmVzVG9EZXN0cm95Lmxlbmd0aCA9IDA7XG5cbiAgICBzdGFnZS51cGRhdGVUcmFuc2Zvcm0oKTtcblxuICAgIHRoaXMuY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwwLDAsMSwwLDApO1xuICAgIHRoaXMuY29udGV4dC5nbG9iYWxBbHBoYSA9IDE7XG5cbiAgICBpZiAobmF2aWdhdG9yLmlzQ29jb29uSlMgJiYgdGhpcy52aWV3LnNjcmVlbmNhbnZhcykge1xuICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gXCJibGFja1wiO1xuICAgICAgICB0aGlzLmNvbnRleHQuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMudHJhbnNwYXJlbnQgJiYgdGhpcy5jbGVhckJlZm9yZVJlbmRlcilcbiAgICB7XG4gICAgICAgIHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSBzdGFnZS5iYWNrZ3JvdW5kQ29sb3JTdHJpbmc7XG4gICAgICAgIHRoaXMuY29udGV4dC5maWxsUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMudHJhbnNwYXJlbnQgJiYgdGhpcy5jbGVhckJlZm9yZVJlbmRlcilcbiAgICB7XG4gICAgICAgIHRoaXMuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyRGlzcGxheU9iamVjdChzdGFnZSk7XG5cbiAgICAvLyBydW4gaW50ZXJhY3Rpb24hXG4gICAgaWYoc3RhZ2UuaW50ZXJhY3RpdmUpXG4gICAge1xuICAgICAgICAvL25lZWQgdG8gYWRkIHNvbWUgZXZlbnRzIVxuICAgICAgICBpZighc3RhZ2UuX2ludGVyYWN0aXZlRXZlbnRzQWRkZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0YWdlLl9pbnRlcmFjdGl2ZUV2ZW50c0FkZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0YWdlLmludGVyYWN0aW9uTWFuYWdlci5zZXRUYXJnZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZW1vdmUgZnJhbWUgdXBkYXRlcy4uXG4gICAgaWYoUElYSS5UZXh0dXJlLmZyYW1lVXBkYXRlcy5sZW5ndGggPiAwKVxuICAgIHtcbiAgICAgICAgUElYSS5UZXh0dXJlLmZyYW1lVXBkYXRlcy5sZW5ndGggPSAwO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVzaXplcyB0aGUgY2FudmFzIHZpZXcgdG8gdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0XG4gKlxuICogQG1ldGhvZCByZXNpemVcbiAqIEBwYXJhbSB3aWR0aCB7TnVtYmVyfSB0aGUgbmV3IHdpZHRoIG9mIHRoZSBjYW52YXMgdmlld1xuICogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSB0aGUgbmV3IGhlaWdodCBvZiB0aGUgY2FudmFzIHZpZXdcbiAqL1xuUElYSS5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodClcbntcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICB0aGlzLnZpZXcud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLnZpZXcuaGVpZ2h0ID0gaGVpZ2h0O1xufTtcblxuLyoqXG4gKiBSZW5kZXJzIGEgZGlzcGxheSBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIHJlbmRlckRpc3BsYXlPYmplY3RcbiAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IHtEaXNwbGF5T2JqZWN0fSBUaGUgZGlzcGxheU9iamVjdCB0byByZW5kZXJcbiAqIEBwYXJhbSBjb250ZXh0IHtDb250ZXh0MkR9IHRoZSBjb250ZXh0IDJkIG1ldGhvZCBvZiB0aGUgY2FudmFzXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJEaXNwbGF5T2JqZWN0ID0gZnVuY3Rpb24oZGlzcGxheU9iamVjdCwgY29udGV4dClcbntcbiAgICAvLyBubyBsb25nZXIgcmVjdXJzaXZlIVxuICAgIC8vdmFyIHRyYW5zZm9ybTtcbiAgICAvL3ZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLmNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXMuY29udGV4dDtcbiAgICBkaXNwbGF5T2JqZWN0Ll9yZW5kZXJDYW52YXModGhpcy5yZW5kZXJTZXNzaW9uKTtcbn07XG5cbi8qKlxuICogUmVuZGVycyBhIGZsYXQgc3RyaXBcbiAqXG4gKiBAbWV0aG9kIHJlbmRlclN0cmlwRmxhdFxuICogQHBhcmFtIHN0cmlwIHtTdHJpcH0gVGhlIFN0cmlwIHRvIHJlbmRlclxuICogQHByaXZhdGVcbiAqL1xuUElYSS5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyU3RyaXBGbGF0ID0gZnVuY3Rpb24oc3RyaXApXG57XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgdmFyIHZlcnRpY2llcyA9IHN0cmlwLnZlcnRpY2llcztcblxuICAgIHZhciBsZW5ndGggPSB2ZXJ0aWNpZXMubGVuZ3RoLzI7XG4gICAgdGhpcy5jb3VudCsrO1xuXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBmb3IgKHZhciBpPTE7IGkgPCBsZW5ndGgtMjsgaSsrKVxuICAgIHtcbiAgICAgICAgLy8gZHJhdyBzb21lIHRyaWFuZ2xlcyFcbiAgICAgICAgdmFyIGluZGV4ID0gaSoyO1xuXG4gICAgICAgIHZhciB4MCA9IHZlcnRpY2llc1tpbmRleF0sICAgeDEgPSB2ZXJ0aWNpZXNbaW5kZXgrMl0sIHgyID0gdmVydGljaWVzW2luZGV4KzRdO1xuICAgICAgICB2YXIgeTAgPSB2ZXJ0aWNpZXNbaW5kZXgrMV0sIHkxID0gdmVydGljaWVzW2luZGV4KzNdLCB5MiA9IHZlcnRpY2llc1tpbmRleCs1XTtcblxuICAgICAgICBjb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4MSwgeTEpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xuICAgIH1cblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCIjRkYwMDAwXCI7XG4gICAgY29udGV4dC5maWxsKCk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5cbi8qKlxuICogUmVuZGVycyBhIHN0cmlwXG4gKlxuICogQG1ldGhvZCByZW5kZXJTdHJpcFxuICogQHBhcmFtIHN0cmlwIHtTdHJpcH0gVGhlIFN0cmlwIHRvIHJlbmRlclxuICogQHByaXZhdGVcbiAqL1xuUElYSS5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyU3RyaXAgPSBmdW5jdGlvbihzdHJpcClcbntcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgIC8vIGRyYXcgdHJpYW5nbGVzISFcbiAgICB2YXIgdmVydGljaWVzID0gc3RyaXAudmVydGljaWVzO1xuICAgIHZhciB1dnMgPSBzdHJpcC51dnM7XG5cbiAgICB2YXIgbGVuZ3RoID0gdmVydGljaWVzLmxlbmd0aC8yO1xuICAgIHRoaXMuY291bnQrKztcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoLTI7IGkrKylcbiAgICB7XG4gICAgICAgIC8vIGRyYXcgc29tZSB0cmlhbmdsZXMhXG4gICAgICAgIHZhciBpbmRleCA9IGkqMjtcblxuICAgICAgICB2YXIgeDAgPSB2ZXJ0aWNpZXNbaW5kZXhdLCAgIHgxID0gdmVydGljaWVzW2luZGV4KzJdLCB4MiA9IHZlcnRpY2llc1tpbmRleCs0XTtcbiAgICAgICAgdmFyIHkwID0gdmVydGljaWVzW2luZGV4KzFdLCB5MSA9IHZlcnRpY2llc1tpbmRleCszXSwgeTIgPSB2ZXJ0aWNpZXNbaW5kZXgrNV07XG5cbiAgICAgICAgdmFyIHUwID0gdXZzW2luZGV4XSAqIHN0cmlwLnRleHR1cmUud2lkdGgsICAgdTEgPSB1dnNbaW5kZXgrMl0gKiBzdHJpcC50ZXh0dXJlLndpZHRoLCB1MiA9IHV2c1tpbmRleCs0XSogc3RyaXAudGV4dHVyZS53aWR0aDtcbiAgICAgICAgdmFyIHYwID0gdXZzW2luZGV4KzFdKiBzdHJpcC50ZXh0dXJlLmhlaWdodCwgdjEgPSB1dnNbaW5kZXgrM10gKiBzdHJpcC50ZXh0dXJlLmhlaWdodCwgdjIgPSB1dnNbaW5kZXgrNV0qIHN0cmlwLnRleHR1cmUuaGVpZ2h0O1xuXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4MSwgeTEpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgIGNvbnRleHQuY2xpcCgpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgbWF0cml4IHRyYW5zZm9ybVxuICAgICAgICB2YXIgZGVsdGEgPSB1MCp2MSArIHYwKnUyICsgdTEqdjIgLSB2MSp1MiAtIHYwKnUxIC0gdTAqdjI7XG4gICAgICAgIHZhciBkZWx0YUEgPSB4MCp2MSArIHYwKngyICsgeDEqdjIgLSB2MSp4MiAtIHYwKngxIC0geDAqdjI7XG4gICAgICAgIHZhciBkZWx0YUIgPSB1MCp4MSArIHgwKnUyICsgdTEqeDIgLSB4MSp1MiAtIHgwKnUxIC0gdTAqeDI7XG4gICAgICAgIHZhciBkZWx0YUMgPSB1MCp2MSp4MiArIHYwKngxKnUyICsgeDAqdTEqdjIgLSB4MCp2MSp1MiAtIHYwKnUxKngyIC0gdTAqeDEqdjI7XG4gICAgICAgIHZhciBkZWx0YUQgPSB5MCp2MSArIHYwKnkyICsgeTEqdjIgLSB2MSp5MiAtIHYwKnkxIC0geTAqdjI7XG4gICAgICAgIHZhciBkZWx0YUUgPSB1MCp5MSArIHkwKnUyICsgdTEqeTIgLSB5MSp1MiAtIHkwKnUxIC0gdTAqeTI7XG4gICAgICAgIHZhciBkZWx0YUYgPSB1MCp2MSp5MiArIHYwKnkxKnUyICsgeTAqdTEqdjIgLSB5MCp2MSp1MiAtIHYwKnUxKnkyIC0gdTAqeTEqdjI7XG5cbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm0oZGVsdGFBIC8gZGVsdGEsIGRlbHRhRCAvIGRlbHRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhQiAvIGRlbHRhLCBkZWx0YUUgLyBkZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YUMgLyBkZWx0YSwgZGVsdGFGIC8gZGVsdGEpO1xuXG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHN0cmlwLnRleHR1cmUuYmFzZVRleHR1cmUuc291cmNlLCAwLCAwKTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgQ2FudmFzIGVsZW1lbnQgb2YgdGhlIGdpdmVuIHNpemVcbiAqXG4gKiBAbWV0aG9kIENhbnZhc0J1ZmZlclxuICogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IHRoZSB3aWR0aCBmb3IgdGhlIG5ld2x5IGNyZWF0ZWQgY2FudmFzXG4gKiBAcGFyYW0gaGVpZ2h0IHtOdW1iZXJ9IHRoZSBoZWlnaHQgZm9yIHRoZSBuZXdseSBjcmVhdGVkIGNhbnZhc1xuICogQHN0YXRpY1xuICogQHByaXZhdGVcbiAqL1xuUElYSS5DYW52YXNCdWZmZXIgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KVxue1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJjYW52YXNcIiApO1xuICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoIFwiMmRcIiApO1xuXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgY2FudmFzIHRoYXQgd2FzIGNyZWF0ZWQgYnkgdGhlIENhbnZhc0J1ZmZlciBjbGFzc1xuICpcbiAqIEBtZXRob2QgY2xlYXJcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuQ2FudmFzQnVmZmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KDAsMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xufTtcblxuLyoqXG4gKiBSZXNpemVzIHRoZSBjYW52YXMgdGhhdCB3YXMgY3JlYXRlZCBieSB0aGUgQ2FudmFzQnVmZmVyIGNsYXNzIHRvIHRoZSBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodFxuICpcbiAqIEBtZXRob2QgcmVzaXplXG4gKiBAcGFyYW0gd2lkdGgge051bWJlcn0gdGhlIG5ldyB3aWR0aCBvZiB0aGUgY2FudmFzXG4gKiBAcGFyYW0gaGVpZ2h0IHtOdW1iZXJ9IHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBjYW52YXNcbiAqIEBwcml2YXRlXG4gKi9cblxuUElYSS5DYW52YXNCdWZmZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpXG57XG4gICAgdGhpcy53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG59O1xuXG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuXG4vKipcbiAqIEEgc2V0IG9mIGZ1bmN0aW9ucyB1c2VkIGJ5IHRoZSBjYW52YXMgcmVuZGVyZXIgdG8gZHJhdyB0aGUgcHJpbWl0aXZlIGdyYXBoaWNzIGRhdGFcbiAqXG4gKiBAY2xhc3MgQ2FudmFzR3JhcGhpY3NcbiAqL1xuUElYSS5DYW52YXNHcmFwaGljcyA9IGZ1bmN0aW9uKClcbntcblxufTtcblxuXG4vKlxuICogUmVuZGVycyB0aGUgZ3JhcGhpY3Mgb2JqZWN0XG4gKlxuICogQHN0YXRpY1xuICogQHByaXZhdGVcbiAqIEBtZXRob2QgcmVuZGVyR3JhcGhpY3NcbiAqIEBwYXJhbSBncmFwaGljcyB7R3JhcGhpY3N9IHRoZSBhY3R1YWwgZ3JhcGhpY3Mgb2JqZWN0IHRvIHJlbmRlclxuICogQHBhcmFtIGNvbnRleHQge0NvbnRleHQyRH0gdGhlIDJkIGRyYXdpbmcgbWV0aG9kIG9mIHRoZSBjYW52YXNcbiAqL1xuUElYSS5DYW52YXNHcmFwaGljcy5yZW5kZXJHcmFwaGljcyA9IGZ1bmN0aW9uKGdyYXBoaWNzLCBjb250ZXh0KVxue1xuICAgIHZhciB3b3JsZEFscGhhID0gZ3JhcGhpY3Mud29ybGRBbHBoYTtcbiAgICB2YXIgY29sb3IgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGRhdGEgPSBncmFwaGljcy5ncmFwaGljc0RhdGFbaV07XG4gICAgICAgIHZhciBwb2ludHMgPSBkYXRhLnBvaW50cztcblxuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3IgPSAnIycgKyAoJzAwMDAwJyArICggZGF0YS5saW5lQ29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG5cbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBkYXRhLmxpbmVXaWR0aDtcblxuICAgICAgICBpZihkYXRhLnR5cGUgPT09IFBJWEkuR3JhcGhpY3MuUE9MWSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqPTE7IGogPCBwb2ludHMubGVuZ3RoLzI7IGorKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwb2ludHNbaiAqIDJdLCBwb2ludHNbaiAqIDIgKyAxXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludCBhcmUgdGhlIHNhbWUgY2xvc2UgdGhlIHBhdGggLSBtdWNoIG5lYXRlciA6KVxuICAgICAgICAgICAgaWYocG9pbnRzWzBdID09PSBwb2ludHNbcG9pbnRzLmxlbmd0aC0yXSAmJiBwb2ludHNbMV0gPT09IHBvaW50c1twb2ludHMubGVuZ3RoLTFdKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGRhdGEuZmlsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5maWxsQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3IgPSAnIycgKyAoJzAwMDAwJyArICggZGF0YS5maWxsQ29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkYXRhLmxpbmVXaWR0aClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5saW5lQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihkYXRhLnR5cGUgPT09IFBJWEkuR3JhcGhpY3MuUkVDVClcbiAgICAgICAge1xuXG4gICAgICAgICAgICBpZihkYXRhLmZpbGxDb2xvciB8fCBkYXRhLmZpbGxDb2xvciA9PT0gMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5maWxsQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3IgPSAnIycgKyAoJzAwMDAwJyArICggZGF0YS5maWxsQ29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdChwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkYXRhLmxpbmVXaWR0aClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5saW5lQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihkYXRhLnR5cGUgPT09IFBJWEkuR3JhcGhpY3MuQ0lSQylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gVE9ETyAtIG5lZWQgdG8gYmUgVW5kZWZpbmVkIVxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQuYXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sMCwyKk1hdGguUEkpO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgICAgICAgICAgaWYoZGF0YS5maWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBkYXRhLmZpbGxBbHBoYSAqIHdvcmxkQWxwaGE7XG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvciA9ICcjJyArICgnMDAwMDAnICsgKCBkYXRhLmZpbGxDb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGRhdGEubGluZVdpZHRoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBkYXRhLmxpbmVBbHBoYSAqIHdvcmxkQWxwaGE7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGRhdGEudHlwZSA9PT0gUElYSS5HcmFwaGljcy5FTElQKVxuICAgICAgICB7XG5cbiAgICAgICAgICAgIC8vIGVsbGlwc2UgY29kZSB0YWtlbiBmcm9tOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIxNzI3OTgvaG93LXRvLWRyYXctYW4tb3ZhbC1pbi1odG1sNS1jYW52YXNcblxuICAgICAgICAgICAgdmFyIGVsbGlwc2VEYXRhID0gIGRhdGEucG9pbnRzO1xuXG4gICAgICAgICAgICB2YXIgdyA9IGVsbGlwc2VEYXRhWzJdICogMjtcbiAgICAgICAgICAgIHZhciBoID0gZWxsaXBzZURhdGFbM10gKiAyO1xuXG4gICAgICAgICAgICB2YXIgeCA9IGVsbGlwc2VEYXRhWzBdIC0gdy8yO1xuICAgICAgICAgICAgdmFyIHkgPSBlbGxpcHNlRGF0YVsxXSAtIGgvMjtcblxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgdmFyIGthcHBhID0gMC41NTIyODQ4LFxuICAgICAgICAgICAgICAgIG94ID0gKHcgLyAyKSAqIGthcHBhLCAvLyBjb250cm9sIHBvaW50IG9mZnNldCBob3Jpem9udGFsXG4gICAgICAgICAgICAgICAgb3kgPSAoaCAvIDIpICoga2FwcGEsIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IHZlcnRpY2FsXG4gICAgICAgICAgICAgICAgeGUgPSB4ICsgdywgICAgICAgICAgIC8vIHgtZW5kXG4gICAgICAgICAgICAgICAgeWUgPSB5ICsgaCwgICAgICAgICAgIC8vIHktZW5kXG4gICAgICAgICAgICAgICAgeG0gPSB4ICsgdyAvIDIsICAgICAgIC8vIHgtbWlkZGxlXG4gICAgICAgICAgICAgICAgeW0gPSB5ICsgaCAvIDI7ICAgICAgIC8vIHktbWlkZGxlXG5cbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHgsIHltKTtcbiAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4LCB5bSAtIG95LCB4bSAtIG94LCB5LCB4bSwgeSk7XG4gICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeG0gKyBveCwgeSwgeGUsIHltIC0gb3ksIHhlLCB5bSk7XG4gICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeGUsIHltICsgb3ksIHhtICsgb3gsIHllLCB4bSwgeWUpO1xuICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHhtIC0gb3gsIHllLCB4LCB5bSArIG95LCB4LCB5bSk7XG5cbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgICAgIGlmKGRhdGEuZmlsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5maWxsQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3IgPSAnIycgKyAoJzAwMDAwJyArICggZGF0YS5maWxsQ29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkYXRhLmxpbmVXaWR0aClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5saW5lQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBQSVhJLkdyYXBoaWNzLlJSRUMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciByeCA9IHBvaW50c1swXTtcbiAgICAgICAgICAgIHZhciByeSA9IHBvaW50c1sxXTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHBvaW50c1syXTtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBwb2ludHNbM107XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gcG9pbnRzWzRdO1xuXG4gICAgICAgICAgICB2YXIgbWF4UmFkaXVzID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyIHwgMDtcbiAgICAgICAgICAgIHJhZGl1cyA9IHJhZGl1cyA+IG1heFJhZGl1cyA/IG1heFJhZGl1cyA6IHJhZGl1cztcblxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHJ4LCByeSArIHJhZGl1cyk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhyeCwgcnkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4LCByeSArIGhlaWdodCwgcnggKyByYWRpdXMsIHJ5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHJ4ICsgd2lkdGggLSByYWRpdXMsIHJ5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhyeCArIHdpZHRoLCByeSArIGhlaWdodCwgcnggKyB3aWR0aCwgcnkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocnggKyB3aWR0aCwgcnkgKyByYWRpdXMpO1xuICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4ICsgd2lkdGgsIHJ5LCByeCArIHdpZHRoIC0gcmFkaXVzLCByeSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhyeCArIHJhZGl1cywgcnkpO1xuICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4LCByeSwgcngsIHJ5ICsgcmFkaXVzKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgICAgIGlmKGRhdGEuZmlsbENvbG9yIHx8IGRhdGEuZmlsbENvbG9yID09PSAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBkYXRhLmZpbGxBbHBoYSAqIHdvcmxkQWxwaGE7XG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvciA9ICcjJyArICgnMDAwMDAnICsgKCBkYXRhLmZpbGxDb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZGF0YS5saW5lV2lkdGgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEubGluZUFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLypcbiAqIFJlbmRlcnMgYSBncmFwaGljcyBtYXNrXG4gKlxuICogQHN0YXRpY1xuICogQHByaXZhdGVcbiAqIEBtZXRob2QgcmVuZGVyR3JhcGhpY3NNYXNrXG4gKiBAcGFyYW0gZ3JhcGhpY3Mge0dyYXBoaWNzfSB0aGUgZ3JhcGhpY3Mgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGEgbWFza1xuICogQHBhcmFtIGNvbnRleHQge0NvbnRleHQyRH0gdGhlIGNvbnRleHQgMmQgbWV0aG9kIG9mIHRoZSBjYW52YXNcbiAqL1xuUElYSS5DYW52YXNHcmFwaGljcy5yZW5kZXJHcmFwaGljc01hc2sgPSBmdW5jdGlvbihncmFwaGljcywgY29udGV4dClcbntcbiAgICB2YXIgbGVuID0gZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhLmxlbmd0aDtcblxuICAgIGlmKGxlbiA9PT0gMCkgcmV0dXJuO1xuXG4gICAgaWYobGVuID4gMSlcbiAgICB7XG4gICAgICAgIGxlbiA9IDE7XG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnUGl4aS5qcyB3YXJuaW5nOiBtYXNrcyBpbiBjYW52YXMgY2FuIG9ubHkgbWFzayB1c2luZyB0aGUgZmlyc3QgcGF0aCBpbiB0aGUgZ3JhcGhpY3Mgb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgZGF0YSA9IGdyYXBoaWNzLmdyYXBoaWNzRGF0YVtpXTtcbiAgICAgICAgdmFyIHBvaW50cyA9IGRhdGEucG9pbnRzO1xuXG4gICAgICAgIGlmKGRhdGEudHlwZSA9PT0gUElYSS5HcmFwaGljcy5QT0xZKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqPTE7IGogPCBwb2ludHMubGVuZ3RoLzI7IGorKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwb2ludHNbaiAqIDJdLCBwb2ludHNbaiAqIDIgKyAxXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludCBhcmUgdGhlIHNhbWUgY2xvc2UgdGhlIHBhdGggLSBtdWNoIG5lYXRlciA6KVxuICAgICAgICAgICAgaWYocG9pbnRzWzBdID09PSBwb2ludHNbcG9pbnRzLmxlbmd0aC0yXSAmJiBwb2ludHNbMV0gPT09IHBvaW50c1twb2ludHMubGVuZ3RoLTFdKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGRhdGEudHlwZSA9PT0gUElYSS5HcmFwaGljcy5SRUNUKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5yZWN0KHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoZGF0YS50eXBlID09PSBQSVhJLkdyYXBoaWNzLkNJUkMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFRPRE8gLSBuZWVkIHRvIGJlIFVuZGVmaW5lZCFcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LmFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLDAsMipNYXRoLlBJKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihkYXRhLnR5cGUgPT09IFBJWEkuR3JhcGhpY3MuRUxJUClcbiAgICAgICAge1xuXG4gICAgICAgICAgICAvLyBlbGxpcHNlIGNvZGUgdGFrZW4gZnJvbTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMTcyNzk4L2hvdy10by1kcmF3LWFuLW92YWwtaW4taHRtbDUtY2FudmFzXG4gICAgICAgICAgICB2YXIgZWxsaXBzZURhdGEgPSAgZGF0YS5wb2ludHM7XG5cbiAgICAgICAgICAgIHZhciB3ID0gZWxsaXBzZURhdGFbMl0gKiAyO1xuICAgICAgICAgICAgdmFyIGggPSBlbGxpcHNlRGF0YVszXSAqIDI7XG5cbiAgICAgICAgICAgIHZhciB4ID0gZWxsaXBzZURhdGFbMF0gLSB3LzI7XG4gICAgICAgICAgICB2YXIgeSA9IGVsbGlwc2VEYXRhWzFdIC0gaC8yO1xuXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgICB2YXIga2FwcGEgPSAwLjU1MjI4NDgsXG4gICAgICAgICAgICAgICAgb3ggPSAodyAvIDIpICoga2FwcGEsIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IGhvcml6b250YWxcbiAgICAgICAgICAgICAgICBveSA9IChoIC8gMikgKiBrYXBwYSwgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgdmVydGljYWxcbiAgICAgICAgICAgICAgICB4ZSA9IHggKyB3LCAgICAgICAgICAgLy8geC1lbmRcbiAgICAgICAgICAgICAgICB5ZSA9IHkgKyBoLCAgICAgICAgICAgLy8geS1lbmRcbiAgICAgICAgICAgICAgICB4bSA9IHggKyB3IC8gMiwgICAgICAgLy8geC1taWRkbGVcbiAgICAgICAgICAgICAgICB5bSA9IHkgKyBoIC8gMjsgICAgICAgLy8geS1taWRkbGVcblxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oeCwgeW0pO1xuICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgsIHltIC0gb3ksIHhtIC0gb3gsIHksIHhtLCB5KTtcbiAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4bSArIG94LCB5LCB4ZSwgeW0gLSBveSwgeGUsIHltKTtcbiAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4ZSwgeW0gKyBveSwgeG0gKyBveCwgeWUsIHhtLCB5ZSk7XG4gICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeG0gLSBveCwgeWUsIHgsIHltICsgb3ksIHgsIHltKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBQSVhJLkdyYXBoaWNzLlJSRUMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciByeCA9IHBvaW50c1swXTtcbiAgICAgICAgICAgIHZhciByeSA9IHBvaW50c1sxXTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHBvaW50c1syXTtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBwb2ludHNbM107XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gcG9pbnRzWzRdO1xuXG4gICAgICAgICAgICB2YXIgbWF4UmFkaXVzID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyIHwgMDtcbiAgICAgICAgICAgIHJhZGl1cyA9IHJhZGl1cyA+IG1heFJhZGl1cyA/IG1heFJhZGl1cyA6IHJhZGl1cztcblxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHJ4LCByeSArIHJhZGl1cyk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhyeCwgcnkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4LCByeSArIGhlaWdodCwgcnggKyByYWRpdXMsIHJ5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHJ4ICsgd2lkdGggLSByYWRpdXMsIHJ5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhyeCArIHdpZHRoLCByeSArIGhlaWdodCwgcnggKyB3aWR0aCwgcnkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocnggKyB3aWR0aCwgcnkgKyByYWRpdXMpO1xuICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4ICsgd2lkdGgsIHJ5LCByeCArIHdpZHRoIC0gcmFkaXVzLCByeSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhyeCArIHJhZGl1cywgcnkpO1xuICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4LCByeSwgcngsIHJ5ICsgcmFkaXVzKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cblxuLyoqXG4gKiBUaGUgR3JhcGhpY3MgY2xhc3MgY29udGFpbnMgYSBzZXQgb2YgbWV0aG9kcyB0aGF0IHlvdSBjYW4gdXNlIHRvIGNyZWF0ZSBwcmltaXRpdmUgc2hhcGVzIGFuZCBsaW5lcy5cbiAqIEl0IGlzIGltcG9ydGFudCB0byBrbm93IHRoYXQgd2l0aCB0aGUgd2ViR0wgcmVuZGVyZXIgb25seSBzaW1wbGUgcG9seWdvbnMgY2FuIGJlIGZpbGxlZCBhdCB0aGlzIHN0YWdlXG4gKiBDb21wbGV4IHBvbHlnb25zIHdpbGwgbm90IGJlIGZpbGxlZC4gSGVyZXMgYW4gZXhhbXBsZSBvZiBhIGNvbXBsZXggcG9seWdvbjogaHR0cDovL3d3dy5nb29kYm95ZGlnaXRhbC5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTMvMDYvY29tcGxleFBvbHlnb24ucG5nXG4gKlxuICogQGNsYXNzIEdyYXBoaWNzXG4gKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0Q29udGFpbmVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuUElYSS5HcmFwaGljcyA9IGZ1bmN0aW9uKClcbntcbiAgICBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5yZW5kZXJhYmxlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbHBoYSBvZiB0aGUgZmlsbCBvZiB0aGlzIGdyYXBoaWNzIG9iamVjdFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGZpbGxBbHBoYVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuZmlsbEFscGhhID0gMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiBhbnkgbGluZXMgZHJhd25cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBsaW5lV2lkdGhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLmxpbmVXaWR0aCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29sb3Igb2YgYW55IGxpbmVzIGRyYXduXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbGluZUNvbG9yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgdGhpcy5saW5lQ29sb3IgPSBcImJsYWNrXCI7XG5cbiAgICAvKipcbiAgICAgKiBHcmFwaGljcyBkYXRhXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZ3JhcGhpY3NEYXRhXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZ3JhcGhpY3NEYXRhID0gW107XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSB0aW50IGFwcGxpZWQgdG8gdGhlIGdyYXBoaWMgc2hhcGUuIFRoaXMgaXMgYSBoZXggdmFsdWVcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0aW50XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMHhGRkZGRkZcbiAgICAgKi9cbiAgICB0aGlzLnRpbnQgPSAweEZGRkZGRjsvLyAqIE1hdGgucmFuZG9tKCk7XG4gICAgXG4gICAgLyoqXG4gICAgICogVGhlIGJsZW5kIG1vZGUgdG8gYmUgYXBwbGllZCB0byB0aGUgZ3JhcGhpYyBzaGFwZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJsZW5kTW9kZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IFBJWEkuYmxlbmRNb2Rlcy5OT1JNQUw7XG4gICAgICovXG4gICAgdGhpcy5ibGVuZE1vZGUgPSBQSVhJLmJsZW5kTW9kZXMuTk9STUFMO1xuICAgIFxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgcGF0aFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGN1cnJlbnRQYXRoXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRQYXRoID0ge3BvaW50czpbXX07XG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBjb250YWluaW5nIHNvbWUgV2ViR0wtcmVsYXRlZCBwcm9wZXJ0aWVzIHVzZWQgYnkgdGhlIFdlYkdMIHJlbmRlcmVyXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgX3dlYkdMXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3dlYkdMID0gW107XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgc2hhcGUgaXMgYmVpbmcgdXNlZCBhcyBhIG1hc2tcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBpc01hc2tcbiAgICAgKiBAdHlwZSBpc01hc2tcbiAgICAgKi9cbiAgICB0aGlzLmlzTWFzayA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJvdW5kcyBvZiB0aGUgZ3JhcGhpYyBzaGFwZSBhcyByZWN0YW5nbGUgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYm91bmRzXG4gICAgICogQHR5cGUgUmVjdGFuZ2xlXG4gICAgICovXG4gICAgdGhpcy5ib3VuZHMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogdGhlIGJvdW5kcycgcGFkZGluZyB1c2VkIGZvciBib3VuZHMgY2FsY3VsYXRpb25cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBib3VuZHNQYWRkaW5nXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5ib3VuZHNQYWRkaW5nID0gMTA7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGRldGVjdCBpZiB0aGUgZ3JhcGhpY3Mgb2JqZWN0IGhhcyBjaGFuZ2VkIGlmIHRoaXMgaXMgc2V0IHRvIHRydWUgdGhlbiB0aGUgZ3JhcGhpY3Mgb2JqZWN0IHdpbGwgYmUgcmVjYWxjdWxhdGVkXG4gICAgICogXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG59O1xuXG4vLyBjb25zdHJ1Y3RvclxuUElYSS5HcmFwaGljcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlICk7XG5QSVhJLkdyYXBoaWNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuR3JhcGhpY3M7XG5cbi8qKlxuICogSWYgY2FjaGVBc0JpdG1hcCBpcyB0cnVlIHRoZSBncmFwaGljcyBvYmplY3Qgd2lsbCB0aGVuIGJlIHJlbmRlcmVkIGFzIGlmIGl0IHdhcyBhIHNwcml0ZS5cbiAqIFRoaXMgaXMgdXNlZnVsIGlmIHlvdXIgZ3JhcGhpY3MgZWxlbWVudCBkb2VzIG5vdCBjaGFuZ2Ugb2Z0ZW4gYXMgaXQgd2lsbCBzcGVlZCB1cCB0aGUgcmVuZGVyaW5nIG9mIHRoZSBvYmplY3RcbiAqIEl0IGlzIGFsc28gdXNmdWwgYXMgdGhlIGdyYXBoaWNzIG9iamVjdCB3aWxsIGFsd2F5cyBiZSBhbnRpYWxpYXNlZCBiZWNhdXNlIGl0IHdpbGwgYmUgcmVuZGVyZWQgdXNpbmcgY2FudmFzXG4gKiBOb3QgcmVjb21tZW5kZWQgaWYgeW91IGFyZSBjb25zdGFubHkgcmVkcmF3aW5nIHRoZSBncmFwaGljcyBlbGVtZW50LlxuICpcbiAqIEBwcm9wZXJ0eSBjYWNoZUFzQml0bWFwXG4gKiBAZGVmYXVsdCBmYWxzZVxuICogQHR5cGUgQm9vbGVhblxuICogQHByaXZhdGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuR3JhcGhpY3MucHJvdG90eXBlLCBcImNhY2hlQXNCaXRtYXBcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAgdGhpcy5fY2FjaGVBc0JpdG1hcDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVBc0JpdG1hcCA9IHZhbHVlO1xuXG4gICAgICAgIGlmKHRoaXMuX2NhY2hlQXNCaXRtYXApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlQ2FjaGVkU3ByaXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lDYWNoZWRTcHJpdGUoKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG59KTtcblxuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgbGluZSBzdHlsZSB1c2VkIGZvciBzdWJzZXF1ZW50IGNhbGxzIHRvIEdyYXBoaWNzIG1ldGhvZHMgc3VjaCBhcyB0aGUgbGluZVRvKCkgbWV0aG9kIG9yIHRoZSBkcmF3Q2lyY2xlKCkgbWV0aG9kLlxuICpcbiAqIEBtZXRob2QgbGluZVN0eWxlXG4gKiBAcGFyYW0gbGluZVdpZHRoIHtOdW1iZXJ9IHdpZHRoIG9mIHRoZSBsaW5lIHRvIGRyYXcsIHdpbGwgdXBkYXRlIHRoZSBvYmplY3QncyBzdG9yZWQgc3R5bGVcbiAqIEBwYXJhbSBjb2xvciB7TnVtYmVyfSBjb2xvciBvZiB0aGUgbGluZSB0byBkcmF3LCB3aWxsIHVwZGF0ZSB0aGUgb2JqZWN0J3Mgc3RvcmVkIHN0eWxlXG4gKiBAcGFyYW0gYWxwaGEge051bWJlcn0gYWxwaGEgb2YgdGhlIGxpbmUgdG8gZHJhdywgd2lsbCB1cGRhdGUgdGhlIG9iamVjdCdzIHN0b3JlZCBzdHlsZVxuICovXG5QSVhJLkdyYXBoaWNzLnByb3RvdHlwZS5saW5lU3R5bGUgPSBmdW5jdGlvbihsaW5lV2lkdGgsIGNvbG9yLCBhbHBoYSlcbntcbiAgICBpZiAoIXRoaXMuY3VycmVudFBhdGgucG9pbnRzLmxlbmd0aCkgdGhpcy5ncmFwaGljc0RhdGEucG9wKCk7XG5cbiAgICB0aGlzLmxpbmVXaWR0aCA9IGxpbmVXaWR0aCB8fCAwO1xuICAgIHRoaXMubGluZUNvbG9yID0gY29sb3IgfHwgMDtcbiAgICB0aGlzLmxpbmVBbHBoYSA9IChhcmd1bWVudHMubGVuZ3RoIDwgMykgPyAxIDogYWxwaGE7XG5cbiAgICB0aGlzLmN1cnJlbnRQYXRoID0ge2xpbmVXaWR0aDp0aGlzLmxpbmVXaWR0aCwgbGluZUNvbG9yOnRoaXMubGluZUNvbG9yLCBsaW5lQWxwaGE6dGhpcy5saW5lQWxwaGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6dGhpcy5maWxsQ29sb3IsIGZpbGxBbHBoYTp0aGlzLmZpbGxBbHBoYSwgZmlsbDp0aGlzLmZpbGxpbmcsIHBvaW50czpbXSwgdHlwZTpQSVhJLkdyYXBoaWNzLlBPTFl9O1xuXG4gICAgdGhpcy5ncmFwaGljc0RhdGEucHVzaCh0aGlzLmN1cnJlbnRQYXRoKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNb3ZlcyB0aGUgY3VycmVudCBkcmF3aW5nIHBvc2l0aW9uIHRvICh4LCB5KS5cbiAqXG4gKiBAbWV0aG9kIG1vdmVUb1xuICogQHBhcmFtIHgge051bWJlcn0gdGhlIFggY29vcmRpbmF0ZSB0byBtb3ZlIHRvXG4gKiBAcGFyYW0geSB7TnVtYmVyfSB0aGUgWSBjb29yZGluYXRlIHRvIG1vdmUgdG9cbiAqL1xuUElYSS5HcmFwaGljcy5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24oeCwgeSlcbntcbiAgICBpZiAoIXRoaXMuY3VycmVudFBhdGgucG9pbnRzLmxlbmd0aCkgdGhpcy5ncmFwaGljc0RhdGEucG9wKCk7XG5cbiAgICB0aGlzLmN1cnJlbnRQYXRoID0gdGhpcy5jdXJyZW50UGF0aCA9IHtsaW5lV2lkdGg6dGhpcy5saW5lV2lkdGgsIGxpbmVDb2xvcjp0aGlzLmxpbmVDb2xvciwgbGluZUFscGhhOnRoaXMubGluZUFscGhhLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOnRoaXMuZmlsbENvbG9yLCBmaWxsQWxwaGE6dGhpcy5maWxsQWxwaGEsIGZpbGw6dGhpcy5maWxsaW5nLCBwb2ludHM6W10sIHR5cGU6UElYSS5HcmFwaGljcy5QT0xZfTtcblxuICAgIHRoaXMuY3VycmVudFBhdGgucG9pbnRzLnB1c2goeCwgeSk7XG5cbiAgICB0aGlzLmdyYXBoaWNzRGF0YS5wdXNoKHRoaXMuY3VycmVudFBhdGgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERyYXdzIGEgbGluZSB1c2luZyB0aGUgY3VycmVudCBsaW5lIHN0eWxlIGZyb20gdGhlIGN1cnJlbnQgZHJhd2luZyBwb3NpdGlvbiB0byAoeCwgeSk7XG4gKiB0aGUgY3VycmVudCBkcmF3aW5nIHBvc2l0aW9uIGlzIHRoZW4gc2V0IHRvICh4LCB5KS5cbiAqXG4gKiBAbWV0aG9kIGxpbmVUb1xuICogQHBhcmFtIHgge051bWJlcn0gdGhlIFggY29vcmRpbmF0ZSB0byBkcmF3IHRvXG4gKiBAcGFyYW0geSB7TnVtYmVyfSB0aGUgWSBjb29yZGluYXRlIHRvIGRyYXcgdG9cbiAqL1xuUElYSS5HcmFwaGljcy5wcm90b3R5cGUubGluZVRvID0gZnVuY3Rpb24oeCwgeSlcbntcbiAgICB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cy5wdXNoKHgsIHkpO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgcG9pbnRzIGZvciBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUuXG4gKiBCYXNlZCBvbiA6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc4NTA5Ny9ob3ctZG8taS1pbXBsZW1lbnQtYS1iZXppZXItY3VydmUtaW4tY1xuICpcbiAqIEBtZXRob2QgcXVhZHJhdGljQ3VydmVUb1xuICogQHBhcmFtICB7bnVtYmVyfSAgIGNwWCAgIENvbnRyb2wgcG9pbnQgeFxuICogQHBhcmFtICB7bnVtYmVyfSAgIGNwWSAgIENvbnRyb2wgcG9pbnQgeVxuICogQHBhcmFtICB7bnVtYmVyfSAgIHRvWCAgIERlc3RpbmF0aW9uIHBvaW50IHhcbiAqIEBwYXJhbSAge251bWJlcn0gICB0b1kgICBEZXN0aW5hdGlvbiBwb2ludCB5XG4gKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfVxuICovXG5QSVhJLkdyYXBoaWNzLnByb3RvdHlwZS5xdWFkcmF0aWNDdXJ2ZVRvID0gZnVuY3Rpb24oY3BYLCBjcFksIHRvWCwgdG9ZKVxue1xuICAgIGlmKCB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cy5sZW5ndGggPT09IDApdGhpcy5tb3ZlVG8oMCwwKTtcblxuICAgIHZhciB4YSxcbiAgICB5YSxcbiAgICBuID0gMjAsXG4gICAgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5wb2ludHM7XG4gICAgaWYocG9pbnRzLmxlbmd0aCA9PT0gMCl0aGlzLm1vdmVUbygwLCAwKTtcbiAgICBcblxuICAgIHZhciBmcm9tWCA9IHBvaW50c1twb2ludHMubGVuZ3RoLTJdO1xuICAgIHZhciBmcm9tWSA9IHBvaW50c1twb2ludHMubGVuZ3RoLTFdO1xuXG4gICAgdmFyIGogPSAwO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG47IGkrKyApXG4gICAge1xuICAgICAgICBqID0gaSAvIG47XG5cbiAgICAgICAgeGEgPSBmcm9tWCArICggKGNwWCAtIGZyb21YKSAqIGogKTtcbiAgICAgICAgeWEgPSBmcm9tWSArICggKGNwWSAtIGZyb21ZKSAqIGogKTtcblxuICAgICAgICBwb2ludHMucHVzaCggeGEgKyAoICgoY3BYICsgKCAodG9YIC0gY3BYKSAqIGogKSkgLSB4YSkgKiBqICksXG4gICAgICAgICAgICAgICAgICAgICB5YSArICggKChjcFkgKyAoICh0b1kgLSBjcFkpICogaiApKSAtIHlhKSAqIGogKSApO1xuICAgIH1cblxuXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBwb2ludHMgZm9yIGEgYmV6aWVyIGN1cnZlLlxuICpcbiAqIEBtZXRob2QgYmV6aWVyQ3VydmVUb1xuICogQHBhcmFtICB7bnVtYmVyfSAgIGNwWCAgICBDb250cm9sIHBvaW50IHhcbiAqIEBwYXJhbSAge251bWJlcn0gICBjcFkgICAgQ29udHJvbCBwb2ludCB5XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICAgY3BYMiAgIFNlY29uZCBDb250cm9sIHBvaW50IHhcbiAqIEBwYXJhbSAge251bWJlcn0gICBjcFkyICAgU2Vjb25kIENvbnRyb2wgcG9pbnQgeVxuICogQHBhcmFtICB7bnVtYmVyfSAgIHRvWCAgICBEZXN0aW5hdGlvbiBwb2ludCB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICAgdG9ZICAgIERlc3RpbmF0aW9uIHBvaW50IHlcbiAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9XG4gKi9cblBJWEkuR3JhcGhpY3MucHJvdG90eXBlLmJlemllckN1cnZlVG8gPSBmdW5jdGlvbihjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1kpXG57XG4gICAgaWYoIHRoaXMuY3VycmVudFBhdGgucG9pbnRzLmxlbmd0aCA9PT0gMCl0aGlzLm1vdmVUbygwLDApO1xuXG4gICAgdmFyIG4gPSAyMCxcbiAgICBkdCxcbiAgICBkdDIsXG4gICAgZHQzLFxuICAgIHQyLFxuICAgIHQzLFxuICAgIHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzO1xuXG4gICAgdmFyIGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMl07XG4gICAgdmFyIGZyb21ZID0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMV07XG4gICAgXG4gICAgdmFyIGogPSAwO1xuXG4gICAgZm9yICh2YXIgaT0xOyBpPG47IGkrKylcbiAgICB7XG4gICAgICAgIGogPSBpIC8gbjtcblxuICAgICAgICBkdCA9ICgxIC0gaik7XG4gICAgICAgIGR0MiA9IGR0ICogZHQ7XG4gICAgICAgIGR0MyA9IGR0MiAqIGR0O1xuXG4gICAgICAgIHQyID0gaiAqIGo7XG4gICAgICAgIHQzID0gdDIgKiBqO1xuICAgICAgICBcbiAgICAgICAgcG9pbnRzLnB1c2goIGR0MyAqIGZyb21YICsgMyAqIGR0MiAqIGogKiBjcFggKyAzICogZHQgKiB0MiAqIGNwWDIgKyB0MyAqIHRvWCxcbiAgICAgICAgICAgICAgICAgICAgIGR0MyAqIGZyb21ZICsgMyAqIGR0MiAqIGogKiBjcFkgKyAzICogZHQgKiB0MiAqIGNwWTIgKyB0MyAqIHRvWSk7XG4gICAgICAgIFxuICAgIH1cbiAgICBcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLypcbiAqIHRoZSBhcmNUbygpIG1ldGhvZCBjcmVhdGVzIGFuIGFyYy9jdXJ2ZSBiZXR3ZWVuIHR3byB0YW5nZW50cyBvbiB0aGUgY2FudmFzLlxuICogXG4gKiBcImJvcnJvd2VkXCIgZnJvbSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Z4Y2FudmFzLyAtIHRoYW5rcyBnb29nbGUhXG4gKlxuICogQG1ldGhvZCBhcmNUb1xuICogQHBhcmFtICB7bnVtYmVyfSAgIHgxICAgICAgICBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFyY1xuICogQHBhcmFtICB7bnVtYmVyfSAgIHkxICAgICAgICBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFyY1xuICogQHBhcmFtICB7bnVtYmVyfSAgIHgyICAgICAgICBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGFyY1xuICogQHBhcmFtICB7bnVtYmVyfSAgIHkyICAgICAgICBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGFyY1xuICogQHBhcmFtICB7bnVtYmVyfSAgIHJhZGl1cyAgICBUaGUgcmFkaXVzIG9mIHRoZSBhcmNcbiAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9XG4gKi9cblBJWEkuR3JhcGhpY3MucHJvdG90eXBlLmFyY1RvID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cylcbntcbiAgICAvLyBjaGVjayB0aGF0IHBhdGggY29udGFpbnMgc3VicGF0aHNcbiAgICBpZiggdGhpcy5jdXJyZW50UGF0aC5wb2ludHMubGVuZ3RoID09PSAwKXRoaXMubW92ZVRvKHgxLCB5MSk7XG4gICAgXG4gICAgdmFyIHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzO1xuICAgIHZhciBmcm9tWCA9IHBvaW50c1twb2ludHMubGVuZ3RoLTJdO1xuICAgIHZhciBmcm9tWSA9IHBvaW50c1twb2ludHMubGVuZ3RoLTFdO1xuXG4vLyAgICBwb2ludHMucHVzaCggeDEsICB5MSk7XG5cbiAgICB2YXIgYTEgPSBmcm9tWSAtIHkxO1xuICAgIHZhciBiMSA9IGZyb21YIC0geDE7XG4gICAgdmFyIGEyID0geTIgICAtIHkxO1xuICAgIHZhciBiMiA9IHgyICAgLSB4MTtcbiAgICB2YXIgbW0gPSBNYXRoLmFicyhhMSAqIGIyIC0gYjEgKiBhMik7XG5cbiAgICBpZiAobW0gPCAxLjBlLTggfHwgcmFkaXVzID09PSAwKVxuICAgIHtcbiAgICAgICAgcG9pbnRzLnB1c2goeDEsIHkxKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdmFyIGRkID0gYTEgKiBhMSArIGIxICogYjE7XG4gICAgICAgIHZhciBjYyA9IGEyICogYTIgKyBiMiAqIGIyO1xuICAgICAgICB2YXIgdHQgPSBhMSAqIGEyICsgYjEgKiBiMjtcbiAgICAgICAgdmFyIGsxID0gcmFkaXVzICogTWF0aC5zcXJ0KGRkKSAvIG1tO1xuICAgICAgICB2YXIgazIgPSByYWRpdXMgKiBNYXRoLnNxcnQoY2MpIC8gbW07XG4gICAgICAgIHZhciBqMSA9IGsxICogdHQgLyBkZDtcbiAgICAgICAgdmFyIGoyID0gazIgKiB0dCAvIGNjO1xuICAgICAgICB2YXIgY3ggPSBrMSAqIGIyICsgazIgKiBiMTtcbiAgICAgICAgdmFyIGN5ID0gazEgKiBhMiArIGsyICogYTE7XG4gICAgICAgIHZhciBweCA9IGIxICogKGsyICsgajEpO1xuICAgICAgICB2YXIgcHkgPSBhMSAqIChrMiArIGoxKTtcbiAgICAgICAgdmFyIHF4ID0gYjIgKiAoazEgKyBqMik7XG4gICAgICAgIHZhciBxeSA9IGEyICogKGsxICsgajIpO1xuICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IE1hdGguYXRhbjIocHkgLSBjeSwgcHggLSBjeCk7XG4gICAgICAgIHZhciBlbmRBbmdsZSAgID0gTWF0aC5hdGFuMihxeSAtIGN5LCBxeCAtIGN4KTtcbiAgICAgICAgLy8gbm90IHJlcXVpcmVkP1xuICAgICAvLyAgIHBvaW50cy5wdXNoKHB4ICsgeDEgLCBweSArIHkxKTtcbiAgICAgICAgdGhpcy5hcmMoY3ggKyB4MSwgY3kgKyB5MSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYjEgKiBhMiA+IGIyICogYTEpO1xuICAgIH1cblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRoZSBhcmMoKSBtZXRob2QgY3JlYXRlcyBhbiBhcmMvY3VydmUgKHVzZWQgdG8gY3JlYXRlIGNpcmNsZXMsIG9yIHBhcnRzIG9mIGNpcmNsZXMpLlxuICpcbiAqIEBtZXRob2QgYXJjXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICAgY3ggICAgICAgICAgICAgICAgVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcbiAqIEBwYXJhbSAge251bWJlcn0gICBjeSAgICAgICAgICAgICAgICBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxuICogQHBhcmFtICB7bnVtYmVyfSAgIHJhZGl1cyAgICAgICAgICAgIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICogQHBhcmFtICB7bnVtYmVyfSAgIHN0YXJ0QW5nbGUgICAgICAgIFRoZSBzdGFydGluZyBhbmdsZSwgaW4gcmFkaWFucyAoMCBpcyBhdCB0aGUgMyBvJ2Nsb2NrIHBvc2l0aW9uIG9mIHRoZSBhcmMncyBjaXJjbGUpXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICAgZW5kQW5nbGUgICAgICAgICAgVGhlIGVuZGluZyBhbmdsZSwgaW4gcmFkaWFuc1xuICogQHBhcmFtICB7bnVtYmVyfSAgIGFudGljbG9ja3dpc2UgICAgIE9wdGlvbmFsLiBTcGVjaWZpZXMgd2hldGhlciB0aGUgZHJhd2luZyBzaG91bGQgYmUgY291bnRlcmNsb2Nrd2lzZSBvciBjbG9ja3dpc2UuIEZhbHNlIGlzIGRlZmF1bHQsIGFuZCBpbmRpY2F0ZXMgY2xvY2t3aXNlLCB3aGlsZSB0cnVlIGluZGljYXRlcyBjb3VudGVyLWNsb2Nrd2lzZS5cbiAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9XG4gKi9cblBJWEkuR3JhcGhpY3MucHJvdG90eXBlLmFyYyA9IGZ1bmN0aW9uKGN4LCBjeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSlcbntcbiAgICB2YXIgc3RhcnRYID0gY3ggKyBNYXRoLmNvcyhzdGFydEFuZ2xlKSAqIHJhZGl1cztcbiAgICB2YXIgc3RhcnRZID0gY3kgKyBNYXRoLnNpbihzdGFydEFuZ2xlKSAqIHJhZGl1cztcbiAgICBcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5wb2ludHM7XG5cbiAgICBpZihwb2ludHMubGVuZ3RoICE9PSAwICYmIHBvaW50c1twb2ludHMubGVuZ3RoLTJdICE9PSBzdGFydFggfHwgcG9pbnRzW3BvaW50cy5sZW5ndGgtMV0gIT09IHN0YXJ0WSlcbiAgICB7XG4gICAgICAgIHRoaXMubW92ZVRvKHN0YXJ0WCwgc3RhcnRZKTtcbiAgICAgICAgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5wb2ludHM7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0QW5nbGUgPT09IGVuZEFuZ2xlKXJldHVybiB0aGlzO1xuXG4gICAgaWYoICFhbnRpY2xvY2t3aXNlICYmIGVuZEFuZ2xlIDw9IHN0YXJ0QW5nbGUgKVxuICAgIHtcbiAgICAgICAgZW5kQW5nbGUgKz0gTWF0aC5QSSAqIDI7XG4gICAgfVxuICAgIGVsc2UgaWYoIGFudGljbG9ja3dpc2UgJiYgc3RhcnRBbmdsZSA8PSBlbmRBbmdsZSApXG4gICAge1xuICAgICAgICBzdGFydEFuZ2xlICs9IE1hdGguUEkgKiAyO1xuICAgIH1cblxuICAgIHZhciBzd2VlcCA9IGFudGljbG9ja3dpc2UgPyAoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSAqLTEgOiAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgICB2YXIgc2VncyA9ICAoIE1hdGguYWJzKHN3ZWVwKS8gKE1hdGguUEkgKiAyKSApICogNDA7XG5cbiAgICBpZiggc3dlZXAgPT09IDAgKSByZXR1cm4gdGhpcztcblxuICAgIHZhciB0aGV0YSA9IHN3ZWVwLyhzZWdzKjIpO1xuICAgIHZhciB0aGV0YTIgPSB0aGV0YSoyO1xuXG4gICAgdmFyIGNUaGV0YSA9IE1hdGguY29zKHRoZXRhKTtcbiAgICB2YXIgc1RoZXRhID0gTWF0aC5zaW4odGhldGEpO1xuICAgIFxuICAgIHZhciBzZWdNaW51cyA9IHNlZ3MgLSAxO1xuXG4gICAgdmFyIHJlbWFpbmRlciA9ICggc2VnTWludXMgJSAxICkgLyBzZWdNaW51cztcblxuICAgIGZvcih2YXIgaT0wOyBpPD1zZWdNaW51czsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIHJlYWwgPSAgaSArIHJlbWFpbmRlciAqIGk7XG5cbiAgICBcbiAgICAgICAgdmFyIGFuZ2xlID0gKCh0aGV0YSkgKyBzdGFydEFuZ2xlICsgKHRoZXRhMiAqIHJlYWwpKTtcblxuICAgICAgICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgdmFyIHMgPSAtTWF0aC5zaW4oYW5nbGUpO1xuXG4gICAgICAgIHBvaW50cy5wdXNoKCggKGNUaGV0YSAqICBjKSArIChzVGhldGEgKiBzKSApICogcmFkaXVzICsgY3gsXG4gICAgICAgICAgICAgICAgICAgICggKGNUaGV0YSAqIC1zKSArIChzVGhldGEgKiBjKSApICogcmFkaXVzICsgY3kpO1xuICAgIH1cblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERyYXdzIGEgbGluZSB1c2luZyB0aGUgY3VycmVudCBsaW5lIHN0eWxlIGZyb20gdGhlIGN1cnJlbnQgZHJhd2luZyBwb3NpdGlvbiB0byAoeCwgeSk7XG4gKiB0aGUgY3VycmVudCBkcmF3aW5nIHBvc2l0aW9uIGlzIHRoZW4gc2V0IHRvICh4LCB5KS5cbiAqXG4gKiBAbWV0aG9kIGxpbmVUb1xuICogQHBhcmFtIHgge051bWJlcn0gdGhlIFggY29vcmRpbmF0ZSB0byBkcmF3IHRvXG4gKiBAcGFyYW0geSB7TnVtYmVyfSB0aGUgWSBjb29yZGluYXRlIHRvIGRyYXcgdG9cbiAqL1xuUElYSS5HcmFwaGljcy5wcm90b3R5cGUuZHJhd1BhdGggPSBmdW5jdGlvbihwYXRoKVxue1xuICAgIGlmICghdGhpcy5jdXJyZW50UGF0aC5wb2ludHMubGVuZ3RoKSB0aGlzLmdyYXBoaWNzRGF0YS5wb3AoKTtcblxuICAgIHRoaXMuY3VycmVudFBhdGggPSB0aGlzLmN1cnJlbnRQYXRoID0ge2xpbmVXaWR0aDp0aGlzLmxpbmVXaWR0aCwgbGluZUNvbG9yOnRoaXMubGluZUNvbG9yLCBsaW5lQWxwaGE6dGhpcy5saW5lQWxwaGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6dGhpcy5maWxsQ29sb3IsIGZpbGxBbHBoYTp0aGlzLmZpbGxBbHBoYSwgZmlsbDp0aGlzLmZpbGxpbmcsIHBvaW50czpbXSwgdHlwZTpQSVhJLkdyYXBoaWNzLlBPTFl9O1xuXG4gICAgdGhpcy5ncmFwaGljc0RhdGEucHVzaCh0aGlzLmN1cnJlbnRQYXRoKTtcblxuICAgIHRoaXMuY3VycmVudFBhdGgucG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5wb2ludHMuY29uY2F0KHBhdGgpO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIHNpbXBsZSBvbmUtY29sb3IgZmlsbCB0aGF0IHN1YnNlcXVlbnQgY2FsbHMgdG8gb3RoZXIgR3JhcGhpY3MgbWV0aG9kc1xuICogKHN1Y2ggYXMgbGluZVRvKCkgb3IgZHJhd0NpcmNsZSgpKSB1c2Ugd2hlbiBkcmF3aW5nLlxuICpcbiAqIEBtZXRob2QgYmVnaW5GaWxsXG4gKiBAcGFyYW0gY29sb3Ige051bWJlcn0gdGhlIGNvbG9yIG9mIHRoZSBmaWxsXG4gKiBAcGFyYW0gYWxwaGEge051bWJlcn0gdGhlIGFscGhhIG9mIHRoZSBmaWxsXG4gKi9cblBJWEkuR3JhcGhpY3MucHJvdG90eXBlLmJlZ2luRmlsbCA9IGZ1bmN0aW9uKGNvbG9yLCBhbHBoYSlcbntcblxuICAgIHRoaXMuZmlsbGluZyA9IHRydWU7XG4gICAgdGhpcy5maWxsQ29sb3IgPSBjb2xvciB8fCAwO1xuICAgIHRoaXMuZmlsbEFscGhhID0gKGFyZ3VtZW50cy5sZW5ndGggPCAyKSA/IDEgOiBhbHBoYTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIGEgZmlsbCB0byB0aGUgbGluZXMgYW5kIHNoYXBlcyB0aGF0IHdlcmUgYWRkZWQgc2luY2UgdGhlIGxhc3QgY2FsbCB0byB0aGUgYmVnaW5GaWxsKCkgbWV0aG9kLlxuICpcbiAqIEBtZXRob2QgZW5kRmlsbFxuICovXG5QSVhJLkdyYXBoaWNzLnByb3RvdHlwZS5lbmRGaWxsID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuZmlsbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZmlsbENvbG9yID0gbnVsbDtcbiAgICB0aGlzLmZpbGxBbHBoYSA9IDE7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkcmF3UmVjdFxuICpcbiAqIEBwYXJhbSB4IHtOdW1iZXJ9IFRoZSBYIGNvb3JkIG9mIHRoZSB0b3AtbGVmdCBvZiB0aGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0geSB7TnVtYmVyfSBUaGUgWSBjb29yZCBvZiB0aGUgdG9wLWxlZnQgb2YgdGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gaGVpZ2h0IHtOdW1iZXJ9IFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICovXG5QSVhJLkdyYXBoaWNzLnByb3RvdHlwZS5kcmF3UmVjdCA9IGZ1bmN0aW9uKCB4LCB5LCB3aWR0aCwgaGVpZ2h0IClcbntcbiAgICBpZiAoIXRoaXMuY3VycmVudFBhdGgucG9pbnRzLmxlbmd0aCkgdGhpcy5ncmFwaGljc0RhdGEucG9wKCk7XG5cbiAgICB0aGlzLmN1cnJlbnRQYXRoID0ge2xpbmVXaWR0aDp0aGlzLmxpbmVXaWR0aCwgbGluZUNvbG9yOnRoaXMubGluZUNvbG9yLCBsaW5lQWxwaGE6dGhpcy5saW5lQWxwaGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6dGhpcy5maWxsQ29sb3IsIGZpbGxBbHBoYTp0aGlzLmZpbGxBbHBoYSwgZmlsbDp0aGlzLmZpbGxpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHM6W3gsIHksIHdpZHRoLCBoZWlnaHRdLCB0eXBlOlBJWEkuR3JhcGhpY3MuUkVDVH07XG5cbiAgICB0aGlzLmdyYXBoaWNzRGF0YS5wdXNoKHRoaXMuY3VycmVudFBhdGgpO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZHJhd1JvdW5kZWRSZWN0XG4gKlxuICogQHBhcmFtIHgge051bWJlcn0gVGhlIFggY29vcmQgb2YgdGhlIHRvcC1sZWZ0IG9mIHRoZSByZWN0YW5nbGVcbiAqIEBwYXJhbSB5IHtOdW1iZXJ9IFRoZSBZIGNvb3JkIG9mIHRoZSB0b3AtbGVmdCBvZiB0aGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gd2lkdGgge051bWJlcn0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAqIEBwYXJhbSBoZWlnaHQge051bWJlcn0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gcmFkaXVzIHtOdW1iZXJ9IFJhZGl1cyBvZiB0aGUgcmVjdGFuZ2xlIGNvcm5lcnNcbiAqL1xuUElYSS5HcmFwaGljcy5wcm90b3R5cGUuZHJhd1JvdW5kZWRSZWN0ID0gZnVuY3Rpb24oIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyApXG57XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRQYXRoLnBvaW50cy5sZW5ndGgpIHRoaXMuZ3JhcGhpY3NEYXRhLnBvcCgpO1xuXG4gICAgdGhpcy5jdXJyZW50UGF0aCA9IHtsaW5lV2lkdGg6dGhpcy5saW5lV2lkdGgsIGxpbmVDb2xvcjp0aGlzLmxpbmVDb2xvciwgbGluZUFscGhhOnRoaXMubGluZUFscGhhLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOnRoaXMuZmlsbENvbG9yLCBmaWxsQWxwaGE6dGhpcy5maWxsQWxwaGEsIGZpbGw6dGhpcy5maWxsaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOlt4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXNdLCB0eXBlOlBJWEkuR3JhcGhpY3MuUlJFQ307XG5cbiAgICB0aGlzLmdyYXBoaWNzRGF0YS5wdXNoKHRoaXMuY3VycmVudFBhdGgpO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERyYXdzIGEgY2lyY2xlLlxuICpcbiAqIEBtZXRob2QgZHJhd0NpcmNsZVxuICogQHBhcmFtIHgge051bWJlcn0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcbiAqIEBwYXJhbSB5IHtOdW1iZXJ9IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXG4gKiBAcGFyYW0gcmFkaXVzIHtOdW1iZXJ9IFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICovXG5QSVhJLkdyYXBoaWNzLnByb3RvdHlwZS5kcmF3Q2lyY2xlID0gZnVuY3Rpb24oeCwgeSwgcmFkaXVzKVxue1xuXG4gICAgaWYgKCF0aGlzLmN1cnJlbnRQYXRoLnBvaW50cy5sZW5ndGgpIHRoaXMuZ3JhcGhpY3NEYXRhLnBvcCgpO1xuXG4gICAgdGhpcy5jdXJyZW50UGF0aCA9IHtsaW5lV2lkdGg6dGhpcy5saW5lV2lkdGgsIGxpbmVDb2xvcjp0aGlzLmxpbmVDb2xvciwgbGluZUFscGhhOnRoaXMubGluZUFscGhhLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOnRoaXMuZmlsbENvbG9yLCBmaWxsQWxwaGE6dGhpcy5maWxsQWxwaGEsIGZpbGw6dGhpcy5maWxsaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOlt4LCB5LCByYWRpdXMsIHJhZGl1c10sIHR5cGU6UElYSS5HcmFwaGljcy5DSVJDfTtcblxuICAgIHRoaXMuZ3JhcGhpY3NEYXRhLnB1c2godGhpcy5jdXJyZW50UGF0aCk7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRHJhd3MgYW4gZWxsaXBzZS5cbiAqXG4gKiBAbWV0aG9kIGRyYXdFbGxpcHNlXG4gKiBAcGFyYW0geCB7TnVtYmVyfSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2VcbiAqIEBwYXJhbSB5IHtOdW1iZXJ9IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZVxuICogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IFRoZSBoYWxmIHdpZHRoIG9mIHRoZSBlbGxpcHNlXG4gKiBAcGFyYW0gaGVpZ2h0IHtOdW1iZXJ9IFRoZSBoYWxmIGhlaWdodCBvZiB0aGUgZWxsaXBzZVxuICovXG5QSVhJLkdyYXBoaWNzLnByb3RvdHlwZS5kcmF3RWxsaXBzZSA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpXG57XG5cbiAgICBpZiAoIXRoaXMuY3VycmVudFBhdGgucG9pbnRzLmxlbmd0aCkgdGhpcy5ncmFwaGljc0RhdGEucG9wKCk7XG5cbiAgICB0aGlzLmN1cnJlbnRQYXRoID0ge2xpbmVXaWR0aDp0aGlzLmxpbmVXaWR0aCwgbGluZUNvbG9yOnRoaXMubGluZUNvbG9yLCBsaW5lQWxwaGE6dGhpcy5saW5lQWxwaGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6dGhpcy5maWxsQ29sb3IsIGZpbGxBbHBoYTp0aGlzLmZpbGxBbHBoYSwgZmlsbDp0aGlzLmZpbGxpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHM6W3gsIHksIHdpZHRoLCBoZWlnaHRdLCB0eXBlOlBJWEkuR3JhcGhpY3MuRUxJUH07XG5cbiAgICB0aGlzLmdyYXBoaWNzRGF0YS5wdXNoKHRoaXMuY3VycmVudFBhdGgpO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgZ3JhcGhpY3MgdGhhdCB3ZXJlIGRyYXduIHRvIHRoaXMgR3JhcGhpY3Mgb2JqZWN0LCBhbmQgcmVzZXRzIGZpbGwgYW5kIGxpbmUgc3R5bGUgc2V0dGluZ3MuXG4gKlxuICogQG1ldGhvZCBjbGVhclxuICovXG5QSVhJLkdyYXBoaWNzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmxpbmVXaWR0aCA9IDA7XG4gICAgdGhpcy5maWxsaW5nID0gZmFsc2U7XG5cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLmNsZWFyRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuZ3JhcGhpY3NEYXRhID0gW107XG5cbiAgICB0aGlzLmJvdW5kcyA9IG51bGw7IC8vbmV3IFBJWEkuUmVjdGFuZ2xlKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVXNlZnVsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRleHR1cmUgb2YgdGhlIGdyYXBoaWNzIG9iamVjdCB0aGF0IGNhbiB0aGVuIGJlIHVzZWQgdG8gY3JlYXRlIHNwcml0ZXNcbiAqIFRoaXMgY2FuIGJlIHF1aXRlIHVzZWZ1bCBpZiB5b3VyIGdlb21ldHJ5IGlzIGNvbXBsaWNhdGVkIGFuZCBuZWVkcyB0byBiZSByZXVzZWQgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogQG1ldGhvZCBnZW5lcmF0ZVRleHR1cmVcbiAqIEByZXR1cm4ge1RleHR1cmV9IGEgdGV4dHVyZSBvZiB0aGUgZ3JhcGhpY3Mgb2JqZWN0XG4gKi9cblBJWEkuR3JhcGhpY3MucHJvdG90eXBlLmdlbmVyYXRlVGV4dHVyZSA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcblxuICAgIHZhciBjYW52YXNCdWZmZXIgPSBuZXcgUElYSS5DYW52YXNCdWZmZXIoYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0KTtcbiAgICB2YXIgdGV4dHVyZSA9IFBJWEkuVGV4dHVyZS5mcm9tQ2FudmFzKGNhbnZhc0J1ZmZlci5jYW52YXMpO1xuXG4gICAgY2FudmFzQnVmZmVyLmNvbnRleHQudHJhbnNsYXRlKC1ib3VuZHMueCwtYm91bmRzLnkpO1xuICAgIFxuICAgIFBJWEkuQ2FudmFzR3JhcGhpY3MucmVuZGVyR3JhcGhpY3ModGhpcywgY2FudmFzQnVmZmVyLmNvbnRleHQpO1xuXG4gICAgcmV0dXJuIHRleHR1cmU7XG59O1xuXG4vKipcbiogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuKlxuKiBAbWV0aG9kIF9yZW5kZXJXZWJHTFxuKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7UmVuZGVyU2Vzc2lvbn0gXG4qIEBwcml2YXRlXG4qL1xuUElYSS5HcmFwaGljcy5wcm90b3R5cGUuX3JlbmRlcldlYkdMID0gZnVuY3Rpb24ocmVuZGVyU2Vzc2lvbilcbntcbiAgICAvLyBpZiB0aGUgc3ByaXRlIGlzIG5vdCB2aXNpYmxlIG9yIHRoZSBhbHBoYSBpcyAwIHRoZW4gbm8gbmVlZCB0byByZW5kZXIgdGhpcyBlbGVtZW50XG4gICAgaWYodGhpcy52aXNpYmxlID09PSBmYWxzZSB8fCB0aGlzLmFscGhhID09PSAwIHx8IHRoaXMuaXNNYXNrID09PSB0cnVlKXJldHVybjtcbiAgICBcblxuICAgIGlmKHRoaXMuX2NhY2hlQXNCaXRtYXApXG4gICAge1xuICAgICAgIFxuICAgICAgICBpZih0aGlzLmRpcnR5KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9nZW5lcmF0ZUNhY2hlZFNwcml0ZSgpO1xuICAgICAgICAgICAgLy8gd2Ugd2lsbCBhbHNvIG5lZWQgdG8gdXBkYXRlIHRoZSB0ZXh0dXJlIG9uIHRoZSBncHUgdG9vIVxuICAgICAgICAgICAgUElYSS51cGRhdGVXZWJHTFRleHR1cmUodGhpcy5fY2FjaGVkU3ByaXRlLnRleHR1cmUuYmFzZVRleHR1cmUsIHJlbmRlclNlc3Npb24uZ2wpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FjaGVkU3ByaXRlLmFscGhhID0gdGhpcy5hbHBoYTtcbiAgICAgICAgUElYSS5TcHJpdGUucHJvdG90eXBlLl9yZW5kZXJXZWJHTC5jYWxsKHRoaXMuX2NhY2hlZFNwcml0ZSwgcmVuZGVyU2Vzc2lvbik7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLnN0b3AoKTtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5ibGVuZE1vZGVNYW5hZ2VyLnNldEJsZW5kTW9kZSh0aGlzLmJsZW5kTW9kZSk7XG5cbiAgICAgICAgaWYodGhpcy5fbWFzaylyZW5kZXJTZXNzaW9uLm1hc2tNYW5hZ2VyLnB1c2hNYXNrKHRoaXMuX21hc2ssIHJlbmRlclNlc3Npb24pO1xuICAgICAgICBpZih0aGlzLl9maWx0ZXJzKXJlbmRlclNlc3Npb24uZmlsdGVyTWFuYWdlci5wdXNoRmlsdGVyKHRoaXMuX2ZpbHRlckJsb2NrKTtcbiAgICAgIFxuICAgICAgICAvLyBjaGVjayBibGVuZCBtb2RlXG4gICAgICAgIGlmKHRoaXMuYmxlbmRNb2RlICE9PSByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLmN1cnJlbnRCbGVuZE1vZGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2guY3VycmVudEJsZW5kTW9kZSA9IHRoaXMuYmxlbmRNb2RlO1xuICAgICAgICAgICAgdmFyIGJsZW5kTW9kZVdlYkdMID0gUElYSS5ibGVuZE1vZGVzV2ViR0xbcmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaC5jdXJyZW50QmxlbmRNb2RlXTtcbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2guZ2wuYmxlbmRGdW5jKGJsZW5kTW9kZVdlYkdMWzBdLCBibGVuZE1vZGVXZWJHTFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAvLyAgZm9yICh2YXIgaSA9IHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIC8vICAgIHRoaXMuZ3JhcGhpY3NEYXRhW2ldXG4gICAgICAgICAgICBcbi8vICAgICAgICB9O1xuXG4gICAgICAgIFBJWEkuV2ViR0xHcmFwaGljcy5yZW5kZXJHcmFwaGljcyh0aGlzLCByZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgXG4gICAgICAgIC8vIG9ubHkgcmVuZGVyIGlmIGl0IGhhcyBjaGlsZHJlbiFcbiAgICAgICAgaWYodGhpcy5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2guc3RhcnQoKTtcblxuICAgICAgICAgICAgIC8vIHNpbXBsZSByZW5kZXIgY2hpbGRyZW4hXG4gICAgICAgICAgICBmb3IodmFyIGk9MCwgaj10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxqOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5fcmVuZGVyV2ViR0wocmVuZGVyU2Vzc2lvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2guc3RvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5fZmlsdGVycylyZW5kZXJTZXNzaW9uLmZpbHRlck1hbmFnZXIucG9wRmlsdGVyKCk7XG4gICAgICAgIGlmKHRoaXMuX21hc2spcmVuZGVyU2Vzc2lvbi5tYXNrTWFuYWdlci5wb3BNYXNrKHRoaXMubWFzaywgcmVuZGVyU2Vzc2lvbik7XG4gICAgICAgICAgXG4gICAgICAgIHJlbmRlclNlc3Npb24uZHJhd0NvdW50Kys7XG5cbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaC5zdGFydCgpO1xuICAgIH1cbn07XG5cbi8qKlxuKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIENhbnZhcyByZW5kZXJlclxuKlxuKiBAbWV0aG9kIF9yZW5kZXJDYW52YXNcbiogQHBhcmFtIHJlbmRlclNlc3Npb24ge1JlbmRlclNlc3Npb259IFxuKiBAcHJpdmF0ZVxuKi9cblBJWEkuR3JhcGhpY3MucHJvdG90eXBlLl9yZW5kZXJDYW52YXMgPSBmdW5jdGlvbihyZW5kZXJTZXNzaW9uKVxue1xuICAgIC8vIGlmIHRoZSBzcHJpdGUgaXMgbm90IHZpc2libGUgb3IgdGhlIGFscGhhIGlzIDAgdGhlbiBubyBuZWVkIHRvIHJlbmRlciB0aGlzIGVsZW1lbnRcbiAgICBpZih0aGlzLnZpc2libGUgPT09IGZhbHNlIHx8IHRoaXMuYWxwaGEgPT09IDAgfHwgdGhpcy5pc01hc2sgPT09IHRydWUpcmV0dXJuO1xuICAgIFxuICAgIHZhciBjb250ZXh0ID0gcmVuZGVyU2Vzc2lvbi5jb250ZXh0O1xuICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuICAgIFxuICAgIGlmKHRoaXMuYmxlbmRNb2RlICE9PSByZW5kZXJTZXNzaW9uLmN1cnJlbnRCbGVuZE1vZGUpXG4gICAge1xuICAgICAgICByZW5kZXJTZXNzaW9uLmN1cnJlbnRCbGVuZE1vZGUgPSB0aGlzLmJsZW5kTW9kZTtcbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBQSVhJLmJsZW5kTW9kZXNDYW52YXNbcmVuZGVyU2Vzc2lvbi5jdXJyZW50QmxlbmRNb2RlXTtcbiAgICB9XG5cbiAgICBpZih0aGlzLl9tYXNrKVxuICAgIHtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5tYXNrTWFuYWdlci5wdXNoTWFzayh0aGlzLl9tYXNrLCByZW5kZXJTZXNzaW9uLmNvbnRleHQpO1xuICAgIH1cblxuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKHRyYW5zZm9ybS5hLCB0cmFuc2Zvcm0uYywgdHJhbnNmb3JtLmIsIHRyYW5zZm9ybS5kLCB0cmFuc2Zvcm0udHgsIHRyYW5zZm9ybS50eSk7XG4gICAgUElYSS5DYW52YXNHcmFwaGljcy5yZW5kZXJHcmFwaGljcyh0aGlzLCBjb250ZXh0KTtcblxuICAgICAvLyBzaW1wbGUgcmVuZGVyIGNoaWxkcmVuIVxuICAgIGZvcih2YXIgaT0wLCBqPXRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpPGo7IGkrKylcbiAgICB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0uX3JlbmRlckNhbnZhcyhyZW5kZXJTZXNzaW9uKTtcbiAgICB9XG5cbiAgICBpZih0aGlzLl9tYXNrKVxuICAgIHtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5tYXNrTWFuYWdlci5wb3BNYXNrKHJlbmRlclNlc3Npb24uY29udGV4dCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGJvdW5kcyBvZiB0aGUgZ3JhcGhpYyBzaGFwZSBhcyBhIHJlY3RhbmdsZSBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIGdldEJvdW5kc1xuICogQHJldHVybiB7UmVjdGFuZ2xlfSB0aGUgcmVjdGFuZ3VsYXIgYm91bmRpbmcgYXJlYVxuICovXG5QSVhJLkdyYXBoaWNzLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiggbWF0cml4IClcbntcbiAgICBpZighdGhpcy5ib3VuZHMpdGhpcy51cGRhdGVCb3VuZHMoKTtcblxuICAgIHZhciB3MCA9IHRoaXMuYm91bmRzLng7XG4gICAgdmFyIHcxID0gdGhpcy5ib3VuZHMud2lkdGggKyB0aGlzLmJvdW5kcy54O1xuXG4gICAgdmFyIGgwID0gdGhpcy5ib3VuZHMueTtcbiAgICB2YXIgaDEgPSB0aGlzLmJvdW5kcy5oZWlnaHQgKyB0aGlzLmJvdW5kcy55O1xuXG4gICAgdmFyIHdvcmxkVHJhbnNmb3JtID0gbWF0cml4IHx8IHRoaXMud29ybGRUcmFuc2Zvcm07XG5cbiAgICB2YXIgYSA9IHdvcmxkVHJhbnNmb3JtLmE7XG4gICAgdmFyIGIgPSB3b3JsZFRyYW5zZm9ybS5jO1xuICAgIHZhciBjID0gd29ybGRUcmFuc2Zvcm0uYjtcbiAgICB2YXIgZCA9IHdvcmxkVHJhbnNmb3JtLmQ7XG4gICAgdmFyIHR4ID0gd29ybGRUcmFuc2Zvcm0udHg7XG4gICAgdmFyIHR5ID0gd29ybGRUcmFuc2Zvcm0udHk7XG5cbiAgICB2YXIgeDEgPSBhICogdzEgKyBjICogaDEgKyB0eDtcbiAgICB2YXIgeTEgPSBkICogaDEgKyBiICogdzEgKyB0eTtcblxuICAgIHZhciB4MiA9IGEgKiB3MCArIGMgKiBoMSArIHR4O1xuICAgIHZhciB5MiA9IGQgKiBoMSArIGIgKiB3MCArIHR5O1xuXG4gICAgdmFyIHgzID0gYSAqIHcwICsgYyAqIGgwICsgdHg7XG4gICAgdmFyIHkzID0gZCAqIGgwICsgYiAqIHcwICsgdHk7XG5cbiAgICB2YXIgeDQgPSAgYSAqIHcxICsgYyAqIGgwICsgdHg7XG4gICAgdmFyIHk0ID0gIGQgKiBoMCArIGIgKiB3MSArIHR5O1xuXG4gICAgdmFyIG1heFggPSB4MTtcbiAgICB2YXIgbWF4WSA9IHkxO1xuXG4gICAgdmFyIG1pblggPSB4MTtcbiAgICB2YXIgbWluWSA9IHkxO1xuXG4gICAgbWluWCA9IHgyIDwgbWluWCA/IHgyIDogbWluWDtcbiAgICBtaW5YID0geDMgPCBtaW5YID8geDMgOiBtaW5YO1xuICAgIG1pblggPSB4NCA8IG1pblggPyB4NCA6IG1pblg7XG5cbiAgICBtaW5ZID0geTIgPCBtaW5ZID8geTIgOiBtaW5ZO1xuICAgIG1pblkgPSB5MyA8IG1pblkgPyB5MyA6IG1pblk7XG4gICAgbWluWSA9IHk0IDwgbWluWSA/IHk0IDogbWluWTtcblxuICAgIG1heFggPSB4MiA+IG1heFggPyB4MiA6IG1heFg7XG4gICAgbWF4WCA9IHgzID4gbWF4WCA/IHgzIDogbWF4WDtcbiAgICBtYXhYID0geDQgPiBtYXhYID8geDQgOiBtYXhYO1xuXG4gICAgbWF4WSA9IHkyID4gbWF4WSA/IHkyIDogbWF4WTtcbiAgICBtYXhZID0geTMgPiBtYXhZID8geTMgOiBtYXhZO1xuICAgIG1heFkgPSB5NCA+IG1heFkgPyB5NCA6IG1heFk7XG5cbiAgICB2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzO1xuXG4gICAgYm91bmRzLnggPSBtaW5YO1xuICAgIGJvdW5kcy53aWR0aCA9IG1heFggLSBtaW5YO1xuXG4gICAgYm91bmRzLnkgPSBtaW5ZO1xuICAgIGJvdW5kcy5oZWlnaHQgPSBtYXhZIC0gbWluWTtcblxuICAgIHJldHVybiBib3VuZHM7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgYm91bmRzIG9mIHRoZSBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kc1xuICovXG5QSVhJLkdyYXBoaWNzLnByb3RvdHlwZS51cGRhdGVCb3VuZHMgPSBmdW5jdGlvbigpXG57XG4gICAgXG4gICAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcblxuICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG4gICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICB2YXIgcG9pbnRzLCB4LCB5LCB3LCBoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ3JhcGhpY3NEYXRhW2ldO1xuICAgICAgICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IGRhdGEubGluZVdpZHRoO1xuXG4gICAgICAgIHBvaW50cyA9IGRhdGEucG9pbnRzO1xuXG4gICAgICAgIGlmKHR5cGUgPT09IFBJWEkuR3JhcGhpY3MuUkVDVClcbiAgICAgICAge1xuICAgICAgICAgICAgeCA9IHBvaW50c1swXSAtIGxpbmVXaWR0aC8yO1xuICAgICAgICAgICAgeSA9IHBvaW50c1sxXSAtIGxpbmVXaWR0aC8yO1xuICAgICAgICAgICAgdyA9IHBvaW50c1syXSArIGxpbmVXaWR0aDtcbiAgICAgICAgICAgIGggPSBwb2ludHNbM10gKyBsaW5lV2lkdGg7XG5cbiAgICAgICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgICAgICAgbWF4WCA9IHggKyB3ID4gbWF4WCA/IHggKyB3IDogbWF4WDtcblxuICAgICAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geCA6IG1pblk7XG4gICAgICAgICAgICBtYXhZID0geSArIGggPiBtYXhZID8geSArIGggOiBtYXhZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodHlwZSA9PT0gUElYSS5HcmFwaGljcy5DSVJDIHx8IHR5cGUgPT09IFBJWEkuR3JhcGhpY3MuRUxJUClcbiAgICAgICAge1xuICAgICAgICAgICAgeCA9IHBvaW50c1swXTtcbiAgICAgICAgICAgIHkgPSBwb2ludHNbMV07XG4gICAgICAgICAgICB3ID0gcG9pbnRzWzJdICsgbGluZVdpZHRoLzI7XG4gICAgICAgICAgICBoID0gcG9pbnRzWzNdICsgbGluZVdpZHRoLzI7XG5cbiAgICAgICAgICAgIG1pblggPSB4IC0gdyA8IG1pblggPyB4IC0gdyA6IG1pblg7XG4gICAgICAgICAgICBtYXhYID0geCArIHcgPiBtYXhYID8geCArIHcgOiBtYXhYO1xuXG4gICAgICAgICAgICBtaW5ZID0geSAtIGggPCBtaW5ZID8geSAtIGggOiBtaW5ZO1xuICAgICAgICAgICAgbWF4WSA9IHkgKyBoID4gbWF4WSA/IHkgKyBoIDogbWF4WTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFBPTFlcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9pbnRzLmxlbmd0aDsgais9MilcbiAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgICAgIHggPSBwb2ludHNbal07XG4gICAgICAgICAgICAgICAgeSA9IHBvaW50c1tqKzFdO1xuICAgICAgICAgICAgICAgIG1pblggPSB4LWxpbmVXaWR0aCA8IG1pblggPyB4LWxpbmVXaWR0aCA6IG1pblg7XG4gICAgICAgICAgICAgICAgbWF4WCA9IHgrbGluZVdpZHRoID4gbWF4WCA/IHgrbGluZVdpZHRoIDogbWF4WDtcblxuICAgICAgICAgICAgICAgIG1pblkgPSB5LWxpbmVXaWR0aCA8IG1pblkgPyB5LWxpbmVXaWR0aCA6IG1pblk7XG4gICAgICAgICAgICAgICAgbWF4WSA9IHkrbGluZVdpZHRoID4gbWF4WSA/IHkrbGluZVdpZHRoIDogbWF4WTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwYWRkaW5nID0gdGhpcy5ib3VuZHNQYWRkaW5nO1xuICAgIHRoaXMuYm91bmRzID0gbmV3IFBJWEkuUmVjdGFuZ2xlKG1pblggLSBwYWRkaW5nLCBtaW5ZIC0gcGFkZGluZywgKG1heFggLSBtaW5YKSArIHBhZGRpbmcgKiAyLCAobWF4WSAtIG1pblkpICsgcGFkZGluZyAqIDIpO1xufTtcblxuXG4vKipcbiAqIEdlbmVyYXRlcyB0aGUgY2FjaGVkIHNwcml0ZSB3aGVuIHRoZSBzcHJpdGUgaGFzIGNhY2hlQXNCaXRtYXAgPSB0cnVlXG4gKlxuICogQG1ldGhvZCBfZ2VuZXJhdGVDYWNoZWRTcHJpdGVcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuR3JhcGhpY3MucHJvdG90eXBlLl9nZW5lcmF0ZUNhY2hlZFNwcml0ZSA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpO1xuXG4gICAgaWYoIXRoaXMuX2NhY2hlZFNwcml0ZSlcbiAgICB7XG4gICAgICAgIHZhciBjYW52YXNCdWZmZXIgPSBuZXcgUElYSS5DYW52YXNCdWZmZXIoYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0KTtcbiAgICAgICAgdmFyIHRleHR1cmUgPSBQSVhJLlRleHR1cmUuZnJvbUNhbnZhcyhjYW52YXNCdWZmZXIuY2FudmFzKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2NhY2hlZFNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkU3ByaXRlLmJ1ZmZlciA9IGNhbnZhc0J1ZmZlcjtcblxuICAgICAgICB0aGlzLl9jYWNoZWRTcHJpdGUud29ybGRUcmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLl9jYWNoZWRTcHJpdGUuYnVmZmVyLnJlc2l6ZShib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpO1xuICAgIH1cblxuICAgIC8vIGxldmVyYWdlIHRoZSBhbmNob3IgdG8gYWNjb3VudCBmb3IgdGhlIG9mZnNldCBvZiB0aGUgZWxlbWVudFxuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5hbmNob3IueCA9IC0oIGJvdW5kcy54IC8gYm91bmRzLndpZHRoICk7XG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLmFuY2hvci55ID0gLSggYm91bmRzLnkgLyBib3VuZHMuaGVpZ2h0ICk7XG5cbiAgIC8vIHRoaXMuX2NhY2hlZFNwcml0ZS5idWZmZXIuY29udGV4dC5zYXZlKCk7XG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLmJ1ZmZlci5jb250ZXh0LnRyYW5zbGF0ZSgtYm91bmRzLngsLWJvdW5kcy55KTtcbiAgICBcbiAgICBQSVhJLkNhbnZhc0dyYXBoaWNzLnJlbmRlckdyYXBoaWNzKHRoaXMsIHRoaXMuX2NhY2hlZFNwcml0ZS5idWZmZXIuY29udGV4dCk7XG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLmFscGhhID0gdGhpcy5hbHBoYTtcblxuICAgLy8gdGhpcy5fY2FjaGVkU3ByaXRlLmJ1ZmZlci5jb250ZXh0LnJlc3RvcmUoKTtcbn07XG5cblBJWEkuR3JhcGhpY3MucHJvdG90eXBlLmRlc3Ryb3lDYWNoZWRTcHJpdGUgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLnRleHR1cmUuZGVzdHJveSh0cnVlKTtcblxuICAgIC8vIGxldCB0aGUgZ2MgY29sbGVjdCB0aGUgdW51c2VkIHNwcml0ZVxuICAgIC8vIFRPRE8gY291bGQgYmUgb2JqZWN0IHBvb2xlZCFcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUgPSBudWxsO1xufTtcblxuXG4vLyBTT01FIFRZUEVTOlxuUElYSS5HcmFwaGljcy5QT0xZID0gMDtcblBJWEkuR3JhcGhpY3MuUkVDVCA9IDE7XG5QSVhJLkdyYXBoaWNzLkNJUkMgPSAyO1xuUElYSS5HcmFwaGljcy5FTElQID0gMztcblBJWEkuR3JhcGhpY3MuUlJFQyA9IDQ7XG5cblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vXG4gKi9cblxuIC8qKlxuICogXG4gKiBAY2xhc3MgU3RyaXBcbiAqIEBleHRlbmRzIERpc3BsYXlPYmplY3RDb250YWluZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHRleHR1cmUge1RleHR1cmV9IFRoZSB0ZXh0dXJlIHRvIHVzZVxuICogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IHRoZSB3aWR0aCBcbiAqIEBwYXJhbSBoZWlnaHQge051bWJlcn0gdGhlIGhlaWdodFxuICogXG4gKi9cblBJWEkuU3RyaXAgPSBmdW5jdGlvbih0ZXh0dXJlKVxue1xuICAgIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKCB0aGlzICk7XG4gICAgXG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcblxuICAgIC8vIHNldCB1cCB0aGUgbWFpbiBiaXRzLi5cbiAgICB0aGlzLnV2cyA9IG5ldyBQSVhJLkZsb2F0MzJBcnJheShbMCwgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEsIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwxXSk7XG5cbiAgICB0aGlzLnZlcnRpY2llcyA9IG5ldyBQSVhJLkZsb2F0MzJBcnJheShbMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAxMDAsMCxcbiAgICAgICAgICAgICAgICAgICAgICAxMDAsMTAwLFxuICAgICAgICAgICAgICAgICAgICAgIDAsIDEwMF0pO1xuXG4gICAgdGhpcy5jb2xvcnMgPSBuZXcgUElYSS5GbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDFdKTtcblxuICAgIHRoaXMuaW5kaWNlcyA9IG5ldyBQSVhJLlVpbnQxNkFycmF5KFswLCAxLCAyLCAzXSk7XG4gICAgXG5cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLlN0cmlwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZSk7XG5QSVhJLlN0cmlwLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuU3RyaXA7XG5cblBJWEkuU3RyaXAucHJvdG90eXBlLl9yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uKHJlbmRlclNlc3Npb24pXG57XG4gICAgLy8gaWYgdGhlIHNwcml0ZSBpcyBub3QgdmlzaWJsZSBvciB0aGUgYWxwaGEgaXMgMCB0aGVuIG5vIG5lZWQgdG8gcmVuZGVyIHRoaXMgZWxlbWVudFxuICAgIGlmKCF0aGlzLnZpc2libGUgfHwgdGhpcy5hbHBoYSA8PSAwKXJldHVybjtcbiAgICAvLyByZW5kZXIgdHJpYW5nbGUgc3RyaXAuLlxuXG4gICAgcmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaC5zdG9wKCk7XG5cbiAgICAvLyBpbml0ISBpbml0IVxuICAgIGlmKCF0aGlzLl92ZXJ0ZXhCdWZmZXIpdGhpcy5faW5pdFdlYkdMKHJlbmRlclNlc3Npb24pO1xuICAgIFxuICAgIHJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlci5zZXRTaGFkZXIocmVuZGVyU2Vzc2lvbi5zaGFkZXJNYW5hZ2VyLnN0cmlwU2hhZGVyKTtcblxuICAgIHRoaXMuX3JlbmRlclN0cmlwKHJlbmRlclNlc3Npb24pO1xuXG4gICAgLy8vcmVuZGVyU2Vzc2lvbi5zaGFkZXJNYW5hZ2VyLmFjdGl2YXRlRGVmYXVsdFNoYWRlcigpO1xuXG4gICAgcmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaC5zdGFydCgpO1xuXG4gICAgLy9UT0RPIGNoZWNrIGN1bGxpbmcgIFxufTtcblxuUElYSS5TdHJpcC5wcm90b3R5cGUuX2luaXRXZWJHTCA9IGZ1bmN0aW9uKHJlbmRlclNlc3Npb24pXG57XG4gICAgLy8gYnVpbGQgdGhlIHN0cmlwIVxuICAgIHZhciBnbCA9IHJlbmRlclNlc3Npb24uZ2w7XG4gICAgXG4gICAgdGhpcy5fdmVydGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy5faW5kZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLl91dkJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMuX2NvbG9yQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuX3ZlcnRleEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGljaWVzLCBnbC5EWU5BTUlDX0RSQVcpO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuX3V2QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgIHRoaXMudXZzLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5fY29sb3JCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmNvbG9ycywgZ2wuU1RBVElDX0RSQVcpO1xuIFxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuX2luZGV4QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGljZXMsIGdsLlNUQVRJQ19EUkFXKTtcbn07XG5cblBJWEkuU3RyaXAucHJvdG90eXBlLl9yZW5kZXJTdHJpcCA9IGZ1bmN0aW9uKHJlbmRlclNlc3Npb24pXG57XG4gICAgdmFyIGdsID0gcmVuZGVyU2Vzc2lvbi5nbDtcbiAgICB2YXIgcHJvamVjdGlvbiA9IHJlbmRlclNlc3Npb24ucHJvamVjdGlvbixcbiAgICAgICAgb2Zmc2V0ID0gcmVuZGVyU2Vzc2lvbi5vZmZzZXQsXG4gICAgICAgIHNoYWRlciA9IHJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlci5zdHJpcFNoYWRlcjtcblxuXG4gICAgLy8gZ2wudW5pZm9ybU1hdHJpeDRmdihzaGFkZXJQcm9ncmFtLm12TWF0cml4VW5pZm9ybSwgZmFsc2UsIG1hdDRSZWFsKTtcblxuICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuXG4gICAgLy8gc2V0IHVuaWZvcm1zXG4gICAgZ2wudW5pZm9ybU1hdHJpeDNmdihzaGFkZXIudHJhbnNsYXRpb25NYXRyaXgsIGZhbHNlLCB0aGlzLndvcmxkVHJhbnNmb3JtLnRvQXJyYXkodHJ1ZSkpO1xuICAgIGdsLnVuaWZvcm0yZihzaGFkZXIucHJvamVjdGlvblZlY3RvciwgcHJvamVjdGlvbi54LCAtcHJvamVjdGlvbi55KTtcbiAgICBnbC51bmlmb3JtMmYoc2hhZGVyLm9mZnNldFZlY3RvciwgLW9mZnNldC54LCAtb2Zmc2V0LnkpO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIuYWxwaGEsIDEpO1xuXG4gICAgaWYoIXRoaXMuZGlydHkpXG4gICAge1xuICAgICAgICBcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuX3ZlcnRleEJ1ZmZlcik7XG4gICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB0aGlzLnZlcnRpY2llcyk7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFWZXJ0ZXhQb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdXZzXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLl91dkJ1ZmZlcik7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFUZXh0dXJlQ29vcmQsIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgICAgICAgICBcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgICAgICAvLyBiaW5kIHRoZSBjdXJyZW50IHRleHR1cmVcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlLmJhc2VUZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSB8fCBQSVhJLmNyZWF0ZVdlYkdMVGV4dHVyZSh0aGlzLnRleHR1cmUuYmFzZVRleHR1cmUsIGdsKSk7XG4gICAgXG4gICAgICAgIC8vIGRvbnQgbmVlZCB0byB1cGxvYWQhXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuX2luZGV4QnVmZmVyKTtcbiAgICBcbiAgICBcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcblxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLl92ZXJ0ZXhCdWZmZXIpO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0aWNpZXMsIGdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYVZlcnRleFBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgICAgICBcbiAgICAgICAgLy8gdXBkYXRlIHRoZSB1dnNcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuX3V2QnVmZmVyKTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHRoaXMudXZzLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFUZXh0dXJlQ29vcmQsIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgICAgICAgICBcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZS5iYXNlVGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0gfHwgUElYSS5jcmVhdGVXZWJHTFRleHR1cmUodGhpcy50ZXh0dXJlLmJhc2VUZXh0dXJlLCBnbCkpO1xuICAgIFxuICAgICAgICAvLyBkb250IG5lZWQgdG8gdXBsb2FkIVxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLl9pbmRleEJ1ZmZlcik7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kaWNlcywgZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICBcbiAgICB9XG4gICAgLy9jb25zb2xlLmxvZyhnbC5UUklBTkdMRV9TVFJJUClcbiAgICAvL1xuICAgIC8vXG4gICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFX1NUUklQLCB0aGlzLmluZGljZXMubGVuZ3RoLCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG4gICAgXG4gIFxufTtcblxuUElYSS5TdHJpcC5wcm90b3R5cGUuX3JlbmRlckNhbnZhcyA9IGZ1bmN0aW9uKHJlbmRlclNlc3Npb24pXG57XG4gICAgdmFyIGNvbnRleHQgPSByZW5kZXJTZXNzaW9uLmNvbnRleHQ7XG4gICAgXG4gICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMud29ybGRUcmFuc2Zvcm07XG5cbiAgICBpZiAocmVuZGVyU2Vzc2lvbi5yb3VuZFBpeGVscylcbiAgICB7XG4gICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKHRyYW5zZm9ybS5hLCB0cmFuc2Zvcm0uYywgdHJhbnNmb3JtLmIsIHRyYW5zZm9ybS5kLCB0cmFuc2Zvcm0udHggfCAwLCB0cmFuc2Zvcm0udHkgfCAwKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0odHJhbnNmb3JtLmEsIHRyYW5zZm9ybS5jLCB0cmFuc2Zvcm0uYiwgdHJhbnNmb3JtLmQsIHRyYW5zZm9ybS50eCwgdHJhbnNmb3JtLnR5KTtcbiAgICB9XG4gICAgICAgIFxuICAgIHZhciBzdHJpcCA9IHRoaXM7XG4gICAgLy8gZHJhdyB0cmlhbmdsZXMhIVxuICAgIHZhciB2ZXJ0aWNpZXMgPSBzdHJpcC52ZXJ0aWNpZXM7XG4gICAgdmFyIHV2cyA9IHN0cmlwLnV2cztcblxuICAgIHZhciBsZW5ndGggPSB2ZXJ0aWNpZXMubGVuZ3RoLzI7XG4gICAgdGhpcy5jb3VudCsrO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGgtMjsgaSsrKVxuICAgIHtcbiAgICAgICAgLy8gZHJhdyBzb21lIHRyaWFuZ2xlcyFcbiAgICAgICAgdmFyIGluZGV4ID0gaSoyO1xuXG4gICAgICAgIHZhciB4MCA9IHZlcnRpY2llc1tpbmRleF0sICAgeDEgPSB2ZXJ0aWNpZXNbaW5kZXgrMl0sIHgyID0gdmVydGljaWVzW2luZGV4KzRdO1xuICAgICAgICB2YXIgeTAgPSB2ZXJ0aWNpZXNbaW5kZXgrMV0sIHkxID0gdmVydGljaWVzW2luZGV4KzNdLCB5MiA9IHZlcnRpY2llc1tpbmRleCs1XTtcblxuICAgICAgICBpZih0cnVlKVxuICAgICAgICB7XG5cbiAgICAgICAgICAgIC8vZXhwYW5kKCk7XG4gICAgICAgICAgICB2YXIgY2VudGVyWCA9ICh4MCArIHgxICsgeDIpLzM7XG4gICAgICAgICAgICB2YXIgY2VudGVyWSA9ICh5MCArIHkxICsgeTIpLzM7XG5cbiAgICAgICAgICAgIHZhciBub3JtWCA9IHgwIC0gY2VudGVyWDtcbiAgICAgICAgICAgIHZhciBub3JtWSA9IHkwIC0gY2VudGVyWTtcblxuICAgICAgICAgICAgdmFyIGRpc3QgPSBNYXRoLnNxcnQoIG5vcm1YICogbm9ybVggKyBub3JtWSAqIG5vcm1ZICk7XG4gICAgICAgICAgICB4MCA9IGNlbnRlclggKyAobm9ybVggLyBkaXN0KSAqIChkaXN0ICsgMyk7XG4gICAgICAgICAgICB5MCA9IGNlbnRlclkgKyAobm9ybVkgLyBkaXN0KSAqIChkaXN0ICsgMyk7XG5cbiAgICAgICAgICAgIC8vIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBub3JtWCA9IHgxIC0gY2VudGVyWDtcbiAgICAgICAgICAgIG5vcm1ZID0geTEgLSBjZW50ZXJZO1xuXG4gICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KCBub3JtWCAqIG5vcm1YICsgbm9ybVkgKiBub3JtWSApO1xuICAgICAgICAgICAgeDEgPSBjZW50ZXJYICsgKG5vcm1YIC8gZGlzdCkgKiAoZGlzdCArIDMpO1xuICAgICAgICAgICAgeTEgPSBjZW50ZXJZICsgKG5vcm1ZIC8gZGlzdCkgKiAoZGlzdCArIDMpO1xuXG4gICAgICAgICAgICBub3JtWCA9IHgyIC0gY2VudGVyWDtcbiAgICAgICAgICAgIG5vcm1ZID0geTIgLSBjZW50ZXJZO1xuXG4gICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KCBub3JtWCAqIG5vcm1YICsgbm9ybVkgKiBub3JtWSApO1xuICAgICAgICAgICAgeDIgPSBjZW50ZXJYICsgKG5vcm1YIC8gZGlzdCkgKiAoZGlzdCArIDMpO1xuICAgICAgICAgICAgeTIgPSBjZW50ZXJZICsgKG5vcm1ZIC8gZGlzdCkgKiAoZGlzdCArIDMpO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdTAgPSB1dnNbaW5kZXhdICogc3RyaXAudGV4dHVyZS53aWR0aCwgICB1MSA9IHV2c1tpbmRleCsyXSAqIHN0cmlwLnRleHR1cmUud2lkdGgsIHUyID0gdXZzW2luZGV4KzRdKiBzdHJpcC50ZXh0dXJlLndpZHRoO1xuICAgICAgICB2YXIgdjAgPSB1dnNbaW5kZXgrMV0qIHN0cmlwLnRleHR1cmUuaGVpZ2h0LCB2MSA9IHV2c1tpbmRleCszXSAqIHN0cmlwLnRleHR1cmUuaGVpZ2h0LCB2MiA9IHV2c1tpbmRleCs1XSogc3RyaXAudGV4dHVyZS5oZWlnaHQ7XG5cbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cblxuICAgICAgICBjb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4MSwgeTEpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xuXG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgY29udGV4dC5jbGlwKCk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBtYXRyaXggdHJhbnNmb3JtXG4gICAgICAgIHZhciBkZWx0YSA9IHUwKnYxICsgdjAqdTIgKyB1MSp2MiAtIHYxKnUyIC0gdjAqdTEgLSB1MCp2MjtcbiAgICAgICAgdmFyIGRlbHRhQSA9IHgwKnYxICsgdjAqeDIgKyB4MSp2MiAtIHYxKngyIC0gdjAqeDEgLSB4MCp2MjtcbiAgICAgICAgdmFyIGRlbHRhQiA9IHUwKngxICsgeDAqdTIgKyB1MSp4MiAtIHgxKnUyIC0geDAqdTEgLSB1MCp4MjtcbiAgICAgICAgdmFyIGRlbHRhQyA9IHUwKnYxKngyICsgdjAqeDEqdTIgKyB4MCp1MSp2MiAtIHgwKnYxKnUyIC0gdjAqdTEqeDIgLSB1MCp4MSp2MjtcbiAgICAgICAgdmFyIGRlbHRhRCA9IHkwKnYxICsgdjAqeTIgKyB5MSp2MiAtIHYxKnkyIC0gdjAqeTEgLSB5MCp2MjtcbiAgICAgICAgdmFyIGRlbHRhRSA9IHUwKnkxICsgeTAqdTIgKyB1MSp5MiAtIHkxKnUyIC0geTAqdTEgLSB1MCp5MjtcbiAgICAgICAgdmFyIGRlbHRhRiA9IHUwKnYxKnkyICsgdjAqeTEqdTIgKyB5MCp1MSp2MiAtIHkwKnYxKnUyIC0gdjAqdTEqeTIgLSB1MCp5MSp2MjtcblxuICAgICAgICBjb250ZXh0LnRyYW5zZm9ybShkZWx0YUEgLyBkZWx0YSwgZGVsdGFEIC8gZGVsdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFCIC8gZGVsdGEsIGRlbHRhRSAvIGRlbHRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhQyAvIGRlbHRhLCBkZWx0YUYgLyBkZWx0YSk7XG5cbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2Uoc3RyaXAudGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsIDAsIDApO1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG59O1xuXG4vKlxuICogU2V0cyB0aGUgdGV4dHVyZSB0aGF0IHRoZSBTdHJpcCB3aWxsIHVzZSBcbiAqXG4gKiBAbWV0aG9kIHNldFRleHR1cmVcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfSB0aGUgdGV4dHVyZSB0aGF0IHdpbGwgYmUgdXNlZFxuICogQHByaXZhdGVcbiAqL1xuXG4vKlxuUElYSS5TdHJpcC5wcm90b3R5cGUuc2V0VGV4dHVyZSA9IGZ1bmN0aW9uKHRleHR1cmUpXG57XG4gICAgLy9UT0RPIFNFVCBUSEUgVEVYVFVSRVNcbiAgICAvL1RPRE8gVklTSUJJTElUWVxuXG4gICAgLy8gc3RvcCBjdXJyZW50IHRleHR1cmVcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgIHRoaXMud2lkdGggICA9IHRleHR1cmUuZnJhbWUud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgID0gdGV4dHVyZS5mcmFtZS5oZWlnaHQ7XG4gICAgdGhpcy51cGRhdGVGcmFtZSA9IHRydWU7XG59O1xuKi9cblxuLyoqXG4gKiBXaGVuIHRoZSB0ZXh0dXJlIGlzIHVwZGF0ZWQsIHRoaXMgZXZlbnQgd2lsbCBmaXJlIHRvIHVwZGF0ZSB0aGUgc2NhbGUgYW5kIGZyYW1lXG4gKlxuICogQG1ldGhvZCBvblRleHR1cmVVcGRhdGVcbiAqIEBwYXJhbSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuXG5QSVhJLlN0cmlwLnByb3RvdHlwZS5vblRleHR1cmVVcGRhdGUgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy51cGRhdGVGcmFtZSA9IHRydWU7XG59O1xuLyogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKiBcbiAqIEBjbGFzcyBSb3BlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfSBUaGUgdGV4dHVyZSB0byB1c2VcbiAqIEBwYXJhbSBwb2ludHMge0FycmF5fVxuICogXG4gKi9cblBJWEkuUm9wZSA9IGZ1bmN0aW9uKHRleHR1cmUsIHBvaW50cylcbntcbiAgICBQSVhJLlN0cmlwLmNhbGwoIHRoaXMsIHRleHR1cmUgKTtcbiAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcblxuICAgIHRoaXMudmVydGljaWVzID0gbmV3IFBJWEkuRmxvYXQzMkFycmF5KHBvaW50cy5sZW5ndGggKiA0KTtcbiAgICB0aGlzLnV2cyA9IG5ldyBQSVhJLkZsb2F0MzJBcnJheShwb2ludHMubGVuZ3RoICogNCk7XG4gICAgdGhpcy5jb2xvcnMgPSBuZXcgUElYSS5GbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDIpO1xuICAgIHRoaXMuaW5kaWNlcyA9IG5ldyBQSVhJLlVpbnQxNkFycmF5KHBvaW50cy5sZW5ndGggKiAyKTtcbiAgIFxuXG4gICAgdGhpcy5yZWZyZXNoKCk7XG59O1xuXG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLlJvcGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUElYSS5TdHJpcC5wcm90b3R5cGUgKTtcblBJWEkuUm9wZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLlJvcGU7XG5cbi8qXG4gKiBSZWZyZXNoZXMgXG4gKlxuICogQG1ldGhvZCByZWZyZXNoXG4gKi9cblBJWEkuUm9wZS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgaWYocG9pbnRzLmxlbmd0aCA8IDEpIHJldHVybjtcblxuICAgIHZhciB1dnMgPSB0aGlzLnV2cztcblxuICAgIHZhciBsYXN0UG9pbnQgPSBwb2ludHNbMF07XG4gICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG4gICAgdmFyIGNvbG9ycyA9IHRoaXMuY29sb3JzO1xuXG4gICAgdGhpcy5jb3VudC09MC4yO1xuXG4gICAgdXZzWzBdID0gMDtcbiAgICB1dnNbMV0gPSAwO1xuICAgIHV2c1syXSA9IDA7XG4gICAgdXZzWzNdID0gMTtcblxuICAgIGNvbG9yc1swXSA9IDE7XG4gICAgY29sb3JzWzFdID0gMTtcblxuICAgIGluZGljZXNbMF0gPSAwO1xuICAgIGluZGljZXNbMV0gPSAxO1xuXG4gICAgdmFyIHRvdGFsID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgcG9pbnQsIGluZGV4LCBhbW91bnQ7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRvdGFsOyBpKyspXG4gICAge1xuICAgICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgaW5kZXggPSBpICogNDtcbiAgICAgICAgLy8gdGltZSB0byBkbyBzb21lIHNtYXJ0IGRyYXdpbmchXG4gICAgICAgIGFtb3VudCA9IGkgLyAodG90YWwtMSk7XG5cbiAgICAgICAgaWYoaSUyKVxuICAgICAgICB7XG4gICAgICAgICAgICB1dnNbaW5kZXhdID0gYW1vdW50O1xuICAgICAgICAgICAgdXZzW2luZGV4KzFdID0gMDtcblxuICAgICAgICAgICAgdXZzW2luZGV4KzJdID0gYW1vdW50O1xuICAgICAgICAgICAgdXZzW2luZGV4KzNdID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHV2c1tpbmRleF0gPSBhbW91bnQ7XG4gICAgICAgICAgICB1dnNbaW5kZXgrMV0gPSAwO1xuXG4gICAgICAgICAgICB1dnNbaW5kZXgrMl0gPSBhbW91bnQ7XG4gICAgICAgICAgICB1dnNbaW5kZXgrM10gPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXggPSBpICogMjtcbiAgICAgICAgY29sb3JzW2luZGV4XSA9IDE7XG4gICAgICAgIGNvbG9yc1tpbmRleCsxXSA9IDE7XG5cbiAgICAgICAgaW5kZXggPSBpICogMjtcbiAgICAgICAgaW5kaWNlc1tpbmRleF0gPSBpbmRleDtcbiAgICAgICAgaW5kaWNlc1tpbmRleCArIDFdID0gaW5kZXggKyAxO1xuXG4gICAgICAgIGxhc3RQb2ludCA9IHBvaW50O1xuICAgIH1cbn07XG5cbi8qXG4gKiBVcGRhdGVzIHRoZSBvYmplY3QgdHJhbnNmb3JtIGZvciByZW5kZXJpbmdcbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVRyYW5zZm9ybVxuICogQHByaXZhdGVcbiAqL1xuUElYSS5Sb3BlLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbigpXG57XG5cbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgaWYocG9pbnRzLmxlbmd0aCA8IDEpcmV0dXJuO1xuXG4gICAgdmFyIGxhc3RQb2ludCA9IHBvaW50c1swXTtcbiAgICB2YXIgbmV4dFBvaW50O1xuICAgIHZhciBwZXJwID0ge3g6MCwgeTowfTtcblxuICAgIHRoaXMuY291bnQtPTAuMjtcblxuICAgIHZhciB2ZXJ0aWNpZXMgPSB0aGlzLnZlcnRpY2llcztcbiAgICB2YXIgdG90YWwgPSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBwb2ludCwgaW5kZXgsIHJhdGlvLCBwZXJwTGVuZ3RoLCBudW07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsOyBpKyspXG4gICAge1xuICAgICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgaW5kZXggPSBpICogNDtcblxuICAgICAgICBpZihpIDwgcG9pbnRzLmxlbmd0aC0xKVxuICAgICAgICB7XG4gICAgICAgICAgICBuZXh0UG9pbnQgPSBwb2ludHNbaSsxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5leHRQb2ludCA9IHBvaW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcGVycC55ID0gLShuZXh0UG9pbnQueCAtIGxhc3RQb2ludC54KTtcbiAgICAgICAgcGVycC54ID0gbmV4dFBvaW50LnkgLSBsYXN0UG9pbnQueTtcblxuICAgICAgICByYXRpbyA9ICgxIC0gKGkgLyAodG90YWwtMSkpKSAqIDEwO1xuXG4gICAgICAgIGlmKHJhdGlvID4gMSkgcmF0aW8gPSAxO1xuXG4gICAgICAgIHBlcnBMZW5ndGggPSBNYXRoLnNxcnQocGVycC54ICogcGVycC54ICsgcGVycC55ICogcGVycC55KTtcbiAgICAgICAgbnVtID0gdGhpcy50ZXh0dXJlLmhlaWdodCAvIDI7IC8vKDIwICsgTWF0aC5hYnMoTWF0aC5zaW4oKGkgKyB0aGlzLmNvdW50KSAqIDAuMykgKiA1MCkgKSogcmF0aW87XG4gICAgICAgIHBlcnAueCAvPSBwZXJwTGVuZ3RoO1xuICAgICAgICBwZXJwLnkgLz0gcGVycExlbmd0aDtcblxuICAgICAgICBwZXJwLnggKj0gbnVtO1xuICAgICAgICBwZXJwLnkgKj0gbnVtO1xuXG4gICAgICAgIHZlcnRpY2llc1tpbmRleF0gPSBwb2ludC54ICsgcGVycC54O1xuICAgICAgICB2ZXJ0aWNpZXNbaW5kZXgrMV0gPSBwb2ludC55ICsgcGVycC55O1xuICAgICAgICB2ZXJ0aWNpZXNbaW5kZXgrMl0gPSBwb2ludC54IC0gcGVycC54O1xuICAgICAgICB2ZXJ0aWNpZXNbaW5kZXgrM10gPSBwb2ludC55IC0gcGVycC55O1xuXG4gICAgICAgIGxhc3RQb2ludCA9IHBvaW50O1xuICAgIH1cblxuICAgIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtLmNhbGwoIHRoaXMgKTtcbn07XG4vKlxuICogU2V0cyB0aGUgdGV4dHVyZSB0aGF0IHRoZSBSb3BlIHdpbGwgdXNlIFxuICpcbiAqIEBtZXRob2Qgc2V0VGV4dHVyZVxuICogQHBhcmFtIHRleHR1cmUge1RleHR1cmV9IHRoZSB0ZXh0dXJlIHRoYXQgd2lsbCBiZSB1c2VkXG4gKi9cblBJWEkuUm9wZS5wcm90b3R5cGUuc2V0VGV4dHVyZSA9IGZ1bmN0aW9uKHRleHR1cmUpXG57XG4gICAgLy8gc3RvcCBjdXJyZW50IHRleHR1cmVcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgIC8vdGhpcy51cGRhdGVGcmFtZSA9IHRydWU7XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS9cbiAqL1xuXG4vKipcbiAqIEEgdGlsaW5nIHNwcml0ZSBpcyBhIGZhc3Qgd2F5IG9mIHJlbmRlcmluZyBhIHRpbGluZyBpbWFnZVxuICpcbiAqIEBjbGFzcyBUaWxpbmdTcHJpdGVcbiAqIEBleHRlbmRzIFNwcml0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gdGV4dHVyZSB7VGV4dHVyZX0gdGhlIHRleHR1cmUgb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAqIEBwYXJhbSB3aWR0aCB7TnVtYmVyfSAgdGhlIHdpZHRoIG9mIHRoZSB0aWxpbmcgc3ByaXRlXG4gKiBAcGFyYW0gaGVpZ2h0IHtOdW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAqL1xuUElYSS5UaWxpbmdTcHJpdGUgPSBmdW5jdGlvbih0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0KVxue1xuICAgIFBJWEkuU3ByaXRlLmNhbGwoIHRoaXMsIHRleHR1cmUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdpdGggb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB3aWR0aFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuX3dpZHRoID0gd2lkdGggfHwgMTAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgdGlsaW5nIHNwcml0ZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGhlaWdodFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodCB8fCAxMDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NhbGluZyBvZiB0aGUgaW1hZ2UgdGhhdCBpcyBiZWluZyB0aWxlZFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRpbGVTY2FsZVxuICAgICAqIEB0eXBlIFBvaW50XG4gICAgICovXG4gICAgdGhpcy50aWxlU2NhbGUgPSBuZXcgUElYSS5Qb2ludCgxLDEpO1xuXG4gICAgLyoqXG4gICAgICogQSBwb2ludCB0aGF0IHJlcHJlc2VudHMgdGhlIHNjYWxlIG9mIHRoZSB0ZXh0dXJlIG9iamVjdFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRpbGVTY2FsZU9mZnNldFxuICAgICAqIEB0eXBlIFBvaW50XG4gICAgICovXG4gICAgdGhpcy50aWxlU2NhbGVPZmZzZXQgPSBuZXcgUElYSS5Qb2ludCgxLDEpO1xuICAgIFxuICAgIC8qKlxuICAgICAqIFRoZSBvZmZzZXQgcG9zaXRpb24gb2YgdGhlIGltYWdlIHRoYXQgaXMgYmVpbmcgdGlsZWRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0aWxlUG9zaXRpb25cbiAgICAgKiBAdHlwZSBQb2ludFxuICAgICAqL1xuICAgIHRoaXMudGlsZVBvc2l0aW9uID0gbmV3IFBJWEkuUG9pbnQoMCwwKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBzcHJpdGUgaXMgcmVuZGVyYWJsZSBvciBub3RcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXJhYmxlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmFibGUgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpbnQgYXBwbGllZCB0byB0aGUgc3ByaXRlLiBUaGlzIGlzIGEgaGV4IHZhbHVlXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdGludFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDB4RkZGRkZGXG4gICAgICovXG4gICAgdGhpcy50aW50ID0gMHhGRkZGRkY7XG4gICAgXG4gICAgLyoqXG4gICAgICogVGhlIGJsZW5kIG1vZGUgdG8gYmUgYXBwbGllZCB0byB0aGUgc3ByaXRlXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYmxlbmRNb2RlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgUElYSS5ibGVuZE1vZGVzLk5PUk1BTDtcbiAgICAgKi9cbiAgICB0aGlzLmJsZW5kTW9kZSA9IFBJWEkuYmxlbmRNb2Rlcy5OT1JNQUw7XG5cbiAgICBcblxufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuVGlsaW5nU3ByaXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUElYSS5TcHJpdGUucHJvdG90eXBlKTtcblBJWEkuVGlsaW5nU3ByaXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuVGlsaW5nU3ByaXRlO1xuXG5cbi8qKlxuICogVGhlIHdpZHRoIG9mIHRoZSBzcHJpdGUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gKlxuICogQHByb3BlcnR5IHdpZHRoXG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuVGlsaW5nU3ByaXRlLnByb3RvdHlwZSwgJ3dpZHRoJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogVGhlIGhlaWdodCBvZiB0aGUgVGlsaW5nU3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxuICpcbiAqIEBwcm9wZXJ0eSBoZWlnaHRcbiAqIEB0eXBlIE51bWJlclxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5UaWxpbmdTcHJpdGUucHJvdG90eXBlLCAnaGVpZ2h0Jywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAgdGhpcy5faGVpZ2h0O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuUElYSS5UaWxpbmdTcHJpdGUucHJvdG90eXBlLnNldFRleHR1cmUgPSBmdW5jdGlvbih0ZXh0dXJlKVxue1xuICAgIGlmICh0aGlzLnRleHR1cmUgPT09IHRleHR1cmUpIHJldHVybjtcblxuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG5cbiAgICB0aGlzLnJlZnJlc2hUZXh0dXJlID0gdHJ1ZTtcblxuICAgIHRoaXMuY2FjaGVkVGludCA9IDB4RkZGRkZGO1xufTtcblxuLyoqXG4qIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbipcbiogQG1ldGhvZCBfcmVuZGVyV2ViR0xcbiogQHBhcmFtIHJlbmRlclNlc3Npb24ge1JlbmRlclNlc3Npb259IFxuKiBAcHJpdmF0ZVxuKi9cblBJWEkuVGlsaW5nU3ByaXRlLnByb3RvdHlwZS5fcmVuZGVyV2ViR0wgPSBmdW5jdGlvbihyZW5kZXJTZXNzaW9uKVxue1xuICAgIGlmICh0aGlzLnZpc2libGUgPT09IGZhbHNlIHx8IHRoaXMuYWxwaGEgPT09IDApIHJldHVybjtcbiAgICB2YXIgaSxqO1xuXG4gICAgaWYgKHRoaXMuX21hc2spXG4gICAge1xuICAgICAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLnN0b3AoKTtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5tYXNrTWFuYWdlci5wdXNoTWFzayh0aGlzLm1hc2ssIHJlbmRlclNlc3Npb24pO1xuICAgICAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLnN0YXJ0KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ZpbHRlcnMpXG4gICAge1xuICAgICAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLmZsdXNoKCk7XG4gICAgICAgIHJlbmRlclNlc3Npb24uZmlsdGVyTWFuYWdlci5wdXNoRmlsdGVyKHRoaXMuX2ZpbHRlckJsb2NrKTtcbiAgICB9XG5cbiAgIFxuXG4gICAgaWYgKCF0aGlzLnRpbGluZ1RleHR1cmUgfHwgdGhpcy5yZWZyZXNoVGV4dHVyZSlcbiAgICB7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVUaWxpbmdUZXh0dXJlKHRydWUpO1xuXG4gICAgICAgIGlmICh0aGlzLnRpbGluZ1RleHR1cmUgJiYgdGhpcy50aWxpbmdUZXh0dXJlLm5lZWRzVXBkYXRlKVxuICAgICAgICB7XG4gICAgICAgICAgICAvL1RPRE8gLSB0d2Vha2luZ1xuICAgICAgICAgICAgUElYSS51cGRhdGVXZWJHTFRleHR1cmUodGhpcy50aWxpbmdUZXh0dXJlLmJhc2VUZXh0dXJlLCByZW5kZXJTZXNzaW9uLmdsKTtcbiAgICAgICAgICAgIHRoaXMudGlsaW5nVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAvLyB0aGlzLnRpbGluZ1RleHR1cmUuX3V2cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaC5yZW5kZXJUaWxpbmdTcHJpdGUodGhpcyk7XG4gICAgfVxuICAgIC8vIHNpbXBsZSByZW5kZXIgY2hpbGRyZW4hXG4gICAgZm9yIChpPTAsaj10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxqOyBpKyspXG4gICAge1xuICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLl9yZW5kZXJXZWJHTChyZW5kZXJTZXNzaW9uKTtcbiAgICB9XG5cbiAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLnN0b3AoKTtcblxuICAgIGlmICh0aGlzLl9maWx0ZXJzKSByZW5kZXJTZXNzaW9uLmZpbHRlck1hbmFnZXIucG9wRmlsdGVyKCk7XG4gICAgaWYgKHRoaXMuX21hc2spIHJlbmRlclNlc3Npb24ubWFza01hbmFnZXIucG9wTWFzayhyZW5kZXJTZXNzaW9uKTtcbiAgICBcbiAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLnN0YXJ0KCk7XG59O1xuXG4vKipcbiogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbipcbiogQG1ldGhvZCBfcmVuZGVyQ2FudmFzXG4qIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtSZW5kZXJTZXNzaW9ufSBcbiogQHByaXZhdGVcbiovXG5QSVhJLlRpbGluZ1Nwcml0ZS5wcm90b3R5cGUuX3JlbmRlckNhbnZhcyA9IGZ1bmN0aW9uKHJlbmRlclNlc3Npb24pXG57XG4gICAgaWYgKHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgfHwgdGhpcy5hbHBoYSA9PT0gMClyZXR1cm47XG4gICAgXG4gICAgdmFyIGNvbnRleHQgPSByZW5kZXJTZXNzaW9uLmNvbnRleHQ7XG5cbiAgICBpZiAodGhpcy5fbWFzaylcbiAgICB7XG4gICAgICAgIHJlbmRlclNlc3Npb24ubWFza01hbmFnZXIucHVzaE1hc2sodGhpcy5fbWFzaywgY29udGV4dCk7XG4gICAgfVxuXG4gICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IHRoaXMud29ybGRBbHBoYTtcbiAgICBcbiAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcblxuICAgIHZhciBpLGo7XG5cbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybSh0cmFuc2Zvcm0uYSwgdHJhbnNmb3JtLmMsIHRyYW5zZm9ybS5iLCB0cmFuc2Zvcm0uZCwgdHJhbnNmb3JtLnR4ICwgdHJhbnNmb3JtLnR5KTtcblxuICAgIGlmICghdGhpcy5fX3RpbGVQYXR0ZXJuIHx8ICB0aGlzLnJlZnJlc2hUZXh0dXJlKVxuICAgIHtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZVRpbGluZ1RleHR1cmUoZmFsc2UpO1xuICAgIFxuICAgICAgICBpZiAodGhpcy50aWxpbmdUZXh0dXJlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9fdGlsZVBhdHRlcm4gPSBjb250ZXh0LmNyZWF0ZVBhdHRlcm4odGhpcy50aWxpbmdUZXh0dXJlLmJhc2VUZXh0dXJlLnNvdXJjZSwgJ3JlcGVhdCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgYmxlbmQgbW9kZVxuICAgIGlmICh0aGlzLmJsZW5kTW9kZSAhPT0gcmVuZGVyU2Vzc2lvbi5jdXJyZW50QmxlbmRNb2RlKVxuICAgIHtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5jdXJyZW50QmxlbmRNb2RlID0gdGhpcy5ibGVuZE1vZGU7XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gUElYSS5ibGVuZE1vZGVzQ2FudmFzW3JlbmRlclNlc3Npb24uY3VycmVudEJsZW5kTW9kZV07XG4gICAgfVxuXG4gICAgdmFyIHRpbGVQb3NpdGlvbiA9IHRoaXMudGlsZVBvc2l0aW9uO1xuICAgIHZhciB0aWxlU2NhbGUgPSB0aGlzLnRpbGVTY2FsZTtcblxuICAgIHRpbGVQb3NpdGlvbi54ICU9IHRoaXMudGlsaW5nVGV4dHVyZS5iYXNlVGV4dHVyZS53aWR0aDtcbiAgICB0aWxlUG9zaXRpb24ueSAlPSB0aGlzLnRpbGluZ1RleHR1cmUuYmFzZVRleHR1cmUuaGVpZ2h0O1xuXG4gICAgLy8gb2Zmc2V0XG4gICAgY29udGV4dC5zY2FsZSh0aWxlU2NhbGUueCx0aWxlU2NhbGUueSk7XG4gICAgY29udGV4dC50cmFuc2xhdGUodGlsZVBvc2l0aW9uLngsIHRpbGVQb3NpdGlvbi55KTtcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5fX3RpbGVQYXR0ZXJuO1xuXG4gICAgLy8gbWFrZSBzdXJlIHRvIGFjY291bnQgZm9yIHRoZSBhbmNob3IgcG9pbnQuLlxuICAgIGNvbnRleHQuZmlsbFJlY3QoLXRpbGVQb3NpdGlvbi54ICsgKHRoaXMuYW5jaG9yLnggKiAtdGhpcy5fd2lkdGgpLFxuICAgICAgICAgICAgICAgICAgICAtdGlsZVBvc2l0aW9uLnkgKyAodGhpcy5hbmNob3IueSAqIC10aGlzLl9oZWlnaHQpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl93aWR0aCAvIHRpbGVTY2FsZS54LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oZWlnaHQgLyB0aWxlU2NhbGUueSk7XG5cbiAgICBjb250ZXh0LnNjYWxlKDEgLyB0aWxlU2NhbGUueCwgMSAvIHRpbGVTY2FsZS55KTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtdGlsZVBvc2l0aW9uLngsIC10aWxlUG9zaXRpb24ueSk7XG5cbiAgICBpZiAodGhpcy5fbWFzaylcbiAgICB7XG4gICAgICAgIHJlbmRlclNlc3Npb24ubWFza01hbmFnZXIucG9wTWFzayhyZW5kZXJTZXNzaW9uLmNvbnRleHQpO1xuICAgIH1cblxuICAgIGZvciAoaT0wLGo9dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGk8ajsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5fcmVuZGVyQ2FudmFzKHJlbmRlclNlc3Npb24pO1xuICAgIH1cbn07XG5cblxuLyoqXG4qIFJldHVybnMgdGhlIGZyYW1pbmcgcmVjdGFuZ2xlIG9mIHRoZSBzcHJpdGUgYXMgYSBQSVhJLlJlY3RhbmdsZSBvYmplY3RcbipcbiogQG1ldGhvZCBnZXRCb3VuZHNcbiogQHJldHVybiB7UmVjdGFuZ2xlfSB0aGUgZnJhbWluZyByZWN0YW5nbGVcbiovXG5QSVhJLlRpbGluZ1Nwcml0ZS5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciB3aWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG5cbiAgICB2YXIgdzAgPSB3aWR0aCAqICgxLXRoaXMuYW5jaG9yLngpO1xuICAgIHZhciB3MSA9IHdpZHRoICogLXRoaXMuYW5jaG9yLng7XG5cbiAgICB2YXIgaDAgPSBoZWlnaHQgKiAoMS10aGlzLmFuY2hvci55KTtcbiAgICB2YXIgaDEgPSBoZWlnaHQgKiAtdGhpcy5hbmNob3IueTtcblxuICAgIHZhciB3b3JsZFRyYW5zZm9ybSA9IHRoaXMud29ybGRUcmFuc2Zvcm07XG5cbiAgICB2YXIgYSA9IHdvcmxkVHJhbnNmb3JtLmE7XG4gICAgdmFyIGIgPSB3b3JsZFRyYW5zZm9ybS5jO1xuICAgIHZhciBjID0gd29ybGRUcmFuc2Zvcm0uYjtcbiAgICB2YXIgZCA9IHdvcmxkVHJhbnNmb3JtLmQ7XG4gICAgdmFyIHR4ID0gd29ybGRUcmFuc2Zvcm0udHg7XG4gICAgdmFyIHR5ID0gd29ybGRUcmFuc2Zvcm0udHk7XG4gICAgXG4gICAgdmFyIHgxID0gYSAqIHcxICsgYyAqIGgxICsgdHg7XG4gICAgdmFyIHkxID0gZCAqIGgxICsgYiAqIHcxICsgdHk7XG5cbiAgICB2YXIgeDIgPSBhICogdzAgKyBjICogaDEgKyB0eDtcbiAgICB2YXIgeTIgPSBkICogaDEgKyBiICogdzAgKyB0eTtcblxuICAgIHZhciB4MyA9IGEgKiB3MCArIGMgKiBoMCArIHR4O1xuICAgIHZhciB5MyA9IGQgKiBoMCArIGIgKiB3MCArIHR5O1xuXG4gICAgdmFyIHg0ID0gIGEgKiB3MSArIGMgKiBoMCArIHR4O1xuICAgIHZhciB5NCA9ICBkICogaDAgKyBiICogdzEgKyB0eTtcblxuICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xuICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xuXG4gICAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgICB2YXIgbWluWSA9IEluZmluaXR5O1xuXG4gICAgbWluWCA9IHgxIDwgbWluWCA/IHgxIDogbWluWDtcbiAgICBtaW5YID0geDIgPCBtaW5YID8geDIgOiBtaW5YO1xuICAgIG1pblggPSB4MyA8IG1pblggPyB4MyA6IG1pblg7XG4gICAgbWluWCA9IHg0IDwgbWluWCA/IHg0IDogbWluWDtcblxuICAgIG1pblkgPSB5MSA8IG1pblkgPyB5MSA6IG1pblk7XG4gICAgbWluWSA9IHkyIDwgbWluWSA/IHkyIDogbWluWTtcbiAgICBtaW5ZID0geTMgPCBtaW5ZID8geTMgOiBtaW5ZO1xuICAgIG1pblkgPSB5NCA8IG1pblkgPyB5NCA6IG1pblk7XG5cbiAgICBtYXhYID0geDEgPiBtYXhYID8geDEgOiBtYXhYO1xuICAgIG1heFggPSB4MiA+IG1heFggPyB4MiA6IG1heFg7XG4gICAgbWF4WCA9IHgzID4gbWF4WCA/IHgzIDogbWF4WDtcbiAgICBtYXhYID0geDQgPiBtYXhYID8geDQgOiBtYXhYO1xuXG4gICAgbWF4WSA9IHkxID4gbWF4WSA/IHkxIDogbWF4WTtcbiAgICBtYXhZID0geTIgPiBtYXhZID8geTIgOiBtYXhZO1xuICAgIG1heFkgPSB5MyA+IG1heFkgPyB5MyA6IG1heFk7XG4gICAgbWF4WSA9IHk0ID4gbWF4WSA/IHk0IDogbWF4WTtcblxuICAgIHZhciBib3VuZHMgPSB0aGlzLl9ib3VuZHM7XG5cbiAgICBib3VuZHMueCA9IG1pblg7XG4gICAgYm91bmRzLndpZHRoID0gbWF4WCAtIG1pblg7XG5cbiAgICBib3VuZHMueSA9IG1pblk7XG4gICAgYm91bmRzLmhlaWdodCA9IG1heFkgLSBtaW5ZO1xuXG4gICAgLy8gc3RvcmUgYSByZWZlcmVuY2Ugc28gdGhhdCBpZiB0aGlzIGZ1bmN0aW9uIGdldHMgY2FsbGVkIGFnYWluIGluIHRoZSByZW5kZXIgY3ljbGUgd2UgZG8gbm90IGhhdmUgdG8gcmVjYWxjdWxhdGVcbiAgICB0aGlzLl9jdXJyZW50Qm91bmRzID0gYm91bmRzO1xuXG4gICAgcmV0dXJuIGJvdW5kcztcbn07XG5cblxuXG4vKipcbiAqIFdoZW4gdGhlIHRleHR1cmUgaXMgdXBkYXRlZCwgdGhpcyBldmVudCB3aWxsIGZpcmUgdG8gdXBkYXRlIHRoZSBzY2FsZSBhbmQgZnJhbWVcbiAqXG4gKiBAbWV0aG9kIG9uVGV4dHVyZVVwZGF0ZVxuICogQHBhcmFtIGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlRpbGluZ1Nwcml0ZS5wcm90b3R5cGUub25UZXh0dXJlVXBkYXRlID0gZnVuY3Rpb24oKVxue1xuICAgLy8gb3ZlcnJpZGluZyB0aGUgc3ByaXRlIHZlcnNpb24gb2YgdGhpcyFcbn07XG5cblxuLyoqXG4qIFxuKiBAbWV0aG9kIGdlbmVyYXRlVGlsaW5nVGV4dHVyZVxuKiBcbiogQHBhcmFtIGZvcmNlUG93ZXJPZlR3byB7Qm9vbGVhbn0gV2hldGhlciB3ZSB3YW50IHRvIGZvcmNlIHRoZSB0ZXh0dXJlIHRvIGJlIGEgcG93ZXIgb2YgdHdvXG4qL1xuUElYSS5UaWxpbmdTcHJpdGUucHJvdG90eXBlLmdlbmVyYXRlVGlsaW5nVGV4dHVyZSA9IGZ1bmN0aW9uKGZvcmNlUG93ZXJPZlR3bylcbntcbiAgICBpZiAoIXRoaXMudGV4dHVyZS5iYXNlVGV4dHVyZS5oYXNMb2FkZWQpIHJldHVybjtcblxuICAgIHZhciB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuICAgIHZhciBmcmFtZSA9IHRleHR1cmUuZnJhbWU7XG4gICAgdmFyIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQ7XG5cbiAgICAvLyAgQ2hlY2sgdGhhdCB0aGUgZnJhbWUgaXMgdGhlIHNhbWUgc2l6ZSBhcyB0aGUgYmFzZSB0ZXh0dXJlLlxuICAgIHZhciBpc0ZyYW1lID0gZnJhbWUud2lkdGggIT09IHRleHR1cmUuYmFzZVRleHR1cmUud2lkdGggfHwgZnJhbWUuaGVpZ2h0ICE9PSB0ZXh0dXJlLmJhc2VUZXh0dXJlLmhlaWdodDtcblxuICAgIHZhciBuZXdUZXh0dXJlUmVxdWlyZWQgPSBmYWxzZTtcblxuICAgIGlmICghZm9yY2VQb3dlck9mVHdvKVxuICAgIHtcbiAgICAgICAgaWYgKGlzRnJhbWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRhcmdldFdpZHRoID0gZnJhbWUud2lkdGg7XG4gICAgICAgICAgICB0YXJnZXRIZWlnaHQgPSBmcmFtZS5oZWlnaHQ7XG4gICAgICAgICAgIFxuICAgICAgICAgICAgbmV3VGV4dHVyZVJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0YXJnZXRXaWR0aCA9IFBJWEkuZ2V0TmV4dFBvd2VyT2ZUd28oZnJhbWUud2lkdGgpO1xuICAgICAgICB0YXJnZXRIZWlnaHQgPSBQSVhJLmdldE5leHRQb3dlck9mVHdvKGZyYW1lLmhlaWdodCk7XG5cbiAgICAgICAgaWYgKGZyYW1lLndpZHRoICE9PSB0YXJnZXRXaWR0aCB8fCBmcmFtZS5oZWlnaHQgIT09IHRhcmdldEhlaWdodCkgbmV3VGV4dHVyZVJlcXVpcmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobmV3VGV4dHVyZVJlcXVpcmVkKVxuICAgIHtcbiAgICAgICAgdmFyIGNhbnZhc0J1ZmZlcjtcblxuICAgICAgICBpZiAodGhpcy50aWxpbmdUZXh0dXJlICYmIHRoaXMudGlsaW5nVGV4dHVyZS5pc1RpbGluZylcbiAgICAgICAge1xuICAgICAgICAgICAgY2FudmFzQnVmZmVyID0gdGhpcy50aWxpbmdUZXh0dXJlLmNhbnZhc0J1ZmZlcjtcbiAgICAgICAgICAgIGNhbnZhc0J1ZmZlci5yZXNpemUodGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLnRpbGluZ1RleHR1cmUuYmFzZVRleHR1cmUud2lkdGggPSB0YXJnZXRXaWR0aDtcbiAgICAgICAgICAgIHRoaXMudGlsaW5nVGV4dHVyZS5iYXNlVGV4dHVyZS5oZWlnaHQgPSB0YXJnZXRIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLnRpbGluZ1RleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgY2FudmFzQnVmZmVyID0gbmV3IFBJWEkuQ2FudmFzQnVmZmVyKHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQpO1xuXG4gICAgICAgICAgICB0aGlzLnRpbGluZ1RleHR1cmUgPSBQSVhJLlRleHR1cmUuZnJvbUNhbnZhcyhjYW52YXNCdWZmZXIuY2FudmFzKTtcbiAgICAgICAgICAgIHRoaXMudGlsaW5nVGV4dHVyZS5jYW52YXNCdWZmZXIgPSBjYW52YXNCdWZmZXI7XG4gICAgICAgICAgICB0aGlzLnRpbGluZ1RleHR1cmUuaXNUaWxpbmcgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FudmFzQnVmZmVyLmNvbnRleHQuZHJhd0ltYWdlKHRleHR1cmUuYmFzZVRleHR1cmUuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUuY3JvcC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUuY3JvcC55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUuY3JvcC53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmNyb3AuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRIZWlnaHQpO1xuXG4gICAgICAgIHRoaXMudGlsZVNjYWxlT2Zmc2V0LnggPSBmcmFtZS53aWR0aCAvIHRhcmdldFdpZHRoO1xuICAgICAgICB0aGlzLnRpbGVTY2FsZU9mZnNldC55ID0gZnJhbWUuaGVpZ2h0IC8gdGFyZ2V0SGVpZ2h0O1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICAvLyAgVE9ETyAtIHN3aXRjaGluZz9cbiAgICAgICAgaWYgKHRoaXMudGlsaW5nVGV4dHVyZSAmJiB0aGlzLnRpbGluZ1RleHR1cmUuaXNUaWxpbmcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGRlc3Ryb3kgdGhlIHRpbGluZyB0ZXh0dXJlIVxuICAgICAgICAgICAgLy8gVE9ETyBjb3VsZCBzdG9yZSB0aGlzIHNvbWV3aGVyZT9cbiAgICAgICAgICAgIHRoaXMudGlsaW5nVGV4dHVyZS5kZXN0cm95KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50aWxlU2NhbGVPZmZzZXQueCA9IDE7XG4gICAgICAgIHRoaXMudGlsZVNjYWxlT2Zmc2V0LnkgPSAxO1xuICAgICAgICB0aGlzLnRpbGluZ1RleHR1cmUgPSB0ZXh0dXJlO1xuICAgIH1cblxuICAgIHRoaXMucmVmcmVzaFRleHR1cmUgPSBmYWxzZTtcbiAgICB0aGlzLnRpbGluZ1RleHR1cmUuYmFzZVRleHR1cmUuX3Bvd2VyT2YyID0gdHJ1ZTtcbn07XG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICogYmFzZWQgb24gcGl4aSBpbXBhY3Qgc3BpbmUgaW1wbGVtZW50YXRpb24gbWFkZSBieSBFZW1lbGkgS2Vsb2tvcnBpIChAZWtlbG9rb3JwaSkgaHR0cHM6Ly9naXRodWIuY29tL2VrZWxva29ycGlcbiAqXG4gKiBBd2Vzb21lIEpTIHJ1biB0aW1lIHByb3ZpZGVkIGJ5IEVzb3RlcmljU29mdHdhcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc290ZXJpY1NvZnR3YXJlL3NwaW5lLXJ1bnRpbWVzXG4gKlxuICovXG5cbi8qXG4gKiBBd2Vzb21lIEpTIHJ1biB0aW1lIHByb3ZpZGVkIGJ5IEVzb3RlcmljU29mdHdhcmVcbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vRXNvdGVyaWNTb2Z0d2FyZS9zcGluZS1ydW50aW1lc1xuICpcbiAqL1xuXG5cblxudmFyIHNwaW5lID0ge307XG5cbnNwaW5lLkJvbmVEYXRhID0gZnVuY3Rpb24gKG5hbWUsIHBhcmVudCkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG59O1xuc3BpbmUuQm9uZURhdGEucHJvdG90eXBlID0ge1xuICAgIGxlbmd0aDogMCxcbiAgICB4OiAwLCB5OiAwLFxuICAgIHJvdGF0aW9uOiAwLFxuICAgIHNjYWxlWDogMSwgc2NhbGVZOiAxXG59O1xuXG5zcGluZS5TbG90RGF0YSA9IGZ1bmN0aW9uIChuYW1lLCBib25lRGF0YSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5ib25lRGF0YSA9IGJvbmVEYXRhO1xufTtcbnNwaW5lLlNsb3REYXRhLnByb3RvdHlwZSA9IHtcbiAgICByOiAxLCBnOiAxLCBiOiAxLCBhOiAxLFxuICAgIGF0dGFjaG1lbnROYW1lOiBudWxsXG59O1xuXG5zcGluZS5Cb25lID0gZnVuY3Rpb24gKGJvbmVEYXRhLCBwYXJlbnQpIHtcbiAgICB0aGlzLmRhdGEgPSBib25lRGF0YTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnNldFRvU2V0dXBQb3NlKCk7XG59O1xuc3BpbmUuQm9uZS55RG93biA9IGZhbHNlO1xuc3BpbmUuQm9uZS5wcm90b3R5cGUgPSB7XG4gICAgeDogMCwgeTogMCxcbiAgICByb3RhdGlvbjogMCxcbiAgICBzY2FsZVg6IDEsIHNjYWxlWTogMSxcbiAgICBtMDA6IDAsIG0wMTogMCwgd29ybGRYOiAwLCAvLyBhIGIgeFxuICAgIG0xMDogMCwgbTExOiAwLCB3b3JsZFk6IDAsIC8vIGMgZCB5XG4gICAgd29ybGRSb3RhdGlvbjogMCxcbiAgICB3b3JsZFNjYWxlWDogMSwgd29ybGRTY2FsZVk6IDEsXG4gICAgdXBkYXRlV29ybGRUcmFuc2Zvcm06IGZ1bmN0aW9uIChmbGlwWCwgZmxpcFkpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMud29ybGRYID0gdGhpcy54ICogcGFyZW50Lm0wMCArIHRoaXMueSAqIHBhcmVudC5tMDEgKyBwYXJlbnQud29ybGRYO1xuICAgICAgICAgICAgdGhpcy53b3JsZFkgPSB0aGlzLnggKiBwYXJlbnQubTEwICsgdGhpcy55ICogcGFyZW50Lm0xMSArIHBhcmVudC53b3JsZFk7XG4gICAgICAgICAgICB0aGlzLndvcmxkU2NhbGVYID0gcGFyZW50LndvcmxkU2NhbGVYICogdGhpcy5zY2FsZVg7XG4gICAgICAgICAgICB0aGlzLndvcmxkU2NhbGVZID0gcGFyZW50LndvcmxkU2NhbGVZICogdGhpcy5zY2FsZVk7XG4gICAgICAgICAgICB0aGlzLndvcmxkUm90YXRpb24gPSBwYXJlbnQud29ybGRSb3RhdGlvbiArIHRoaXMucm90YXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndvcmxkWCA9IHRoaXMueDtcbiAgICAgICAgICAgIHRoaXMud29ybGRZID0gdGhpcy55O1xuICAgICAgICAgICAgdGhpcy53b3JsZFNjYWxlWCA9IHRoaXMuc2NhbGVYO1xuICAgICAgICAgICAgdGhpcy53b3JsZFNjYWxlWSA9IHRoaXMuc2NhbGVZO1xuICAgICAgICAgICAgdGhpcy53b3JsZFJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFkaWFucyA9IHRoaXMud29ybGRSb3RhdGlvbiAqIE1hdGguUEkgLyAxODA7XG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhyYWRpYW5zKTtcbiAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKHJhZGlhbnMpO1xuICAgICAgICB0aGlzLm0wMCA9IGNvcyAqIHRoaXMud29ybGRTY2FsZVg7XG4gICAgICAgIHRoaXMubTEwID0gc2luICogdGhpcy53b3JsZFNjYWxlWDtcbiAgICAgICAgdGhpcy5tMDEgPSAtc2luICogdGhpcy53b3JsZFNjYWxlWTtcbiAgICAgICAgdGhpcy5tMTEgPSBjb3MgKiB0aGlzLndvcmxkU2NhbGVZO1xuICAgICAgICBpZiAoZmxpcFgpIHtcbiAgICAgICAgICAgIHRoaXMubTAwID0gLXRoaXMubTAwO1xuICAgICAgICAgICAgdGhpcy5tMDEgPSAtdGhpcy5tMDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsaXBZKSB7XG4gICAgICAgICAgICB0aGlzLm0xMCA9IC10aGlzLm0xMDtcbiAgICAgICAgICAgIHRoaXMubTExID0gLXRoaXMubTExO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzcGluZS5Cb25lLnlEb3duKSB7XG4gICAgICAgICAgICB0aGlzLm0xMCA9IC10aGlzLm0xMDtcbiAgICAgICAgICAgIHRoaXMubTExID0gLXRoaXMubTExO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzZXRUb1NldHVwUG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgdGhpcy54ID0gZGF0YS54O1xuICAgICAgICB0aGlzLnkgPSBkYXRhLnk7XG4gICAgICAgIHRoaXMucm90YXRpb24gPSBkYXRhLnJvdGF0aW9uO1xuICAgICAgICB0aGlzLnNjYWxlWCA9IGRhdGEuc2NhbGVYO1xuICAgICAgICB0aGlzLnNjYWxlWSA9IGRhdGEuc2NhbGVZO1xuICAgIH1cbn07XG5cbnNwaW5lLlNsb3QgPSBmdW5jdGlvbiAoc2xvdERhdGEsIHNrZWxldG9uLCBib25lKSB7XG4gICAgdGhpcy5kYXRhID0gc2xvdERhdGE7XG4gICAgdGhpcy5za2VsZXRvbiA9IHNrZWxldG9uO1xuICAgIHRoaXMuYm9uZSA9IGJvbmU7XG4gICAgdGhpcy5zZXRUb1NldHVwUG9zZSgpO1xufTtcbnNwaW5lLlNsb3QucHJvdG90eXBlID0ge1xuICAgIHI6IDEsIGc6IDEsIGI6IDEsIGE6IDEsXG4gICAgX2F0dGFjaG1lbnRUaW1lOiAwLFxuICAgIGF0dGFjaG1lbnQ6IG51bGwsXG4gICAgc2V0QXR0YWNobWVudDogZnVuY3Rpb24gKGF0dGFjaG1lbnQpIHtcbiAgICAgICAgdGhpcy5hdHRhY2htZW50ID0gYXR0YWNobWVudDtcbiAgICAgICAgdGhpcy5fYXR0YWNobWVudFRpbWUgPSB0aGlzLnNrZWxldG9uLnRpbWU7XG4gICAgfSxcbiAgICBzZXRBdHRhY2htZW50VGltZTogZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgdGhpcy5fYXR0YWNobWVudFRpbWUgPSB0aGlzLnNrZWxldG9uLnRpbWUgLSB0aW1lO1xuICAgIH0sXG4gICAgZ2V0QXR0YWNobWVudFRpbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2tlbGV0b24udGltZSAtIHRoaXMuX2F0dGFjaG1lbnRUaW1lO1xuICAgIH0sXG4gICAgc2V0VG9TZXR1cFBvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIHRoaXMuciA9IGRhdGEucjtcbiAgICAgICAgdGhpcy5nID0gZGF0YS5nO1xuICAgICAgICB0aGlzLmIgPSBkYXRhLmI7XG4gICAgICAgIHRoaXMuYSA9IGRhdGEuYTtcblxuICAgICAgICB2YXIgc2xvdERhdGFzID0gdGhpcy5za2VsZXRvbi5kYXRhLnNsb3RzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNsb3REYXRhcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzbG90RGF0YXNbaV0gPT0gZGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0YWNobWVudCghZGF0YS5hdHRhY2htZW50TmFtZSA/IG51bGwgOiB0aGlzLnNrZWxldG9uLmdldEF0dGFjaG1lbnRCeVNsb3RJbmRleChpLCBkYXRhLmF0dGFjaG1lbnROYW1lKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5zcGluZS5Ta2luID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuYXR0YWNobWVudHMgPSB7fTtcbn07XG5zcGluZS5Ta2luLnByb3RvdHlwZSA9IHtcbiAgICBhZGRBdHRhY2htZW50OiBmdW5jdGlvbiAoc2xvdEluZGV4LCBuYW1lLCBhdHRhY2htZW50KSB7XG4gICAgICAgIHRoaXMuYXR0YWNobWVudHNbc2xvdEluZGV4ICsgXCI6XCIgKyBuYW1lXSA9IGF0dGFjaG1lbnQ7XG4gICAgfSxcbiAgICBnZXRBdHRhY2htZW50OiBmdW5jdGlvbiAoc2xvdEluZGV4LCBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dGFjaG1lbnRzW3Nsb3RJbmRleCArIFwiOlwiICsgbmFtZV07XG4gICAgfSxcbiAgICBfYXR0YWNoQWxsOiBmdW5jdGlvbiAoc2tlbGV0b24sIG9sZFNraW4pIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9sZFNraW4uYXR0YWNobWVudHMpIHtcbiAgICAgICAgICAgIHZhciBjb2xvbiA9IGtleS5pbmRleE9mKFwiOlwiKTtcbiAgICAgICAgICAgIHZhciBzbG90SW5kZXggPSBwYXJzZUludChrZXkuc3Vic3RyaW5nKDAsIGNvbG9uKSwgMTApO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBrZXkuc3Vic3RyaW5nKGNvbG9uICsgMSk7XG4gICAgICAgICAgICB2YXIgc2xvdCA9IHNrZWxldG9uLnNsb3RzW3Nsb3RJbmRleF07XG4gICAgICAgICAgICBpZiAoc2xvdC5hdHRhY2htZW50ICYmIHNsb3QuYXR0YWNobWVudC5uYW1lID09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0YWNobWVudCA9IHRoaXMuZ2V0QXR0YWNobWVudChzbG90SW5kZXgsIG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50KSBzbG90LnNldEF0dGFjaG1lbnQoYXR0YWNobWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5zcGluZS5BbmltYXRpb24gPSBmdW5jdGlvbiAobmFtZSwgdGltZWxpbmVzLCBkdXJhdGlvbikge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy50aW1lbGluZXMgPSB0aW1lbGluZXM7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xufTtcbnNwaW5lLkFuaW1hdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgYXBwbHk6IGZ1bmN0aW9uIChza2VsZXRvbiwgdGltZSwgbG9vcCkge1xuICAgICAgICBpZiAobG9vcCAmJiB0aGlzLmR1cmF0aW9uKSB0aW1lICU9IHRoaXMuZHVyYXRpb247XG4gICAgICAgIHZhciB0aW1lbGluZXMgPSB0aGlzLnRpbWVsaW5lcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aW1lbGluZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAgdGltZWxpbmVzW2ldLmFwcGx5KHNrZWxldG9uLCB0aW1lLCAxKTtcbiAgICB9LFxuICAgIG1peDogZnVuY3Rpb24gKHNrZWxldG9uLCB0aW1lLCBsb29wLCBhbHBoYSkge1xuICAgICAgICBpZiAobG9vcCAmJiB0aGlzLmR1cmF0aW9uKSB0aW1lICU9IHRoaXMuZHVyYXRpb247XG4gICAgICAgIHZhciB0aW1lbGluZXMgPSB0aGlzLnRpbWVsaW5lcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aW1lbGluZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAgdGltZWxpbmVzW2ldLmFwcGx5KHNrZWxldG9uLCB0aW1lLCBhbHBoYSk7XG4gICAgfVxufTtcblxuc3BpbmUuYmluYXJ5U2VhcmNoID0gZnVuY3Rpb24gKHZhbHVlcywgdGFyZ2V0LCBzdGVwKSB7XG4gICAgdmFyIGxvdyA9IDA7XG4gICAgdmFyIGhpZ2ggPSBNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGggLyBzdGVwKSAtIDI7XG4gICAgaWYgKCFoaWdoKSByZXR1cm4gc3RlcDtcbiAgICB2YXIgY3VycmVudCA9IGhpZ2ggPj4+IDE7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKHZhbHVlc1soY3VycmVudCArIDEpICogc3RlcF0gPD0gdGFyZ2V0KVxuICAgICAgICAgICAgbG93ID0gY3VycmVudCArIDE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGhpZ2ggPSBjdXJyZW50O1xuICAgICAgICBpZiAobG93ID09IGhpZ2gpIHJldHVybiAobG93ICsgMSkgKiBzdGVwO1xuICAgICAgICBjdXJyZW50ID0gKGxvdyArIGhpZ2gpID4+PiAxO1xuICAgIH1cbn07XG5zcGluZS5saW5lYXJTZWFyY2ggPSBmdW5jdGlvbiAodmFsdWVzLCB0YXJnZXQsIHN0ZXApIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGFzdCA9IHZhbHVlcy5sZW5ndGggLSBzdGVwOyBpIDw9IGxhc3Q7IGkgKz0gc3RlcClcbiAgICAgICAgaWYgKHZhbHVlc1tpXSA+IHRhcmdldCkgcmV0dXJuIGk7XG4gICAgcmV0dXJuIC0xO1xufTtcblxuc3BpbmUuQ3VydmVzID0gZnVuY3Rpb24gKGZyYW1lQ291bnQpIHtcbiAgICB0aGlzLmN1cnZlcyA9IFtdOyAvLyBkZngsIGRmeSwgZGRmeCwgZGRmeSwgZGRkZngsIGRkZGZ5LCAuLi5cbiAgICB0aGlzLmN1cnZlcy5sZW5ndGggPSAoZnJhbWVDb3VudCAtIDEpICogNjtcbn07XG5zcGluZS5DdXJ2ZXMucHJvdG90eXBlID0ge1xuICAgIHNldExpbmVhcjogZnVuY3Rpb24gKGZyYW1lSW5kZXgpIHtcbiAgICAgICAgdGhpcy5jdXJ2ZXNbZnJhbWVJbmRleCAqIDZdID0gMC8qTElORUFSKi87XG4gICAgfSxcbiAgICBzZXRTdGVwcGVkOiBmdW5jdGlvbiAoZnJhbWVJbmRleCkge1xuICAgICAgICB0aGlzLmN1cnZlc1tmcmFtZUluZGV4ICogNl0gPSAtMS8qU1RFUFBFRCovO1xuICAgIH0sXG4gICAgLyoqIFNldHMgdGhlIGNvbnRyb2wgaGFuZGxlIHBvc2l0aW9ucyBmb3IgYW4gaW50ZXJwb2xhdGlvbiBiZXppZXIgY3VydmUgdXNlZCB0byB0cmFuc2l0aW9uIGZyb20gdGhpcyBrZXlmcmFtZSB0byB0aGUgbmV4dC5cbiAgICAgKiBjeDEgYW5kIGN4MiBhcmUgZnJvbSAwIHRvIDEsIHJlcHJlc2VudGluZyB0aGUgcGVyY2VudCBvZiB0aW1lIGJldHdlZW4gdGhlIHR3byBrZXlmcmFtZXMuIGN5MSBhbmQgY3kyIGFyZSB0aGUgcGVyY2VudCBvZlxuICAgICAqIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGtleWZyYW1lJ3MgdmFsdWVzLiAqL1xuICAgIHNldEN1cnZlOiBmdW5jdGlvbiAoZnJhbWVJbmRleCwgY3gxLCBjeTEsIGN4MiwgY3kyKSB7XG4gICAgICAgIHZhciBzdWJkaXZfc3RlcCA9IDEgLyAxMC8qQkVaSUVSX1NFR01FTlRTKi87XG4gICAgICAgIHZhciBzdWJkaXZfc3RlcDIgPSBzdWJkaXZfc3RlcCAqIHN1YmRpdl9zdGVwO1xuICAgICAgICB2YXIgc3ViZGl2X3N0ZXAzID0gc3ViZGl2X3N0ZXAyICogc3ViZGl2X3N0ZXA7XG4gICAgICAgIHZhciBwcmUxID0gMyAqIHN1YmRpdl9zdGVwO1xuICAgICAgICB2YXIgcHJlMiA9IDMgKiBzdWJkaXZfc3RlcDI7XG4gICAgICAgIHZhciBwcmU0ID0gNiAqIHN1YmRpdl9zdGVwMjtcbiAgICAgICAgdmFyIHByZTUgPSA2ICogc3ViZGl2X3N0ZXAzO1xuICAgICAgICB2YXIgdG1wMXggPSAtY3gxICogMiArIGN4MjtcbiAgICAgICAgdmFyIHRtcDF5ID0gLWN5MSAqIDIgKyBjeTI7XG4gICAgICAgIHZhciB0bXAyeCA9IChjeDEgLSBjeDIpICogMyArIDE7XG4gICAgICAgIHZhciB0bXAyeSA9IChjeTEgLSBjeTIpICogMyArIDE7XG4gICAgICAgIHZhciBpID0gZnJhbWVJbmRleCAqIDY7XG4gICAgICAgIHZhciBjdXJ2ZXMgPSB0aGlzLmN1cnZlcztcbiAgICAgICAgY3VydmVzW2ldID0gY3gxICogcHJlMSArIHRtcDF4ICogcHJlMiArIHRtcDJ4ICogc3ViZGl2X3N0ZXAzO1xuICAgICAgICBjdXJ2ZXNbaSArIDFdID0gY3kxICogcHJlMSArIHRtcDF5ICogcHJlMiArIHRtcDJ5ICogc3ViZGl2X3N0ZXAzO1xuICAgICAgICBjdXJ2ZXNbaSArIDJdID0gdG1wMXggKiBwcmU0ICsgdG1wMnggKiBwcmU1O1xuICAgICAgICBjdXJ2ZXNbaSArIDNdID0gdG1wMXkgKiBwcmU0ICsgdG1wMnkgKiBwcmU1O1xuICAgICAgICBjdXJ2ZXNbaSArIDRdID0gdG1wMnggKiBwcmU1O1xuICAgICAgICBjdXJ2ZXNbaSArIDVdID0gdG1wMnkgKiBwcmU1O1xuICAgIH0sXG4gICAgZ2V0Q3VydmVQZXJjZW50OiBmdW5jdGlvbiAoZnJhbWVJbmRleCwgcGVyY2VudCkge1xuICAgICAgICBwZXJjZW50ID0gcGVyY2VudCA8IDAgPyAwIDogKHBlcmNlbnQgPiAxID8gMSA6IHBlcmNlbnQpO1xuICAgICAgICB2YXIgY3VydmVJbmRleCA9IGZyYW1lSW5kZXggKiA2O1xuICAgICAgICB2YXIgY3VydmVzID0gdGhpcy5jdXJ2ZXM7XG4gICAgICAgIHZhciBkZnggPSBjdXJ2ZXNbY3VydmVJbmRleF07XG4gICAgICAgIGlmICghZGZ4LypMSU5FQVIqLykgcmV0dXJuIHBlcmNlbnQ7XG4gICAgICAgIGlmIChkZnggPT0gLTEvKlNURVBQRUQqLykgcmV0dXJuIDA7XG4gICAgICAgIHZhciBkZnkgPSBjdXJ2ZXNbY3VydmVJbmRleCArIDFdO1xuICAgICAgICB2YXIgZGRmeCA9IGN1cnZlc1tjdXJ2ZUluZGV4ICsgMl07XG4gICAgICAgIHZhciBkZGZ5ID0gY3VydmVzW2N1cnZlSW5kZXggKyAzXTtcbiAgICAgICAgdmFyIGRkZGZ4ID0gY3VydmVzW2N1cnZlSW5kZXggKyA0XTtcbiAgICAgICAgdmFyIGRkZGZ5ID0gY3VydmVzW2N1cnZlSW5kZXggKyA1XTtcbiAgICAgICAgdmFyIHggPSBkZngsIHkgPSBkZnk7XG4gICAgICAgIHZhciBpID0gMTAvKkJFWklFUl9TRUdNRU5UUyovIC0gMjtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmICh4ID49IHBlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFggPSB4IC0gZGZ4O1xuICAgICAgICAgICAgICAgIHZhciBsYXN0WSA9IHkgLSBkZnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhc3RZICsgKHkgLSBsYXN0WSkgKiAocGVyY2VudCAtIGxhc3RYKSAvICh4IC0gbGFzdFgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpKSBicmVhaztcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIGRmeCArPSBkZGZ4O1xuICAgICAgICAgICAgZGZ5ICs9IGRkZnk7XG4gICAgICAgICAgICBkZGZ4ICs9IGRkZGZ4O1xuICAgICAgICAgICAgZGRmeSArPSBkZGRmeTtcbiAgICAgICAgICAgIHggKz0gZGZ4O1xuICAgICAgICAgICAgeSArPSBkZnk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHkgKyAoMSAtIHkpICogKHBlcmNlbnQgLSB4KSAvICgxIC0geCk7IC8vIExhc3QgcG9pbnQgaXMgMSwxLlxuICAgIH1cbn07XG5cbnNwaW5lLlJvdGF0ZVRpbWVsaW5lID0gZnVuY3Rpb24gKGZyYW1lQ291bnQpIHtcbiAgICB0aGlzLmN1cnZlcyA9IG5ldyBzcGluZS5DdXJ2ZXMoZnJhbWVDb3VudCk7XG4gICAgdGhpcy5mcmFtZXMgPSBbXTsgLy8gdGltZSwgYW5nbGUsIC4uLlxuICAgIHRoaXMuZnJhbWVzLmxlbmd0aCA9IGZyYW1lQ291bnQgKiAyO1xufTtcbnNwaW5lLlJvdGF0ZVRpbWVsaW5lLnByb3RvdHlwZSA9IHtcbiAgICBib25lSW5kZXg6IDAsXG4gICAgZ2V0RnJhbWVDb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFtZXMubGVuZ3RoIC8gMjtcbiAgICB9LFxuICAgIHNldEZyYW1lOiBmdW5jdGlvbiAoZnJhbWVJbmRleCwgdGltZSwgYW5nbGUpIHtcbiAgICAgICAgZnJhbWVJbmRleCAqPSAyO1xuICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4XSA9IHRpbWU7XG4gICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyAxXSA9IGFuZ2xlO1xuICAgIH0sXG4gICAgYXBwbHk6IGZ1bmN0aW9uIChza2VsZXRvbiwgdGltZSwgYWxwaGEpIHtcbiAgICAgICAgdmFyIGZyYW1lcyA9IHRoaXMuZnJhbWVzLFxuICAgICAgICAgICAgYW1vdW50O1xuXG4gICAgICAgIGlmICh0aW1lIDwgZnJhbWVzWzBdKSByZXR1cm47IC8vIFRpbWUgaXMgYmVmb3JlIGZpcnN0IGZyYW1lLlxuXG4gICAgICAgIHZhciBib25lID0gc2tlbGV0b24uYm9uZXNbdGhpcy5ib25lSW5kZXhdO1xuXG4gICAgICAgIGlmICh0aW1lID49IGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gMl0pIHsgLy8gVGltZSBpcyBhZnRlciBsYXN0IGZyYW1lLlxuICAgICAgICAgICAgYW1vdW50ID0gYm9uZS5kYXRhLnJvdGF0aW9uICsgZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSAxXSAtIGJvbmUucm90YXRpb247XG4gICAgICAgICAgICB3aGlsZSAoYW1vdW50ID4gMTgwKVxuICAgICAgICAgICAgICAgIGFtb3VudCAtPSAzNjA7XG4gICAgICAgICAgICB3aGlsZSAoYW1vdW50IDwgLTE4MClcbiAgICAgICAgICAgICAgICBhbW91bnQgKz0gMzYwO1xuICAgICAgICAgICAgYm9uZS5yb3RhdGlvbiArPSBhbW91bnQgKiBhbHBoYTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEludGVycG9sYXRlIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IGZyYW1lLlxuICAgICAgICB2YXIgZnJhbWVJbmRleCA9IHNwaW5lLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUsIDIpO1xuICAgICAgICB2YXIgbGFzdEZyYW1lVmFsdWUgPSBmcmFtZXNbZnJhbWVJbmRleCAtIDFdO1xuICAgICAgICB2YXIgZnJhbWVUaW1lID0gZnJhbWVzW2ZyYW1lSW5kZXhdO1xuICAgICAgICB2YXIgcGVyY2VudCA9IDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lSW5kZXggLSAyLypMQVNUX0ZSQU1FX1RJTUUqL10gLSBmcmFtZVRpbWUpO1xuICAgICAgICBwZXJjZW50ID0gdGhpcy5jdXJ2ZXMuZ2V0Q3VydmVQZXJjZW50KGZyYW1lSW5kZXggLyAyIC0gMSwgcGVyY2VudCk7XG5cbiAgICAgICAgYW1vdW50ID0gZnJhbWVzW2ZyYW1lSW5kZXggKyAxLypGUkFNRV9WQUxVRSovXSAtIGxhc3RGcmFtZVZhbHVlO1xuICAgICAgICB3aGlsZSAoYW1vdW50ID4gMTgwKVxuICAgICAgICAgICAgYW1vdW50IC09IDM2MDtcbiAgICAgICAgd2hpbGUgKGFtb3VudCA8IC0xODApXG4gICAgICAgICAgICBhbW91bnQgKz0gMzYwO1xuICAgICAgICBhbW91bnQgPSBib25lLmRhdGEucm90YXRpb24gKyAobGFzdEZyYW1lVmFsdWUgKyBhbW91bnQgKiBwZXJjZW50KSAtIGJvbmUucm90YXRpb247XG4gICAgICAgIHdoaWxlIChhbW91bnQgPiAxODApXG4gICAgICAgICAgICBhbW91bnQgLT0gMzYwO1xuICAgICAgICB3aGlsZSAoYW1vdW50IDwgLTE4MClcbiAgICAgICAgICAgIGFtb3VudCArPSAzNjA7XG4gICAgICAgIGJvbmUucm90YXRpb24gKz0gYW1vdW50ICogYWxwaGE7XG4gICAgfVxufTtcblxuc3BpbmUuVHJhbnNsYXRlVGltZWxpbmUgPSBmdW5jdGlvbiAoZnJhbWVDb3VudCkge1xuICAgIHRoaXMuY3VydmVzID0gbmV3IHNwaW5lLkN1cnZlcyhmcmFtZUNvdW50KTtcbiAgICB0aGlzLmZyYW1lcyA9IFtdOyAvLyB0aW1lLCB4LCB5LCAuLi5cbiAgICB0aGlzLmZyYW1lcy5sZW5ndGggPSBmcmFtZUNvdW50ICogMztcbn07XG5zcGluZS5UcmFuc2xhdGVUaW1lbGluZS5wcm90b3R5cGUgPSB7XG4gICAgYm9uZUluZGV4OiAwLFxuICAgIGdldEZyYW1lQ291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhbWVzLmxlbmd0aCAvIDM7XG4gICAgfSxcbiAgICBzZXRGcmFtZTogZnVuY3Rpb24gKGZyYW1lSW5kZXgsIHRpbWUsIHgsIHkpIHtcbiAgICAgICAgZnJhbWVJbmRleCAqPSAzO1xuICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4XSA9IHRpbWU7XG4gICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyAxXSA9IHg7XG4gICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyAyXSA9IHk7XG4gICAgfSxcbiAgICBhcHBseTogZnVuY3Rpb24gKHNrZWxldG9uLCB0aW1lLCBhbHBoYSkge1xuICAgICAgICB2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXM7XG4gICAgICAgIGlmICh0aW1lIDwgZnJhbWVzWzBdKSByZXR1cm47IC8vIFRpbWUgaXMgYmVmb3JlIGZpcnN0IGZyYW1lLlxuXG4gICAgICAgIHZhciBib25lID0gc2tlbGV0b24uYm9uZXNbdGhpcy5ib25lSW5kZXhdO1xuXG4gICAgICAgIGlmICh0aW1lID49IGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gM10pIHsgLy8gVGltZSBpcyBhZnRlciBsYXN0IGZyYW1lLlxuICAgICAgICAgICAgYm9uZS54ICs9IChib25lLmRhdGEueCArIGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gMl0gLSBib25lLngpICogYWxwaGE7XG4gICAgICAgICAgICBib25lLnkgKz0gKGJvbmUuZGF0YS55ICsgZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSAxXSAtIGJvbmUueSkgKiBhbHBoYTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEludGVycG9sYXRlIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IGZyYW1lLlxuICAgICAgICB2YXIgZnJhbWVJbmRleCA9IHNwaW5lLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUsIDMpO1xuICAgICAgICB2YXIgbGFzdEZyYW1lWCA9IGZyYW1lc1tmcmFtZUluZGV4IC0gMl07XG4gICAgICAgIHZhciBsYXN0RnJhbWVZID0gZnJhbWVzW2ZyYW1lSW5kZXggLSAxXTtcbiAgICAgICAgdmFyIGZyYW1lVGltZSA9IGZyYW1lc1tmcmFtZUluZGV4XTtcbiAgICAgICAgdmFyIHBlcmNlbnQgPSAxIC0gKHRpbWUgLSBmcmFtZVRpbWUpIC8gKGZyYW1lc1tmcmFtZUluZGV4ICsgLTMvKkxBU1RfRlJBTUVfVElNRSovXSAtIGZyYW1lVGltZSk7XG4gICAgICAgIHBlcmNlbnQgPSB0aGlzLmN1cnZlcy5nZXRDdXJ2ZVBlcmNlbnQoZnJhbWVJbmRleCAvIDMgLSAxLCBwZXJjZW50KTtcblxuICAgICAgICBib25lLnggKz0gKGJvbmUuZGF0YS54ICsgbGFzdEZyYW1lWCArIChmcmFtZXNbZnJhbWVJbmRleCArIDEvKkZSQU1FX1gqL10gLSBsYXN0RnJhbWVYKSAqIHBlcmNlbnQgLSBib25lLngpICogYWxwaGE7XG4gICAgICAgIGJvbmUueSArPSAoYm9uZS5kYXRhLnkgKyBsYXN0RnJhbWVZICsgKGZyYW1lc1tmcmFtZUluZGV4ICsgMi8qRlJBTUVfWSovXSAtIGxhc3RGcmFtZVkpICogcGVyY2VudCAtIGJvbmUueSkgKiBhbHBoYTtcbiAgICB9XG59O1xuXG5zcGluZS5TY2FsZVRpbWVsaW5lID0gZnVuY3Rpb24gKGZyYW1lQ291bnQpIHtcbiAgICB0aGlzLmN1cnZlcyA9IG5ldyBzcGluZS5DdXJ2ZXMoZnJhbWVDb3VudCk7XG4gICAgdGhpcy5mcmFtZXMgPSBbXTsgLy8gdGltZSwgeCwgeSwgLi4uXG4gICAgdGhpcy5mcmFtZXMubGVuZ3RoID0gZnJhbWVDb3VudCAqIDM7XG59O1xuc3BpbmUuU2NhbGVUaW1lbGluZS5wcm90b3R5cGUgPSB7XG4gICAgYm9uZUluZGV4OiAwLFxuICAgIGdldEZyYW1lQ291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhbWVzLmxlbmd0aCAvIDM7XG4gICAgfSxcbiAgICBzZXRGcmFtZTogZnVuY3Rpb24gKGZyYW1lSW5kZXgsIHRpbWUsIHgsIHkpIHtcbiAgICAgICAgZnJhbWVJbmRleCAqPSAzO1xuICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4XSA9IHRpbWU7XG4gICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyAxXSA9IHg7XG4gICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyAyXSA9IHk7XG4gICAgfSxcbiAgICBhcHBseTogZnVuY3Rpb24gKHNrZWxldG9uLCB0aW1lLCBhbHBoYSkge1xuICAgICAgICB2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXM7XG4gICAgICAgIGlmICh0aW1lIDwgZnJhbWVzWzBdKSByZXR1cm47IC8vIFRpbWUgaXMgYmVmb3JlIGZpcnN0IGZyYW1lLlxuXG4gICAgICAgIHZhciBib25lID0gc2tlbGV0b24uYm9uZXNbdGhpcy5ib25lSW5kZXhdO1xuXG4gICAgICAgIGlmICh0aW1lID49IGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gM10pIHsgLy8gVGltZSBpcyBhZnRlciBsYXN0IGZyYW1lLlxuICAgICAgICAgICAgYm9uZS5zY2FsZVggKz0gKGJvbmUuZGF0YS5zY2FsZVggLSAxICsgZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSAyXSAtIGJvbmUuc2NhbGVYKSAqIGFscGhhO1xuICAgICAgICAgICAgYm9uZS5zY2FsZVkgKz0gKGJvbmUuZGF0YS5zY2FsZVkgLSAxICsgZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSAxXSAtIGJvbmUuc2NhbGVZKSAqIGFscGhhO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW50ZXJwb2xhdGUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgZnJhbWUuXG4gICAgICAgIHZhciBmcmFtZUluZGV4ID0gc3BpbmUuYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSwgMyk7XG4gICAgICAgIHZhciBsYXN0RnJhbWVYID0gZnJhbWVzW2ZyYW1lSW5kZXggLSAyXTtcbiAgICAgICAgdmFyIGxhc3RGcmFtZVkgPSBmcmFtZXNbZnJhbWVJbmRleCAtIDFdO1xuICAgICAgICB2YXIgZnJhbWVUaW1lID0gZnJhbWVzW2ZyYW1lSW5kZXhdO1xuICAgICAgICB2YXIgcGVyY2VudCA9IDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lSW5kZXggKyAtMy8qTEFTVF9GUkFNRV9USU1FKi9dIC0gZnJhbWVUaW1lKTtcbiAgICAgICAgcGVyY2VudCA9IHRoaXMuY3VydmVzLmdldEN1cnZlUGVyY2VudChmcmFtZUluZGV4IC8gMyAtIDEsIHBlcmNlbnQpO1xuXG4gICAgICAgIGJvbmUuc2NhbGVYICs9IChib25lLmRhdGEuc2NhbGVYIC0gMSArIGxhc3RGcmFtZVggKyAoZnJhbWVzW2ZyYW1lSW5kZXggKyAxLypGUkFNRV9YKi9dIC0gbGFzdEZyYW1lWCkgKiBwZXJjZW50IC0gYm9uZS5zY2FsZVgpICogYWxwaGE7XG4gICAgICAgIGJvbmUuc2NhbGVZICs9IChib25lLmRhdGEuc2NhbGVZIC0gMSArIGxhc3RGcmFtZVkgKyAoZnJhbWVzW2ZyYW1lSW5kZXggKyAyLypGUkFNRV9ZKi9dIC0gbGFzdEZyYW1lWSkgKiBwZXJjZW50IC0gYm9uZS5zY2FsZVkpICogYWxwaGE7XG4gICAgfVxufTtcblxuc3BpbmUuQ29sb3JUaW1lbGluZSA9IGZ1bmN0aW9uIChmcmFtZUNvdW50KSB7XG4gICAgdGhpcy5jdXJ2ZXMgPSBuZXcgc3BpbmUuQ3VydmVzKGZyYW1lQ291bnQpO1xuICAgIHRoaXMuZnJhbWVzID0gW107IC8vIHRpbWUsIHIsIGcsIGIsIGEsIC4uLlxuICAgIHRoaXMuZnJhbWVzLmxlbmd0aCA9IGZyYW1lQ291bnQgKiA1O1xufTtcbnNwaW5lLkNvbG9yVGltZWxpbmUucHJvdG90eXBlID0ge1xuICAgIHNsb3RJbmRleDogMCxcbiAgICBnZXRGcmFtZUNvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYW1lcy5sZW5ndGggLyA1O1xuICAgIH0sXG4gICAgc2V0RnJhbWU6IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCByLCBnLCBiLCBhKSB7XG4gICAgICAgIGZyYW1lSW5kZXggKj0gNTtcbiAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleF0gPSB0aW1lO1xuICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgMV0gPSByO1xuICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgMl0gPSBnO1xuICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgM10gPSBiO1xuICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgNF0gPSBhO1xuICAgIH0sXG4gICAgYXBwbHk6IGZ1bmN0aW9uIChza2VsZXRvbiwgdGltZSwgYWxwaGEpIHtcbiAgICAgICAgdmFyIGZyYW1lcyA9IHRoaXMuZnJhbWVzO1xuICAgICAgICBpZiAodGltZSA8IGZyYW1lc1swXSkgcmV0dXJuOyAvLyBUaW1lIGlzIGJlZm9yZSBmaXJzdCBmcmFtZS5cblxuICAgICAgICB2YXIgc2xvdCA9IHNrZWxldG9uLnNsb3RzW3RoaXMuc2xvdEluZGV4XTtcblxuICAgICAgICBpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDVdKSB7IC8vIFRpbWUgaXMgYWZ0ZXIgbGFzdCBmcmFtZS5cbiAgICAgICAgICAgIHZhciBpID0gZnJhbWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBzbG90LnIgPSBmcmFtZXNbaSAtIDNdO1xuICAgICAgICAgICAgc2xvdC5nID0gZnJhbWVzW2kgLSAyXTtcbiAgICAgICAgICAgIHNsb3QuYiA9IGZyYW1lc1tpIC0gMV07XG4gICAgICAgICAgICBzbG90LmEgPSBmcmFtZXNbaV07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnRlcnBvbGF0ZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBmcmFtZS5cbiAgICAgICAgdmFyIGZyYW1lSW5kZXggPSBzcGluZS5iaW5hcnlTZWFyY2goZnJhbWVzLCB0aW1lLCA1KTtcbiAgICAgICAgdmFyIGxhc3RGcmFtZVIgPSBmcmFtZXNbZnJhbWVJbmRleCAtIDRdO1xuICAgICAgICB2YXIgbGFzdEZyYW1lRyA9IGZyYW1lc1tmcmFtZUluZGV4IC0gM107XG4gICAgICAgIHZhciBsYXN0RnJhbWVCID0gZnJhbWVzW2ZyYW1lSW5kZXggLSAyXTtcbiAgICAgICAgdmFyIGxhc3RGcmFtZUEgPSBmcmFtZXNbZnJhbWVJbmRleCAtIDFdO1xuICAgICAgICB2YXIgZnJhbWVUaW1lID0gZnJhbWVzW2ZyYW1lSW5kZXhdO1xuICAgICAgICB2YXIgcGVyY2VudCA9IDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lSW5kZXggLSA1LypMQVNUX0ZSQU1FX1RJTUUqL10gLSBmcmFtZVRpbWUpO1xuICAgICAgICBwZXJjZW50ID0gdGhpcy5jdXJ2ZXMuZ2V0Q3VydmVQZXJjZW50KGZyYW1lSW5kZXggLyA1IC0gMSwgcGVyY2VudCk7XG5cbiAgICAgICAgdmFyIHIgPSBsYXN0RnJhbWVSICsgKGZyYW1lc1tmcmFtZUluZGV4ICsgMS8qRlJBTUVfUiovXSAtIGxhc3RGcmFtZVIpICogcGVyY2VudDtcbiAgICAgICAgdmFyIGcgPSBsYXN0RnJhbWVHICsgKGZyYW1lc1tmcmFtZUluZGV4ICsgMi8qRlJBTUVfRyovXSAtIGxhc3RGcmFtZUcpICogcGVyY2VudDtcbiAgICAgICAgdmFyIGIgPSBsYXN0RnJhbWVCICsgKGZyYW1lc1tmcmFtZUluZGV4ICsgMy8qRlJBTUVfQiovXSAtIGxhc3RGcmFtZUIpICogcGVyY2VudDtcbiAgICAgICAgdmFyIGEgPSBsYXN0RnJhbWVBICsgKGZyYW1lc1tmcmFtZUluZGV4ICsgNC8qRlJBTUVfQSovXSAtIGxhc3RGcmFtZUEpICogcGVyY2VudDtcbiAgICAgICAgaWYgKGFscGhhIDwgMSkge1xuICAgICAgICAgICAgc2xvdC5yICs9IChyIC0gc2xvdC5yKSAqIGFscGhhO1xuICAgICAgICAgICAgc2xvdC5nICs9IChnIC0gc2xvdC5nKSAqIGFscGhhO1xuICAgICAgICAgICAgc2xvdC5iICs9IChiIC0gc2xvdC5iKSAqIGFscGhhO1xuICAgICAgICAgICAgc2xvdC5hICs9IChhIC0gc2xvdC5hKSAqIGFscGhhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2xvdC5yID0gcjtcbiAgICAgICAgICAgIHNsb3QuZyA9IGc7XG4gICAgICAgICAgICBzbG90LmIgPSBiO1xuICAgICAgICAgICAgc2xvdC5hID0gYTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnNwaW5lLkF0dGFjaG1lbnRUaW1lbGluZSA9IGZ1bmN0aW9uIChmcmFtZUNvdW50KSB7XG4gICAgdGhpcy5jdXJ2ZXMgPSBuZXcgc3BpbmUuQ3VydmVzKGZyYW1lQ291bnQpO1xuICAgIHRoaXMuZnJhbWVzID0gW107IC8vIHRpbWUsIC4uLlxuICAgIHRoaXMuZnJhbWVzLmxlbmd0aCA9IGZyYW1lQ291bnQ7XG4gICAgdGhpcy5hdHRhY2htZW50TmFtZXMgPSBbXTsgLy8gdGltZSwgLi4uXG4gICAgdGhpcy5hdHRhY2htZW50TmFtZXMubGVuZ3RoID0gZnJhbWVDb3VudDtcbn07XG5zcGluZS5BdHRhY2htZW50VGltZWxpbmUucHJvdG90eXBlID0ge1xuICAgIHNsb3RJbmRleDogMCxcbiAgICBnZXRGcmFtZUNvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcmFtZXMubGVuZ3RoO1xuICAgIH0sXG4gICAgc2V0RnJhbWU6IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCBhdHRhY2htZW50TmFtZSkge1xuICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4XSA9IHRpbWU7XG4gICAgICAgIHRoaXMuYXR0YWNobWVudE5hbWVzW2ZyYW1lSW5kZXhdID0gYXR0YWNobWVudE5hbWU7XG4gICAgfSxcbiAgICBhcHBseTogZnVuY3Rpb24gKHNrZWxldG9uLCB0aW1lLCBhbHBoYSkge1xuICAgICAgICB2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXM7XG4gICAgICAgIGlmICh0aW1lIDwgZnJhbWVzWzBdKSByZXR1cm47IC8vIFRpbWUgaXMgYmVmb3JlIGZpcnN0IGZyYW1lLlxuXG4gICAgICAgIHZhciBmcmFtZUluZGV4O1xuICAgICAgICBpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDFdKSAvLyBUaW1lIGlzIGFmdGVyIGxhc3QgZnJhbWUuXG4gICAgICAgICAgICBmcmFtZUluZGV4ID0gZnJhbWVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZyYW1lSW5kZXggPSBzcGluZS5iaW5hcnlTZWFyY2goZnJhbWVzLCB0aW1lLCAxKSAtIDE7XG5cbiAgICAgICAgdmFyIGF0dGFjaG1lbnROYW1lID0gdGhpcy5hdHRhY2htZW50TmFtZXNbZnJhbWVJbmRleF07XG4gICAgICAgIHNrZWxldG9uLnNsb3RzW3RoaXMuc2xvdEluZGV4XS5zZXRBdHRhY2htZW50KCFhdHRhY2htZW50TmFtZSA/IG51bGwgOiBza2VsZXRvbi5nZXRBdHRhY2htZW50QnlTbG90SW5kZXgodGhpcy5zbG90SW5kZXgsIGF0dGFjaG1lbnROYW1lKSk7XG4gICAgfVxufTtcblxuc3BpbmUuU2tlbGV0b25EYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYm9uZXMgPSBbXTtcbiAgICB0aGlzLnNsb3RzID0gW107XG4gICAgdGhpcy5za2lucyA9IFtdO1xuICAgIHRoaXMuYW5pbWF0aW9ucyA9IFtdO1xufTtcbnNwaW5lLlNrZWxldG9uRGF0YS5wcm90b3R5cGUgPSB7XG4gICAgZGVmYXVsdFNraW46IG51bGwsXG4gICAgLyoqIEByZXR1cm4gTWF5IGJlIG51bGwuICovXG4gICAgZmluZEJvbmU6IGZ1bmN0aW9uIChib25lTmFtZSkge1xuICAgICAgICB2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAgICAgIGlmIChib25lc1tpXS5uYW1lID09IGJvbmVOYW1lKSByZXR1cm4gYm9uZXNbaV07XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgLyoqIEByZXR1cm4gLTEgaWYgdGhlIGJvbmUgd2FzIG5vdCBmb3VuZC4gKi9cbiAgICBmaW5kQm9uZUluZGV4OiBmdW5jdGlvbiAoYm9uZU5hbWUpIHtcbiAgICAgICAgdmFyIGJvbmVzID0gdGhpcy5ib25lcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAgICAgICAgICBpZiAoYm9uZXNbaV0ubmFtZSA9PSBib25lTmFtZSkgcmV0dXJuIGk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9LFxuICAgIC8qKiBAcmV0dXJuIE1heSBiZSBudWxsLiAqL1xuICAgIGZpbmRTbG90OiBmdW5jdGlvbiAoc2xvdE5hbWUpIHtcbiAgICAgICAgdmFyIHNsb3RzID0gdGhpcy5zbG90cztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBzbG90cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzbG90c1tpXS5uYW1lID09IHNsb3ROYW1lKSByZXR1cm4gc2xvdFtpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIC8qKiBAcmV0dXJuIC0xIGlmIHRoZSBib25lIHdhcyBub3QgZm91bmQuICovXG4gICAgZmluZFNsb3RJbmRleDogZnVuY3Rpb24gKHNsb3ROYW1lKSB7XG4gICAgICAgIHZhciBzbG90cyA9IHRoaXMuc2xvdHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAgaWYgKHNsb3RzW2ldLm5hbWUgPT0gc2xvdE5hbWUpIHJldHVybiBpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSxcbiAgICAvKiogQHJldHVybiBNYXkgYmUgbnVsbC4gKi9cbiAgICBmaW5kU2tpbjogZnVuY3Rpb24gKHNraW5OYW1lKSB7XG4gICAgICAgIHZhciBza2lucyA9IHRoaXMuc2tpbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2tpbnMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAgaWYgKHNraW5zW2ldLm5hbWUgPT0gc2tpbk5hbWUpIHJldHVybiBza2luc1tpXTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICAvKiogQHJldHVybiBNYXkgYmUgbnVsbC4gKi9cbiAgICBmaW5kQW5pbWF0aW9uOiBmdW5jdGlvbiAoYW5pbWF0aW9uTmFtZSkge1xuICAgICAgICB2YXIgYW5pbWF0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBhbmltYXRpb25zLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAgICAgIGlmIChhbmltYXRpb25zW2ldLm5hbWUgPT0gYW5pbWF0aW9uTmFtZSkgcmV0dXJuIGFuaW1hdGlvbnNbaV07XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbnNwaW5lLlNrZWxldG9uID0gZnVuY3Rpb24gKHNrZWxldG9uRGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IHNrZWxldG9uRGF0YTtcblxuICAgIHRoaXMuYm9uZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNrZWxldG9uRGF0YS5ib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIGJvbmVEYXRhID0gc2tlbGV0b25EYXRhLmJvbmVzW2ldO1xuICAgICAgICB2YXIgcGFyZW50ID0gIWJvbmVEYXRhLnBhcmVudCA/IG51bGwgOiB0aGlzLmJvbmVzW3NrZWxldG9uRGF0YS5ib25lcy5pbmRleE9mKGJvbmVEYXRhLnBhcmVudCldO1xuICAgICAgICB0aGlzLmJvbmVzLnB1c2gobmV3IHNwaW5lLkJvbmUoYm9uZURhdGEsIHBhcmVudCkpO1xuICAgIH1cblxuICAgIHRoaXMuc2xvdHMgPSBbXTtcbiAgICB0aGlzLmRyYXdPcmRlciA9IFtdO1xuICAgIGZvciAoaSA9IDAsIG4gPSBza2VsZXRvbkRhdGEuc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBzbG90RGF0YSA9IHNrZWxldG9uRGF0YS5zbG90c1tpXTtcbiAgICAgICAgdmFyIGJvbmUgPSB0aGlzLmJvbmVzW3NrZWxldG9uRGF0YS5ib25lcy5pbmRleE9mKHNsb3REYXRhLmJvbmVEYXRhKV07XG4gICAgICAgIHZhciBzbG90ID0gbmV3IHNwaW5lLlNsb3Qoc2xvdERhdGEsIHRoaXMsIGJvbmUpO1xuICAgICAgICB0aGlzLnNsb3RzLnB1c2goc2xvdCk7XG4gICAgICAgIHRoaXMuZHJhd09yZGVyLnB1c2goc2xvdCk7XG4gICAgfVxufTtcbnNwaW5lLlNrZWxldG9uLnByb3RvdHlwZSA9IHtcbiAgICB4OiAwLCB5OiAwLFxuICAgIHNraW46IG51bGwsXG4gICAgcjogMSwgZzogMSwgYjogMSwgYTogMSxcbiAgICB0aW1lOiAwLFxuICAgIGZsaXBYOiBmYWxzZSwgZmxpcFk6IGZhbHNlLFxuICAgIC8qKiBVcGRhdGVzIHRoZSB3b3JsZCB0cmFuc2Zvcm0gZm9yIGVhY2ggYm9uZS4gKi9cbiAgICB1cGRhdGVXb3JsZFRyYW5zZm9ybTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZmxpcFggPSB0aGlzLmZsaXBYO1xuICAgICAgICB2YXIgZmxpcFkgPSB0aGlzLmZsaXBZO1xuICAgICAgICB2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAgICAgIGJvbmVzW2ldLnVwZGF0ZVdvcmxkVHJhbnNmb3JtKGZsaXBYLCBmbGlwWSk7XG4gICAgfSxcbiAgICAvKiogU2V0cyB0aGUgYm9uZXMgYW5kIHNsb3RzIHRvIHRoZWlyIHNldHVwIHBvc2UgdmFsdWVzLiAqL1xuICAgIHNldFRvU2V0dXBQb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0Qm9uZXNUb1NldHVwUG9zZSgpO1xuICAgICAgICB0aGlzLnNldFNsb3RzVG9TZXR1cFBvc2UoKTtcbiAgICB9LFxuICAgIHNldEJvbmVzVG9TZXR1cFBvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJvbmVzID0gdGhpcy5ib25lcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAgICAgICAgICBib25lc1tpXS5zZXRUb1NldHVwUG9zZSgpO1xuICAgIH0sXG4gICAgc2V0U2xvdHNUb1NldHVwUG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2xvdHMgPSB0aGlzLnNsb3RzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAgICAgIHNsb3RzW2ldLnNldFRvU2V0dXBQb3NlKGkpO1xuICAgIH0sXG4gICAgLyoqIEByZXR1cm4gTWF5IHJldHVybiBudWxsLiAqL1xuICAgIGdldFJvb3RCb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvbmVzLmxlbmd0aCA/IHRoaXMuYm9uZXNbMF0gOiBudWxsO1xuICAgIH0sXG4gICAgLyoqIEByZXR1cm4gTWF5IGJlIG51bGwuICovXG4gICAgZmluZEJvbmU6IGZ1bmN0aW9uIChib25lTmFtZSkge1xuICAgICAgICB2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAgICAgIGlmIChib25lc1tpXS5kYXRhLm5hbWUgPT0gYm9uZU5hbWUpIHJldHVybiBib25lc1tpXTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICAvKiogQHJldHVybiAtMSBpZiB0aGUgYm9uZSB3YXMgbm90IGZvdW5kLiAqL1xuICAgIGZpbmRCb25lSW5kZXg6IGZ1bmN0aW9uIChib25lTmFtZSkge1xuICAgICAgICB2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAgICAgIGlmIChib25lc1tpXS5kYXRhLm5hbWUgPT0gYm9uZU5hbWUpIHJldHVybiBpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSxcbiAgICAvKiogQHJldHVybiBNYXkgYmUgbnVsbC4gKi9cbiAgICBmaW5kU2xvdDogZnVuY3Rpb24gKHNsb3ROYW1lKSB7XG4gICAgICAgIHZhciBzbG90cyA9IHRoaXMuc2xvdHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAgaWYgKHNsb3RzW2ldLmRhdGEubmFtZSA9PSBzbG90TmFtZSkgcmV0dXJuIHNsb3RzW2ldO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIC8qKiBAcmV0dXJuIC0xIGlmIHRoZSBib25lIHdhcyBub3QgZm91bmQuICovXG4gICAgZmluZFNsb3RJbmRleDogZnVuY3Rpb24gKHNsb3ROYW1lKSB7XG4gICAgICAgIHZhciBzbG90cyA9IHRoaXMuc2xvdHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAgaWYgKHNsb3RzW2ldLmRhdGEubmFtZSA9PSBzbG90TmFtZSkgcmV0dXJuIGk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9LFxuICAgIHNldFNraW5CeU5hbWU6IGZ1bmN0aW9uIChza2luTmFtZSkge1xuICAgICAgICB2YXIgc2tpbiA9IHRoaXMuZGF0YS5maW5kU2tpbihza2luTmFtZSk7XG4gICAgICAgIGlmICghc2tpbikgdGhyb3cgXCJTa2luIG5vdCBmb3VuZDogXCIgKyBza2luTmFtZTtcbiAgICAgICAgdGhpcy5zZXRTa2luKHNraW4pO1xuICAgIH0sXG4gICAgLyoqIFNldHMgdGhlIHNraW4gdXNlZCB0byBsb29rIHVwIGF0dGFjaG1lbnRzIG5vdCBmb3VuZCBpbiB0aGUge0BsaW5rIFNrZWxldG9uRGF0YSNnZXREZWZhdWx0U2tpbigpIGRlZmF1bHQgc2tpbn0uIEF0dGFjaG1lbnRzXG4gICAgICogZnJvbSB0aGUgbmV3IHNraW4gYXJlIGF0dGFjaGVkIGlmIHRoZSBjb3JyZXNwb25kaW5nIGF0dGFjaG1lbnQgZnJvbSB0aGUgb2xkIHNraW4gd2FzIGF0dGFjaGVkLlxuICAgICAqIEBwYXJhbSBuZXdTa2luIE1heSBiZSBudWxsLiAqL1xuICAgIHNldFNraW46IGZ1bmN0aW9uIChuZXdTa2luKSB7XG4gICAgICAgIGlmICh0aGlzLnNraW4gJiYgbmV3U2tpbikgbmV3U2tpbi5fYXR0YWNoQWxsKHRoaXMsIHRoaXMuc2tpbik7XG4gICAgICAgIHRoaXMuc2tpbiA9IG5ld1NraW47XG4gICAgfSxcbiAgICAvKiogQHJldHVybiBNYXkgYmUgbnVsbC4gKi9cbiAgICBnZXRBdHRhY2htZW50QnlTbG90TmFtZTogZnVuY3Rpb24gKHNsb3ROYW1lLCBhdHRhY2htZW50TmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRhY2htZW50QnlTbG90SW5kZXgodGhpcy5kYXRhLmZpbmRTbG90SW5kZXgoc2xvdE5hbWUpLCBhdHRhY2htZW50TmFtZSk7XG4gICAgfSxcbiAgICAvKiogQHJldHVybiBNYXkgYmUgbnVsbC4gKi9cbiAgICBnZXRBdHRhY2htZW50QnlTbG90SW5kZXg6IGZ1bmN0aW9uIChzbG90SW5kZXgsIGF0dGFjaG1lbnROYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLnNraW4pIHtcbiAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gdGhpcy5za2luLmdldEF0dGFjaG1lbnQoc2xvdEluZGV4LCBhdHRhY2htZW50TmFtZSk7XG4gICAgICAgICAgICBpZiAoYXR0YWNobWVudCkgcmV0dXJuIGF0dGFjaG1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGF0YS5kZWZhdWx0U2tpbikgcmV0dXJuIHRoaXMuZGF0YS5kZWZhdWx0U2tpbi5nZXRBdHRhY2htZW50KHNsb3RJbmRleCwgYXR0YWNobWVudE5hbWUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIC8qKiBAcGFyYW0gYXR0YWNobWVudE5hbWUgTWF5IGJlIG51bGwuICovXG4gICAgc2V0QXR0YWNobWVudDogZnVuY3Rpb24gKHNsb3ROYW1lLCBhdHRhY2htZW50TmFtZSkge1xuICAgICAgICB2YXIgc2xvdHMgPSB0aGlzLnNsb3RzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNsb3RzLnNpemU7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzbG90ID0gc2xvdHNbaV07XG4gICAgICAgICAgICBpZiAoc2xvdC5kYXRhLm5hbWUgPT0gc2xvdE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0YWNobWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQgPSB0aGlzLmdldEF0dGFjaG1lbnQoaSwgYXR0YWNobWVudE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudCA9PSBudWxsKSB0aHJvdyBcIkF0dGFjaG1lbnQgbm90IGZvdW5kOiBcIiArIGF0dGFjaG1lbnROYW1lICsgXCIsIGZvciBzbG90OiBcIiArIHNsb3ROYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzbG90LnNldEF0dGFjaG1lbnQoYXR0YWNobWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IFwiU2xvdCBub3QgZm91bmQ6IFwiICsgc2xvdE5hbWU7XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICB0aW1lICs9IGRlbHRhO1xuICAgIH1cbn07XG5cbnNwaW5lLkF0dGFjaG1lbnRUeXBlID0ge1xuICAgIHJlZ2lvbjogMFxufTtcblxuc3BpbmUuUmVnaW9uQXR0YWNobWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm9mZnNldCA9IFtdO1xuICAgIHRoaXMub2Zmc2V0Lmxlbmd0aCA9IDg7XG4gICAgdGhpcy51dnMgPSBbXTtcbiAgICB0aGlzLnV2cy5sZW5ndGggPSA4O1xufTtcbnNwaW5lLlJlZ2lvbkF0dGFjaG1lbnQucHJvdG90eXBlID0ge1xuICAgIHg6IDAsIHk6IDAsXG4gICAgcm90YXRpb246IDAsXG4gICAgc2NhbGVYOiAxLCBzY2FsZVk6IDEsXG4gICAgd2lkdGg6IDAsIGhlaWdodDogMCxcbiAgICByZW5kZXJlck9iamVjdDogbnVsbCxcbiAgICByZWdpb25PZmZzZXRYOiAwLCByZWdpb25PZmZzZXRZOiAwLFxuICAgIHJlZ2lvbldpZHRoOiAwLCByZWdpb25IZWlnaHQ6IDAsXG4gICAgcmVnaW9uT3JpZ2luYWxXaWR0aDogMCwgcmVnaW9uT3JpZ2luYWxIZWlnaHQ6IDAsXG4gICAgc2V0VVZzOiBmdW5jdGlvbiAodSwgdiwgdTIsIHYyLCByb3RhdGUpIHtcbiAgICAgICAgdmFyIHV2cyA9IHRoaXMudXZzO1xuICAgICAgICBpZiAocm90YXRlKSB7XG4gICAgICAgICAgICB1dnNbMi8qWDIqL10gPSB1O1xuICAgICAgICAgICAgdXZzWzMvKlkyKi9dID0gdjI7XG4gICAgICAgICAgICB1dnNbNC8qWDMqL10gPSB1O1xuICAgICAgICAgICAgdXZzWzUvKlkzKi9dID0gdjtcbiAgICAgICAgICAgIHV2c1s2LypYNCovXSA9IHUyO1xuICAgICAgICAgICAgdXZzWzcvKlk0Ki9dID0gdjtcbiAgICAgICAgICAgIHV2c1swLypYMSovXSA9IHUyO1xuICAgICAgICAgICAgdXZzWzEvKlkxKi9dID0gdjI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dnNbMC8qWDEqL10gPSB1O1xuICAgICAgICAgICAgdXZzWzEvKlkxKi9dID0gdjI7XG4gICAgICAgICAgICB1dnNbMi8qWDIqL10gPSB1O1xuICAgICAgICAgICAgdXZzWzMvKlkyKi9dID0gdjtcbiAgICAgICAgICAgIHV2c1s0LypYMyovXSA9IHUyO1xuICAgICAgICAgICAgdXZzWzUvKlkzKi9dID0gdjtcbiAgICAgICAgICAgIHV2c1s2LypYNCovXSA9IHUyO1xuICAgICAgICAgICAgdXZzWzcvKlk0Ki9dID0gdjI7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHVwZGF0ZU9mZnNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVnaW9uU2NhbGVYID0gdGhpcy53aWR0aCAvIHRoaXMucmVnaW9uT3JpZ2luYWxXaWR0aCAqIHRoaXMuc2NhbGVYO1xuICAgICAgICB2YXIgcmVnaW9uU2NhbGVZID0gdGhpcy5oZWlnaHQgLyB0aGlzLnJlZ2lvbk9yaWdpbmFsSGVpZ2h0ICogdGhpcy5zY2FsZVk7XG4gICAgICAgIHZhciBsb2NhbFggPSAtdGhpcy53aWR0aCAvIDIgKiB0aGlzLnNjYWxlWCArIHRoaXMucmVnaW9uT2Zmc2V0WCAqIHJlZ2lvblNjYWxlWDtcbiAgICAgICAgdmFyIGxvY2FsWSA9IC10aGlzLmhlaWdodCAvIDIgKiB0aGlzLnNjYWxlWSArIHRoaXMucmVnaW9uT2Zmc2V0WSAqIHJlZ2lvblNjYWxlWTtcbiAgICAgICAgdmFyIGxvY2FsWDIgPSBsb2NhbFggKyB0aGlzLnJlZ2lvbldpZHRoICogcmVnaW9uU2NhbGVYO1xuICAgICAgICB2YXIgbG9jYWxZMiA9IGxvY2FsWSArIHRoaXMucmVnaW9uSGVpZ2h0ICogcmVnaW9uU2NhbGVZO1xuICAgICAgICB2YXIgcmFkaWFucyA9IHRoaXMucm90YXRpb24gKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MocmFkaWFucyk7XG4gICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbihyYWRpYW5zKTtcbiAgICAgICAgdmFyIGxvY2FsWENvcyA9IGxvY2FsWCAqIGNvcyArIHRoaXMueDtcbiAgICAgICAgdmFyIGxvY2FsWFNpbiA9IGxvY2FsWCAqIHNpbjtcbiAgICAgICAgdmFyIGxvY2FsWUNvcyA9IGxvY2FsWSAqIGNvcyArIHRoaXMueTtcbiAgICAgICAgdmFyIGxvY2FsWVNpbiA9IGxvY2FsWSAqIHNpbjtcbiAgICAgICAgdmFyIGxvY2FsWDJDb3MgPSBsb2NhbFgyICogY29zICsgdGhpcy54O1xuICAgICAgICB2YXIgbG9jYWxYMlNpbiA9IGxvY2FsWDIgKiBzaW47XG4gICAgICAgIHZhciBsb2NhbFkyQ29zID0gbG9jYWxZMiAqIGNvcyArIHRoaXMueTtcbiAgICAgICAgdmFyIGxvY2FsWTJTaW4gPSBsb2NhbFkyICogc2luO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIG9mZnNldFswLypYMSovXSA9IGxvY2FsWENvcyAtIGxvY2FsWVNpbjtcbiAgICAgICAgb2Zmc2V0WzEvKlkxKi9dID0gbG9jYWxZQ29zICsgbG9jYWxYU2luO1xuICAgICAgICBvZmZzZXRbMi8qWDIqL10gPSBsb2NhbFhDb3MgLSBsb2NhbFkyU2luO1xuICAgICAgICBvZmZzZXRbMy8qWTIqL10gPSBsb2NhbFkyQ29zICsgbG9jYWxYU2luO1xuICAgICAgICBvZmZzZXRbNC8qWDMqL10gPSBsb2NhbFgyQ29zIC0gbG9jYWxZMlNpbjtcbiAgICAgICAgb2Zmc2V0WzUvKlkzKi9dID0gbG9jYWxZMkNvcyArIGxvY2FsWDJTaW47XG4gICAgICAgIG9mZnNldFs2LypYNCovXSA9IGxvY2FsWDJDb3MgLSBsb2NhbFlTaW47XG4gICAgICAgIG9mZnNldFs3LypZNCovXSA9IGxvY2FsWUNvcyArIGxvY2FsWDJTaW47XG4gICAgfSxcbiAgICBjb21wdXRlVmVydGljZXM6IGZ1bmN0aW9uICh4LCB5LCBib25lLCB2ZXJ0aWNlcykge1xuICAgICAgICB4ICs9IGJvbmUud29ybGRYO1xuICAgICAgICB5ICs9IGJvbmUud29ybGRZO1xuICAgICAgICB2YXIgbTAwID0gYm9uZS5tMDA7XG4gICAgICAgIHZhciBtMDEgPSBib25lLm0wMTtcbiAgICAgICAgdmFyIG0xMCA9IGJvbmUubTEwO1xuICAgICAgICB2YXIgbTExID0gYm9uZS5tMTE7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgdmVydGljZXNbMC8qWDEqL10gPSBvZmZzZXRbMC8qWDEqL10gKiBtMDAgKyBvZmZzZXRbMS8qWTEqL10gKiBtMDEgKyB4O1xuICAgICAgICB2ZXJ0aWNlc1sxLypZMSovXSA9IG9mZnNldFswLypYMSovXSAqIG0xMCArIG9mZnNldFsxLypZMSovXSAqIG0xMSArIHk7XG4gICAgICAgIHZlcnRpY2VzWzIvKlgyKi9dID0gb2Zmc2V0WzIvKlgyKi9dICogbTAwICsgb2Zmc2V0WzMvKlkyKi9dICogbTAxICsgeDtcbiAgICAgICAgdmVydGljZXNbMy8qWTIqL10gPSBvZmZzZXRbMi8qWDIqL10gKiBtMTAgKyBvZmZzZXRbMy8qWTIqL10gKiBtMTEgKyB5O1xuICAgICAgICB2ZXJ0aWNlc1s0LypYMyovXSA9IG9mZnNldFs0LypYMyovXSAqIG0wMCArIG9mZnNldFs1LypYMyovXSAqIG0wMSArIHg7XG4gICAgICAgIHZlcnRpY2VzWzUvKlgzKi9dID0gb2Zmc2V0WzQvKlgzKi9dICogbTEwICsgb2Zmc2V0WzUvKlgzKi9dICogbTExICsgeTtcbiAgICAgICAgdmVydGljZXNbNi8qWDQqL10gPSBvZmZzZXRbNi8qWDQqL10gKiBtMDAgKyBvZmZzZXRbNy8qWTQqL10gKiBtMDEgKyB4O1xuICAgICAgICB2ZXJ0aWNlc1s3LypZNCovXSA9IG9mZnNldFs2LypYNCovXSAqIG0xMCArIG9mZnNldFs3LypZNCovXSAqIG0xMSArIHk7XG4gICAgfVxufVxuXG5zcGluZS5BbmltYXRpb25TdGF0ZURhdGEgPSBmdW5jdGlvbiAoc2tlbGV0b25EYXRhKSB7XG4gICAgdGhpcy5za2VsZXRvbkRhdGEgPSBza2VsZXRvbkRhdGE7XG4gICAgdGhpcy5hbmltYXRpb25Ub01peFRpbWUgPSB7fTtcbn07XG5zcGluZS5BbmltYXRpb25TdGF0ZURhdGEucHJvdG90eXBlID0ge1xuICAgICAgICBkZWZhdWx0TWl4OiAwLFxuICAgIHNldE1peEJ5TmFtZTogZnVuY3Rpb24gKGZyb21OYW1lLCB0b05hbWUsIGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBmcm9tID0gdGhpcy5za2VsZXRvbkRhdGEuZmluZEFuaW1hdGlvbihmcm9tTmFtZSk7XG4gICAgICAgIGlmICghZnJvbSkgdGhyb3cgXCJBbmltYXRpb24gbm90IGZvdW5kOiBcIiArIGZyb21OYW1lO1xuICAgICAgICB2YXIgdG8gPSB0aGlzLnNrZWxldG9uRGF0YS5maW5kQW5pbWF0aW9uKHRvTmFtZSk7XG4gICAgICAgIGlmICghdG8pIHRocm93IFwiQW5pbWF0aW9uIG5vdCBmb3VuZDogXCIgKyB0b05hbWU7XG4gICAgICAgIHRoaXMuc2V0TWl4KGZyb20sIHRvLCBkdXJhdGlvbik7XG4gICAgfSxcbiAgICBzZXRNaXg6IGZ1bmN0aW9uIChmcm9tLCB0bywgZHVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25Ub01peFRpbWVbZnJvbS5uYW1lICsgXCI6XCIgKyB0by5uYW1lXSA9IGR1cmF0aW9uO1xuICAgIH0sXG4gICAgZ2V0TWl4OiBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIHRpbWUgPSB0aGlzLmFuaW1hdGlvblRvTWl4VGltZVtmcm9tLm5hbWUgKyBcIjpcIiArIHRvLm5hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIHRpbWUgPyB0aW1lIDogdGhpcy5kZWZhdWx0TWl4O1xuICAgIH1cbn07XG5cbnNwaW5lLkFuaW1hdGlvblN0YXRlID0gZnVuY3Rpb24gKHN0YXRlRGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IHN0YXRlRGF0YTtcbiAgICB0aGlzLnF1ZXVlID0gW107XG59O1xuc3BpbmUuQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlID0ge1xuICAgIGFuaW1hdGlvblNwZWVkOiAxLFxuICAgIGN1cnJlbnQ6IG51bGwsXG4gICAgcHJldmlvdXM6IG51bGwsXG4gICAgY3VycmVudFRpbWU6IDAsXG4gICAgcHJldmlvdXNUaW1lOiAwLFxuICAgIGN1cnJlbnRMb29wOiBmYWxzZSxcbiAgICBwcmV2aW91c0xvb3A6IGZhbHNlLFxuICAgIG1peFRpbWU6IDAsXG4gICAgbWl4RHVyYXRpb246IDAsXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZSArPSAoZGVsdGEgKiB0aGlzLmFuaW1hdGlvblNwZWVkKTsgLy90aW1lU2NhbGU6IE11bHRpcGx5IGRlbHRhIGJ5IHRoZSBzcGVlZCBvZiBhbmltYXRpb24gcmVxdWlyZWQuXG4gICAgICAgIHRoaXMucHJldmlvdXNUaW1lICs9IGRlbHRhO1xuICAgICAgICB0aGlzLm1peFRpbWUgKz0gZGVsdGE7XG5cbiAgICAgICAgaWYgKHRoaXMucXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5xdWV1ZVswXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRUaW1lID49IGVudHJ5LmRlbGF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0QW5pbWF0aW9uKGVudHJ5LmFuaW1hdGlvbiwgZW50cnkubG9vcCk7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBhcHBseTogZnVuY3Rpb24gKHNrZWxldG9uKSB7XG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50KSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzLmFwcGx5KHNrZWxldG9uLCB0aGlzLnByZXZpb3VzVGltZSwgdGhpcy5wcmV2aW91c0xvb3ApO1xuICAgICAgICAgICAgdmFyIGFscGhhID0gdGhpcy5taXhUaW1lIC8gdGhpcy5taXhEdXJhdGlvbjtcbiAgICAgICAgICAgIGlmIChhbHBoYSA+PSAxKSB7XG4gICAgICAgICAgICAgICAgYWxwaGEgPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Lm1peChza2VsZXRvbiwgdGhpcy5jdXJyZW50VGltZSwgdGhpcy5jdXJyZW50TG9vcCwgYWxwaGEpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5hcHBseShza2VsZXRvbiwgdGhpcy5jdXJyZW50VGltZSwgdGhpcy5jdXJyZW50TG9vcCk7XG4gICAgfSxcbiAgICBjbGVhckFuaW1hdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5xdWV1ZS5sZW5ndGggPSAwO1xuICAgIH0sXG4gICAgX3NldEFuaW1hdGlvbjogZnVuY3Rpb24gKGFuaW1hdGlvbiwgbG9vcCkge1xuICAgICAgICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgaWYgKGFuaW1hdGlvbiAmJiB0aGlzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMubWl4RHVyYXRpb24gPSB0aGlzLmRhdGEuZ2V0TWl4KHRoaXMuY3VycmVudCwgYW5pbWF0aW9uKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1peER1cmF0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWl4VGltZSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91cyA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzVGltZSA9IHRoaXMuY3VycmVudFRpbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c0xvb3AgPSB0aGlzLmN1cnJlbnRMb29wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudCA9IGFuaW1hdGlvbjtcbiAgICAgICAgdGhpcy5jdXJyZW50TG9vcCA9IGxvb3A7XG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICAgIH0sXG4gICAgLyoqIEBzZWUgI3NldEFuaW1hdGlvbihBbmltYXRpb24sIEJvb2xlYW4pICovXG4gICAgc2V0QW5pbWF0aW9uQnlOYW1lOiBmdW5jdGlvbiAoYW5pbWF0aW9uTmFtZSwgbG9vcCkge1xuICAgICAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5kYXRhLnNrZWxldG9uRGF0YS5maW5kQW5pbWF0aW9uKGFuaW1hdGlvbk5hbWUpO1xuICAgICAgICBpZiAoIWFuaW1hdGlvbikgdGhyb3cgXCJBbmltYXRpb24gbm90IGZvdW5kOiBcIiArIGFuaW1hdGlvbk5hbWU7XG4gICAgICAgIHRoaXMuc2V0QW5pbWF0aW9uKGFuaW1hdGlvbiwgbG9vcCk7XG4gICAgfSxcbiAgICAvKiogU2V0IHRoZSBjdXJyZW50IGFuaW1hdGlvbi4gQW55IHF1ZXVlZCBhbmltYXRpb25zIGFyZSBjbGVhcmVkIGFuZCB0aGUgY3VycmVudCBhbmltYXRpb24gdGltZSBpcyBzZXQgdG8gMC5cbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9uIE1heSBiZSBudWxsLiAqL1xuICAgIHNldEFuaW1hdGlvbjogZnVuY3Rpb24gKGFuaW1hdGlvbiwgbG9vcCkge1xuICAgICAgICB0aGlzLnF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX3NldEFuaW1hdGlvbihhbmltYXRpb24sIGxvb3ApO1xuICAgIH0sXG4gICAgLyoqIEBzZWUgI2FkZEFuaW1hdGlvbihBbmltYXRpb24sIEJvb2xlYW4sIE51bWJlcikgKi9cbiAgICBhZGRBbmltYXRpb25CeU5hbWU6IGZ1bmN0aW9uIChhbmltYXRpb25OYW1lLCBsb29wLCBkZWxheSkge1xuICAgICAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5kYXRhLnNrZWxldG9uRGF0YS5maW5kQW5pbWF0aW9uKGFuaW1hdGlvbk5hbWUpO1xuICAgICAgICBpZiAoIWFuaW1hdGlvbikgdGhyb3cgXCJBbmltYXRpb24gbm90IGZvdW5kOiBcIiArIGFuaW1hdGlvbk5hbWU7XG4gICAgICAgIHRoaXMuYWRkQW5pbWF0aW9uKGFuaW1hdGlvbiwgbG9vcCwgZGVsYXkpO1xuICAgIH0sXG4gICAgLyoqIEFkZHMgYW4gYW5pbWF0aW9uIHRvIGJlIHBsYXllZCBkZWxheSBzZWNvbmRzIGFmdGVyIHRoZSBjdXJyZW50IG9yIGxhc3QgcXVldWVkIGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0gZGVsYXkgTWF5IGJlIDw9IDAgdG8gdXNlIGR1cmF0aW9uIG9mIHByZXZpb3VzIGFuaW1hdGlvbiBtaW51cyBhbnkgbWl4IGR1cmF0aW9uIHBsdXMgdGhlIG5lZ2F0aXZlIGRlbGF5LiAqL1xuICAgIGFkZEFuaW1hdGlvbjogZnVuY3Rpb24gKGFuaW1hdGlvbiwgbG9vcCwgZGVsYXkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0ge307XG4gICAgICAgIGVudHJ5LmFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcbiAgICAgICAgZW50cnkubG9vcCA9IGxvb3A7XG5cbiAgICAgICAgaWYgKCFkZWxheSB8fCBkZWxheSA8PSAwKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNBbmltYXRpb24gPSB0aGlzLnF1ZXVlLmxlbmd0aCA/IHRoaXMucXVldWVbdGhpcy5xdWV1ZS5sZW5ndGggLSAxXS5hbmltYXRpb24gOiB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNBbmltYXRpb24gIT0gbnVsbClcbiAgICAgICAgICAgICAgICBkZWxheSA9IHByZXZpb3VzQW5pbWF0aW9uLmR1cmF0aW9uIC0gdGhpcy5kYXRhLmdldE1peChwcmV2aW91c0FuaW1hdGlvbiwgYW5pbWF0aW9uKSArIChkZWxheSB8fCAwKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZW50cnkuZGVsYXkgPSBkZWxheTtcblxuICAgICAgICB0aGlzLnF1ZXVlLnB1c2goZW50cnkpO1xuICAgIH0sXG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiBubyBhbmltYXRpb24gaXMgc2V0IG9yIGlmIHRoZSBjdXJyZW50IHRpbWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBhbmltYXRpb24gZHVyYXRpb24sIHJlZ2FyZGxlc3Mgb2YgbG9vcGluZy4gKi9cbiAgICBpc0NvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jdXJyZW50IHx8IHRoaXMuY3VycmVudFRpbWUgPj0gdGhpcy5jdXJyZW50LmR1cmF0aW9uO1xuICAgIH1cbn07XG5cbnNwaW5lLlNrZWxldG9uSnNvbiA9IGZ1bmN0aW9uIChhdHRhY2htZW50TG9hZGVyKSB7XG4gICAgdGhpcy5hdHRhY2htZW50TG9hZGVyID0gYXR0YWNobWVudExvYWRlcjtcbn07XG5zcGluZS5Ta2VsZXRvbkpzb24ucHJvdG90eXBlID0ge1xuICAgIHNjYWxlOiAxLFxuICAgIHJlYWRTa2VsZXRvbkRhdGE6IGZ1bmN0aW9uIChyb290KSB7XG4gICAgICAgIC8qanNoaW50IC1XMDY5Ki9cbiAgICAgICAgdmFyIHNrZWxldG9uRGF0YSA9IG5ldyBzcGluZS5Ta2VsZXRvbkRhdGEoKSxcbiAgICAgICAgICAgIGJvbmVEYXRhO1xuXG4gICAgICAgIC8vIEJvbmVzLlxuICAgICAgICB2YXIgYm9uZXMgPSByb290W1wiYm9uZXNcIl07XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9uZU1hcCA9IGJvbmVzW2ldO1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoYm9uZU1hcFtcInBhcmVudFwiXSkge1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHNrZWxldG9uRGF0YS5maW5kQm9uZShib25lTWFwW1wicGFyZW50XCJdKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudCkgdGhyb3cgXCJQYXJlbnQgYm9uZSBub3QgZm91bmQ6IFwiICsgYm9uZU1hcFtcInBhcmVudFwiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvbmVEYXRhID0gbmV3IHNwaW5lLkJvbmVEYXRhKGJvbmVNYXBbXCJuYW1lXCJdLCBwYXJlbnQpO1xuICAgICAgICAgICAgYm9uZURhdGEubGVuZ3RoID0gKGJvbmVNYXBbXCJsZW5ndGhcIl0gfHwgMCkgKiB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgYm9uZURhdGEueCA9IChib25lTWFwW1wieFwiXSB8fCAwKSAqIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBib25lRGF0YS55ID0gKGJvbmVNYXBbXCJ5XCJdIHx8IDApICogdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGJvbmVEYXRhLnJvdGF0aW9uID0gKGJvbmVNYXBbXCJyb3RhdGlvblwiXSB8fCAwKTtcbiAgICAgICAgICAgIGJvbmVEYXRhLnNjYWxlWCA9IGJvbmVNYXBbXCJzY2FsZVhcIl0gfHwgMTtcbiAgICAgICAgICAgIGJvbmVEYXRhLnNjYWxlWSA9IGJvbmVNYXBbXCJzY2FsZVlcIl0gfHwgMTtcbiAgICAgICAgICAgIHNrZWxldG9uRGF0YS5ib25lcy5wdXNoKGJvbmVEYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNsb3RzLlxuICAgICAgICB2YXIgc2xvdHMgPSByb290W1wic2xvdHNcIl07XG4gICAgICAgIGZvciAoaSA9IDAsIG4gPSBzbG90cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzbG90TWFwID0gc2xvdHNbaV07XG4gICAgICAgICAgICBib25lRGF0YSA9IHNrZWxldG9uRGF0YS5maW5kQm9uZShzbG90TWFwW1wiYm9uZVwiXSk7XG4gICAgICAgICAgICBpZiAoIWJvbmVEYXRhKSB0aHJvdyBcIlNsb3QgYm9uZSBub3QgZm91bmQ6IFwiICsgc2xvdE1hcFtcImJvbmVcIl07XG4gICAgICAgICAgICB2YXIgc2xvdERhdGEgPSBuZXcgc3BpbmUuU2xvdERhdGEoc2xvdE1hcFtcIm5hbWVcIl0sIGJvbmVEYXRhKTtcblxuICAgICAgICAgICAgdmFyIGNvbG9yID0gc2xvdE1hcFtcImNvbG9yXCJdO1xuICAgICAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgc2xvdERhdGEuciA9IHNwaW5lLlNrZWxldG9uSnNvbi50b0NvbG9yKGNvbG9yLCAwKTtcbiAgICAgICAgICAgICAgICBzbG90RGF0YS5nID0gc3BpbmUuU2tlbGV0b25Kc29uLnRvQ29sb3IoY29sb3IsIDEpO1xuICAgICAgICAgICAgICAgIHNsb3REYXRhLmIgPSBzcGluZS5Ta2VsZXRvbkpzb24udG9Db2xvcihjb2xvciwgMik7XG4gICAgICAgICAgICAgICAgc2xvdERhdGEuYSA9IHNwaW5lLlNrZWxldG9uSnNvbi50b0NvbG9yKGNvbG9yLCAzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2xvdERhdGEuYXR0YWNobWVudE5hbWUgPSBzbG90TWFwW1wiYXR0YWNobWVudFwiXTtcblxuICAgICAgICAgICAgc2tlbGV0b25EYXRhLnNsb3RzLnB1c2goc2xvdERhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2tpbnMuXG4gICAgICAgIHZhciBza2lucyA9IHJvb3RbXCJza2luc1wiXTtcbiAgICAgICAgZm9yICh2YXIgc2tpbk5hbWUgaW4gc2tpbnMpIHtcbiAgICAgICAgICAgIGlmICghc2tpbnMuaGFzT3duUHJvcGVydHkoc2tpbk5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciBza2luTWFwID0gc2tpbnNbc2tpbk5hbWVdO1xuICAgICAgICAgICAgdmFyIHNraW4gPSBuZXcgc3BpbmUuU2tpbihza2luTmFtZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBzbG90TmFtZSBpbiBza2luTWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFza2luTWFwLmhhc093blByb3BlcnR5KHNsb3ROYW1lKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgdmFyIHNsb3RJbmRleCA9IHNrZWxldG9uRGF0YS5maW5kU2xvdEluZGV4KHNsb3ROYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgc2xvdEVudHJ5ID0gc2tpbk1hcFtzbG90TmFtZV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYXR0YWNobWVudE5hbWUgaW4gc2xvdEVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2xvdEVudHJ5Lmhhc093blByb3BlcnR5KGF0dGFjaG1lbnROYW1lKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gdGhpcy5yZWFkQXR0YWNobWVudChza2luLCBhdHRhY2htZW50TmFtZSwgc2xvdEVudHJ5W2F0dGFjaG1lbnROYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50ICE9IG51bGwpIHNraW4uYWRkQXR0YWNobWVudChzbG90SW5kZXgsIGF0dGFjaG1lbnROYW1lLCBhdHRhY2htZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBza2VsZXRvbkRhdGEuc2tpbnMucHVzaChza2luKTtcbiAgICAgICAgICAgIGlmIChza2luLm5hbWUgPT0gXCJkZWZhdWx0XCIpIHNrZWxldG9uRGF0YS5kZWZhdWx0U2tpbiA9IHNraW47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbmltYXRpb25zLlxuICAgICAgICB2YXIgYW5pbWF0aW9ucyA9IHJvb3RbXCJhbmltYXRpb25zXCJdO1xuICAgICAgICBmb3IgKHZhciBhbmltYXRpb25OYW1lIGluIGFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghYW5pbWF0aW9ucy5oYXNPd25Qcm9wZXJ0eShhbmltYXRpb25OYW1lKSkgY29udGludWU7XG4gICAgICAgICAgICB0aGlzLnJlYWRBbmltYXRpb24oYW5pbWF0aW9uTmFtZSwgYW5pbWF0aW9uc1thbmltYXRpb25OYW1lXSwgc2tlbGV0b25EYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBza2VsZXRvbkRhdGE7XG4gICAgfSxcbiAgICByZWFkQXR0YWNobWVudDogZnVuY3Rpb24gKHNraW4sIG5hbWUsIG1hcCkge1xuICAgICAgICAvKmpzaGludCAtVzA2OSovXG4gICAgICAgIG5hbWUgPSBtYXBbXCJuYW1lXCJdIHx8IG5hbWU7XG5cbiAgICAgICAgdmFyIHR5cGUgPSBzcGluZS5BdHRhY2htZW50VHlwZVttYXBbXCJ0eXBlXCJdIHx8IFwicmVnaW9uXCJdO1xuXG4gICAgICAgIGlmICh0eXBlID09IHNwaW5lLkF0dGFjaG1lbnRUeXBlLnJlZ2lvbikge1xuICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSBuZXcgc3BpbmUuUmVnaW9uQXR0YWNobWVudCgpO1xuICAgICAgICAgICAgYXR0YWNobWVudC54ID0gKG1hcFtcInhcIl0gfHwgMCkgKiB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgYXR0YWNobWVudC55ID0gKG1hcFtcInlcIl0gfHwgMCkgKiB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgYXR0YWNobWVudC5zY2FsZVggPSBtYXBbXCJzY2FsZVhcIl0gfHwgMTtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQuc2NhbGVZID0gbWFwW1wic2NhbGVZXCJdIHx8IDE7XG4gICAgICAgICAgICBhdHRhY2htZW50LnJvdGF0aW9uID0gbWFwW1wicm90YXRpb25cIl0gfHwgMDtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQud2lkdGggPSAobWFwW1wid2lkdGhcIl0gfHwgMzIpICogdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQuaGVpZ2h0ID0gKG1hcFtcImhlaWdodFwiXSB8fCAzMikgKiB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgYXR0YWNobWVudC51cGRhdGVPZmZzZXQoKTtcblxuICAgICAgICAgICAgYXR0YWNobWVudC5yZW5kZXJlck9iamVjdCA9IHt9O1xuICAgICAgICAgICAgYXR0YWNobWVudC5yZW5kZXJlck9iamVjdC5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQucmVuZGVyZXJPYmplY3Quc2NhbGUgPSB7fTtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQucmVuZGVyZXJPYmplY3Quc2NhbGUueCA9IGF0dGFjaG1lbnQuc2NhbGVYO1xuICAgICAgICAgICAgYXR0YWNobWVudC5yZW5kZXJlck9iamVjdC5zY2FsZS55ID0gYXR0YWNobWVudC5zY2FsZVk7XG4gICAgICAgICAgICBhdHRhY2htZW50LnJlbmRlcmVyT2JqZWN0LnJvdGF0aW9uID0gLWF0dGFjaG1lbnQucm90YXRpb24gKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgICAgICAgcmV0dXJuIGF0dGFjaG1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgXCJVbmtub3duIGF0dGFjaG1lbnQgdHlwZTogXCIgKyB0eXBlO1xuICAgIH0sXG5cbiAgICByZWFkQW5pbWF0aW9uOiBmdW5jdGlvbiAobmFtZSwgbWFwLCBza2VsZXRvbkRhdGEpIHtcbiAgICAgICAgLypqc2hpbnQgLVcwNjkqL1xuICAgICAgICB2YXIgdGltZWxpbmVzID0gW107XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IDA7XG4gICAgICAgIHZhciBmcmFtZUluZGV4LCB0aW1lbGluZSwgdGltZWxpbmVOYW1lLCB2YWx1ZU1hcCwgdmFsdWVzLFxuICAgICAgICAgICAgaSwgbjtcblxuICAgICAgICB2YXIgYm9uZXMgPSBtYXBbXCJib25lc1wiXTtcbiAgICAgICAgZm9yICh2YXIgYm9uZU5hbWUgaW4gYm9uZXMpIHtcbiAgICAgICAgICAgIGlmICghYm9uZXMuaGFzT3duUHJvcGVydHkoYm9uZU5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciBib25lSW5kZXggPSBza2VsZXRvbkRhdGEuZmluZEJvbmVJbmRleChib25lTmFtZSk7XG4gICAgICAgICAgICBpZiAoYm9uZUluZGV4ID09IC0xKSB0aHJvdyBcIkJvbmUgbm90IGZvdW5kOiBcIiArIGJvbmVOYW1lO1xuICAgICAgICAgICAgdmFyIGJvbmVNYXAgPSBib25lc1tib25lTmFtZV07XG5cbiAgICAgICAgICAgIGZvciAodGltZWxpbmVOYW1lIGluIGJvbmVNYXApIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJvbmVNYXAuaGFzT3duUHJvcGVydHkodGltZWxpbmVOYW1lKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgdmFsdWVzID0gYm9uZU1hcFt0aW1lbGluZU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lbGluZU5hbWUgPT0gXCJyb3RhdGVcIikge1xuICAgICAgICAgICAgICAgICAgICB0aW1lbGluZSA9IG5ldyBzcGluZS5Sb3RhdGVUaW1lbGluZSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuYm9uZUluZGV4ID0gYm9uZUluZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBuID0gdmFsdWVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVNYXAgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zZXRGcmFtZShmcmFtZUluZGV4LCB2YWx1ZU1hcFtcInRpbWVcIl0sIHZhbHVlTWFwW1wiYW5nbGVcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BpbmUuU2tlbGV0b25Kc29uLnJlYWRDdXJ2ZSh0aW1lbGluZSwgZnJhbWVJbmRleCwgdmFsdWVNYXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzW3RpbWVsaW5lLmdldEZyYW1lQ291bnQoKSAqIDIgLSAyXSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRpbWVsaW5lTmFtZSA9PSBcInRyYW5zbGF0ZVwiIHx8IHRpbWVsaW5lTmFtZSA9PSBcInNjYWxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lU2NhbGUgPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZWxpbmVOYW1lID09IFwic2NhbGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lID0gbmV3IHNwaW5lLlNjYWxlVGltZWxpbmUodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUgPSBuZXcgc3BpbmUuVHJhbnNsYXRlVGltZWxpbmUodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZVNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5ib25lSW5kZXggPSBib25lSW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgICAgZnJhbWVJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIG4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZU1hcCA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gKHZhbHVlTWFwW1wieFwiXSB8fCAwKSAqIHRpbWVsaW5lU2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9ICh2YWx1ZU1hcFtcInlcIl0gfHwgMCkgKiB0aW1lbGluZVNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgdmFsdWVNYXBbXCJ0aW1lXCJdLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwaW5lLlNrZWxldG9uSnNvbi5yZWFkQ3VydmUodGltZWxpbmUsIGZyYW1lSW5kZXgsIHZhbHVlTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1t0aW1lbGluZS5nZXRGcmFtZUNvdW50KCkgKiAzIC0gM10pO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCB0aW1lbGluZSB0eXBlIGZvciBhIGJvbmU6IFwiICsgdGltZWxpbmVOYW1lICsgXCIgKFwiICsgYm9uZU5hbWUgKyBcIilcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc2xvdHMgPSBtYXBbXCJzbG90c1wiXTtcbiAgICAgICAgZm9yICh2YXIgc2xvdE5hbWUgaW4gc2xvdHMpIHtcbiAgICAgICAgICAgIGlmICghc2xvdHMuaGFzT3duUHJvcGVydHkoc2xvdE5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciBzbG90TWFwID0gc2xvdHNbc2xvdE5hbWVdO1xuICAgICAgICAgICAgdmFyIHNsb3RJbmRleCA9IHNrZWxldG9uRGF0YS5maW5kU2xvdEluZGV4KHNsb3ROYW1lKTtcblxuICAgICAgICAgICAgZm9yICh0aW1lbGluZU5hbWUgaW4gc2xvdE1hcCkge1xuICAgICAgICAgICAgICAgIGlmICghc2xvdE1hcC5oYXNPd25Qcm9wZXJ0eSh0aW1lbGluZU5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBzbG90TWFwW3RpbWVsaW5lTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVsaW5lTmFtZSA9PSBcImNvbG9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUgPSBuZXcgc3BpbmUuQ29sb3JUaW1lbGluZSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2xvdEluZGV4ID0gc2xvdEluZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBuID0gdmFsdWVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVNYXAgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSB2YWx1ZU1hcFtcImNvbG9yXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBzcGluZS5Ta2VsZXRvbkpzb24udG9Db2xvcihjb2xvciwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IHNwaW5lLlNrZWxldG9uSnNvbi50b0NvbG9yKGNvbG9yLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gc3BpbmUuU2tlbGV0b25Kc29uLnRvQ29sb3IoY29sb3IsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBzcGluZS5Ta2VsZXRvbkpzb24udG9Db2xvcihjb2xvciwgMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zZXRGcmFtZShmcmFtZUluZGV4LCB2YWx1ZU1hcFtcInRpbWVcIl0sIHIsIGcsIGIsIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BpbmUuU2tlbGV0b25Kc29uLnJlYWRDdXJ2ZSh0aW1lbGluZSwgZnJhbWVJbmRleCwgdmFsdWVNYXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzW3RpbWVsaW5lLmdldEZyYW1lQ291bnQoKSAqIDUgLSA1XSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRpbWVsaW5lTmFtZSA9PSBcImF0dGFjaG1lbnRcIikge1xuICAgICAgICAgICAgICAgICAgICB0aW1lbGluZSA9IG5ldyBzcGluZS5BdHRhY2htZW50VGltZWxpbmUodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNsb3RJbmRleCA9IHNsb3RJbmRleDtcblxuICAgICAgICAgICAgICAgICAgICBmcmFtZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlTWFwID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCsrLCB2YWx1ZU1hcFtcInRpbWVcIl0sIHZhbHVlTWFwW1wibmFtZVwiXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzW3RpbWVsaW5lLmdldEZyYW1lQ291bnQoKSAtIDFdKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgdGltZWxpbmUgdHlwZSBmb3IgYSBzbG90OiBcIiArIHRpbWVsaW5lTmFtZSArIFwiIChcIiArIHNsb3ROYW1lICsgXCIpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2tlbGV0b25EYXRhLmFuaW1hdGlvbnMucHVzaChuZXcgc3BpbmUuQW5pbWF0aW9uKG5hbWUsIHRpbWVsaW5lcywgZHVyYXRpb24pKTtcbiAgICB9XG59O1xuc3BpbmUuU2tlbGV0b25Kc29uLnJlYWRDdXJ2ZSA9IGZ1bmN0aW9uICh0aW1lbGluZSwgZnJhbWVJbmRleCwgdmFsdWVNYXApIHtcbiAgICAvKmpzaGludCAtVzA2OSovXG4gICAgdmFyIGN1cnZlID0gdmFsdWVNYXBbXCJjdXJ2ZVwiXTtcbiAgICBpZiAoIWN1cnZlKSByZXR1cm47XG4gICAgaWYgKGN1cnZlID09IFwic3RlcHBlZFwiKVxuICAgICAgICB0aW1lbGluZS5jdXJ2ZXMuc2V0U3RlcHBlZChmcmFtZUluZGV4KTtcbiAgICBlbHNlIGlmIChjdXJ2ZSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICB0aW1lbGluZS5jdXJ2ZXMuc2V0Q3VydmUoZnJhbWVJbmRleCwgY3VydmVbMF0sIGN1cnZlWzFdLCBjdXJ2ZVsyXSwgY3VydmVbM10pO1xufTtcbnNwaW5lLlNrZWxldG9uSnNvbi50b0NvbG9yID0gZnVuY3Rpb24gKGhleFN0cmluZywgY29sb3JJbmRleCkge1xuICAgIGlmIChoZXhTdHJpbmcubGVuZ3RoICE9IDgpIHRocm93IFwiQ29sb3IgaGV4aWRlY2ltYWwgbGVuZ3RoIG11c3QgYmUgOCwgcmVjaWV2ZWQ6IFwiICsgaGV4U3RyaW5nO1xuICAgIHJldHVybiBwYXJzZUludChoZXhTdHJpbmcuc3Vic3RyKGNvbG9ySW5kZXggKiAyLCAyKSwgMTYpIC8gMjU1O1xufTtcblxuc3BpbmUuQXRsYXMgPSBmdW5jdGlvbiAoYXRsYXNUZXh0LCB0ZXh0dXJlTG9hZGVyKSB7XG4gICAgdGhpcy50ZXh0dXJlTG9hZGVyID0gdGV4dHVyZUxvYWRlcjtcbiAgICB0aGlzLnBhZ2VzID0gW107XG4gICAgdGhpcy5yZWdpb25zID0gW107XG5cbiAgICB2YXIgcmVhZGVyID0gbmV3IHNwaW5lLkF0bGFzUmVhZGVyKGF0bGFzVGV4dCk7XG4gICAgdmFyIHR1cGxlID0gW107XG4gICAgdHVwbGUubGVuZ3RoID0gNDtcbiAgICB2YXIgcGFnZSA9IG51bGw7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGxpbmUgPSByZWFkZXIucmVhZExpbmUoKTtcbiAgICAgICAgaWYgKGxpbmUgPT0gbnVsbCkgYnJlYWs7XG4gICAgICAgIGxpbmUgPSByZWFkZXIudHJpbShsaW5lKTtcbiAgICAgICAgaWYgKCFsaW5lLmxlbmd0aClcbiAgICAgICAgICAgIHBhZ2UgPSBudWxsO1xuICAgICAgICBlbHNlIGlmICghcGFnZSkge1xuICAgICAgICAgICAgcGFnZSA9IG5ldyBzcGluZS5BdGxhc1BhZ2UoKTtcbiAgICAgICAgICAgIHBhZ2UubmFtZSA9IGxpbmU7XG5cbiAgICAgICAgICAgIHBhZ2UuZm9ybWF0ID0gc3BpbmUuQXRsYXMuRm9ybWF0W3JlYWRlci5yZWFkVmFsdWUoKV07XG5cbiAgICAgICAgICAgIHJlYWRlci5yZWFkVHVwbGUodHVwbGUpO1xuICAgICAgICAgICAgcGFnZS5taW5GaWx0ZXIgPSBzcGluZS5BdGxhcy5UZXh0dXJlRmlsdGVyW3R1cGxlWzBdXTtcbiAgICAgICAgICAgIHBhZ2UubWFnRmlsdGVyID0gc3BpbmUuQXRsYXMuVGV4dHVyZUZpbHRlclt0dXBsZVsxXV07XG5cbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSByZWFkZXIucmVhZFZhbHVlKCk7XG4gICAgICAgICAgICBwYWdlLnVXcmFwID0gc3BpbmUuQXRsYXMuVGV4dHVyZVdyYXAuY2xhbXBUb0VkZ2U7XG4gICAgICAgICAgICBwYWdlLnZXcmFwID0gc3BpbmUuQXRsYXMuVGV4dHVyZVdyYXAuY2xhbXBUb0VkZ2U7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09IFwieFwiKVxuICAgICAgICAgICAgICAgIHBhZ2UudVdyYXAgPSBzcGluZS5BdGxhcy5UZXh0dXJlV3JhcC5yZXBlYXQ7XG4gICAgICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT0gXCJ5XCIpXG4gICAgICAgICAgICAgICAgcGFnZS52V3JhcCA9IHNwaW5lLkF0bGFzLlRleHR1cmVXcmFwLnJlcGVhdDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBcInh5XCIpXG4gICAgICAgICAgICAgICAgcGFnZS51V3JhcCA9IHBhZ2UudldyYXAgPSBzcGluZS5BdGxhcy5UZXh0dXJlV3JhcC5yZXBlYXQ7XG5cbiAgICAgICAgICAgIHRleHR1cmVMb2FkZXIubG9hZChwYWdlLCBsaW5lKTtcblxuICAgICAgICAgICAgdGhpcy5wYWdlcy5wdXNoKHBhZ2UpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVnaW9uID0gbmV3IHNwaW5lLkF0bGFzUmVnaW9uKCk7XG4gICAgICAgICAgICByZWdpb24ubmFtZSA9IGxpbmU7XG4gICAgICAgICAgICByZWdpb24ucGFnZSA9IHBhZ2U7XG5cbiAgICAgICAgICAgIHJlZ2lvbi5yb3RhdGUgPSByZWFkZXIucmVhZFZhbHVlKCkgPT0gXCJ0cnVlXCI7XG5cbiAgICAgICAgICAgIHJlYWRlci5yZWFkVHVwbGUodHVwbGUpO1xuICAgICAgICAgICAgdmFyIHggPSBwYXJzZUludCh0dXBsZVswXSwgMTApO1xuICAgICAgICAgICAgdmFyIHkgPSBwYXJzZUludCh0dXBsZVsxXSwgMTApO1xuXG4gICAgICAgICAgICByZWFkZXIucmVhZFR1cGxlKHR1cGxlKTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHBhcnNlSW50KHR1cGxlWzBdLCAxMCk7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcGFyc2VJbnQodHVwbGVbMV0sIDEwKTtcblxuICAgICAgICAgICAgcmVnaW9uLnUgPSB4IC8gcGFnZS53aWR0aDtcbiAgICAgICAgICAgIHJlZ2lvbi52ID0geSAvIHBhZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHJlZ2lvbi5yb3RhdGUpIHtcbiAgICAgICAgICAgICAgICByZWdpb24udTIgPSAoeCArIGhlaWdodCkgLyBwYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgIHJlZ2lvbi52MiA9ICh5ICsgd2lkdGgpIC8gcGFnZS5oZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZ2lvbi51MiA9ICh4ICsgd2lkdGgpIC8gcGFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICByZWdpb24udjIgPSAoeSArIGhlaWdodCkgLyBwYWdlLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZ2lvbi54ID0geDtcbiAgICAgICAgICAgIHJlZ2lvbi55ID0geTtcbiAgICAgICAgICAgIHJlZ2lvbi53aWR0aCA9IE1hdGguYWJzKHdpZHRoKTtcbiAgICAgICAgICAgIHJlZ2lvbi5oZWlnaHQgPSBNYXRoLmFicyhoZWlnaHQpO1xuXG4gICAgICAgICAgICBpZiAocmVhZGVyLnJlYWRUdXBsZSh0dXBsZSkgPT0gNCkgeyAvLyBzcGxpdCBpcyBvcHRpb25hbFxuICAgICAgICAgICAgICAgIHJlZ2lvbi5zcGxpdHMgPSBbcGFyc2VJbnQodHVwbGVbMF0sIDEwKSwgcGFyc2VJbnQodHVwbGVbMV0sIDEwKSwgcGFyc2VJbnQodHVwbGVbMl0sIDEwKSwgcGFyc2VJbnQodHVwbGVbM10sIDEwKV07XG5cbiAgICAgICAgICAgICAgICBpZiAocmVhZGVyLnJlYWRUdXBsZSh0dXBsZSkgPT0gNCkgeyAvLyBwYWQgaXMgb3B0aW9uYWwsIGJ1dCBvbmx5IHByZXNlbnQgd2l0aCBzcGxpdHNcbiAgICAgICAgICAgICAgICAgICAgcmVnaW9uLnBhZHMgPSBbcGFyc2VJbnQodHVwbGVbMF0sIDEwKSwgcGFyc2VJbnQodHVwbGVbMV0sIDEwKSwgcGFyc2VJbnQodHVwbGVbMl0sIDEwKSwgcGFyc2VJbnQodHVwbGVbM10sIDEwKV07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRUdXBsZSh0dXBsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWdpb24ub3JpZ2luYWxXaWR0aCA9IHBhcnNlSW50KHR1cGxlWzBdLCAxMCk7XG4gICAgICAgICAgICByZWdpb24ub3JpZ2luYWxIZWlnaHQgPSBwYXJzZUludCh0dXBsZVsxXSwgMTApO1xuXG4gICAgICAgICAgICByZWFkZXIucmVhZFR1cGxlKHR1cGxlKTtcbiAgICAgICAgICAgIHJlZ2lvbi5vZmZzZXRYID0gcGFyc2VJbnQodHVwbGVbMF0sIDEwKTtcbiAgICAgICAgICAgIHJlZ2lvbi5vZmZzZXRZID0gcGFyc2VJbnQodHVwbGVbMV0sIDEwKTtcblxuICAgICAgICAgICAgcmVnaW9uLmluZGV4ID0gcGFyc2VJbnQocmVhZGVyLnJlYWRWYWx1ZSgpLCAxMCk7XG5cbiAgICAgICAgICAgIHRoaXMucmVnaW9ucy5wdXNoKHJlZ2lvbik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuc3BpbmUuQXRsYXMucHJvdG90eXBlID0ge1xuICAgIGZpbmRSZWdpb246IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciByZWdpb25zID0gdGhpcy5yZWdpb25zO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHJlZ2lvbnMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAgaWYgKHJlZ2lvbnNbaV0ubmFtZSA9PSBuYW1lKSByZXR1cm4gcmVnaW9uc1tpXTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYWdlcyA9IHRoaXMucGFnZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcGFnZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAgdGhpcy50ZXh0dXJlTG9hZGVyLnVubG9hZChwYWdlc1tpXS5yZW5kZXJlck9iamVjdCk7XG4gICAgfSxcbiAgICB1cGRhdGVVVnM6IGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgICAgIHZhciByZWdpb25zID0gdGhpcy5yZWdpb25zO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHJlZ2lvbnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmVnaW9uID0gcmVnaW9uc1tpXTtcbiAgICAgICAgICAgIGlmIChyZWdpb24ucGFnZSAhPSBwYWdlKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJlZ2lvbi51ID0gcmVnaW9uLnggLyBwYWdlLndpZHRoO1xuICAgICAgICAgICAgcmVnaW9uLnYgPSByZWdpb24ueSAvIHBhZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHJlZ2lvbi5yb3RhdGUpIHtcbiAgICAgICAgICAgICAgICByZWdpb24udTIgPSAocmVnaW9uLnggKyByZWdpb24uaGVpZ2h0KSAvIHBhZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgcmVnaW9uLnYyID0gKHJlZ2lvbi55ICsgcmVnaW9uLndpZHRoKSAvIHBhZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWdpb24udTIgPSAocmVnaW9uLnggKyByZWdpb24ud2lkdGgpIC8gcGFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICByZWdpb24udjIgPSAocmVnaW9uLnkgKyByZWdpb24uaGVpZ2h0KSAvIHBhZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuc3BpbmUuQXRsYXMuRm9ybWF0ID0ge1xuICAgIGFscGhhOiAwLFxuICAgIGludGVuc2l0eTogMSxcbiAgICBsdW1pbmFuY2VBbHBoYTogMixcbiAgICByZ2I1NjU6IDMsXG4gICAgcmdiYTQ0NDQ6IDQsXG4gICAgcmdiODg4OiA1LFxuICAgIHJnYmE4ODg4OiA2XG59O1xuXG5zcGluZS5BdGxhcy5UZXh0dXJlRmlsdGVyID0ge1xuICAgIG5lYXJlc3Q6IDAsXG4gICAgbGluZWFyOiAxLFxuICAgIG1pcE1hcDogMixcbiAgICBtaXBNYXBOZWFyZXN0TmVhcmVzdDogMyxcbiAgICBtaXBNYXBMaW5lYXJOZWFyZXN0OiA0LFxuICAgIG1pcE1hcE5lYXJlc3RMaW5lYXI6IDUsXG4gICAgbWlwTWFwTGluZWFyTGluZWFyOiA2XG59O1xuXG5zcGluZS5BdGxhcy5UZXh0dXJlV3JhcCA9IHtcbiAgICBtaXJyb3JlZFJlcGVhdDogMCxcbiAgICBjbGFtcFRvRWRnZTogMSxcbiAgICByZXBlYXQ6IDJcbn07XG5cbnNwaW5lLkF0bGFzUGFnZSA9IGZ1bmN0aW9uICgpIHt9O1xuc3BpbmUuQXRsYXNQYWdlLnByb3RvdHlwZSA9IHtcbiAgICBuYW1lOiBudWxsLFxuICAgIGZvcm1hdDogbnVsbCxcbiAgICBtaW5GaWx0ZXI6IG51bGwsXG4gICAgbWFnRmlsdGVyOiBudWxsLFxuICAgIHVXcmFwOiBudWxsLFxuICAgIHZXcmFwOiBudWxsLFxuICAgIHJlbmRlcmVyT2JqZWN0OiBudWxsLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxufTtcblxuc3BpbmUuQXRsYXNSZWdpb24gPSBmdW5jdGlvbiAoKSB7fTtcbnNwaW5lLkF0bGFzUmVnaW9uLnByb3RvdHlwZSA9IHtcbiAgICBwYWdlOiBudWxsLFxuICAgIG5hbWU6IG51bGwsXG4gICAgeDogMCwgeTogMCxcbiAgICB3aWR0aDogMCwgaGVpZ2h0OiAwLFxuICAgIHU6IDAsIHY6IDAsIHUyOiAwLCB2MjogMCxcbiAgICBvZmZzZXRYOiAwLCBvZmZzZXRZOiAwLFxuICAgIG9yaWdpbmFsV2lkdGg6IDAsIG9yaWdpbmFsSGVpZ2h0OiAwLFxuICAgIGluZGV4OiAwLFxuICAgIHJvdGF0ZTogZmFsc2UsXG4gICAgc3BsaXRzOiBudWxsLFxuICAgIHBhZHM6IG51bGxcbn07XG5cbnNwaW5lLkF0bGFzUmVhZGVyID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICB0aGlzLmxpbmVzID0gdGV4dC5zcGxpdCgvXFxyXFxufFxccnxcXG4vKTtcbn07XG5zcGluZS5BdGxhc1JlYWRlci5wcm90b3R5cGUgPSB7XG4gICAgaW5kZXg6IDAsXG4gICAgdHJpbTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBcIlwiKTtcbiAgICB9LFxuICAgIHJlYWRMaW5lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID49IHRoaXMubGluZXMubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZXNbdGhpcy5pbmRleCsrXTtcbiAgICB9LFxuICAgIHJlYWRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMucmVhZExpbmUoKTtcbiAgICAgICAgdmFyIGNvbG9uID0gbGluZS5pbmRleE9mKFwiOlwiKTtcbiAgICAgICAgaWYgKGNvbG9uID09IC0xKSB0aHJvdyBcIkludmFsaWQgbGluZTogXCIgKyBsaW5lO1xuICAgICAgICByZXR1cm4gdGhpcy50cmltKGxpbmUuc3Vic3RyaW5nKGNvbG9uICsgMSkpO1xuICAgIH0sXG4gICAgLyoqIFJldHVybnMgdGhlIG51bWJlciBvZiB0dXBsZSB2YWx1ZXMgcmVhZCAoMiBvciA0KS4gKi9cbiAgICByZWFkVHVwbGU6IGZ1bmN0aW9uICh0dXBsZSkge1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMucmVhZExpbmUoKTtcbiAgICAgICAgdmFyIGNvbG9uID0gbGluZS5pbmRleE9mKFwiOlwiKTtcbiAgICAgICAgaWYgKGNvbG9uID09IC0xKSB0aHJvdyBcIkludmFsaWQgbGluZTogXCIgKyBsaW5lO1xuICAgICAgICB2YXIgaSA9IDAsIGxhc3RNYXRjaD0gY29sb24gKyAxO1xuICAgICAgICBmb3IgKDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNvbW1hID0gbGluZS5pbmRleE9mKFwiLFwiLCBsYXN0TWF0Y2gpO1xuICAgICAgICAgICAgaWYgKGNvbW1hID09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpKSB0aHJvdyBcIkludmFsaWQgbGluZTogXCIgKyBsaW5lO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHVwbGVbaV0gPSB0aGlzLnRyaW0obGluZS5zdWJzdHIobGFzdE1hdGNoLCBjb21tYSAtIGxhc3RNYXRjaCkpO1xuICAgICAgICAgICAgbGFzdE1hdGNoID0gY29tbWEgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHR1cGxlW2ldID0gdGhpcy50cmltKGxpbmUuc3Vic3RyaW5nKGxhc3RNYXRjaCkpO1xuICAgICAgICByZXR1cm4gaSArIDE7XG4gICAgfVxufVxuXG5zcGluZS5BdGxhc0F0dGFjaG1lbnRMb2FkZXIgPSBmdW5jdGlvbiAoYXRsYXMpIHtcbiAgICB0aGlzLmF0bGFzID0gYXRsYXM7XG59XG5zcGluZS5BdGxhc0F0dGFjaG1lbnRMb2FkZXIucHJvdG90eXBlID0ge1xuICAgIG5ld0F0dGFjaG1lbnQ6IGZ1bmN0aW9uIChza2luLCB0eXBlLCBuYW1lKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIHNwaW5lLkF0dGFjaG1lbnRUeXBlLnJlZ2lvbjpcbiAgICAgICAgICAgIHZhciByZWdpb24gPSB0aGlzLmF0bGFzLmZpbmRSZWdpb24obmFtZSk7XG4gICAgICAgICAgICBpZiAoIXJlZ2lvbikgdGhyb3cgXCJSZWdpb24gbm90IGZvdW5kIGluIGF0bGFzOiBcIiArIG5hbWUgKyBcIiAoXCIgKyB0eXBlICsgXCIpXCI7XG4gICAgICAgICAgICB2YXIgYXR0YWNobWVudCA9IG5ldyBzcGluZS5SZWdpb25BdHRhY2htZW50KG5hbWUpO1xuICAgICAgICAgICAgYXR0YWNobWVudC5yZW5kZXJlck9iamVjdCA9IHJlZ2lvbjtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQuc2V0VVZzKHJlZ2lvbi51LCByZWdpb24udiwgcmVnaW9uLnUyLCByZWdpb24udjIsIHJlZ2lvbi5yb3RhdGUpO1xuICAgICAgICAgICAgYXR0YWNobWVudC5yZWdpb25PZmZzZXRYID0gcmVnaW9uLm9mZnNldFg7XG4gICAgICAgICAgICBhdHRhY2htZW50LnJlZ2lvbk9mZnNldFkgPSByZWdpb24ub2Zmc2V0WTtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQucmVnaW9uV2lkdGggPSByZWdpb24ud2lkdGg7XG4gICAgICAgICAgICBhdHRhY2htZW50LnJlZ2lvbkhlaWdodCA9IHJlZ2lvbi5oZWlnaHQ7XG4gICAgICAgICAgICBhdHRhY2htZW50LnJlZ2lvbk9yaWdpbmFsV2lkdGggPSByZWdpb24ub3JpZ2luYWxXaWR0aDtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQucmVnaW9uT3JpZ2luYWxIZWlnaHQgPSByZWdpb24ub3JpZ2luYWxIZWlnaHQ7XG4gICAgICAgICAgICByZXR1cm4gYXR0YWNobWVudDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBcIlVua25vd24gYXR0YWNobWVudCB0eXBlOiBcIiArIHR5cGU7XG4gICAgfVxufVxuXG5zcGluZS5Cb25lLnlEb3duID0gdHJ1ZTtcblBJWEkuQW5pbUNhY2hlID0ge307XG5cbi8qKlxuICogQSBjbGFzcyB0aGF0IGVuYWJsZXMgdGhlIHlvdSB0byBpbXBvcnQgYW5kIHJ1biB5b3VyIHNwaW5lIGFuaW1hdGlvbnMgaW4gcGl4aS5cbiAqIFNwaW5lIGFuaW1hdGlvbiBkYXRhIG5lZWRzIHRvIGJlIGxvYWRlZCB1c2luZyB0aGUgUElYSS5Bc3NldExvYWRlciBvciBQSVhJLlNwaW5lTG9hZGVyIGJlZm9yZSBpdCBjYW4gYmUgdXNlZCBieSB0aGlzIGNsYXNzXG4gKiBTZWUgZXhhbXBsZSAxMiAoaHR0cDovL3d3dy5nb29kYm95ZGlnaXRhbC5jb20vcGl4aWpzL2V4YW1wbGVzLzEyLykgdG8gc2VlIGEgd29ya2luZyBleGFtcGxlIGFuZCBjaGVjayBvdXQgdGhlIHNvdXJjZVxuICpcbiAqIEBjbGFzcyBTcGluZVxuICogQGV4dGVuZHMgRGlzcGxheU9iamVjdENvbnRhaW5lclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gdXJsIHtTdHJpbmd9IFRoZSB1cmwgb2YgdGhlIHNwaW5lIGFuaW0gZmlsZSB0byBiZSB1c2VkXG4gKi9cblBJWEkuU3BpbmUgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnNwaW5lRGF0YSA9IFBJWEkuQW5pbUNhY2hlW3VybF07XG5cbiAgICBpZiAoIXRoaXMuc3BpbmVEYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNwaW5lIGRhdGEgbXVzdCBiZSBwcmVsb2FkZWQgdXNpbmcgUElYSS5TcGluZUxvYWRlciBvciBQSVhJLkFzc2V0TG9hZGVyOiBcIiArIHVybCk7XG4gICAgfVxuXG4gICAgdGhpcy5za2VsZXRvbiA9IG5ldyBzcGluZS5Ta2VsZXRvbih0aGlzLnNwaW5lRGF0YSk7XG4gICAgdGhpcy5za2VsZXRvbi51cGRhdGVXb3JsZFRyYW5zZm9ybSgpO1xuXG4gICAgdGhpcy5zdGF0ZURhdGEgPSBuZXcgc3BpbmUuQW5pbWF0aW9uU3RhdGVEYXRhKHRoaXMuc3BpbmVEYXRhKTtcbiAgICB0aGlzLnN0YXRlID0gbmV3IHNwaW5lLkFuaW1hdGlvblN0YXRlKHRoaXMuc3RhdGVEYXRhKTtcblxuICAgIHRoaXMuc2xvdENvbnRhaW5lcnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGhpcy5za2VsZXRvbi5kcmF3T3JkZXIubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBzbG90ID0gdGhpcy5za2VsZXRvbi5kcmF3T3JkZXJbaV07XG4gICAgICAgIHZhciBhdHRhY2htZW50ID0gc2xvdC5hdHRhY2htZW50O1xuICAgICAgICB2YXIgc2xvdENvbnRhaW5lciA9IG5ldyBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIoKTtcbiAgICAgICAgdGhpcy5zbG90Q29udGFpbmVycy5wdXNoKHNsb3RDb250YWluZXIpO1xuICAgICAgICB0aGlzLmFkZENoaWxkKHNsb3RDb250YWluZXIpO1xuICAgICAgICBpZiAoIShhdHRhY2htZW50IGluc3RhbmNlb2Ygc3BpbmUuUmVnaW9uQXR0YWNobWVudCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzcHJpdGVOYW1lID0gYXR0YWNobWVudC5yZW5kZXJlck9iamVjdC5uYW1lO1xuICAgICAgICB2YXIgc3ByaXRlID0gdGhpcy5jcmVhdGVTcHJpdGUoc2xvdCwgYXR0YWNobWVudC5yZW5kZXJlck9iamVjdCk7XG4gICAgICAgIHNsb3QuY3VycmVudFNwcml0ZSA9IHNwcml0ZTtcbiAgICAgICAgc2xvdC5jdXJyZW50U3ByaXRlTmFtZSA9IHNwcml0ZU5hbWU7XG4gICAgICAgIHNsb3RDb250YWluZXIuYWRkQ2hpbGQoc3ByaXRlKTtcbiAgICB9XG59O1xuXG5QSVhJLlNwaW5lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZSk7XG5QSVhJLlNwaW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuU3BpbmU7XG5cbi8qXG4gKiBVcGRhdGVzIHRoZSBvYmplY3QgdHJhbnNmb3JtIGZvciByZW5kZXJpbmdcbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVRyYW5zZm9ybVxuICogQHByaXZhdGVcbiAqL1xuUElYSS5TcGluZS5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubGFzdFRpbWUgPSB0aGlzLmxhc3RUaW1lIHx8IERhdGUubm93KCk7XG4gICAgdmFyIHRpbWVEZWx0YSA9IChEYXRlLm5vdygpIC0gdGhpcy5sYXN0VGltZSkgKiAwLjAwMTtcbiAgICB0aGlzLmxhc3RUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLnN0YXRlLnVwZGF0ZSh0aW1lRGVsdGEpO1xuICAgIHRoaXMuc3RhdGUuYXBwbHkodGhpcy5za2VsZXRvbik7XG4gICAgdGhpcy5za2VsZXRvbi51cGRhdGVXb3JsZFRyYW5zZm9ybSgpO1xuXG4gICAgdmFyIGRyYXdPcmRlciA9IHRoaXMuc2tlbGV0b24uZHJhd09yZGVyO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gZHJhd09yZGVyLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICB2YXIgc2xvdCA9IGRyYXdPcmRlcltpXTtcbiAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSBzbG90LmF0dGFjaG1lbnQ7XG4gICAgICAgIHZhciBzbG90Q29udGFpbmVyID0gdGhpcy5zbG90Q29udGFpbmVyc1tpXTtcbiAgICAgICAgaWYgKCEoYXR0YWNobWVudCBpbnN0YW5jZW9mIHNwaW5lLlJlZ2lvbkF0dGFjaG1lbnQpKSB7XG4gICAgICAgICAgICBzbG90Q29udGFpbmVyLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF0dGFjaG1lbnQucmVuZGVyZXJPYmplY3QpIHtcbiAgICAgICAgICAgIGlmICghc2xvdC5jdXJyZW50U3ByaXRlTmFtZSB8fCBzbG90LmN1cnJlbnRTcHJpdGVOYW1lICE9IGF0dGFjaG1lbnQubmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBzcHJpdGVOYW1lID0gYXR0YWNobWVudC5yZW5kZXJlck9iamVjdC5uYW1lO1xuICAgICAgICAgICAgICAgIGlmIChzbG90LmN1cnJlbnRTcHJpdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzbG90LmN1cnJlbnRTcHJpdGUudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzbG90LnNwcml0ZXMgPSBzbG90LnNwcml0ZXMgfHwge307XG4gICAgICAgICAgICAgICAgaWYgKHNsb3Quc3ByaXRlc1tzcHJpdGVOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsb3Quc3ByaXRlc1tzcHJpdGVOYW1lXS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ByaXRlID0gdGhpcy5jcmVhdGVTcHJpdGUoc2xvdCwgYXR0YWNobWVudC5yZW5kZXJlck9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHNsb3RDb250YWluZXIuYWRkQ2hpbGQoc3ByaXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2xvdC5jdXJyZW50U3ByaXRlID0gc2xvdC5zcHJpdGVzW3Nwcml0ZU5hbWVdO1xuICAgICAgICAgICAgICAgIHNsb3QuY3VycmVudFNwcml0ZU5hbWUgPSBzcHJpdGVOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNsb3RDb250YWluZXIudmlzaWJsZSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGJvbmUgPSBzbG90LmJvbmU7XG5cbiAgICAgICAgc2xvdENvbnRhaW5lci5wb3NpdGlvbi54ID0gYm9uZS53b3JsZFggKyBhdHRhY2htZW50LnggKiBib25lLm0wMCArIGF0dGFjaG1lbnQueSAqIGJvbmUubTAxO1xuICAgICAgICBzbG90Q29udGFpbmVyLnBvc2l0aW9uLnkgPSBib25lLndvcmxkWSArIGF0dGFjaG1lbnQueCAqIGJvbmUubTEwICsgYXR0YWNobWVudC55ICogYm9uZS5tMTE7XG4gICAgICAgIHNsb3RDb250YWluZXIuc2NhbGUueCA9IGJvbmUud29ybGRTY2FsZVg7XG4gICAgICAgIHNsb3RDb250YWluZXIuc2NhbGUueSA9IGJvbmUud29ybGRTY2FsZVk7XG5cbiAgICAgICAgc2xvdENvbnRhaW5lci5yb3RhdGlvbiA9IC0oc2xvdC5ib25lLndvcmxkUm90YXRpb24gKiBNYXRoLlBJIC8gMTgwKTtcblxuICAgICAgICBzbG90Q29udGFpbmVyLmFscGhhID0gc2xvdC5hO1xuICAgICAgICBzbG90LmN1cnJlbnRTcHJpdGUudGludCA9IFBJWEkucmdiMmhleChbc2xvdC5yLHNsb3QuZyxzbG90LmJdKTtcbiAgICB9XG5cbiAgICBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybS5jYWxsKHRoaXMpO1xufTtcblxuXG5QSVhJLlNwaW5lLnByb3RvdHlwZS5jcmVhdGVTcHJpdGUgPSBmdW5jdGlvbiAoc2xvdCwgZGVzY3JpcHRvcikge1xuICAgIHZhciBuYW1lID0gUElYSS5UZXh0dXJlQ2FjaGVbZGVzY3JpcHRvci5uYW1lXSA/IGRlc2NyaXB0b3IubmFtZSA6IGRlc2NyaXB0b3IubmFtZSArIFwiLnBuZ1wiO1xuICAgIHZhciBzcHJpdGUgPSBuZXcgUElYSS5TcHJpdGUoUElYSS5UZXh0dXJlLmZyb21GcmFtZShuYW1lKSk7XG4gICAgc3ByaXRlLnNjYWxlID0gZGVzY3JpcHRvci5zY2FsZTtcbiAgICBzcHJpdGUucm90YXRpb24gPSBkZXNjcmlwdG9yLnJvdGF0aW9uO1xuICAgIHNwcml0ZS5hbmNob3IueCA9IHNwcml0ZS5hbmNob3IueSA9IDAuNTtcblxuICAgIHNsb3Quc3ByaXRlcyA9IHNsb3Quc3ByaXRlcyB8fCB7fTtcbiAgICBzbG90LnNwcml0ZXNbZGVzY3JpcHRvci5uYW1lXSA9IHNwcml0ZTtcbiAgICByZXR1cm4gc3ByaXRlO1xufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG5QSVhJLkJhc2VUZXh0dXJlQ2FjaGUgPSB7fTtcblBJWEkudGV4dHVyZXNUb1VwZGF0ZSA9IFtdO1xuUElYSS50ZXh0dXJlc1RvRGVzdHJveSA9IFtdO1xuXG5QSVhJLkJhc2VUZXh0dXJlQ2FjaGVJZEdlbmVyYXRvciA9IDA7XG5cbi8qKlxuICogQSB0ZXh0dXJlIHN0b3JlcyB0aGUgaW5mb3JtYXRpb24gdGhhdCByZXByZXNlbnRzIGFuIGltYWdlLiBBbGwgdGV4dHVyZXMgaGF2ZSBhIGJhc2UgdGV4dHVyZVxuICpcbiAqIEBjbGFzcyBCYXNlVGV4dHVyZVxuICogQHVzZXMgRXZlbnRUYXJnZXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHNvdXJjZSB7U3RyaW5nfSB0aGUgc291cmNlIG9iamVjdCAoaW1hZ2Ugb3IgY2FudmFzKVxuICogQHBhcmFtIHNjYWxlTW9kZSB7TnVtYmVyfSBTaG91bGQgYmUgb25lIG9mIHRoZSBQSVhJLnNjYWxlTW9kZSBjb25zdHNcbiAqL1xuUElYSS5CYXNlVGV4dHVyZSA9IGZ1bmN0aW9uKHNvdXJjZSwgc2NhbGVNb2RlKVxue1xuICAgIFBJWEkuRXZlbnRUYXJnZXQuY2FsbCggdGhpcyApO1xuXG4gICAgLyoqXG4gICAgICogW3JlYWQtb25seV0gVGhlIHdpZHRoIG9mIHRoZSBiYXNlIHRleHR1cmUgc2V0IHdoZW4gdGhlIGltYWdlIGhhcyBsb2FkZWRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB3aWR0aFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSAxMDA7XG5cbiAgICAvKipcbiAgICAgKiBbcmVhZC1vbmx5XSBUaGUgaGVpZ2h0IG9mIHRoZSBiYXNlIHRleHR1cmUgc2V0IHdoZW4gdGhlIGltYWdlIGhhcyBsb2FkZWRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBoZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IDEwMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY2FsZSBtb2RlIHRvIGFwcGx5IHdoZW4gc2NhbGluZyB0aGlzIHRleHR1cmVcbiAgICAgKiBAcHJvcGVydHkgc2NhbGVNb2RlXG4gICAgICogQHR5cGUgUElYSS5zY2FsZU1vZGVzXG4gICAgICogQGRlZmF1bHQgUElYSS5zY2FsZU1vZGVzLkxJTkVBUlxuICAgICAqL1xuICAgIHRoaXMuc2NhbGVNb2RlID0gc2NhbGVNb2RlIHx8IFBJWEkuc2NhbGVNb2Rlcy5ERUZBVUxUO1xuXG4gICAgLyoqXG4gICAgICogW3JlYWQtb25seV0gRGVzY3JpYmVzIGlmIHRoZSBiYXNlIHRleHR1cmUgaGFzIGxvYWRlZCBvciBub3RcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBoYXNMb2FkZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5oYXNMb2FkZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzb3VyY2UgdGhhdCBpcyBsb2FkZWQgdG8gY3JlYXRlIHRoZSB0ZXh0dXJlXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgc291cmNlXG4gICAgICogQHR5cGUgSW1hZ2VcbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcblxuICAgIC8vVE9ETyB3aWxsIGJlIHVzZWQgZm9yIGZ1dGVyIHBpeGkgMS41Li4uXG4gICAgdGhpcy5pZCA9IFBJWEkuQmFzZVRleHR1cmVDYWNoZUlkR2VuZXJhdG9yKys7XG5cbiAgICAvKipcbiAgICAgKiBDb250cm9scyBpZiBSR0IgY2hhbm5lbHMgc2hvdWxkIGJlIHByZW11bHRpcGxpZWQgYnkgQWxwaGEgIChXZWJHTCBvbmx5KVxuICAgICAqXG4gICAgICogQHByb3BlcnR5XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IFRSVUVcbiAgICAqL1xuICAgIHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gdHJ1ZTtcblxuICAgIC8vIHVzZWQgZm9yIHdlYkdMXG4gICAgdGhpcy5fZ2xUZXh0dXJlcyA9IFtdO1xuICAgIFxuICAgIC8vIHVzZWQgZm9yIHdlYkdMIHRldHVyZSB1cGRhdGVpbmcuLi5cbiAgICB0aGlzLl9kaXJ0eSA9IFtdO1xuICAgIFxuICAgIGlmKCFzb3VyY2UpcmV0dXJuO1xuXG4gICAgaWYoKHRoaXMuc291cmNlLmNvbXBsZXRlIHx8IHRoaXMuc291cmNlLmdldENvbnRleHQpICYmIHRoaXMuc291cmNlLndpZHRoICYmIHRoaXMuc291cmNlLmhlaWdodClcbiAgICB7XG4gICAgICAgIHRoaXMuaGFzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuc291cmNlLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuc291cmNlLmhlaWdodDtcblxuICAgICAgICBQSVhJLnRleHR1cmVzVG9VcGRhdGUucHVzaCh0aGlzKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcblxuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgICAgICB0aGlzLnNvdXJjZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgc2NvcGUuaGFzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHNjb3BlLndpZHRoID0gc2NvcGUuc291cmNlLndpZHRoO1xuICAgICAgICAgICAgc2NvcGUuaGVpZ2h0ID0gc2NvcGUuc291cmNlLmhlaWdodDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY29wZS5fZ2xUZXh0dXJlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzY29wZS5fZGlydHlbaV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhZGQgaXQgdG8gc29tZXdoZXJlLi4uXG4gICAgICAgICAgICBzY29wZS5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdsb2FkZWQnLCBjb250ZW50OiBzY29wZSB9ICk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc291cmNlLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNjb3BlLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Vycm9yJywgY29udGVudDogc2NvcGUgfSApO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuaW1hZ2VVcmwgPSBudWxsO1xuICAgIHRoaXMuX3Bvd2VyT2YyID0gZmFsc2U7XG5cbiAgICBcblxufTtcblxuUElYSS5CYXNlVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkJhc2VUZXh0dXJlO1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoaXMgYmFzZSB0ZXh0dXJlXG4gKlxuICogQG1ldGhvZCBkZXN0cm95XG4gKi9cblBJWEkuQmFzZVRleHR1cmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXG57XG4gICAgaWYodGhpcy5pbWFnZVVybClcbiAgICB7XG4gICAgICAgIGRlbGV0ZSBQSVhJLkJhc2VUZXh0dXJlQ2FjaGVbdGhpcy5pbWFnZVVybF07XG4gICAgICAgIGRlbGV0ZSBQSVhJLlRleHR1cmVDYWNoZVt0aGlzLmltYWdlVXJsXTtcbiAgICAgICAgdGhpcy5pbWFnZVVybCA9IG51bGw7XG4gICAgICAgIHRoaXMuc291cmNlLnNyYyA9IG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuc291cmNlICYmIHRoaXMuc291cmNlLl9waXhpSWQpXG4gICAge1xuICAgICAgICBkZWxldGUgUElYSS5CYXNlVGV4dHVyZUNhY2hlW3RoaXMuc291cmNlLl9waXhpSWRdO1xuICAgIH1cbiAgICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gICAgUElYSS50ZXh0dXJlc1RvRGVzdHJveS5wdXNoKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSBzb3VyY2UgaW1hZ2Ugb2YgdGhlIHRleHR1cmVcbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVNvdXJjZUltYWdlXG4gKiBAcGFyYW0gbmV3U3JjIHtTdHJpbmd9IHRoZSBwYXRoIG9mIHRoZSBpbWFnZVxuICovXG5QSVhJLkJhc2VUZXh0dXJlLnByb3RvdHlwZS51cGRhdGVTb3VyY2VJbWFnZSA9IGZ1bmN0aW9uKG5ld1NyYylcbntcbiAgICB0aGlzLmhhc0xvYWRlZCA9IGZhbHNlO1xuICAgIHRoaXMuc291cmNlLnNyYyA9IG51bGw7XG4gICAgdGhpcy5zb3VyY2Uuc3JjID0gbmV3U3JjO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgYmFzZSB0ZXh0dXJlIGJhc2VkIG9uIGFuIGltYWdlIHVybFxuICogSWYgdGhlIGltYWdlIGlzIG5vdCBpbiB0aGUgYmFzZSB0ZXh0dXJlIGNhY2hlIGl0IHdpbGwgYmUgY3JlYXRlZCBhbmQgbG9hZGVkXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBmcm9tSW1hZ2VcbiAqIEBwYXJhbSBpbWFnZVVybCB7U3RyaW5nfSBUaGUgaW1hZ2UgdXJsIG9mIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gY3Jvc3NvcmlnaW4ge0Jvb2xlYW59IFxuICogQHBhcmFtIHNjYWxlTW9kZSB7TnVtYmVyfSBTaG91bGQgYmUgb25lIG9mIHRoZSBQSVhJLnNjYWxlTW9kZSBjb25zdHNcbiAqIEByZXR1cm4gQmFzZVRleHR1cmVcbiAqL1xuUElYSS5CYXNlVGV4dHVyZS5mcm9tSW1hZ2UgPSBmdW5jdGlvbihpbWFnZVVybCwgY3Jvc3NvcmlnaW4sIHNjYWxlTW9kZSlcbntcbiAgICB2YXIgYmFzZVRleHR1cmUgPSBQSVhJLkJhc2VUZXh0dXJlQ2FjaGVbaW1hZ2VVcmxdO1xuICAgIFxuICAgIGlmKGNyb3Nzb3JpZ2luID09PSB1bmRlZmluZWQgJiYgaW1hZ2VVcmwuaW5kZXhPZignZGF0YTonKSA9PT0gLTEpIGNyb3Nzb3JpZ2luID0gdHJ1ZTtcblxuICAgIGlmKCFiYXNlVGV4dHVyZSlcbiAgICB7XG4gICAgICAgIC8vIG5ldyBJbWFnZSgpIGJyZWFrcyB0ZXggbG9hZGluZyBpbiBzb21lIHZlcnNpb25zIG9mIENocm9tZS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yMzgwNzFcbiAgICAgICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7Ly9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgaWYgKGNyb3Nzb3JpZ2luKVxuICAgICAgICB7XG4gICAgICAgICAgICBpbWFnZS5jcm9zc09yaWdpbiA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGltYWdlLnNyYyA9IGltYWdlVXJsO1xuICAgICAgICBiYXNlVGV4dHVyZSA9IG5ldyBQSVhJLkJhc2VUZXh0dXJlKGltYWdlLCBzY2FsZU1vZGUpO1xuICAgICAgICBiYXNlVGV4dHVyZS5pbWFnZVVybCA9IGltYWdlVXJsO1xuICAgICAgICBQSVhJLkJhc2VUZXh0dXJlQ2FjaGVbaW1hZ2VVcmxdID0gYmFzZVRleHR1cmU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2VUZXh0dXJlO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgYmFzZSB0ZXh0dXJlIGJhc2VkIG9uIGEgY2FudmFzIGVsZW1lbnRcbiAqIElmIHRoZSBpbWFnZSBpcyBub3QgaW4gdGhlIGJhc2UgdGV4dHVyZSBjYWNoZSBpdCB3aWxsIGJlIGNyZWF0ZWQgYW5kIGxvYWRlZFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZnJvbUNhbnZhc1xuICogQHBhcmFtIGNhbnZhcyB7Q2FudmFzfSBUaGUgY2FudmFzIGVsZW1lbnQgc291cmNlIG9mIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gc2NhbGVNb2RlIHtOdW1iZXJ9IFNob3VsZCBiZSBvbmUgb2YgdGhlIFBJWEkuc2NhbGVNb2RlIGNvbnN0c1xuICogQHJldHVybiBCYXNlVGV4dHVyZVxuICovXG5QSVhJLkJhc2VUZXh0dXJlLmZyb21DYW52YXMgPSBmdW5jdGlvbihjYW52YXMsIHNjYWxlTW9kZSlcbntcbiAgICBpZighY2FudmFzLl9waXhpSWQpXG4gICAge1xuICAgICAgICBjYW52YXMuX3BpeGlJZCA9ICdjYW52YXNfJyArIFBJWEkuVGV4dHVyZUNhY2hlSWRHZW5lcmF0b3IrKztcbiAgICB9XG5cbiAgICB2YXIgYmFzZVRleHR1cmUgPSBQSVhJLkJhc2VUZXh0dXJlQ2FjaGVbY2FudmFzLl9waXhpSWRdO1xuXG4gICAgaWYoIWJhc2VUZXh0dXJlKVxuICAgIHtcbiAgICAgICAgYmFzZVRleHR1cmUgPSBuZXcgUElYSS5CYXNlVGV4dHVyZShjYW52YXMsIHNjYWxlTW9kZSk7XG4gICAgICAgIFBJWEkuQmFzZVRleHR1cmVDYWNoZVtjYW52YXMuX3BpeGlJZF0gPSBiYXNlVGV4dHVyZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZVRleHR1cmU7XG59O1xuXG5cblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG5QSVhJLlRleHR1cmVDYWNoZSA9IHt9O1xuUElYSS5GcmFtZUNhY2hlID0ge307XG5cblBJWEkuVGV4dHVyZUNhY2hlSWRHZW5lcmF0b3IgPSAwO1xuXG4vKipcbiAqIEEgdGV4dHVyZSBzdG9yZXMgdGhlIGluZm9ybWF0aW9uIHRoYXQgcmVwcmVzZW50cyBhbiBpbWFnZSBvciBwYXJ0IG9mIGFuIGltYWdlLiBJdCBjYW5ub3QgYmUgYWRkZWRcbiAqIHRvIHRoZSBkaXNwbGF5IGxpc3QgZGlyZWN0bHkuIFRvIGRvIHRoaXMgdXNlIFBJWEkuU3ByaXRlLiBJZiBubyBmcmFtZSBpcyBwcm92aWRlZCB0aGVuIHRoZSB3aG9sZSBpbWFnZSBpcyB1c2VkXG4gKlxuICogQGNsYXNzIFRleHR1cmVcbiAqIEB1c2VzIEV2ZW50VGFyZ2V0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSBiYXNlVGV4dHVyZSB7QmFzZVRleHR1cmV9IFRoZSBiYXNlIHRleHR1cmUgc291cmNlIHRvIGNyZWF0ZSB0aGUgdGV4dHVyZSBmcm9tXG4gKiBAcGFyYW0gZnJhbWUge1JlY3RhbmdsZX0gVGhlIHJlY3RhbmdsZSBmcmFtZSBvZiB0aGUgdGV4dHVyZSB0byBzaG93XG4gKi9cblBJWEkuVGV4dHVyZSA9IGZ1bmN0aW9uKGJhc2VUZXh0dXJlLCBmcmFtZSlcbntcbiAgICBQSVhJLkV2ZW50VGFyZ2V0LmNhbGwoIHRoaXMgKTtcblxuICAgIC8qKlxuICAgICAqIERvZXMgdGhpcyBUZXh0dXJlIGhhdmUgYW55IGZyYW1lIGRhdGEgYXNzaWduZWQgdG8gaXQ/XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbm9GcmFtZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLm5vRnJhbWUgPSBmYWxzZTtcblxuICAgIGlmICghZnJhbWUpXG4gICAge1xuICAgICAgICB0aGlzLm5vRnJhbWUgPSB0cnVlO1xuICAgICAgICBmcmFtZSA9IG5ldyBQSVhJLlJlY3RhbmdsZSgwLDAsMSwxKTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZVRleHR1cmUgaW5zdGFuY2VvZiBQSVhJLlRleHR1cmUpXG4gICAge1xuICAgICAgICBiYXNlVGV4dHVyZSA9IGJhc2VUZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIHRleHR1cmUgdGhhdCB0aGlzIHRleHR1cmUgdXNlcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBiYXNlVGV4dHVyZVxuICAgICAqIEB0eXBlIEJhc2VUZXh0dXJlXG4gICAgICovXG4gICAgdGhpcy5iYXNlVGV4dHVyZSA9IGJhc2VUZXh0dXJlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYW1lIHNwZWNpZmllcyB0aGUgcmVnaW9uIG9mIHRoZSBiYXNlIHRleHR1cmUgdGhhdCB0aGlzIHRleHR1cmUgdXNlc1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IGZyYW1lXG4gICAgICogQHR5cGUgUmVjdGFuZ2xlXG4gICAgICovXG4gICAgdGhpcy5mcmFtZSA9IGZyYW1lO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRyaW0gcG9pbnRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0cmltXG4gICAgICogQHR5cGUgUmVjdGFuZ2xlXG4gICAgICovXG4gICAgdGhpcy50cmltID0gbnVsbDtcbiAgICBcbiAgICAvKipcbiAgICAgKiBUaGlzIHdpbGwgbGV0IHRoZSByZW5kZXJlciBrbm93IGlmIHRoZSB0ZXh0dXJlIGlzIHZhbGlkLiBJZiBpdHMgbm90IHRoZW4gaXQgY2Fubm90IGJlIHJlbmRlcmVkLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHZhbGlkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250ZXh0IHNjb3BlIHVuZGVyIHdoaWNoIGV2ZW50cyBhcmUgcnVuLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHNjb3BlXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgdGhpcy5zY29wZSA9IHRoaXM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgV2ViR0wgVVYgZGF0YSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IF91dnNcbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICB0aGlzLl91dnMgPSBudWxsO1xuICAgIFxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgVGV4dHVyZSBpbiBwaXhlbHMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgd2lkdGhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLndpZHRoID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIFRleHR1cmUgaW4gcGl4ZWxzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGhlaWdodFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGFyZWEgb2YgdGhlIEJhc2VUZXh0dXJlIGltYWdlIHRvIGFjdHVhbGx5IGNvcHkgdG8gdGhlIENhbnZhcyAvIFdlYkdMIHdoZW4gcmVuZGVyaW5nLFxuICAgICAqIGlycmVzcGVjdGl2ZSBvZiB0aGUgYWN0dWFsIGZyYW1lIHNpemUgb3IgcGxhY2VtZW50ICh3aGljaCBjYW4gYmUgaW5mbHVlbmNlZCBieSB0cmltbWVkIHRleHR1cmUgYXRsYXNlcylcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjcm9wXG4gICAgICogQHR5cGUgUmVjdGFuZ2xlXG4gICAgICovXG4gICAgdGhpcy5jcm9wID0gbmV3IFBJWEkuUmVjdGFuZ2xlKDAsIDAsIDEsIDEpO1xuXG4gICAgaWYgKGJhc2VUZXh0dXJlLmhhc0xvYWRlZClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLm5vRnJhbWUpIGZyYW1lID0gbmV3IFBJWEkuUmVjdGFuZ2xlKDAsIDAsIGJhc2VUZXh0dXJlLndpZHRoLCBiYXNlVGV4dHVyZS5oZWlnaHQpO1xuICAgICAgICB0aGlzLnNldEZyYW1lKGZyYW1lKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICAgICAgYmFzZVRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkJywgZnVuY3Rpb24oKXsgc2NvcGUub25CYXNlVGV4dHVyZUxvYWRlZCgpOyB9KTtcbiAgICB9XG59O1xuXG5QSVhJLlRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5UZXh0dXJlO1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHRoZSBiYXNlIHRleHR1cmUgaXMgbG9hZGVkXG4gKlxuICogQG1ldGhvZCBvbkJhc2VUZXh0dXJlTG9hZGVkXG4gKiBAcGFyYW0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuVGV4dHVyZS5wcm90b3R5cGUub25CYXNlVGV4dHVyZUxvYWRlZCA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgYmFzZVRleHR1cmUgPSB0aGlzLmJhc2VUZXh0dXJlO1xuICAgIGJhc2VUZXh0dXJlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWRlZCcsIHRoaXMub25Mb2FkZWQpO1xuXG4gICAgaWYgKHRoaXMubm9GcmFtZSkgdGhpcy5mcmFtZSA9IG5ldyBQSVhJLlJlY3RhbmdsZSgwLCAwLCBiYXNlVGV4dHVyZS53aWR0aCwgYmFzZVRleHR1cmUuaGVpZ2h0KTtcbiAgICBcbiAgICB0aGlzLnNldEZyYW1lKHRoaXMuZnJhbWUpO1xuXG4gICAgdGhpcy5zY29wZS5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICd1cGRhdGUnLCBjb250ZW50OiB0aGlzIH0gKTtcbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhpcyB0ZXh0dXJlXG4gKlxuICogQG1ldGhvZCBkZXN0cm95XG4gKiBAcGFyYW0gZGVzdHJveUJhc2Uge0Jvb2xlYW59IFdoZXRoZXIgdG8gZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIGFzIHdlbGxcbiAqL1xuUElYSS5UZXh0dXJlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oZGVzdHJveUJhc2UpXG57XG4gICAgaWYgKGRlc3Ryb3lCYXNlKSB0aGlzLmJhc2VUZXh0dXJlLmRlc3Ryb3koKTtcblxuICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSByZWdpb24gb2YgdGhlIGJhc2VUZXh0dXJlIHRoYXQgdGhpcyB0ZXh0dXJlIHdpbGwgdXNlLlxuICpcbiAqIEBtZXRob2Qgc2V0RnJhbWVcbiAqIEBwYXJhbSBmcmFtZSB7UmVjdGFuZ2xlfSBUaGUgZnJhbWUgb2YgdGhlIHRleHR1cmUgdG8gc2V0IGl0IHRvXG4gKi9cblBJWEkuVGV4dHVyZS5wcm90b3R5cGUuc2V0RnJhbWUgPSBmdW5jdGlvbihmcmFtZSlcbntcbiAgICB0aGlzLm5vRnJhbWUgPSBmYWxzZTtcblxuICAgIHRoaXMuZnJhbWUgPSBmcmFtZTtcbiAgICB0aGlzLndpZHRoID0gZnJhbWUud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBmcmFtZS5oZWlnaHQ7XG5cbiAgICB0aGlzLmNyb3AueCA9IGZyYW1lLng7XG4gICAgdGhpcy5jcm9wLnkgPSBmcmFtZS55O1xuICAgIHRoaXMuY3JvcC53aWR0aCA9IGZyYW1lLndpZHRoO1xuICAgIHRoaXMuY3JvcC5oZWlnaHQgPSBmcmFtZS5oZWlnaHQ7XG5cbiAgICBpZiAoIXRoaXMudHJpbSAmJiAoZnJhbWUueCArIGZyYW1lLndpZHRoID4gdGhpcy5iYXNlVGV4dHVyZS53aWR0aCB8fCBmcmFtZS55ICsgZnJhbWUuaGVpZ2h0ID4gdGhpcy5iYXNlVGV4dHVyZS5oZWlnaHQpKVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0dXJlIEVycm9yOiBmcmFtZSBkb2VzIG5vdCBmaXQgaW5zaWRlIHRoZSBiYXNlIFRleHR1cmUgZGltZW5zaW9ucyAnICsgdGhpcyk7XG4gICAgfVxuXG4gICAgdGhpcy52YWxpZCA9IGZyYW1lICYmIGZyYW1lLndpZHRoICYmIGZyYW1lLmhlaWdodCAmJiB0aGlzLmJhc2VUZXh0dXJlLnNvdXJjZSAmJiB0aGlzLmJhc2VUZXh0dXJlLmhhc0xvYWRlZDtcblxuICAgIGlmICh0aGlzLnRyaW0pXG4gICAge1xuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy50cmltLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMudHJpbS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuZnJhbWUud2lkdGggPSB0aGlzLnRyaW0ud2lkdGg7XG4gICAgICAgIHRoaXMuZnJhbWUuaGVpZ2h0ID0gdGhpcy50cmltLmhlaWdodDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy52YWxpZCkgUElYSS5UZXh0dXJlLmZyYW1lVXBkYXRlcy5wdXNoKHRoaXMpO1xuXG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGludGVybmFsIFdlYkdMIFVWIGNhY2hlLlxuICpcbiAqIEBtZXRob2QgX3VwZGF0ZVdlYkdMdXZzXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlRleHR1cmUucHJvdG90eXBlLl91cGRhdGVXZWJHTHV2cyA9IGZ1bmN0aW9uKClcbntcbiAgICBpZighdGhpcy5fdXZzKXRoaXMuX3V2cyA9IG5ldyBQSVhJLlRleHR1cmVVdnMoKTtcblxuICAgIHZhciBmcmFtZSA9IHRoaXMuY3JvcDtcbiAgICB2YXIgdHcgPSB0aGlzLmJhc2VUZXh0dXJlLndpZHRoO1xuICAgIHZhciB0aCA9IHRoaXMuYmFzZVRleHR1cmUuaGVpZ2h0O1xuXG4gICAgdGhpcy5fdXZzLngwID0gZnJhbWUueCAvIHR3O1xuICAgIHRoaXMuX3V2cy55MCA9IGZyYW1lLnkgLyB0aDtcblxuICAgIHRoaXMuX3V2cy54MSA9IChmcmFtZS54ICsgZnJhbWUud2lkdGgpIC8gdHc7XG4gICAgdGhpcy5fdXZzLnkxID0gZnJhbWUueSAvIHRoO1xuXG4gICAgdGhpcy5fdXZzLngyID0gKGZyYW1lLnggKyBmcmFtZS53aWR0aCkgLyB0dztcbiAgICB0aGlzLl91dnMueTIgPSAoZnJhbWUueSArIGZyYW1lLmhlaWdodCkgLyB0aDtcblxuICAgIHRoaXMuX3V2cy54MyA9IGZyYW1lLnggLyB0dztcbiAgICB0aGlzLl91dnMueTMgPSAoZnJhbWUueSArIGZyYW1lLmhlaWdodCkgLyB0aDtcblxufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdGV4dHVyZSBiYXNlZCBvbiBhbiBpbWFnZSB1cmxcbiAqIElmIHRoZSBpbWFnZSBpcyBub3QgaW4gdGhlIHRleHR1cmUgY2FjaGUgaXQgd2lsbCBiZSAgY3JlYXRlZCBhbmQgbG9hZGVkXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBmcm9tSW1hZ2VcbiAqIEBwYXJhbSBpbWFnZVVybCB7U3RyaW5nfSBUaGUgaW1hZ2UgdXJsIG9mIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gY3Jvc3NvcmlnaW4ge0Jvb2xlYW59IFdoZXRoZXIgcmVxdWVzdHMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgY3Jvc3NvcmlnaW5cbiAqIEBwYXJhbSBzY2FsZU1vZGUge051bWJlcn0gU2hvdWxkIGJlIG9uZSBvZiB0aGUgUElYSS5zY2FsZU1vZGUgY29uc3RzXG4gKiBAcmV0dXJuIFRleHR1cmVcbiAqL1xuUElYSS5UZXh0dXJlLmZyb21JbWFnZSA9IGZ1bmN0aW9uKGltYWdlVXJsLCBjcm9zc29yaWdpbiwgc2NhbGVNb2RlKVxue1xuICAgIHZhciB0ZXh0dXJlID0gUElYSS5UZXh0dXJlQ2FjaGVbaW1hZ2VVcmxdO1xuXG4gICAgaWYoIXRleHR1cmUpXG4gICAge1xuICAgICAgICB0ZXh0dXJlID0gbmV3IFBJWEkuVGV4dHVyZShQSVhJLkJhc2VUZXh0dXJlLmZyb21JbWFnZShpbWFnZVVybCwgY3Jvc3NvcmlnaW4sIHNjYWxlTW9kZSkpO1xuICAgICAgICBQSVhJLlRleHR1cmVDYWNoZVtpbWFnZVVybF0gPSB0ZXh0dXJlO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0dXJlO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdGV4dHVyZSBiYXNlZCBvbiBhIGZyYW1lIGlkXG4gKiBJZiB0aGUgZnJhbWUgaWQgaXMgbm90IGluIHRoZSB0ZXh0dXJlIGNhY2hlIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBmcm9tRnJhbWVcbiAqIEBwYXJhbSBmcmFtZUlkIHtTdHJpbmd9IFRoZSBmcmFtZSBpZCBvZiB0aGUgdGV4dHVyZVxuICogQHJldHVybiBUZXh0dXJlXG4gKi9cblBJWEkuVGV4dHVyZS5mcm9tRnJhbWUgPSBmdW5jdGlvbihmcmFtZUlkKVxue1xuICAgIHZhciB0ZXh0dXJlID0gUElYSS5UZXh0dXJlQ2FjaGVbZnJhbWVJZF07XG4gICAgaWYoIXRleHR1cmUpIHRocm93IG5ldyBFcnJvcignVGhlIGZyYW1lSWQgXCInICsgZnJhbWVJZCArICdcIiBkb2VzIG5vdCBleGlzdCBpbiB0aGUgdGV4dHVyZSBjYWNoZSAnKTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRleHR1cmUgYmFzZWQgb24gYSBjYW52YXMgZWxlbWVudFxuICogSWYgdGhlIGNhbnZhcyBpcyBub3QgaW4gdGhlIHRleHR1cmUgY2FjaGUgaXQgd2lsbCBiZSAgY3JlYXRlZCBhbmQgbG9hZGVkXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBmcm9tQ2FudmFzXG4gKiBAcGFyYW0gY2FudmFzIHtDYW52YXN9IFRoZSBjYW52YXMgZWxlbWVudCBzb3VyY2Ugb2YgdGhlIHRleHR1cmVcbiAqIEBwYXJhbSBzY2FsZU1vZGUge051bWJlcn0gU2hvdWxkIGJlIG9uZSBvZiB0aGUgUElYSS5zY2FsZU1vZGUgY29uc3RzXG4gKiBAcmV0dXJuIFRleHR1cmVcbiAqL1xuUElYSS5UZXh0dXJlLmZyb21DYW52YXMgPSBmdW5jdGlvbihjYW52YXMsIHNjYWxlTW9kZSlcbntcbiAgICB2YXIgYmFzZVRleHR1cmUgPSBQSVhJLkJhc2VUZXh0dXJlLmZyb21DYW52YXMoY2FudmFzLCBzY2FsZU1vZGUpO1xuXG4gICAgcmV0dXJuIG5ldyBQSVhJLlRleHR1cmUoIGJhc2VUZXh0dXJlICk7XG5cbn07XG5cblxuLyoqXG4gKiBBZGRzIGEgdGV4dHVyZSB0byB0aGUgdGV4dHVyZUNhY2hlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgYWRkVGV4dHVyZVRvQ2FjaGVcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfVxuICogQHBhcmFtIGlkIHtTdHJpbmd9IHRoZSBpZCB0aGF0IHRoZSB0ZXh0dXJlIHdpbGwgYmUgc3RvcmVkIGFnYWluc3QuXG4gKi9cblBJWEkuVGV4dHVyZS5hZGRUZXh0dXJlVG9DYWNoZSA9IGZ1bmN0aW9uKHRleHR1cmUsIGlkKVxue1xuICAgIFBJWEkuVGV4dHVyZUNhY2hlW2lkXSA9IHRleHR1cmU7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIHRleHR1cmUgZnJvbSB0aGUgdGV4dHVyZUNhY2hlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgcmVtb3ZlVGV4dHVyZUZyb21DYWNoZVxuICogQHBhcmFtIGlkIHtTdHJpbmd9IHRoZSBpZCBvZiB0aGUgdGV4dHVyZSB0byBiZSByZW1vdmVkXG4gKiBAcmV0dXJuIHtUZXh0dXJlfSB0aGUgdGV4dHVyZSB0aGF0IHdhcyByZW1vdmVkXG4gKi9cblBJWEkuVGV4dHVyZS5yZW1vdmVUZXh0dXJlRnJvbUNhY2hlID0gZnVuY3Rpb24oaWQpXG57XG4gICAgdmFyIHRleHR1cmUgPSBQSVhJLlRleHR1cmVDYWNoZVtpZF07XG4gICAgZGVsZXRlIFBJWEkuVGV4dHVyZUNhY2hlW2lkXTtcbiAgICBkZWxldGUgUElYSS5CYXNlVGV4dHVyZUNhY2hlW2lkXTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbn07XG5cbi8vIHRoaXMgaXMgbW9yZSBmb3Igd2ViR0wuLiBpdCBjb250YWlucyB1cGRhdGVkIGZyYW1lcy4uXG5QSVhJLlRleHR1cmUuZnJhbWVVcGRhdGVzID0gW107XG5cblBJWEkuVGV4dHVyZVV2cyA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLngwID0gMDtcbiAgICB0aGlzLnkwID0gMDtcblxuICAgIHRoaXMueDEgPSAwO1xuICAgIHRoaXMueTEgPSAwO1xuXG4gICAgdGhpcy54MiA9IDA7XG4gICAgdGhpcy55MiA9IDA7XG5cbiAgICB0aGlzLngzID0gMDtcbiAgICB0aGlzLnkzID0gMDtcblxuXG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuIEEgUmVuZGVyVGV4dHVyZSBpcyBhIHNwZWNpYWwgdGV4dHVyZSB0aGF0IGFsbG93cyBhbnkgcGl4aSBkaXNwbGF5T2JqZWN0IHRvIGJlIHJlbmRlcmVkIHRvIGl0LlxuXG4gX19IaW50X186IEFsbCBEaXNwbGF5T2JqZWN0cyAoZXhtcGwuIFNwcml0ZXMpIHRoYXQgcmVuZGVyIG9uIFJlbmRlclRleHR1cmUgc2hvdWxkIGJlIHByZWxvYWRlZC5cbiBPdGhlcndpc2UgYmxhY2sgcmVjdGFuZ2xlcyB3aWxsIGJlIGRyYXduIGluc3RlYWQuXG5cbiBSZW5kZXJUZXh0dXJlIHRha2VzIHNuYXBzaG90IG9mIERpc3BsYXlPYmplY3QgcGFzc2VkIHRvIHJlbmRlciBtZXRob2QuIElmIERpc3BsYXlPYmplY3QgaXMgcGFzc2VkIHRvIHJlbmRlciBtZXRob2QsIHBvc2l0aW9uIGFuZCByb3RhdGlvbiBvZiBpdCB3aWxsIGJlIGlnbm9yZWQuIEZvciBleGFtcGxlOlxuXG4gICAgdmFyIHJlbmRlclRleHR1cmUgPSBuZXcgUElYSS5SZW5kZXJUZXh0dXJlKDgwMCwgNjAwKTtcbiAgICB2YXIgc3ByaXRlID0gUElYSS5TcHJpdGUuZnJvbUltYWdlKFwic3Bpbk9ial8wMS5wbmdcIik7XG4gICAgc3ByaXRlLnBvc2l0aW9uLnggPSA4MDAvMjtcbiAgICBzcHJpdGUucG9zaXRpb24ueSA9IDYwMC8yO1xuICAgIHNwcml0ZS5hbmNob3IueCA9IDAuNTtcbiAgICBzcHJpdGUuYW5jaG9yLnkgPSAwLjU7XG4gICAgcmVuZGVyVGV4dHVyZS5yZW5kZXIoc3ByaXRlKTtcblxuIFNwcml0ZSBpbiB0aGlzIGNhc2Ugd2lsbCBiZSByZW5kZXJlZCB0byAwLDAgcG9zaXRpb24uIFRvIHJlbmRlciB0aGlzIHNwcml0ZSBhdCBjZW50ZXIgRGlzcGxheU9iamVjdENvbnRhaW5lciBzaG91bGQgYmUgdXNlZDpcblxuICAgIHZhciBkb2MgPSBuZXcgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyKCk7XG4gICAgZG9jLmFkZENoaWxkKHNwcml0ZSk7XG4gICAgcmVuZGVyVGV4dHVyZS5yZW5kZXIoZG9jKTsgIC8vIFJlbmRlcnMgdG8gY2VudGVyIG9mIHJlbmRlclRleHR1cmVcblxuICogQGNsYXNzIFJlbmRlclRleHR1cmVcbiAqIEBleHRlbmRzIFRleHR1cmVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgcmVuZGVyIHRleHR1cmVcbiAqIEBwYXJhbSBoZWlnaHQge051bWJlcn0gVGhlIGhlaWdodCBvZiB0aGUgcmVuZGVyIHRleHR1cmVcbiAqIEBwYXJhbSBzY2FsZU1vZGUge051bWJlcn0gU2hvdWxkIGJlIG9uZSBvZiB0aGUgUElYSS5zY2FsZU1vZGUgY29uc3RzXG4gKi9cblBJWEkuUmVuZGVyVGV4dHVyZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHJlbmRlcmVyLCBzY2FsZU1vZGUpXG57XG4gICAgUElYSS5FdmVudFRhcmdldC5jYWxsKCB0aGlzICk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2l0aCBvZiB0aGUgcmVuZGVyIHRleHR1cmVcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB3aWR0aFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAxMDA7XG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgcmVuZGVyIHRleHR1cmVcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBoZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAxMDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhlIHJlbmRlciB0ZXh0dXJlXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZnJhbWVcbiAgICAgKiBAdHlwZSBSZWN0YW5nbGVcbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lID0gbmV3IFBJWEkuUmVjdGFuZ2xlKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGFyZWEgb2YgdGhlIEJhc2VUZXh0dXJlIGltYWdlIHRvIGFjdHVhbGx5IGNvcHkgdG8gdGhlIENhbnZhcyAvIFdlYkdMIHdoZW4gcmVuZGVyaW5nLFxuICAgICAqIGlycmVzcGVjdGl2ZSBvZiB0aGUgYWN0dWFsIGZyYW1lIHNpemUgb3IgcGxhY2VtZW50ICh3aGljaCBjYW4gYmUgaW5mbHVlbmNlZCBieSB0cmltbWVkIHRleHR1cmUgYXRsYXNlcylcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjcm9wXG4gICAgICogQHR5cGUgUmVjdGFuZ2xlXG4gICAgICovXG4gICAgdGhpcy5jcm9wID0gbmV3IFBJWEkuUmVjdGFuZ2xlKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSB0ZXh0dXJlIG9iamVjdCB0aGF0IHRoaXMgdGV4dHVyZSB1c2VzXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYmFzZVRleHR1cmVcbiAgICAgKiBAdHlwZSBCYXNlVGV4dHVyZVxuICAgICAqL1xuICAgIHRoaXMuYmFzZVRleHR1cmUgPSBuZXcgUElYSS5CYXNlVGV4dHVyZSgpO1xuICAgIHRoaXMuYmFzZVRleHR1cmUud2lkdGggPSB0aGlzLndpZHRoO1xuICAgIHRoaXMuYmFzZVRleHR1cmUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgdGhpcy5iYXNlVGV4dHVyZS5fZ2xUZXh0dXJlcyA9IFtdO1xuXG4gICAgdGhpcy5iYXNlVGV4dHVyZS5zY2FsZU1vZGUgPSBzY2FsZU1vZGUgfHwgUElYSS5zY2FsZU1vZGVzLkRFRkFVTFQ7XG5cbiAgICB0aGlzLmJhc2VUZXh0dXJlLmhhc0xvYWRlZCA9IHRydWU7XG5cbiAgICAvLyBlYWNoIHJlbmRlciB0ZXh0dXJlIGNhbiBvbmx5IGJlbG9uZyB0byBvbmUgcmVuZGVyZXIgYXQgdGhlIG1vbWVudCBpZiBpdHMgd2ViR0xcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXIgfHwgUElYSS5kZWZhdWx0UmVuZGVyZXI7XG5cbiAgICBpZih0aGlzLnJlbmRlcmVyLnR5cGUgPT09IFBJWEkuV0VCR0xfUkVOREVSRVIpXG4gICAge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuXG4gICAgICAgIHRoaXMudGV4dHVyZUJ1ZmZlciA9IG5ldyBQSVhJLkZpbHRlclRleHR1cmUoZ2wsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLmJhc2VUZXh0dXJlLnNjYWxlTW9kZSk7XG4gICAgICAgIHRoaXMuYmFzZVRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdID0gIHRoaXMudGV4dHVyZUJ1ZmZlci50ZXh0dXJlO1xuXG4gICAgICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXJXZWJHTDtcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uID0gbmV3IFBJWEkuUG9pbnQodGhpcy53aWR0aC8yICwgLXRoaXMuaGVpZ2h0LzIpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyQ2FudmFzO1xuICAgICAgICB0aGlzLnRleHR1cmVCdWZmZXIgPSBuZXcgUElYSS5DYW52YXNCdWZmZXIodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLnNvdXJjZSA9IHRoaXMudGV4dHVyZUJ1ZmZlci5jYW52YXM7XG4gICAgfVxuXG4gICAgdGhpcy52YWxpZCA9IHRydWU7XG4gICAgUElYSS5UZXh0dXJlLmZyYW1lVXBkYXRlcy5wdXNoKHRoaXMpO1xuXG5cbn07XG5cblBJWEkuUmVuZGVyVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBJWEkuVGV4dHVyZS5wcm90b3R5cGUpO1xuUElYSS5SZW5kZXJUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuUmVuZGVyVGV4dHVyZTtcblxuLyoqXG4gKiBSZXNpemUgdGhlIFJlbmRlclRleHR1cmUuXG4gKlxuICogQG1ldGhvZCByZXNpemVcbiAqIEBwYXJhbSB3aWR0aCB7TnVtYmVyfSBUaGUgd2lkdGggdG8gcmVzaXplIHRvLlxuICogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSBUaGUgaGVpZ2h0IHRvIHJlc2l6ZSB0by5cbiAqIEBwYXJhbSB1cGRhdGVCYXNlIHtCb29sZWFufSBTaG91bGQgdGhlIGJhc2VUZXh0dXJlLndpZHRoIGFuZCBoZWlnaHQgdmFsdWVzIGJlIHJlc2l6ZWQgYXMgd2VsbD9cbiAqL1xuUElYSS5SZW5kZXJUZXh0dXJlLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCB1cGRhdGVCYXNlKVxue1xuICAgIGlmICh3aWR0aCA9PT0gdGhpcy53aWR0aCAmJiBoZWlnaHQgPT09IHRoaXMuaGVpZ2h0KVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMud2lkdGggPSB0aGlzLmZyYW1lLndpZHRoID0gdGhpcy5jcm9wLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSAgdGhpcy5mcmFtZS5oZWlnaHQgPSB0aGlzLmNyb3AuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgaWYgKHVwZGF0ZUJhc2UpXG4gICAge1xuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZW5kZXJlci50eXBlID09PSBQSVhJLldFQkdMX1JFTkRFUkVSKVxuICAgIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uLnggPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uLnkgPSAtdGhpcy5oZWlnaHQgLyAyO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLnRleHR1cmVCdWZmZXIucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbn07XG5cbi8qKlxuICogQ2xlYXJzIHRoZSBSZW5kZXJUZXh0dXJlLlxuICpcbiAqIEBtZXRob2QgY2xlYXJcbiAqL1xuUElYSS5SZW5kZXJUZXh0dXJlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKClcbntcbiAgICBpZiAodGhpcy5yZW5kZXJlci50eXBlID09PSBQSVhJLldFQkdMX1JFTkRFUkVSKVxuICAgIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5yZW5kZXJlci5nbC5GUkFNRUJVRkZFUiwgdGhpcy50ZXh0dXJlQnVmZmVyLmZyYW1lQnVmZmVyKTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy50ZXh0dXJlQnVmZmVyLmNsZWFyKCk7XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBkcmF3IHRoZSBkaXNwbGF5IG9iamVjdCB0byB0aGUgdGV4dHVyZS5cbiAqXG4gKiBAbWV0aG9kIHJlbmRlcldlYkdMXG4gKiBAcGFyYW0gZGlzcGxheU9iamVjdCB7RGlzcGxheU9iamVjdH0gVGhlIGRpc3BsYXkgb2JqZWN0IHRvIHJlbmRlciB0aGlzIHRleHR1cmUgb25cbiAqIEBwYXJhbSBjbGVhciB7Qm9vbGVhbn0gSWYgdHJ1ZSB0aGUgdGV4dHVyZSB3aWxsIGJlIGNsZWFyZWQgYmVmb3JlIHRoZSBkaXNwbGF5T2JqZWN0IGlzIGRyYXduXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlJlbmRlclRleHR1cmUucHJvdG90eXBlLnJlbmRlcldlYkdMID0gZnVuY3Rpb24oZGlzcGxheU9iamVjdCwgcG9zaXRpb24sIGNsZWFyKVxue1xuICAgIC8vVE9PRCByZXBsYWNlIHBvc2l0aW9uIHdpdGggbWF0cml4Li5cbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuXG4gICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuXG4gICAgZ2wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLnRleHR1cmVCdWZmZXIuZnJhbWVCdWZmZXIgKTtcblxuICAgIGlmKGNsZWFyKXRoaXMudGV4dHVyZUJ1ZmZlci5jbGVhcigpO1xuXG5cbiAgICAvLyBUSElTIFdJTEwgTUVTUyBXSVRIIEhJVCBURVNUSU5HIVxuICAgIHZhciBjaGlsZHJlbiA9IGRpc3BsYXlPYmplY3QuY2hpbGRyZW47XG5cbiAgICAvL1RPRE8gLT8gY3JlYXRlIGEgbmV3IG9uZT8/PyBkb250IHRoaW5rIHNvIVxuICAgIHZhciBvcmlnaW5hbFdvcmxkVHJhbnNmb3JtID0gZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybTtcbiAgICBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtID0gUElYSS5SZW5kZXJUZXh0dXJlLnRlbXBNYXRyaXg7XG4gICAgLy8gbW9kaWZ5IHRvIGZsaXAuLi5cbiAgICBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtLmQgPSAtMTtcbiAgICBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtLnR5ID0gdGhpcy5wcm9qZWN0aW9uLnkgKiAtMjtcblxuICAgIGlmKHBvc2l0aW9uKVxuICAgIHtcbiAgICAgICAgZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybS50eCA9IHBvc2l0aW9uLng7XG4gICAgICAgIGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm0udHkgLT0gcG9zaXRpb24ueTtcbiAgICB9XG5cbiAgICBmb3IodmFyIGk9MCxqPWNoaWxkcmVuLmxlbmd0aDsgaTxqOyBpKyspXG4gICAge1xuICAgICAgICBjaGlsZHJlbltpXS51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGhlIHRleHR1cmVzIVxuICAgIFBJWEkuV2ViR0xSZW5kZXJlci51cGRhdGVUZXh0dXJlcygpO1xuXG4gICAgdGhpcy5yZW5kZXJlci5zcHJpdGVCYXRjaC5kaXJ0eSA9IHRydWU7XG4gICAgXG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXJEaXNwbGF5T2JqZWN0KGRpc3BsYXlPYmplY3QsIHRoaXMucHJvamVjdGlvbiwgdGhpcy50ZXh0dXJlQnVmZmVyLmZyYW1lQnVmZmVyKTtcblxuICAgIGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm0gPSBvcmlnaW5hbFdvcmxkVHJhbnNmb3JtO1xuXG4gICAgdGhpcy5yZW5kZXJlci5zcHJpdGVCYXRjaC5kaXJ0eSA9IHRydWU7XG59O1xuXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGRyYXcgdGhlIGRpc3BsYXkgb2JqZWN0IHRvIHRoZSB0ZXh0dXJlLlxuICpcbiAqIEBtZXRob2QgcmVuZGVyQ2FudmFzXG4gKiBAcGFyYW0gZGlzcGxheU9iamVjdCB7RGlzcGxheU9iamVjdH0gVGhlIGRpc3BsYXkgb2JqZWN0IHRvIHJlbmRlciB0aGlzIHRleHR1cmUgb25cbiAqIEBwYXJhbSBjbGVhciB7Qm9vbGVhbn0gSWYgdHJ1ZSB0aGUgdGV4dHVyZSB3aWxsIGJlIGNsZWFyZWQgYmVmb3JlIHRoZSBkaXNwbGF5T2JqZWN0IGlzIGRyYXduXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlJlbmRlclRleHR1cmUucHJvdG90eXBlLnJlbmRlckNhbnZhcyA9IGZ1bmN0aW9uKGRpc3BsYXlPYmplY3QsIHBvc2l0aW9uLCBjbGVhcilcbntcbiAgICB2YXIgY2hpbGRyZW4gPSBkaXNwbGF5T2JqZWN0LmNoaWxkcmVuO1xuXG4gICAgdmFyIG9yaWdpbmFsV29ybGRUcmFuc2Zvcm0gPSBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtO1xuXG4gICAgZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybSA9IFBJWEkuUmVuZGVyVGV4dHVyZS50ZW1wTWF0cml4O1xuICAgIFxuICAgIGlmKHBvc2l0aW9uKVxuICAgIHtcbiAgICAgICAgZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybS50eCA9IHBvc2l0aW9uLng7XG4gICAgICAgIGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm0udHkgPSBwb3NpdGlvbi55O1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtLnR4ID0gMDtcbiAgICAgICAgZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybS50eSA9IDA7XG4gICAgfVxuXG4gICAgZm9yKHZhciBpID0gMCwgaiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKylcbiAgICB7XG4gICAgICAgIGNoaWxkcmVuW2ldLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgIH1cblxuICAgIGlmKGNsZWFyKXRoaXMudGV4dHVyZUJ1ZmZlci5jbGVhcigpO1xuXG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLnRleHR1cmVCdWZmZXIuY29udGV4dDtcblxuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyRGlzcGxheU9iamVjdChkaXNwbGF5T2JqZWN0LCBjb250ZXh0KTtcblxuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsMCwwLDEsMCwwKTtcblxuICAgIGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm0gPSBvcmlnaW5hbFdvcmxkVHJhbnNmb3JtO1xufTtcblxuUElYSS5SZW5kZXJUZXh0dXJlLnRlbXBNYXRyaXggPSBuZXcgUElYSS5NYXRyaXgoKTtcblxuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogQSBDbGFzcyB0aGF0IGxvYWRzIGEgYnVuY2ggb2YgaW1hZ2VzIC8gc3ByaXRlIHNoZWV0IC8gYml0bWFwIGZvbnQgZmlsZXMuIE9uY2UgdGhlXG4gKiBhc3NldHMgaGF2ZSBiZWVuIGxvYWRlZCB0aGV5IGFyZSBhZGRlZCB0byB0aGUgUElYSSBUZXh0dXJlIGNhY2hlIGFuZCBjYW4gYmUgYWNjZXNzZWRcbiAqIGVhc2lseSB0aHJvdWdoIFBJWEkuVGV4dHVyZS5mcm9tSW1hZ2UoKSBhbmQgUElYSS5TcHJpdGUuZnJvbUltYWdlKClcbiAqIFdoZW4gYWxsIGl0ZW1zIGhhdmUgYmVlbiBsb2FkZWQgdGhpcyBjbGFzcyB3aWxsIGRpc3BhdGNoIGEgJ29uTG9hZGVkJyBldmVudFxuICogQXMgZWFjaCBpbmRpdmlkdWFsIGl0ZW0gaXMgbG9hZGVkIHRoaXMgY2xhc3Mgd2lsbCBkaXNwYXRjaCBhICdvblByb2dyZXNzJyBldmVudFxuICpcbiAqIEBjbGFzcyBBc3NldExvYWRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAdXNlcyBFdmVudFRhcmdldFxuICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBhc3NldFVSTHMgYW4gYXJyYXkgb2YgaW1hZ2Uvc3ByaXRlIHNoZWV0IHVybHMgdGhhdCB5b3Ugd291bGQgbGlrZSBsb2FkZWRcbiAqICAgICAgc3VwcG9ydGVkLiBTdXBwb3J0ZWQgaW1hZ2UgZm9ybWF0cyBpbmNsdWRlICdqcGVnJywgJ2pwZycsICdwbmcnLCAnZ2lmJy4gU3VwcG9ydGVkXG4gKiAgICAgIHNwcml0ZSBzaGVldCBkYXRhIGZvcm1hdHMgb25seSBpbmNsdWRlICdKU09OJyBhdCB0aGlzIHRpbWUuIFN1cHBvcnRlZCBiaXRtYXAgZm9udFxuICogICAgICBkYXRhIGZvcm1hdHMgaW5jbHVkZSAneG1sJyBhbmQgJ2ZudCcuXG4gKiBAcGFyYW0gY3Jvc3NvcmlnaW4ge0Jvb2xlYW59IFdoZXRoZXIgcmVxdWVzdHMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgY3Jvc3NvcmlnaW5cbiAqL1xuUElYSS5Bc3NldExvYWRlciA9IGZ1bmN0aW9uKGFzc2V0VVJMcywgY3Jvc3NvcmlnaW4pXG57XG4gICAgUElYSS5FdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFycmF5IG9mIGFzc2V0IFVSTHMgdGhhdCBhcmUgZ29pbmcgdG8gYmUgbG9hZGVkXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYXNzZXRVUkxzXG4gICAgICogQHR5cGUgQXJyYXk8U3RyaW5nPlxuICAgICAqL1xuICAgIHRoaXMuYXNzZXRVUkxzID0gYXNzZXRVUkxzO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVxdWVzdHMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgY3Jvc3Mgb3JpZ2luXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY3Jvc3NvcmlnaW5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5jcm9zc29yaWdpbiA9IGNyb3Nzb3JpZ2luO1xuXG4gICAgLyoqXG4gICAgICogTWFwcyBmaWxlIGV4dGVuc2lvbiB0byBsb2FkZXIgdHlwZXNcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBsb2FkZXJzQnlUeXBlXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgdGhpcy5sb2FkZXJzQnlUeXBlID0ge1xuICAgICAgICAnanBnJzogIFBJWEkuSW1hZ2VMb2FkZXIsXG4gICAgICAgICdqcGVnJzogUElYSS5JbWFnZUxvYWRlcixcbiAgICAgICAgJ3BuZyc6ICBQSVhJLkltYWdlTG9hZGVyLFxuICAgICAgICAnZ2lmJzogIFBJWEkuSW1hZ2VMb2FkZXIsXG4gICAgICAgICd3ZWJwJzogUElYSS5JbWFnZUxvYWRlcixcbiAgICAgICAgJ2pzb24nOiBQSVhJLkpzb25Mb2FkZXIsXG4gICAgICAgICdhdGxhcyc6IFBJWEkuQXRsYXNMb2FkZXIsXG4gICAgICAgICdhbmltJzogUElYSS5TcGluZUxvYWRlcixcbiAgICAgICAgJ3htbCc6ICBQSVhJLkJpdG1hcEZvbnRMb2FkZXIsXG4gICAgICAgICdmbnQnOiAgUElYSS5CaXRtYXBGb250TG9hZGVyXG4gICAgfTtcbn07XG5cbi8qKlxuICogRmlyZWQgd2hlbiBhbiBpdGVtIGhhcyBsb2FkZWRcbiAqIEBldmVudCBvblByb2dyZXNzXG4gKi9cblxuLyoqXG4gKiBGaXJlZCB3aGVuIGFsbCB0aGUgYXNzZXRzIGhhdmUgbG9hZGVkXG4gKiBAZXZlbnQgb25Db21wbGV0ZVxuICovXG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLkFzc2V0TG9hZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuQXNzZXRMb2FkZXI7XG5cbi8qKlxuICogR2l2ZW4gYSBmaWxlbmFtZSwgcmV0dXJucyBpdHMgZXh0ZW5zaW9uLCB3aWxcbiAqXG4gKiBAbWV0aG9kIF9nZXREYXRhVHlwZVxuICogQHBhcmFtIHN0ciB7U3RyaW5nfSB0aGUgbmFtZSBvZiB0aGUgYXNzZXRcbiAqL1xuUElYSS5Bc3NldExvYWRlci5wcm90b3R5cGUuX2dldERhdGFUeXBlID0gZnVuY3Rpb24oc3RyKVxue1xuICAgIHZhciB0ZXN0ID0gJ2RhdGE6JztcbiAgICAvL3N0YXJ0cyB3aXRoICdkYXRhOidcbiAgICB2YXIgc3RhcnQgPSBzdHIuc2xpY2UoMCwgdGVzdC5sZW5ndGgpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHN0YXJ0ID09PSB0ZXN0KSB7XG4gICAgICAgIHZhciBkYXRhID0gc3RyLnNsaWNlKHRlc3QubGVuZ3RoKTtcblxuICAgICAgICB2YXIgc2VwSWR4ID0gZGF0YS5pbmRleE9mKCcsJyk7XG4gICAgICAgIGlmIChzZXBJZHggPT09IC0xKSAvL21hbGZvcm1lZCBkYXRhIFVSSSBzY2hlbWVcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgIC8vZS5nLiAnaW1hZ2UvZ2lmO2Jhc2U2NCcgPT4gJ2ltYWdlL2dpZidcbiAgICAgICAgdmFyIGluZm8gPSBkYXRhLnNsaWNlKDAsIHNlcElkeCkuc3BsaXQoJzsnKVswXTtcblxuICAgICAgICAvL1dlIG1pZ2h0IG5lZWQgdG8gaGFuZGxlIHNvbWUgc3BlY2lhbCBjYXNlcyBoZXJlLi4uXG4gICAgICAgIC8vc3RhbmRhcmRpemUgdGV4dC9wbGFpbiB0byAndHh0JyBmaWxlIGV4dGVuc2lvblxuICAgICAgICBpZiAoIWluZm8gfHwgaW5mby50b0xvd2VyQ2FzZSgpID09PSAndGV4dC9wbGFpbicpXG4gICAgICAgICAgICByZXR1cm4gJ3R4dCc7XG5cbiAgICAgICAgLy9Vc2VyIHNwZWNpZmllZCBtaW1lIHR5cGUsIHRyeSBzcGxpdHRpbmcgaXQgYnkgJy8nXG4gICAgICAgIHJldHVybiBpbmZvLnNwbGl0KCcvJykucG9wKCkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogU3RhcnRzIGxvYWRpbmcgdGhlIGFzc2V0cyBzZXF1ZW50aWFsbHlcbiAqXG4gKiBAbWV0aG9kIGxvYWRcbiAqL1xuUElYSS5Bc3NldExvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gb25Mb2FkKGV2dCkge1xuICAgICAgICBzY29wZS5vbkFzc2V0TG9hZGVkKGV2dC5jb250ZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLmxvYWRDb3VudCA9IHRoaXMuYXNzZXRVUkxzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGk9MDsgaSA8IHRoaXMuYXNzZXRVUkxzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGZpbGVOYW1lID0gdGhpcy5hc3NldFVSTHNbaV07XG4gICAgICAgIC8vZmlyc3Qgc2VlIGlmIHdlIGhhdmUgYSBkYXRhIFVSSSBzY2hlbWUuLlxuICAgICAgICB2YXIgZmlsZVR5cGUgPSB0aGlzLl9nZXREYXRhVHlwZShmaWxlTmFtZSk7XG5cbiAgICAgICAgLy9pZiBub3QsIGFzc3VtZSBpdCdzIGEgZmlsZSBVUklcbiAgICAgICAgaWYgKCFmaWxlVHlwZSlcbiAgICAgICAgICAgIGZpbGVUeXBlID0gZmlsZU5hbWUuc3BsaXQoJz8nKS5zaGlmdCgpLnNwbGl0KCcuJykucG9wKCkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzLmxvYWRlcnNCeVR5cGVbZmlsZVR5cGVdO1xuICAgICAgICBpZighQ29uc3RydWN0b3IpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZmlsZVR5cGUgKyAnIGlzIGFuIHVuc3VwcG9ydGVkIGZpbGUgdHlwZScpO1xuXG4gICAgICAgIHZhciBsb2FkZXIgPSBuZXcgQ29uc3RydWN0b3IoZmlsZU5hbWUsIHRoaXMuY3Jvc3NvcmlnaW4pO1xuXG4gICAgICAgIGxvYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWQnLCBvbkxvYWQpO1xuICAgICAgICBsb2FkZXIubG9hZCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogSW52b2tlZCBhZnRlciBlYWNoIGZpbGUgaXMgbG9hZGVkXG4gKlxuICogQG1ldGhvZCBvbkFzc2V0TG9hZGVkXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkFzc2V0TG9hZGVyLnByb3RvdHlwZS5vbkFzc2V0TG9hZGVkID0gZnVuY3Rpb24obG9hZGVyKVxue1xuICAgIHRoaXMubG9hZENvdW50LS07XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KHsgdHlwZTogJ29uUHJvZ3Jlc3MnLCBjb250ZW50OiB0aGlzLCBsb2FkZXI6IGxvYWRlciB9KTtcbiAgICBpZiAodGhpcy5vblByb2dyZXNzKSB0aGlzLm9uUHJvZ3Jlc3MobG9hZGVyKTtcblxuICAgIGlmICghdGhpcy5sb2FkQ291bnQpXG4gICAge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ICdvbkNvbXBsZXRlJywgY29udGVudDogdGhpc30pO1xuICAgICAgICBpZih0aGlzLm9uQ29tcGxldGUpIHRoaXMub25Db21wbGV0ZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKiBUaGUganNvbiBmaWxlIGxvYWRlciBpcyB1c2VkIHRvIGxvYWQgaW4gSlNPTiBkYXRhIGFuZCBwYXJzZSBpdFxuICogV2hlbiBsb2FkZWQgdGhpcyBjbGFzcyB3aWxsIGRpc3BhdGNoIGEgJ2xvYWRlZCcgZXZlbnRcbiAqIElmIGxvYWRpbmcgZmFpbHMgdGhpcyBjbGFzcyB3aWxsIGRpc3BhdGNoIGFuICdlcnJvcicgZXZlbnRcbiAqXG4gKiBAY2xhc3MgSnNvbkxvYWRlclxuICogQHVzZXMgRXZlbnRUYXJnZXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHVybCB7U3RyaW5nfSBUaGUgdXJsIG9mIHRoZSBKU09OIGZpbGVcbiAqIEBwYXJhbSBjcm9zc29yaWdpbiB7Qm9vbGVhbn0gV2hldGhlciByZXF1ZXN0cyBzaG91bGQgYmUgdHJlYXRlZCBhcyBjcm9zc29yaWdpblxuICovXG5QSVhJLkpzb25Mb2FkZXIgPSBmdW5jdGlvbiAodXJsLCBjcm9zc29yaWdpbikge1xuICAgIFBJWEkuRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB1cmwgb2YgdGhlIGJpdG1hcCBmb250IGRhdGFcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB1cmxcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICB0aGlzLnVybCA9IHVybDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHJlcXVlc3RzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGNyb3NzIG9yaWdpblxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNyb3Nzb3JpZ2luXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMuY3Jvc3NvcmlnaW4gPSBjcm9zc29yaWdpbjtcblxuICAgIC8qKlxuICAgICAqIFtyZWFkLW9ubHldIFRoZSBiYXNlIHVybCBvZiB0aGUgYml0bWFwIGZvbnQgZGF0YVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJhc2VVcmxcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmJhc2VVcmwgPSB1cmwucmVwbGFjZSgvW15cXC9dKiQvLCAnJyk7XG5cbiAgICAvKipcbiAgICAgKiBbcmVhZC1vbmx5XSBXaGV0aGVyIHRoZSBkYXRhIGhhcyBsb2FkZWQgeWV0XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbG9hZGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG5cbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLkpzb25Mb2FkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5Kc29uTG9hZGVyO1xuXG4vKipcbiAqIExvYWRzIHRoZSBKU09OIGRhdGFcbiAqXG4gKiBAbWV0aG9kIGxvYWRcbiAqL1xuUElYSS5Kc29uTG9hZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgIGlmKHdpbmRvdy5YRG9tYWluUmVxdWVzdCAmJiBzY29wZS5jcm9zc29yaWdpbilcbiAgICB7XG4gICAgICAgIHRoaXMuYWpheFJlcXVlc3QgPSBuZXcgd2luZG93LlhEb21haW5SZXF1ZXN0KCk7XG5cbiAgICAgICAgLy8gWERvbWFpblJlcXVlc3QgaGFzIGEgZmV3IHF1ZXJrcy4gT2NjYXNpb25hbGx5IGl0IHdpbGwgYWJvcnQgcmVxdWVzdHNcbiAgICAgICAgLy8gQSB3YXkgdG8gYXZvaWQgdGhpcyBpcyB0byBtYWtlIHN1cmUgQUxMIGNhbGxiYWNrcyBhcmUgc2V0IGV2ZW4gaWYgbm90IHVzZWRcbiAgICAgICAgLy8gTW9yZSBpbmZvIGhlcmU6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTU3ODY5NjYveGRvbWFpbnJlcXVlc3QtYWJvcnRzLXBvc3Qtb24taWUtOVxuICAgICAgICB0aGlzLmFqYXhSZXF1ZXN0LnRpbWVvdXQgPSAzMDAwO1xuXG4gICAgICAgIHRoaXMuYWpheFJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNjb3BlLm9uRXJyb3IoKTtcbiAgICAgICAgfTtcbiAgICAgICAgICAgXG4gICAgICAgIHRoaXMuYWpheFJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2NvcGUub25FcnJvcigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYWpheFJlcXVlc3Qub25wcm9ncmVzcyA9IGZ1bmN0aW9uKCkge307XG5cbiAgICB9XG4gICAgZWxzZSBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KVxuICAgIHtcbiAgICAgICAgdGhpcy5hamF4UmVxdWVzdCA9IG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5hamF4UmVxdWVzdCA9IG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9XG5cbiAgICBcblxuICAgIHRoaXMuYWpheFJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oKXtcblxuICAgICAgICBzY29wZS5vbkpTT05Mb2FkZWQoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5hamF4UmVxdWVzdC5vcGVuKCdHRVQnLHRoaXMudXJsLHRydWUpO1xuXG4gICAgdGhpcy5hamF4UmVxdWVzdC5zZW5kKCk7XG59O1xuXG4vKipcbiAqIEludm9rZSB3aGVuIEpTT04gZmlsZSBpcyBsb2FkZWRcbiAqXG4gKiBAbWV0aG9kIG9uSlNPTkxvYWRlZFxuICogQHByaXZhdGVcbiAqL1xuUElYSS5Kc29uTG9hZGVyLnByb3RvdHlwZS5vbkpTT05Mb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgXG4gICAgaWYoIXRoaXMuYWpheFJlcXVlc3QucmVzcG9uc2VUZXh0IClcbiAgICB7XG4gICAgICAgIHRoaXMub25FcnJvcigpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgXG4gICAgdGhpcy5qc29uID0gSlNPTi5wYXJzZSh0aGlzLmFqYXhSZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG5cbiAgICBpZih0aGlzLmpzb24uZnJhbWVzKVxuICAgIHtcbiAgICAgICAgLy8gc3ByaXRlIHNoZWV0XG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICAgIHZhciB0ZXh0dXJlVXJsID0gdGhpcy5iYXNlVXJsICsgdGhpcy5qc29uLm1ldGEuaW1hZ2U7XG4gICAgICAgIHZhciBpbWFnZSA9IG5ldyBQSVhJLkltYWdlTG9hZGVyKHRleHR1cmVVcmwsIHRoaXMuY3Jvc3NvcmlnaW4pO1xuICAgICAgICB2YXIgZnJhbWVEYXRhID0gdGhpcy5qc29uLmZyYW1lcztcblxuICAgICAgICB0aGlzLnRleHR1cmUgPSBpbWFnZS50ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNjb3BlLm9uTG9hZGVkKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGkgaW4gZnJhbWVEYXRhKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IGZyYW1lRGF0YVtpXS5mcmFtZTtcblxuICAgICAgICAgICAgaWYgKHJlY3QpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgUElYSS5UZXh0dXJlQ2FjaGVbaV0gPSBuZXcgUElYSS5UZXh0dXJlKHRoaXMudGV4dHVyZSwge1xuICAgICAgICAgICAgICAgICAgICB4OiByZWN0LngsXG4gICAgICAgICAgICAgICAgICAgIHk6IHJlY3QueSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHJlY3QudyxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmhcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIFBJWEkuVGV4dHVyZUNhY2hlW2ldLmNyb3AgPSBuZXcgUElYSS5SZWN0YW5nbGUocmVjdC54LCByZWN0LnksIHJlY3QudywgcmVjdC5oKTtcblxuICAgICAgICAgICAgICAgIC8vICBDaGVjayB0byBzZWUgaWYgdGhlIHNwcml0ZSBpcyB0cmltbWVkXG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lRGF0YVtpXS50cmltbWVkKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdHVhbFNpemUgPSBmcmFtZURhdGFbaV0uc291cmNlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlYWxTaXplID0gZnJhbWVEYXRhW2ldLnNwcml0ZVNvdXJjZVNpemU7XG4gICAgICAgICAgICAgICAgICAgIFBJWEkuVGV4dHVyZUNhY2hlW2ldLnRyaW0gPSBuZXcgUElYSS5SZWN0YW5nbGUocmVhbFNpemUueCwgcmVhbFNpemUueSwgYWN0dWFsU2l6ZS53LCBhY3R1YWxTaXplLmgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGltYWdlLmxvYWQoKTtcblxuICAgIH1cbiAgICBlbHNlIGlmKHRoaXMuanNvbi5ib25lcylcbiAgICB7XG4gICAgICAgIC8vIHNwaW5lIGFuaW1hdGlvblxuICAgICAgICB2YXIgc3BpbmVKc29uUGFyc2VyID0gbmV3IHNwaW5lLlNrZWxldG9uSnNvbigpO1xuICAgICAgICB2YXIgc2tlbGV0b25EYXRhID0gc3BpbmVKc29uUGFyc2VyLnJlYWRTa2VsZXRvbkRhdGEodGhpcy5qc29uKTtcbiAgICAgICAgUElYSS5BbmltQ2FjaGVbdGhpcy51cmxdID0gc2tlbGV0b25EYXRhO1xuICAgICAgICB0aGlzLm9uTG9hZGVkKCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMub25Mb2FkZWQoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEludm9rZSB3aGVuIGpzb24gZmlsZSBsb2FkZWRcbiAqXG4gKiBAbWV0aG9kIG9uTG9hZGVkXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkpzb25Mb2FkZXIucHJvdG90eXBlLm9uTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICB0eXBlOiAnbG9hZGVkJyxcbiAgICAgICAgY29udGVudDogdGhpc1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBJbnZva2Ugd2hlbiBlcnJvciBvY2N1cmVkXG4gKlxuICogQG1ldGhvZCBvbkVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkpzb25Mb2FkZXIucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICBjb250ZW50OiB0aGlzXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWFydGluIEtlbG0gaHR0cDovL21rZWxtLmdpdGh1Yi5jb21cbiAqL1xuXG4vKipcbiAqIFRoZSBhdGxhcyBmaWxlIGxvYWRlciBpcyB1c2VkIHRvIGxvYWQgaW4gQXRsYXMgZGF0YSBhbmQgcGFyc2UgaXRcbiAqIFdoZW4gbG9hZGVkIHRoaXMgY2xhc3Mgd2lsbCBkaXNwYXRjaCBhICdsb2FkZWQnIGV2ZW50XG4gKiBJZiBsb2FkaW5nIGZhaWxzIHRoaXMgY2xhc3Mgd2lsbCBkaXNwYXRjaCBhbiAnZXJyb3InIGV2ZW50XG4gKiBAY2xhc3MgQXRsYXNMb2FkZXJcbiAqIEBleHRlbmRzIEV2ZW50VGFyZ2V0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgdGhlIHVybCBvZiB0aGUgSlNPTiBmaWxlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNyb3Nzb3JpZ2luXG4gKi9cblxuUElYSS5BdGxhc0xvYWRlciA9IGZ1bmN0aW9uICh1cmwsIGNyb3Nzb3JpZ2luKSB7XG4gICAgUElYSS5FdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuYmFzZVVybCA9IHVybC5yZXBsYWNlKC9bXlxcL10qJC8sICcnKTtcbiAgICB0aGlzLmNyb3Nzb3JpZ2luID0gY3Jvc3NvcmlnaW47XG4gICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcblxufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuQXRsYXNMb2FkZXIuY29uc3RydWN0b3IgPSBQSVhJLkF0bGFzTG9hZGVyO1xuXG5cbiAvKipcbiAqIFN0YXJ0cyBsb2FkaW5nIHRoZSBKU09OIGZpbGVcbiAqXG4gKiBAbWV0aG9kIGxvYWRcbiAqL1xuUElYSS5BdGxhc0xvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFqYXhSZXF1ZXN0ID0gbmV3IFBJWEkuQWpheFJlcXVlc3QoKTtcbiAgICB0aGlzLmFqYXhSZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHRoaXMub25BdGxhc0xvYWRlZC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5hamF4UmVxdWVzdC5vcGVuKCdHRVQnLCB0aGlzLnVybCwgdHJ1ZSk7XG4gICAgaWYgKHRoaXMuYWpheFJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZSkgdGhpcy5hamF4UmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlKCdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgdGhpcy5hamF4UmVxdWVzdC5zZW5kKG51bGwpO1xufTtcblxuLyoqXG4gKiBJbnZva2Ugd2hlbiBKU09OIGZpbGUgaXMgbG9hZGVkXG4gKiBAbWV0aG9kIG9uQXRsYXNMb2FkZWRcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuQXRsYXNMb2FkZXIucHJvdG90eXBlLm9uQXRsYXNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYWpheFJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICBpZiAodGhpcy5hamF4UmVxdWVzdC5zdGF0dXMgPT09IDIwMCB8fCB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKCdodHRwJykgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmF0bGFzID0ge1xuICAgICAgICAgICAgICAgIG1ldGEgOiB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlIDogW11cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZyYW1lcyA6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuYWpheFJlcXVlc3QucmVzcG9uc2VUZXh0LnNwbGl0KC9cXHI/XFxuLyk7XG4gICAgICAgICAgICB2YXIgbGluZUNvdW50ID0gLTM7XG5cbiAgICAgICAgICAgIHZhciBjdXJyZW50SW1hZ2VJZCA9IDA7XG4gICAgICAgICAgICB2YXIgY3VycmVudEZyYW1lID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBuYW1lSW5OZXh0TGluZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICAgICAgaiA9IDAsXG4gICAgICAgICAgICAgICAgc2VsZk9uTG9hZGVkID0gdGhpcy5vbkxvYWRlZC5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBwYXJzZXIgd2l0aG91dCByb3RhdGlvbiBzdXBwb3J0IHlldCFcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSByZXN1bHRbaV0ucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbaV0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVJbk5leHRMaW5lID0gaSsxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0W2ldLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVJbk5leHRMaW5lID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0bGFzLm1ldGEuaW1hZ2UucHVzaChyZXN1bHRbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEltYWdlSWQgPSB0aGlzLmF0bGFzLm1ldGEuaW1hZ2UubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXRsYXMuZnJhbWVzLnB1c2goe30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUNvdW50ID0gLTM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGluZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVDb3VudCAlIDcgPT09IDEpIHsgLy8gZnJhbWUgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RnJhbWUgIT0gbnVsbCkgeyAvL2pzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0bGFzLmZyYW1lc1tjdXJyZW50SW1hZ2VJZF1bY3VycmVudEZyYW1lLm5hbWVdID0gY3VycmVudEZyYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RnJhbWUgPSB7IG5hbWU6IHJlc3VsdFtpXSwgZnJhbWUgOiB7fSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHJlc3VsdFtpXS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lQ291bnQgJSA3ID09PSAzKSB7IC8vIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGcmFtZS5mcmFtZS54ID0gTnVtYmVyKHRleHRbMV0ucmVwbGFjZSgnLCcsICcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGcmFtZS5mcmFtZS55ID0gTnVtYmVyKHRleHRbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGluZUNvdW50ICUgNyA9PT0gNCkgeyAvLyBzaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGcmFtZS5mcmFtZS53ID0gTnVtYmVyKHRleHRbMV0ucmVwbGFjZSgnLCcsICcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGcmFtZS5mcmFtZS5oID0gTnVtYmVyKHRleHRbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGluZUNvdW50ICUgNyA9PT0gNSkgeyAvLyByZWFsIHNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlYWxTaXplID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5IDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcgOiBOdW1iZXIodGV4dFsxXS5yZXBsYWNlKCcsJywgJycpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGggOiBOdW1iZXIodGV4dFsyXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVhbFNpemUudyA+IGN1cnJlbnRGcmFtZS5mcmFtZS53IHx8IHJlYWxTaXplLmggPiBjdXJyZW50RnJhbWUuZnJhbWUuaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZyYW1lLnRyaW1tZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZyYW1lLnJlYWxTaXplID0gcmVhbFNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RnJhbWUudHJpbW1lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxpbmVDb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRGcmFtZSAhPSBudWxsKSB7IC8vanNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICAgICAgdGhpcy5hdGxhcy5mcmFtZXNbY3VycmVudEltYWdlSWRdW2N1cnJlbnRGcmFtZS5uYW1lXSA9IGN1cnJlbnRGcmFtZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuYXRsYXMubWV0YS5pbWFnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbWFnZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdGhpcy5hdGxhcy5tZXRhLmltYWdlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNwcml0ZSBzaGVldFxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dHVyZVVybCA9IHRoaXMuYmFzZVVybCArIHRoaXMuYXRsYXMubWV0YS5pbWFnZVtqXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lRGF0YSA9IHRoaXMuYXRsYXMuZnJhbWVzW2pdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlcy5wdXNoKG5ldyBQSVhJLkltYWdlTG9hZGVyKHRleHR1cmVVcmwsIHRoaXMuY3Jvc3NvcmlnaW4pKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgaW4gZnJhbWVEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGZyYW1lRGF0YVtpXS5mcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUElYSS5UZXh0dXJlQ2FjaGVbaV0gPSBuZXcgUElYSS5UZXh0dXJlKHRoaXMuaW1hZ2VzW2pdLnRleHR1cmUuYmFzZVRleHR1cmUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogcmVjdC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiByZWN0LnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiByZWN0LncsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogcmVjdC5oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lRGF0YVtpXS50cmltbWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBJWEkuVGV4dHVyZUNhY2hlW2ldLnJlYWxTaXplID0gZnJhbWVEYXRhW2ldLnJlYWxTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmltIGluIHBpeGkgbm90IHN1cHBvcnRlZCB5ZXQsIHRvZG8gdXBkYXRlIHRyaW0gcHJvcGVydGllcyBpZiBpdCBpcyBkb25lIC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQSVhJLlRleHR1cmVDYWNoZVtpXS50cmltLnggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQSVhJLlRleHR1cmVDYWNoZVtpXS50cmltLnkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEltYWdlSWQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLmltYWdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlc1tqXS5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWQnLCBzZWxmT25Mb2FkZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlc1t0aGlzLmN1cnJlbnRJbWFnZUlkXS5sb2FkKCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkxvYWRlZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogSW52b2tlIHdoZW4ganNvbiBmaWxlIGhhcyBsb2FkZWRcbiAqIEBtZXRob2Qgb25Mb2FkZWRcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuQXRsYXNMb2FkZXIucHJvdG90eXBlLm9uTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmltYWdlcy5sZW5ndGggLSAxID4gdGhpcy5jdXJyZW50SW1hZ2VJZCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRJbWFnZUlkKys7XG4gICAgICAgIHRoaXMuaW1hZ2VzW3RoaXMuY3VycmVudEltYWdlSWRdLmxvYWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICB0eXBlOiAnbG9hZGVkJyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBJbnZva2Ugd2hlbiBlcnJvciBvY2N1cmVkXG4gKiBAbWV0aG9kIG9uRXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuQXRsYXNMb2FkZXIucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgY29udGVudDogdGhpc1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqIFRoZSBzcHJpdGUgc2hlZXQgbG9hZGVyIGlzIHVzZWQgdG8gbG9hZCBpbiBKU09OIHNwcml0ZSBzaGVldCBkYXRhXG4gKiBUbyBnZW5lcmF0ZSB0aGUgZGF0YSB5b3UgY2FuIHVzZSBodHRwOi8vd3d3LmNvZGVhbmR3ZWIuY29tL3RleHR1cmVwYWNrZXIgYW5kIHB1Ymxpc2ggaW4gdGhlICdKU09OJyBmb3JtYXRcbiAqIFRoZXJlIGlzIGEgZnJlZSB2ZXJzaW9uIHNvIHRoYXRzIG5pY2UsIGFsdGhvdWdoIHRoZSBwYWlkIHZlcnNpb24gaXMgZ3JlYXQgdmFsdWUgZm9yIG1vbmV5LlxuICogSXQgaXMgaGlnaGx5IHJlY29tbWVuZGVkIHRvIHVzZSBTcHJpdGUgc2hlZXRzIChhbHNvIGtub3cgYXMgYSAndGV4dHVyZSBhdGxhcycpIGFzIGl0IG1lYW5zIHNwcml0ZXMgY2FuIGJlIGJhdGNoZWQgYW5kIGRyYXduIHRvZ2V0aGVyIGZvciBoaWdobHkgaW5jcmVhc2VkIHJlbmRlcmluZyBzcGVlZC5cbiAqIE9uY2UgdGhlIGRhdGEgaGFzIGJlZW4gbG9hZGVkIHRoZSBmcmFtZXMgYXJlIHN0b3JlZCBpbiB0aGUgUElYSSB0ZXh0dXJlIGNhY2hlIGFuZCBjYW4gYmUgYWNjZXNzZWQgdGhvdWdoIFBJWEkuVGV4dHVyZS5mcm9tRnJhbWVJZCgpIGFuZCBQSVhJLlNwcml0ZS5mcm9tRnJhbWVJZCgpXG4gKiBUaGlzIGxvYWRlciB3aWxsIGxvYWQgdGhlIGltYWdlIGZpbGUgdGhhdCB0aGUgU3ByaXRlc2hlZXQgcG9pbnRzIHRvIGFzIHdlbGwgYXMgdGhlIGRhdGEuXG4gKiBXaGVuIGxvYWRlZCB0aGlzIGNsYXNzIHdpbGwgZGlzcGF0Y2ggYSAnbG9hZGVkJyBldmVudFxuICpcbiAqIEBjbGFzcyBTcHJpdGVTaGVldExvYWRlclxuICogQHVzZXMgRXZlbnRUYXJnZXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHVybCB7U3RyaW5nfSBUaGUgdXJsIG9mIHRoZSBzcHJpdGUgc2hlZXQgSlNPTiBmaWxlXG4gKiBAcGFyYW0gY3Jvc3NvcmlnaW4ge0Jvb2xlYW59IFdoZXRoZXIgcmVxdWVzdHMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgY3Jvc3NvcmlnaW5cbiAqL1xuUElYSS5TcHJpdGVTaGVldExvYWRlciA9IGZ1bmN0aW9uICh1cmwsIGNyb3Nzb3JpZ2luKSB7XG4gICAgLypcbiAgICAgKiBpIHVzZSB0ZXh0dXJlIHBhY2tlciB0byBsb2FkIHRoZSBhc3NldHMuLlxuICAgICAqIGh0dHA6Ly93d3cuY29kZWFuZHdlYi5jb20vdGV4dHVyZXBhY2tlclxuICAgICAqIG1ha2Ugc3VyZSB0byBzZXQgdGhlIGZvcm1hdCBhcyAnSlNPTidcbiAgICAgKi9cbiAgICBQSVhJLkV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdXJsIG9mIHRoZSBiaXRtYXAgZm9udCBkYXRhXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdXJsXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgdGhpcy51cmwgPSB1cmw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSByZXF1ZXN0cyBzaG91bGQgYmUgdHJlYXRlZCBhcyBjcm9zcyBvcmlnaW5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjcm9zc29yaWdpblxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLmNyb3Nzb3JpZ2luID0gY3Jvc3NvcmlnaW47XG5cbiAgICAvKipcbiAgICAgKiBbcmVhZC1vbmx5XSBUaGUgYmFzZSB1cmwgb2YgdGhlIGJpdG1hcCBmb250IGRhdGFcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBiYXNlVXJsXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5iYXNlVXJsID0gdXJsLnJlcGxhY2UoL1teXFwvXSokLywgJycpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRleHR1cmUgYmVpbmcgbG9hZGVkXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdGV4dHVyZVxuICAgICAqIEB0eXBlIFRleHR1cmVcbiAgICAgKi9cbiAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYW1lcyBvZiB0aGUgc3ByaXRlIHNoZWV0XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZnJhbWVzXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgdGhpcy5mcmFtZXMgPSB7fTtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLlNwcml0ZVNoZWV0TG9hZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuU3ByaXRlU2hlZXRMb2FkZXI7XG5cbi8qKlxuICogVGhpcyB3aWxsIGJlZ2luIGxvYWRpbmcgdGhlIEpTT04gZmlsZVxuICpcbiAqIEBtZXRob2QgbG9hZFxuICovXG5QSVhJLlNwcml0ZVNoZWV0TG9hZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgdmFyIGpzb25Mb2FkZXIgPSBuZXcgUElYSS5Kc29uTG9hZGVyKHRoaXMudXJsLCB0aGlzLmNyb3Nzb3JpZ2luKTtcbiAgICBqc29uTG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzY29wZS5qc29uID0gZXZlbnQuY29udGVudC5qc29uO1xuICAgICAgICBzY29wZS5vbkxvYWRlZCgpO1xuICAgIH0pO1xuICAgIGpzb25Mb2FkZXIubG9hZCgpO1xufTtcblxuLyoqXG4gKiBJbnZva2Ugd2hlbiBhbGwgZmlsZXMgYXJlIGxvYWRlZCAoanNvbiBhbmQgdGV4dHVyZSlcbiAqXG4gKiBAbWV0aG9kIG9uTG9hZGVkXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlNwcml0ZVNoZWV0TG9hZGVyLnByb3RvdHlwZS5vbkxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICB0eXBlOiAnbG9hZGVkJyxcbiAgICAgICAgY29udGVudDogdGhpc1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqIFRoZSBpbWFnZSBsb2FkZXIgY2xhc3MgaXMgcmVzcG9uc2libGUgZm9yIGxvYWRpbmcgaW1hZ2VzIGZpbGUgZm9ybWF0cyAoJ2pwZWcnLCAnanBnJywgJ3BuZycgYW5kICdnaWYnKVxuICogT25jZSB0aGUgaW1hZ2UgaGFzIGJlZW4gbG9hZGVkIGl0IGlzIHN0b3JlZCBpbiB0aGUgUElYSSB0ZXh0dXJlIGNhY2hlIGFuZCBjYW4gYmUgYWNjZXNzZWQgdGhvdWdoIFBJWEkuVGV4dHVyZS5mcm9tRnJhbWVJZCgpIGFuZCBQSVhJLlNwcml0ZS5mcm9tRnJhbWVJZCgpXG4gKiBXaGVuIGxvYWRlZCB0aGlzIGNsYXNzIHdpbGwgZGlzcGF0Y2ggYSAnbG9hZGVkJyBldmVudFxuICpcbiAqIEBjbGFzcyBJbWFnZUxvYWRlclxuICogQHVzZXMgRXZlbnRUYXJnZXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHVybCB7U3RyaW5nfSBUaGUgdXJsIG9mIHRoZSBpbWFnZVxuICogQHBhcmFtIGNyb3Nzb3JpZ2luIHtCb29sZWFufSBXaGV0aGVyIHJlcXVlc3RzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGNyb3Nzb3JpZ2luXG4gKi9cblBJWEkuSW1hZ2VMb2FkZXIgPSBmdW5jdGlvbih1cmwsIGNyb3Nzb3JpZ2luKVxue1xuICAgIFBJWEkuRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0dXJlIGJlaW5nIGxvYWRlZFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRleHR1cmVcbiAgICAgKiBAdHlwZSBUZXh0dXJlXG4gICAgICovXG4gICAgdGhpcy50ZXh0dXJlID0gUElYSS5UZXh0dXJlLmZyb21JbWFnZSh1cmwsIGNyb3Nzb3JpZ2luKTtcblxuICAgIC8qKlxuICAgICAqIGlmIHRoZSBpbWFnZSBpcyBsb2FkZWQgd2l0aCBsb2FkRnJhbWVkU3ByaXRlU2hlZXRcbiAgICAgKiBmcmFtZXMgd2lsbCBjb250YWluIHRoZSBzcHJpdGUgc2hlZXQgZnJhbWVzXG4gICAgICpcbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lcyA9IFtdO1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuSW1hZ2VMb2FkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5JbWFnZUxvYWRlcjtcblxuLyoqXG4gKiBMb2FkcyBpbWFnZSBvciB0YWtlcyBpdCBmcm9tIGNhY2hlXG4gKlxuICogQG1ldGhvZCBsb2FkXG4gKi9cblBJWEkuSW1hZ2VMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbigpXG57XG4gICAgaWYoIXRoaXMudGV4dHVyZS5iYXNlVGV4dHVyZS5oYXNMb2FkZWQpXG4gICAge1xuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgICAgICB0aGlzLnRleHR1cmUuYmFzZVRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkJywgZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICBzY29wZS5vbkxvYWRlZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5vbkxvYWRlZCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogSW52b2tlZCB3aGVuIGltYWdlIGZpbGUgaXMgbG9hZGVkIG9yIGl0IGlzIGFscmVhZHkgY2FjaGVkIGFuZCByZWFkeSB0byB1c2VcbiAqXG4gKiBAbWV0aG9kIG9uTG9hZGVkXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkltYWdlTG9hZGVyLnByb3RvdHlwZS5vbkxvYWRlZCA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ICdsb2FkZWQnLCBjb250ZW50OiB0aGlzfSk7XG59O1xuXG4vKipcbiAqIExvYWRzIGltYWdlIGFuZCBzcGxpdCBpdCB0byB1bmlmb3JtIHNpemVkIGZyYW1lc1xuICpcbiAqXG4gKiBAbWV0aG9kIGxvYWRGcmFtZWRTcHJpdGVTaGVldFxuICogQHBhcmFtIGZyYW1lV2lkdGgge051bWJlcn0gd2lkdGggb2YgZWFjaCBmcmFtZVxuICogQHBhcmFtIGZyYW1lSGVpZ2h0IHtOdW1iZXJ9IGhlaWdodCBvZiBlYWNoIGZyYW1lXG4gKiBAcGFyYW0gdGV4dHVyZU5hbWUge1N0cmluZ30gaWYgZ2l2ZW4sIHRoZSBmcmFtZXMgd2lsbCBiZSBjYWNoZWQgaW4gPHRleHR1cmVOYW1lPi08b3JkPiBmb3JtYXRcbiAqL1xuUElYSS5JbWFnZUxvYWRlci5wcm90b3R5cGUubG9hZEZyYW1lZFNwcml0ZVNoZWV0ID0gZnVuY3Rpb24oZnJhbWVXaWR0aCwgZnJhbWVIZWlnaHQsIHRleHR1cmVOYW1lKVxue1xuICAgIHRoaXMuZnJhbWVzID0gW107XG4gICAgdmFyIGNvbHMgPSBNYXRoLmZsb29yKHRoaXMudGV4dHVyZS53aWR0aCAvIGZyYW1lV2lkdGgpO1xuICAgIHZhciByb3dzID0gTWF0aC5mbG9vcih0aGlzLnRleHR1cmUuaGVpZ2h0IC8gZnJhbWVIZWlnaHQpO1xuXG4gICAgdmFyIGk9MDtcbiAgICBmb3IgKHZhciB5PTA7IHk8cm93czsgeSsrKVxuICAgIHtcbiAgICAgICAgZm9yICh2YXIgeD0wOyB4PGNvbHM7IHgrKyxpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gbmV3IFBJWEkuVGV4dHVyZSh0aGlzLnRleHR1cmUsIHtcbiAgICAgICAgICAgICAgICB4OiB4KmZyYW1lV2lkdGgsXG4gICAgICAgICAgICAgICAgeTogeSpmcmFtZUhlaWdodCxcbiAgICAgICAgICAgICAgICB3aWR0aDogZnJhbWVXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGZyYW1lSGVpZ2h0XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5mcmFtZXMucHVzaCh0ZXh0dXJlKTtcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlTmFtZSkgUElYSS5UZXh0dXJlQ2FjaGVbdGV4dHVyZU5hbWUgKyAnLScgKyBpXSA9IHRleHR1cmU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZighdGhpcy50ZXh0dXJlLmJhc2VUZXh0dXJlLmhhc0xvYWRlZClcbiAgICB7XG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICAgIHRoaXMudGV4dHVyZS5iYXNlVGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNjb3BlLm9uTG9hZGVkKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLm9uTG9hZGVkKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqIFRoZSB4bWwgbG9hZGVyIGlzIHVzZWQgdG8gbG9hZCBpbiBYTUwgYml0bWFwIGZvbnQgZGF0YSAoJ3htbCcgb3IgJ2ZudCcpXG4gKiBUbyBnZW5lcmF0ZSB0aGUgZGF0YSB5b3UgY2FuIHVzZSBodHRwOi8vd3d3LmFuZ2VsY29kZS5jb20vcHJvZHVjdHMvYm1mb250L1xuICogVGhpcyBsb2FkZXIgd2lsbCBhbHNvIGxvYWQgdGhlIGltYWdlIGZpbGUgYXMgdGhlIGRhdGEuXG4gKiBXaGVuIGxvYWRlZCB0aGlzIGNsYXNzIHdpbGwgZGlzcGF0Y2ggYSAnbG9hZGVkJyBldmVudFxuICpcbiAqIEBjbGFzcyBCaXRtYXBGb250TG9hZGVyXG4gKiBAdXNlcyBFdmVudFRhcmdldFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gdXJsIHtTdHJpbmd9IFRoZSB1cmwgb2YgdGhlIHNwcml0ZSBzaGVldCBKU09OIGZpbGVcbiAqIEBwYXJhbSBjcm9zc29yaWdpbiB7Qm9vbGVhbn0gV2hldGhlciByZXF1ZXN0cyBzaG91bGQgYmUgdHJlYXRlZCBhcyBjcm9zc29yaWdpblxuICovXG5QSVhJLkJpdG1hcEZvbnRMb2FkZXIgPSBmdW5jdGlvbih1cmwsIGNyb3Nzb3JpZ2luKVxue1xuICAgIC8qXG4gICAgICogSSB1c2UgdGV4dHVyZSBwYWNrZXIgdG8gbG9hZCB0aGUgYXNzZXRzLi5cbiAgICAgKiBodHRwOi8vd3d3LmNvZGVhbmR3ZWIuY29tL3RleHR1cmVwYWNrZXJcbiAgICAgKiBtYWtlIHN1cmUgdG8gc2V0IHRoZSBmb3JtYXQgYXMgJ0pTT04nXG4gICAgICovXG4gICAgUElYSS5FdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHVybCBvZiB0aGUgYml0bWFwIGZvbnQgZGF0YVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHVybFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIHRoaXMudXJsID0gdXJsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVxdWVzdHMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgY3Jvc3Mgb3JpZ2luXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY3Jvc3NvcmlnaW5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5jcm9zc29yaWdpbiA9IGNyb3Nzb3JpZ2luO1xuXG4gICAgLyoqXG4gICAgICogW3JlYWQtb25seV0gVGhlIGJhc2UgdXJsIG9mIHRoZSBiaXRtYXAgZm9udCBkYXRhXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYmFzZVVybFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMuYmFzZVVybCA9IHVybC5yZXBsYWNlKC9bXlxcL10qJC8sICcnKTtcblxuICAgIC8qKlxuICAgICAqIFtyZWFkLW9ubHldIFRoZSB0ZXh0dXJlIG9mIHRoZSBiaXRtYXAgZm9udFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJhc2VVcmxcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuQml0bWFwRm9udExvYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkJpdG1hcEZvbnRMb2FkZXI7XG5cbi8qKlxuICogTG9hZHMgdGhlIFhNTCBmb250IGRhdGFcbiAqXG4gKiBAbWV0aG9kIGxvYWRcbiAqL1xuUElYSS5CaXRtYXBGb250TG9hZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuYWpheFJlcXVlc3QgPSBuZXcgUElYSS5BamF4UmVxdWVzdCgpO1xuICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgdGhpcy5hamF4UmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpXG4gICAge1xuICAgICAgICBzY29wZS5vblhNTExvYWRlZCgpO1xuICAgIH07XG5cbiAgICB0aGlzLmFqYXhSZXF1ZXN0Lm9wZW4oJ0dFVCcsIHRoaXMudXJsLCB0cnVlKTtcbiAgICBpZiAodGhpcy5hamF4UmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlKSB0aGlzLmFqYXhSZXF1ZXN0Lm92ZXJyaWRlTWltZVR5cGUoJ2FwcGxpY2F0aW9uL3htbCcpO1xuICAgIHRoaXMuYWpheFJlcXVlc3Quc2VuZChudWxsKTtcbn07XG5cbi8qKlxuICogSW52b2tlZCB3aGVuIHRoZSBYTUwgZmlsZSBpcyBsb2FkZWQsIHBhcnNlcyB0aGUgZGF0YVxuICpcbiAqIEBtZXRob2Qgb25YTUxMb2FkZWRcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuQml0bWFwRm9udExvYWRlci5wcm90b3R5cGUub25YTUxMb2FkZWQgPSBmdW5jdGlvbigpXG57XG4gICAgaWYgKHRoaXMuYWpheFJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gNClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmFqYXhSZXF1ZXN0LnN0YXR1cyA9PT0gMjAwIHx8IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbC5pbmRleE9mKCdodHRwJykgPT09IC0xKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2VYTUwgPSB0aGlzLmFqYXhSZXF1ZXN0LnJlc3BvbnNlWE1MO1xuICAgICAgICAgICAgaWYoIXJlc3BvbnNlWE1MIHx8IC9NU0lFIDkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IG5hdmlnYXRvci5pc0NvY29vbkpTKSB7XG4gICAgICAgICAgICAgICAgaWYodHlwZW9mKHdpbmRvdy5ET01QYXJzZXIpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb21wYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlWE1MID0gZG9tcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh0aGlzLmFqYXhSZXF1ZXN0LnJlc3BvbnNlVGV4dCwgJ3RleHQveG1sJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gdGhpcy5hamF4UmVxdWVzdC5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlWE1MID0gZGl2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRleHR1cmVVcmwgPSB0aGlzLmJhc2VVcmwgKyByZXNwb25zZVhNTC5nZXRFbGVtZW50c0J5VGFnTmFtZSgncGFnZScpWzBdLmdldEF0dHJpYnV0ZSgnZmlsZScpO1xuICAgICAgICAgICAgdmFyIGltYWdlID0gbmV3IFBJWEkuSW1hZ2VMb2FkZXIodGV4dHVyZVVybCwgdGhpcy5jcm9zc29yaWdpbik7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmUgPSBpbWFnZS50ZXh0dXJlLmJhc2VUZXh0dXJlO1xuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICAgICAgdmFyIGluZm8gPSByZXNwb25zZVhNTC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5mbycpWzBdO1xuICAgICAgICAgICAgdmFyIGNvbW1vbiA9IHJlc3BvbnNlWE1MLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdjb21tb24nKVswXTtcbiAgICAgICAgICAgIGRhdGEuZm9udCA9IGluZm8uZ2V0QXR0cmlidXRlKCdmYWNlJyk7XG4gICAgICAgICAgICBkYXRhLnNpemUgPSBwYXJzZUludChpbmZvLmdldEF0dHJpYnV0ZSgnc2l6ZScpLCAxMCk7XG4gICAgICAgICAgICBkYXRhLmxpbmVIZWlnaHQgPSBwYXJzZUludChjb21tb24uZ2V0QXR0cmlidXRlKCdsaW5lSGVpZ2h0JyksIDEwKTtcbiAgICAgICAgICAgIGRhdGEuY2hhcnMgPSB7fTtcblxuICAgICAgICAgICAgLy9wYXJzZSBsZXR0ZXJzXG4gICAgICAgICAgICB2YXIgbGV0dGVycyA9IHJlc3BvbnNlWE1MLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdjaGFyJyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV0dGVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhckNvZGUgPSBwYXJzZUludChsZXR0ZXJzW2ldLmdldEF0dHJpYnV0ZSgnaWQnKSwgMTApO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRleHR1cmVSZWN0ID0gbmV3IFBJWEkuUmVjdGFuZ2xlKFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChsZXR0ZXJzW2ldLmdldEF0dHJpYnV0ZSgneCcpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGxldHRlcnNbaV0uZ2V0QXR0cmlidXRlKCd5JyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQobGV0dGVyc1tpXS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQobGV0dGVyc1tpXS5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpLCAxMClcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgZGF0YS5jaGFyc1tjaGFyQ29kZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHhPZmZzZXQ6IHBhcnNlSW50KGxldHRlcnNbaV0uZ2V0QXR0cmlidXRlKCd4b2Zmc2V0JyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgeU9mZnNldDogcGFyc2VJbnQobGV0dGVyc1tpXS5nZXRBdHRyaWJ1dGUoJ3lvZmZzZXQnKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICB4QWR2YW5jZTogcGFyc2VJbnQobGV0dGVyc1tpXS5nZXRBdHRyaWJ1dGUoJ3hhZHZhbmNlJyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAga2VybmluZzoge30sXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmU6IFBJWEkuVGV4dHVyZUNhY2hlW2NoYXJDb2RlXSA9IG5ldyBQSVhJLlRleHR1cmUodGhpcy50ZXh0dXJlLCB0ZXh0dXJlUmVjdClcblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vcGFyc2Uga2VybmluZ3NcbiAgICAgICAgICAgIHZhciBrZXJuaW5ncyA9IHJlc3BvbnNlWE1MLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdrZXJuaW5nJyk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2VybmluZ3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gcGFyc2VJbnQoa2VybmluZ3NbaV0uZ2V0QXR0cmlidXRlKCdmaXJzdCcpLCAxMCk7XG4gICAgICAgICAgICAgICAgdmFyIHNlY29uZCA9IHBhcnNlSW50KGtlcm5pbmdzW2ldLmdldEF0dHJpYnV0ZSgnc2Vjb25kJyksIDEwKTtcbiAgICAgICAgICAgICAgICB2YXIgYW1vdW50ID0gcGFyc2VJbnQoa2VybmluZ3NbaV0uZ2V0QXR0cmlidXRlKCdhbW91bnQnKSwgMTApO1xuXG4gICAgICAgICAgICAgICAgZGF0YS5jaGFyc1tzZWNvbmRdLmtlcm5pbmdbZmlyc3RdID0gYW1vdW50O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFBJWEkuQml0bWFwVGV4dC5mb250c1tkYXRhLmZvbnRdID0gZGF0YTtcblxuICAgICAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICAgICAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNjb3BlLm9uTG9hZGVkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGltYWdlLmxvYWQoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogSW52b2tlZCB3aGVuIGFsbCBmaWxlcyBhcmUgbG9hZGVkICh4bWwvZm50IGFuZCB0ZXh0dXJlKVxuICpcbiAqIEBtZXRob2Qgb25Mb2FkZWRcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuQml0bWFwRm9udExvYWRlci5wcm90b3R5cGUub25Mb2FkZWQgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiAnbG9hZGVkJywgY29udGVudDogdGhpc30pO1xufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqIGJhc2VkIG9uIHBpeGkgaW1wYWN0IHNwaW5lIGltcGxlbWVudGF0aW9uIG1hZGUgYnkgRWVtZWxpIEtlbG9rb3JwaSAoQGVrZWxva29ycGkpIGh0dHBzOi8vZ2l0aHViLmNvbS9la2Vsb2tvcnBpXG4gKlxuICogQXdlc29tZSBKUyBydW4gdGltZSBwcm92aWRlZCBieSBFc290ZXJpY1NvZnR3YXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vRXNvdGVyaWNTb2Z0d2FyZS9zcGluZS1ydW50aW1lc1xuICpcbiAqL1xuXG4vKipcbiAqIFRoZSBTcGluZSBsb2FkZXIgaXMgdXNlZCB0byBsb2FkIGluIEpTT04gc3BpbmUgZGF0YVxuICogVG8gZ2VuZXJhdGUgdGhlIGRhdGEgeW91IG5lZWQgdG8gdXNlIGh0dHA6Ly9lc290ZXJpY3NvZnR3YXJlLmNvbS8gYW5kIGV4cG9ydCBpbiB0aGUgXCJKU09OXCIgZm9ybWF0XG4gKiBEdWUgdG8gYSBjbGFzaCBvZiBuYW1lcyAgWW91IHdpbGwgbmVlZCB0byBjaGFuZ2UgdGhlIGV4dGVuc2lvbiBvZiB0aGUgc3BpbmUgZmlsZSBmcm9tICouanNvbiB0byAqLmFuaW0gZm9yIGl0IHRvIGxvYWRcbiAqIFNlZSBleGFtcGxlIDEyIChodHRwOi8vd3d3Lmdvb2Rib3lkaWdpdGFsLmNvbS9waXhpanMvZXhhbXBsZXMvMTIvKSB0byBzZWUgYSB3b3JraW5nIGV4YW1wbGUgYW5kIGNoZWNrIG91dCB0aGUgc291cmNlXG4gKiBZb3Ugd2lsbCBuZWVkIHRvIGdlbmVyYXRlIGEgc3ByaXRlIHNoZWV0IHRvIGFjY29tcGFueSB0aGUgc3BpbmUgZGF0YVxuICogV2hlbiBsb2FkZWQgdGhpcyBjbGFzcyB3aWxsIGRpc3BhdGNoIGEgXCJsb2FkZWRcIiBldmVudFxuICpcbiAqIEBjbGFzcyBTcGluZVxuICogQHVzZXMgRXZlbnRUYXJnZXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHVybCB7U3RyaW5nfSBUaGUgdXJsIG9mIHRoZSBKU09OIGZpbGVcbiAqIEBwYXJhbSBjcm9zc29yaWdpbiB7Qm9vbGVhbn0gV2hldGhlciByZXF1ZXN0cyBzaG91bGQgYmUgdHJlYXRlZCBhcyBjcm9zc29yaWdpblxuICovXG5QSVhJLlNwaW5lTG9hZGVyID0gZnVuY3Rpb24odXJsLCBjcm9zc29yaWdpbilcbntcbiAgICBQSVhJLkV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdXJsIG9mIHRoZSBiaXRtYXAgZm9udCBkYXRhXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdXJsXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgdGhpcy51cmwgPSB1cmw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSByZXF1ZXN0cyBzaG91bGQgYmUgdHJlYXRlZCBhcyBjcm9zcyBvcmlnaW5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjcm9zc29yaWdpblxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLmNyb3Nzb3JpZ2luID0gY3Jvc3NvcmlnaW47XG5cbiAgICAvKipcbiAgICAgKiBbcmVhZC1vbmx5XSBXaGV0aGVyIHRoZSBkYXRhIGhhcyBsb2FkZWQgeWV0XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbG9hZGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG59O1xuXG5QSVhJLlNwaW5lTG9hZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuU3BpbmVMb2FkZXI7XG5cbi8qKlxuICogTG9hZHMgdGhlIEpTT04gZGF0YVxuICpcbiAqIEBtZXRob2QgbG9hZFxuICovXG5QSVhJLlNwaW5lTG9hZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICB2YXIganNvbkxvYWRlciA9IG5ldyBQSVhJLkpzb25Mb2FkZXIodGhpcy51cmwsIHRoaXMuY3Jvc3NvcmlnaW4pO1xuICAgIGpzb25Mb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc2NvcGUuanNvbiA9IGV2ZW50LmNvbnRlbnQuanNvbjtcbiAgICAgICAgc2NvcGUub25Mb2FkZWQoKTtcbiAgICB9KTtcbiAgICBqc29uTG9hZGVyLmxvYWQoKTtcbn07XG5cbi8qKlxuICogSW52b2tlIHdoZW4gSlNPTiBmaWxlIGlzIGxvYWRlZFxuICpcbiAqIEBtZXRob2Qgb25Mb2FkZWRcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuU3BpbmVMb2FkZXIucHJvdG90eXBlLm9uTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6IFwibG9hZGVkXCIsIGNvbnRlbnQ6IHRoaXN9KTtcbn07XG5cblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGNyZWF0aW5nIGEgcGl4aS5qcyBmaWx0ZXIuIEN1cnJlbnRseSBvbmx5IHdlYkdMIHN1cHBvcnRzIGZpbHRlcnMuXG4gKiBJZiB5b3Ugd2FudCB0byBtYWtlIGEgY3VzdG9tIGZpbHRlciB0aGlzIHNob3VsZCBiZSB5b3VyIGJhc2UgY2xhc3MuXG4gKiBAY2xhc3MgQWJzdHJhY3RGaWx0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGZyYWdtZW50U3JjXG4gKiBAcGFyYW0gdW5pZm9ybXNcbiAqL1xuUElYSS5BYnN0cmFjdEZpbHRlciA9IGZ1bmN0aW9uKGZyYWdtZW50U3JjLCB1bmlmb3JtcylcbntcbiAgICAvKipcbiAgICAqIEFuIGFycmF5IG9mIHBhc3NlcyAtIHNvbWUgZmlsdGVycyBjb250YWluIGEgZmV3IHN0ZXBzIHRoaXMgYXJyYXkgc2ltcGx5IHN0b3JlcyB0aGUgc3RlcHMgaW4gYSBsaW5pZWFyIGZhc2hpb24uXG4gICAgKiBGb3IgZXhhbXBsZSB0aGUgYmx1ciBmaWx0ZXIgaGFzIHR3byBwYXNzZXMgYmx1clggYW5kIGJsdXJZLlxuICAgICogQHByb3BlcnR5IHBhc3Nlc1xuICAgICogQHR5cGUgQXJyYXkgYW4gYXJyYXkgb2YgZmlsdGVyIG9iamVjdHNcbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLnBhc3NlcyA9IFt0aGlzXTtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHNoYWRlcnNcbiAgICAqIEB0eXBlIEFycmF5IGFuIGFycmF5IG9mIHNoYWRlcnNcbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLnNoYWRlcnMgPSBbXTtcbiAgICBcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLnBhZGRpbmcgPSAwO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkgdW5pZm9ybXNcbiAgICAqIEB0eXBlIG9iamVjdFxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMudW5pZm9ybXMgPSB1bmlmb3JtcyB8fCB7fTtcbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSBmcmFnbWVudFNyY1xuICAgICogQHR5cGUgQXJyYXlcbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLmZyYWdtZW50U3JjID0gZnJhZ21lbnRTcmMgfHwgW107XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICpcbiAqIFRoZSBBbHBoYU1hc2tGaWx0ZXIgY2xhc3MgdXNlcyB0aGUgcGl4ZWwgdmFsdWVzIGZyb20gdGhlIHNwZWNpZmllZCB0ZXh0dXJlIChjYWxsZWQgdGhlIGRpc3BsYWNlbWVudCBtYXApIHRvIHBlcmZvcm0gYSBkaXNwbGFjZW1lbnQgb2YgYW4gb2JqZWN0LlxuICogWW91IGNhbiB1c2UgdGhpcyBmaWx0ZXIgdG8gYXBwbHkgYWxsIG1hbm9yIG9mIGNyYXp5IHdhcnBpbmcgZWZmZWN0c1xuICogQ3VycmVudGx5IHRoZSByIHByb3BlcnR5IG9mIHRoZSB0ZXh0dXJlIGlzIHVzZWQgdG8gb2Zmc2V0IHRoZSB4IGFuZCB0aGUgZyBwcm9wZXJ5IG9mIHRoZSB0ZXh0dXJlIGlzIHVzZWQgdG8gb2Zmc2V0IHRoZSB5LlxuICogQGNsYXNzIEFscGhhTWFza0ZpbHRlclxuICogQGNvbnRydWN0b3JcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfSBUaGUgdGV4dHVyZSB1c2VkIGZvciB0aGUgZGlzcGxhY2VtdGVudCBtYXAgKiBtdXN0IGJlIHBvd2VyIG9mIDIgdGV4dHVyZSBhdCB0aGUgbW9tZW50XG4gKi9cblBJWEkuQWxwaGFNYXNrRmlsdGVyID0gZnVuY3Rpb24odGV4dHVyZSlcbntcbiAgICBQSVhJLkFic3RyYWN0RmlsdGVyLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMucGFzc2VzID0gW3RoaXNdO1xuICAgIHRleHR1cmUuYmFzZVRleHR1cmUuX3Bvd2VyT2YyID0gdHJ1ZTtcblxuICAgIC8vIHNldCB0aGUgdW5pZm9ybXNcbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgICBtYXNrOiB7dHlwZTogJ3NhbXBsZXIyRCcsIHZhbHVlOnRleHR1cmV9LFxuICAgICAgICBtYXBEaW1lbnNpb25zOiAgIHt0eXBlOiAnMmYnLCB2YWx1ZTp7eDoxLCB5OjUxMTJ9fSxcbiAgICAgICAgZGltZW5zaW9uczogICB7dHlwZTogJzRmdicsIHZhbHVlOlswLDAsMCwwXX1cbiAgICB9O1xuXG4gICAgaWYodGV4dHVyZS5iYXNlVGV4dHVyZS5oYXNMb2FkZWQpXG4gICAge1xuICAgICAgICB0aGlzLnVuaWZvcm1zLm1hc2sudmFsdWUueCA9IHRleHR1cmUud2lkdGg7XG4gICAgICAgIHRoaXMudW5pZm9ybXMubWFzay52YWx1ZS55ID0gdGV4dHVyZS5oZWlnaHQ7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMuYm91bmRMb2FkZWRGdW5jdGlvbiA9IHRoaXMub25UZXh0dXJlTG9hZGVkLmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5vbignbG9hZGVkJywgdGhpcy5ib3VuZExvYWRlZEZ1bmN0aW9uKTtcbiAgICB9XG5cbiAgICB0aGlzLmZyYWdtZW50U3JjID0gW1xuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCBtYXNrOycsXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMyIG9mZnNldDsnLFxuICAgICAgICAndW5pZm9ybSB2ZWM0IGRpbWVuc2lvbnM7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiBtYXBEaW1lbnNpb25zOycsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIHZlYzIgbWFwQ29yZHMgPSB2VGV4dHVyZUNvb3JkLnh5OycsXG4gICAgICAgICcgICBtYXBDb3JkcyArPSAoZGltZW5zaW9ucy56dyArIG9mZnNldCkvIGRpbWVuc2lvbnMueHkgOycsXG4gICAgICAgICcgICBtYXBDb3Jkcy55ICo9IC0xLjA7JyxcbiAgICAgICAgJyAgIG1hcENvcmRzLnkgKz0gMS4wOycsXG4gICAgICAgICcgICBtYXBDb3JkcyAqPSBkaW1lbnNpb25zLnh5IC8gbWFwRGltZW5zaW9uczsnLFxuXG4gICAgICAgICcgICB2ZWM0IG9yaWdpbmFsID0gIHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7JyxcbiAgICAgICAgJyAgIGZsb2F0IG1hc2tBbHBoYSA9ICB0ZXh0dXJlMkQobWFzaywgbWFwQ29yZHMpLnI7JyxcbiAgICAgICAgJyAgIG9yaWdpbmFsICo9IG1hc2tBbHBoYTsnLFxuICAgICAgICAvLycgICBvcmlnaW5hbC5yZ2IgKj0gbWFza0FscGhhOycsXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSAgb3JpZ2luYWw7JyxcbiAgICAgICAgLy8nICAgZ2xfRnJhZ0NvbG9yID0gZ2xfRnJhZ0NvbG9yOycsXG4gICAgICAgICd9J1xuICAgIF07XG59O1xuXG5QSVhJLkFscGhhTWFza0ZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQSVhJLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSApO1xuUElYSS5BbHBoYU1hc2tGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5BbHBoYU1hc2tGaWx0ZXI7XG5cblBJWEkuQWxwaGFNYXNrRmlsdGVyLnByb3RvdHlwZS5vblRleHR1cmVMb2FkZWQgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy51bmlmb3Jtcy5tYXBEaW1lbnNpb25zLnZhbHVlLnggPSB0aGlzLnVuaWZvcm1zLm1hc2sudmFsdWUud2lkdGg7XG4gICAgdGhpcy51bmlmb3Jtcy5tYXBEaW1lbnNpb25zLnZhbHVlLnkgPSB0aGlzLnVuaWZvcm1zLm1hc2sudmFsdWUuaGVpZ2h0O1xuXG4gICAgdGhpcy51bmlmb3Jtcy5tYXNrLnZhbHVlLmJhc2VUZXh0dXJlLm9mZignbG9hZGVkJywgdGhpcy5ib3VuZExvYWRlZEZ1bmN0aW9uKTtcbn07XG5cbi8qKlxuICogVGhlIHRleHR1cmUgdXNlZCBmb3IgdGhlIGRpc3BsYWNlbXRlbnQgbWFwICogbXVzdCBiZSBwb3dlciBvZiAyIHRleHR1cmUgYXQgdGhlIG1vbWVudFxuICpcbiAqIEBwcm9wZXJ0eSBtYXBcbiAqIEB0eXBlIFRleHR1cmVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuQWxwaGFNYXNrRmlsdGVyLnByb3RvdHlwZSwgJ21hcCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5tYXNrLnZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnVuaWZvcm1zLm1hc2sudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICpcbiAqIFRoZSBDb2xvck1hdHJpeEZpbHRlciBjbGFzcyBsZXRzIHlvdSBhcHBseSBhIDR4NCBtYXRyaXggdHJhbnNmb3JtYXRpb24gb24gdGhlIFJHQkFcbiAqIGNvbG9yIGFuZCBhbHBoYSB2YWx1ZXMgb2YgZXZlcnkgcGl4ZWwgb24geW91ciBkaXNwbGF5T2JqZWN0IHRvIHByb2R1Y2UgYSByZXN1bHRcbiAqIHdpdGggYSBuZXcgc2V0IG9mIFJHQkEgY29sb3IgYW5kIGFscGhhIHZhbHVlcy4gSXRzIHByZXR0eSBwb3dlcmZ1bCFcbiAqIEBjbGFzcyBDb2xvck1hdHJpeEZpbHRlclxuICogQGNvbnRydWN0b3JcbiAqL1xuUElYSS5Db2xvck1hdHJpeEZpbHRlciA9IGZ1bmN0aW9uKClcbntcbiAgICBQSVhJLkFic3RyYWN0RmlsdGVyLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMucGFzc2VzID0gW3RoaXNdO1xuXG4gICAgLy8gc2V0IHRoZSB1bmlmb3Jtc1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICAgIG1hdHJpeDoge3R5cGU6ICdtYXQ0JywgdmFsdWU6IFsxLDAsMCwwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwxLDAsMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsMCwxLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLDAsMCwxXX1cbiAgICB9O1xuXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxuICAgICAgICAndW5pZm9ybSBmbG9hdCBpbnZlcnQ7JyxcbiAgICAgICAgJ3VuaWZvcm0gbWF0NCBtYXRyaXg7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiBtYXRyaXg7JyxcbiAgICAgIC8vICAnICAgZ2xfRnJhZ0NvbG9yID0gZ2xfRnJhZ0NvbG9yOycsXG4gICAgICAgICd9J1xuICAgIF07XG59O1xuXG5QSVhJLkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBJWEkuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlICk7XG5QSVhJLkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuQ29sb3JNYXRyaXhGaWx0ZXI7XG5cbi8qKlxuICogU2V0cyB0aGUgbWF0cml4IG9mIHRoZSBjb2xvciBtYXRyaXggZmlsdGVyXG4gKlxuICogQHByb3BlcnR5IG1hdHJpeFxuICogQHR5cGUgQXJyYXkgYW5kIGFycmF5IG9mIDI2IG51bWJlcnNcbiAqIEBkZWZhdWx0IFsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUsICdtYXRyaXgnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubWF0cml4LnZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnVuaWZvcm1zLm1hdHJpeC52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn0pO1xuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqXG4gKiBUaGlzIHR1cm5zIHlvdXIgZGlzcGxheU9iamVjdHMgdG8gYmxhY2sgYW5kIHdoaXRlLlxuICogQGNsYXNzIEdyYXlGaWx0ZXJcbiAqIEBjb250cnVjdG9yXG4gKi9cblBJWEkuR3JheUZpbHRlciA9IGZ1bmN0aW9uKClcbntcbiAgICBQSVhJLkFic3RyYWN0RmlsdGVyLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMucGFzc2VzID0gW3RoaXNdO1xuXG4gICAgLy8gc2V0IHRoZSB1bmlmb3Jtc1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICAgIGdyYXk6IHt0eXBlOiAnMWYnLCB2YWx1ZTogMX1cbiAgICB9O1xuXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgZ3JheTsnLFxuXG4gICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpOycsXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IucmdiID0gbWl4KGdsX0ZyYWdDb2xvci5yZ2IsIHZlYzMoMC4yMTI2KmdsX0ZyYWdDb2xvci5yICsgMC43MTUyKmdsX0ZyYWdDb2xvci5nICsgMC4wNzIyKmdsX0ZyYWdDb2xvci5iKSwgZ3JheSk7JyxcbiAgICAgLy8gICAnICAgZ2xfRnJhZ0NvbG9yID0gZ2xfRnJhZ0NvbG9yOycsXG4gICAgICAgICd9J1xuICAgIF07XG59O1xuXG5QSVhJLkdyYXlGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUElYSS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUgKTtcblBJWEkuR3JheUZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkdyYXlGaWx0ZXI7XG5cbi8qKlxuVGhlIHN0cmVuZ3RoIG9mIHRoZSBncmF5LiAxIHdpbGwgbWFrZSB0aGUgb2JqZWN0IGJsYWNrIGFuZCB3aGl0ZSwgMCB3aWxsIG1ha2UgdGhlIG9iamVjdCBpdHMgbm9ybWFsIGNvbG9yXG5AcHJvcGVydHkgZ3JheVxuKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLkdyYXlGaWx0ZXIucHJvdG90eXBlLCAnZ3JheScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5ncmF5LnZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnVuaWZvcm1zLmdyYXkudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqXG4gKiBUaGUgRGlzcGxhY2VtZW50RmlsdGVyIGNsYXNzIHVzZXMgdGhlIHBpeGVsIHZhbHVlcyBmcm9tIHRoZSBzcGVjaWZpZWQgdGV4dHVyZSAoY2FsbGVkIHRoZSBkaXNwbGFjZW1lbnQgbWFwKSB0byBwZXJmb3JtIGEgZGlzcGxhY2VtZW50IG9mIGFuIG9iamVjdC5cbiAqIFlvdSBjYW4gdXNlIHRoaXMgZmlsdGVyIHRvIGFwcGx5IGFsbCBtYW5vciBvZiBjcmF6eSB3YXJwaW5nIGVmZmVjdHNcbiAqIEN1cnJlbnRseSB0aGUgciBwcm9wZXJ0eSBvZiB0aGUgdGV4dHVyZSBpcyB1c2VkIG9mZnNldCB0aGUgeCBhbmQgdGhlIGcgcHJvcGVyeSBvZiB0aGUgdGV4dHVyZSBpcyB1c2VkIHRvIG9mZnNldCB0aGUgeS5cbiAqIEBjbGFzcyBEaXNwbGFjZW1lbnRGaWx0ZXJcbiAqIEBjb250cnVjdG9yXG4gKiBAcGFyYW0gdGV4dHVyZSB7VGV4dHVyZX0gVGhlIHRleHR1cmUgdXNlZCBmb3IgdGhlIGRpc3BsYWNlbXRlbnQgbWFwICogbXVzdCBiZSBwb3dlciBvZiAyIHRleHR1cmUgYXQgdGhlIG1vbWVudFxuICovXG5QSVhJLkRpc3BsYWNlbWVudEZpbHRlciA9IGZ1bmN0aW9uKHRleHR1cmUpXG57XG4gICAgUElYSS5BYnN0cmFjdEZpbHRlci5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnBhc3NlcyA9IFt0aGlzXTtcbiAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLl9wb3dlck9mMiA9IHRydWU7XG5cbiAgICAvLyBzZXQgdGhlIHVuaWZvcm1zXG4gICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgICAgZGlzcGxhY2VtZW50TWFwOiB7dHlwZTogJ3NhbXBsZXIyRCcsIHZhbHVlOnRleHR1cmV9LFxuICAgICAgICBzY2FsZTogICAgICAgICAgIHt0eXBlOiAnMmYnLCB2YWx1ZTp7eDozMCwgeTozMH19LFxuICAgICAgICBvZmZzZXQ6ICAgICAgICAgIHt0eXBlOiAnMmYnLCB2YWx1ZTp7eDowLCB5OjB9fSxcbiAgICAgICAgbWFwRGltZW5zaW9uczogICB7dHlwZTogJzJmJywgdmFsdWU6e3g6MSwgeTo1MTEyfX0sXG4gICAgICAgIGRpbWVuc2lvbnM6ICAge3R5cGU6ICc0ZnYnLCB2YWx1ZTpbMCwwLDAsMF19XG4gICAgfTtcblxuICAgIGlmKHRleHR1cmUuYmFzZVRleHR1cmUuaGFzTG9hZGVkKVxuICAgIHtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5tYXBEaW1lbnNpb25zLnZhbHVlLnggPSB0ZXh0dXJlLndpZHRoO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLm1hcERpbWVuc2lvbnMudmFsdWUueSA9IHRleHR1cmUuaGVpZ2h0O1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLmJvdW5kTG9hZGVkRnVuY3Rpb24gPSB0aGlzLm9uVGV4dHVyZUxvYWRlZC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRleHR1cmUuYmFzZVRleHR1cmUub24oJ2xvYWRlZCcsIHRoaXMuYm91bmRMb2FkZWRGdW5jdGlvbik7XG4gICAgfVxuXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgZGlzcGxhY2VtZW50TWFwOycsXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMyIHNjYWxlOycsXG4gICAgICAgICd1bmlmb3JtIHZlYzIgb2Zmc2V0OycsXG4gICAgICAgICd1bmlmb3JtIHZlYzQgZGltZW5zaW9uczsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMyIG1hcERpbWVuc2lvbnM7JywvLyA9IHZlYzIoMjU2LjAsIDI1Ni4wKTsnLFxuICAgICAgICAvLyAnY29uc3QgdmVjMiB0ZXh0dXJlRGltZW5zaW9ucyA9IHZlYzIoNzUwLjAsIDc1MC4wKTsnLFxuXG4gICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICcgICB2ZWMyIG1hcENvcmRzID0gdlRleHR1cmVDb29yZC54eTsnLFxuICAgICAgICAvLycgICBtYXBDb3JkcyAtPSA7JyxcbiAgICAgICAgJyAgIG1hcENvcmRzICs9IChkaW1lbnNpb25zLnp3ICsgb2Zmc2V0KS8gZGltZW5zaW9ucy54eSA7JyxcbiAgICAgICAgJyAgIG1hcENvcmRzLnkgKj0gLTEuMDsnLFxuICAgICAgICAnICAgbWFwQ29yZHMueSArPSAxLjA7JyxcbiAgICAgICAgJyAgIHZlYzIgbWF0U2FtcGxlID0gdGV4dHVyZTJEKGRpc3BsYWNlbWVudE1hcCwgbWFwQ29yZHMpLnh5OycsXG4gICAgICAgICcgICBtYXRTYW1wbGUgLT0gMC41OycsXG4gICAgICAgICcgICBtYXRTYW1wbGUgKj0gc2NhbGU7JyxcbiAgICAgICAgJyAgIG1hdFNhbXBsZSAvPSBtYXBEaW1lbnNpb25zOycsXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54ICsgbWF0U2FtcGxlLngsIHZUZXh0dXJlQ29vcmQueSArIG1hdFNhbXBsZS55KSk7JyxcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvci5yZ2IgPSBtaXgoIGdsX0ZyYWdDb2xvci5yZ2IsIGdsX0ZyYWdDb2xvci5yZ2IsIDEuMCk7JyxcbiAgICAgICAgJyAgIHZlYzIgY29yZCA9IHZUZXh0dXJlQ29vcmQ7JyxcblxuICAgICAgICAvLycgICBnbF9GcmFnQ29sb3IgPSAgdGV4dHVyZTJEKGRpc3BsYWNlbWVudE1hcCwgY29yZCk7JyxcbiAgICAgLy8gICAnICAgZ2xfRnJhZ0NvbG9yID0gZ2xfRnJhZ0NvbG9yOycsXG4gICAgICAgICd9J1xuICAgIF07XG59O1xuXG5QSVhJLkRpc3BsYWNlbWVudEZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQSVhJLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSApO1xuUElYSS5EaXNwbGFjZW1lbnRGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5EaXNwbGFjZW1lbnRGaWx0ZXI7XG5cblBJWEkuRGlzcGxhY2VtZW50RmlsdGVyLnByb3RvdHlwZS5vblRleHR1cmVMb2FkZWQgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy51bmlmb3Jtcy5tYXBEaW1lbnNpb25zLnZhbHVlLnggPSB0aGlzLnVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZS53aWR0aDtcbiAgICB0aGlzLnVuaWZvcm1zLm1hcERpbWVuc2lvbnMudmFsdWUueSA9IHRoaXMudW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlLmhlaWdodDtcblxuICAgIHRoaXMudW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlLmJhc2VUZXh0dXJlLm9mZignbG9hZGVkJywgdGhpcy5ib3VuZExvYWRlZEZ1bmN0aW9uKTtcbn07XG5cbi8qKlxuICogVGhlIHRleHR1cmUgdXNlZCBmb3IgdGhlIGRpc3BsYWNlbXRlbnQgbWFwICogbXVzdCBiZSBwb3dlciBvZiAyIHRleHR1cmUgYXQgdGhlIG1vbWVudFxuICpcbiAqIEBwcm9wZXJ0eSBtYXBcbiAqIEB0eXBlIFRleHR1cmVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuRGlzcGxhY2VtZW50RmlsdGVyLnByb3RvdHlwZSwgJ21hcCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogVGhlIG11bHRpcGxpZXIgdXNlZCB0byBzY2FsZSB0aGUgZGlzcGxhY2VtZW50IHJlc3VsdCBmcm9tIHRoZSBtYXAgY2FsY3VsYXRpb24uXG4gKlxuICogQHByb3BlcnR5IHNjYWxlXG4gKiBAdHlwZSBQb2ludFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5EaXNwbGFjZW1lbnRGaWx0ZXIucHJvdG90eXBlLCAnc2NhbGUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuc2NhbGUudmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuc2NhbGUudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBUaGUgb2Zmc2V0IHVzZWQgdG8gbW92ZSB0aGUgZGlzcGxhY2VtZW50IG1hcC5cbiAqXG4gKiBAcHJvcGVydHkgb2Zmc2V0XG4gKiBAdHlwZSBQb2ludFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5EaXNwbGFjZW1lbnRGaWx0ZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm9mZnNldC52YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5vZmZzZXQudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqXG4gKiBUaGlzIGZpbHRlciBhcHBsaWVzIGEgcGl4ZWxhdGUgZWZmZWN0IG1ha2luZyBkaXNwbGF5IG9iamVjdHMgYXBwZWFyICdibG9ja3knXG4gKiBAY2xhc3MgUGl4ZWxhdGVGaWx0ZXJcbiAqIEBjb250cnVjdG9yXG4gKi9cblBJWEkuUGl4ZWxhdGVGaWx0ZXIgPSBmdW5jdGlvbigpXG57XG4gICAgUElYSS5BYnN0cmFjdEZpbHRlci5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnBhc3NlcyA9IFt0aGlzXTtcblxuICAgIC8vIHNldCB0aGUgdW5pZm9ybXNcbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgICBpbnZlcnQ6IHt0eXBlOiAnMWYnLCB2YWx1ZTogMH0sXG4gICAgICAgIGRpbWVuc2lvbnM6IHt0eXBlOiAnNGZ2JywgdmFsdWU6bmV3IEZsb2F0MzJBcnJheShbMTAwMDAsIDEwMCwgMTAsIDEwXSl9LFxuICAgICAgICBwaXhlbFNpemU6IHt0eXBlOiAnMmYnLCB2YWx1ZTp7eDoxMCwgeToxMH19XG4gICAgfTtcblxuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBbXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiB0ZXN0RGltOycsXG4gICAgICAgICd1bmlmb3JtIHZlYzQgZGltZW5zaW9uczsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMyIHBpeGVsU2l6ZTsnLFxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgdmVjMiBjb29yZCA9IHZUZXh0dXJlQ29vcmQ7JyxcblxuICAgICAgICAnICAgdmVjMiBzaXplID0gZGltZW5zaW9ucy54eS9waXhlbFNpemU7JyxcblxuICAgICAgICAnICAgdmVjMiBjb2xvciA9IGZsb29yKCAoIHZUZXh0dXJlQ29vcmQgKiBzaXplICkgKSAvIHNpemUgKyBwaXhlbFNpemUvZGltZW5zaW9ucy54eSAqIDAuNTsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCBjb2xvcik7JyxcbiAgICAgICAgJ30nXG4gICAgXTtcbn07XG5cblBJWEkuUGl4ZWxhdGVGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUElYSS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUgKTtcblBJWEkuUGl4ZWxhdGVGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5QaXhlbGF0ZUZpbHRlcjtcblxuLyoqXG4gKlxuICogVGhpcyBhIHBvaW50IHRoYXQgZGVzY3JpYmVzIHRoZSBzaXplIG9mIHRoZSBibG9jcy4geCBpcyB0aGUgd2lkdGggb2YgdGhlIGJsb2NrIGFuZCB5IGlzIHRoZSB0aGUgaGVpZ2h0XG4gKiBAcHJvcGVydHkgc2l6ZVxuICogQHR5cGUgUG9pbnRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuUGl4ZWxhdGVGaWx0ZXIucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5waXhlbFNpemUudmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnBpeGVsU2l6ZS52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cblBJWEkuQmx1clhGaWx0ZXIgPSBmdW5jdGlvbigpXG57XG4gICAgUElYSS5BYnN0cmFjdEZpbHRlci5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnBhc3NlcyA9IFt0aGlzXTtcblxuICAgIC8vIHNldCB0aGUgdW5pZm9ybXNcbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgICBibHVyOiB7dHlwZTogJzFmJywgdmFsdWU6IDEvNTEyfVxuICAgIH07XG5cbiAgICB0aGlzLmZyYWdtZW50U3JjID0gW1xuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IGJsdXI7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIHZlYzQgc3VtID0gdmVjNCgwLjApOycsXG5cbiAgICAgICAgJyAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54IC0gNC4wKmJsdXIsIHZUZXh0dXJlQ29vcmQueSkpICogMC4wNTsnLFxuICAgICAgICAnICAgc3VtICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLnggLSAzLjAqYmx1ciwgdlRleHR1cmVDb29yZC55KSkgKiAwLjA5OycsXG4gICAgICAgICcgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCAtIDIuMCpibHVyLCB2VGV4dHVyZUNvb3JkLnkpKSAqIDAuMTI7JyxcbiAgICAgICAgJyAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54IC0gYmx1ciwgdlRleHR1cmVDb29yZC55KSkgKiAwLjE1OycsXG4gICAgICAgICcgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCwgdlRleHR1cmVDb29yZC55KSkgKiAwLjE2OycsXG4gICAgICAgICcgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCArIGJsdXIsIHZUZXh0dXJlQ29vcmQueSkpICogMC4xNTsnLFxuICAgICAgICAnICAgc3VtICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLnggKyAyLjAqYmx1ciwgdlRleHR1cmVDb29yZC55KSkgKiAwLjEyOycsXG4gICAgICAgICcgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCArIDMuMCpibHVyLCB2VGV4dHVyZUNvb3JkLnkpKSAqIDAuMDk7JyxcbiAgICAgICAgJyAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54ICsgNC4wKmJsdXIsIHZUZXh0dXJlQ29vcmQueSkpICogMC4wNTsnLFxuXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSBzdW07JyxcbiAgICAgICAgJ30nXG4gICAgXTtcbn07XG5cblBJWEkuQmx1clhGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUElYSS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUgKTtcblBJWEkuQmx1clhGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5CbHVyWEZpbHRlcjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuQmx1clhGaWx0ZXIucHJvdG90eXBlLCAnYmx1cicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5ibHVyLnZhbHVlIC8gKDEvNzAwMCk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuYmx1ci52YWx1ZSA9ICgxLzcwMDApICogdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuUElYSS5CbHVyWUZpbHRlciA9IGZ1bmN0aW9uKClcbntcbiAgICBQSVhJLkFic3RyYWN0RmlsdGVyLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMucGFzc2VzID0gW3RoaXNdO1xuXG4gICAgLy8gc2V0IHRoZSB1bmlmb3Jtc1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICAgIGJsdXI6IHt0eXBlOiAnMWYnLCB2YWx1ZTogMS81MTJ9XG4gICAgfTtcblxuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBbXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgYmx1cjsnLFxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgdmVjNCBzdW0gPSB2ZWM0KDAuMCk7JyxcblxuICAgICAgICAnICAgc3VtICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLngsIHZUZXh0dXJlQ29vcmQueSAtIDQuMCpibHVyKSkgKiAwLjA1OycsXG4gICAgICAgICcgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCwgdlRleHR1cmVDb29yZC55IC0gMy4wKmJsdXIpKSAqIDAuMDk7JyxcbiAgICAgICAgJyAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54LCB2VGV4dHVyZUNvb3JkLnkgLSAyLjAqYmx1cikpICogMC4xMjsnLFxuICAgICAgICAnICAgc3VtICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLngsIHZUZXh0dXJlQ29vcmQueSAtIGJsdXIpKSAqIDAuMTU7JyxcbiAgICAgICAgJyAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54LCB2VGV4dHVyZUNvb3JkLnkpKSAqIDAuMTY7JyxcbiAgICAgICAgJyAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54LCB2VGV4dHVyZUNvb3JkLnkgKyBibHVyKSkgKiAwLjE1OycsXG4gICAgICAgICcgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCwgdlRleHR1cmVDb29yZC55ICsgMi4wKmJsdXIpKSAqIDAuMTI7JyxcbiAgICAgICAgJyAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54LCB2VGV4dHVyZUNvb3JkLnkgKyAzLjAqYmx1cikpICogMC4wOTsnLFxuICAgICAgICAnICAgc3VtICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLngsIHZUZXh0dXJlQ29vcmQueSArIDQuMCpibHVyKSkgKiAwLjA1OycsXG5cbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHN1bTsnLFxuICAgICAgICAnfSdcbiAgICBdO1xufTtcblxuUElYSS5CbHVyWUZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQSVhJLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSApO1xuUElYSS5CbHVyWUZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkJsdXJZRmlsdGVyO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5CbHVyWUZpbHRlci5wcm90b3R5cGUsICdibHVyJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmJsdXIudmFsdWUgLyAoMS83MDAwKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy90aGlzLnBhZGRpbmcgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5ibHVyLnZhbHVlID0gKDEvNzAwMCkgKiB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqXG4gKiBUaGUgQmx1ckZpbHRlciBhcHBsaWVzIGEgR2F1c3NpYW4gYmx1ciB0byBhbiBvYmplY3QuXG4gKiBUaGUgc3RyZW5ndGggb2YgdGhlIGJsdXIgY2FuIGJlIHNldCBmb3IgeC0gYW5kIHktYXhpcyBzZXBhcmF0ZWx5IChhbHdheXMgcmVsYXRpdmUgdG8gdGhlIHN0YWdlKS5cbiAqXG4gKiBAY2xhc3MgQmx1ckZpbHRlclxuICogQGNvbnRydWN0b3JcbiAqL1xuUElYSS5CbHVyRmlsdGVyID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuYmx1clhGaWx0ZXIgPSBuZXcgUElYSS5CbHVyWEZpbHRlcigpO1xuICAgIHRoaXMuYmx1cllGaWx0ZXIgPSBuZXcgUElYSS5CbHVyWUZpbHRlcigpO1xuXG4gICAgdGhpcy5wYXNzZXMgPVt0aGlzLmJsdXJYRmlsdGVyLCB0aGlzLmJsdXJZRmlsdGVyXTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgc3RyZW5ndGggb2YgYm90aCB0aGUgYmx1clggYW5kIGJsdXJZIHByb3BlcnRpZXMgc2ltdWx0YW5lb3VzbHlcbiAqXG4gKiBAcHJvcGVydHkgYmx1clxuICogQHR5cGUgTnVtYmVyIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1clxuICogQGRlZmF1bHQgMlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5CbHVyRmlsdGVyLnByb3RvdHlwZSwgJ2JsdXInLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmx1clhGaWx0ZXIuYmx1cjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5ibHVyWEZpbHRlci5ibHVyID0gdGhpcy5ibHVyWUZpbHRlci5ibHVyID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RyZW5ndGggb2YgdGhlIGJsdXJYIHByb3BlcnR5XG4gKlxuICogQHByb3BlcnR5IGJsdXJYXG4gKiBAdHlwZSBOdW1iZXIgdGhlIHN0cmVuZ3RoIG9mIHRoZSBibHVyWFxuICogQGRlZmF1bHQgMlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5CbHVyRmlsdGVyLnByb3RvdHlwZSwgJ2JsdXJYJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsdXJYRmlsdGVyLmJsdXI7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYmx1clhGaWx0ZXIuYmx1ciA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIHRoZSBibHVyWCBwcm9wZXJ0eVxuICpcbiAqIEBwcm9wZXJ0eSBibHVyWVxuICogQHR5cGUgTnVtYmVyIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1cllcbiAqIEBkZWZhdWx0IDJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuQmx1ckZpbHRlci5wcm90b3R5cGUsICdibHVyWScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibHVyWUZpbHRlci5ibHVyO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLmJsdXJZRmlsdGVyLmJsdXIgPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqXG4gKiBUaGlzIGludmVydHMgeW91ciBkaXNwbGF5T2JqZWN0cyBjb2xvcnMuXG4gKiBAY2xhc3MgSW52ZXJ0RmlsdGVyXG4gKiBAY29udHJ1Y3RvclxuICovXG5QSVhJLkludmVydEZpbHRlciA9IGZ1bmN0aW9uKClcbntcbiAgICBQSVhJLkFic3RyYWN0RmlsdGVyLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMucGFzc2VzID0gW3RoaXNdO1xuXG4gICAgLy8gc2V0IHRoZSB1bmlmb3Jtc1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICAgIGludmVydDoge3R5cGU6ICcxZicsIHZhbHVlOiAxfVxuICAgIH07XG5cbiAgICB0aGlzLmZyYWdtZW50U3JjID0gW1xuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IGludmVydDsnLFxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yLnJnYiA9IG1peCggKHZlYzMoMSktZ2xfRnJhZ0NvbG9yLnJnYikgKiBnbF9GcmFnQ29sb3IuYSwgZ2xfRnJhZ0NvbG9yLnJnYiwgMS4wIC0gaW52ZXJ0KTsnLFxuICAgICAgICAvLycgICBnbF9GcmFnQ29sb3IucmdiID0gZ2xfRnJhZ0NvbG9yLnJnYiAgKiBnbF9GcmFnQ29sb3IuYTsnLFxuICAgICAgLy8gICcgICBnbF9GcmFnQ29sb3IgPSBnbF9GcmFnQ29sb3IgKiB2Q29sb3I7JyxcbiAgICAgICAgJ30nXG4gICAgXTtcbn07XG5cblBJWEkuSW52ZXJ0RmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBJWEkuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlICk7XG5QSVhJLkludmVydEZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkludmVydEZpbHRlcjtcblxuLyoqXG5UaGUgc3RyZW5ndGggb2YgdGhlIGludmVydC4gMSB3aWxsIGZ1bGx5IGludmVydCB0aGUgY29sb3JzLCAwIHdpbGwgbWFrZSB0aGUgb2JqZWN0IGl0cyBub3JtYWwgY29sb3JcbkBwcm9wZXJ0eSBpbnZlcnRcbiovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5JbnZlcnRGaWx0ZXIucHJvdG90eXBlLCAnaW52ZXJ0Jywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmludmVydC52YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5pbnZlcnQudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqXG4gKiBUaGlzIGFwcGxpZXMgYSBzZXBpYSBlZmZlY3QgdG8geW91ciBkaXNwbGF5T2JqZWN0cy5cbiAqIEBjbGFzcyBTZXBpYUZpbHRlclxuICogQGNvbnRydWN0b3JcbiAqL1xuUElYSS5TZXBpYUZpbHRlciA9IGZ1bmN0aW9uKClcbntcbiAgICBQSVhJLkFic3RyYWN0RmlsdGVyLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMucGFzc2VzID0gW3RoaXNdO1xuXG4gICAgLy8gc2V0IHRoZSB1bmlmb3Jtc1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICAgIHNlcGlhOiB7dHlwZTogJzFmJywgdmFsdWU6IDF9XG4gICAgfTtcblxuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBbXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgc2VwaWE7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG5cbiAgICAgICAgJ2NvbnN0IG1hdDMgc2VwaWFNYXRyaXggPSBtYXQzKDAuMzU4OCwgMC43MDQ0LCAwLjEzNjgsIDAuMjk5MCwgMC41ODcwLCAwLjExNDAsIDAuMjM5MiwgMC40Njk2LCAwLjA5MTIpOycsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7JyxcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvci5yZ2IgPSBtaXgoIGdsX0ZyYWdDb2xvci5yZ2IsIGdsX0ZyYWdDb2xvci5yZ2IgKiBzZXBpYU1hdHJpeCwgc2VwaWEpOycsXG4gICAgICAgLy8gJyAgIGdsX0ZyYWdDb2xvciA9IGdsX0ZyYWdDb2xvciAqIHZDb2xvcjsnLFxuICAgICAgICAnfSdcbiAgICBdO1xufTtcblxuUElYSS5TZXBpYUZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQSVhJLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSApO1xuUElYSS5TZXBpYUZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLlNlcGlhRmlsdGVyO1xuXG4vKipcblRoZSBzdHJlbmd0aCBvZiB0aGUgc2VwaWEuIDEgd2lsbCBhcHBseSB0aGUgZnVsbCBzZXBpYSBlZmZlY3QsIDAgd2lsbCBtYWtlIHRoZSBvYmplY3QgaXRzIG5vcm1hbCBjb2xvclxuQHByb3BlcnR5IHNlcGlhXG4qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuU2VwaWFGaWx0ZXIucHJvdG90eXBlLCAnc2VwaWEnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuc2VwaWEudmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuc2VwaWEudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqXG4gKiBUaGlzIGZpbHRlciBhcHBsaWVzIGEgdHdpc3QgZWZmZWN0IG1ha2luZyBkaXNwbGF5IG9iamVjdHMgYXBwZWFyIHR3aXN0ZWQgaW4gdGhlIGdpdmVuIGRpcmVjdGlvblxuICogQGNsYXNzIFR3aXN0RmlsdGVyXG4gKiBAY29udHJ1Y3RvclxuICovXG5QSVhJLlR3aXN0RmlsdGVyID0gZnVuY3Rpb24oKVxue1xuICAgIFBJWEkuQWJzdHJhY3RGaWx0ZXIuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5wYXNzZXMgPSBbdGhpc107XG5cbiAgICAvLyBzZXQgdGhlIHVuaWZvcm1zXG4gICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgICAgcmFkaXVzOiB7dHlwZTogJzFmJywgdmFsdWU6MC41fSxcbiAgICAgICAgYW5nbGU6IHt0eXBlOiAnMWYnLCB2YWx1ZTo1fSxcbiAgICAgICAgb2Zmc2V0OiB7dHlwZTogJzJmJywgdmFsdWU6e3g6MC41LCB5OjAuNX19XG4gICAgfTtcblxuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBbXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjNCBkaW1lbnNpb25zOycsXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLFxuXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHJhZGl1czsnLFxuICAgICAgICAndW5pZm9ybSBmbG9hdCBhbmdsZTsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMyIG9mZnNldDsnLFxuXG4gICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICcgICB2ZWMyIGNvb3JkID0gdlRleHR1cmVDb29yZCAtIG9mZnNldDsnLFxuICAgICAgICAnICAgZmxvYXQgZGlzdGFuY2UgPSBsZW5ndGgoY29vcmQpOycsXG5cbiAgICAgICAgJyAgIGlmIChkaXN0YW5jZSA8IHJhZGl1cykgeycsXG4gICAgICAgICcgICAgICAgZmxvYXQgcmF0aW8gPSAocmFkaXVzIC0gZGlzdGFuY2UpIC8gcmFkaXVzOycsXG4gICAgICAgICcgICAgICAgZmxvYXQgYW5nbGVNb2QgPSByYXRpbyAqIHJhdGlvICogYW5nbGU7JyxcbiAgICAgICAgJyAgICAgICBmbG9hdCBzID0gc2luKGFuZ2xlTW9kKTsnLFxuICAgICAgICAnICAgICAgIGZsb2F0IGMgPSBjb3MoYW5nbGVNb2QpOycsXG4gICAgICAgICcgICAgICAgY29vcmQgPSB2ZWMyKGNvb3JkLnggKiBjIC0gY29vcmQueSAqIHMsIGNvb3JkLnggKiBzICsgY29vcmQueSAqIGMpOycsXG4gICAgICAgICcgICB9JyxcblxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCBjb29yZCtvZmZzZXQpOycsXG4gICAgICAgICd9J1xuICAgIF07XG59O1xuXG5QSVhJLlR3aXN0RmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBJWEkuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlICk7XG5QSVhJLlR3aXN0RmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuVHdpc3RGaWx0ZXI7XG5cbi8qKlxuICpcbiAqIFRoaXMgcG9pbnQgZGVzY3JpYmVzIHRoZSB0aGUgb2Zmc2V0IG9mIHRoZSB0d2lzdFxuICogQHByb3BlcnR5IHNpemVcbiAqIEB0eXBlIFBvaW50XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLlR3aXN0RmlsdGVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5vZmZzZXQudmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLm9mZnNldC52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqXG4gKiBUaGlzIHJhZGl1cyBkZXNjcmliZXMgc2l6ZSBvZiB0aGUgdHdpc3RcbiAqIEBwcm9wZXJ0eSBzaXplXG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuVHdpc3RGaWx0ZXIucHJvdG90eXBlLCAncmFkaXVzJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnJhZGl1cy52YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMudW5pZm9ybXMucmFkaXVzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICpcbiAqIFRoaXMgcmFkaXVzIGRlc2NyaWJlcyBhbmdsZSBvZiB0aGUgdHdpc3RcbiAqIEBwcm9wZXJ0eSBhbmdsZVxuICogQHR5cGUgTnVtYmVyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLlR3aXN0RmlsdGVyLnByb3RvdHlwZSwgJ2FuZ2xlJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmFuZ2xlLnZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5hbmdsZS52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn0pO1xuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqXG4gKiBUaGlzIGxvd2VycyB0aGUgY29sb3IgZGVwdGggb2YgeW91ciBpbWFnZSBieSB0aGUgZ2l2ZW4gYW1vdW50LCBwcm9kdWNpbmcgYW4gaW1hZ2Ugd2l0aCBhIHNtYWxsZXIgcGFsZXR0ZS5cbiAqIEBjbGFzcyBDb2xvclN0ZXBGaWx0ZXJcbiAqIEBjb250cnVjdG9yXG4gKi9cblBJWEkuQ29sb3JTdGVwRmlsdGVyID0gZnVuY3Rpb24oKVxue1xuICAgIFBJWEkuQWJzdHJhY3RGaWx0ZXIuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5wYXNzZXMgPSBbdGhpc107XG5cbiAgICAvLyBzZXQgdGhlIHVuaWZvcm1zXG4gICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgICAgc3RlcDoge3R5cGU6ICcxZicsIHZhbHVlOiA1fVxuICAgIH07XG5cbiAgICB0aGlzLmZyYWdtZW50U3JjID0gW1xuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLFxuICAgICAgICAndW5pZm9ybSBmbG9hdCBzdGVwOycsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpOycsXG4gICAgICAgICcgICBjb2xvciA9IGZsb29yKGNvbG9yICogc3RlcCkgLyBzdGVwOycsXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjsnLFxuICAgICAgICAnfSdcbiAgICBdO1xufTtcblxuUElYSS5Db2xvclN0ZXBGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUElYSS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUgKTtcblBJWEkuQ29sb3JTdGVwRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuQ29sb3JTdGVwRmlsdGVyO1xuXG4vKipcblRoZSBudW1iZXIgb2Ygc3RlcHMuXG5AcHJvcGVydHkgc3RlcFxuKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLkNvbG9yU3RlcEZpbHRlci5wcm90b3R5cGUsICdzdGVwJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnN0ZXAudmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuc3RlcC52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICogb3JpZ2luYWwgZmlsdGVyOiBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvZ2xmeC5qcy9ibG9iL21hc3Rlci9zcmMvZmlsdGVycy9mdW4vZG90c2NyZWVuLmpzXG4gKi9cblxuLyoqXG4gKlxuICogVGhpcyBmaWx0ZXIgYXBwbGllcyBhIGRvdHNjcmVlbiBlZmZlY3QgbWFraW5nIGRpc3BsYXkgb2JqZWN0cyBhcHBlYXIgdG8gYmUgbWFkZSBvdXQgb2YgYmxhY2sgYW5kIHdoaXRlIGhhbGZ0b25lIGRvdHMgbGlrZSBhbiBvbGQgcHJpbnRlclxuICogQGNsYXNzIERvdFNjcmVlbkZpbHRlclxuICogQGNvbnRydWN0b3JcbiAqL1xuUElYSS5Eb3RTY3JlZW5GaWx0ZXIgPSBmdW5jdGlvbigpXG57XG4gICAgUElYSS5BYnN0cmFjdEZpbHRlci5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnBhc3NlcyA9IFt0aGlzXTtcblxuICAgIC8vIHNldCB0aGUgdW5pZm9ybXNcbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgICBzY2FsZToge3R5cGU6ICcxZicsIHZhbHVlOjF9LFxuICAgICAgICBhbmdsZToge3R5cGU6ICcxZicsIHZhbHVlOjV9LFxuICAgICAgICBkaW1lbnNpb25zOiAgIHt0eXBlOiAnNGZ2JywgdmFsdWU6WzAsMCwwLDBdfVxuICAgIH07XG5cbiAgICB0aGlzLmZyYWdtZW50U3JjID0gW1xuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG4gICAgICAgICd1bmlmb3JtIHZlYzQgZGltZW5zaW9uczsnLFxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcblxuICAgICAgICAndW5pZm9ybSBmbG9hdCBhbmdsZTsnLFxuICAgICAgICAndW5pZm9ybSBmbG9hdCBzY2FsZTsnLFxuXG4gICAgICAgICdmbG9hdCBwYXR0ZXJuKCkgeycsXG4gICAgICAgICcgICBmbG9hdCBzID0gc2luKGFuZ2xlKSwgYyA9IGNvcyhhbmdsZSk7JyxcbiAgICAgICAgJyAgIHZlYzIgdGV4ID0gdlRleHR1cmVDb29yZCAqIGRpbWVuc2lvbnMueHk7JyxcbiAgICAgICAgJyAgIHZlYzIgcG9pbnQgPSB2ZWMyKCcsXG4gICAgICAgICcgICAgICAgYyAqIHRleC54IC0gcyAqIHRleC55LCcsXG4gICAgICAgICcgICAgICAgcyAqIHRleC54ICsgYyAqIHRleC55JyxcbiAgICAgICAgJyAgICkgKiBzY2FsZTsnLFxuICAgICAgICAnICAgcmV0dXJuIChzaW4ocG9pbnQueCkgKiBzaW4ocG9pbnQueSkpICogNC4wOycsXG4gICAgICAgICd9JyxcblxuICAgICAgICAndm9pZCBtYWluKCkgeycsXG4gICAgICAgICcgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTsnLFxuICAgICAgICAnICAgZmxvYXQgYXZlcmFnZSA9IChjb2xvci5yICsgY29sb3IuZyArIGNvbG9yLmIpIC8gMy4wOycsXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlYzMoYXZlcmFnZSAqIDEwLjAgLSA1LjAgKyBwYXR0ZXJuKCkpLCBjb2xvci5hKTsnLFxuICAgICAgICAnfSdcbiAgICBdO1xufTtcblxuUElYSS5Eb3RTY3JlZW5GaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUElYSS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUgKTtcblBJWEkuRG90U2NyZWVuRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuRG90U2NyZWVuRmlsdGVyO1xuXG4vKipcbiAqXG4gKiBUaGlzIGRlc2NyaWJlcyB0aGUgdGhlIHNjYWxlXG4gKiBAcHJvcGVydHkgc2NhbGVcbiAqIEB0eXBlIE51bWJlclxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5Eb3RTY3JlZW5GaWx0ZXIucHJvdG90eXBlLCAnc2NhbGUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuc2NhbGUudmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICpcbiAqIFRoaXMgcmFkaXVzIGRlc2NyaWJlcyBhbmdsZVxuICogQHByb3BlcnR5IGFuZ2xlXG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuRG90U2NyZWVuRmlsdGVyLnByb3RvdHlwZSwgJ2FuZ2xlJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmFuZ2xlLnZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5hbmdsZS52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cblBJWEkuQ3Jvc3NIYXRjaEZpbHRlciA9IGZ1bmN0aW9uKClcbntcbiAgICBQSVhJLkFic3RyYWN0RmlsdGVyLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMucGFzc2VzID0gW3RoaXNdO1xuXG4gICAgLy8gc2V0IHRoZSB1bmlmb3Jtc1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICAgIGJsdXI6IHt0eXBlOiAnMWYnLCB2YWx1ZTogMSAvIDUxMn1cbiAgICB9O1xuXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxuICAgICAgICAndW5pZm9ybSBmbG9hdCBibHVyOycsXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLFxuXG4gICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICcgICAgZmxvYXQgbHVtID0gbGVuZ3RoKHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZC54eSkucmdiKTsnLFxuXG4gICAgICAgICcgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAxLjApOycsXG5cbiAgICAgICAgJyAgICBpZiAobHVtIDwgMS4wMCkgeycsXG4gICAgICAgICcgICAgICAgIGlmIChtb2QoZ2xfRnJhZ0Nvb3JkLnggKyBnbF9GcmFnQ29vcmQueSwgMTAuMCkgPT0gMC4wKSB7JyxcbiAgICAgICAgJyAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKTsnLFxuICAgICAgICAnICAgICAgICB9JyxcbiAgICAgICAgJyAgICB9JyxcblxuICAgICAgICAnICAgIGlmIChsdW0gPCAwLjc1KSB7JyxcbiAgICAgICAgJyAgICAgICAgaWYgKG1vZChnbF9GcmFnQ29vcmQueCAtIGdsX0ZyYWdDb29yZC55LCAxMC4wKSA9PSAwLjApIHsnLFxuICAgICAgICAnICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApOycsXG4gICAgICAgICcgICAgICAgIH0nLFxuICAgICAgICAnICAgIH0nLFxuXG4gICAgICAgICcgICAgaWYgKGx1bSA8IDAuNTApIHsnLFxuICAgICAgICAnICAgICAgICBpZiAobW9kKGdsX0ZyYWdDb29yZC54ICsgZ2xfRnJhZ0Nvb3JkLnkgLSA1LjAsIDEwLjApID09IDAuMCkgeycsXG4gICAgICAgICcgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCk7JyxcbiAgICAgICAgJyAgICAgICAgfScsXG4gICAgICAgICcgICAgfScsXG5cbiAgICAgICAgJyAgICBpZiAobHVtIDwgMC4zKSB7JyxcbiAgICAgICAgJyAgICAgICAgaWYgKG1vZChnbF9GcmFnQ29vcmQueCAtIGdsX0ZyYWdDb29yZC55IC0gNS4wLCAxMC4wKSA9PSAwLjApIHsnLFxuICAgICAgICAnICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApOycsXG4gICAgICAgICcgICAgICAgIH0nLFxuICAgICAgICAnICAgIH0nLFxuICAgICAgICAnfSdcbiAgICBdO1xufTtcblxuUElYSS5Dcm9zc0hhdGNoRmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBJWEkuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlICk7XG5QSVhJLkNyb3NzSGF0Y2hGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5CbHVyWUZpbHRlcjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuQ3Jvc3NIYXRjaEZpbHRlci5wcm90b3R5cGUsICdibHVyJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmJsdXIudmFsdWUgLyAoMS83MDAwKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy90aGlzLnBhZGRpbmcgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5ibHVyLnZhbHVlID0gKDEvNzAwMCkgKiB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG5QSVhJLlJHQlNwbGl0RmlsdGVyID0gZnVuY3Rpb24oKVxue1xuICAgIFBJWEkuQWJzdHJhY3RGaWx0ZXIuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5wYXNzZXMgPSBbdGhpc107XG5cbiAgICAvLyBzZXQgdGhlIHVuaWZvcm1zXG4gICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgICAgcmVkOiB7dHlwZTogJzJmJywgdmFsdWU6IHt4OjIwLCB5OjIwfX0sXG4gICAgICAgIGdyZWVuOiB7dHlwZTogJzJmJywgdmFsdWU6IHt4Oi0yMCwgeToyMH19LFxuICAgICAgICBibHVlOiB7dHlwZTogJzJmJywgdmFsdWU6IHt4OjIwLCB5Oi0yMH19LFxuICAgICAgICBkaW1lbnNpb25zOiAgIHt0eXBlOiAnNGZ2JywgdmFsdWU6WzAsMCwwLDBdfVxuICAgIH07XG5cbiAgICB0aGlzLmZyYWdtZW50U3JjID0gW1xuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG4gICAgICAgICd1bmlmb3JtIHZlYzIgcmVkOycsXG4gICAgICAgICd1bmlmb3JtIHZlYzIgZ3JlZW47JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiBibHVlOycsXG4gICAgICAgICd1bmlmb3JtIHZlYzQgZGltZW5zaW9uczsnLFxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yLnIgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQgKyByZWQvZGltZW5zaW9ucy54eSkucjsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yLmcgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQgKyBncmVlbi9kaW1lbnNpb25zLnh5KS5nOycsXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IuYiA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCArIGJsdWUvZGltZW5zaW9ucy54eSkuYjsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yLmEgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpLmE7JyxcbiAgICAgICAgJ30nXG4gICAgXTtcbn07XG5cblBJWEkuUkdCU3BsaXRGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUElYSS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUgKTtcblBJWEkuUkdCU3BsaXRGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5SR0JTcGxpdEZpbHRlcjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuUkdCU3BsaXRGaWx0ZXIucHJvdG90eXBlLCAnYW5nbGUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuYmx1ci52YWx1ZSAvICgxLzcwMDApO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvL3RoaXMucGFkZGluZyA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLmJsdXIudmFsdWUgPSAoMS83MDAwKSAqIHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gUElYSTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzLlBJWEkgPSBQSVhJO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoUElYSSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5QSVhJID0gUElYSTtcbiAgICB9XG59KS5jYWxsKHRoaXMpOyIsIihmdW5jdGlvbigpIHtcblxudmFyIFBJWEk7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuXHRQSVhJID0gcmVxdWlyZShcInBpeGkuanNcIik7XG59IGVsc2Uge1xuXHRQSVhJID0gd2luZG93LlBJWEk7XG59XG4vKipcbiAqIEFTMy9qcXVlcnkgc3R5bGUgZXZlbnQgZGlzcGF0Y2hlci4gU2xpZ2h0bHkgbW9kaWZpZWQuIFRoZVxuICoganF1ZXJ5IHN0eWxlIG9uL29mZi90cmlnZ2VyIHN0eWxlIG9mIGFkZGluZyBsaXN0ZW5lcnMgaXNcbiAqIGN1cnJlbnRseSB0aGUgcHJlZmVycmVkIG9uZS5cbiAqXG4gKiBUaGUgb24gbWV0aG9kIGZvciBhZGRpbmcgbGlzdGVuZXJzIHRha2VzIGFuIGV4dHJhIHBhcmFtZXRlciB3aGljaCBpcyB0aGVcbiAqIHNjb3BlIGluIHdoaWNoIGxpc3RlbmVycyBzaG91bGQgYmUgY2FsbGVkLiBTbyB0aGlzOlxuICpcbiAqICAgICBvYmplY3Qub24oXCJldmVudFwiLCBsaXN0ZW5lciwgdGhpcyk7XG4gKlxuICogSGFzIHRoZSBzYW1lIGZ1bmN0aW9uIHdoZW4gYWRkaW5nIGV2ZW50cyBhczpcbiAqXG4gKiAgICAgb2JqZWN0Lm9uKFwiZXZlbnRcIiwgbGlzdGVuZXIuYmluZCh0aGlzKSk7XG4gKlxuICogSG93ZXZlciwgdGhlIGRpZmZlcmVuY2UgaXMgdGhhdCBpZiB3ZSB1c2UgdGhlIHNlY29uZCBtZXRob2QgaXRcbiAqIHdpbGwgbm90IGJlIHBvc3NpYmxlIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJzIGxhdGVyLCB1bmxlc3NcbiAqIHRoZSBjbG9zdXJlIGNyZWF0ZWQgYnkgYmluZCBpcyBzdG9yZWQgc29tZXdoZXJlLiBJZiB0aGVcbiAqIGZpcnN0IG1ldGhvZCBpcyB1c2VkLCB3ZSBjYW4gcmVtb3ZlIHRoZSBsaXN0ZW5lciB3aXRoOlxuICpcbiAqICAgICBvYmplY3Qub2ZmKFwiZXZlbnRcIiwgbGlzdGVuZXIsIHRoaXMpO1xuICpcbiAqIEBjbGFzcyBFdmVudERpc3BhdGNoZXJcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBFdmVudERpc3BhdGNoZXIoKSB7XG5cdHRoaXMubGlzdGVuZXJNYXAgPSB7fTtcbn1cblxuLyoqXG4gKiBBZGQgZXZlbnQgbGlzdGVuZXIuXG4gKiBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXJcbiAqL1xuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lciwgc2NvcGUpIHtcblx0aWYgKCF0aGlzLmxpc3RlbmVyTWFwKVxuXHRcdHRoaXMubGlzdGVuZXJNYXAgPSB7fTtcblxuXHRpZiAoIWV2ZW50VHlwZSlcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCB0eXBlIHJlcXVpcmVkIGZvciBldmVudCBkaXNwYXRjaGVyXCIpO1xuXG5cdGlmICghbGlzdGVuZXIpXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiTGlzdGVuZXIgcmVxdWlyZWQgZm9yIGV2ZW50IGRpc3BhdGNoZXJcIik7XG5cblx0dGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIHNjb3BlKTtcblxuXHRpZiAoIXRoaXMubGlzdGVuZXJNYXAuaGFzT3duUHJvcGVydHkoZXZlbnRUeXBlKSlcblx0XHR0aGlzLmxpc3RlbmVyTWFwW2V2ZW50VHlwZV0gPSBbXTtcblxuXHR0aGlzLmxpc3RlbmVyTWFwW2V2ZW50VHlwZV0ucHVzaCh7XG5cdFx0bGlzdGVuZXI6IGxpc3RlbmVyLFxuXHRcdHNjb3BlOiBzY29wZVxuXHR9KTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXIuXG4gKiBAbWV0aG9kIHJlbW92ZUV2ZW50TGlzdGVuZXJcbiAqL1xuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lciwgc2NvcGUpIHtcblx0aWYgKCF0aGlzLmxpc3RlbmVyTWFwKVxuXHRcdHRoaXMubGlzdGVuZXJNYXAgPSB7fTtcblxuXHRpZiAoIXRoaXMubGlzdGVuZXJNYXAuaGFzT3duUHJvcGVydHkoZXZlbnRUeXBlKSlcblx0XHRyZXR1cm47XG5cblx0dmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJNYXBbZXZlbnRUeXBlXTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBsaXN0ZW5lck9iaiA9IGxpc3RlbmVyc1tpXTtcblxuXHRcdGlmIChsaXN0ZW5lciA9PSBsaXN0ZW5lck9iai5saXN0ZW5lciAmJiBzY29wZSA9PSBsaXN0ZW5lck9iai5zY29wZSkge1xuXHRcdFx0bGlzdGVuZXJzLnNwbGljZShpLCAxKTtcblx0XHRcdGktLTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIWxpc3RlbmVycy5sZW5ndGgpXG5cdFx0ZGVsZXRlIHRoaXMubGlzdGVuZXJNYXBbZXZlbnRUeXBlXTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBldmVudC5cbiAqIEBtZXRob2QgZGlzcGF0Y2hFdmVudFxuICovXG5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudCAvKiAuLi4gKi8gKSB7XG5cdGlmICghdGhpcy5saXN0ZW5lck1hcClcblx0XHR0aGlzLmxpc3RlbmVyTWFwID0ge307XG5cblx0dmFyIGV2ZW50VHlwZTtcblx0dmFyIGxpc3RlbmVyUGFyYW1zO1xuXG5cdGlmICh0eXBlb2YgZXZlbnQgPT0gXCJzdHJpbmdcIikge1xuXHRcdGV2ZW50VHlwZSA9IGV2ZW50O1xuXHRcdGxpc3RlbmVyUGFyYW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0fSBlbHNlIHtcblx0XHRldmVudFR5cGUgPSBldmVudC50eXBlO1xuXHRcdGV2ZW50LnRhcmdldCA9IHRoaXM7XG5cdFx0bGlzdGVuZXJQYXJhbXMgPSBbZXZlbnRdO1xuXHR9XG5cblx0aWYgKCF0aGlzLmxpc3RlbmVyTWFwLmhhc093blByb3BlcnR5KGV2ZW50VHlwZSkpXG5cdFx0cmV0dXJuO1xuXG5cdGZvciAodmFyIGkgaW4gdGhpcy5saXN0ZW5lck1hcFtldmVudFR5cGVdKSB7XG5cdFx0dmFyIGxpc3RlbmVyT2JqID0gdGhpcy5saXN0ZW5lck1hcFtldmVudFR5cGVdW2ldO1xuXHRcdGxpc3RlbmVyT2JqLmxpc3RlbmVyLmFwcGx5KGxpc3RlbmVyT2JqLnNjb3BlLCBsaXN0ZW5lclBhcmFtcyk7XG5cdH1cbn1cblxuLyoqXG4gKiBKcXVlcnkgc3R5bGUgYWxpYXMgZm9yIGFkZEV2ZW50TGlzdGVuZXJcbiAqIEBtZXRob2Qgb25cbiAqL1xuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcblxuLyoqXG4gKiBKcXVlcnkgc3R5bGUgYWxpYXMgZm9yIHJlbW92ZUV2ZW50TGlzdGVuZXJcbiAqIEBtZXRob2Qgb2ZmXG4gKi9cbkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUub2ZmID0gRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXG4vKipcbiAqIEpxdWVyeSBzdHlsZSBhbGlhcyBmb3IgZGlzcGF0Y2hFdmVudFxuICogQG1ldGhvZCB0cmlnZ2VyXG4gKi9cbkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUudHJpZ2dlciA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudDtcblxuLyoqXG4gKiBNYWtlIHNvbWV0aGluZyBhbiBldmVudCBkaXNwYXRjaGVyLiBDYW4gYmUgdXNlZCBmb3IgbXVsdGlwbGUgaW5oZXJpdGFuY2UuXG4gKiBAbWV0aG9kIGluaXRcbiAqIEBzdGF0aWNcbiAqL1xuRXZlbnREaXNwYXRjaGVyLmluaXQgPSBmdW5jdGlvbihjbHMpIHtcblx0Y2xzLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuXHRjbHMucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cdGNscy5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudDtcblx0Y2xzLnByb3RvdHlwZS5vbiA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUub247XG5cdGNscy5wcm90b3R5cGUub2ZmID0gRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5vZmY7XG5cdGNscy5wcm90b3R5cGUudHJpZ2dlciA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUudHJpZ2dlcjtcbn1cblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gRXZlbnREaXNwYXRjaGVyO1xufVxuXG4vKipcbiAqIEtlZXAgY29udGVudCB3aXRoIGEgbG9naWMgc2l6ZSBpbnNpZGUgYm91bmRhcmllcy5cbiAqIEBjbGFzcyBDb250ZW50U2NhbGVyXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gQ29udGVudFNjYWxlcihjb250ZW50KSB7XG5cdFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKHRoaXMpO1xuXG5cdHRoaXMuY29udGVudFdpZHRoID0gMTAwO1xuXHR0aGlzLmNvbnRlbnRIZWlnaHQgPSAxMDA7XG5cblx0dGhpcy5zY3JlZW5XaWR0aCA9IDEwMDtcblx0dGhpcy5zY3JlZW5IZWlnaHQgPSAxMDA7XG5cblx0dGhpcy50aGVNYXNrID0gbnVsbDtcblxuXHRpZiAoY29udGVudClcblx0XHR0aGlzLnNldENvbnRlbnQoY29udGVudCk7XG5cblx0dGhpcy52ZXJ0aWNhbEFsaWduID0gQ29udGVudFNjYWxlci5NSURETEU7XG5cdHRoaXMuaG9yaXpvbnRhbEFsaWduID0gQ29udGVudFNjYWxlci5DRU5URVI7XG5cdHRoaXMuc2NhbGVNb2RlID0gQ29udGVudFNjYWxlci5TSE9XX0FMTDtcblxuXHR0aGlzLm1pblNjYWxlID0gLTE7XG5cdHRoaXMubWF4U2NhbGUgPSAtMTtcblxuXHR0aGlzLm1hc2tDb250ZW50RW5hYmxlZCA9IGZhbHNlO1xuXHR0aGlzLm1hc2tDb2xvciA9IDB4MDAwMDAwO1xufVxuXG5Db250ZW50U2NhbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZSk7XG5Db250ZW50U2NhbGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnRlbnRTY2FsZXI7XG5cbkNvbnRlbnRTY2FsZXIuVE9QID0gXCJ0b3BcIjtcbkNvbnRlbnRTY2FsZXIuTUlERExFID0gXCJtaWRkbGVcIjtcbkNvbnRlbnRTY2FsZXIuQk9UVE9NID0gXCJib3R0b21cIjtcblxuQ29udGVudFNjYWxlci5MRUZUID0gXCJsZWZ0XCI7XG5Db250ZW50U2NhbGVyLkNFTlRFUiA9IFwiY2VudGVyXCI7XG5Db250ZW50U2NhbGVyLlJJR0hUID0gXCJyaWdodFwiO1xuXG5Db250ZW50U2NhbGVyLk5PX0JPUkRFUiA9IFwibm9Cb3JkZXJcIjtcbkNvbnRlbnRTY2FsZXIuTk9fU0NBTEUgPSBcIm5vU2NhbGVcIjtcbkNvbnRlbnRTY2FsZXIuU0hPV19BTEwgPSBcInNob3dBbGxcIjtcblxuLyoqXG4gKiBTaG91bGQgdGhlIGNvbnRlbnQgYmUgbWFza2VkP1xuICogQG1ldGhvZCBzZXRNYXNrQ29udGVudEVuYWJsZWRcbiAqL1xuQ29udGVudFNjYWxlci5wcm90b3R5cGUuc2V0TWFza0NvbnRlbnRFbmFibGVkID0gZnVuY3Rpb24odmFsdWUpIHtcblx0dGhpcy5tYXNrQ29udGVudEVuYWJsZWQgPSB2YWx1ZTtcblx0dGhpcy51cGRhdGVTY2FsZSgpO1xufVxuXG4vKipcbiAqIFNldCBjb2xvciBvZiB0aGUgbWFzay5cbiAqIEBtZXRob2Qgc2V0TWFza0NvbG9yXG4gKi9cbkNvbnRlbnRTY2FsZXIucHJvdG90eXBlLnNldE1hc2tDb2xvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdHRoaXMubWFza0NvbG9yID0gdmFsdWU7XG5cdHRoaXMudXBkYXRlU2NhbGUoKTtcbn1cblxuLyoqXG4gKiBTZXQgbWluaW11bSB2YWx1ZSBmb3Igc2NhbGUuXG4gKiBAbWV0aG9kIHNldE1pblNjYWxlXG4gKi9cbkNvbnRlbnRTY2FsZXIucHJvdG90eXBlLnNldE1pblNjYWxlID0gZnVuY3Rpb24obWluU2NhbGUpIHtcblx0dGhpcy5taW5TY2FsZSA9IG1pblNjYWxlO1xuXHR0aGlzLnVwZGF0ZVNjYWxlKCk7XG59XG5cbi8qKlxuICogU2V0IG1heGltdW0gdmFsdWUgZm9yIHNjYWxlLlxuICogQG1ldGhvZCBzZXRNYXhTY2FsZVxuICovXG5Db250ZW50U2NhbGVyLnByb3RvdHlwZS5zZXRNYXhTY2FsZSA9IGZ1bmN0aW9uKG1heFNjYWxlKSB7XG5cdHRoaXMubWF4U2NhbGUgPSBtYXhTY2FsZTtcblx0dGhpcy51cGRhdGVTY2FsZSgpO1xufVxuXG4vKipcbiAqIFNldCBjb250ZW50IHRvIHVzZS5cbiAqIEBtZXRob2Qgc2V0Q29udGVudFxuICovXG5Db250ZW50U2NhbGVyLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24oY29udGVudCkge1xuXHRpZiAodGhpcy5jb250ZW50KVxuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvbnRlbnQgYWxyZWFkeSBzZXQuXCIpO1xuXG5cdHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG5cdHRoaXMuYWRkQ2hpbGQodGhpcy5jb250ZW50KTtcblxuXHRpZiAodGhpcy50aGVNYXNrKSB7XG5cdFx0dGhpcy5yZW1vdmVDaGlsZCh0aGlzLnRoZU1hc2spO1xuXHRcdHRoaXMudGhlTWFzayA9IG51bGw7XG5cdH1cblxuXHR0aGlzLnRoZU1hc2sgPSBuZXcgUElYSS5HcmFwaGljcygpO1xuXHR0aGlzLmFkZENoaWxkKHRoaXMudGhlTWFzayk7XG5cblx0dGhpcy51cGRhdGVTY2FsZSgpO1xufVxuXG4vKipcbiAqIFNldCBsb2dpYyBzaXplIG9mIHRoZSBjb250ZW50LlxuICogQG1ldGhvZCBzZXRDb250ZW50U2l6ZVxuICovXG5Db250ZW50U2NhbGVyLnByb3RvdHlwZS5zZXRDb250ZW50U2l6ZSA9IGZ1bmN0aW9uKGNvbnRlbnRXaWR0aCwgY29udGVudEhlaWdodCkge1xuXHR0aGlzLmNvbnRlbnRXaWR0aCA9IGNvbnRlbnRXaWR0aDtcblx0dGhpcy5jb250ZW50SGVpZ2h0ID0gY29udGVudEhlaWdodDtcblx0dGhpcy51cGRhdGVTY2FsZSgpO1xufVxuXG4vKipcbiAqIFNldCB0aGUgYWN0dWFsIHNjcmVlbiBzaXplLlxuICogQG1ldGhvZCBzZXRTY3JlZW5TaXplXG4gKi9cbkNvbnRlbnRTY2FsZXIucHJvdG90eXBlLnNldFNjcmVlblNpemUgPSBmdW5jdGlvbihzY3JlZW5XaWR0aCwgc2NyZWVuSGVpZ2h0KSB7XG5cdHRoaXMuc2NyZWVuV2lkdGggPSBzY3JlZW5XaWR0aDtcblx0dGhpcy5zY3JlZW5IZWlnaHQgPSBzY3JlZW5IZWlnaHQ7XG5cdHRoaXMudXBkYXRlU2NhbGUoKTtcbn1cblxuLyoqXG4gKiBTZXQgaG93IHRoZSBjb250ZW50IHNob3VsZCBiZSBhbGlnbmVkIG9uIHRoZSBzY3JlZW4uXG4gKiBAbWV0aG9kIHNldFZlcnRpY2FsQWxpZ25cbiAqL1xuQ29udGVudFNjYWxlci5wcm90b3R5cGUuc2V0VmVydGljYWxBbGlnbiA9IGZ1bmN0aW9uKGFsaWduKSB7XG5cdHRoaXMudmVydGljYWxBbGlnbiA9IGFsaWduO1xuXHR0aGlzLnVwZGF0ZVNjYWxlKCk7XG59XG5cbi8qKlxuICogU2V0IGhvdyB0aGUgY29udGVudCBzaG91bGQgYmUgYWxpZ25lZCBvbiB0aGUgc2NyZWVuLlxuICogQG1ldGhvZCBzZXRIb3Jpem9udGFsQWxpZ25cbiAqL1xuQ29udGVudFNjYWxlci5wcm90b3R5cGUuc2V0SG9yaXpvbnRhbEFsaWduID0gZnVuY3Rpb24oYWxpZ24pIHtcblx0dGhpcy5ob3Jpem9udGFsQWxpZ24gPSBhbGlnbjtcblx0dGhpcy51cGRhdGVTY2FsZSgpO1xufVxuXG4vKipcbiAqIFNldCBzY2FsZSBtb2RlLlxuICogQG1ldGhvZCBzZXRTY2FsZU1vZGVcbiAqL1xuQ29udGVudFNjYWxlci5wcm90b3R5cGUuc2V0U2NhbGVNb2RlID0gZnVuY3Rpb24oc2NhbGVNb2RlKSB7XG5cdHRoaXMuc2NhbGVNb2RlID0gc2NhbGVNb2RlO1xuXHR0aGlzLnVwZGF0ZVNjYWxlKCk7XG59XG5cbi8qKlxuICogVXBkYXRlIHRoZSBzY2FsaW5nLlxuICogQG1ldGhvZCB1cGRhdGVTY2FsZVxuICogQHByaXZhdGVcbiAqL1xuQ29udGVudFNjYWxlci5wcm90b3R5cGUudXBkYXRlU2NhbGUgPSBmdW5jdGlvbigpIHtcblx0dmFyIHNjYWxlO1xuXG5cdGlmICh0aGlzLnNjYWxlTW9kZSA9PSBDb250ZW50U2NhbGVyLk5PX1NDQUxFKSB7XG5cdFx0c2NhbGUgPSAxO1xuXHR9IGVsc2UgaWYgKHRoaXMuc2NhbGVNb2RlID09IENvbnRlbnRTY2FsZXIuTk9fQk9SREVSKSB7XG5cdFx0aWYgKHRoaXMuc2NyZWVuV2lkdGggLyB0aGlzLmNvbnRlbnRXaWR0aCA+IHRoaXMuc2NyZWVuSGVpZ2h0IC8gdGhpcy5jb250ZW50SGVpZ2h0KVxuXHRcdFx0c2NhbGUgPSB0aGlzLnNjcmVlbldpZHRoIC8gdGhpcy5jb250ZW50V2lkdGg7XG5cblx0XHRlbHNlXG5cdFx0XHRzY2FsZSA9IHRoaXMuc2NyZWVuSGVpZ2h0IC8gdGhpcy5jb250ZW50SGVpZ2h0O1xuXHR9IGVsc2Uge1xuXHRcdGlmICh0aGlzLnNjcmVlbldpZHRoIC8gdGhpcy5jb250ZW50V2lkdGggPCB0aGlzLnNjcmVlbkhlaWdodCAvIHRoaXMuY29udGVudEhlaWdodClcblx0XHRcdHNjYWxlID0gdGhpcy5zY3JlZW5XaWR0aCAvIHRoaXMuY29udGVudFdpZHRoO1xuXG5cdFx0ZWxzZVxuXHRcdFx0c2NhbGUgPSB0aGlzLnNjcmVlbkhlaWdodCAvIHRoaXMuY29udGVudEhlaWdodDtcblx0fVxuXG5cdGlmICh0aGlzLm1pblNjYWxlID4gMCAmJiBzY2FsZSA8IHRoaXMubWluU2NhbGUpXG5cdFx0c2NhbGUgPSB0aGlzLm1pblNjYWxlO1xuXG5cdGlmICh0aGlzLm1heFNjYWxlID4gMCAmJiBzY2FsZSA+IHRoaXMubWF4U2NhbGUpXG5cdFx0c2NhbGUgPSB0aGlzLm1heFNjYWxlO1xuXG5cdHRoaXMuY29udGVudC5zY2FsZS54ID0gc2NhbGU7XG5cdHRoaXMuY29udGVudC5zY2FsZS55ID0gc2NhbGU7XG5cblx0dmFyIHNjYWxlZFdpZHRoID0gdGhpcy5jb250ZW50V2lkdGggKiBzY2FsZTtcblx0dmFyIHNjYWxlZEhlaWdodCA9IHRoaXMuY29udGVudEhlaWdodCAqIHNjYWxlO1xuXG5cdHRoaXMuY29udGVudC5wb3NpdGlvbi54ID0gKHRoaXMuc2NyZWVuV2lkdGggLSBzY2FsZWRXaWR0aCkgLyAyO1xuXG5cdGlmICh0aGlzLnZlcnRpY2FsQWxpZ24gPT0gQ29udGVudFNjYWxlci5UT1ApXG5cdFx0dGhpcy5jb250ZW50LnBvc2l0aW9uLnkgPSAwO1xuXG5cdGVsc2UgaWYgKHRoaXMudmVydGljYWxBbGlnbiA9PSBDb250ZW50U2NhbGVyLkJPVFRPTSlcblx0XHR0aGlzLmNvbnRlbnQucG9zaXRpb24ueSA9IHRoaXMuc2NyZWVuSGVpZ2h0IC0gc2NhbGVkSGVpZ2h0O1xuXG5cdGVsc2Vcblx0XHR0aGlzLmNvbnRlbnQucG9zaXRpb24ueSA9ICh0aGlzLnNjcmVlbkhlaWdodCAtIHNjYWxlZEhlaWdodCkgLyAyO1xuXG5cdGlmICh0aGlzLmhvcml6b250YWxBbGlnbiA9PSBDb250ZW50U2NhbGVyLkxFRlQpXG5cdFx0dGhpcy5jb250ZW50LnBvc2l0aW9uLnggPSAwO1xuXG5cdGVsc2UgaWYgKHRoaXMuaG9yaXpvbnRhbEFsaWduID09IENvbnRlbnRTY2FsZXIuUklHSFQpXG5cdFx0dGhpcy5jb250ZW50LnBvc2l0aW9uLnggPSB0aGlzLnNjcmVlbldpZHRoIC0gc2NhbGVkV2lkdGg7XG5cblx0ZWxzZVxuXHRcdHRoaXMuY29udGVudC5wb3NpdGlvbi54ID0gKHRoaXMuc2NyZWVuV2lkdGggLSBzY2FsZWRXaWR0aCkgLyAyO1xuXG5cdHZhciByID0gbmV3IFBJWEkuUmVjdGFuZ2xlKHRoaXMuY29udGVudC5wb3NpdGlvbi54LCB0aGlzLmNvbnRlbnQucG9zaXRpb24ueSwgc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodCk7XG5cdHZhciByaWdodCA9IHIueCArIHIud2lkdGg7XG5cdHZhciBib3R0b20gPSByLnkgKyByLmhlaWdodDtcblxuXHR0aGlzLnRoZU1hc2suY2xlYXIoKTtcblxuXHRpZiAodGhpcy5tYXNrQ29udGVudEVuYWJsZWQpIHtcblx0XHR0aGlzLnRoZU1hc2suYmVnaW5GaWxsKHRoaXMubWFza0NvbG9yLCAxKTtcblx0XHR0aGlzLnRoZU1hc2suZHJhd1JlY3QoMCwgMCwgdGhpcy5zY3JlZW5XaWR0aCwgci55KTtcblx0XHR0aGlzLnRoZU1hc2suZHJhd1JlY3QoMCwgMCwgci54LCB0aGlzLnNjcmVlbkhlaWdodCk7XG5cdFx0dGhpcy50aGVNYXNrLmRyYXdSZWN0KHJpZ2h0LCAwLCB0aGlzLnNjcmVlbldpZHRoIC0gcmlnaHQsIHRoaXMuc2NyZWVuSGVpZ2h0KTtcblx0XHR0aGlzLnRoZU1hc2suZHJhd1JlY3QoMCwgYm90dG9tLCB0aGlzLnNjcmVlbldpZHRoLCB0aGlzLnNjcmVlbkhlaWdodCAtIGJvdHRvbSk7XG5cdFx0dGhpcy50aGVNYXNrLmVuZEZpbGwoKTtcblx0fVxufVxuXG4vKipcbiAqIEdldCB2aXNpYmxlIHJlY3RhbmdsZS5cbiAqIEBtZXRob2QgZ2V0VmlzaWJsZVJlY3RcbiAqL1xuQ29udGVudFNjYWxlci5wcm90b3R5cGUuZ2V0VmlzaWJsZVJlY3QgPSBmdW5jdGlvbigpIHtcblx0dmFyIHggPSAtdGhpcy5jb250ZW50LnBvc2l0aW9uLnggLyB0aGlzLmNvbnRlbnQuc2NhbGUueDtcblx0dmFyIHkgPSAtdGhpcy5jb250ZW50LnBvc2l0aW9uLnkgLyB0aGlzLmNvbnRlbnQuc2NhbGUueTtcblxuXHR2YXIgd2lkdGggPSB0aGlzLnNjcmVlbldpZHRoIC8gdGhpcy5jb250ZW50LnNjYWxlLng7XG5cdHZhciBoZWlnaHQgPSB0aGlzLnNjcmVlbkhlaWdodCAvIHRoaXMuY29udGVudC5zY2FsZS55O1xuXHQvLyB0aGlzLmNvbnRlbnQucG9zaXRpb24sIHRoaXMuY29udGVudC5wb3NpdGlvbiwgdGhpcy5zY3JlZW5XaWR0aCwgdGhpcy5zY3JlZW5IZWlnaHRcblxuXHRyZXR1cm4gbmV3IFBJWEkuUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xufVxuLyoqXG4gKiBNYW5hZ2VzIHRoZSBtYWluIGxvb3AgYW5kIHNjYWxpbmcgb2YgYSBQSVhJIGFwcGxpY2F0aW9uLlxuICogVGhlIGludGVuZGVkIHdheSBvZiB1c2luZyB0aGlzIGNsYXNzIGlzIHRvIGV4dGVuZCBpdCwgZm9yIGV4YW1wbGU6XG4gKlxuICogICAgIHZhciBQSVhJID0gcmVxdWlyZShcInBpeGkuanNcIik7XG4gKiAgICAgdmFyIFBpeGlBcHAgPSByZXF1aXJlKFwiUGl4aUFwcFwiKTtcbiAqICAgICB2YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiaW5oZXJpdHNcIik7XG4gKlxuICogICAgIGZ1bmN0aW9uIE15QXBwKCkge1xuICogICAgICAgICBQaXhpQXBwLmNhbGwodGhpcyk7XG4gKlxuICogICAgICAgICB2YXIgdCA9IG5ldyBQSVhJLlRleHQoXCJIZWxsbyBQSVhJLmpzIVwiKTtcbiAqICAgICAgICAgdGhpcy5hZGRDaGlsZCh0KTtcbiAqICAgICB9XG4gKlxuICogICAgIGluaGVyaXRzKE15QXBwLCBQaXhpQXBwKTtcbiAqXG4gKiAgICAgbmV3IE15QXBwKCk7XG4gKiBAY2xhc3MgUGl4aUFwcFxuICovXG5mdW5jdGlvbiBQaXhpQXBwKHdpZHRoLCBoZWlnaHQpIHtcblx0UElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLmNhbGwodGhpcyk7XG5cblx0dGhpcy5fYXBwbGljYXRpb25XaWR0aCA9IHdpZHRoO1xuXHR0aGlzLl9hcHBsaWNhdGlvbkhlaWdodCA9IGhlaWdodDtcblx0dGhpcy5fYmFja2dyb3VuZENvbG9yID0gMHhmZmZmZmY7XG5cblx0c2V0VGltZW91dCh0aGlzLm9uQ2hlY2tSZWFkeVRpbWVvdXQuYmluZCh0aGlzKSwgMCk7XG5cblx0dGhpcy5jb250ZW50U2NhbGVyID0gbmV3IENvbnRlbnRTY2FsZXIodGhpcyk7XG59XG5cblBpeGlBcHAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlKTtcblBpeGlBcHAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGl4aUFwcDtcblxuRXZlbnREaXNwYXRjaGVyLmluaXQoUGl4aUFwcCk7XG5cbi8qKlxuICogRGlzcGF0Y2hlZCBpZiB0aGUgYXBwIGlzIHJlc2l6ZWQuXG4gKiBAZXZlbnQgcmVzaXplXG4gKi9cblxuLyoqXG4gKiBEaXNwYXRjaGVkIGV2ZXJ5IGZyYW1lIGJlZm9yZSByZW5kZXJpbmcuXG4gKiBUaGUgdGltZSBpcyBzZW5kIHRvIHRoZSBsaXN0ZW5pbmcgZnVuY3Rpb24gYXMgcGFyYW1ldGVyLlxuICogQGV2ZW50IGZyYW1lXG4gKi9cblxuUGl4aUFwcC5UT1AgPSBDb250ZW50U2NhbGVyLlRPUDtcblBpeGlBcHAuTUlERExFID0gQ29udGVudFNjYWxlci5NSURETEU7XG5QaXhpQXBwLkJPVFRPTSA9IENvbnRlbnRTY2FsZXIuQk9UVE9NO1xuXG5QaXhpQXBwLkxFRlQgPSBDb250ZW50U2NhbGVyLkxFRlQ7XG5QaXhpQXBwLkNFTlRFUiA9IENvbnRlbnRTY2FsZXIuQ0VOVEVSO1xuUGl4aUFwcC5SSUdIVCA9IENvbnRlbnRTY2FsZXIuUklHSFQ7XG5cblBpeGlBcHAuTk9fQk9SREVSID0gQ29udGVudFNjYWxlci5OT19CT1JERVI7XG5QaXhpQXBwLk5PX1NDQUxFID0gQ29udGVudFNjYWxlci5OT19TQ0FMRTtcblBpeGlBcHAuU0hPV19BTEwgPSBDb250ZW50U2NhbGVyLlNIT1dfQUxMO1xuXG4vKipcbiAqIENoZWNrIGlmIGl0J3MgdGltZSB0byBhdHRhY2ggb3Vyc2VsdmVzLlxuICogQG1ldGhvZCBvbkNoZWNrUmVhZHlUaW1lb3V0XG4gKiBAcHJpdmF0ZVxuICovXG5QaXhpQXBwLnByb3RvdHlwZS5vbkNoZWNrUmVhZHlUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLmF0dGFjaGVkVG9FbGVtZW50KVxuXHRcdHJldHVybjtcblxuXHRpZiAoIWRvY3VtZW50LmJvZHkpIHtcblx0XHRzZXRUaW1lb3V0KHRoaXMub25DaGVja1JlYWR5VGltZW91dC5iaW5kKHRoaXMpLCAwKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR0aGlzLmF0dGFjaFRvRWxlbWVudChkb2N1bWVudC5ib2R5KTtcbn1cblxuLyoqXG4gKiBBdHRhY2ggdG8gYW4gZWxlbWVudCBpbiB0aGUgZG9jdW1lbnQuXG4gKiBJZiB0aGlzIGZ1bmN0aW9uIGlzIG5vdCBjYWxsZWQsIHRoZSBhcHAgd2lsbCBiZSBhdHRhY2hlZFxuICogdG8gZW50aXJlIGJyb3dzZXIgd2luZG93LlxuICogQG1ldGhvZCBhdHRhY2hUb0VsZW1lbnRcbiAqIEBwYXJhbSBlbGVtZW50IHtET01FbGVtZW50fSBUaGUgZWxlbWVudCB0byBhdHRhY2ggdG8uXG4gKi9cblBpeGlBcHAucHJvdG90eXBlLmF0dGFjaFRvRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0aWYgKHRoaXMuYXR0YWNoZWRUb0VsZW1lbnQpXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBhdHRhY2hlZCFcIik7XG5cblx0aWYgKHR5cGVvZiBlbGVtZW50ID09IFwic3RyaW5nXCIpXG5cdFx0ZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnQpO1xuXG5cdGlmICghZWxlbWVudClcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGF0J3Mgbm90IGFuIGVsZW1lbnQhXCIpO1xuXG5cdC8vY29uc29sZS5sb2coXCIqKiBhdHRhY2hpbmcgdG8gZWxlbWVudCwgdz1cIiArIGVsZW1lbnQuY2xpZW50V2lkdGggKyBcIiBoPVwiICsgZWxlbWVudC5jbGllbnRIZWlnaHQpO1xuXG5cdHRoaXMuY29udGFpbmVyRWxlbWVudCA9IGVsZW1lbnQ7XG5cdHRoaXMuYXR0YWNoZWRUb0VsZW1lbnQgPSB0cnVlO1xuXG5cdHZhciB2aWV3O1xuXG5cdGlmIChuYXZpZ2F0b3IuaXNDb2Nvb25KUylcblx0XHR2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyZWVuY2FudmFzJyk7XG5cblx0ZWxzZVxuXHRcdHZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuXHR2aWV3LnN0eWxlLm1hcmdpbiA9IDA7XG5cdHZpZXcuc3R5bGUucGFkZGluZyA9IDA7XG5cblx0aWYgKHRoaXMuY29udGFpbmVyRWxlbWVudCA9PSBkb2N1bWVudC5ib2R5KSB7XG5cdFx0Ly9jb25zb2xlLmxvZyhcInN0eWxlOiBcIiArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5oZWlnaHQpO1xuXG5cdFx0dmlldy5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcblxuXHRcdGRvY3VtZW50LmJvZHkuc3R5bGUubWFyZ2luID0gMDtcblx0XHRkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmcgPSAwO1xuXHRcdGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXG5cdFx0ZG9jdW1lbnQuYm9keS5vbnJlc2l6ZSA9IHRoaXMub25XaW5kb3dSZXNpemUuYmluZCh0aGlzKTtcblx0XHR3aW5kb3cub25yZXNpemUgPSB0aGlzLm9uV2luZG93UmVzaXplLmJpbmQodGhpcyk7XG5cdH1cblxuXHR0aGlzLnJlbmRlcmVyID0gbmV3IFBJWEkuYXV0b0RldGVjdFJlbmRlcmVyKHRoaXMuZ2V0RWxlbWVudFdpZHRoKCksIHRoaXMuZ2V0RWxlbWVudEhlaWdodCgpLCB2aWV3KTtcblx0dGhpcy5jb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMucmVuZGVyZXIudmlldyk7XG5cblx0dGhpcy5zdGFnZSA9IG5ldyBQSVhJLlN0YWdlKHRoaXMuX2JhY2tncm91bmRDb2xvcik7XG5cblx0dGhpcy51cGRhdGVDb250ZW50U2NhbGVyKCk7XG5cdHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy5jb250ZW50U2NhbGVyKTtcblxuXHR0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnN0YWdlKTtcblx0dGhpcy5zaXplRGlydHkgPSBmYWxzZTtcblxuXHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMub25BbmltYXRpb25GcmFtZS5iaW5kKHRoaXMpKTtcblx0dGhpcy50cmlnZ2VyKFwicmVzaXplXCIpO1xuXG5cdC8vY29uc29sZS5sb2coXCJhdHRhY2hlZC4uLlwiKTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgdGhlIGNvbnRlbnQgc2NhbGVyLlxuICogQG1ldGhvZCB1cGRhdGVDb250ZW50U2NhbGVyXG4gKiBAcHJpdmF0ZVxuICovXG5QaXhpQXBwLnByb3RvdHlwZS51cGRhdGVDb250ZW50U2NhbGVyID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuY29udGVudFNjYWxlci5zZXRDb250ZW50U2l6ZSh0aGlzLl9hcHBsaWNhdGlvbldpZHRoLCB0aGlzLl9hcHBsaWNhdGlvbkhlaWdodCk7XG5cdHRoaXMuY29udGVudFNjYWxlci5zZXRTY3JlZW5TaXplKHRoaXMuZ2V0RWxlbWVudFdpZHRoKCksIHRoaXMuZ2V0RWxlbWVudEhlaWdodCgpKTtcbn1cblxuLyoqXG4gKiBBbmltYXRpb24gZnJhbWUuIFJlbmRlciBvdXJzZWxmcy5cbiAqIEBtZXRob2Qgb25BbmltYXRpb25GcmFtZVxuICogQHByaXZhdGVcbiAqL1xuUGl4aUFwcC5wcm90b3R5cGUub25BbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKHRpbWUpIHtcblx0Ly9jb25zb2xlLmxvZyhcInJlbmRlclwiKTtcblxuXHRpZiAodGhpcy5zaXplRGlydHkpIHtcblx0XHR0aGlzLnVwZGF0ZUNvbnRlbnRTY2FsZXIoKTtcblx0XHR0aGlzLnJlbmRlcmVyLnJlc2l6ZSh0aGlzLmdldEVsZW1lbnRXaWR0aCgpLCB0aGlzLmdldEVsZW1lbnRIZWlnaHQoKSk7XG5cdFx0dGhpcy5zaXplRGlydHkgPSBmYWxzZTtcblx0fVxuXG5cdHRoaXMudHJpZ2dlcihcImZyYW1lXCIsIHRpbWUpO1xuXG5cdHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc3RhZ2UpO1xuXHQvL1RXRUVOLnVwZGF0ZSh0aW1lKTtcblxuXHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMub25BbmltYXRpb25GcmFtZS5iaW5kKHRoaXMpKTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgd2luZG93IHJlc2l6ZS5cbiAqIEBtZXRob2Qgb25XaW5kb3dSZXNpemVcbiAqIEBwcml2YXRlXG4gKi9cblBpeGlBcHAucHJvdG90eXBlLm9uV2luZG93UmVzaXplID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuc2l6ZURpcnR5ID0gdHJ1ZTtcblx0dGhpcy50cmlnZ2VyKFwicmVzaXplXCIpO1xufVxuXG4vKipcbiAqIEdldCBoZWlnaHQgb2YgdGhlIGVsZW1lbnQgdGhhdCB3ZSBhcmUgYXR0YWNoZWQgdG8uXG4gKiBAbWV0aG9kIGdldEVsZW1lbnRIZWlnaHRcbiAqIEBwcml2YXRlXG4gKi9cblBpeGlBcHAucHJvdG90eXBlLmdldEVsZW1lbnRIZWlnaHQgPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuY29udGFpbmVyRWxlbWVudCA9PSBkb2N1bWVudC5ib2R5KVxuXHRcdHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cblx0cmV0dXJuIHRoaXMuY29udGFpbmVyRWxlbWVudC5jbGllbnRIZWlnaHQ7XG59XG5cbi8qKlxuICogR2V0IGhlaWdodCBvZiB0aGUgZWxlbWVudCB0aGF0IHdlIGFyZSBhdHRhY2hlZCB0by5cbiAqIEBtZXRob2QgZ2V0RWxlbWVudFdpZHRoXG4gKiBAcHJpdmF0ZVxuICovXG5QaXhpQXBwLnByb3RvdHlwZS5nZXRFbGVtZW50V2lkdGggPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuY29udGFpbmVyRWxlbWVudCA9PSBkb2N1bWVudC5ib2R5KVxuXHRcdHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aDtcblxuXHRyZXR1cm4gdGhpcy5jb250YWluZXJFbGVtZW50LmNsaWVudFdpZHRoO1xufVxuXG4vKipcbiAqIFRoZSBsb2dpYyB3aWR0aCBvZiB0aGUgYXBwbGljYXRpb24uXG4gKiBAcHJvcGVydHkgYXBwbGljYXRpb25XaWR0aFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGl4aUFwcC5wcm90b3R5cGUsICdhcHBsaWNhdGlvbldpZHRoJywge1xuXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hcHBsaWNhdGlvbldpZHRoO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dGhpcy5fYXBwbGljYXRpb25XaWR0aCA9IHZhbHVlO1xuXHRcdHRoaXMuc2l6ZURpcnR5ID0gdHJ1ZTtcblx0fVxufSk7XG5cbi8qKlxuICogVGhlIGxvZ2ljIGhlaWdodCBvZiB0aGUgYXBwbGljYXRpb24uXG4gKiBAcHJvcGVydHkgYXBwbGljYXRpb25IZWlnaHRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBpeGlBcHAucHJvdG90eXBlLCAnYXBwbGljYXRpb25IZWlnaHQnLCB7XG5cdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FwcGxpY2F0aW9uSGVpZ2h0O1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dGhpcy5fYXBwbGljYXRpb25IZWlnaHQgPSB2YWx1ZTtcblx0XHR0aGlzLnNpemVEaXJ0eSA9IHRydWU7XG5cdH1cbn0pO1xuXG4vKipcbiAqIEhvdyB0aGUgYXBwbGljYXRpb24gc2hvdWxkIGJlIHZlcnRpY2FsbHkgYWxpZ25lZCBpbiB0aGUgd2luZG93LlxuICogQHByb3BlcnR5IHZlcnRpY2FsQWxpZ25cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBpeGlBcHAucHJvdG90eXBlLCBcInZlcnRpY2FsQWxpZ25cIiwge1xuXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRlbnRTY2FsZXIudmVydGljYWxBbGlnbjtcblx0fSxcblx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHRoaXMuY29udGVudFNjYWxlci5zZXRWZXJ0aWNhbEFsaWduKHZhbHVlKVxuXHR9XG59KTtcblxuLyoqXG4gKiBIb3cgdGhlIGFwcGxpY2F0aW9uIHNob3VsZCBiZSBob3Jpem9udGFsbHkgYWxpZ25lZCBpbiB0aGUgd2luZG93LlxuICogQHByb3BlcnR5IGhvcml6b250YWxBbGlnblxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGl4aUFwcC5wcm90b3R5cGUsIFwiaG9yaXpvbnRhbEFsaWduXCIsIHtcblx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZW50U2NhbGVyLmhvcml6b250YWxBbGlnbjtcblx0fSxcblx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHRoaXMuY29udGVudFNjYWxlci5zZXRIb3Jpem9udGFsQWxpZ24odmFsdWUpXG5cdH1cbn0pO1xuXG4vKipcbiAqIEhvdyBzaG91bGQgdGhlIGFwcGxpY2F0aW9uIGJlIHNjYWxlZCB0byBmaXQgdGhlIHdpbmRvdz9cbiAqIEF2YWlsYWJsZSB2YXVlcyBhcmU6XG4gKiA8dWw+XG4gKiAgIDxsaT5cbiAqICAgICBgUGl4aUFwcC5TSE9XX0FMTGAgLSBFbnN1cmUgdGhhdCB0aGUgd2hvbGUgYXBwbGljYXRpb24gYXMgZGVmaW5lZCBieVxuICogICAgIGBhcHBsaWNhdGlvbldpZHRoYCBhbmQgYGFwcGxpY2F0aW9uSGVpZ2h0YCBpcyB2aXNpYmxlIG9uIHRoZSBzY3JlZW4uXG4gKiAgIDwvbGk+XG4gKiAgIDxsaT5cbiAqICAgICBgUGl4aUFwcC5OT19CT1JERVJgIC0gU2hvdyBhcyBtdWNoIGFzIHBvc3NpYmxlIG9mIHRoZSBhcHBsaWNhdGlvbixcbiAqICAgICBidXQgc2NhbGUgaXQgc28gdGhhdCB0aGVyZSB3aWxsIGJlIG5vIGJvcmRlci5cbiAqICAgPC9saT5cbiAqICAgPGxpPlxuICogICAgIGBQaXhpQXBwLk5PX1NDQUxFYCAtIERvbid0IHNjYWxlIHRoZSBhcHBsaWNhdGlvbiBhdCBhbGwuXG4gKiAgIDwvbGk+XG4gKiA8L3VsPlxuICogQHByb3BlcnR5IHNjYWxlTW9kZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGl4aUFwcC5wcm90b3R5cGUsIFwic2NhbGVNb2RlXCIsIHtcblx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZW50U2NhbGVyLnNjYWxlTW9kZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHRoaXMuY29udGVudFNjYWxlci5zZXRTY2FsZU1vZGUodmFsdWUpXG5cdH1cbn0pO1xuXG4vKipcbiAqIEdldCBvciBzZXQgdGhlIG1pbmltdW0gYWxsb3dlZCBzY2FsZSB2YWx1ZS5cbiAqIEBwcm9wZXJ0eSBtaW5TY2FsZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGl4aUFwcC5wcm90b3R5cGUsIFwibWluU2NhbGVcIiwge1xuXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRlbnRTY2FsZXIubWluU2NhbGU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzLmNvbnRlbnRTY2FsZXIuc2V0TWluU2NhbGUodmFsdWUpXG5cdH1cbn0pO1xuXG4vKipcbiAqIEdldCBvciBzZXQgdGhlIG1heGltdW0gYWxsb3dlZCBzY2FsZSB2YWx1ZS5cbiAqIEBwcm9wZXJ0eSBtaW5TY2FsZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGl4aUFwcC5wcm90b3R5cGUsIFwibWF4U2NhbGVcIiwge1xuXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRlbnRTY2FsZXIubWF4U2NhbGU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzLmNvbnRlbnRTY2FsZXIuc2V0TWF4U2NhbGUodmFsdWUpXG5cdH1cbn0pO1xuXG4vKipcbiAqIFNob3VsZCB0aGVyZSBiZSBhIGxldHRlcmJveCBtYXR0ZSBhcm91bmQgdGhlIGNvbnRlbnQ/IEkuZS5cbiAqIHNob3VsZCB0aGUgY29udGVudCBvdXRzaWRlIHRoZSBhcHBsaWNhdGlvbiBhcmVhIGJlIG1hc2tlZFxuICogYXdheT9cbiAqIEBwcm9wZXJ0eSBtYXR0ZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGl4aUFwcC5wcm90b3R5cGUsIFwibWF0dGVcIiwge1xuXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRlbnRTY2FsZXIubWFza0NvbnRlbnRFbmFibGVkXG5cdH0sXG5cdHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzLmNvbnRlbnRTY2FsZXIuc2V0TWFza0NvbnRlbnRFbmFibGVkKHZhbHVlKTtcblx0fVxufSk7XG5cbi8qKlxuICogVGhlIGNvbG9yIG9mIHRoZSBsZXR0ZXJib3ggbWF0dGUuIFRoaXMgaGFzIGVmZmVjdCBvbmx5IGlmIHRoZSBcbiAqIGxldHRlciBib3ggbWF0dGUgaXMgZW5hYmxlZCB1c2luZyB0aGUgbWF0dGUgcHJvcGVydHkuXG4gKiBAcHJvcGVydHkgbWF0dGVDb2xvclxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGl4aUFwcC5wcm90b3R5cGUsIFwibWF0dGVDb2xvclwiLCB7XG5cdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udGVudFNjYWxlci5tYXNrQ29sb3I7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzLmNvbnRlbnRTY2FsZXIuc2V0TWFza0NvbG9yKHZhbHVlKTtcblx0fVxufSk7XG5cbi8qKlxuICogR2V0cyB0aGUgcmVjdGFuZ2xlIG9uIHRoZSBzY3JlZW4gdGhhdCBpcyBjdXJyZW50bHkgdmlzaWJsZS5cbiAqIFRoZSByZWN0YW5nbGUgaXMgcmVwcmVzZW50ZWQgaW4gYXBwbGljYXRpb24gY29vcmRpbmF0ZXMuXG4gKiBAcHJvcGVydHkgdmlzaWJsZVJlY3RcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBpeGlBcHAucHJvdG90eXBlLCBcInZpc2libGVSZWN0XCIsIHtcblx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5zaXplRGlydHkpIHtcblx0XHRcdHRoaXMudXBkYXRlQ29udGVudFNjYWxlcigpO1xuXHRcdFx0dGhpcy5yZW5kZXJlci5yZXNpemUodGhpcy5nZXRFbGVtZW50V2lkdGgoKSwgdGhpcy5nZXRFbGVtZW50SGVpZ2h0KCkpO1xuXHRcdFx0dGhpcy5zaXplRGlydHkgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5jb250ZW50U2NhbGVyLmdldFZpc2libGVSZWN0KCk7XG5cdH0sXG59KTtcblxuLyoqXG4gKiBUaGUgYmFja2dyb3VuZCBjb2xvciBmb3IgdGhlIGFwcGxpY2F0aW9uLlxuICogRGVmYXVsdCBpcyAweGZmZmZmZiwgaS5lLiB3aGl0ZS5cbiAqIEBwcm9wZXJ0eSBiYWNrZ3JvdW5kQ29sb3JcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBpeGlBcHAucHJvdG90eXBlLCBcImJhY2tncm91bmRDb2xvclwiLCB7XG5cdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2JhY2tncm91bmRDb2xvcjtcblx0fSxcblx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHRoaXMuX2JhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuXHRcdGlmICh0aGlzLnN0YWdlKVxuXHRcdFx0dGhpcy5zdGFnZS5zZXRCYWNrZ3JvdW5kQ29sb3IodGhpcy5fYmFja2dyb3VuZENvbG9yKTtcblx0fVxufSk7XG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBQaXhpQXBwO1xufSBlbHNlIHtcblx0d2luZG93LlBpeGlBcHAgPSBQaXhpQXBwO1xufVxuXG59KS5jYWxsKHRoaXMpOyIsIi8qKlxuICogQSBzdWJzZXQgb2YgUHJvbWlzZXMvQSsuXG4gKiBAY2xhc3MgVGhlbmFibGVcbiAqL1xuZnVuY3Rpb24gVGhlbmFibGUoKSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBUaGVuYWJsZSkpXG5cdFx0cmV0dXJuIG5ldyBUaGVuYWJsZSgpO1xuXG5cdHRoaXMuZGVjaWRlZCA9IGZhbHNlO1xuXHR0aGlzLmhhbmRsZXJzVXNlZCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZW4uXG4gKiBAbWV0aG9kIHJlc29sdmVcbiAqL1xuVGhlbmFibGUucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihyZXNvbHV0aW9uSGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuXHRpZiAodGhpcy5oYW5kbGVyc1VzZWQpXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSGFuZGxlcnMgYWxyZWFkeSByZWdpc3RlcmVkIG9yIGNhbGxlZC5cIik7XG5cblx0dGhpcy5oYW5kbGVyc1VzZWQgPSB0cnVlO1xuXHR0aGlzLnJlc29sdXRpb25IYW5kbGVyID0gcmVzb2x1dGlvbkhhbmRsZXI7XG5cdHRoaXMucmVqZWN0aW9uSGFuZGxlciA9IHJlamVjdGlvbkhhbmRsZXI7XG59XG5cbi8qKlxuICogUmVzb2x2ZS5cbiAqIEBtZXRob2QgcmVzb2x2ZVxuICovXG5UaGVuYWJsZS5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuXHRpZiAodGhpcy5kZWNpZGVkKVxuXHRcdHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgZGVjaWRlZC5cIik7XG5cblx0dGhpcy5kZWNpZGVkID0gdHJ1ZTtcblx0cHJvY2Vzcy5uZXh0VGljayh0aGlzLmNhbGxIYW5kbGVyLmJpbmQodGhpcywgdHJ1ZSwgcmVzdWx0KSk7XG59XG5cbi8qKlxuICogUmVqZWN0LlxuICogQG1ldGhvZCByZXNvbHZlXG4gKi9cblRoZW5hYmxlLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbihyZWFzb24pIHtcblx0aWYgKHRoaXMuZGVjaWRlZClcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IGRlY2lkZWQuXCIpO1xuXG5cdHRoaXMuZGVjaWRlZCA9IHRydWU7XG5cdHByb2Nlc3MubmV4dFRpY2sodGhpcy5jYWxsSGFuZGxlci5iaW5kKHRoaXMsIGZhbHNlLCByZWFzb24pKTtcbn1cblxuLyoqXG4gKiBDYWxsIGhhbmRsZXIuXG4gKiBAbWV0aG9kIGNhbGxIYW5kbGVyXG4gKiBAcHJpdmF0ZVxuICovXG5UaGVuYWJsZS5wcm90b3R5cGUuY2FsbEhhbmRsZXIgPSBmdW5jdGlvbihyZXNvbHZlZCwgcGFyYW1ldGVyKSB7XG5cdHRoaXMuaGFuZGxlcnNVc2VkID0gdHJ1ZTtcblxuXHR2YXIgaGFuZGxlcjtcblxuXHRpZiAocmVzb2x2ZWQpXG5cdFx0aGFuZGxlciA9IHRoaXMucmVzb2x1dGlvbkhhbmRsZXI7XG5cblx0ZWxzZVxuXHRcdGhhbmRsZXIgPSB0aGlzLnJlamVjdGlvbkhhbmRsZXI7XG5cblx0Ly9jb25zb2xlLmxvZyhcImluIGNhbGxIYW5kbGVyLCBoYW5kbGVyPVwiICsgaGFuZGxlcik7XG5cblx0aWYgKGhhbmRsZXIpIHtcblx0XHR0cnkge1xuXHRcdFx0aGFuZGxlcihwYXJhbWV0ZXIpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJVbmhhbmRsZWQ6IFwiICsgZSk7XG5cdFx0XHRjb25zb2xlLmxvZyhlLnN0YWNrKTtcblx0XHRcdHRocm93IGU7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogUmV0dXJuIGEgcmVzb2x2ZWQgdGhlbmFibGUuXG4gKiBAbWV0aG9kIHJlc29sdmVkXG4gKi9cblRoZW5hYmxlLnJlc29sdmVkID0gZnVuY3Rpb24ocGFyYW1ldGVyKSB7XG5cdHZhciB0ID0gbmV3IFRoZW5hYmxlKCk7XG5cdHQucmVzb2x2ZShwYXJhbWV0ZXIpO1xuXHRyZXR1cm4gdDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSByZWplY3RlZCB0aGVuYWJsZS5cbiAqIEBtZXRob2QgcmVqZWN0ZWRcbiAqL1xuVGhlbmFibGUucmVqZWN0ZWQgPSBmdW5jdGlvbihwYXJhbWV0ZXIpIHtcblx0dmFyIHQgPSBuZXcgVGhlbmFibGUoKTtcblx0dC5yZWplY3QocGFyYW1ldGVyKTtcblx0cmV0dXJuIHQ7XG59XG5cbi8qKlxuICogV2FpdCBmb3IgYWxsIHRvIHJlc29sdmUgb3IgYW55IHRvIHJlamVjdC5cbiAqIEBtZXRob2QgYWxsXG4gKi9cblRoZW5hYmxlLmFsbCA9IGZ1bmN0aW9uKCAvKiAuLi4gKi8gKSB7XG5cdHZhciB0aGVuYWJsZSA9IG5ldyBUaGVuYWJsZSgpO1xuXHR2YXIgaTtcblx0dmFyIHRoZW5hYmxlcyA9IFtdO1xuXHR2YXIgZGVjaWRlZCA9IGZhbHNlO1xuXHR2YXIgcmVzb2x2ZWRDb3VudCA9IDA7XG5cblx0Zm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcblx0XHR0aGVuYWJsZXMgPSB0aGVuYWJsZXMuY29uY2F0KGFyZ3VtZW50c1tpXSk7XG5cblx0ZnVuY3Rpb24gb25SZXNvbHZlZCgpIHtcblx0XHRyZXNvbHZlZENvdW50Kys7XG5cblx0XHRpZiAoIWRlY2lkZWQgJiYgcmVzb2x2ZWRDb3VudCA+PSB0aGVuYWJsZXMubGVuZ3RoKSB7XG5cdFx0XHRkZWNpZGVkID0gdHJ1ZTtcblx0XHRcdHRoZW5hYmxlLnJlc29sdmUoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBvblJlamVjdGVkKGUpIHtcblx0XHRpZiAoIWRlY2lkZWQpIHtcblx0XHRcdGRlY2lkZWQgPSB0cnVlO1xuXHRcdFx0dGhlbmFibGUucmVqZWN0KGUpO1xuXHRcdH1cblx0fVxuXG5cdGZvciAoaSA9IDA7IGkgPCB0aGVuYWJsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR0aGVuYWJsZXNbaV0udGhlbihvblJlc29sdmVkLCBvblJlamVjdGVkKTtcblx0fVxuXG5cdHJldHVybiB0aGVuYWJsZTtcbn1cblxuLyoqXG4gKiBXYWl0IGZvciBhbnkgdG8gcmVzb2x2ZSBvciBhbGwgdG8gcmVqZWN0LlxuICogQG1ldGhvZCBhbGxcbiAqL1xuVGhlbmFibGUucmFjZSA9IGZ1bmN0aW9uKCAvKiAuLi4gKi8gKSB7XG5cdHZhciB0aGVuYWJsZSA9IG5ldyBUaGVuYWJsZSgpO1xuXHR2YXIgaTtcblx0dmFyIHRoZW5hYmxlcyA9IFtdO1xuXHR2YXIgZGVjaWRlZCA9IGZhbHNlO1xuXHR2YXIgcmVzb2x2ZWRDb3VudCA9IDA7XG5cblx0Zm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcblx0XHR0aGVuYWJsZXMgPSB0aGVuYWJsZXMuY29uY2F0KGFyZ3VtZW50c1tpXSk7XG5cblx0ZnVuY3Rpb24gb25SZWplY3RlZCgpIHtcblx0XHRyZXNvbHZlZENvdW50Kys7XG5cblx0XHRpZiAoIWRlY2lkZWQgJiYgcmVzb2x2ZWRDb3VudCA+PSB0aGVuYWJsZXMubGVuZ3RoKSB7XG5cdFx0XHRkZWNpZGVkID0gdHJ1ZTtcblx0XHRcdHRoZW5hYmxlLnJlamVjdCgpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG9uUmVzb2x2ZWQocikge1xuXHRcdGlmICghZGVjaWRlZCkge1xuXHRcdFx0ZGVjaWRlZCA9IHRydWU7XG5cdFx0XHR0aGVuYWJsZS5yZXNvbHZlKHIpO1xuXHRcdH1cblx0fVxuXG5cdGZvciAoaSA9IDA7IGkgPCB0aGVuYWJsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR0aGVuYWJsZXNbaV0udGhlbihvblJlc29sdmVkLCBvblJlamVjdGVkKTtcblx0fVxuXG5cdHJldHVybiB0aGVuYWJsZTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSByZXNvbHZlZCBUaGVuYWJsZS5cbiAqIEBtZXRob2QgcmVzb2x2ZWRcbiAqL1xuVGhlbmFibGUucmVzb2x2ZWQgPSBmdW5jdGlvbihyZXN1bHQpIHtcblx0dmFyIHQgPSBuZXcgVGhlbmFibGU7XG5cdHQucmVzb2x2ZShyZXN1bHQpO1xuXG5cdHJldHVybiB0O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJlamVjdGVkIFRoZW5hYmxlLlxuICogQG1ldGhvZCByZWplY3RlZFxuICovXG5UaGVuYWJsZS5yZWplY3RlZCA9IGZ1bmN0aW9uKHJlYXNvbikge1xuXHR2YXIgdCA9IG5ldyBUaGVuYWJsZTtcblx0dC5yZWplY3QocmVhc29uKTtcblxuXHRyZXR1cm4gdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUaGVuYWJsZTsiXX0=
